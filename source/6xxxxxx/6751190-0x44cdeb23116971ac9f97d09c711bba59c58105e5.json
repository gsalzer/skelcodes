{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of 'user permissions'.\r\n */\r\n\r\n/// @title Ownable\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to link contract on an owner\r\n/// @dev Base class\r\ncontract Ownable {\r\n    //Variables\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    //    Modifiers\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newOwner = _newOwner;\r\n\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n\r\n  bool public revocable;\r\n\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _start the time (as Unix time) at which point vesting starts \r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  constructor(\r\n    address _beneficiary,\r\n    uint256 _start,\r\n    uint256 _cliff,\r\n    uint256 _duration,\r\n    bool _revocable\r\n  )\r\n    public\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20Basic token) public {\r\n    uint256 unreleased = releasableAmount(token);\r\n\r\n    require(unreleased > 0);\r\n\r\n    released[token] = released[token].add(unreleased);\r\n\r\n    token.safeTransfer(beneficiary, unreleased);\r\n\r\n    emit Released(unreleased);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function revoke(ERC20Basic token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[token]);\r\n\r\n    uint256 balance = token.balanceOf(this);\r\n\r\n    uint256 unreleased = releasableAmount(token);\r\n    uint256 refund = balance.sub(unreleased);\r\n\r\n    revoked[token] = true;\r\n\r\n    token.safeTransfer(owner, refund);\r\n\r\n    emit Revoked();\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\r\n    return vestedAmount(token).sub(released[token]);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n    uint256 currentBalance = token.balanceOf(this);\r\n    uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n    if (block.timestamp < cliff) {\r\n      return 0;\r\n    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\n/// @title OpenZeppelinERC20\r\n/// @author Applicature\r\n/// @notice Open Zeppelin implementation of standart ERC20\r\n/// @dev Base class\r\ncontract OpenZeppelinERC20 is StandardToken, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public decimals;\r\n    string public name;\r\n    string public symbol;\r\n    string public standard;\r\n\r\n    constructor(\r\n        uint256 _totalSupply,\r\n        string _tokenName,\r\n        uint8 _decimals,\r\n        string _tokenSymbol,\r\n        bool _transferAllSupplyToOwner\r\n    ) public {\r\n        standard = 'ERC20 0.1';\r\n        totalSupply_ = _totalSupply;\r\n\r\n        if (_transferAllSupplyToOwner) {\r\n            balances[msg.sender] = _totalSupply;\r\n        } else {\r\n            balances[this] = _totalSupply;\r\n        }\r\n\r\n        name = _tokenName;\r\n        // Set the name for display purposes\r\n        symbol = _tokenSymbol;\r\n        // Set the symbol for display purposes\r\n        decimals = _decimals;\r\n    }\r\n\r\n}\r\n/// @title MintableToken\r\n/// @author Applicature\r\n/// @notice allow to mint tokens\r\n/// @dev Base class\r\ncontract MintableToken is BasicToken, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public maxSupply;\r\n    bool public allowedMinting;\r\n    mapping(address => bool) public mintingAgents;\r\n    mapping(address => bool) public stateChangeAgents;\r\n\r\n    event Mint(address indexed holder, uint256 tokens);\r\n\r\n    modifier onlyMintingAgents () {\r\n        require(mintingAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyStateChangeAgents () {\r\n        require(stateChangeAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor(uint256 _maxSupply, uint256 _mintedSupply, bool _allowedMinting) public {\r\n        maxSupply = _maxSupply;\r\n        totalSupply_ = totalSupply_.add(_mintedSupply);\r\n        allowedMinting = _allowedMinting;\r\n        mintingAgents[msg.sender] = true;\r\n    }\r\n\r\n    /// @notice allow to mint tokens\r\n    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\r\n        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\r\n\r\n        totalSupply_ = totalSupply_.add(_tokens);\r\n\r\n        balances[_holder] = balances[_holder].add(_tokens);\r\n\r\n        if (totalSupply_ == maxSupply) {\r\n            allowedMinting = false;\r\n        }\r\n        emit Transfer(address(0), _holder, _tokens);\r\n        emit Mint(_holder, _tokens);\r\n    }\r\n\r\n    /// @notice update allowedMinting flat\r\n    function disableMinting() public onlyStateChangeAgents() {\r\n        allowedMinting = false;\r\n    }\r\n\r\n    /// @notice update minting agent\r\n    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\r\n        mintingAgents[_agent] = _status;\r\n    }\r\n\r\n    /// @notice update state change agent\r\n    function updateStateChangeAgent(address _agent, bool _status) public onlyOwner {\r\n        stateChangeAgents[_agent] = _status;\r\n    }\r\n\r\n    /// @return available tokens\r\n    function availableTokens() public view returns (uint256 tokens) {\r\n        return maxSupply.sub(totalSupply_);\r\n    }\r\n}\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n/// @title MintableBurnableToken\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to burn tokens\r\n/// @dev implementation\r\ncontract MintableBurnableToken is MintableToken, BurnableToken {\r\n\r\n    mapping (address => bool) public burnAgents;\r\n\r\n    modifier onlyBurnAgents () {\r\n        require(burnAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _maxSupply,\r\n        uint256 _mintedSupply,\r\n        bool _allowedMinting\r\n    ) public MintableToken(\r\n        _maxSupply,\r\n        _mintedSupply,\r\n        _allowedMinting\r\n    ) {\r\n\r\n    }\r\n\r\n    /// @notice update burn agent\r\n    function updateBurnAgent(address _agent, bool _status) public onlyOwner {\r\n        burnAgents[_agent] = _status;\r\n    }\r\n\r\n    function burnByAgent(address _holder, uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\r\n        if (_tokensToBurn == 0) {\r\n            _tokensToBurn = balances[_holder];\r\n        }\r\n        _burn(_holder, _tokensToBurn);\r\n\r\n        return _tokensToBurn;\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        super._burn(_who, _value);\r\n        maxSupply = maxSupply.sub(_value);\r\n    }\r\n}\r\n/// @title TimeLocked\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to lock contract on a timestamp\r\n/// @dev Base class\r\ncontract TimeLocked {\r\n    uint256 public time;\r\n    mapping(address => bool) public excludedAddresses;\r\n\r\n    modifier isTimeLocked(address _holder, bool _timeLocked) {\r\n        bool locked = (block.timestamp < time);\r\n        require(excludedAddresses[_holder] == true || locked == _timeLocked);\r\n        _;\r\n    }\r\n\r\n    constructor(uint256 _time) public {\r\n        time = _time;\r\n    }\r\n\r\n    function updateExcludedAddress(address _address, bool _status) public;\r\n}\r\n/// @title TimeLockedToken\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to lock contract on a timestamp\r\n/// @dev Base class\r\ncontract TimeLockedToken is TimeLocked, StandardToken {\r\n\r\n    constructor(uint256 _time) public TimeLocked(_time) {}\r\n\r\n    function transfer(address _to, uint256 _tokens) public isTimeLocked(msg.sender, false) returns (bool) {\r\n        return super.transfer(_to, _tokens);\r\n    }\r\n\r\n    function transferFrom(address _holder, address _to, uint256 _tokens)\r\n        public\r\n        isTimeLocked(_holder, false)\r\n        returns (bool)\r\n    {\r\n        return super.transferFrom(_holder, _to, _tokens);\r\n    }\r\n}\r\ncontract ICUToken is OpenZeppelinERC20, MintableBurnableToken, TimeLockedToken {\r\n\r\n    ICUCrowdsale public crowdsale;\r\n\r\n    bool public isSoftCapAchieved;\r\n\r\n    constructor(uint256 _unlockTokensTime)\r\n        public\r\n        OpenZeppelinERC20(0, 'iCumulate', 18, 'ICU', false)\r\n        MintableBurnableToken(4700000000e18, 0, true)\r\n        TimeLockedToken(_unlockTokensTime)\r\n    {}\r\n\r\n    function setUnlockTime(uint256 _unlockTokensTime) public onlyStateChangeAgents {\r\n        time = _unlockTokensTime;\r\n    }\r\n\r\n    function setIsSoftCapAchieved() public onlyStateChangeAgents {\r\n        isSoftCapAchieved = true;\r\n    }\r\n\r\n    function setCrowdSale(address _crowdsale) public onlyOwner {\r\n        require(_crowdsale != address(0));\r\n        crowdsale = ICUCrowdsale(_crowdsale);\r\n    }\r\n\r\n    function updateExcludedAddress(address _address, bool _status) public onlyOwner {\r\n        excludedAddresses[_address] = _status;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokens) public returns (bool) {\r\n        require(true == isTransferAllowed(msg.sender));\r\n        return super.transfer(_to, _tokens);\r\n    }\r\n\r\n    function transferFrom(address _holder, address _to, uint256 _tokens) public returns (bool) {\r\n        require(true == isTransferAllowed(_holder));\r\n        return super.transferFrom(_holder, _to, _tokens);\r\n    }\r\n\r\n    function isTransferAllowed(address _address) public view returns (bool) {\r\n        if (excludedAddresses[_address] == true) {\r\n            return true;\r\n        }\r\n\r\n        if (!isSoftCapAchieved && (address(crowdsale) == address(0) || false == crowdsale.isSoftCapAchieved(0))) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function burnUnsoldTokens(uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\r\n        require(maxSupply.sub(_tokensToBurn) >= totalSupply_);\r\n\r\n        maxSupply = maxSupply.sub(_tokensToBurn);\r\n\r\n        emit Burn(address(0), _tokensToBurn);\r\n\r\n        return _tokensToBurn;\r\n    }\r\n\r\n}\r\n/// @title Agent\r\n/// @author Applicature\r\n/// @notice Contract which takes actions on state change and contribution\r\n/// @dev Base class\r\ncontract Agent {\r\n    using SafeMath for uint256;\r\n\r\n    function isInitialized() public view returns (bool) {\r\n        return false;\r\n    }\r\n}\r\n/// @title CrowdsaleAgent\r\n/// @author Applicature\r\n/// @notice Contract which takes actions on state change and contribution\r\n/// @dev Base class\r\ncontract CrowdsaleAgent is Agent {\r\n\r\n    Crowdsale public crowdsale;\r\n    bool public _isInitialized;\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(msg.sender == address(crowdsale));\r\n        _;\r\n    }\r\n\r\n    constructor(Crowdsale _crowdsale) public {\r\n        crowdsale = _crowdsale;\r\n\r\n        if (address(0) != address(_crowdsale)) {\r\n            _isInitialized = true;\r\n        } else {\r\n            _isInitialized = false;\r\n        }\r\n    }\r\n\r\n    function isInitialized() public view returns (bool) {\r\n        return _isInitialized;\r\n    }\r\n\r\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\r\n        public onlyCrowdsale();\r\n\r\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale();\r\n\r\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned);\r\n}\r\n/// @title MintableCrowdsaleOnSuccessAgent\r\n/// @author Applicature\r\n/// @notice Contract which takes actions on state change and contribution\r\n/// un-pause tokens and disable minting on Crowdsale success\r\n/// @dev implementation\r\ncontract MintableCrowdsaleOnSuccessAgent is CrowdsaleAgent {\r\n\r\n    MintableToken public token;\r\n    bool public _isInitialized;\r\n\r\n    constructor(Crowdsale _crowdsale, MintableToken _token) public CrowdsaleAgent(_crowdsale) {\r\n        token = _token;\r\n\r\n        if (address(0) != address(_token) && address(0) != address(_crowdsale)) {\r\n            _isInitialized = true;\r\n        } else {\r\n            _isInitialized = false;\r\n        }\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public view returns (bool) {\r\n        return _isInitialized;\r\n    }\r\n\r\n    /// @notice Takes actions on contribution\r\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus) public onlyCrowdsale;\r\n\r\n    /// @notice Takes actions on state change,\r\n    /// un-pause tokens and disable minting on Crowdsale success\r\n    /// @param _state Crowdsale.State\r\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale;\r\n}\r\ncontract ICUAgent is MintableCrowdsaleOnSuccessAgent {\r\n\r\n    ICUStrategy public strategy;\r\n    ICUCrowdsale public crowdsale;\r\n\r\n    bool public burnStatus;\r\n\r\n    constructor(\r\n        ICUCrowdsale _crowdsale,\r\n        ICUToken _token,\r\n        ICUStrategy _strategy\r\n    ) public MintableCrowdsaleOnSuccessAgent(_crowdsale, _token) {\r\n        require(address(_strategy) != address(0) && address(_crowdsale) != address(0));\r\n        strategy = _strategy;\r\n        crowdsale = _crowdsale;\r\n    }\r\n\r\n    /// @notice Takes actions on contribution\r\n    function onContribution(\r\n        address,\r\n        uint256 _tierIndex,\r\n        uint256 _tokens,\r\n        uint256 _bonus\r\n    ) public onlyCrowdsale() {\r\n        strategy.updateTierState(_tierIndex, _tokens, _bonus);\r\n    }\r\n\r\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\r\n        ICUToken icuToken = ICUToken(token);\r\n        if (\r\n            icuToken.isSoftCapAchieved() == false\r\n            && (_state == Crowdsale.State.Success || _state == Crowdsale.State.Finalized)\r\n            && crowdsale.isSoftCapAchieved(0)\r\n        ) {\r\n            icuToken.setIsSoftCapAchieved();\r\n        }\r\n\r\n        if (_state > Crowdsale.State.InCrowdsale && burnStatus == false) {\r\n            uint256 unsoldTokensAmount = strategy.getUnsoldTokens();\r\n\r\n            burnStatus = true;\r\n\r\n            icuToken.burnUnsoldTokens(unsoldTokensAmount);\r\n        }\r\n\r\n    }\r\n\r\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\r\n        burned = ICUToken(token).burnByAgent(_contributor, _tokens);\r\n    }\r\n\r\n    function updateLockPeriod(uint256 _time) public {\r\n        require(msg.sender == address(strategy));\r\n        ICUToken(token).setUnlockTime(_time);\r\n    }\r\n\r\n}\r\n/// @title TokenAllocator\r\n/// @author Applicature\r\n/// @notice Contract responsible for defining distribution logic of tokens.\r\n/// @dev Base class\r\ncontract TokenAllocator is Ownable {\r\n\r\n\r\n    mapping(address => bool) public crowdsales;\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(crowdsales[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function addCrowdsales(address _address) public onlyOwner {\r\n        crowdsales[_address] = true;\r\n    }\r\n\r\n    function removeCrowdsales(address _address) public onlyOwner {\r\n        crowdsales[_address] = false;\r\n    }\r\n\r\n    function isInitialized() public view returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\r\n        internalAllocate(_holder, _tokens);\r\n    }\r\n\r\n    function tokensAvailable() public view returns (uint256);\r\n\r\n    function internalAllocate(address _holder, uint256 _tokens) internal onlyCrowdsale();\r\n}\r\n/// @title MintableTokenAllocator\r\n/// @author Applicature\r\n/// @notice Contract responsible for defining distribution logic of tokens.\r\n/// @dev implementation\r\ncontract MintableTokenAllocator is TokenAllocator {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableToken public token;\r\n\r\n    constructor(MintableToken _token) public {\r\n        require(address(0) != address(_token));\r\n        token = _token;\r\n    }\r\n\r\n    /// @notice update instance of MintableToken\r\n    function setToken(MintableToken _token) public onlyOwner {\r\n        token = _token;\r\n    }\r\n\r\n    function internalAllocate(address _holder, uint256 _tokens) internal {\r\n        token.mint(_holder, _tokens);\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public view returns (bool) {\r\n        return token.mintingAgents(this);\r\n    }\r\n\r\n    /// @return available tokens\r\n    function tokensAvailable() public view returns (uint256) {\r\n        return token.availableTokens();\r\n    }\r\n\r\n}\r\n/// @title ContributionForwarder\r\n/// @author Applicature\r\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\r\n/// @dev Base class\r\ncontract ContributionForwarder {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public weiCollected;\r\n    uint256 public weiForwarded;\r\n\r\n    event ContributionForwarded(address receiver, uint256 weiAmount);\r\n\r\n    function isInitialized() public view returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @notice transfer wei to receiver\r\n    function forward() public payable {\r\n        require(msg.value > 0);\r\n\r\n        weiCollected += msg.value;\r\n\r\n        internalForward();\r\n    }\r\n\r\n    function internalForward() internal;\r\n}\r\n/// @title DistributedDirectContributionForwarder\r\n/// @author Applicature\r\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\r\n/// @dev implementation\r\ncontract DistributedDirectContributionForwarder is ContributionForwarder {\r\n    Receiver[] public receivers;\r\n    uint256 public proportionAbsMax;\r\n    bool public isInitialized_;\r\n\r\n    struct Receiver {\r\n        address receiver;\r\n        uint256 proportion; // abslolute value in range of 0 - proportionAbsMax\r\n        uint256 forwardedWei;\r\n    }\r\n\r\n    constructor(uint256 _proportionAbsMax, address[] _receivers, uint256[] _proportions) public {\r\n        proportionAbsMax = _proportionAbsMax;\r\n\r\n        require(_receivers.length == _proportions.length);\r\n\r\n        require(_receivers.length > 0);\r\n\r\n        uint256 totalProportion;\r\n\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            uint256 proportion = _proportions[i];\r\n\r\n            totalProportion = totalProportion.add(proportion);\r\n\r\n            receivers.push(Receiver(_receivers[i], proportion, 0));\r\n        }\r\n\r\n        require(totalProportion == proportionAbsMax);\r\n        isInitialized_ = true;\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public view returns (bool) {\r\n        return isInitialized_;\r\n    }\r\n\r\n    function internalForward() internal {\r\n        uint256 transferred;\r\n\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n            Receiver storage receiver = receivers[i];\r\n\r\n            uint256 value = msg.value.mul(receiver.proportion).div(proportionAbsMax);\r\n\r\n            if (i == receivers.length - 1) {\r\n                value = msg.value.sub(transferred);\r\n            }\r\n\r\n            transferred = transferred.add(value);\r\n\r\n            receiver.receiver.transfer(value);\r\n\r\n            emit ContributionForwarded(receiver.receiver, value);\r\n        }\r\n\r\n        weiForwarded = weiForwarded.add(transferred);\r\n    }\r\n}\r\ncontract Crowdsale {\r\n\r\n    uint256 public tokensSold;\r\n\r\n    enum State {Unknown, Initializing, BeforeCrowdsale, InCrowdsale, Success, Finalized, Refunding}\r\n\r\n    function externalContribution(address _contributor, uint256 _wei) public payable;\r\n\r\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable;\r\n\r\n    function getState() public view returns (State);\r\n\r\n    function updateState() public;\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal;\r\n\r\n}\r\n/// @title Crowdsale\r\n/// @author Applicature\r\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\r\ncontract CrowdsaleImpl is Crowdsale, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    State public currentState;\r\n    TokenAllocator public allocator;\r\n    ContributionForwarder public contributionForwarder;\r\n    PricingStrategy public pricingStrategy;\r\n    CrowdsaleAgent public crowdsaleAgent;\r\n    bool public finalized;\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    bool public allowWhitelisted;\r\n    bool public allowSigned;\r\n    bool public allowAnonymous;\r\n    mapping(address => bool) public whitelisted;\r\n    mapping(address => bool) public signers;\r\n    mapping(address => bool) public externalContributionAgents;\r\n\r\n    event Contribution(address _contributor, uint256 _wei, uint256 _tokensExcludingBonus, uint256 _bonus);\r\n\r\n    constructor(\r\n        TokenAllocator _allocator,\r\n        ContributionForwarder _contributionForwarder,\r\n        PricingStrategy _pricingStrategy,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        bool _allowWhitelisted,\r\n        bool _allowSigned,\r\n        bool _allowAnonymous\r\n    ) public {\r\n        allocator = _allocator;\r\n        contributionForwarder = _contributionForwarder;\r\n        pricingStrategy = _pricingStrategy;\r\n\r\n        startDate = _startDate;\r\n        endDate = _endDate;\r\n\r\n        allowWhitelisted = _allowWhitelisted;\r\n        allowSigned = _allowSigned;\r\n        allowAnonymous = _allowAnonymous;\r\n\r\n        currentState = State.Unknown;\r\n    }\r\n\r\n    /// @notice default payable function\r\n    function() public payable {\r\n        require(allowWhitelisted || allowAnonymous);\r\n\r\n        if (!allowAnonymous) {\r\n            if (allowWhitelisted) {\r\n                require(whitelisted[msg.sender]);\r\n            }\r\n        }\r\n\r\n        internalContribution(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice update crowdsale agent\r\n    function setCrowdsaleAgent(CrowdsaleAgent _crowdsaleAgent) public onlyOwner {\r\n        require(address(_crowdsaleAgent) != address(0));\r\n        crowdsaleAgent = _crowdsaleAgent;\r\n    }\r\n\r\n    /// @notice allows external user to do contribution\r\n    function externalContribution(address _contributor, uint256 _wei) public payable {\r\n        require(externalContributionAgents[msg.sender]);\r\n        internalContribution(_contributor, _wei);\r\n    }\r\n\r\n    /// @notice update external contributor\r\n    function addExternalContributor(address _contributor) public onlyOwner {\r\n        externalContributionAgents[_contributor] = true;\r\n    }\r\n\r\n    /// @notice update external contributor\r\n    function removeExternalContributor(address _contributor) public onlyOwner {\r\n        externalContributionAgents[_contributor] = false;\r\n    }\r\n\r\n    /// @notice update whitelisting address\r\n    function updateWhitelist(address _address, bool _status) public onlyOwner {\r\n        whitelisted[_address] = _status;\r\n    }\r\n\r\n    /// @notice update signer\r\n    function addSigner(address _signer) public onlyOwner {\r\n        signers[_signer] = true;\r\n    }\r\n\r\n    /// @notice update signer\r\n    function removeSigner(address _signer) public onlyOwner {\r\n        signers[_signer] = false;\r\n    }\r\n\r\n    /// @notice allows to do signed contributions\r\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\r\n        address recoveredAddress = verify(msg.sender, _v, _r, _s);\r\n        require(signers[recoveredAddress]);\r\n        internalContribution(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice check sign\r\n    function verify(address _sender, uint8 _v, bytes32 _r, bytes32 _s) public view returns (address) {\r\n        bytes32 hash = keccak256(abi.encodePacked(this, _sender));\r\n\r\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\r\n\r\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\r\n    }\r\n\r\n    /// @return Crowdsale state\r\n    function getState() public view returns (State) {\r\n        if (finalized) {\r\n            return State.Finalized;\r\n        } else if (allocator.isInitialized() == false) {\r\n            return State.Initializing;\r\n        } else if (contributionForwarder.isInitialized() == false) {\r\n            return State.Initializing;\r\n        } else if (pricingStrategy.isInitialized() == false) {\r\n            return State.Initializing;\r\n        } else if (block.timestamp < startDate) {\r\n            return State.BeforeCrowdsale;\r\n        } else if (block.timestamp >= startDate && block.timestamp <= endDate) {\r\n            return State.InCrowdsale;\r\n        } else if (block.timestamp > endDate) {\r\n            return State.Success;\r\n        }\r\n\r\n        return State.Unknown;\r\n    }\r\n\r\n    /// @notice Crowdsale state\r\n    function updateState() public {\r\n        State state = getState();\r\n\r\n        if (currentState != state) {\r\n            if (crowdsaleAgent != address(0)) {\r\n                crowdsaleAgent.onStateChange(state);\r\n            }\r\n\r\n            currentState = state;\r\n        }\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        require(getState() == State.InCrowdsale);\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\r\n\r\n        require(tokens > 0 && tokens <= tokensAvailable);\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        if (msg.value > 0) {\r\n            contributionForwarder.forward.value(msg.value)();\r\n        }\r\n\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n\r\n}\r\n/// @title HardCappedCrowdsale\r\n/// @author Applicature\r\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\r\n/// with hard limit\r\ncontract HardCappedCrowdsale is CrowdsaleImpl {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public hardCap;\r\n\r\n    constructor(\r\n        TokenAllocator _allocator,\r\n        ContributionForwarder _contributionForwarder,\r\n        PricingStrategy _pricingStrategy,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        bool _allowWhitelisted,\r\n        bool _allowSigned,\r\n        bool _allowAnonymous,\r\n        uint256 _hardCap\r\n    ) public CrowdsaleImpl(\r\n        _allocator,\r\n        _contributionForwarder,\r\n        _pricingStrategy,\r\n        _startDate,\r\n        _endDate,\r\n        _allowWhitelisted,\r\n        _allowSigned,\r\n        _allowAnonymous\r\n    ) {\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n    /// @return Crowdsale state\r\n    function getState() public view returns (State) {\r\n        State state = super.getState();\r\n\r\n        if (state == State.InCrowdsale) {\r\n            if (isHardCapAchieved(0)) {\r\n                return State.Success;\r\n            }\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (hardCap <= tokensSold.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        require(getState() == State.InCrowdsale);\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\r\n\r\n        require(tokens <= tokensAvailable && tokens > 0 && false == isHardCapAchieved(tokens.sub(1)));\r\n\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        if (msg.value > 0) {\r\n            contributionForwarder.forward.value(msg.value)();\r\n        }\r\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n}\r\n/// @title RefundableCrowdsale\r\n/// @author Applicature\r\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\r\n/// with hard and soft limits\r\ncontract RefundableCrowdsale is HardCappedCrowdsale {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public softCap;\r\n    mapping(address => uint256) public contributorsWei;\r\n    address[] public contributors;\r\n\r\n    event Refund(address _holder, uint256 _wei, uint256 _tokens);\r\n\r\n    constructor(\r\n        TokenAllocator _allocator,\r\n        ContributionForwarder _contributionForwarder,\r\n        PricingStrategy _pricingStrategy,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        bool _allowWhitelisted,\r\n        bool _allowSigned,\r\n        bool _allowAnonymous,\r\n        uint256 _softCap,\r\n        uint256 _hardCap\r\n\r\n    ) public HardCappedCrowdsale(\r\n        _allocator, _contributionForwarder, _pricingStrategy,\r\n        _startDate, _endDate,\r\n        _allowWhitelisted, _allowSigned, _allowAnonymous, _hardCap\r\n    ) {\r\n        softCap = _softCap;\r\n    }\r\n\r\n    /// @return Crowdsale state\r\n    function getState() public view returns (State) {\r\n        State state = super.getState();\r\n\r\n        if (state == State.Success) {\r\n            if (!isSoftCapAchieved(0)) {\r\n                return State.Refunding;\r\n            }\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (softCap <= tokensSold.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice refund ethers to contributor\r\n    function refund() public {\r\n        internalRefund(msg.sender);\r\n    }\r\n\r\n    /// @notice refund ethers to delegate\r\n    function delegatedRefund(address _address) public {\r\n        internalRefund(_address);\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\r\n\r\n        require(tokens <= tokensAvailable && tokens > 0 && hardCap > tokensSold.add(tokens));\r\n\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        // transfer only if softcap is reached\r\n        if (isSoftCapAchieved(0)) {\r\n            if (msg.value > 0) {\r\n                contributionForwarder.forward.value(address(this).balance)();\r\n            }\r\n        } else {\r\n            // store contributor if it is not stored before\r\n            if (contributorsWei[_contributor] == 0) {\r\n                contributors.push(_contributor);\r\n            }\r\n            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\r\n        }\r\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n\r\n    function internalRefund(address _holder) internal {\r\n        updateState();\r\n        require(block.timestamp > endDate);\r\n        require(!isSoftCapAchieved(0));\r\n        require(crowdsaleAgent != address(0));\r\n\r\n        uint256 value = contributorsWei[_holder];\r\n\r\n        require(value > 0);\r\n\r\n        contributorsWei[_holder] = 0;\r\n        uint256 burnedTokens = crowdsaleAgent.onRefund(_holder, 0);\r\n\r\n        _holder.transfer(value);\r\n\r\n        emit Refund(_holder, value, burnedTokens);\r\n    }\r\n}\r\ncontract ICUCrowdsale is RefundableCrowdsale {\r\n\r\n    uint256 public maxSaleSupply = 2350000000e18;\r\n\r\n    uint256 public availableBonusAmount = 447500000e18;\r\n\r\n    uint256 public usdCollected;\r\n\r\n    mapping(address => uint256) public contributorBonuses;\r\n\r\n    constructor(\r\n        MintableTokenAllocator _allocator,\r\n        DistributedDirectContributionForwarder _contributionForwarder,\r\n        ICUStrategy _pricingStrategy,\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    ) public RefundableCrowdsale(\r\n        _allocator,\r\n        _contributionForwarder,\r\n        _pricingStrategy,\r\n        _startTime,\r\n        _endTime,\r\n        true,\r\n        true,\r\n        false,\r\n        2500000e5, //softCap\r\n        23500000e5//hardCap\r\n    ) {}\r\n\r\n    function updateState() public {\r\n        (startDate, endDate) = ICUStrategy(pricingStrategy).getActualDates();\r\n        super.updateState();\r\n    }\r\n\r\n    function claimBonuses() public {\r\n        require(isSoftCapAchieved(0) && contributorBonuses[msg.sender] > 0);\r\n\r\n        uint256 bonus = contributorBonuses[msg.sender];\r\n        contributorBonuses[msg.sender] = 0;\r\n        allocator.allocate(msg.sender, bonus);\r\n    }\r\n\r\n    function addExternalContributor(address) public onlyOwner {\r\n        require(false);\r\n    }\r\n\r\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (hardCap <= usdCollected.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (softCap <= usdCollected.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        updateState();\r\n        require(currentState == State.InCrowdsale);\r\n\r\n        ICUStrategy pricing = ICUStrategy(pricingStrategy);\r\n        uint256 usdAmount = pricing.getUSDAmount(_wei);\r\n        require(!isHardCapAchieved(usdAmount.sub(1)));\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n        uint256 tierIndex = pricing.getTierIndex();\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricing.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei\r\n        );\r\n\r\n        require(tokens > 0);\r\n        tokensSold = tokensSold.add(tokens);\r\n        allocator.allocate(_contributor, tokensExcludingBonus);\r\n\r\n        if (isSoftCapAchieved(usdAmount)) {\r\n            if (msg.value > 0) {\r\n                contributionForwarder.forward.value(address(this).balance)();\r\n            }\r\n        } else {\r\n            // store contributor if it is not stored before\r\n            if (contributorsWei[_contributor] == 0) {\r\n                contributors.push(_contributor);\r\n            }\r\n            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\r\n        }\r\n\r\n        usdCollected = usdCollected.add(usdAmount);\r\n\r\n        if (availableBonusAmount > 0) {\r\n            if (availableBonusAmount >= bonus) {\r\n                availableBonusAmount -= bonus;\r\n            } else {\r\n                bonus = availableBonusAmount;\r\n                availableBonusAmount = 0;\r\n            }\r\n            contributorBonuses[_contributor] = contributorBonuses[_contributor].add(bonus);\r\n        } else {\r\n            bonus = 0;\r\n        }\r\n\r\n        crowdsaleAgent.onContribution(pricing, tierIndex, tokensExcludingBonus, bonus);\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n\r\n}\r\n/// @title PricingStrategy\r\n/// @author Applicature\r\n/// @notice Contract is responsible for calculating tokens amount depending on different criterias\r\n/// @dev Base class\r\ncontract PricingStrategy {\r\n\r\n    function isInitialized() public view returns (bool);\r\n\r\n    function getTokens(\r\n        address _contributor,\r\n        uint256 _tokensAvailable,\r\n        uint256 _tokensSold,\r\n        uint256 _weiAmount,\r\n        uint256 _collectedWei\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 tokens, uint256 tokensExludingBonus, uint256 bonus);\r\n\r\n    function getWeis(\r\n        uint256 _collectedWei,\r\n        uint256 _tokensSold,\r\n        uint256 _tokens\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 weiAmount, uint256 tokensBonus);\r\n}\r\n/// @title TokenDateCappedTiersPricingStrategy\r\n/// @author Applicature\r\n/// @notice Contract is responsible for calculating tokens amount depending on price in USD\r\n/// @dev implementation\r\ncontract TokenDateCappedTiersPricingStrategy is PricingStrategy, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public etherPriceInUSD;\r\n\r\n    uint256 public capsAmount;\r\n\r\n    struct Tier {\r\n        uint256 tokenInUSD;\r\n        uint256 maxTokensCollected;\r\n        uint256 soldTierTokens;\r\n        uint256 bonusTierTokens;\r\n        uint256 discountPercents;\r\n        uint256 minInvestInUSD;\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        bool unsoldProcessed;\r\n        uint256[] capsData;\r\n    }\r\n\r\n    Tier[] public tiers;\r\n    uint256 public decimals;\r\n\r\n    constructor(\r\n        uint256[] _tiers,\r\n        uint256[] _capsData,\r\n        uint256 _decimals,\r\n        uint256 _etherPriceInUSD\r\n    )\r\n        public\r\n    {\r\n        decimals = _decimals;\r\n        require(_etherPriceInUSD > 0);\r\n        etherPriceInUSD = _etherPriceInUSD;\r\n\r\n        require(_tiers.length % 6 == 0);\r\n        uint256 length = _tiers.length / 6;\r\n\r\n        require(_capsData.length % 2 == 0);\r\n        uint256 lengthCaps = _capsData.length / 2;\r\n\r\n        uint256[] memory emptyArray;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tiers.push(\r\n                Tier(\r\n                    _tiers[i * 6],//tokenInUSD\r\n                    _tiers[i * 6 + 1],//maxTokensCollected\r\n                    0,//soldTierTokens\r\n                    0,//bonusTierTokens\r\n                    _tiers[i * 6 + 2],//discountPercents\r\n                    _tiers[i * 6 + 3],//minInvestInUSD\r\n                    _tiers[i * 6 + 4],//startDate\r\n                    _tiers[i * 6 + 5],//endDate\r\n                    false,\r\n                    emptyArray//capsData\r\n                )\r\n            );\r\n\r\n            for (uint256 j = 0; j < lengthCaps; j++) {\r\n                tiers[i].capsData.push(_capsData[i * lengthCaps + j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @return tier index\r\n    function getTierIndex() public view returns (uint256) {\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            if (\r\n                block.timestamp >= tiers[i].startDate &&\r\n                block.timestamp < tiers[i].endDate &&\r\n                tiers[i].maxTokensCollected > tiers[i].soldTierTokens\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return tiers.length;\r\n    }\r\n\r\n    function getActualTierIndex() public view returns (uint256) {\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            if (\r\n                block.timestamp >= tiers[i].startDate\r\n                && block.timestamp < tiers[i].endDate\r\n                && tiers[i].maxTokensCollected > tiers[i].soldTierTokens\r\n                || block.timestamp < tiers[i].startDate\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return tiers.length.sub(1);\r\n    }\r\n\r\n    /// @return actual dates\r\n    function getActualDates() public view returns (uint256 startDate, uint256 endDate) {\r\n        uint256 tierIndex = getActualTierIndex();\r\n        startDate = tiers[tierIndex].startDate;\r\n        endDate = tiers[tierIndex].endDate;\r\n    }\r\n\r\n    function getTokensWithoutRestrictions(uint256 _weiAmount) public view returns (\r\n        uint256 tokens,\r\n        uint256 tokensExcludingBonus,\r\n        uint256 bonus\r\n    ) {\r\n        if (_weiAmount == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint256 tierIndex = getActualTierIndex();\r\n\r\n        tokensExcludingBonus = _weiAmount.mul(etherPriceInUSD).div(getTokensInUSD(tierIndex));\r\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\r\n        tokens = tokensExcludingBonus.add(bonus);\r\n    }\r\n\r\n    /// @return tokens based on sold tokens and wei amount\r\n    function getTokens(\r\n        address,\r\n        uint256 _tokensAvailable,\r\n        uint256,\r\n        uint256 _weiAmount,\r\n        uint256\r\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\r\n        if (_weiAmount == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint256 tierIndex = getTierIndex();\r\n        if (tierIndex == tiers.length || _weiAmount.mul(etherPriceInUSD).div(1e18) < tiers[tierIndex].minInvestInUSD) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        tokensExcludingBonus = _weiAmount.mul(etherPriceInUSD).div(getTokensInUSD(tierIndex));\r\n\r\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(tokensExcludingBonus)) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\r\n        tokens = tokensExcludingBonus.add(bonus);\r\n\r\n        if (tokens > _tokensAvailable) {\r\n            return (0, 0, 0);\r\n        }\r\n    }\r\n\r\n    /// @return weis based on sold and required tokens\r\n    function getWeis(\r\n        uint256,\r\n        uint256,\r\n        uint256 _tokens\r\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\r\n        if (_tokens == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint256 tierIndex = getTierIndex();\r\n        if (tierIndex == tiers.length) {\r\n            return (0, 0);\r\n        }\r\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(_tokens)) {\r\n            return (0, 0);\r\n        }\r\n        uint256 usdAmount = _tokens.mul(getTokensInUSD(tierIndex)).div(1e18);\r\n        totalWeiAmount = usdAmount.mul(1e18).div(etherPriceInUSD);\r\n\r\n        if (totalWeiAmount < uint256(1 ether).mul(tiers[tierIndex].minInvestInUSD).div(etherPriceInUSD)) {\r\n            return (0, 0);\r\n        }\r\n\r\n        tokensBonus = calculateBonusAmount(tierIndex, _tokens);\r\n    }\r\n\r\n    function calculateBonusAmount(uint256 _tierIndex, uint256 _tokens) public view returns (uint256 bonus) {\r\n        uint256 length = tiers[_tierIndex].capsData.length.div(2);\r\n\r\n        uint256 remainingTokens = _tokens;\r\n        uint256 newSoldTokens = tiers[_tierIndex].soldTierTokens;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (tiers[_tierIndex].capsData[i.mul(2)] == 0) {\r\n                break;\r\n            }\r\n            if (newSoldTokens.add(remainingTokens) <= tiers[_tierIndex].capsData[i.mul(2)]) {\r\n                bonus += remainingTokens.mul(tiers[_tierIndex].capsData[i.mul(2).add(1)]).div(100);\r\n                break;\r\n            } else {\r\n                uint256 diff = tiers[_tierIndex].capsData[i.mul(2)].sub(newSoldTokens);\r\n                remainingTokens -= diff;\r\n                newSoldTokens += diff;\r\n                bonus += diff.mul(tiers[_tierIndex].capsData[i.mul(2).add(1)]).div(100);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTokensInUSD(uint256 _tierIndex) public view returns (uint256) {\r\n        if (_tierIndex < uint256(tiers.length)) {\r\n            return tiers[_tierIndex].tokenInUSD;\r\n        }\r\n    }\r\n\r\n    function getDiscount(uint256 _tierIndex) public view returns (uint256) {\r\n        if (_tierIndex < uint256(tiers.length)) {\r\n            return tiers[_tierIndex].discountPercents;\r\n        }\r\n    }\r\n\r\n    function getMinEtherInvest(uint256 _tierIndex) public view returns (uint256) {\r\n        if (_tierIndex < uint256(tiers.length)) {\r\n            return tiers[_tierIndex].minInvestInUSD.mul(1 ether).div(etherPriceInUSD);\r\n        }\r\n    }\r\n\r\n    function getUSDAmount(uint256 _weiAmount) public view returns (uint256) {\r\n        return _weiAmount.mul(etherPriceInUSD).div(1 ether);\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /// @notice updates tier start/end dates by id\r\n    function updateDates(uint8 _tierId, uint256 _start, uint256 _end) public onlyOwner() {\r\n        if (_start != 0 && _start < _end && _tierId < tiers.length) {\r\n            Tier storage tier = tiers[_tierId];\r\n            tier.startDate = _start;\r\n            tier.endDate = _end;\r\n        }\r\n    }\r\n}\r\ncontract ICUStrategy is TokenDateCappedTiersPricingStrategy {\r\n\r\n    ICUAgent public agent;\r\n\r\n    event UnsoldTokensProcessed(uint256 fromTier, uint256 toTier, uint256 tokensAmount);\r\n\r\n    constructor(\r\n        uint256[] _emptyArray,\r\n        uint256 _etherPriceInUSD\r\n    ) public TokenDateCappedTiersPricingStrategy(\r\n        _emptyArray,\r\n        _emptyArray,\r\n        18,\r\n        _etherPriceInUSD\r\n    ) {\r\n        //Pre-ICO\r\n        tiers.push(\r\n            Tier(\r\n                0.01e5,//tokenInUSD\r\n                1000000000e18,//maxTokensCollected\r\n                0,//soldTierTokens\r\n                0,//bonusTierTokens\r\n                0,//discountPercents\r\n                uint256(20).mul(_etherPriceInUSD),//minInvestInUSD | 20 ethers\r\n                1543579200,//startDate | 2018/11/30 12:00:00 PM UTC\r\n                1544184000,//endDate | 2018/12/07 12:00:00 PM UTC\r\n                false,\r\n                _emptyArray\r\n            )\r\n        );\r\n        //ICO\r\n        tiers.push(\r\n            Tier(\r\n                0.01e5,//tokenInUSD\r\n                1350000000e18,//maxTokensCollected\r\n                0,//soldTierTokens\r\n                0,//bonusTierTokens\r\n                0,//discountPercents\r\n                uint256(_etherPriceInUSD).div(10),//minInvestInUSD | 0.1 ether\r\n                1544443200,//startDate | 2018/12/10\t12:00:00 PM UTC\r\n                1546257600,//endDate | 2018/12/31 12:00:00 PM UTC\r\n                false,\r\n                _emptyArray\r\n            )\r\n        );\r\n\r\n        //Pre-ICO caps data\r\n        tiers[0].capsData.push(1000000000e18);//cap $10,000,000 in tokens\r\n        tiers[0].capsData.push(30);//bonus percents\r\n\r\n        //ICO caps data\r\n        tiers[1].capsData.push(400000000e18);//cap $4,000,000 in tokens\r\n        tiers[1].capsData.push(20);//bonus percents\r\n\r\n        tiers[1].capsData.push(800000000e18);//cap $4,000,000 in tokens\r\n        tiers[1].capsData.push(10);//bonus percents\r\n\r\n        tiers[1].capsData.push(1350000000e18);//cap $5,500,000 in tokens\r\n        tiers[1].capsData.push(5);//bonus percents\r\n\r\n    }\r\n\r\n    function getArrayOfTiers() public view returns (uint256[14] tiersData) {\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            tiersData[j++] = uint256(tiers[i].tokenInUSD);\r\n            tiersData[j++] = uint256(tiers[i].maxTokensCollected);\r\n            tiersData[j++] = uint256(tiers[i].soldTierTokens);\r\n            tiersData[j++] = uint256(tiers[i].discountPercents);\r\n            tiersData[j++] = uint256(tiers[i].minInvestInUSD);\r\n            tiersData[j++] = uint256(tiers[i].startDate);\r\n            tiersData[j++] = uint256(tiers[i].endDate);\r\n        }\r\n    }\r\n\r\n    function updateTier(\r\n        uint256 _tierId,\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _minInvest,\r\n        uint256 _price,\r\n        uint256 _discount,\r\n        uint256[] _capsData,\r\n        bool updateLockNeeded\r\n    ) public onlyOwner() {\r\n        require(\r\n            _start != 0 &&\r\n            _price != 0 &&\r\n            _start < _end &&\r\n            _tierId < tiers.length &&\r\n            _capsData.length > 0 &&\r\n            _capsData.length % 2 == 0\r\n        );\r\n\r\n        if (updateLockNeeded) {\r\n            agent.updateLockPeriod(_end);\r\n        }\r\n\r\n        Tier storage tier = tiers[_tierId];\r\n        tier.tokenInUSD = _price;\r\n        tier.discountPercents = _discount;\r\n        tier.minInvestInUSD = _minInvest;\r\n        tier.startDate = _start;\r\n        tier.endDate = _end;\r\n        tier.capsData = _capsData;\r\n    }\r\n\r\n    function setCrowdsaleAgent(ICUAgent _crowdsaleAgent) public onlyOwner {\r\n        agent = _crowdsaleAgent;\r\n    }\r\n\r\n    function updateTierState(uint256 _tierId, uint256 _soldTokens, uint256 _bonusTokens) public {\r\n        require(\r\n            msg.sender == address(agent) &&\r\n            _tierId < tiers.length &&\r\n            _soldTokens > 0\r\n        );\r\n\r\n        Tier storage tier = tiers[_tierId];\r\n\r\n        if (_tierId > 0 && !tiers[_tierId.sub(1)].unsoldProcessed) {\r\n            Tier storage prevTier = tiers[_tierId.sub(1)];\r\n            prevTier.unsoldProcessed = true;\r\n\r\n            uint256 unsold = prevTier.maxTokensCollected.sub(prevTier.soldTierTokens);\r\n            tier.maxTokensCollected = tier.maxTokensCollected.add(unsold);\r\n            tier.capsData[0] = tier.capsData[0].add(unsold);\r\n\r\n            emit UnsoldTokensProcessed(_tierId.sub(1), _tierId, unsold);\r\n        }\r\n\r\n        tier.soldTierTokens = tier.soldTierTokens.add(_soldTokens);\r\n        tier.bonusTierTokens = tier.bonusTierTokens.add(_bonusTokens);\r\n    }\r\n\r\n    function getTierUnsoldTokens(uint256 _tierId) public view returns (uint256) {\r\n        if (_tierId >= tiers.length || tiers[_tierId].unsoldProcessed) {\r\n            return 0;\r\n        }\r\n\r\n        return tiers[_tierId].maxTokensCollected.sub(tiers[_tierId].soldTierTokens);\r\n    }\r\n\r\n    function getUnsoldTokens() public view returns (uint256 unsoldTokens) {\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            unsoldTokens += getTierUnsoldTokens(i);\r\n        }\r\n    }\r\n\r\n    function getCapsData(uint256 _tierId) public view returns (uint256[]) {\r\n        if (_tierId < tiers.length) {\r\n            return tiers[_tierId].capsData;\r\n        }\r\n    }\r\n\r\n}\r\ncontract Referral is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableTokenAllocator public allocator;\r\n    CrowdsaleImpl public crowdsale;\r\n\r\n    uint256 public constant DECIMALS = 18;\r\n\r\n    uint256 public totalSupply;\r\n    bool public unLimited;\r\n    bool public sentOnce;\r\n\r\n    mapping(address => bool) public claimed;\r\n    mapping(address => uint256) public claimedBalances;\r\n\r\n    constructor(\r\n        uint256 _totalSupply,\r\n        address _allocator,\r\n        address _crowdsale,\r\n        bool _sentOnce\r\n    ) public {\r\n        require(_allocator != address(0) && _crowdsale != address(0));\r\n        totalSupply = _totalSupply;\r\n        if (totalSupply == 0) {\r\n            unLimited = true;\r\n        }\r\n        allocator = MintableTokenAllocator(_allocator);\r\n        crowdsale = CrowdsaleImpl(_crowdsale);\r\n        sentOnce = _sentOnce;\r\n    }\r\n\r\n    function setAllocator(address _allocator) public onlyOwner {\r\n        require(_allocator != address(0));\r\n        allocator = MintableTokenAllocator(_allocator);\r\n    }\r\n\r\n    function setCrowdsale(address _crowdsale) public onlyOwner {\r\n        require(_crowdsale != address(0));\r\n        crowdsale = CrowdsaleImpl(_crowdsale);\r\n    }\r\n\r\n    function multivestMint(\r\n        address _address,\r\n        uint256 _amount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public {\r\n        require(true == crowdsale.signers(verify(msg.sender, _amount, _v, _r, _s)));\r\n        if (true == sentOnce) {\r\n            require(claimed[_address] == false);\r\n            claimed[_address] = true;\r\n        }\r\n        require(\r\n            _address == msg.sender &&\r\n            _amount > 0 &&\r\n            (true == unLimited || _amount <= totalSupply)\r\n        );\r\n        claimedBalances[_address] = claimedBalances[_address].add(_amount);\r\n        if (false == unLimited) {\r\n            totalSupply = totalSupply.sub(_amount);\r\n        }\r\n        allocator.allocate(_address, _amount);\r\n    }\r\n\r\n    /// @notice check sign\r\n    function verify(address _sender, uint256 _amount, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\r\n        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount));\r\n\r\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\r\n\r\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\r\n    }\r\n}\r\ncontract ICUReferral is Referral {\r\n\r\n    constructor(\r\n        address _allocator,\r\n        address _crowdsale\r\n    ) public Referral(35000000e18, _allocator, _crowdsale, true) {}\r\n\r\n    function multivestMint(\r\n        address _address,\r\n        uint256 _amount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public {\r\n        ICUCrowdsale icuCrowdsale = ICUCrowdsale(crowdsale);\r\n        icuCrowdsale.updateState();\r\n        require(icuCrowdsale.isSoftCapAchieved(0) && block.timestamp > icuCrowdsale.endDate());\r\n        super.multivestMint(_address, _amount, _v, _r, _s);\r\n    }\r\n}\r\ncontract Stats {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableToken public token;\r\n    MintableTokenAllocator public allocator;\r\n    ICUCrowdsale public crowdsale;\r\n    ICUStrategy public pricing;\r\n\r\n    constructor(\r\n        MintableToken _token,\r\n        MintableTokenAllocator _allocator,\r\n        ICUCrowdsale _crowdsale,\r\n        ICUStrategy _pricing\r\n    ) public {\r\n        token = _token;\r\n        allocator = _allocator;\r\n        crowdsale = _crowdsale;\r\n        pricing = _pricing;\r\n    }\r\n\r\n    function getTokens(\r\n        uint256,\r\n        uint256 _weiAmount\r\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\r\n        return pricing.getTokensWithoutRestrictions(_weiAmount);\r\n    }\r\n\r\n    function getWeis(\r\n        uint256,\r\n        uint256 _tokenAmount\r\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\r\n        return pricing.getWeis(0, 0, _tokenAmount);\r\n    }\r\n\r\n    function getStats(uint256 _userType, uint256[7] _ethPerCurrency) public view returns (\r\n        uint256[8] stats,\r\n        uint256[26] tiersData,\r\n        uint256[21] currencyContr //tokensPerEachCurrency,\r\n    ) {\r\n        stats = getStatsData(_userType);\r\n        tiersData = getTiersData(_userType);\r\n        currencyContr = getCurrencyContrData(_userType, _ethPerCurrency);\r\n    }\r\n\r\n    function getTiersData(uint256) public view returns (\r\n        uint256[26] tiersData\r\n    ) {\r\n        uint256[14] memory tiers = pricing.getArrayOfTiers();\r\n        uint256 tierElements = tiers.length.div(2);\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i <= tierElements; i += tierElements) {\r\n            tiersData[j++] = uint256(1e23).div(tiers[i]);// tokenInUSD;\r\n            tiersData[j++] = 0;// tokenInWei;\r\n            tiersData[j++] = uint256(tiers[i.add(1)]);// maxTokensCollected;\r\n            tiersData[j++] = uint256(tiers[i.add(2)]);// soldTierTokens;\r\n            tiersData[j++] = 0;// discountPercents;\r\n            tiersData[j++] = 0;// bonusPercents;\r\n            tiersData[j++] = uint256(tiers[i.add(4)]);// minInvestInUSD;\r\n            tiersData[j++] = 0;// minInvestInWei;\r\n            tiersData[j++] = 0;// maxInvestInUSD;\r\n            tiersData[j++] = 0;// maxInvestInWei;\r\n            tiersData[j++] = uint256(tiers[i.add(5)]);// startDate;\r\n            tiersData[j++] = uint256(tiers[i.add(6)]);// endDate;\r\n            tiersData[j++] = 1;\r\n        }\r\n\r\n        tiersData[25] = 2;\r\n    }\r\n\r\n    function getStatsData(uint256 _type) public view returns (\r\n        uint256[8] stats\r\n    ) {\r\n        _type = _type;\r\n        stats[0] = token.maxSupply();\r\n        stats[1] = token.totalSupply();\r\n        stats[2] = crowdsale.maxSaleSupply();\r\n        stats[3] = crowdsale.tokensSold();\r\n        stats[4] = uint256(crowdsale.currentState());\r\n        stats[5] = pricing.getActualTierIndex();\r\n        stats[6] = pricing.getTierUnsoldTokens(stats[5]);\r\n        stats[7] = pricing.getMinEtherInvest(stats[5]);\r\n    }\r\n\r\n    function getCurrencyContrData(uint256 _type, uint256[7] _ethPerCurrency) public view returns (\r\n        uint256[21] currencyContr\r\n    ) {\r\n        _type = _type;\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < _ethPerCurrency.length; i++) {\r\n            (currencyContr[j++], currencyContr[j++], currencyContr[j++]) = pricing.getTokensWithoutRestrictions(\r\n                _ethPerCurrency[i]\r\n            );\r\n        }\r\n    }\r\n\r\n}\r\ncontract PeriodicTokenVesting is TokenVesting {\r\n    address public unreleasedHolder;\r\n    uint256 public periods;\r\n\r\n    constructor(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _periods,\r\n        bool _revocable,\r\n        address _unreleasedHolder\r\n    )\r\n        public TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable)\r\n    {\r\n        require(_revocable == false || _unreleasedHolder != address(0));\r\n        periods = _periods;\r\n        unreleasedHolder = _unreleasedHolder;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the amount that has already vested.\r\n    * @param token ERC20 token which is being vested\r\n    */\r\n    function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n        uint256 currentBalance = token.balanceOf(this);\r\n        uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n        if (now < cliff) {\r\n            return 0;\r\n        } else if (now >= start.add(duration * periods) || revoked[token]) {\r\n            return totalBalance;\r\n        } else {\r\n\r\n            uint256 periodTokens = totalBalance.div(periods);\r\n\r\n            uint256 periodsOver = now.sub(start).div(duration);\r\n\r\n            if (periodsOver >= periods) {\r\n                return totalBalance;\r\n            }\r\n\r\n            return periodTokens.mul(periodsOver);\r\n        }\r\n    }\r\n\r\n    /**\r\n * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n * remain in the contract, the rest are returned to the owner.\r\n * @param token ERC20 token which is being vested\r\n */\r\n    function revoke(ERC20Basic token) public onlyOwner {\r\n        require(revocable);\r\n        require(!revoked[token]);\r\n\r\n        uint256 balance = token.balanceOf(this);\r\n\r\n        uint256 unreleased = releasableAmount(token);\r\n        uint256 refund = balance.sub(unreleased);\r\n\r\n        revoked[token] = true;\r\n\r\n        token.safeTransfer(unreleasedHolder, refund);\r\n\r\n        emit Revoked();\r\n    }\r\n}\r\ncontract ICUAllocation is Ownable {\r\n\r\n    using SafeERC20 for ERC20Basic;\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant BOUNTY_TOKENS = 47000000e18;\r\n    uint256 public constant MAX_TREASURY_TOKENS = 2350000000e18;\r\n\r\n    uint256 public icoEndTime;\r\n\r\n    address[] public vestings;\r\n\r\n    address public bountyAddress;\r\n\r\n    address public treasuryAddress;\r\n\r\n    bool public isBountySent;\r\n\r\n    bool public isTeamSent;\r\n\r\n    event VestingCreated(\r\n        address _vesting,\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _periods,\r\n        bool _revocable\r\n    );\r\n\r\n    event VestingRevoked(address _vesting);\r\n\r\n    constructor(address _bountyAddress, address _treasuryAddress) public {\r\n        require(_bountyAddress != address(0) && _treasuryAddress != address(0));\r\n        bountyAddress = _bountyAddress;\r\n        treasuryAddress = _treasuryAddress;\r\n    }\r\n\r\n    function setICOEndTime(uint256 _icoEndTime) public onlyOwner {\r\n        icoEndTime = _icoEndTime;\r\n    }\r\n\r\n    function allocateBounty(MintableTokenAllocator _allocator, ICUCrowdsale _crowdsale) public onlyOwner {\r\n        require(!isBountySent && icoEndTime < block.timestamp && _crowdsale.isSoftCapAchieved(0));\r\n\r\n        isBountySent = true;\r\n        _allocator.allocate(bountyAddress, BOUNTY_TOKENS);\r\n    }\r\n\r\n    function allocateTreasury(MintableTokenAllocator _allocator) public onlyOwner {\r\n        require(icoEndTime < block.timestamp, 'ICO is not ended');\r\n        require(isBountySent, 'Bounty is not sent');\r\n        require(isTeamSent, 'Team vesting is not created');\r\n        require(MAX_TREASURY_TOKENS >= _allocator.tokensAvailable(), 'Unsold tokens are not burned');\r\n\r\n        _allocator.allocate(treasuryAddress, _allocator.tokensAvailable());\r\n    }\r\n\r\n    function createVesting(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _periods,\r\n        bool _revocable,\r\n        address _unreleasedHolder,\r\n        MintableTokenAllocator _allocator,\r\n        uint256 _amount\r\n    ) public onlyOwner returns (PeriodicTokenVesting) {\r\n        require(icoEndTime > 0 && _amount > 0);\r\n\r\n        isTeamSent = true;\r\n\r\n        PeriodicTokenVesting vesting = new PeriodicTokenVesting(\r\n            _beneficiary, _start, _cliff, _duration, _periods, _revocable, _unreleasedHolder\r\n        );\r\n\r\n        vestings.push(vesting);\r\n\r\n        emit VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\r\n\r\n        _allocator.allocate(address(vesting), _amount);\r\n\r\n        return vesting;\r\n    }\r\n\r\n    function revokeVesting(PeriodicTokenVesting _vesting, ERC20Basic token) public onlyOwner() {\r\n        _vesting.revoke(token);\r\n\r\n        emit VestingRevoked(_vesting);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_tierIndex\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"onContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"updateLockPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"onRefund\",\"outputs\":[{\"name\":\"burned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_isInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"onStateChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_strategy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ICUAgent","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009cb22d847750eaa06de1fb64cc87ce10a9d41b480000000000000000000000008a1c33885cff159d1696b24e8b9be8c1ba8ab37600000000000000000000000095fc99b18eff2ab26679e069437ef3b600fe8bd8","Library":"","SwarmSource":"bzzr://2fa8e3d9b92412b19b064b47f556015df0e6bf1218b8d0ce2172feb87540bb2e"}]}