{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n  Zethr | https://zethr.io\r\n  (c) Copyright 2018 | All Rights Reserved\r\n  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/Libraries/SafeMath.sol\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/Libraries/ZethrTierLibrary.sol\r\n\r\nlibrary ZethrTierLibrary {\r\n  uint constant internal magnitude = 2 ** 64;\r\n\r\n  // Gets the tier (1-7) of the divs sent based off of average dividend rate\r\n  // This is an index used to call into the correct sub-bankroll to withdraw tokens\r\n  function getTier(uint divRate) internal pure returns (uint8) {\r\n\r\n    // Divide the average dividned rate by magnitude\r\n    // Remainder doesn't matter because of the below logic\r\n    uint actualDiv = divRate / magnitude;\r\n    if (actualDiv >= 30) {\r\n      return 6;\r\n    } else if (actualDiv >= 25) {\r\n      return 5;\r\n    } else if (actualDiv >= 20) {\r\n      return 4;\r\n    } else if (actualDiv >= 15) {\r\n      return 3;\r\n    } else if (actualDiv >= 10) {\r\n      return 2;\r\n    } else if (actualDiv >= 5) {\r\n      return 1;\r\n    } else if (actualDiv >= 2) {\r\n      return 0;\r\n    } else {\r\n      // Impossible\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function getDivRate(uint _tier)\r\n  internal pure\r\n  returns (uint8)\r\n  {\r\n    if (_tier == 0) {\r\n      return 2;\r\n    } else if (_tier == 1) {\r\n      return 5;\r\n    } else if (_tier == 2) {\r\n      return 10;\r\n    } else if (_tier == 3) {\r\n      return 15;\r\n    } else if (_tier == 4) {\r\n      return 20;\r\n    } else if (_tier == 5) {\r\n      return 25;\r\n    } else if (_tier == 6) {\r\n      return 33;\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ERC/ERC223Receiving.sol\r\n\r\ncontract ERC223Receiving {\r\n  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\r\n}\r\n\r\n// File: contracts/ZethrMultiSigWallet.sol\r\n\r\n/* Zethr MultisigWallet\r\n *\r\n * Standard multisig wallet\r\n * Holds the bankroll ETH, as well as the bankroll 33% ZTH tokens.\r\n*/ \r\ncontract ZethrMultiSigWallet is ERC223Receiving {\r\n  using SafeMath for uint;\r\n\r\n  /*=================================\r\n  =              EVENTS            =\r\n  =================================*/\r\n\r\n  event Confirmation(address indexed sender, uint indexed transactionId);\r\n  event Revocation(address indexed sender, uint indexed transactionId);\r\n  event Submission(uint indexed transactionId);\r\n  event Execution(uint indexed transactionId);\r\n  event ExecutionFailure(uint indexed transactionId);\r\n  event Deposit(address indexed sender, uint value);\r\n  event OwnerAddition(address indexed owner);\r\n  event OwnerRemoval(address indexed owner);\r\n  event WhiteListAddition(address indexed contractAddress);\r\n  event WhiteListRemoval(address indexed contractAddress);\r\n  event RequirementChange(uint required);\r\n  event BankrollInvest(uint amountReceived);\r\n\r\n  /*=================================\r\n  =             VARIABLES           =\r\n  =================================*/\r\n\r\n  mapping (uint => Transaction) public transactions;\r\n  mapping (uint => mapping (address => bool)) public confirmations;\r\n  mapping (address => bool) public isOwner;\r\n  address[] public owners;\r\n  uint public required;\r\n  uint public transactionCount;\r\n  bool internal reEntered = false;\r\n  uint constant public MAX_OWNER_COUNT = 15;\r\n\r\n  /*=================================\r\n  =         CUSTOM CONSTRUCTS       =\r\n  =================================*/\r\n\r\n  struct Transaction {\r\n    address destination;\r\n    uint value;\r\n    bytes data;\r\n    bool executed;\r\n  }\r\n\r\n  struct TKN {\r\n    address sender;\r\n    uint value;\r\n  }\r\n\r\n  /*=================================\r\n  =            MODIFIERS            =\r\n  =================================*/\r\n\r\n  modifier onlyWallet() {\r\n    if (msg.sender != address(this))\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier isAnOwner() {\r\n    address caller = msg.sender;\r\n    if (isOwner[caller])\r\n      _;\r\n    else\r\n      revert();\r\n  }\r\n\r\n  modifier ownerDoesNotExist(address owner) {\r\n    if (isOwner[owner]) \r\n      revert();\r\n      _;\r\n  }\r\n\r\n  modifier ownerExists(address owner) {\r\n    if (!isOwner[owner])\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier transactionExists(uint transactionId) {\r\n    if (transactions[transactionId].destination == 0)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier confirmed(uint transactionId, address owner) {\r\n    if (!confirmations[transactionId][owner])\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier notConfirmed(uint transactionId, address owner) {\r\n    if (confirmations[transactionId][owner])\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier notExecuted(uint transactionId) {\r\n    if (transactions[transactionId].executed)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier notNull(address _address) {\r\n    if (_address == 0)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier validRequirement(uint ownerCount, uint _required) {\r\n    if ( ownerCount > MAX_OWNER_COUNT\r\n      || _required > ownerCount\r\n      || _required == 0\r\n      || ownerCount == 0)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n\r\n  /*=================================\r\n  =         PUBLIC FUNCTIONS        =\r\n  =================================*/\r\n\r\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n  /// @param _owners List of initial owners.\r\n  /// @param _required Number of required confirmations.\r\n  constructor (address[] _owners, uint _required)\r\n    public\r\n    validRequirement(_owners.length, _required)\r\n  {\r\n    // Add owners\r\n    for (uint i=0; i<_owners.length; i++) {\r\n      if (isOwner[_owners[i]] || _owners[i] == 0)\r\n        revert();\r\n      isOwner[_owners[i]] = true;\r\n    }\r\n\r\n    // Set owners\r\n    owners = _owners;\r\n\r\n    // Set required\r\n    required = _required;\r\n  }\r\n\r\n  /** Testing only.\r\n  function exitAll()\r\n    public\r\n  {\r\n    uint tokenBalance = ZTHTKN.balanceOf(address(this));\r\n    ZTHTKN.sell(tokenBalance - 1e18);\r\n    ZTHTKN.sell(1e18);\r\n    ZTHTKN.withdraw(address(0x0));\r\n  }\r\n  **/\r\n\r\n  /// @dev Fallback function allows Ether to be deposited.\r\n  function()\r\n    public\r\n    payable\r\n  {\r\n\r\n  }\r\n    \r\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n  /// @param owner Address of new owner.\r\n  function addOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerDoesNotExist(owner)\r\n    notNull(owner)\r\n    validRequirement(owners.length + 1, required)\r\n  {\r\n    isOwner[owner] = true;\r\n    owners.push(owner);\r\n    emit OwnerAddition(owner);\r\n  }\r\n\r\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n  /// @param owner Address of owner.\r\n  function removeOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    validRequirement(owners.length, required)\r\n  {\r\n    isOwner[owner] = false;\r\n    for (uint i=0; i<owners.length - 1; i++)\r\n      if (owners[i] == owner) {\r\n        owners[i] = owners[owners.length - 1];\r\n        break;\r\n      }\r\n\r\n    owners.length -= 1;\r\n    if (required > owners.length)\r\n      changeRequirement(owners.length);\r\n    emit OwnerRemoval(owner);\r\n  }\r\n\r\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n  /// @param owner Address of owner to be replaced.\r\n  /// @param owner Address of new owner.\r\n  function replaceOwner(address owner, address newOwner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    ownerDoesNotExist(newOwner)\r\n  {\r\n    for (uint i=0; i<owners.length; i++)\r\n      if (owners[i] == owner) {\r\n        owners[i] = newOwner;\r\n        break;\r\n      }\r\n\r\n    isOwner[owner] = false;\r\n    isOwner[newOwner] = true;\r\n    emit OwnerRemoval(owner);\r\n    emit OwnerAddition(newOwner);\r\n  }\r\n\r\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n  /// @param _required Number of required confirmations.\r\n  function changeRequirement(uint _required)\r\n    public\r\n    onlyWallet\r\n    validRequirement(owners.length, _required)\r\n  {\r\n    required = _required;\r\n    emit RequirementChange(_required);\r\n  }\r\n\r\n  /// @dev Allows an owner to submit and confirm a transaction.\r\n  /// @param destination Transaction target address.\r\n  /// @param value Transaction ether value.\r\n  /// @param data Transaction data payload.\r\n  /// @return Returns transaction ID.\r\n  function submitTransaction(address destination, uint value, bytes data)\r\n    public\r\n    returns (uint transactionId)\r\n  {\r\n    transactionId = addTransaction(destination, value, data);\r\n    confirmTransaction(transactionId);\r\n  }\r\n\r\n  /// @dev Allows an owner to confirm a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n  {\r\n    confirmations[transactionId][msg.sender] = true;\r\n    emit Confirmation(msg.sender, transactionId);\r\n    executeTransaction(transactionId);\r\n  }\r\n\r\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n  {\r\n    confirmations[transactionId][msg.sender] = false;\r\n    emit Revocation(msg.sender, transactionId);\r\n  }\r\n\r\n  /// @dev Allows anyone to execute a confirmed transaction.\r\n  /// @param transactionId Transaction ID.\r\n  function executeTransaction(uint transactionId)\r\n    public\r\n    notExecuted(transactionId)\r\n  {\r\n    if (isConfirmed(transactionId)) {\r\n      Transaction storage txToExecute = transactions[transactionId];\r\n      txToExecute.executed = true;\r\n      if (txToExecute.destination.call.value(txToExecute.value)(txToExecute.data))\r\n        emit Execution(transactionId);\r\n      else {\r\n        emit ExecutionFailure(transactionId);\r\n        txToExecute.executed = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the confirmation status of a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  /// @return Confirmation status.\r\n  function isConfirmed(uint transactionId)\r\n    public\r\n    constant\r\n    returns (bool)\r\n  {\r\n    uint count = 0;\r\n    for (uint i=0; i<owners.length; i++) {\r\n      if (confirmations[transactionId][owners[i]])\r\n        count += 1;\r\n      if (count == required)\r\n        return true;\r\n    }\r\n  }\r\n\r\n  /*=================================\r\n  =        OPERATOR FUNCTIONS       =\r\n  =================================*/\r\n\r\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n  /// @param destination Transaction target address.\r\n  /// @param value Transaction ether value.\r\n  /// @param data Transaction data payload.\r\n  /// @return Returns transaction ID.\r\n  function addTransaction(address destination, uint value, bytes data)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint transactionId)\r\n  {\r\n    transactionId = transactionCount;\r\n\r\n    transactions[transactionId] = Transaction({\r\n        destination: destination,\r\n        value: value,\r\n        data: data,\r\n        executed: false\r\n    });\r\n\r\n    transactionCount += 1;\r\n    emit Submission(transactionId);\r\n  }\r\n\r\n  /*\r\n   * Web3 call functions\r\n   */\r\n  /// @dev Returns number of confirmations of a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  /// @return Number of confirmations.\r\n  function getConfirmationCount(uint transactionId)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n  {\r\n    for (uint i=0; i<owners.length; i++)\r\n      if (confirmations[transactionId][owners[i]])\r\n        count += 1;\r\n  }\r\n\r\n  /// @dev Returns total number of transactions after filers are applied.\r\n  /// @param pending Include pending transactions.\r\n  /// @param executed Include executed transactions.\r\n  /// @return Total number of transactions after filters are applied.\r\n  function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n  {\r\n    for (uint i=0; i<transactionCount; i++)\r\n      if (pending && !transactions[i].executed || executed && transactions[i].executed)\r\n        count += 1;\r\n  }\r\n\r\n  /// @dev Returns list of owners.\r\n  /// @return List of owner addresses.\r\n  function getOwners()\r\n    public\r\n    constant\r\n    returns (address[])\r\n  {\r\n    return owners;\r\n  }\r\n\r\n  /// @dev Returns array with owner addresses, which confirmed transaction.\r\n  /// @param transactionId Transaction ID.\r\n  /// @return Returns array of owner addresses.\r\n  function getConfirmations(uint transactionId)\r\n    public\r\n    constant\r\n    returns (address[] _confirmations)\r\n  {\r\n    address[] memory confirmationsTemp = new address[](owners.length);\r\n    uint count = 0;\r\n    uint i;\r\n    for (i=0; i<owners.length; i++)\r\n      if (confirmations[transactionId][owners[i]]) {\r\n        confirmationsTemp[count] = owners[i];\r\n        count += 1;\r\n      }\r\n\r\n      _confirmations = new address[](count);\r\n\r\n      for (i=0; i<count; i++)\r\n        _confirmations[i] = confirmationsTemp[i];\r\n  }\r\n\r\n  /// @dev Returns list of transaction IDs in defined range.\r\n  /// @param from Index start position of transaction array.\r\n  /// @param to Index end position of transaction array.\r\n  /// @param pending Include pending transactions.\r\n  /// @param executed Include executed transactions.\r\n  /// @return Returns array of transaction IDs.\r\n  function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint[] _transactionIds)\r\n  {\r\n    uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n    uint count = 0;\r\n    uint i;\r\n\r\n    for (i=0; i<transactionCount; i++)\r\n      if (pending && !transactions[i].executed || executed && transactions[i].executed) {\r\n        transactionIdsTemp[count] = i;\r\n        count += 1;\r\n      }\r\n\r\n      _transactionIds = new uint[](to - from);\r\n\r\n    for (i=from; i<to; i++)\r\n      _transactionIds[i - from] = transactionIdsTemp[i];\r\n  }\r\n\r\n  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\r\n  public\r\n  returns (bool)\r\n  {\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/Bankroll/Interfaces/ZethrTokenBankrollInterface.sol\r\n\r\n// Zethr token bankroll function prototypes\r\ncontract ZethrTokenBankrollInterface is ERC223Receiving {\r\n  uint public jackpotBalance;\r\n  \r\n  function getMaxProfit(address) public view returns (uint);\r\n  function gameTokenResolution(uint _toWinnerAmount, address _winnerAddress, uint _toJackpotAmount, address _jackpotAddress, uint _originalBetSize) external;\r\n  function payJackpotToWinner(address _winnerAddress, uint payoutDivisor) public;\r\n}\r\n\r\n// File: contracts/Bankroll/Interfaces/ZethrBankrollControllerInterface.sol\r\n\r\ncontract ZethrBankrollControllerInterface is ERC223Receiving {\r\n  address public jackpotAddress;\r\n\r\n  ZethrTokenBankrollInterface[7] public tokenBankrolls; \r\n  \r\n  ZethrMultiSigWallet public multiSigWallet;\r\n\r\n  mapping(address => bool) public validGameAddresses;\r\n\r\n  function gamePayoutResolver(address _resolver, uint _tokenAmount) public;\r\n\r\n  function isTokenBankroll(address _address) public view returns (bool);\r\n\r\n  function getTokenBankrollAddressFromTier(uint8 _tier) public view returns (address);\r\n\r\n  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\r\n}\r\n\r\n// File: contracts/Bankroll/ZethrGame.sol\r\n\r\n/* Zethr Game Interface\r\n *\r\n * Contains the necessary functions to integrate with\r\n * the Zethr Token bankrolls & the Zethr game ecosystem.\r\n *\r\n * Token Bankroll Functions:\r\n *  - execute\r\n *\r\n * Player Functions:\r\n *  - finish\r\n *\r\n * Bankroll Controller / Owner Functions:\r\n *  - pauseGame\r\n *  - resumeGame\r\n *  - set resolver percentage\r\n *  - set controller address\r\n *\r\n * Player/Token Bankroll Functions:\r\n *  - resolvePendingBets\r\n*/\r\ncontract ZethrGame {\r\n  using SafeMath for uint;\r\n  using SafeMath for uint56;\r\n\r\n  // Default events:\r\n  event Result (address player, uint amountWagered, int amountOffset);\r\n  event Wager (address player, uint amount, bytes data);\r\n\r\n  // Queue of pending/unresolved bets\r\n  address[] pendingBetsQueue;\r\n  uint queueHead = 0;\r\n  uint queueTail = 0;\r\n\r\n  // Store each player's latest bet via mapping\r\n  mapping(address => BetBase) bets;\r\n\r\n  // Bet structures must start with this layout\r\n  struct BetBase {\r\n    // Must contain these in this order\r\n    uint56 tokenValue;    // Multiply by 1e14 to get tokens\r\n    uint48 blockNumber;\r\n    uint8 tier;\r\n    // Game specific structures can add more after this\r\n  }\r\n\r\n  // Mapping of addresses to their *position* in the queue\r\n  // Zero = they aren't in the queue\r\n  mapping(address => uint) pendingBetsMapping;\r\n\r\n  // Holds the bankroll controller info\r\n  ZethrBankrollControllerInterface controller;\r\n\r\n  // Is the game paused?\r\n  bool paused;\r\n\r\n  // Minimum bet should always be >= 1\r\n  uint minBet = 1e18;\r\n\r\n  // Percentage that a resolver gets when he resolves bets for the house\r\n  uint resolverPercentage;\r\n\r\n  // Every game has a name\r\n  string gameName;\r\n\r\n  constructor (address _controllerAddress, uint _resolverPercentage, string _name) public {\r\n    controller = ZethrBankrollControllerInterface(_controllerAddress);\r\n    resolverPercentage = _resolverPercentage;\r\n    gameName = _name;\r\n  }\r\n\r\n  /** @dev Gets the max profit of this game as decided by the token bankroll\r\n    * @return uint The maximum profit\r\n    */\r\n  function getMaxProfit()\r\n  public view\r\n  returns (uint)\r\n  {\r\n    return ZethrTokenBankrollInterface(msg.sender).getMaxProfit(address(this));\r\n  }\r\n\r\n  /** @dev Pauses the game, preventing anyone from placing bets\r\n    */\r\n  function ownerPauseGame()\r\n  public\r\n  ownerOnly\r\n  {\r\n    paused = true;\r\n  }\r\n\r\n  /** @dev Resumes the game, allowing bets\r\n    */\r\n  function ownerResumeGame()\r\n  public\r\n  ownerOnly\r\n  {\r\n    paused = false;\r\n  }\r\n\r\n  /** @dev Sets the percentage of the bets that a resolver gets when resolving tokens.\r\n    * @param _percentage The percentage as x/1,000,000 that the resolver gets\r\n    */\r\n  function ownerSetResolverPercentage(uint _percentage)\r\n  public\r\n  ownerOnly\r\n  {\r\n    require(_percentage <= 1000000);\r\n    resolverPercentage = _percentage;\r\n  }\r\n\r\n  /** @dev Sets the address of the game controller\r\n    * @param _controllerAddress The new address of the controller\r\n    */\r\n  function ownerSetControllerAddress(address _controllerAddress)\r\n  public\r\n  ownerOnly\r\n  {\r\n    controller = ZethrBankrollControllerInterface(_controllerAddress);\r\n  }\r\n\r\n  // Every game should have a name\r\n  /** @dev Sets the name of the game\r\n    * @param _name The name of the game\r\n    */\r\n  function ownerSetGameName(string _name)\r\n  ownerOnly\r\n  public\r\n  {\r\n    gameName = _name;\r\n  }\r\n\r\n  /** @dev Gets the game name\r\n    * @return The name of the game\r\n    */\r\n  function getGameName()\r\n  public view\r\n  returns (string)\r\n  {\r\n    return gameName;\r\n  }\r\n\r\n  /** @dev Resolve expired bets in the queue. Gives a percentage of the house edge to the resolver as ZTH\r\n    * @param _numToResolve The number of bets to resolve.\r\n    * @return tokensEarned The number of tokens earned\r\n    * @return queueHead The new head of the queue\r\n    */\r\n  function resolveExpiredBets(uint _numToResolve)\r\n  public\r\n  returns (uint tokensEarned_, uint queueHead_)\r\n  {\r\n    uint mQueue = queueHead;\r\n    uint head;\r\n    uint tail = (mQueue + _numToResolve) > pendingBetsQueue.length ? pendingBetsQueue.length : (mQueue + _numToResolve);\r\n    uint tokensEarned = 0;\r\n\r\n    for (head = mQueue; head < tail; head++) {\r\n      // Check the head of the queue to see if there is a resolvable bet\r\n      // This means the bet at the queue head is older than 255 blocks AND is not 0\r\n      // (However, if the address at the head is null, skip it, it's already been resolved)\r\n      if (pendingBetsQueue[head] == address(0x0)) {\r\n        continue;\r\n      }\r\n\r\n      if (bets[pendingBetsQueue[head]].blockNumber != 0 && block.number > 256 + bets[pendingBetsQueue[head]].blockNumber) {\r\n        // Resolve the bet\r\n        // finishBetfrom returns the *player* profit\r\n        // this will be negative if the player lost and the house won\r\n        // so flip it to get the house profit, if any\r\n        int sum = - finishBetFrom(pendingBetsQueue[head]);\r\n\r\n        // Tokens earned is a percentage of the loss\r\n        if (sum > 0) {\r\n          tokensEarned += (uint(sum).mul(resolverPercentage)).div(1000000);\r\n        }\r\n\r\n        // Queue-tail is always the \"next\" open spot, so queue head and tail will never overlap\r\n      } else {\r\n        // If we can't resolve a bet, stop going down the queue\r\n        break;\r\n      }\r\n    }\r\n\r\n    queueHead = head;\r\n\r\n    // Send the earned tokens to the resolver\r\n    if (tokensEarned >= 1e14) {\r\n      controller.gamePayoutResolver(msg.sender, tokensEarned);\r\n    }\r\n\r\n    return (tokensEarned, head);\r\n  }\r\n\r\n  /** @dev Finishes the bet of the sender, if it exists.\r\n    * @return int The total profit (positive or negative) earned by the sender\r\n    */\r\n  function finishBet()\r\n  public\r\n  hasNotBetThisBlock(msg.sender)\r\n  returns (int)\r\n  {\r\n    return finishBetFrom(msg.sender);\r\n  }\r\n\r\n  /** @dev Resturns a random number\r\n    * @param _blockn The block number to base the random number off of\r\n    * @param _entropy Data to use in the random generation\r\n    * @param _index Data to use in the random generation\r\n    * @return randomNumber The random number to return\r\n    */\r\n  function maxRandom(uint _blockn, address _entropy, uint _index)\r\n  private view\r\n  returns (uint256 randomNumber)\r\n  {\r\n    return uint256(keccak256(\r\n        abi.encodePacked(\r\n          blockhash(_blockn),\r\n          _entropy,\r\n          _index\r\n        )));\r\n  }\r\n\r\n  /** @dev Returns a random number\r\n    * @param _upper The upper end of the range, exclusive\r\n    * @param _blockn The block number to use for the random number\r\n    * @param _entropy An address to be used for entropy\r\n    * @param _index A number to get the next random number\r\n    * @return randomNumber The random number\r\n    */\r\n  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\r\n  internal view\r\n  returns (uint256 randomNumber)\r\n  {\r\n    return maxRandom(_blockn, _entropy, _index) % _upper;\r\n  }\r\n\r\n  // Prevents the user from placing two bets in one block\r\n  modifier hasNotBetThisBlock(address _sender)\r\n  {\r\n    require(bets[_sender].blockNumber != block.number);\r\n    _;\r\n  }\r\n\r\n  // Requires that msg.sender is one of the token bankrolls\r\n  modifier bankrollOnly {\r\n    require(controller.isTokenBankroll(msg.sender));\r\n    _;\r\n  }\r\n\r\n  // Requires that the game is not paused\r\n  modifier isNotPaused {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  // Requires that the bet given has max profit low enough\r\n  modifier betIsValid(uint _betSize, uint _tier, bytes _data) {\r\n    uint divRate = ZethrTierLibrary.getDivRate(_tier);\r\n    require(isBetValid(_betSize, divRate, _data));\r\n    _;\r\n  }\r\n\r\n  // Only an owner can call this method (controller is always an owner)\r\n  modifier ownerOnly()\r\n  {\r\n    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\r\n    _;\r\n  }\r\n\r\n  /** @dev Places a bet. Callable only by token bankrolls\r\n    * @param _player The player that is placing the bet\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _divRate The dividend rate of the player\r\n    * @param _data The game-specific data, encoded in bytes-form\r\n    */\r\n  function execute(address _player, uint _tokenCount, uint _divRate, bytes _data) public;\r\n\r\n  /** @dev Resolves the bet of the supplied player.\r\n    * @param _playerAddress The address of the player whos bet we are resolving\r\n    * @return int The total profit the player earned, positive or negative\r\n    */\r\n  function finishBetFrom(address _playerAddress) internal returns (int);\r\n\r\n  /** @dev Determines if a supplied bet is valid\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _divRate The dividend rate of the bet\r\n    * @param _data The game-specific bet data\r\n    * @return bool Whether or not the bet is valid\r\n    */\r\n  function isBetValid(uint _tokenCount, uint _divRate, bytes _data) public view returns (bool);\r\n}\r\n\r\n// File: contracts/Games/ZethrDice.sol\r\n\r\n/* The actual game contract.\r\n *\r\n * This contract contains the actual game logic,\r\n * including placing bets (execute), resolving bets,\r\n * and resolving expired bets.\r\n*/\r\ncontract ZethrDice is ZethrGame {\r\n\r\n  /****************************\r\n   * GAME SPECIFIC\r\n   ****************************/\r\n\r\n  // Slots-specific bet structure\r\n  struct Bet {\r\n    // Must contain these in this order\r\n    uint56 tokenValue;\r\n    uint48 blockNumber;\r\n    uint8 tier;\r\n    // Game specific\r\n    uint8 rollUnder;\r\n    uint8 numRolls;\r\n  }\r\n\r\n  /****************************\r\n   * FIELDS\r\n   ****************************/\r\n\r\n  uint constant private MAX_INT = 2 ** 256 - 1;\r\n  uint constant public maxProfitDivisor = 1000000;\r\n  uint constant public maxNumber = 100;\r\n  uint constant public minNumber = 2;\r\n  uint constant public houseEdgeDivisor = 1000;\r\n  uint constant public houseEdge = 990;\r\n  uint constant public minBet = 1e18;\r\n\r\n  /****************************\r\n   * CONSTRUCTOR\r\n   ****************************/\r\n\r\n  constructor (address _controllerAddress, uint _resolverPercentage, string _name)\r\n  ZethrGame(_controllerAddress, _resolverPercentage, _name)\r\n  public\r\n  {\r\n  }\r\n\r\n  /****************************\r\n   * USER METHODS\r\n   ****************************/\r\n\r\n  /** @dev Retrieve the results of the last roll of a player, for web3 calls.\r\n    * @param _playerAddress The address of the player\r\n    */\r\n  function getLastRollOutput(address _playerAddress)\r\n  public view\r\n  returns (uint winAmount, uint lossAmount, uint[] memory output)\r\n  {\r\n    // Cast to Bet and read from storage\r\n    Bet storage playerBetInStorage = getBet(_playerAddress);\r\n    Bet memory playerBet = playerBetInStorage;\r\n\r\n    // Safety check\r\n    require(playerBet.blockNumber != 0);\r\n\r\n    (winAmount, lossAmount, output) = getRollOutput(playerBet.blockNumber, playerBet.rollUnder, playerBet.numRolls, playerBet.tokenValue.mul(1e14), _playerAddress);\r\n\r\n    return (winAmount, lossAmount, output);\r\n  }\r\n\r\n    event RollResult(\r\n        uint    _blockNumber,\r\n        address _target,\r\n        uint    _rollUnder,\r\n        uint    _numRolls,\r\n        uint    _tokenValue,\r\n        uint    _winAmount,\r\n        uint    _lossAmount,\r\n        uint[]  _output\r\n    );\r\n\r\n  /** @dev Retrieve the results of the spin, for web3 calls.\r\n    * @param _blockNumber The block number of the spin\r\n    * @param _numRolls The number of rolls of this bet\r\n    * @param _tokenValue The total number of tokens bet\r\n    * @param _target The address of the better\r\n    * @return winAmount The total number of tokens won\r\n    * @return lossAmount The total number of tokens lost\r\n    * @return output An array of all of the results of a multispin\r\n    */\r\n  function getRollOutput(uint _blockNumber, uint8 _rollUnder, uint8 _numRolls, uint _tokenValue, address _target)\r\n  public\r\n  returns (uint winAmount, uint lossAmount, uint[] memory output)\r\n  {\r\n    output = new uint[](_numRolls);\r\n    // Where the result sections start and stop\r\n\r\n    // If current block for the first spin is older than 255 blocks, ALL rolls are losses\r\n    if (block.number - _blockNumber > 255) {\r\n      lossAmount = _tokenValue.mul(_numRolls);\r\n    } else {\r\n      uint profit = calculateProfit(_tokenValue, _rollUnder);\r\n\r\n      for (uint i = 0; i < _numRolls; i++) {\r\n        // Store the output\r\n        output[i] = random(100, _blockNumber, _target, i) + 1;\r\n\r\n        if (output[i] < _rollUnder) {\r\n          // Player has won!\r\n          winAmount += profit + _tokenValue;\r\n        } else {\r\n          lossAmount += _tokenValue;\r\n        }\r\n      }\r\n    }\r\n    emit RollResult(_blockNumber, _target, _rollUnder, _numRolls, _tokenValue, winAmount, lossAmount, output);\r\n    return (winAmount, lossAmount, output);\r\n  }\r\n\r\n  /** @dev Retrieve the results of the roll, for contract calls.\r\n    * @param _blockNumber The block number of the roll\r\n    * @param _numRolls The number of rolls of this bet\r\n    * @param _rollUnder The number the roll has to be under to win\r\n    * @param _tokenValue The total number of tokens bet\r\n    * @param _target The address of the better\r\n    * @return winAmount The total number of tokens won\r\n    * @return lossAmount The total number of tokens lost\r\n    */\r\n  function getRollResults(uint _blockNumber, uint8 _rollUnder, uint8 _numRolls, uint _tokenValue, address _target)\r\n  public\r\n  returns (uint winAmount, uint lossAmount)\r\n  {\r\n    // If current block for the first spin is older than 255 blocks, ALL rolls are losses\r\n    if (block.number - _blockNumber > 255) {\r\n      lossAmount = _tokenValue.mul(_numRolls);\r\n    } else {\r\n      uint profit = calculateProfit(_tokenValue, _rollUnder);\r\n\r\n      for (uint i = 0; i < _numRolls; i++) {\r\n        // Store the output\r\n        uint output = random(100, _blockNumber, _target, i) + 1;\r\n\r\n        if (output < _rollUnder) {\r\n          winAmount += profit + _tokenValue;\r\n        } else {\r\n          lossAmount += _tokenValue;\r\n        }\r\n      }\r\n    }\r\n\r\n    return (winAmount, lossAmount);\r\n  }\r\n\r\n  /****************************\r\n   * OWNER METHODS\r\n   ****************************/\r\n\r\n  /****************************\r\n   * INTERNALS\r\n   ****************************/\r\n\r\n  // Calculate the maximum potential profit\r\n  function calculateProfit(uint _initBet, uint _roll)\r\n  internal view\r\n  returns (uint)\r\n  {\r\n    return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\r\n  }\r\n\r\n  /** @dev Returs the bet struct of a player\r\n    * @param _playerAddress The address of the player\r\n    * @return Bet The bet of the player\r\n    */\r\n  function getBet(address _playerAddress)\r\n  internal view\r\n  returns (Bet storage)\r\n  {\r\n    // Cast BetBase to Bet\r\n    BetBase storage betBase = bets[_playerAddress];\r\n\r\n    Bet storage playerBet;\r\n    assembly {\r\n    // tmp is pushed onto stack and points to betBase slot in storage\r\n      let tmp := betBase_slot\r\n\r\n    // swap1 swaps tmp and playerBet pointers\r\n      swap1\r\n    }\r\n    // tmp is popped off the stack\r\n\r\n    // playerBet now points to betBase\r\n    return playerBet;\r\n  }\r\n\r\n  /****************************\r\n   * OVERRIDDEN METHODS\r\n   ****************************/\r\n\r\n  /** @dev Resolves the bet of the supplied player.\r\n    * @param _playerAddress The address of the player whos bet we are resolving\r\n    * @return totalProfit The total profit the player earned, positive or negative\r\n    */\r\n  function finishBetFrom(address _playerAddress)\r\n  internal\r\n  returns (int /*totalProfit*/)\r\n  {\r\n    // Memory vars to hold data as we compute it\r\n    uint winAmount;\r\n    uint lossAmount;\r\n\r\n    // Cast to Bet and read from storage\r\n    Bet storage playerBetInStorage = getBet(_playerAddress);\r\n    Bet memory playerBet = playerBetInStorage;\r\n\r\n    // Safety check\r\n    require(playerBet.blockNumber != 0);\r\n    playerBetInStorage.blockNumber = 0;\r\n\r\n    // Iterate over the number of rolls and calculate totals:\r\n    //  - player win amount\r\n    //  - bankroll win amount\r\n    (winAmount, lossAmount) = getRollResults(playerBet.blockNumber, playerBet.rollUnder, playerBet.numRolls, playerBet.tokenValue.mul(1e14), _playerAddress);\r\n\r\n    // Figure out the token bankroll address\r\n    address tokenBankrollAddress = controller.getTokenBankrollAddressFromTier(playerBet.tier);\r\n    ZethrTokenBankrollInterface bankroll = ZethrTokenBankrollInterface(tokenBankrollAddress);\r\n\r\n    // Call into the bankroll to do some token accounting\r\n    bankroll.gameTokenResolution(winAmount, _playerAddress, 0, address(0x0), playerBet.tokenValue.mul(1e14).mul(playerBet.numRolls));\r\n\r\n    // Grab the position of the player in the pending bets queue\r\n    uint index = pendingBetsMapping[_playerAddress];\r\n\r\n    // Remove the player from the pending bets queue by setting the address to 0x0\r\n    pendingBetsQueue[index] = address(0x0);\r\n\r\n    // Delete the player's bet by setting the mapping to zero\r\n    pendingBetsMapping[_playerAddress] = 0;\r\n\r\n    emit Result(_playerAddress, playerBet.tokenValue.mul(1e14), int(winAmount) - int(lossAmount));\r\n\r\n    // Return all bet results + total *player* profit\r\n    return (int(winAmount) - int(lossAmount));\r\n  }\r\n\r\n  /** @dev Places a bet. Callable only by token bankrolls\r\n    * @param _player The player that is placing the bet\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _tier The div rate tier the player falls in\r\n    * @param _data The game-specific data, encoded in bytes-form\r\n    */\r\n  function execute(address _player, uint _tokenCount, uint _tier, bytes _data)\r\n  isNotPaused\r\n  bankrollOnly\r\n  betIsValid(_tokenCount, _tier, _data)\r\n  hasNotBetThisBlock(_player)\r\n  public\r\n  {\r\n    Bet storage playerBet = getBet(_player);\r\n\r\n    // Check for a player bet and resolve if necessary\r\n    if (playerBet.blockNumber != 0) {\r\n      finishBetFrom(_player);\r\n    }\r\n\r\n    uint8 rolls = uint8(_data[0]);\r\n    uint8 rollUnder = uint8(_data[1]);\r\n\r\n    // Set bet information\r\n    playerBet.tokenValue = uint56(_tokenCount.div(rolls).div(1e14));\r\n    playerBet.blockNumber = uint48(block.number);\r\n    playerBet.tier = uint8(_tier);\r\n    playerBet.rollUnder = rollUnder;\r\n    playerBet.numRolls = rolls;\r\n\r\n    // Add player to the pending bets queue\r\n    pendingBetsQueue.length ++;\r\n    pendingBetsQueue[queueTail] = _player;\r\n    queueTail++;\r\n\r\n    // Add the player's position in the queue to the pending bets mapping\r\n    pendingBetsMapping[_player] = queueTail - 1;\r\n\r\n    // Emit event\r\n    emit Wager(_player, _tokenCount, _data);\r\n  }\r\n\r\n  /** @dev Determines if a supplied bet is valid\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _data The game-specific bet data\r\n    * @return bool Whether or not the bet is valid\r\n    */\r\n  function isBetValid(uint _tokenCount, uint /*_divRate*/, bytes _data)\r\n  public view\r\n  returns (bool)\r\n  {\r\n    uint8 rollUnder = uint8(_data[1]);\r\n\r\n    return (calculateProfit(_tokenCount, rollUnder) < getMaxProfit()\r\n    && _tokenCount >= minBet\r\n    && rollUnder >= minNumber\r\n    && rollUnder <= maxNumber);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"ownerSetResolverPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerResumeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numToResolve\",\"type\":\"uint256\"}],\"name\":\"resolveExpiredBets\",\"outputs\":[{\"name\":\"tokensEarned_\",\"type\":\"uint256\"},{\"name\":\"queueHead_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"ownerSetGameName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_tokenCount\",\"type\":\"uint256\"},{\"name\":\"_tier\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishBet\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_rollUnder\",\"type\":\"uint8\"},{\"name\":\"_numRolls\",\"type\":\"uint8\"},{\"name\":\"_tokenValue\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getRollOutput\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"name\":\"output\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controllerAddress\",\"type\":\"address\"}],\"name\":\"ownerSetControllerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenCount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"isBetValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getLastRollOutput\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"name\":\"output\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_rollUnder\",\"type\":\"uint8\"},{\"name\":\"_numRolls\",\"type\":\"uint8\"},{\"name\":\"_tokenValue\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getRollResults\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"lossAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controllerAddress\",\"type\":\"address\"},{\"name\":\"_resolverPercentage\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_numRolls\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_winAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_lossAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_output\",\"type\":\"uint256[]\"}],\"name\":\"RollResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWagered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOffset\",\"type\":\"int256\"}],\"name\":\"Result\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Wager\",\"type\":\"event\"}]","ContractName":"ZethrDice","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008ad129fa24f169f3dd06e67bb1e795d57c7d83e70000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000095a65746872446963650000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://1a4343fe6f98f8c121033049c3b50b044ae6c9a7c3183462c322e71da8abb448"}]}