{"status":"1","message":"OK","result":[{"SourceCode":"/* EntityLib.sol\r\n *\r\n * Copyright (C) 2018 Ethertify B.V. <info@ethertify.com>\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity 0.4.19;\r\n\r\nlibrary EntityLib {\r\n  struct SignerData {\r\n    string signerDataHash;\r\n    /*\r\n     * status == 0 => NOT_VALID\r\n     * status == 1 => VALIDATION_PENDING\r\n     * status == 2 => VALID\r\n     * status == 3 => DATA_UPDATED\r\n     */\r\n    uint status;\r\n  }\r\n\r\n  struct EntityData {\r\n    address owner;\r\n    string dataHash; // hash entity data\r\n    /*\r\n      * status == 0 => NOT_VALID\r\n      * status == 1 => VALIDATION_PENDING\r\n      * status == 2 => VALID\r\n      * status == 4 => RENEWAL_REQUESTED\r\n      * status == 8 => CLOSED\r\n      * otherwise => UNKNOWN\r\n      */\r\n    uint status;\r\n    bytes32 urlHash;         // hash url only\r\n    uint expiration;         // Expiration date\r\n    uint renewalPeriod;      // Renewal period to be used for 3rd party renewals (3rd party paying the validation expenses)\r\n    bytes32 oraclizeQueryId; // Last query Id from oraclize. We will only process the last request\r\n\r\n    /*\r\n      * signers[a] == 0;\r\n      * signers[a] = ipfs multihash address for signer data file in json format\r\n      */\r\n    mapping(address => SignerData) signers;\r\n    address[] signersArr;\r\n  }\r\n\r\n  struct Data {\r\n    mapping(uint => EntityData) entities;\r\n    mapping(bytes32 => uint) entityIds;\r\n    uint nEntities;\r\n  }\r\n\r\n  // METHODS\r\n\r\n  /**\r\n   * Creates a new entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entitDatayHash {string} - The ipfs multihash address of the entity information in json format\r\n   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity\r\n   * @param expirationDate {uint} - The expiration date of the current entity\r\n   * @param renewalPeriod {uint} - The time period which will be added to the current date or expiration date when a renewal is requested\r\n   * @return {uint} The id of the created entity\r\n   */\r\n  function create(Data storage self, uint entityId, string entitDatayHash, bytes32 urlHash, uint expirationDate, uint renewalPeriod) isExpirationDateValid(expirationDate) isRenewalPeriodValid(renewalPeriod) public {\r\n    self.entities[entityId] = EntityData({\r\n        owner: msg.sender,\r\n        dataHash: entitDatayHash,\r\n        urlHash: urlHash,\r\n        status: 1,\r\n        expiration: expirationDate,\r\n        renewalPeriod: renewalPeriod,\r\n        oraclizeQueryId: 0,\r\n        signersArr: new address[](0)\r\n    });\r\n    EntityCreated(entityId);\r\n  }\r\n\r\n  /**\r\n   * Process validation after the oraclize callback\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param queryId {bytes32} - The id of the oraclize query (returned by the call to oraclize_query method)\r\n   * @param result {string} - The result of the query\r\n   */\r\n  function processValidation(Data storage self, bytes32 queryId, string result) public {\r\n    uint entityId = self.entityIds[queryId];\r\n    self.entityIds[queryId] = 0;\r\n    \r\n    EntityData storage entity = self.entities[entityId];\r\n\r\n    require (queryId == entity.oraclizeQueryId);\r\n\r\n    string memory entityIdStr = uintToString(entityId);\r\n    string memory toCompare = strConcat(entityIdStr, \":\", entity.dataHash); \r\n\r\n    if (stringsEqual(result, toCompare)) {\r\n      if (entity.status == 4) { // if entity is waiting for renewal\r\n        uint initDate = max(entity.expiration, now);\r\n        entity.expiration = initDate + entity.renewalPeriod;\r\n      }\r\n\r\n      entity.status = 2; // set entity status to valid\r\n      EntityValidated(entityId);\r\n    } else {\r\n      entity.status = 1;  // set entity status to validation pending\r\n      EntityInvalid(entityId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets a new expiration date for the entity. It will trigger an entity validation through the oracle, so it must be paid.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param expirationDate {uint} - The new expiration date of the entity\r\n   */\r\n  function setExpiration (Data storage self, uint entityId, uint expirationDate) isNotClosed(self, entityId) onlyEntity(self, entityId) isExpirationDateValid(expirationDate) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.status = 1;\r\n    entity.expiration = expirationDate;\r\n    EntityExpirationSet(entityId);\r\n  }\r\n  \r\n  /**\r\n   * Sets a new renewal interval\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param renewalPeriod {uint} - The new renewal interval (in seconds)\r\n   */\r\n  function setRenewalPeriod (Data storage self, uint entityId, uint renewalPeriod) isNotClosed(self, entityId) onlyEntity(self, entityId) isRenewalPeriodValid(renewalPeriod) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.renewalPeriod = renewalPeriod;\r\n    EntityRenewalSet(entityId);\r\n  }\r\n\r\n  /**\r\n   * Close an entity. This status will not allow further operations on the entity.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function closeEntity(Data storage self, uint entityId) isNotClosed(self, entityId) onlyEntity(self, entityId) public {\r\n    self.entities[entityId].status = 8;\r\n    EntityClosed(entityId);\r\n  }\r\n\r\n  /**\r\n   * Registers a new signer in an entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be registered\r\n   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format\r\n   */\r\n  function registerSigner(Data storage self, uint entityId, address signerAddress, string signerDataHash) isValidEntity(self, entityId) onlyEntity(self, entityId) signerIsNotYetRegistered(self, entityId, signerAddress) public {\r\n    self.entities[entityId].signersArr.push(signerAddress);\r\n    self.entities[entityId].signers[signerAddress] = SignerData({\r\n      signerDataHash: signerDataHash,\r\n      status: 1\r\n    });\r\n    SignerAdded(entityId, signerAddress);\r\n  }\r\n\r\n  /**\r\n   * Confirms signer registration\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerDataHash {string} - The ipfs data hash of the signer to confirm\r\n   */\r\n  function confirmSignerRegistration(Data storage self, uint entityId, string signerDataHash) isValidEntity(self, entityId) isWaitingConfirmation(self, entityId, signerDataHash) public {\r\n    self.entities[entityId].signers[msg.sender].status = 2;\r\n    SignerConfirmed(entityId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Removes a signer from an entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be removed\r\n   */\r\n  function removeSigner(Data storage self, uint entityId, address signerAddress) isValidEntity(self, entityId) onlyEntity(self, entityId) public {\r\n    internalRemoveSigner(self, entityId, signerAddress);\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes a signer from an entity (internal use, without modifiers)\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be removed\r\n   */\r\n  function internalRemoveSigner(Data storage self, uint entityId, address signerAddress) private {\r\n    EntityData storage entity = self.entities[entityId];\r\n    address[] storage signersArr = entity.signersArr;\r\n    SignerData storage signer = entity.signers[signerAddress];\r\n\r\n    if (bytes(signer.signerDataHash).length != 0 || signer.status != 0) {\r\n      signer.status = 0;\r\n      signer.signerDataHash = '';\r\n      delete entity.signers[signerAddress];\r\n\r\n      // Update array for iterator\r\n      uint i = 0;\r\n      for (i; signerAddress != signersArr[i]; i++) {}\r\n      signersArr[i] = signersArr[signersArr.length - 1];\r\n      signersArr[signersArr.length - 1] = 0;\r\n      signersArr.length = signersArr.length - 1;\r\n      \r\n      SignerRemoved(entityId, signerAddress);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Leave the specified entity (remove signer if found)\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function leaveEntity(Data storage self, uint entityId) signerBelongsToEntity(self, entityId) public {\r\n    internalRemoveSigner(self, entityId, msg.sender);\r\n  }\r\n\r\n  /**\r\n    * Checks if an entity can be validated\r\n    * @param entityId {uint} - The id of the entity to validate\r\n    * @param url {string} - The URL of the entity\r\n    * @return {bytes32} - The id of the oraclize query\r\n    */\r\n  function canValidateSigningEntity(Data storage self, uint entityId, string url) isNotClosed(self, entityId) isRegisteredURL(self, entityId, url) view public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if an entity validity can be renewed\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to validate\r\n   * @param url {string} - The URL of the entity\r\n   * @return {bool} - True if renewal is possible\r\n   */\r\n  function canRenew(Data storage self, uint entityId, string url) isValidatedEntity(self, entityId) isRenewalPeriod(self, entityId) isRegisteredURL(self, entityId, url) view public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if an entity can issue certificate (from its signers)\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check\r\n   * @return {bool} - True if issuance is possible\r\n   */\r\n  function canIssueCertificates(Data storage self, uint entityId) isNotClosed(self, entityId) notExpired(self, entityId) signerBelongsToEntity(self, entityId) view public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates entity data\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param entityDataHash {string} - The ipfs multihash address of the entity information in json format\r\n   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity\r\n   */\r\n  function updateEntityData(Data storage self, uint entityId, string entityDataHash, bytes32 urlHash) isNotClosed(self, entityId) onlyEntity(self, entityId) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.dataHash = entityDataHash;\r\n    entity.urlHash = urlHash;\r\n    entity.status = 1;\r\n    EntityDataUpdated(entityId);\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the signer data in the requestes entities\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityIds {array} - The ids of the entities to update\r\n   * @param signerDataHash {string} - The ipfs multihash of the new signer data\r\n   */\r\n  function updateSignerData(Data storage self, uint[] entityIds, string signerDataHash) signerBelongsToEntities(self, entityIds) public {\r\n    uint[] memory updated = new uint[](entityIds.length);\r\n    for (uint i = 0; i < entityIds.length; i++) {\r\n      uint entityId = entityIds[i];\r\n      SignerData storage signer = self.entities[entityId].signers[msg.sender];\r\n\r\n      if (signer.status != 2) {\r\n        continue;\r\n      }\r\n      signer.status = 3;\r\n      signer.signerDataHash = signerDataHash;\r\n      updated[i] = entityId;\r\n    }\r\n    SignerDataUpdated(updated, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Accepts a new signer data update in the entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer update to be accepted\r\n   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format to be accepted\r\n   */\r\n  function acceptSignerUpdate(Data storage self, uint entityId, address signerAddress, string signerDataHash) onlyEntity(self, entityId) notExpired(self, entityId) signerUpdateCanBeAccepted(self, entityId, signerAddress, signerDataHash) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.signers[signerAddress].status = 2;\r\n    SignerUpdateAccepted(entityId, signerAddress);\r\n  }\r\n\r\n  // HELPER METHODS\r\n\r\n  /**\r\n   * Returns the max of two numbers\r\n   * @param a {uint} - Input number a\r\n   * @param b {uint} - Input number b\r\n   * @return {uint} - The maximum of the two inputs\r\n   */\r\n  function max(uint a, uint b) pure public returns(uint) {\r\n    if (a > b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Compares two strings\r\n   * @param _a {string} - One of the strings\r\n   * @param _b {string} - The other string\r\n   * @return {bool} True if the two strings are equal, false otherwise\r\n   */\r\n  function stringsEqual(string memory _a, string memory _b) pure internal returns (bool) {\r\n    bytes memory a = bytes(_a);\r\n    bytes memory b = bytes(_b);\r\n    if (a.length != b.length)\r\n      return false;\r\n    for (uint i = 0; i < a.length; i ++) {\r\n      if (a[i] != b[i])\r\n        return false;\r\n        }\r\n    return true;\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) pure internal returns (string){\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) {babcde[k++] = _ba[i];}\r\n    for (i = 0; i < _bb.length; i++) {babcde[k++] = _bb[i];}\r\n    for (i = 0; i < _bc.length; i++) {babcde[k++] = _bc[i];}\r\n    for (i = 0; i < _bd.length; i++) {babcde[k++] = _bd[i];}\r\n    for (i = 0; i < _be.length; i++) {babcde[k++] = _be[i];}\r\n    return string(babcde);\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d) pure internal returns (string) {\r\n      return strConcat(_a, _b, _c, _d, \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c) pure internal returns (string) {\r\n      return strConcat(_a, _b, _c, \"\", \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b) pure internal returns (string) {\r\n      return strConcat(_a, _b, \"\", \"\", \"\");\r\n  }\r\n\r\n  // uint to string\r\n  function uintToString(uint v) pure public returns (string) {\r\n    uint maxlength = 100;\r\n    bytes memory reversed = new bytes(maxlength);\r\n    uint i = 0;\r\n    while (v != 0) {\r\n      uint remainder = v % 10;\r\n      v = v / 10;\r\n      reversed[i++] = byte(48 + remainder);\r\n    }\r\n    bytes memory s = new bytes(i); // i + 1 is inefficient\r\n    for (uint j = 0; j < i; j++) {\r\n        s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\r\n    }\r\n    string memory str = string(s); // memory isn't implicitly convertible to storage\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Set the oraclize query id of the last request\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity\r\n   * @param queryId {bytes32} - The query id from the oraclize request\r\n   */\r\n  function setOraclizeQueryId(Data storage self, uint id, bytes32 queryId) public {\r\n    self.entities[id].oraclizeQueryId = queryId;\r\n  }\r\n\r\n  // Helper functions\r\n\r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   * @return {bool} - True if the entity is validated\r\n   */\r\n  function isValidated(Data storage self, uint id) view public returns (bool) {\r\n    return (id > 0 && (self.entities[id].status == 2 || self.entities[id].status == 4));\r\n  }\r\n\r\n /**\r\n  * Returns True if specified entity is not expired. False otherwise.\r\n  * @param self {object} - The data containing the entity mappings\r\n  * @param id {uint} - The id of the entity to check \r\n  * @return {bool} - True if the entity is not expired\r\n  */\r\n  function isExpired(Data storage self, uint id) view public returns (bool) {\r\n    return (id > 0 && (self.entities[id].expiration < now));\r\n  }\r\n\r\n  /**\r\n  * Returns True if specified entity is closed.\r\n  * @param self {object} - The data containing the entity mappings\r\n  * @param id {uint} - The id of the entity to check \r\n  * @return {bool} - True if the entity is closed\r\n  */\r\n  function isClosed(Data storage self, uint id) view public returns (bool) {\r\n    return self.entities[id].status == 8;\r\n  }\r\n\r\n /**\r\n   * Returns True if specified entity is validated and not expired\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   * @return {bool} - True if the entity is validated\r\n   */\r\n  function isValid(Data storage self, uint id) view public returns (bool) {\r\n    return isValidated(self, id) && !isExpired(self, id) && !isClosed(self, id);\r\n  }\r\n\r\n /**\r\n   * Returns True if specified entity exists\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   * @return {bool} - True if the entity exists\r\n   */\r\n  function exists(Data storage self, uint id) view public returns(bool) {\r\n    EntityData storage entity = self.entities[id];\r\n    return entity.status > 0;\r\n  }\r\n\r\n  // MODIFIERS\r\n  \r\n  /**\r\n   * Valid if the renewal period is less than 31 days\r\n   * @param renewalPeriod {uint} - The renewal period to check (in seconds)\r\n   */\r\n  modifier isRenewalPeriodValid(uint renewalPeriod) {\r\n    require(renewalPeriod >= 0 && renewalPeriod <= 32 * 24 * 60 * 60); // Renewal period less than 32 days\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Valid if the expiration date is in less than 31 days\r\n   * @param expiration {uint} - The expiration date (in seconds)\r\n   */\r\n  modifier isExpirationDateValid(uint expiration) {\r\n    require(expiration - now > 0 && expiration - now <= 32 * 24 * 60 * 60); // Expiration date is in less than 32 days in the future\r\n    _;\r\n  }\r\n  \r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   */\r\n  modifier isValidatedEntity(Data storage self, uint id) {\r\n    require (isValidated(self, id));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed, not expired and not closed. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   */\r\n  modifier isValidEntity(Data storage self, uint id) {\r\n    require (isValid(self, id));\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * Returns True if specified entity is validated. False otherwise.\r\n  * @param self {object} - The data containing the entity mappings\r\n  * @param id {uint} - The id of the entity to check \r\n  */\r\n  modifier notExpired(Data storage self, uint id) {\r\n    require (!isExpired(self, id));\r\n    _;  \r\n  }\r\n\r\n  /**\r\n    * Returns True if tansaction sent by owner of entity. False otherwise.\r\n    * @param self {object} - The data containing the entity mappings\r\n    * @param id {uint} - The id of the entity to check\r\n    */\r\n  modifier onlyEntity(Data storage self, uint id) {\r\n    require (msg.sender == self.entities[id].owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n    * Returns True if an URL is the one associated to the entity. False otherwise.\r\n    * @param self {object} - The data containing the entity mappings\r\n    * @param entityId {uint} - The id of the entity\r\n    * @param url {string} - The  URL\r\n    */\r\n  modifier isRegisteredURL(Data storage self, uint entityId, string url) {\r\n    require (self.entities[entityId].urlHash == sha256(url));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns True if current time is in renewal period for a valid entity. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check \r\n   */\r\n  modifier isRenewalPeriod(Data storage self, uint entityId) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    require (entity.renewalPeriod > 0 && entityId > 0 && (entity.expiration - entity.renewalPeriod < now) && entity.status == 2);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if sender is registered in entity. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   */\r\n  modifier signerBelongsToEntity(Data storage self, uint entityId) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    require (entityId > 0 && (bytes(entity.signers[msg.sender].signerDataHash).length != 0) && (entity.signers[msg.sender].status == 2));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if sender is registered in all the entities. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityIds {array} - The ids of the entities\r\n   */\r\n  modifier signerBelongsToEntities(Data storage self, uint[] entityIds) {\r\n    for (uint i = 0; i < entityIds.length; i++) {\r\n      uint entityId = entityIds[i];\r\n      EntityData storage entity = self.entities[entityId];\r\n      require (entityId > 0 && (entity.signers[msg.sender].status != 0));\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the signer was not yet added to an entity.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   * @param signerAddress {address} - The signer to check\r\n   */\r\n  modifier signerIsNotYetRegistered(Data storage self, uint entityId, address signerAddress) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    require (entity.signers[signerAddress].status == 0);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the entity is validated AND the signer has a pending update with a matching IPFS data hash\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   * @param signerAddress {address} - The signer to check\r\n   * @param signerDataHash {string} - The signer IPFS data pending of confirmation\r\n   */\r\n  modifier signerUpdateCanBeAccepted(Data storage self, uint entityId, address signerAddress, string signerDataHash) {\r\n    require (isValid(self, entityId));\r\n    EntityData storage entity = self.entities[entityId];\r\n    string memory oldSignerDatHash = entity.signers[signerAddress].signerDataHash;\r\n    require (entity.signers[signerAddress].status == 3 && stringsEqual(oldSignerDatHash, signerDataHash));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the sender is registered as a signer in entityId and the status is VALIDATION_PENDING. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check\r\n   */\r\n  modifier isWaitingConfirmation(Data storage self, uint entityId, string signerDataHash) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    SignerData storage signer = entity.signers[msg.sender];\r\n    require ((bytes(signer.signerDataHash).length != 0) && (signer.status == 1) && stringsEqual(signer.signerDataHash, signerDataHash));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the entity has not been closed\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check\r\n   */\r\n  modifier isNotClosed(Data storage self, uint entityId) {\r\n    require(!isClosed(self, entityId));\r\n    _;\r\n  }\r\n\r\n  // EVENTS\r\n\r\n  event EntityCreated(uint indexed entityId);\r\n  event EntityValidated(uint indexed entityId);\r\n  event EntityDataUpdated(uint indexed entityId);\r\n  event EntityInvalid(uint indexed entityId);\r\n  event SignerAdded(uint indexed entityId, address indexed signerAddress);\r\n  event SignerDataUpdated(uint[] entities, address indexed signerAddress);\r\n  event SignerUpdateAccepted(uint indexed entityId, address indexed signerAddress);\r\n  event SignerRemoved(uint indexed entityId, address signerAddress);\r\n  event EntityClosed(uint indexed entityId);\r\n  event SignerConfirmed(uint indexed entityId, address signerAddress);\r\n  event EntityExpirationSet(uint indexed entityId);\r\n  event EntityRenewalSet(uint indexed entityId);  \r\n }","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"canRenew\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"entityDataHash\",\"type\":\"string\"},{\"name\":\"urlHash\",\"type\":\"bytes32\"}],\"name\":\"updateEntityData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"closeEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"queryId\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"processValidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"renewalPeriod\",\"type\":\"uint256\"}],\"name\":\"setRenewalPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"leaveEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityIds\",\"type\":\"uint256[]\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"updateSignerData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"expirationDate\",\"type\":\"uint256\"}],\"name\":\"setExpiration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"canValidateSigningEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"acceptSignerUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"confirmSignerRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"canIssueCertificates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isValidated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"registerSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"setOraclizeQueryId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"uintToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EntityLib.Data storage\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"entitDatayHash\",\"type\":\"string\"},{\"name\":\"urlHash\",\"type\":\"bytes32\"},{\"name\":\"expirationDate\",\"type\":\"uint256\"},{\"name\":\"renewalPeriod\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityInvalid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"entities\",\"type\":\"uint256[]\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerUpdateAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityExpirationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityRenewalSet\",\"type\":\"event\"}]","ContractName":"EntityLib","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://210090398d871979abef2b69351167d5d9ef2300c6fc126e1f981eaaa3292074"}]}