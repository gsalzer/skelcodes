{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract NoboToken is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 totalSupply_;\r\n\r\n    constructor() public {\r\n        name = \"Nobotoken\";\r\n        symbol = \"NBX\";\r\n        decimals = 18;\r\n        totalSupply_ = 0;\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    // ------------------------- GENERAL ERC20 -------------------------------\r\n    // -----------------------------------------------------------------------\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n\r\n    /*\r\n    * @dev tracks token balances of users\r\n    */\r\n    mapping (address => uint256) balances;\r\n\r\n    /*\r\n    * @dev transfer token for a specified address\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n    /*\r\n    * @dev gets the balance of the specified address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n\r\n    // -----------------------------------------------------------------------\r\n    // ------------------------- ALLOWANCE RELEATED --------------------------\r\n    // -----------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev tracks the allowance an address has from another one\r\n    */\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /*\r\n    * @dev transfers token from one address to another, must have allowance\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev gives allowance to spender, works together with transferFrom\r\n    */\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev used to increase the allowance a spender has\r\n    */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint _addedValue\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] =\r\n            allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev used to decrease the allowance a spender has\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint _subtractedValue\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev used to check what allowance a spender has from the owner\r\n    */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // -----------------------------------------------------------------------\r\n    //--------------------------- MINTING RELEATED ---------------------------\r\n    // -----------------------------------------------------------------------\r\n    /*\r\n    * @title Mintable token\r\n    * @dev instead of another contract, all mintable functionality goes here\r\n    */\r\n    event Mint(\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event MintFinished();\r\n\r\n    /*\r\n    * @dev signifies whether or not minting process is over\r\n    */\r\n    bool public mintingFinished = false;\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev minting of tokens, restricted to owner address (crowdsale)\r\n    */\r\n    function mint(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        public\r\n        onlyOwner\r\n        canMint\r\n        returns (bool success)\r\n    {\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev Function to stop minting new tokens.\r\n    */\r\n    function finishMinting() onlyOwner canMint public returns (bool success) {\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract RefundVault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum State { Active, Refunding, Closed }\r\n\r\n    mapping (address => uint256) public deposited;\r\n    address public wallet;\r\n    State public state;\r\n\r\n    event Closed();\r\n    event RefundsEnabled();\r\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n    /**\r\n   * @param _wallet Vault address\r\n   */\r\n    constructor(address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n        state = State.Active;\r\n    }\r\n\r\n    /**\r\n   * @param investor Investor address\r\n   */\r\n    function deposit(address investor) onlyOwner public payable {\r\n        require(state == State.Active);\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n\r\n    function close() onlyOwner public {\r\n        require(state == State.Active);\r\n        state = State.Closed;\r\n        emit Closed();\r\n        wallet.transfer(address(this).balance);\r\n    }\r\n\r\n    function enableRefunds() onlyOwner public {\r\n        require(state == State.Active);\r\n        state = State.Refunding;\r\n        emit RefundsEnabled();\r\n    }\r\n\r\n    /**\r\n   * @param investor Investor address\r\n   */\r\n    function refund(address investor) public {\r\n        require(state == State.Refunding);\r\n        uint256 depositedValue = deposited[investor];\r\n        deposited[investor] = 0;\r\n        investor.transfer(depositedValue);\r\n        emit Refunded(investor, depositedValue);\r\n    }\r\n\r\n    function batchRefund(address[] _investors) public {\r\n        require(state == State.Refunding);\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n           require(_investors[i] != address(0));\r\n           uint256 _depositedValue = deposited[_investors[i]];\r\n           require(_depositedValue > 0);\r\n           deposited[_investors[i]] = 0;\r\n           _investors[i].transfer(_depositedValue);\r\n           emit Refunded(_investors[i], _depositedValue);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract TimedAccess is Ownable {\r\n   /*\r\n    * @dev Requires msg.sender to have valid access message.\r\n    * @param _v ECDSA signature parameter v.\r\n    * @param _r ECDSA signature parameters r.\r\n    * @param _s ECDSA signature parameters s.\r\n    * @param _blockNum used to limit access time, will be checked if signed\r\n    * @param _etherPrice must be checked to ensure no tampering\r\n    */\r\n    address public signer;\r\n\r\n    function _setSigner(address _signer) internal {\r\n        require(_signer != address(0));\r\n        signer = _signer;\r\n    }\r\n\r\n    modifier onlyWithValidCode(\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _v,\r\n        uint256 _blockNum,\r\n        uint256 _etherPrice\r\n    )\r\n    {\r\n        require(\r\n            isValidAccessMessage(\r\n                _r,\r\n                _s,\r\n                _v,\r\n                _blockNum,\r\n                _etherPrice,\r\n                msg.sender\r\n            ),\r\n            \"Access code is incorrect or expired.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev Verifies if message was signed by owner to give access to\r\n    *      _add for this contract.\r\n    *      Assumes Geth signature prefix (\\x19Ethereum Signed Message:\\n32).\r\n    * @param _sender Address of agent with access\r\n    * @return Validity of access message for a given address.\r\n    */\r\n    function isValidAccessMessage(\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _v,\r\n        uint256 _blockNum,\r\n        uint256 _etherPrice,\r\n        address _sender\r\n    )\r\n        view\r\n        public\r\n        returns (bool)\r\n    {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                _blockNum,\r\n                _etherPrice,\r\n                _sender\r\n            )\r\n        );\r\n        bool isValid = (\r\n            signer == ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19Ethereum Signed Message:\\n32\",\r\n                        hash\r\n                    )\r\n                ),\r\n                _v,\r\n                _r,\r\n                _s\r\n            )\r\n        );\r\n\r\n        // after 123 blocks have passed, no purchase is possible\r\n        // (roughly 30 minutes)\r\n        bool isStillTime = (_blockNum + 123 > block.number);\r\n\r\n        return (isValid && isStillTime);\r\n    }\r\n}\r\n\r\ncontract NoboCrowdsale is TimedAccess {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n    * @dev TokenAmountGetter: a library to calculate appropiate token amount\r\n    */\r\n    using TokenAmountGetter for uint256;\r\n\r\n    // -----------------------------------------------------------------------\r\n    // ---------------------------- VARIABLES --------------------------------\r\n    // -----------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev the supervisor can prevent the owner from having control\r\n    */\r\n    address public supervisor;\r\n\r\n    /*\r\n    * @dev wallet = where the ether goes to in a successful crowdsale\r\n    */\r\n    address public wallet;\r\n\r\n    /*\r\n    * @dev token is the actual ERC20 token contract\r\n    */\r\n    NoboToken public token;\r\n\r\n    /*\r\n    * @dev RefundVault: where the ether is stored, used to enable refunds\r\n    */\r\n    RefundVault public vault;\r\n\r\n    /*\r\n    * @dev the base rate for NBX, without any bonuses\r\n    */\r\n    uint256  public baseRate;\r\n\r\n   /*\r\n    * @dev startTime regulates the time bonuses, set when crowdsale begins\r\n    */\r\n    uint256  public startTime;\r\n\r\n    /*\r\n    * @dev softCap = goal of our crowdsale, if it is not reached,\r\n    *   customers can be refunded\r\n    */\r\n    uint256 public softCap;\r\n\r\n    /*\r\n    * @dev maximum amount of ether we can collect in this crowdsale\r\n    */\r\n    uint256 public hardCap;\r\n\r\n    /*\r\n    * @dev the status controls the accessibilty of certain functions, e.g. the\r\n    *   purchase token function (in combination with the modifier onlyDuring)\r\n    */\r\n    enum Status { unstarted, started, ended, paused }\r\n    Status public status;\r\n\r\n    /*\r\n    * @dev balances stores the balances an investor is eligible to\r\n    */\r\n    mapping(address => uint256) public balances;\r\n\r\n    /*\r\n    * @dev accessAllowed-bit needs to be true for certain functions,\r\n    *   can only be switched by supervisor\r\n    */\r\n    bool public accessAllowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ------------------------------ EVENTS ----------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev NoAccessCode emitted when tx is made without data field\r\n    */\r\n    event NoAccessCode(address indexed sender);\r\n\r\n    /*\r\n    * @dev CapReached signals the end of the crowdsale to us\r\n    */\r\n    event CapReached(address indexed sender, uint256 indexed etherAmount);\r\n\r\n    /*\r\n    * @dev PurchaseTooSmall is emitted when tx with less than 0.1 ETH is made\r\n    */\r\n    event PurchaseTooSmall(address indexed sender, uint256 indexed etherAmount);\r\n\r\n    /*\r\n    * @dev TokenPurchase is the general log for a legit purchase\r\n    */\r\n    event TokenPurchase(\r\n        address indexed investor,\r\n        uint256 indexed etherAmount,\r\n        uint256 indexed etherPrice,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    /*\r\n    * @dev AccessChanged is emitted when the supervisor dis-/allows functions\r\n    */\r\n    event AccessChanged(bool indexed accessAllowed);\r\n\r\n    /*\r\n    * @dev SignerChanged signals the change of the signer address,\r\n    *   the one against whcih the signature of the access code is compared to\r\n    */\r\n    event SignerChanged(address indexed previousSigner, address indexed newSigner);\r\n\r\n    /*\r\n    * @dev StatusChanged signals the change of crowdsale stages\r\n    */\r\n    event StatusChanged(\r\n        Status indexed previousStatus,\r\n        Status indexed newStatus\r\n    );\r\n\r\n    // ------------------------------------------------------------------------\r\n    // --------------------------- MODIFIER -----------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev restricts functions to certain crowdsale stages\r\n    */\r\n    modifier onlyDuring(Status _status) {\r\n        require (status == _status);\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * @dev akin to onlyOwner\r\n    */\r\n    modifier onlySupervisor() {\r\n        require(supervisor == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * @dev certain functions need permission from the supervisor\r\n    */\r\n    modifier whenAccessAllowed() {\r\n        require(accessAllowed);\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // --------------------------- CONSTRUCTOR --------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev the constructor needs the token contract address\r\n    * @dev the crowdsale contract needs to be made owner of the token contract\r\n    */\r\n    constructor (\r\n        address _tokenAddress,\r\n        address _signer,\r\n        address _supervisor,\r\n        address _wallet\r\n    )\r\n        public\r\n    {\r\n        require(_tokenAddress != address(0));\r\n        require(_signer != address(0));\r\n        require(_supervisor!= address(0));\r\n        require(_wallet != address(0));\r\n        signer = _signer;\r\n        supervisor = _supervisor;\r\n        wallet = _wallet;\r\n        token = NoboToken(_tokenAddress);\r\n        vault = new RefundVault(wallet);\r\n        baseRate = 500;\r\n        softCap = 25000 ether;\r\n        hardCap = 250000 ether;\r\n        status = Status.unstarted;\r\n        accessAllowed = false;\r\n    }\r\n\r\n    /*\r\n    * @dev send ether back to sender when no access code is specified\r\n    */\r\n    function() public payable {\r\n        emit NoAccessCode(msg.sender);\r\n        msg.sender.transfer(msg.value);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // -------------------------- MAIN PURCHASE -------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev called by users to buy token, whilst providing their access code\r\n    *   for more information about v, r and as see TimedAccess contract\r\n    * @param _v ECDSA signature parameter v.\r\n    * @param _r ECDSA signature parameters r.\r\n    * @param _s ECDSA signature parameters s.\r\n    * @param _blockNum used to make sure the user has only a certain timeperiod\r\n    *   to buy the tokens (after a set amount of blocks the function will\r\n    *   not execute anymore. Checked in TimedAccess\r\n    * @param _etherPrice used to get the bonus for the user\r\n    */\r\n    function purchaseTokens(\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _v,\r\n        uint256 _blockNum,\r\n        uint256 _etherPrice\r\n    )\r\n        public\r\n        payable\r\n        onlyDuring(Status.started)\r\n        onlyWithValidCode( _r, _s, _v, _blockNum, _etherPrice)\r\n    {\r\n        if (_isPurchaseValid(msg.sender, msg.value)) {\r\n            uint256 _etherAmount = msg.value;\r\n            uint256 _tokenAmount = _etherAmount.getTokenAmount(\r\n                _etherPrice,\r\n                startTime,\r\n                baseRate\r\n            );\r\n            emit TokenPurchase(msg.sender, _etherAmount, _etherPrice, _tokenAmount);\r\n            // registering purchase in a balance mapping\r\n            _registerPurchase(msg.sender, _tokenAmount);\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev checks if ether Amount is sufficient (measured in Euro)\r\n    *   and if the hardcap would be reached\r\n    */\r\n    function _isPurchaseValid(\r\n        address _sender,\r\n        uint256 _etherAmount\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // if raised ether would be more than hardcap, revert\r\n        if (getEtherRaised().add(_etherAmount) > hardCap) {\r\n            _sender.transfer(_etherAmount);\r\n            emit CapReached(_sender, getEtherRaised()); // for testing\r\n            return false;\r\n        }\r\n        if(_etherAmount <  0.1 ether) {\r\n            _sender.transfer(_etherAmount);\r\n            emit PurchaseTooSmall(_sender, _etherAmount);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Overrides parent by storing balances instead of issuing tokens right away.\r\n    * @param _investor Token purchaser\r\n    * @param _tokenAmount Amount of tokens purchased\r\n    */\r\n    function _registerPurchase(\r\n        address _investor,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        // registering balance of tokens in mapping for the customer\r\n        balances[_investor] = balances[_investor].add(_tokenAmount);\r\n        // and registering in the refundvault\r\n        vault.deposit.value(msg.value)(_investor);\r\n    }\r\n\r\n    /*\r\n    * @dev used to check if refunds need to be enabled\r\n    */\r\n    function _isGoalReached() internal view returns (bool) {\r\n\t    return (getEtherRaised() >= softCap);\r\n    }\r\n\r\n    /*\r\n    * @dev used to check how much ether is in the refundvault\r\n    */\r\n    function getEtherRaised() public view returns (uint256) {\r\n        return address(vault).balance;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ------------------------- STAGE MANAGEMENT -----------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev used to start Crowdsale, sets the starttime for bonuses\r\n    */\r\n    function startCrowdsale()\r\n        external\r\n        whenAccessAllowed\r\n        onlyOwner\r\n        onlyDuring(Status.unstarted)\r\n    {\r\n        emit StatusChanged(status, Status.started);\r\n        status = Status.started;\r\n        startTime = now;\r\n    }\r\n\r\n    /*\r\n    * @dev ends Crowdsale, enables refunding of contracts\r\n    */\r\n    function endCrowdsale()\r\n        external\r\n        whenAccessAllowed\r\n        onlyOwner\r\n        onlyDuring(Status.started)\r\n    {\r\n        emit StatusChanged(status, Status.ended);\r\n        status = Status.ended;\r\n        if(_isGoalReached()) {\r\n            vault.close();\r\n        } else {\r\n            vault.enableRefunds();\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev can be called in ongoing Crowdsale\r\n    */\r\n    function pauseCrowdsale()\r\n        external\r\n        onlySupervisor\r\n        onlyDuring(Status.started)\r\n    {\r\n        emit StatusChanged(status, Status.paused);\r\n        status = Status.paused;\r\n    }\r\n\r\n    /*\r\n    * @dev if problem was fixed, Crowdsale can resume\r\n    */\r\n    function resumeCrowdsale()\r\n        external\r\n        onlySupervisor\r\n        onlyDuring(Status.paused)\r\n    {\r\n        emit StatusChanged(status, Status.started);\r\n        status = Status.started;\r\n    }\r\n\r\n    /*\r\n    * @dev if problem cant be resolved, cancel the crowdsale\r\n    */\r\n    function cancelCrowdsale()\r\n        external\r\n        onlySupervisor\r\n        onlyDuring(Status.paused)\r\n    {\r\n        emit StatusChanged(status, Status.ended);\r\n        status = Status.ended;\r\n        vault.enableRefunds();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // --------------------------- POSTCROWDSALE ------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n\r\n    /**\r\n    * @dev validate a customer and send the tokens\r\n    */\r\n    function approveInvestor(\r\n        address _beneficiary\r\n    )\r\n        external\r\n        whenAccessAllowed\r\n        onlyOwner\r\n    {\r\n        uint256 _amount = balances[_beneficiary];\r\n        require(_amount > 0);\r\n        balances[_beneficiary] = 0;\r\n        _deliverTokens(_beneficiary, _amount);\r\n    }\r\n\r\n    /*\r\n    * @dev mint tokens using an array to reduce transaction costs\r\n    */\r\n    function approveInvestors(\r\n        address[] _beneficiaries\r\n    )\r\n        external\r\n        whenAccessAllowed\r\n        onlyOwner\r\n    {\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n           require(_beneficiaries[i] != address(0));\r\n           uint256 _amount = balances[_beneficiaries[i]];\r\n           require(_amount > 0);\r\n           balances[_beneficiaries[i]] = 0;\r\n            _deliverTokens(_beneficiaries[i], _amount);\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev minting 49 percent for the platform and finishing minting\r\n    */\r\n    function mintForPlatform()\r\n        external\r\n        whenAccessAllowed\r\n        onlyOwner\r\n        onlyDuring(Status.ended)\r\n    {\r\n        uint256 _tokensForPlatform = token.totalSupply().mul(49).div(51);\r\n        require(token.mint(wallet, _tokensForPlatform));\r\n        require(token.finishMinting());\r\n    }\r\n\r\n    /*\r\n    * @dev delivers token to a certain address\r\n    */\r\n    function _deliverTokens(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        require(token.mint(_beneficiary, _tokenAmount));\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // --------------------------- SUPERVISOR ---------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev change signer if account there is problem with the account\r\n    */\r\n    function changeSigner(\r\n        address _newSigner\r\n    )\r\n        external\r\n        onlySupervisor\r\n        onlyDuring(Status.paused)\r\n    {\r\n        require(_newSigner != address(0));\r\n        emit SignerChanged(signer, _newSigner);\r\n        signer = _newSigner;\r\n    }\r\n\r\n    /*\r\n    * @dev change the state of accessAllowed bit, thus locking or freeing functions\r\n    */\r\n    function setAccess(bool value) public onlySupervisor {\r\n        require(accessAllowed != value);\r\n        emit AccessChanged(value);\r\n        accessAllowed = value;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ----------------------- Expired Crowdsale ------------------------------\r\n    // ------------------------------------------------------------------------\r\n\r\n    /*\r\n    * @dev function for everyone to enable refunds after certain time\r\n    */\r\n    function endExpiredCrowdsale() public {\r\n        require(status != Status.unstarted);\r\n        require(now > startTime + 365 days);\r\n        status = Status.ended;\r\n        if(_isGoalReached()) {\r\n            vault.close();\r\n        } else {\r\n            vault.enableRefunds();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary TokenAmountGetter {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n    * @dev get the amount of tokens corresponding to the ether amount\r\n    * @param _etherAmount amount of ether the user has invested\r\n    * @param _etherPrice price of ether in euro ca at the time of purchase\r\n    * @param _startTime starting time of the ICO\r\n    * @param _baseRate the base rate of token to ether, constant\r\n    */\r\n    function getTokenAmount(\r\n        uint256 _etherAmount,\r\n        uint256 _etherPrice,\r\n        uint256 _startTime,\r\n        uint256 _baseRate\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 _baseTokenAmount = _etherAmount.mul(_baseRate);\r\n        uint256 _timeBonus = _getTimeBonus(_baseTokenAmount, _startTime);\r\n        uint256 _amountBonus = _getAmountBonus(\r\n            _etherAmount,\r\n            _etherPrice,\r\n            _baseTokenAmount\r\n        );\r\n        uint256 _totalBonus = _timeBonus.add(_amountBonus);\r\n\r\n        uint256 _totalAmount = _baseTokenAmount.add(_totalBonus);\r\n\r\n        // another 2% on top if tokens bought in the first 24 hours\r\n        if(_startTime + 1 days > now)\r\n            _totalAmount = _totalAmount.add(_totalAmount.mul(2).div(100));\r\n\r\n        return _totalAmount;\r\n    }\r\n\r\n    /*\r\n    * @dev get time bonus for base amount, does not include 24H 2% on top\r\n    */\r\n    function _getTimeBonus(\r\n        uint256 _baseTokenAmount,\r\n        uint256 _startTime\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (now <= (_startTime + 1 weeks))\r\n            return (_baseTokenAmount.mul(20).div(100));\r\n        if (now <= (_startTime + 2 weeks))\r\n            return (_baseTokenAmount.mul(18).div(100));\r\n        if (now <= (_startTime + 3 weeks))\r\n            return (_baseTokenAmount.mul(16).div(100));\r\n        if (now <= (_startTime + 4 weeks))\r\n            return (_baseTokenAmount.mul(14).div(100));\r\n        if (now <= (_startTime + 5 weeks))\r\n            return (_baseTokenAmount.mul(12).div(100));\r\n        if (now <= (_startTime + 6 weeks))\r\n            return (_baseTokenAmount.mul(10).div(100));\r\n        if (now <= (_startTime + 7 weeks))\r\n            return (_baseTokenAmount.mul(8).div(100));\r\n        if (now <= (_startTime + 8 weeks))\r\n            return (_baseTokenAmount.mul(6).div(100));\r\n        if (now <= (_startTime + 9 weeks))\r\n            return (_baseTokenAmount.mul(4).div(100));\r\n        if (now <= (_startTime + 10 weeks))\r\n            return (_baseTokenAmount.mul(2).div(100));\r\n        return 0;\r\n    }\r\n\r\n    /*\r\n    * @dev get amount bonus for amount measured in euro, which is\r\n    *   determined by the current price and amount\r\n    */\r\n    function _getAmountBonus(\r\n        uint256 _etherAmount,\r\n        uint256 _etherPrice,\r\n        uint256 _baseTokenAmount\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 _etherAmountInEuro = _etherAmount.mul(_etherPrice).div(1 ether);\r\n        if (_etherAmountInEuro < 100000)\r\n            return 0;\r\n        if (_etherAmountInEuro >= 100000 && _etherAmountInEuro < 150000)\r\n            return (_baseTokenAmount.mul(3)).div(100);\r\n        if (_etherAmountInEuro >= 150000 && _etherAmountInEuro < 200000)\r\n            return (_baseTokenAmount.mul(6)).div(100);\r\n        if (_etherAmountInEuro >= 200000 && _etherAmountInEuro < 300000)\r\n            return (_baseTokenAmount.mul(9)).div(100);\r\n        if (_etherAmountInEuro >= 300000 && _etherAmountInEuro < 1000000)\r\n            return (_baseTokenAmount.mul(12)).div(100);\r\n        if (_etherAmountInEuro >= 1000000 && _etherAmountInEuro < 1500000)\r\n            return (_baseTokenAmount.mul(15)).div(100);\r\n        if (_etherAmountInEuro >= 1500000)\r\n            return (_baseTokenAmount.mul(20)).div(100);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_etherPrice\",\"type\":\"uint256\"}],\"name\":\"purchaseTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintForPlatform\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"approveInvestors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supervisor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accessAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"approveInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSigner\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endExpiredCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_etherPrice\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"isValidAccessMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_supervisor\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NoAccessCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"CapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"PurchaseTooSmall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"etherPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"accessAllowed\",\"type\":\"bool\"}],\"name\":\"AccessChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousSigner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"SignerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousStatus\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"StatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NoboCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000010a10582ff6381db2209b37c9a33dffb4ec98de30000000000000000000000005d23603eed3ae75e96189303547a7d8446c33de60000000000000000000000000a2deb45f039fb49b83f583cd9a93a5971d811cf0000000000000000000000007ab8b14f3fed8e124fd341158cd21b13a8daa705","Library":"","SwarmSource":"bzzr://c8ebf078d64a40f157aa2ca6c6b56e94bf12d56e9b0f0d6fa121364182ba5ef6"}]}