{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.1; /*\r\n\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n\r\n██████╗  ██████╗ ██╗   ██╗██████╗ ██╗     ███████╗    ███████╗████████╗██╗  ██╗███████╗██████╗ \r\n██╔══██╗██╔═══██╗██║   ██║██╔══██╗██║     ██╔════╝    ██╔════╝╚══██╔══╝██║  ██║██╔════╝██╔══██╗\r\n██║  ██║██║   ██║██║   ██║██████╔╝██║     █████╗      █████╗     ██║   ███████║█████╗  ██████╔╝\r\n██║  ██║██║   ██║██║   ██║██╔══██╗██║     ██╔══╝      ██╔══╝     ██║   ██╔══██║██╔══╝  ██╔══██╗\r\n██████╔╝╚██████╔╝╚██████╔╝██████╔╝███████╗███████╗    ███████╗   ██║   ██║  ██║███████╗██║  ██║\r\n╚═════╝  ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝╚══════╝    ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\r\n                                                                                               \r\n                                                                                               \r\n// ----------------------------------------------------------------------------\r\n// 'Double Ether' Token contract with following features\r\n//      => ERC20 Compliance\r\n//      => Safeguard functionality \r\n//      => selfdestruct ability by owner\r\n//      => SafeMath implementation \r\n//      => Burnable and no minting\r\n//\r\n// Name        : Double Ether\r\n// Symbol      : DET\r\n// Total supply: 100,000,000 (100 Million)\r\n// Decimals    : 18\r\n//\r\n// Copyright (c) 2018 Deteth Inc. ( https://deteth.com )\r\n// Contract designed by EtherAuthority ( https://EtherAuthority.io )\r\n// ----------------------------------------------------------------------------\r\n  \r\n*/ \r\n\r\n//*******************************************************************//\r\n//------------------------ SafeMath Library -------------------------//\r\n//*******************************************************************//\r\n    /**\r\n     * @title SafeMath\r\n     * @dev Math operations with safety checks that throw on error\r\n     */\r\n    library SafeMath {\r\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n      }\r\n    \r\n      function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n      }\r\n    \r\n      function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n      }\r\n    \r\n      function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n      }\r\n    }\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\n    contract owned {\r\n        address payable public owner;\r\n        \r\n         constructor () public {\r\n            owner = msg.sender;\r\n        }\r\n    \r\n        modifier onlyOwner {\r\n            require(msg.sender == owner);\r\n            _;\r\n        }\r\n    \r\n        function transferOwnership(address payable newOwner) onlyOwner public {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n    \r\n    interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata  _extraData) external; }\r\n\r\n\r\n//***************************************************************//\r\n//------------------ ERC20 Standard Template -------------------//\r\n//***************************************************************//\r\n    \r\n    contract TokenERC20 {\r\n        // Public variables of the token\r\n        using SafeMath for uint256;\r\n        string public name;\r\n        string public symbol;\r\n        uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\r\n        uint256 public totalSupply;\r\n        bool public safeguard = false;  //putting safeguard on will halt all non-owner functions\r\n    \r\n        // This creates an array with all balances\r\n        mapping (address => uint256) public balanceOf;\r\n        mapping (address => mapping (address => uint256)) public allowance;\r\n    \r\n        // This generates a public event on the blockchain that will notify clients\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n        // This notifies clients about the amount burnt\r\n        event Burn(address indexed from, uint256 value);\r\n    \r\n        /**\r\n         * Constrctor function\r\n         *\r\n         * Initializes contract with initial supply tokens to the creator of the contract\r\n         */\r\n        constructor (\r\n            uint256 initialSupply,\r\n            string memory tokenName,\r\n            string memory tokenSymbol\r\n        ) public {\r\n            \r\n            totalSupply = initialSupply * 1 ether;      // Update total supply with the decimal amount\r\n            uint256 halfTotalSupply = totalSupply / 2;  // Half of the totalSupply\r\n            \r\n            balanceOf[msg.sender] = halfTotalSupply;    // 50 Million tokens sent to owner\r\n            balanceOf[address(this)] = halfTotalSupply; // 50 Million tokens sent to smart contract\r\n            name = tokenName;                           // Set the name for display purposes\r\n            symbol = tokenSymbol;                       // Set the symbol for display purposes\r\n            \r\n            emit Transfer(address(0x0), msg.sender, halfTotalSupply);   // Transfer event\r\n            emit Transfer(address(0x0), address(this), halfTotalSupply);// Transfer event\r\n        }\r\n    \r\n        /**\r\n         * Internal transfer, only can be called by this contract\r\n         */\r\n        function _transfer(address _from, address _to, uint _value) internal {\r\n            require(!safeguard);\r\n            // Prevent transfer to 0x0 address. Use burn() instead\r\n            require(_to != address(0x0));\r\n            // Check if the sender has enough\r\n            require(balanceOf[_from] >= _value);\r\n            // Check for overflows\r\n            require(balanceOf[_to].add(_value) > balanceOf[_to]);\r\n            // Save this for an assertion in the future\r\n            uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n            // Subtract from the sender\r\n            balanceOf[_from] = balanceOf[_from].sub(_value);\r\n            // Add the same to the recipient\r\n            balanceOf[_to] = balanceOf[_to].add(_value);\r\n            emit Transfer(_from, _to, _value);\r\n            // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n            assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n        }\r\n    \r\n        /**\r\n         * Transfer tokens\r\n         *\r\n         * Send `_value` tokens to `_to` from your account\r\n         *\r\n         * @param _to The address of the recipient\r\n         * @param _value the amount to send\r\n         */\r\n        function transfer(address _to, uint256 _value) public returns (bool success) {\r\n            _transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * Transfer tokens from other address\r\n         *\r\n         * Send `_value` tokens to `_to` in behalf of `_from`\r\n         *\r\n         * @param _from The address of the sender\r\n         * @param _to The address of the recipient\r\n         * @param _value the amount to send\r\n         */\r\n        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n            require(!safeguard);\r\n            require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n            _transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * Set allowance for other address\r\n         *\r\n         * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n         *\r\n         * @param _spender The address authorized to spend\r\n         * @param _value the max amount they can spend\r\n         */\r\n        function approve(address _spender, uint256 _value) public\r\n            returns (bool success) {\r\n            require(!safeguard);\r\n            allowance[msg.sender][_spender] = _value;\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * Set allowance for other address and notify\r\n         *\r\n         * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n         *\r\n         * @param _spender The address authorized to spend\r\n         * @param _value the max amount they can spend\r\n         * @param _extraData some extra information to send to the approved contract\r\n         */\r\n        function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n            public\r\n            returns (bool success) {\r\n            require(!safeguard);\r\n            tokenRecipient spender = tokenRecipient(_spender);\r\n            if (approve(_spender, _value)) {\r\n                spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n                return true;\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * Destroy tokens\r\n         *\r\n         * Remove `_value` tokens from the system irreversibly\r\n         *\r\n         * @param _value the amount of money to burn\r\n         */\r\n        function burn(uint256 _value) public returns (bool success) {\r\n            require(!safeguard);\r\n            require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender\r\n            totalSupply = totalSupply.sub(_value);                      // Updates totalSupply\r\n            emit Burn(msg.sender, _value);\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * Destroy tokens from other account\r\n         *\r\n         * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n         *\r\n         * @param _from the address of the sender\r\n         * @param _value the amount of money to burn\r\n         */\r\n        function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n            require(!safeguard);\r\n            require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n            require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n            balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the targeted balance\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);             // Subtract from the sender's allowance\r\n            totalSupply = totalSupply.sub(_value);                              // Update totalSupply\r\n            emit  Burn(_from, _value);\r\n            return true;\r\n        }\r\n        \r\n    }\r\n    \r\n//*******************************************************************************//\r\n//---------------------  DOUBLE ETHER MAIN CODE STARTS HERE ---------------------//\r\n//*******************************************************************************//\r\n    \r\n    contract DoubleEther is owned, TokenERC20 {\r\n        \r\n        \r\n        /********************************/\r\n        /* Code for the ERC20 DET Token */\r\n        /********************************/\r\n    \r\n        /* Public variables of the token */\r\n        string internal tokenName = \"Double Ether\";\r\n        string internal tokenSymbol = \"DET\";\r\n        uint256 internal initialSupply = 100000000;  //100 Million\r\n        \r\n        \r\n        /* Records for the fronzen accounts */\r\n        mapping (address => bool) public frozenAccount;\r\n        \r\n        /* This generates a public event on the blockchain that will notify clients */\r\n        event FrozenFunds(address target, bool frozen);\r\n    \r\n        /* Initializes contract with initial supply tokens to the creator of the contract */\r\n        constructor () TokenERC20(initialSupply, tokenName, tokenSymbol) public {}\r\n\r\n        /* Internal transfer, only can be called by this contract */\r\n        function _transfer(address _from, address _to, uint _value) internal {\r\n            require(!safeguard);\r\n            require (_to != address(0x0));                      // Prevent transfer to 0x0 address. Use burn() instead\r\n            require (balanceOf[_from] >= _value);               // Check if the sender has enough\r\n            require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n            require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n            require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n            balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the sender\r\n            balanceOf[_to] = balanceOf[_to].add(_value);        // Add the same to the recipient\r\n            emit Transfer(_from, _to, _value);\r\n        }\r\n        \r\n        /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n        /// @param target Address to be frozen\r\n        /// @param freeze either to freeze it or not\r\n        function freezeAccount(address target, bool freeze) onlyOwner public {\r\n                frozenAccount[target] = freeze;\r\n            emit  FrozenFunds(target, freeze);\r\n        }\r\n        \r\n        /**\r\n         * Change safeguard status on or off\r\n         *\r\n         * When safeguard is true, then all the non-owner functions will stop working.\r\n         * When safeguard is false, then all the functions will resume working back again!\r\n         */\r\n        function changeSafeguardStatus() onlyOwner public{\r\n            if (safeguard == false){\r\n                safeguard = true;\r\n            }\r\n            else{\r\n                safeguard = false;    \r\n            }\r\n        }\r\n\r\n\r\n\r\n        /*******************************************/\r\n        /* Code for the Double Ether Functionality */\r\n        /*******************************************/\r\n\r\n        \r\n        uint256 public returnPercentage = 150;  // 150% return, which is 1.5 times the amount deposited \r\n        uint256 public additionalFund = 0;\r\n        address payable[] public winnerQueueAddresses;\r\n        uint256[] public winnerQueueAmount;\r\n        \r\n        // This will log for all the deposits made by users\r\n        event Deposit(address indexed depositor, uint256 depositAmount);\r\n        \r\n        // This will log for any ether paid to users\r\n        event RewardPaid(address indexed rewardPayee, uint256 rewardAmount);\r\n        \r\n        function showPeopleInQueue() public view returns(uint256) {\r\n            return winnerQueueAmount.length;\r\n        }\r\n        \r\n        //@dev fallback function, which accepts ether\r\n        function () payable external {\r\n            require(!safeguard);\r\n            require(!frozenAccount[msg.sender]);\r\n            require(msg.value >= 0.5 ether);\r\n            \r\n            //If users send more than 3 ether, then it will consider only 3 ether, and rest goes to owner as service fee\r\n            uint256 _depositedEther;\r\n            if(msg.value >= 3 ether){\r\n                _depositedEther = 3 ether;\r\n                additionalFund += msg.value - 3 ether; \r\n            }\r\n            else{\r\n                _depositedEther = msg.value;\r\n            }\r\n            \r\n            \r\n            //following loop will send reward to one or more addresses\r\n            uint256 TotalPeopleInQueue = winnerQueueAmount.length;\r\n            for(uint256 index = 0; index < TotalPeopleInQueue; index++){\r\n                \r\n                if(winnerQueueAmount[0] <= (address(this).balance - additionalFund) ){\r\n                    \r\n                    //transfer the ether and token to leader / first position\r\n                    winnerQueueAddresses[0].transfer(winnerQueueAmount[0]);\r\n                    _transfer(address(this), winnerQueueAddresses[0], winnerQueueAmount[0]*100/returnPercentage);\r\n                    \r\n                    //this will shift one index up in both arrays, removing the person who is paid\r\n                    for (uint256 i = 0; i<winnerQueueAmount.length-1; i++){\r\n                        winnerQueueAmount[i] = winnerQueueAmount[i+1];\r\n                        winnerQueueAddresses[i] = winnerQueueAddresses[i+1];\r\n                    }\r\n                    winnerQueueAmount.length--;\r\n                    winnerQueueAddresses.length--;\r\n                }\r\n                else{\r\n                    //because there is not enough ether in contract to pay for leader, so break.\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            //Putting depositor in the queue\r\n            winnerQueueAddresses.push(msg.sender); \r\n            winnerQueueAmount.push(_depositedEther * returnPercentage / 100);\r\n            emit Deposit(msg.sender, msg.value);\r\n        }\r\n\r\n    \r\n\r\n        //Just in rare case, owner wants to transfer Ether from contract to owner address.Like owner decided to destruct this contract.\r\n        function manualWithdrawEtherAll() onlyOwner public{\r\n            address(owner).transfer(address(this).balance);\r\n        }\r\n        \r\n        //It is useful when owner wants to transfer additionalFund, which is fund sent by users more than 3 ether, or after removing any stuck address.\r\n        function manualWithdrawEtherAdditionalOnly() onlyOwner public{\r\n            additionalFund = 0;\r\n            address(owner).transfer(additionalFund);\r\n        }\r\n        \r\n        //Just in rare case, owner wants to transfer Tokens from contract to owner address\r\n        function manualWithdrawTokens(uint tokenAmount) onlyOwner public{\r\n            //no need to validate the input amount as transfer function automatically throws for invalid amounts\r\n            _transfer(address(this), address(owner), tokenAmount);\r\n        }\r\n        \r\n        //selfdestruct function. just in case owner decided to destruct this contract.\r\n        function destructContract()onlyOwner public{\r\n            selfdestruct(owner);\r\n        }\r\n        \r\n        //To remove any stuck address and un-stuck the queue. \r\n        //This often happen if user have put contract address, and contract does not receive ether.\r\n        function removeAddressFromQueue(uint256 index) onlyOwner public {\r\n            require(index <= winnerQueueAmount.length);\r\n            additionalFund +=  winnerQueueAmount[index];\r\n            //this will shift one index up in both arrays, removing the address owner specified\r\n            for (uint256 i = index; i<winnerQueueAmount.length-1; i++){\r\n                winnerQueueAmount[i] = winnerQueueAmount[i+1];\r\n                winnerQueueAddresses[i] = winnerQueueAddresses[i+1];\r\n            }\r\n            winnerQueueAmount.length--;\r\n            winnerQueueAddresses.length--;\r\n        } \r\n\r\n        /**\r\n         * This function removes the 35 queues. And restart the game again.\r\n         * Those people who did not get the ETH will recieve tokens multiplied by 200\r\n         * Which is: Ether amount * 200 tokens\r\n         *\r\n         * \r\n         * Ether will remained in the contract will be used toward the next round\r\n         */\r\n        function restartTheQueue() onlyOwner public {\r\n            //To become more gas cost effective, we want to process it differently when addresses are more or less than 35\r\n            uint256 arrayLength = winnerQueueAmount.length;\r\n            if(arrayLength < 35){\r\n                //if addresses are less than 35 then we will just loop through it and send tokens\r\n                for(uint256 i = 0; i < arrayLength; i++){\r\n                    _transfer(address(this), winnerQueueAddresses[i], winnerQueueAmount[i]*200*100/returnPercentage);\r\n                }\r\n                //then empty the array, and so the game will begin fresh\r\n                winnerQueueAddresses = new address payable[](0);\r\n                winnerQueueAmount = new uint256[](0);\r\n            }\r\n            else{\r\n                //if there are more than 35 addresses, then we will process it differently\r\n                //sending tokens to first 35 addresses\r\n                for(uint256 i = 0; i < 35; i++){\r\n                    //doing token transfer\r\n                    _transfer(address(this), winnerQueueAddresses[i], winnerQueueAmount[i]*200*100/returnPercentage);\r\n                    \r\n                    //shifting index one by one\r\n                    for (uint256 j = 0; j<arrayLength-i-1; j++){\r\n                        winnerQueueAmount[j] = winnerQueueAmount[j+1];\r\n                        winnerQueueAddresses[j] = winnerQueueAddresses[j+1];\r\n                    }\r\n                }\r\n                //removing total array length by 35\r\n                winnerQueueAmount.length -= 35;\r\n                winnerQueueAddresses.length -= 35;\r\n            }\r\n        }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualWithdrawEtherAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeAddressFromQueue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartTheQueue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeSafeguardStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualWithdrawEtherAdditionalOnly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showPeopleInQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destructContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeguard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnerQueueAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"additionalFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnerQueueAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"manualWithdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rewardPayee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"DoubleEther","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4183859ea200782d6519956f47a3f1ea24bcb9f1856b0cdc52942e76639e860f"}]}