{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n// last compiled with v0.4.19+commit.c4cbbb05;\r\n\r\ncontract SafeMath {\r\n  //internals\r\n\r\n  function safeMul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n\r\n  /// @return total amount of tokens\r\n  function totalSupply() public constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  mapping(address => uint256) public balances;\r\n\r\n  mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n  uint256 public totalSupply;\r\n\r\n}\r\n\r\ncontract ReserveToken is StandardToken, SafeMath {\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals = 18;\r\n  address public minter;\r\n\r\n  event Create(address account, uint amount);\r\n  event Destroy(address account, uint amount);\r\n\r\n  function ReserveToken(string name_, string symbol_) public {\r\n    name = name_;\r\n    symbol = symbol_;\r\n    minter = msg.sender;\r\n  }\r\n\r\n  function create(address account, uint amount) public {\r\n    require(msg.sender == minter);\r\n    balances[account] = safeAdd(balances[account], amount);\r\n    totalSupply = safeAdd(totalSupply, amount);\r\n    Create(account, amount);\r\n  }\r\n\r\n  function destroy(address account, uint amount) public {\r\n    require(msg.sender == minter);\r\n    require(balances[account] >= amount);\r\n    balances[account] = safeSub(balances[account], amount);\r\n    totalSupply = safeSub(totalSupply, amount);\r\n    Destroy(account, amount);\r\n  }\r\n}\r\n\r\ncontract Challenge is SafeMath {\r\n\r\n  uint public fee = 10 * (10 ** 16); // fee percentage (100% = 10 ** 18)\r\n  uint public blockPeriod = 6000; // period of blocks for waiting until certain transactions can be sent\r\n  uint public blockNumber; // block number when this challenge was initiated\r\n  bool public funded; // has the initial challenger funded the contract?\r\n  address public witnessJury; // the WitnessJury smart contract\r\n  address public token; // the token of the prize pool\r\n  address public user1; // the initial challenger\r\n  address public user2; // the responding challenger\r\n  string public key1; // something to identify the initial challenger\r\n  string public key2; // something to identify the responding challenger\r\n  uint public amount; // the amount each challenger committed to prize pool\r\n  address public host; // the witness who agreed to host\r\n  string public hostKey; // something to identify the host\r\n  string public witnessJuryKey; // something the host used to identify the challenge specifics\r\n  uint public witnessJuryRequestNum; // the WitnessJury request number (in the WitnessJury smart contract)\r\n  uint public winner; // the winner (1 or 2)\r\n  bool public rescued; // has the contract been rescued?\r\n  bool public juryCalled; // has the jury been called?\r\n  address public referrer; // the referrer of the person who created the challenge (splits reward with host)\r\n\r\n  event NewChallenge(uint amount, address user1, string key1);\r\n  event Fund();\r\n  event Respond(address user2, string key2);\r\n  event Host(address host, string hostKey);\r\n  event SetWitnessJuryKey(uint witnessJuryRequestNum, string witnessJuryKey);\r\n  event RequestJury();\r\n  event Resolve(uint winner, bool wasContested, uint winnerAmount, uint hostAmount, uint witnessJuryAmount);\r\n  event Rescue();\r\n\r\n  function Challenge(address witnessJury_, address token_, uint amount_, address user1_, string key1_, uint blockPeriod_, address referrer_) public {\r\n    require(amount_ > 0);\r\n    blockPeriod = blockPeriod_;\r\n    witnessJury = witnessJury_;\r\n    token = token_;\r\n    user1 = user1_;\r\n    key1 = key1_;\r\n    amount = amount_;\r\n    referrer = referrer_;\r\n    blockNumber = block.number;\r\n    NewChallenge(amount, user1, key1);\r\n  }\r\n\r\n  function fund() public {\r\n    // remember to call approve() on the token first...\r\n    require(!funded);\r\n    require(!rescued);\r\n    require(msg.sender == user1);\r\n    require(Token(token).transferFrom(user1, this, amount));\r\n    funded = true;\r\n    blockNumber = block.number;\r\n    Fund();\r\n  }\r\n\r\n  function respond(address user2_, string key2_) public {\r\n    // remember to call approve() on the token first...\r\n    require(user2 == 0x0);\r\n    require(msg.sender == user2_);\r\n    require(funded);\r\n    require(!rescued);\r\n    user2 = user2_;\r\n    key2 = key2_;\r\n    blockNumber = block.number;\r\n    require(Token(token).transferFrom(user2, this, amount));\r\n    Respond(user2, key2);\r\n  }\r\n\r\n  function host(string hostKey_) public {\r\n    require(host == 0x0);\r\n    require(!rescued);\r\n    host = msg.sender;\r\n    hostKey = hostKey_;\r\n    blockNumber = block.number;\r\n    Host(host, hostKey);\r\n  }\r\n\r\n  function setWitnessJuryKey(string witnessJuryKey_) public {\r\n    require(witnessJuryRequestNum == 0);\r\n    require(msg.sender == host);\r\n    require(!rescued);\r\n    witnessJuryRequestNum = WitnessJury(witnessJury).numRequests() + 1;\r\n    witnessJuryKey = witnessJuryKey_;\r\n    blockNumber = block.number;\r\n    WitnessJury(witnessJury).newRequest(witnessJuryKey, this);\r\n    SetWitnessJuryKey(witnessJuryRequestNum, witnessJuryKey);\r\n  }\r\n\r\n  function requestJury() public {\r\n    require(!juryCalled);\r\n    require(msg.sender == user1 || msg.sender == user2);\r\n    require(!rescued);\r\n    require(winner == 0);\r\n    require(WitnessJury(witnessJury).getWinner1(witnessJuryRequestNum) != 0 && WitnessJury(witnessJury).getWinner2(witnessJuryRequestNum) != 0);\r\n    juryCalled = true;\r\n    blockNumber = block.number;\r\n    WitnessJury(witnessJury).juryNeeded(witnessJuryRequestNum);\r\n    RequestJury();\r\n  }\r\n\r\n  function resolve(uint witnessJuryRequestNum_, bool juryContested, address[] majorityJurors, uint winner_, address witness1, address witness2, uint witnessJuryRewardPercentage) public {\r\n    require(winner == 0);\r\n    require(witnessJuryRequestNum_ == witnessJuryRequestNum);\r\n    require(msg.sender == witnessJury);\r\n    require(winner_ == 1 || winner_ == 2);\r\n    require(!rescued);\r\n    require(block.number > blockNumber + blockPeriod);\r\n    uint totalFee = safeMul(safeMul(amount, 2), fee) / (1 ether);\r\n    uint winnerAmount = safeSub(safeMul(amount, 2), totalFee);\r\n    uint witnessJuryAmount = safeMul(totalFee, witnessJuryRewardPercentage) / (1 ether);\r\n    uint hostAmount = safeSub(totalFee, witnessJuryAmount);\r\n    uint flipWinner = winner_ == 1 ? 2 : 1;\r\n    winner = juryContested ? flipWinner : winner_;\r\n    if (winnerAmount > 0) {\r\n      require(Token(token).transfer(winner == 1 ? user1 : user2, winnerAmount));\r\n    }\r\n    if (referrer != 0x0 && hostAmount / 2 > 0) {\r\n      require(Token(token).transfer(host, hostAmount / 2));\r\n      require(Token(token).transfer(referrer, hostAmount / 2));\r\n    } else if (referrer == 0 && hostAmount > 0) {\r\n      require(Token(token).transfer(host, hostAmount));\r\n    }\r\n    if (!juryContested && witnessJuryAmount / 2 > 0) {\r\n      require(Token(token).transfer(witness1, witnessJuryAmount / 2));\r\n      require(Token(token).transfer(witness2, witnessJuryAmount / 2));\r\n    } else if (juryContested && witnessJuryAmount / majorityJurors.length > 0) {\r\n      for (uint i = 0; i < majorityJurors.length; i++) {\r\n        require(Token(token).transfer(majorityJurors[i], witnessJuryAmount / majorityJurors.length));\r\n      }\r\n    }\r\n    uint excessBalance = Token(token).balanceOf(this);\r\n    if (excessBalance > 0) {\r\n      require(Token(token).transfer(0x0, excessBalance));\r\n    }\r\n    Resolve(winner, juryContested, winnerAmount, hostAmount, witnessJuryAmount);\r\n  }\r\n\r\n  function rescue() public {\r\n    require(!rescued);\r\n    require(funded);\r\n    require(block.number > blockNumber + blockPeriod * 10);\r\n    require(msg.sender == user1 || msg.sender == user2);\r\n    require(winner == 0);\r\n    rescued = true;\r\n    if (user2 != 0x0) {\r\n      require(Token(token).transfer(user1, amount));\r\n      require(Token(token).transfer(user2, amount));\r\n    } else {\r\n      require(Token(token).transfer(user1, amount));\r\n    }\r\n    Rescue();\r\n  }\r\n\r\n}\r\n\r\ncontract ChallengeFactory is SafeMath {\r\n\r\n  address witnessJury;\r\n  address token;\r\n\r\n  mapping(uint => Challenge) public challenges;\r\n  uint numChallenges;\r\n\r\n  event NewChallenge(address addr, uint amount, address user, string key);\r\n\r\n  function ChallengeFactory(address witnessJury_, address token_) public {\r\n    witnessJury = witnessJury_;\r\n    token = token_;\r\n  }\r\n\r\n  function newChallenge(uint amount, address user, string key, address referrer) public {\r\n    numChallenges = safeAdd(numChallenges, 1);\r\n    uint blockPeriod = 6000;\r\n    challenges[numChallenges] = new Challenge(witnessJury, token, amount, user, key, blockPeriod, referrer);\r\n    NewChallenge(address(challenges[numChallenges]), amount, user, key);\r\n  }\r\n\r\n}\r\n\r\ncontract WitnessJury is SafeMath {\r\n  mapping(address => uint) public balances; // mapping of witness address to witness balance\r\n  uint public limit = 10 ** 16; // 1% = the max percentage of the overall witness pool one person can have\r\n  uint public numWitnessesBeforeLimit = 100; // the number of witnesses before the limit starts kicking in\r\n  uint public totalBalance; // the total of all witness balances\r\n  uint public numWitnesses; // count of total witnesses with non-zero balances\r\n  uint public blockPeriod = 6000; // 1 day at 14.4 seconds per block\r\n  uint public desiredWitnesses = 2; // desired number of witnesses to fulfill a request (witness a match)\r\n  uint public desiredJurors = 3; // desired number of jurors\r\n  uint public penalty = 50 * (10 ** 16); // penalty for witnesses if jury votes yes (penalty is sent back to the witnesses)\r\n  address public token; // the token being staked by witnesses\r\n  mapping(uint => Request) public requests; // mapping of requests that are partially or completely filled\r\n  uint public numRequests; // count of total number of partially or completely filled requests\r\n  mapping(uint => uint) public requestsPerBlockGroup; // map of number of requests per block group\r\n  uint public drmVolumeCap = 10000; // after this many matches per block group, fee stops increasing\r\n  uint public drmMinFee = 25 * (10 ** 16); // minimum witness reward percentage (100% = 10 ** 18)\r\n  uint public drmMaxFee = 50 * (10 ** 16); // maximum witness reward percentage (100% = 10 ** 18)\r\n  mapping(uint => bool) public juryNeeded; // mapping of requestNum to whether the jury is needed\r\n  mapping(uint => mapping(address => bool)) public juryVoted; // mapping of requestNum to juror addresses who already voted\r\n  mapping(uint => uint) public juryYesCount; // mapping of requestNum to number of yes votes\r\n  mapping(uint => uint) public juryNoCount; // mapping of requestNum to number of no votes\r\n  mapping(uint => address[]) public juryYesVoters; // mapping of requestNum to array of yes voters\r\n  mapping(uint => address[]) public juryNoVoters; // mapping of requestNum to array of no voters\r\n\r\n  struct Request {\r\n    string key; // the key, which should contain details about the request (for example, match ID)\r\n    address witness1; // the first witness\r\n    address witness2; // the second witness\r\n    string answer1; // the first witness' answer\r\n    string answer2; // the second witness' answer\r\n    uint winner1; // the first witness' winner\r\n    uint winner2; // the second witness' winner\r\n    uint fee; // percentage of match fee that will go to witness / jury pool (100% = 10 ** 18)\r\n    address challenge; // challenge smart contract\r\n    uint blockNumber; // block number when request was made\r\n  }\r\n\r\n  event Deposit(uint amount);\r\n  event Withdraw(uint amount);\r\n  event ReduceToLimit(address witness, uint amount);\r\n  event Report(uint requestNum, string answer, uint winner);\r\n  event NewRequest(uint requestNum, string key);\r\n  event JuryNeeded(uint requestNum);\r\n  event JuryVote(uint requestNum, address juror, bool vote);\r\n  event Resolve(uint requestNum);\r\n  event JuryContested(uint requestNum);\r\n\r\n  function WitnessJury(address token_) public {\r\n    token = token_;\r\n  }\r\n\r\n  function balanceOf(address user) public constant returns(uint) {\r\n    return balances[user];\r\n  }\r\n\r\n  function reduceToLimit(address witness) public {\r\n    require(witness == msg.sender);\r\n    uint amount = balances[witness];\r\n    uint limitAmount = safeMul(totalBalance, limit) / (1 ether);\r\n    if (amount > limitAmount && numWitnesses > numWitnessesBeforeLimit) {\r\n      uint excess = safeSub(amount, limitAmount);\r\n      balances[witness] = safeSub(amount, excess);\r\n      totalBalance = safeSub(totalBalance, excess);\r\n      require(Token(token).transfer(witness, excess));\r\n      ReduceToLimit(witness, excess);\r\n    }\r\n  }\r\n\r\n  function deposit(uint amount) public {\r\n    // remember to call approve() on the token first...\r\n    require(amount > 0);\r\n    if (balances[msg.sender] == 0) {\r\n      numWitnesses = safeAdd(numWitnesses, 1);\r\n    }\r\n    balances[msg.sender] = safeAdd(balances[msg.sender], amount);\r\n    totalBalance = safeAdd(totalBalance, amount);\r\n    require(Token(token).transferFrom(msg.sender, this, amount));\r\n    Deposit(amount);\r\n  }\r\n\r\n  function withdraw(uint amount) public {\r\n    require(amount > 0);\r\n    require(amount <= balances[msg.sender]);\r\n    balances[msg.sender] = safeSub(balances[msg.sender], amount);\r\n    totalBalance = safeSub(totalBalance, amount);\r\n    if (balances[msg.sender] == 0) {\r\n      numWitnesses = safeSub(numWitnesses, 1);\r\n    }\r\n    require(Token(token).transfer(msg.sender, amount));\r\n    Withdraw(amount);\r\n  }\r\n\r\n  function isWitness(uint requestNum, address witness) public constant returns(bool) {\r\n    //random number from 0-999999999\r\n    bytes32 hash = sha256(this, requestNum, requests[requestNum].key);\r\n    uint rand = uint(sha256(requestNum, hash, witness)) % 1000000000;\r\n    return (\r\n      rand * totalBalance < 1000000000 * desiredWitnesses * balances[witness] ||\r\n      block.number > requests[requestNum].blockNumber + blockPeriod\r\n    );\r\n  }\r\n\r\n  function isJuror(uint requestNum, address juror) public constant returns(bool) {\r\n    //random number from 0-999999999\r\n    bytes32 hash = sha256(1, this, requestNum, requests[requestNum].key);\r\n    uint rand = uint(sha256(requestNum, hash, juror)) % 1000000000;\r\n    return (\r\n      rand * totalBalance < 1000000000 * desiredWitnesses * balances[juror]\r\n    );\r\n  }\r\n\r\n  function newRequest(string key, address challenge) public {\r\n    numRequests = safeAdd(numRequests, 1);\r\n    require(requests[numRequests].challenge == 0x0);\r\n    requests[numRequests].blockNumber = block.number;\r\n    requests[numRequests].challenge = challenge;\r\n    requests[numRequests].key = key;\r\n    requestsPerBlockGroup[block.number / blockPeriod] = safeAdd(requestsPerBlockGroup[block.number / blockPeriod], 1);\r\n    uint recentNumRequests = requestsPerBlockGroup[block.number / blockPeriod];\r\n    if (recentNumRequests < drmVolumeCap) {\r\n      requests[numRequests].fee = safeAdd(safeMul(safeMul(recentNumRequests, recentNumRequests), safeSub(drmMaxFee, drmMinFee)) / safeMul(drmVolumeCap, drmVolumeCap), drmMinFee);\r\n    } else {\r\n      requests[numRequests].fee = drmMaxFee;\r\n    }\r\n    NewRequest(numRequests, key);\r\n  }\r\n\r\n  function report(uint requestNum, string answer, uint winner) public {\r\n    require(requests[requestNum].challenge != 0x0);\r\n    require(requests[requestNum].witness1 == 0x0 || requests[requestNum].witness2 == 0x0);\r\n    require(requests[requestNum].witness1 != msg.sender);\r\n    require(isWitness(requestNum, msg.sender));\r\n    reportLogic(requestNum, answer, winner);\r\n    Report(requestNum, answer, winner);\r\n  }\r\n\r\n  function reportLogic(uint requestNum, string answer, uint winner) private {\r\n    reduceToLimit(msg.sender);\r\n    if (requests[requestNum].witness1 == 0x0) {\r\n      requests[requestNum].witness1 = msg.sender;\r\n      requests[requestNum].answer1 = answer;\r\n      requests[requestNum].winner1 = winner;\r\n    } else if (requests[requestNum].witness2 == 0x0) {\r\n      requests[requestNum].witness2 = msg.sender;\r\n      requests[requestNum].answer2 = answer;\r\n      requests[requestNum].winner2 = winner;\r\n    }\r\n  }\r\n\r\n  function juryNeeded(uint requestNum) public {\r\n    require(msg.sender == requests[requestNum].challenge);\r\n    require(!juryNeeded[requestNum]);\r\n    juryNeeded[requestNum] = true;\r\n    JuryNeeded(requestNum);\r\n  }\r\n\r\n  function juryVote(uint requestNum, bool vote) public {\r\n    require(!juryVoted[requestNum][msg.sender]);\r\n    require(juryNeeded[requestNum]);\r\n    require(safeAdd(juryYesCount[requestNum], juryNoCount[requestNum]) < desiredJurors);\r\n    require(isJuror(requestNum, msg.sender));\r\n    juryVoted[requestNum][msg.sender] = true;\r\n    if (vote) {\r\n      juryYesCount[requestNum] = safeAdd(juryYesCount[requestNum], 1);\r\n      juryYesVoters[requestNum].push(msg.sender);\r\n    } else {\r\n      juryNoCount[requestNum] = safeAdd(juryNoCount[requestNum], 1);\r\n      juryNoVoters[requestNum].push(msg.sender);\r\n    }\r\n    JuryVote(requestNum, msg.sender, vote);\r\n  }\r\n\r\n  function resolve(uint requestNum) public {\r\n    bool juryContested = juryYesCount[requestNum] > juryNoCount[requestNum] && safeAdd(juryYesCount[requestNum], juryNoCount[requestNum]) == desiredJurors;\r\n    Challenge(requests[requestNum].challenge).resolve(\r\n      requestNum,\r\n      juryContested,\r\n      juryYesCount[requestNum] > juryNoCount[requestNum] ? juryYesVoters[requestNum] : juryNoVoters[requestNum],\r\n      requests[requestNum].winner1,\r\n      requests[requestNum].witness1,\r\n      requests[requestNum].witness2,\r\n      requests[requestNum].fee\r\n    );\r\n    if (juryContested) {\r\n      uint penalty1 = safeMul(balances[requests[requestNum].witness1], penalty) / (1 ether);\r\n      uint penalty2 = safeMul(balances[requests[requestNum].witness2], penalty) / (1 ether);\r\n      balances[requests[requestNum].witness1] = safeSub(balances[requests[requestNum].witness1], penalty1);\r\n      balances[requests[requestNum].witness2] = safeSub(balances[requests[requestNum].witness2], penalty2);\r\n      require(Token(token).transfer(requests[requestNum].witness1, penalty1));\r\n      require(Token(token).transfer(requests[requestNum].witness2, penalty2));\r\n      JuryContested(requestNum);\r\n    }\r\n    Resolve(requestNum);\r\n  }\r\n\r\n  function getWinner1(uint requestNum) public constant returns(uint) {\r\n    return requests[requestNum].winner1;\r\n  }\r\n\r\n  function getWinner2(uint requestNum) public constant returns(uint) {\r\n    return requests[requestNum].winner2;\r\n  }\r\n\r\n  function getRequest(uint requestNum) public constant returns(string, address, address, string, string, uint, address) {\r\n    return (requests[requestNum].key,\r\n            requests[requestNum].witness1,\r\n            requests[requestNum].witness2,\r\n            requests[requestNum].answer1,\r\n            requests[requestNum].answer2,\r\n            requests[requestNum].fee,\r\n            requests[requestNum].challenge);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challenges\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"newChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"witnessJury_\",\"type\":\"address\"},{\"name\":\"token_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"}],\"name\":\"NewChallenge\",\"type\":\"event\"}]","ContractName":"ChallengeFactory","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000494d274563f2bd7433a1660be26244a84cf4b4d9000000000000000000000000af30d2a7e90d7dc361c8c4585e9bb7d2f6f15bc7","Library":"","SwarmSource":"bzzr://2b85424e21c80ae8ad8b5dbb082a2da4447a570af9ffe2aea7377f2e91258c42"}]}