{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @dev Pulled from OpenZeppelin: https://git.io/vbaRf\r\n *   When this is in a public release we will switch to not vendoring this file\r\n *\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Extracting these values isn't possible without assembly\r\n    // solhint-disable no-inline-assembly\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SigningLogic is contract implementing signature recovery from typed data signatures\r\n * @notice Recovers signatures based on the SignTypedData implementation provided by ethSigUtil\r\n * @dev This contract is inherited by other contracts.\r\n */\r\ncontract SigningLogic {\r\n\r\n  // Signatures contain a nonce to make them unique. usedSignatures tracks which signatures\r\n  //  have been used so they can't be replayed\r\n  mapping (bytes32 => bool) public usedSignatures;\r\n\r\n  function burnSignatureDigest(bytes32 _signatureDigest, address _sender) internal {\r\n    bytes32 _txDataHash = keccak256(abi.encode(_signatureDigest, _sender));\r\n    require(!usedSignatures[_txDataHash], \"Signature not unique\");\r\n    usedSignatures[_txDataHash] = true;\r\n  }\r\n\r\n  bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n  );\r\n\r\n  bytes32 constant ATTESTATION_REQUEST_TYPEHASH = keccak256(\r\n    \"AttestationRequest(bytes32 dataHash,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ADD_ADDRESS_TYPEHASH = keccak256(\r\n    \"AddAddress(address addressToAdd,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant REMOVE_ADDRESS_TYPEHASH = keccak256(\r\n    \"RemoveAddress(address addressToRemove,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant PAY_TOKENS_TYPEHASH = keccak256(\r\n    \"PayTokens(address sender,address receiver,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant RELEASE_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"ReleaseTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ATTEST_FOR_TYPEHASH = keccak256(\r\n    \"AttestFor(address subject,address requester,uint256 reward,bytes32 dataHash,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant CONTEST_FOR_TYPEHASH = keccak256(\r\n    \"ContestFor(address requester,uint256 reward,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant REVOKE_ATTESTATION_FOR_TYPEHASH = keccak256(\r\n    \"RevokeAttestationFor(bytes32 link,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant VOTE_FOR_TYPEHASH = keccak256(\r\n    \"VoteFor(uint16 choice,address voter,bytes32 nonce,address poll)\"\r\n  );\r\n\r\n  bytes32 constant LOCKUP_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"LockupTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 DOMAIN_SEPARATOR;\r\n\r\n  constructor (string name, string version, uint256 chainId) public {\r\n    DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n      name: name,\r\n      version: version,\r\n      chainId: chainId,\r\n      verifyingContract: this\r\n    }));\r\n  }\r\n\r\n  struct EIP712Domain {\r\n      string  name;\r\n      string  version;\r\n      uint256 chainId;\r\n      address verifyingContract;\r\n  }\r\n\r\n  function hash(EIP712Domain eip712Domain) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      EIP712DOMAIN_TYPEHASH,\r\n      keccak256(bytes(eip712Domain.name)),\r\n      keccak256(bytes(eip712Domain.version)),\r\n      eip712Domain.chainId,\r\n      eip712Domain.verifyingContract\r\n    ));\r\n  }\r\n\r\n  struct AttestationRequest {\r\n      bytes32 dataHash;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AttestationRequest request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTESTATION_REQUEST_TYPEHASH,\r\n      request.dataHash,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AddAddress {\r\n      address addressToAdd;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AddAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ADD_ADDRESS_TYPEHASH,\r\n      request.addressToAdd,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct RemoveAddress {\r\n      address addressToRemove;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RemoveAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REMOVE_ADDRESS_TYPEHASH,\r\n      request.addressToRemove,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct PayTokens {\r\n      address sender;\r\n      address receiver;\r\n      uint256 amount;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(PayTokens request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      PAY_TOKENS_TYPEHASH,\r\n      request.sender,\r\n      request.receiver,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AttestFor {\r\n      address subject;\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 dataHash;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(AttestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTEST_FOR_TYPEHASH,\r\n      request.subject,\r\n      request.requester,\r\n      request.reward,\r\n      request.dataHash,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct ContestFor {\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(ContestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      CONTEST_FOR_TYPEHASH,\r\n      request.requester,\r\n      request.reward,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct RevokeAttestationFor {\r\n      bytes32 link;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RevokeAttestationFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REVOKE_ATTESTATION_FOR_TYPEHASH,\r\n      request.link,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct VoteFor {\r\n      uint16 choice;\r\n      address voter;\r\n      bytes32 nonce;\r\n      address poll;\r\n  }\r\n\r\n  function hash(VoteFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      VOTE_FOR_TYPEHASH,\r\n      request.choice,\r\n      request.voter,\r\n      request.nonce,\r\n      request.poll\r\n    ));\r\n  }\r\n\r\n  struct LockupTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(LockupTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      LOCKUP_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct ReleaseTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(ReleaseTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      RELEASE_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  function generateRequestAttestationSchemaHash(\r\n    bytes32 _dataHash,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestationRequest(\r\n          _dataHash,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAddAddressSchemaHash(\r\n    address _addressToAdd,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AddAddress(\r\n          _addressToAdd,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRemoveAddressSchemaHash(\r\n    address _addressToRemove,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RemoveAddress(\r\n          _addressToRemove,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generatePayTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(PayTokens(\r\n          _sender,\r\n          _receiver,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestFor(\r\n          _subject,\r\n          _requester,\r\n          _reward,\r\n          _dataHash,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ContestFor(\r\n          _requester,\r\n          _reward,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRevokeAttestationForDelegationSchemaHash(\r\n    bytes32 _link,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RevokeAttestationFor(\r\n          _link,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(VoteFor(\r\n          _choice,\r\n          _voter,\r\n          _nonce,\r\n          _poll\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(LockupTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateReleaseTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ReleaseTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function recoverSigner(bytes32 _hash, bytes _sig) internal pure returns (address) {\r\n    address signer = ECRecovery.recover(_hash, _sig);\r\n    require(signer != address(0));\r\n\r\n    return signer;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Initializable\r\n * @dev The Initializable contract has an initializer address, and provides basic authorization control\r\n * only while in initialization mode. Once changed to production mode the inializer loses authority\r\n */\r\ncontract Initializable {\r\n  address public initializer;\r\n  bool public initializing;\r\n\r\n  event InitializationEnded();\r\n\r\n  /**\r\n   * @dev The Initializable constructor sets the initializer to the provided address\r\n   */\r\n  constructor(address _initializer) public {\r\n    initializer = _initializer;\r\n    initializing = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyDuringInitialization() {\r\n    require(msg.sender == initializer, 'Method can only be called by initializer');\r\n    require(initializing, 'Method can only be called during initialization');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the initializer to end the initialization period\r\n   */\r\n  function endInitialization() public onlyDuringInitialization {\r\n    initializing = false;\r\n    emit InitializationEnded();\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Bloom account registry\r\n * @notice Account Registry Logic allows users to link multiple addresses to the same owner\r\n *\r\n */\r\ncontract AccountRegistryLogic is Initializable, SigningLogic {\r\n  /**\r\n   * @notice The AccountRegistry constructor configures the signing logic implementation\r\n   */\r\n  constructor(\r\n    address _initializer\r\n  ) public Initializable(_initializer) SigningLogic(\"Bloom Account Registry\", \"2\", 1) {}\r\n\r\n  event AddressLinked(address indexed currentAddress, address indexed newAddress, uint256 indexed linkId);\r\n  event AddressUnlinked(address indexed addressToRemove);\r\n\r\n  // Counter to generate unique link Ids\r\n  uint256 linkCounter;\r\n  mapping(address => uint256) public linkIds;\r\n\r\n  /**\r\n   * @notice Add an address to an existing id on behalf of a user to pay the gas costs\r\n   * @param _currentAddress Address to which user wants to link another address. May currently be linked to another address\r\n   * @param _currentAddressSig Signed message from address currently associated with account confirming intention\r\n   * @param _newAddress Address to add to account. Cannot currently be linked to another address\r\n   * @param _newAddressSig Signed message from new address confirming ownership by the sender\r\n   * @param _nonce hex string used when generating sigs to make them one time use\r\n   */\r\n  function linkAddresses(\r\n    address _currentAddress,\r\n    bytes _currentAddressSig,\r\n    address _newAddress,\r\n    bytes _newAddressSig,\r\n    bytes32 _nonce\r\n    ) external {\r\n      // Confirm newAddress is not linked to another account\r\n      require(linkIds[_newAddress] == 0);\r\n      // Confirm new address is signed by current address and is unused\r\n      validateLinkSignature(_currentAddress, _newAddress, _nonce, _currentAddressSig);\r\n\r\n      // Confirm current address is signed by new address and is unused\r\n      validateLinkSignature(_newAddress, _currentAddress, _nonce, _newAddressSig);\r\n\r\n      // Get linkId of current address if exists. Otherwise use incremented linkCounter\r\n      if (linkIds[_currentAddress] == 0) {\r\n        linkIds[_currentAddress] = ++linkCounter;\r\n      }\r\n      linkIds[_newAddress] = linkIds[_currentAddress];\r\n\r\n      emit AddressLinked(_currentAddress, _newAddress, linkIds[_currentAddress]);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove an address from a link relationship\r\n   * @param _addressToRemove Address to unlink from all other addresses\r\n   * @param _unlinkSignature Signed message from address currently associated with account confirming intention to unlink\r\n   * @param _nonce hex string used when generating sigs to make them one time use\r\n   */\r\n  function unlinkAddress(\r\n    address _addressToRemove,\r\n    bytes32 _nonce,\r\n    bytes _unlinkSignature\r\n  ) external {\r\n    // Confirm unlink request is signed by sender and is unused\r\n    validateUnlinkSignature(_addressToRemove, _nonce, _unlinkSignature);\r\n    linkIds[_addressToRemove] = 0;\r\n\r\n    emit AddressUnlinked(_addressToRemove);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify link signature is valid and unused V\r\n   * @param _currentAddress Address signing intention to link\r\n   * @param _addressToAdd Address being linked\r\n   * @param _nonce Unique nonce for this request\r\n   * @param _linkSignature Signature of address a\r\n   */\r\n  function validateLinkSignature(\r\n    address _currentAddress,\r\n    address _addressToAdd,\r\n    bytes32 _nonce,\r\n    bytes _linkSignature\r\n  ) private {\r\n    bytes32 _signatureDigest = generateAddAddressSchemaHash(_addressToAdd, _nonce);\r\n    require(_currentAddress == recoverSigner(_signatureDigest, _linkSignature));\r\n    burnSignatureDigest(_signatureDigest, _currentAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify unlink signature is valid and unused \r\n   * @param _addressToRemove Address being unlinked\r\n   * @param _nonce Unique nonce for this request\r\n   * @param _unlinkSignature Signature of senderAddress\r\n   */\r\n  function validateUnlinkSignature(\r\n    address _addressToRemove,\r\n    bytes32 _nonce,\r\n    bytes _unlinkSignature\r\n  ) private {\r\n\r\n    // require that address to remove is currently linked to senderAddress\r\n    require(linkIds[_addressToRemove] != 0, \"Address does not have active link\");\r\n\r\n    bytes32 _signatureDigest = generateRemoveAddressSchemaHash(_addressToRemove, _nonce);\r\n\r\n    require(_addressToRemove == recoverSigner(_signatureDigest, _unlinkSignature));\r\n    burnSignatureDigest(_signatureDigest, _addressToRemove);\r\n  }\r\n\r\n  /**\r\n   * @notice Submit link completed prior to deployment of this contract\r\n   * @dev Gives initializer privileges to write links during the initialization period without signatures\r\n   * @param _currentAddress Address to which user wants to link another address. May currently be linked to another address\r\n   * @param _newAddress Address to add to account. Cannot currently be linked to another address\r\n   */\r\n  function migrateLink(\r\n    address _currentAddress,\r\n    address _newAddress\r\n  ) external onlyDuringInitialization {\r\n    // Confirm newAddress is not linked to another account\r\n    require(linkIds[_newAddress] == 0);\r\n\r\n    // Get linkId of current address if exists. Otherwise use incremented linkCounter\r\n    if (linkIds[_currentAddress] == 0) {\r\n      linkIds[_currentAddress] = ++linkCounter;\r\n    }\r\n    linkIds[_newAddress] = linkIds[_currentAddress];\r\n\r\n    emit AddressLinked(_currentAddress, _newAddress, linkIds[_currentAddress]);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_currentAddress\",\"type\":\"address\"},{\"name\":\"_currentAddressSig\",\"type\":\"bytes\"},{\"name\":\"_newAddress\",\"type\":\"address\"},{\"name\":\"_newAddressSig\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"linkAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentAddress\",\"type\":\"address\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"migrateLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToRemove\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"name\":\"_unlinkSignature\",\"type\":\"bytes\"}],\"name\":\"unlinkAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"linkIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endInitialization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initializer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"currentAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"linkId\",\"type\":\"uint256\"}],\"name\":\"AddressLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addressToRemove\",\"type\":\"address\"}],\"name\":\"AddressUnlinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitializationEnded\",\"type\":\"event\"}]","ContractName":"AccountRegistryLogic","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000028c7ba752fd214a54ea25f075ab459ab17bd5fd2","Library":"ECRecovery:7a75cb349d9a9d4c2d3eb8a22cb3090222d8557b","SwarmSource":"bzzr://7694bdb87cd3deba57121013253434badb51b9ecefbe73a7a8974286bb91a680"}]}