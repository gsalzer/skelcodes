{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n// expansion on original contract from dav's stronghands contract sac3d\r\n// the real OG \r\n\r\n// expansion Slaughter3D Coded by spielley \r\n\r\n// now reworked with new refund line model \r\n//  and able to force someone into a match if they hold enough balance\r\n\r\n// Thank you for playing Spielleys contract creations.\r\n// spielley is not liable for any contract bugs and exploits known or unknown.\r\n\r\n// this games dev fee gets shared in SPASM\r\n// check it out at: https://etherscan.io/address/0xfaae60f2ce6491886c9f7c9356bd92f688ca66a1#code\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\ncontract Slaughter3D is Owned {\r\n    using SafeMath for uint;\r\n    struct Stage {\r\n        uint8 numberOfPlayers;\r\n        uint256 blocknumber;\r\n        bool finalized;\r\n        mapping (uint8 => address) slotXplayer;\r\n        mapping (address => bool) players;\r\n        mapping (uint8 => address) setMN;\r\n        \r\n    }\r\n    \r\n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\r\n    Slaughter3DInterface constant old = Slaughter3DInterface(0xA76daa02C1A6411c6c368f3A59f4f2257a460006);\r\n    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\r\n    uint256 constant private P3D_SHARE = 0.005 ether;\r\n    \r\n    uint8 constant public MAX_PLAYERS_PER_STAGE = 2;\r\n    uint256 constant public OFFER_SIZE = 0.1 ether;\r\n    uint256 public Refundpot;\r\n    \r\n    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\r\n    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \r\n    uint256 public winningsPerRound = 0.185 ether;\r\n    \r\n    mapping(address => uint256) public playerVault;\r\n    mapping(uint256 => Stage) public stages;\r\n    mapping(uint256 => address) public RefundWaitingLine;\r\n    mapping(uint256 => address) public Loser;\r\n    uint256 public  NextInLine;//next person to be refunded\r\n    uint256 public  NextAtLineEnd;//next spot to add loser\r\n    uint256 private numberOfFinalizedStages;\r\n    \r\n    uint256 public numberOfStages;\r\n    \r\n    event SacrificeOffered(address indexed player);\r\n    event SacrificeChosen(address indexed sarifice);\r\n    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\r\n    event StageInvalidated(uint256 indexed stage);\r\n    \r\n    uint256 public NextInLineOld;\r\n    uint256 public lastToPayOld;\r\n    // UI view functions\r\n    function previousstageloser()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return (Loser[numberOfFinalizedStages]);\r\n    }\r\n    function previousstageplayer1()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return (stages[numberOfFinalizedStages].slotXplayer[0]);\r\n    }\r\n    function previousstageplayer2()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return (stages[numberOfFinalizedStages].slotXplayer[1]);\r\n    }\r\n    function currentstageplayer1()\r\n        public\r\n        view\r\n        returns( address )\r\n    {\r\n        return (stages[numberOfStages].slotXplayer[0]);\r\n    }\r\n    function currentstageplayer2()\r\n        public\r\n        view\r\n        returns( address )\r\n    {\r\n        return (stages[numberOfStages].slotXplayer[1]);\r\n    }\r\n\r\n    function checkstatus()// true = ready to vallidate\r\n        public\r\n        view\r\n        returns(bool )\r\n    {\r\n        bool check;\r\n        if(numberOfStages >= numberOfFinalizedStages)\r\n        {\r\n            if(!stages[numberOfFinalizedStages].finalized && stages[numberOfFinalizedStages].numberOfPlayers < MAX_PLAYERS_PER_STAGE && stages[numberOfFinalizedStages].blocknumber != 0)\r\n            {\r\n                check = true;\r\n            }\r\n        }\r\n        return (check);\r\n    }\r\n    \r\n    function nextonetogetpaid()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        \r\n        return (RefundWaitingLine[NextInLine]);\r\n    }\r\n   function contractownsthismanyP3D()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (p3dContract.balanceOf(address(this)));\r\n    }\r\n    // expansion functions\r\n    // new refundline model\r\n    uint256 public pointMultiplier = 10e18;\r\nstruct Account {\r\n  uint balance;\r\n  uint lastDividendPoints;\r\n}\r\nmapping(address => uint256) public balances;\r\nuint256 public _totalSupply;\r\nmapping(address=>Account) public accounts;\r\nuint public ethtotalSupply;\r\nuint public totalDividendPoints;\r\nuint public unclaimedDividends;\r\n\r\nfunction dividendsOwing(address account) public view returns(uint256) {\r\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\r\n  return (balances[account] * newDividendPoints) / pointMultiplier;\r\n}\r\nmodifier updateAccount(address account) {\r\n  uint256 owing = dividendsOwing(account);\r\n  if(owing > balances[account]){balances[account] = owing;}\r\n  if(owing > 0 ) {\r\n    unclaimedDividends = unclaimedDividends.sub(owing);\r\n    \r\n    playerVault[account] = playerVault[account].add(owing);\r\n    balances[account] = balances[account].sub(owing);\r\n    _totalSupply = _totalSupply.sub(owing);\r\n  }\r\n  accounts[account].lastDividendPoints = totalDividendPoints;\r\n  _;\r\n}\r\nfunction () external payable{}\r\nfunction fetchdivs(address toUpdate) public updateAccount(toUpdate){}\r\n\r\nfunction disburse() public  payable {\r\n    uint256 amount = msg.value;\r\n    \r\n  totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\r\n  //ethtotalSupply = ethtotalSupply.add(amount);\r\n unclaimedDividends = unclaimedDividends.add(amount);\r\n}\r\n\r\n    //fetch P3D divs\r\n    function DivsToRefundpot ()public\r\n    {\r\n        //allocate p3d dividends to contract \r\n            uint256 dividends = p3dContract.myDividends(true);\r\n            require(dividends > 0);\r\n            uint256 base = dividends.div(100);\r\n            p3dContract.withdraw();\r\n            SPASM_.disburse.value(base.mul(5))();// to dev fee sharing contract SPASM\r\n            Refundpot = Refundpot.add(base.mul(95));\r\n            \r\n    }\r\n    //Donate to losers\r\n    function DonateToLosers ()public payable\r\n    {\r\n            require(msg.value > 0);\r\n            Refundpot = Refundpot.add(msg.value);\r\n\r\n    }\r\n    // legacystarting refunds from old contract\r\n    function legacyStart(uint256 amountProgress) onlyOwner public{\r\n        uint256 nextUp = NextInLineOld;\r\n        for(uint i=0; i< amountProgress; i++)\r\n        {\r\n        address torefund = old.RefundWaitingLine(nextUp + i);\r\n        i++;\r\n        balances[torefund] = balances[torefund].add(0.1 ether);\r\n        }\r\n        NextInLineOld += i;\r\n        _totalSupply = _totalSupply.add(i.mul(0.1 ether));\r\n    }\r\n    // next loser payout distribution\r\n    function Payoutnextrefund ()public\r\n    {\r\n         \r\n        require(Refundpot > 0.00001 ether);\r\n        uint256 amount = Refundpot;\r\n    Refundpot = 0;\r\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\r\n    unclaimedDividends = unclaimedDividends.add(amount);\r\n    }\r\n    \r\n    // Sac dep\r\n    modifier isValidOffer()\r\n    {\r\n        require(msg.value == OFFER_SIZE);\r\n        _;\r\n    }\r\n    \r\n    modifier canPayFromVault()\r\n    {\r\n        require(playerVault[msg.sender] >= OFFER_SIZE);\r\n        _;\r\n    }\r\n    \r\n    modifier hasEarnings()\r\n    {\r\n        require(playerVault[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier prepareStage()\r\n    {\r\n        //create a new stage if current has reached max amount of players\r\n        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n           stages[numberOfStages] = Stage(0, 0, false );\r\n           numberOfStages++;\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier isNewToStage()\r\n    {\r\n        require(stages[numberOfStages - 1].players[msg.sender] == false);\r\n        _;\r\n    }\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        stages[numberOfStages] = Stage(0, 0, false);\r\n        numberOfStages++;\r\n        NextInLineOld = old.NextInLine();\r\n        lastToPayOld = 525;\r\n    }\r\n    \r\n    //function() external payable {}\r\n    \r\n    function offerAsSacrifice(address MN)\r\n        external\r\n        payable\r\n        isValidOffer\r\n        prepareStage\r\n        isNewToStage\r\n    {\r\n        acceptOffer(MN);\r\n        \r\n        //try to choose a sacrifice in an already full stage (finalize a stage)\r\n        tryFinalizeStage();\r\n    }\r\n    \r\n    function offerAsSacrificeFromVault(address MN)\r\n        external\r\n        canPayFromVault\r\n        prepareStage\r\n        isNewToStage\r\n    {\r\n        playerVault[msg.sender] -= OFFER_SIZE;\r\n        \r\n        acceptOffer(MN);\r\n        \r\n        tryFinalizeStage();\r\n    }\r\n    function offerAsSacrificeFromVaultForce(address MN, address forcedToFight)\r\n        external\r\n        payable\r\n        prepareStage\r\n        \r\n    {\r\n        uint256 value = msg.value;\r\n        require(value >= 0.005 ether);\r\n        require(playerVault[forcedToFight] >= OFFER_SIZE);\r\n        require(stages[numberOfStages - 1].players[forcedToFight] == false);\r\n        playerVault[forcedToFight] -= OFFER_SIZE;\r\n        playerVault[forcedToFight] += 0.003 ether;\r\n        SPASM_.disburse.value(0.002 ether)();\r\n        //\r\n        Stage storage currentStage = stages[numberOfStages - 1];\r\n        \r\n        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\r\n        \r\n        address player = forcedToFight;\r\n        \r\n        //add player to current stage\r\n        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\r\n        currentStage.numberOfPlayers++;\r\n        currentStage.players[player] = true;\r\n        currentStage.setMN[currentStage.numberOfPlayers] = MN;\r\n        emit SacrificeOffered(player);\r\n        \r\n        //add blocknumber to current stage when the last player is added\r\n        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n            currentStage.blocknumber = block.number;\r\n        }\r\n        //\r\n        tryFinalizeStage();\r\n        \r\n\r\n    }\r\n    function withdraw()\r\n        external\r\n        hasEarnings\r\n    {\r\n        tryFinalizeStage();\r\n        \r\n        uint256 amount = playerVault[msg.sender];\r\n        playerVault[msg.sender] = 0;\r\n        \r\n        emit EarningsWithdrawn(msg.sender, amount); \r\n        \r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function myEarnings()\r\n        external\r\n        view\r\n        hasEarnings\r\n        returns(uint256)\r\n    {\r\n        return playerVault[msg.sender];\r\n    }\r\n    \r\n    function currentPlayers()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return stages[numberOfStages - 1].numberOfPlayers;\r\n    }\r\n    \r\n    function acceptOffer(address MN)\r\n        private\r\n    {\r\n        Stage storage currentStage = stages[numberOfStages - 1];\r\n        \r\n        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\r\n        \r\n        address player = msg.sender;\r\n        \r\n        //add player to current stage\r\n        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\r\n        currentStage.numberOfPlayers++;\r\n        currentStage.players[player] = true;\r\n        currentStage.setMN[currentStage.numberOfPlayers] = MN;\r\n        emit SacrificeOffered(player);\r\n        \r\n        //add blocknumber to current stage when the last player is added\r\n        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n            currentStage.blocknumber = block.number;\r\n        }\r\n        \r\n    }\r\n    \r\n    function tryFinalizeStage()\r\n        public\r\n    {\r\n        assert(numberOfStages >= numberOfFinalizedStages);\r\n        \r\n        //there are no stages to finalize\r\n        if(numberOfStages == numberOfFinalizedStages) {return;}\r\n        \r\n        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\r\n        \r\n        assert(!stageToFinalize.finalized);\r\n        \r\n        //stage is not ready to be finalized\r\n        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\r\n        \r\n        assert(stageToFinalize.blocknumber != 0);\r\n        \r\n        //check if blockhash can be determined\r\n        if(block.number - 256 <= stageToFinalize.blocknumber) {\r\n            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\r\n            if(block.number == stageToFinalize.blocknumber) {return;}\r\n                \r\n            //determine sacrifice\r\n            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\r\n           \r\n            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\r\n            Loser[numberOfFinalizedStages] = sacrifice;\r\n            emit SacrificeChosen(sacrifice);\r\n            \r\n            //allocate winnings to survivors\r\n            allocateSurvivorWinnings(sacrifice);\r\n           \r\n            //add sacrifice to refund waiting line\r\n            fetchdivs(sacrifice);\r\n            balances[sacrifice] = balances[sacrifice].add(0.1 ether);\r\n            _totalSupply += 0.1 ether;\r\n            \r\n            \r\n            //add 0.005 ether to Refundpot\r\n            Refundpot = Refundpot.add(0.005 ether);\r\n            //purchase p3d (using ref) \r\n            p3dContract.buy.value(0.004 ether)(stageToFinalize.setMN[1]);\r\n            p3dContract.buy.value(0.004 ether)(stageToFinalize.setMN[2]);\r\n            SPASM_.disburse.value(0.002 ether)();\r\n            \r\n        } else {\r\n            invalidateStage(numberOfFinalizedStages);\r\n            \r\n            emit StageInvalidated(numberOfFinalizedStages);\r\n        }\r\n        //finalize stage\r\n        stageToFinalize.finalized = true;\r\n        numberOfFinalizedStages++;\r\n    }\r\n    \r\n    function allocateSurvivorWinnings(address sacrifice)\r\n        private\r\n    {\r\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\r\n            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\r\n            if(survivor != sacrifice) {\r\n                playerVault[survivor] += winningsPerRound;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function invalidateStage(uint256 stageIndex)\r\n        private\r\n    {\r\n        Stage storage stageToInvalidate = stages[stageIndex];\r\n        \r\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\r\n            address player = stageToInvalidate.slotXplayer[i];\r\n            playerVault[player] += OFFER_SIZE;\r\n        }\r\n    }\r\n}\r\n\r\ninterface HourglassInterface {\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function withdraw() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n}\r\ninterface SPASMInterface  {\r\n    function() payable external;\r\n    function disburse() external  payable;\r\n}\r\ninterface Slaughter3DInterface {\r\n    function RefundWaitingLine(uint256 index) external view returns(address);\r\n    function NextInLine() external view returns(uint256);\r\n    function NextAtLineEnd() external view returns(uint256);\r\n}\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"DonateToLosers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractownsthismanyP3D\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefundWaitingLine\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentstageplayer1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousstageloser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividendPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toUpdate\",\"type\":\"address\"}],\"name\":\"fetchdivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextAtLineEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousstageplayer2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OFFER_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextInLineOld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lastDividendPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pointMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MN\",\"type\":\"address\"}],\"name\":\"offerAsSacrifice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentstageplayer2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkstatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DivsToRefundpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendsOwing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"name\":\"numberOfPlayers\",\"type\":\"uint8\"},{\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningsPerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousstageplayer1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextInLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MN\",\"type\":\"address\"},{\"name\":\"forcedToFight\",\"type\":\"address\"}],\"name\":\"offerAsSacrificeFromVaultForce\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethtotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tryFinalizeStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disburse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Refundpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfStages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Payoutnextrefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountProgress\",\"type\":\"uint256\"}],\"name\":\"legacyStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PLAYERS_PER_STAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastToPayOld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextonetogetpaid\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MN\",\"type\":\"address\"}],\"name\":\"offerAsSacrificeFromVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Loser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"SacrificeOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sarifice\",\"type\":\"address\"}],\"name\":\"SacrificeChosen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EarningsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"StageInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Slaughter3D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c49dd0dda8afb47bdaa264f0b99a78f4b95d553723928a087292303e8f4216a2"}]}