{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n// Project: token ALE, http://alehub.io\r\n// v1, 2018-12-13\r\n// Full compatibility with ERC20.\r\n// Token with special add. properties: division into privileged (default, for all) and usual tokens (for team).\r\n\r\n// Authors: Ivan Fedorov and Dmitry Borodin (CryptoB2B)\r\n// Copying in whole or in part is prohibited.\r\n// This code is the property of CryptoB2B.io\r\n\r\ncontract IRightAndRoles {\r\n    address[][] public wallets;\r\n    mapping(address => uint16) public roles;\r\n\r\n    event WalletChanged(address indexed newWallet, address indexed oldWallet, uint8 indexed role);\r\n    event CloneChanged(address indexed wallet, uint8 indexed role, bool indexed mod);\r\n\r\n    function changeWallet(address _wallet, uint8 _role) external;\r\n    function onlyRoles(address _sender, uint16 _roleMask) view external returns(bool);\r\n}\r\n\r\ncontract RightAndRoles is IRightAndRoles {\r\n    constructor (address[] _roles) public {\r\n        uint8 len = uint8(_roles.length);\r\n        require(len > 0 &&len <16);\r\n        wallets.length = len;\r\n\r\n        for(uint8 i = 0; i < len; i++){\r\n            wallets[i].push(_roles[i]);\r\n            roles[_roles[i]] += uint16(2)**i;\r\n            emit WalletChanged(_roles[i], address(0),i);\r\n        }\r\n        \r\n    }\r\n\r\n    function changeClons(address _clon, uint8 _role, bool _mod) external {\r\n        require(wallets[_role][0] == msg.sender&&_clon != msg.sender);\r\n        emit CloneChanged(_clon,_role,_mod);\r\n        uint16 roleMask = uint16(2)**_role;\r\n        if(_mod){\r\n            require(roles[_clon]&roleMask == 0);\r\n            wallets[_role].push(_clon);\r\n        }else{\r\n            address[] storage tmp = wallets[_role];\r\n            uint8 i = 1;\r\n            for(i; i < tmp.length; i++){\r\n                if(tmp[i] == _clon) break;\r\n            }\r\n            require(i > tmp.length);\r\n            tmp[i] = tmp[tmp.length];\r\n            delete tmp[tmp.length];\r\n        }\r\n        roles[_clon] = _mod?roles[_clon]|roleMask:roles[_clon]&~roleMask;\r\n    }\r\n\r\n    function changeWallet(address _wallet, uint8 _role) external {\r\n        require(wallets[_role][0] == msg.sender || wallets[0][0] == msg.sender || (wallets[2][0] == msg.sender && _role == 0));\r\n        emit WalletChanged(wallets[_role][0],_wallet,_role);\r\n        uint16 roleMask = uint16(2)**_role;\r\n        address[] storage tmp = wallets[_role];\r\n        for(uint8 i = 0; i < tmp.length; i++){\r\n            roles[tmp[i]] = roles[tmp[i]]&~roleMask;\r\n        }\r\n        delete  wallets[_role];\r\n        tmp.push(_wallet);\r\n        roles[_wallet] = roles[_wallet]|roleMask;\r\n    }\r\n\r\n    function onlyRoles(address _sender, uint16 _roleMask) view external returns(bool) {\r\n        return roles[_sender]&_roleMask != 0;\r\n    }\r\n\r\n    function getMainWallets() view external returns(address[]){\r\n        address[] memory _wallets = new address[](wallets.length);\r\n        for(uint8 i = 0; i<wallets.length; i++){\r\n            _wallets[i] = wallets[i][0];\r\n        }\r\n        return _wallets;\r\n    }\r\n\r\n    function getCloneWallets(uint8 _role) view external returns(address[]){\r\n        return wallets[_role];\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract GuidedByRoles {\r\n    IRightAndRoles public rightAndRoles;\r\n    constructor(IRightAndRoles _rightAndRoles) public {\r\n        rightAndRoles = _rightAndRoles;\r\n    }\r\n}\r\n\r\ncontract BaseIterableDubleToken{\r\n    \r\n    uint8 public withdrawPriority;\r\n    uint8 public mixedType;\r\n    \r\n    uint256[2] public supply = [0,0];\r\n    \r\n    struct Item {\r\n        uint256 index;\r\n        uint256 value;\r\n    }\r\n    \r\n    address[][] items = [[address(0)],[address(0)]];\r\n    \r\n    mapping (uint8 => mapping (address => Item)) balances;\r\n    \r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Mint(address indexed to, uint256 value);\r\n    \r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    event changeBalance(uint8 indexed tokenType, address indexed owner, uint256 newValue);\r\n    \r\n    function totalSupply() view public returns(uint256){\r\n        return supply[0] + supply[1];\r\n    }\r\n    \r\n    function balanceOf(address _who) view public returns(uint256) {\r\n        return getBalance(0,_who) + getBalance(1,_who);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) public returns (bool){\r\n        internalTransfer(msg.sender,_to,_value);\r\n        return true;\r\n    }\r\n    \r\n    function getBalance(uint8 _type ,address _addr) view public returns(uint256){\r\n        return balances[_type][_addr].value;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        \r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n        internalTransfer(_from, _to, _value);\r\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\r\n        uint256 _tmpAllowed = allowed[msg.sender][_spender] + _addedValue;\r\n        require(_tmpAllowed >= _addedValue);\r\n\r\n        allowed[msg.sender][_spender] = _tmpAllowed;\r\n        emit Approval(msg.sender, _spender, _tmpAllowed);\r\n        return true;\r\n    }\r\n    \r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        require(allowed[msg.sender][_spender] >= _subtractedValue);\r\n        \r\n        allowed[msg.sender][_spender] -= _subtractedValue;\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n    \r\n    function internalMint(uint8 _type, address _account, uint256 _value) internal {\r\n        require(totalSupply() + _value >= _value);\r\n        supply[_type] += _value;\r\n        uint256 _tmpBalance = getBalance(_type,_account) + _value;\r\n        emit Mint(_account,_value);\r\n        setBalance(_type,_account,_tmpBalance);\r\n    }\r\n    \r\n    function internalBurn(uint8 _type, address _account, uint256 _value) internal {\r\n        uint256 _tmpBalance = getBalance(_type,_account);\r\n        require(_tmpBalance >= _value);\r\n        _tmpBalance -= _value;\r\n        emit Burn(_account,_value);\r\n        setBalance(_type,_account,_tmpBalance);\r\n    }\r\n    \r\n    function setBalance(uint8 _type ,address _addr, uint256 _value) internal {\r\n        address[] storage _items = items[_type];\r\n        Item storage _item = balances[_type][_addr];\r\n        if(_item.value == _value) return;\r\n        emit changeBalance(_type, _addr, _value);\r\n        if(_value == 0){\r\n            uint256 _index = _item.index;\r\n            delete balances[_type][_addr];\r\n            _items[_index] = _items[items.length - 1];\r\n            balances[_type][_items[_index]].index = _index;\r\n            _items.length = _items.length - 1;\r\n        }else{\r\n            if(_item.value == 0){\r\n               _item.index = _items.length; \r\n               _items.push(_addr);\r\n            }\r\n            _item.value = _value;\r\n        }\r\n    }\r\n    \r\n    function internalSend(uint8 _type, address _to, uint256 _value) internal {\r\n        uint8 _tmpType = (mixedType > 1) ? mixedType - 2 : _type;\r\n        uint256 _tmpBalance = getBalance(_tmpType,_to);\r\n        require(mixedType != 1 || _tmpBalance > 0);\r\n        if(_tmpType != _type){\r\n            supply[_type] -= _value;\r\n            supply[_tmpType] += _value;\r\n        }\r\n        setBalance(_tmpType,_to,_tmpBalance + _value);\r\n    }\r\n    \r\n    function internalTransfer(address _from, address _to, uint256 _value) internal {\r\n        require(balanceOf(_from) >= _value);\r\n        emit Transfer(_from,_to,_value);\r\n        uint8 _tmpType = withdrawPriority;\r\n        uint256 _tmpValue = _value;\r\n        uint256 _tmpBalance = getBalance(_tmpType,_from);\r\n        if(_tmpBalance < _value){\r\n            setBalance(_tmpType,_from,0);\r\n            internalSend(_tmpType,_to,_tmpBalance);\r\n            _tmpType = (_tmpType == 0) ? 1 : 0;\r\n            _tmpValue = _tmpValue - _tmpBalance;\r\n            _tmpBalance = getBalance(_tmpType,_from);\r\n        }\r\n        setBalance(_tmpType,_from,_tmpBalance - _tmpValue);\r\n        internalSend(_tmpType,_to,_tmpValue);\r\n    }\r\n    \r\n    function getBalancesList(uint8 _type) view external returns(address[] _addreses, uint256[] _values){\r\n        require(_type < 3);\r\n        address[] storage _items = items[_type];\r\n        uint256 _length = _items.length - 1;\r\n        _addreses = new address[](_length);\r\n        _values = new uint256[](_length);\r\n        for(uint256 i = 0; i < _length; i++){\r\n            _addreses[i] = _items[i + 1];\r\n            _values[i] = getBalance(_type,_items[i + 1]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract FreezingToken is BaseIterableDubleToken, GuidedByRoles {\r\n    struct freeze {\r\n    uint256 amount;\r\n    uint256 when;\r\n    }\r\n\r\n    mapping (address => freeze) freezedTokens;\r\n    \r\n    constructor(IRightAndRoles _rightAndRoles) GuidedByRoles(_rightAndRoles) public {}\r\n\r\n    function freezedTokenOf(address _beneficiary) public view returns (uint256 amount){\r\n        freeze storage _freeze = freezedTokens[_beneficiary];\r\n        if(_freeze.when < now) return 0;\r\n        return _freeze.amount;\r\n    }\r\n\r\n    function defrostDate(address _beneficiary) public view returns (uint256 Date) {\r\n        freeze storage _freeze = freezedTokens[_beneficiary];\r\n        if(_freeze.when < now) return 0;\r\n        return _freeze.when;\r\n    }\r\n\r\n    function masFreezedTokens(address[] _beneficiary, uint256[] _amount, uint256[] _when) public {\r\n        require(rightAndRoles.onlyRoles(msg.sender,3));\r\n        require(_beneficiary.length == _amount.length && _beneficiary.length == _when.length);\r\n        for(uint16 i = 0; i < _beneficiary.length; i++){\r\n            freeze storage _freeze = freezedTokens[_beneficiary[i]];\r\n            _freeze.amount = _amount[i];\r\n            _freeze.when = _when[i];\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(balanceOf(msg.sender) >= freezedTokenOf(msg.sender) + _value);\r\n        return super.transfer(_to,_value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(balanceOf(_from) >= freezedTokenOf(_from) + _value);\r\n        return super.transferFrom( _from,_to,_value);\r\n    }\r\n}\r\n\r\ncontract managedToken is FreezingToken{\r\n    uint256[2] public mintLimit = [101000000 ether, 9000000 ether]; // privileged, usual (total hardcap = 110M tokens)\r\n    uint256[2] public totalMint = [0,0];\r\n    string public constant name = \"ALE\";\r\n    string public constant symbol = \"ALE\";\r\n    uint8 public constant decimals = 18;\r\n    \r\n    constructor(IRightAndRoles _rightAndRoles) FreezingToken(_rightAndRoles) public {}\r\n    \r\n    function internalMint(uint8 _type, address _account, uint256 _value) internal {\r\n        totalMint[_type] += _value;\r\n        require(totalMint[_type] <= mintLimit[_type]);\r\n        super.internalMint(_type,_account,_value);\r\n    }\r\n    // _withdrawPriority \r\n    // first use when sending:\r\n    // 0 - privileged\r\n    // 1 - usual\r\n    // _mixedType\r\n    // 0 - mixing enabled\r\n    // 1 - mixing disabled\r\n    // 2 - mixing disabled, forced conversion into privileged\r\n    // 3 - mixing disabled, forced conversion into usual\r\n    function setup(uint8 _withdrawPriority, uint8 _mixedType) public {\r\n        require(rightAndRoles.onlyRoles(msg.sender,3));\r\n        require(_withdrawPriority < 2 && _mixedType < 4);\r\n        mixedType = _mixedType;\r\n        withdrawPriority = _withdrawPriority;\r\n    }\r\n    function massMint(uint8[] _types, address[] _addreses, uint256[] _values) public {\r\n        require(rightAndRoles.onlyRoles(msg.sender,3));\r\n        require(_types.length == _addreses.length && _addreses.length == _values.length);\r\n        for(uint256 i = 0; i < _types.length; i++){\r\n            internalMint(_types[i], _addreses[i], _values[i]);\r\n        }\r\n    }\r\n    function massBurn(uint8[] _types, address[] _addreses, uint256[] _values) public {\r\n        require(rightAndRoles.onlyRoles(msg.sender,3));\r\n        require(_types.length == _addreses.length && _addreses.length == _values.length);\r\n        for(uint256 i = 0; i < _types.length; i++){\r\n            internalBurn(_types[i], _addreses[i], _values[i]);\r\n        }\r\n    }\r\n    \r\n    function distribution(uint8 _type, address[] _addresses, uint256[] _values, uint256[] _when) public {\r\n        require(rightAndRoles.onlyRoles(msg.sender,3));\r\n        require(_addresses.length == _values.length && _values.length == _when.length);\r\n        uint256 sumValue = 0;\r\n        for(uint256 i = 0; i < _addresses.length; i++){\r\n            sumValue += _values[i]; \r\n            uint256 _value = getBalance(_type,_addresses[i]) + _values[i];\r\n            setBalance(_type,_addresses[i],_value);\r\n            emit Transfer(msg.sender, _addresses[i], _values[i]);\r\n            if(_when[i] > 0){\r\n                _value = balanceOf(_addresses[i]);\r\n                freeze storage _freeze = freezedTokens[_addresses[i]];\r\n                _freeze.amount = _value;\r\n                _freeze.when = _when[i];\r\n            }\r\n        }\r\n        uint256 _balance = getBalance(_type, msg.sender);\r\n        require(_balance >= sumValue);\r\n        setBalance(_type,msg.sender,_balance-sumValue);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Creator{\r\n\r\n    IRightAndRoles public rightAndRoles;\r\n    managedToken public token;\r\n\r\n    constructor() public{\r\n        address[] memory tmp = new address[](3);\r\n        tmp[0] = address(this);\r\n        tmp[1] = msg.sender;\r\n        tmp[2] = 0x19557B8beb5cC065fe001dc466b3642b747DA62B;\r\n\r\n        rightAndRoles = new RightAndRoles(tmp);\r\n\r\n        token=new managedToken(rightAndRoles);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rightAndRoles\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Creator","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://79786cfcbbb9e8dbf74223bf696663c680209a9f0d5277a2739499dc1a0f174d"}]}