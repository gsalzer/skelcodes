{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract ERC20 {\r\n    function balanceOf(address tokenOwner) public view returns (uint256);\r\n    function transfer(address to, uint tokens) public;\r\n    function transferFrom(address from, address to, uint256 value) public;\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\ncontract BitchipWallet is owned{\r\n    address private ETH = 0x0000000000000000000000000000000000000000;\r\n    using SafeMath for uint;\r\n    constructor() public {\r\n    }\r\n    \r\n\r\n    function() external payable {\r\n    }\r\n\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) public onlyOwner {\r\n        token.transfer(sendTo, amount);\r\n    }\r\n\r\n    function withdrawEther(uint amount, address sendTo) public onlyOwner {\r\n        address(sendTo).transfer(amount);\r\n    }\r\n    function withdraw(address[] _to, address[] _token, uint[] _amount) public onlyOwner{\r\n        for(uint x = 0; x < _amount.length ; ++x){\r\n            require(_amount[x] > 0);\r\n        }\r\n        for(uint i = 0; i < _amount.length ; ++i){\r\n            _withdraw(_token[i], _amount[i], _to[i]);\r\n        }\r\n    }\r\n\r\n    function withdrawFrom(address[] _from, address[] _to, address[] _token, uint256[] _amount) public onlyOwner{\r\n        for(uint x = 0; x < _from.length ; ++x){\r\n            require(_amount[x] > 0);\r\n        }\r\n        for(uint i = 0; i < _from.length ; ++i){\r\n            ERC20(_token[i]).transferFrom(_from[i], _to[i], _amount[i]);\r\n        }\r\n    }\r\n    \r\n    function balanceOf(address coin) public view returns (uint balance){\r\n        if (coin == ETH) {\r\n            return address(this).balance;\r\n        }else{\r\n            return ERC20(coin).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function _withdraw(address coin, uint amount, address to) internal{\r\n        if (coin == ETH) {\r\n            to.transfer(amount);\r\n        }else{\r\n            ERC20(coin).transfer(to, amount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address[]\"},{\"name\":\"_token\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"withdrawFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address[]\"},{\"name\":\"_token\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"BitchipWallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://131ea9574224d6d6f82be64881b41acd73f7314b9cec101f3f520457c1db4023"}]}