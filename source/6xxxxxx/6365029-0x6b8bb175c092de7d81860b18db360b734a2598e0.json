{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\ncontract RepublicToken is PausableToken, BurnableToken {\r\n\r\n    string public constant name = \"Republic Token\";\r\n    string public constant symbol = \"REN\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);\r\n\r\n    /// @notice The RepublicToken Constructor.\r\n    constructor() public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\r\n        /* solium-disable error-reason */\r\n        require(amount > 0);\r\n\r\n        balances[owner] = balances[owner].sub(amount);\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        emit Transfer(owner, beneficiary, amount);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @notice LinkedList is a library for a circular double linked list.\r\n */\r\nlibrary LinkedList {\r\n\r\n    /*\r\n    * @notice A permanent NULL node (0x0) in the circular double linked list.\r\n    * NULL.next is the head, and NULL.previous is the tail.\r\n    */\r\n    address public constant NULL = 0x0;\r\n\r\n    /**\r\n    * @notice A node points to the node before it, and the node after it. If\r\n    * node.previous = NULL, then the node is the head of the list. If\r\n    * node.next = NULL, then the node is the tail of the list.\r\n    */\r\n    struct Node {\r\n        bool inList;\r\n        address previous;\r\n        address next;\r\n    }\r\n\r\n    /**\r\n    * @notice LinkedList uses a mapping from address to nodes. Each address\r\n    * uniquely identifies a node, and in this way they are used like pointers.\r\n    */\r\n    struct List {\r\n        mapping (address => Node) list;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node before an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert before the target.\r\n    */\r\n    function insertBefore(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address prev = self.list[target].previous;\r\n\r\n        self.list[newNode].next = target;\r\n        self.list[newNode].previous = prev;\r\n        self.list[target].previous = newNode;\r\n        self.list[prev].next = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node after an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert after the target.\r\n    */\r\n    function insertAfter(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address n = self.list[target].next;\r\n\r\n        self.list[newNode].previous = target;\r\n        self.list[newNode].next = n;\r\n        self.list[target].next = newNode;\r\n        self.list[n].previous = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove a node from the list, and fix the previous and next\r\n    * pointers that are pointing to the removed node. Removing anode that is not\r\n    * in the list will do nothing.\r\n    *\r\n    * @param self The list being using.\r\n    * @param node The node in the list to be removed.\r\n    */\r\n    function remove(List storage self, address node) internal {\r\n        require(isInList(self, node), \"not in list\");\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n        address p = self.list[node].previous;\r\n        address n = self.list[node].next;\r\n\r\n        self.list[p].next = n;\r\n        self.list[n].previous = p;\r\n\r\n        // Deleting the node should set this value to false, but we set it here for\r\n        // explicitness.\r\n        self.list[node].inList = false;\r\n        delete self.list[node];\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the beginning of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the beginning of the list.\r\n    */\r\n    function prepend(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertBefore(self, begin(self), node);\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the end of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the end of the list.\r\n    */\r\n    function append(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertAfter(self, end(self), node);\r\n    }\r\n\r\n    function swap(List storage self, address left, address right) internal {\r\n        // isInList(left) and isInList(right) are checked in remove\r\n\r\n        address previousRight = self.list[right].previous;\r\n        remove(self, right);\r\n        insertAfter(self, left, right);\r\n        remove(self, left);\r\n        insertAfter(self, previousRight, left);\r\n    }\r\n\r\n    function isInList(List storage self, address node) internal view returns (bool) {\r\n        return self.list[node].inList;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the beginning of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the beginning of the double\r\n    * linked list.\r\n    */\r\n    function begin(List storage self) internal view returns (address) {\r\n        return self.list[NULL].next;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the end of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the end of the double linked\r\n    * list.\r\n    */\r\n    function end(List storage self) internal view returns (address) {\r\n        return self.list[NULL].previous;\r\n    }\r\n\r\n    function next(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].next;\r\n    }\r\n\r\n    function previous(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].previous;\r\n    }\r\n\r\n}\r\n\r\n/// @notice This contract stores data and funds for the DarknodeRegistry\r\n/// contract. The data / fund logic and storage have been separated to improve\r\n/// upgradability.\r\ncontract DarknodeRegistryStore is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknodes are stored in the darknode struct. The owner is the\r\n    /// address that registered the darknode, the bond is the amount of REN that\r\n    /// was transferred during registration, and the public key is the\r\n    /// encryption key that should be used when sending sensitive information to\r\n    /// the darknode.\r\n    struct Darknode {\r\n        // The owner of a Darknode is the address that called the register\r\n        // function. The owner is the only address that is allowed to\r\n        // deregister the Darknode, unless the Darknode is slashed for\r\n        // malicious behavior.\r\n        address owner;\r\n\r\n        // The bond is the amount of REN submitted as a bond by the Darknode.\r\n        // This amount is reduced when the Darknode is slashed for malicious\r\n        // behavior.\r\n        uint256 bond;\r\n\r\n        // The block number at which the Darknode is considered registered.\r\n        uint256 registeredAt;\r\n\r\n        // The block number at which the Darknode is considered deregistered.\r\n        uint256 deregisteredAt;\r\n\r\n        // The public key used by this Darknode for encrypting sensitive data\r\n        // off chain. It is assumed that the Darknode has access to the\r\n        // respective private key, and that there is an agreement on the format\r\n        // of the public key.\r\n        bytes publicKey;\r\n    }\r\n\r\n    /// Registry data.\r\n    mapping(address => Darknode) private darknodeRegistry;\r\n    LinkedList.List private darknodes;\r\n\r\n    // RepublicToken.\r\n    RepublicToken public ren;\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _ren The address of the RepublicToken contract.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _ren\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        ren = _ren;\r\n    }\r\n\r\n    /// @notice Instantiates a darknode and appends it to the darknodes\r\n    /// linked-list.\r\n    ///\r\n    /// @param _darknodeID The darknode's ID.\r\n    /// @param _darknodeOwner The darknode's owner's address\r\n    /// @param _bond The darknode's bond value\r\n    /// @param _publicKey The darknode's public key\r\n    /// @param _registeredAt The time stamp when the darknode is registered.\r\n    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\r\n    function appendDarknode(\r\n        address _darknodeID,\r\n        address _darknodeOwner,\r\n        uint256 _bond,\r\n        bytes _publicKey,\r\n        uint256 _registeredAt,\r\n        uint256 _deregisteredAt\r\n    ) external onlyOwner {\r\n        Darknode memory darknode = Darknode({\r\n            owner: _darknodeOwner,\r\n            bond: _bond,\r\n            publicKey: _publicKey,\r\n            registeredAt: _registeredAt,\r\n            deregisteredAt: _deregisteredAt\r\n        });\r\n        darknodeRegistry[_darknodeID] = darknode;\r\n        LinkedList.append(darknodes, _darknodeID);\r\n    }\r\n\r\n    /// @notice Returns the address of the first darknode in the store\r\n    function begin() external view onlyOwner returns(address) {\r\n        return LinkedList.begin(darknodes);\r\n    }\r\n\r\n    /// @notice Returns the address of the next darknode in the store after the\r\n    /// given address.\r\n    function next(address darknodeID) external view onlyOwner returns(address) {\r\n        return LinkedList.next(darknodes, darknodeID);\r\n    }\r\n\r\n    /// @notice Removes a darknode from the store and transfers its bond to the\r\n    /// owner of this contract.\r\n    function removeDarknode(address darknodeID) external onlyOwner {\r\n        uint256 bond = darknodeRegistry[darknodeID].bond;\r\n        delete darknodeRegistry[darknodeID];\r\n        LinkedList.remove(darknodes, darknodeID);\r\n        require(ren.transfer(owner, bond), \"bond transfer failed\");\r\n    }\r\n\r\n    /// @notice Updates the bond of the darknode. If the bond is being\r\n    /// decreased, the difference is sent to the owner of this contract.\r\n    function updateDarknodeBond(address darknodeID, uint256 bond) external onlyOwner {\r\n        uint256 previousBond = darknodeRegistry[darknodeID].bond;\r\n        darknodeRegistry[darknodeID].bond = bond;\r\n        if (previousBond > bond) {\r\n            require(ren.transfer(owner, previousBond - bond), \"cannot transfer bond\");\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the deregistration timestamp of a darknode.\r\n    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\r\n        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the owner of a given darknode.\r\n    function darknodeOwner(address darknodeID) external view onlyOwner returns (address) {\r\n        return darknodeRegistry[darknodeID].owner;\r\n    }\r\n\r\n    /// @notice Returns the bond of a given darknode.\r\n    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].bond;\r\n    }\r\n\r\n    /// @notice Returns the registration time of a given darknode.\r\n    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].registeredAt;\r\n    }\r\n\r\n    /// @notice Returns the deregistration time of a given darknode.\r\n    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the encryption public key of a given darknode.\r\n    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes) {\r\n        return darknodeRegistry[darknodeID].publicKey;\r\n    }\r\n}\r\n\r\n/// @notice DarknodeRegistry is responsible for the registration and\r\n/// deregistration of Darknodes.\r\ncontract DarknodeRegistry is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknode pods are shuffled after a fixed number of blocks.\r\n    /// An Epoch stores an epoch hash used as an (insecure) RNG seed, and the\r\n    /// blocknumber which restricts when the next epoch can be called.\r\n    struct Epoch {\r\n        uint256 epochhash;\r\n        uint256 blocknumber;\r\n    }\r\n\r\n    uint256 public numDarknodes;\r\n    uint256 public numDarknodesNextEpoch;\r\n    uint256 public numDarknodesPreviousEpoch;\r\n\r\n    /// Variables used to parameterize behavior.\r\n    uint256 public minimumBond;\r\n    uint256 public minimumPodSize;\r\n    uint256 public minimumEpochInterval;\r\n    address public slasher;\r\n\r\n    /// When one of the above variables is modified, it is only updated when the\r\n    /// next epoch is called. These variables store the values for the next epoch.\r\n    uint256 public nextMinimumBond;\r\n    uint256 public nextMinimumPodSize;\r\n    uint256 public nextMinimumEpochInterval;\r\n    address public nextSlasher;\r\n\r\n    /// The current and previous epoch\r\n    Epoch public currentEpoch;\r\n    Epoch public previousEpoch;\r\n\r\n    /// Republic ERC20 token contract used to transfer bonds.\r\n    RepublicToken public ren;\r\n\r\n    /// Darknode Registry Store is the storage contract for darknodes.\r\n    DarknodeRegistryStore public store;\r\n\r\n    /// @notice Emitted when a darknode is registered.\r\n    /// @param _darknodeID The darknode ID that was registered.\r\n    /// @param _bond The amount of REN that was transferred as bond.\r\n    event LogDarknodeRegistered(address _darknodeID, uint256 _bond);\r\n\r\n    /// @notice Emitted when a darknode is deregistered.\r\n    /// @param _darknodeID The darknode ID that was deregistered.\r\n    event LogDarknodeDeregistered(address _darknodeID);\r\n\r\n    /// @notice Emitted when a refund has been made.\r\n    /// @param _owner The address that was refunded.\r\n    /// @param _amount The amount of REN that was refunded.\r\n    event LogDarknodeOwnerRefunded(address _owner, uint256 _amount);\r\n\r\n    /// @notice Emitted when a new epoch has begun.\r\n    event LogNewEpoch();\r\n\r\n    /// @notice Emitted when a constructor parameter has been updated.\r\n    event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond);\r\n    event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize);\r\n    event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval);\r\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\r\n\r\n    /// @notice Only allow the owner that registered the darknode to pass.\r\n    modifier onlyDarknodeOwner(address _darknodeID) {\r\n        require(store.darknodeOwner(_darknodeID) == msg.sender, \"must be darknode owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow unregistered darknodes.\r\n    modifier onlyRefunded(address _darknodeID) {\r\n        require(isRefunded(_darknodeID), \"must be refunded or never registered\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow refundable darknodes.\r\n    modifier onlyRefundable(address _darknodeID) {\r\n        require(isRefundable(_darknodeID), \"must be deregistered for at least one epoch\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allowed registered nodes without a pending deregistration to\r\n    /// deregister\r\n    modifier onlyDeregisterable(address _darknodeID) {\r\n        require(isDeregisterable(_darknodeID), \"must be deregisterable\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow the Slasher contract.\r\n    modifier onlySlasher() {\r\n        require(slasher == msg.sender, \"must be slasher\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _renAddress The address of the RepublicToken contract.\r\n    /// @param _storeAddress The address of the DarknodeRegistryStore contract.\r\n    /// @param _minimumBond The minimum bond amount that can be submitted by a\r\n    ///        Darknode.\r\n    /// @param _minimumPodSize The minimum size of a Darknode pod.\r\n    /// @param _minimumEpochInterval The minimum number of blocks between\r\n    ///        epochs.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _renAddress,\r\n        DarknodeRegistryStore _storeAddress,\r\n        uint256 _minimumBond,\r\n        uint256 _minimumPodSize,\r\n        uint256 _minimumEpochInterval\r\n    ) public {\r\n        VERSION = _VERSION;\r\n\r\n        store = _storeAddress;\r\n        ren = _renAddress;\r\n\r\n        minimumBond = _minimumBond;\r\n        nextMinimumBond = minimumBond;\r\n\r\n        minimumPodSize = _minimumPodSize;\r\n        nextMinimumPodSize = minimumPodSize;\r\n\r\n        minimumEpochInterval = _minimumEpochInterval;\r\n        nextMinimumEpochInterval = minimumEpochInterval;\r\n\r\n        currentEpoch = Epoch({\r\n            epochhash: uint256(blockhash(block.number - 1)),\r\n            blocknumber: block.number\r\n        });\r\n        numDarknodes = 0;\r\n        numDarknodesNextEpoch = 0;\r\n        numDarknodesPreviousEpoch = 0;\r\n    }\r\n\r\n    /// @notice Register a darknode and transfer the bond to this contract. The\r\n    /// caller must provide a public encryption key for the darknode as well as\r\n    /// a bond in REN. The bond must be provided as an ERC20 allowance. The dark\r\n    /// node will remain pending registration until the next epoch. Only after\r\n    /// this period can the darknode be deregistered. The caller of this method\r\n    /// will be stored as the owner of the darknode.\r\n    ///\r\n    /// @param _darknodeID The darknode ID that will be registered.\r\n    /// @param _publicKey The public key of the darknode. It is stored to allow\r\n    ///        other darknodes and traders to encrypt messages to the trader.\r\n    /// @param _bond The bond that will be paid. It must be greater than, or\r\n    ///        equal to, the minimum bond.\r\n    function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) {\r\n        // REN allowance\r\n        require(_bond >= minimumBond, \"insufficient bond\");\r\n        // require(ren.allowance(msg.sender, address(this)) >= _bond);\r\n        require(ren.transferFrom(msg.sender, address(this), _bond), \"bond transfer failed\");\r\n        ren.transfer(address(store), _bond);\r\n\r\n        // Flag this darknode for registration\r\n        store.appendDarknode(\r\n            _darknodeID,\r\n            msg.sender,\r\n            _bond,\r\n            _publicKey,\r\n            currentEpoch.blocknumber + minimumEpochInterval,\r\n            0\r\n        );\r\n\r\n        numDarknodesNextEpoch += 1;\r\n\r\n        // Emit an event.\r\n        emit LogDarknodeRegistered(_darknodeID, _bond);\r\n    }\r\n\r\n    /// @notice Deregister a darknode. The darknode will not be deregistered\r\n    /// until the end of the epoch. After another epoch, the bond can be\r\n    /// refunded by calling the refund method.\r\n    /// @param _darknodeID The darknode ID that will be deregistered. The caller\r\n    ///        of this method store.darknodeRegisteredAt(_darknodeID) must be\r\n    //         the owner of this darknode.\r\n    function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {\r\n        // Flag the darknode for deregistration\r\n        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + minimumEpochInterval);\r\n        numDarknodesNextEpoch -= 1;\r\n\r\n        // Emit an event\r\n        emit LogDarknodeDeregistered(_darknodeID);\r\n    }\r\n\r\n    /// @notice Progress the epoch if it is possible to do so. This captures\r\n    /// the current timestamp and current blockhash and overrides the current\r\n    /// epoch.\r\n    function epoch() external {\r\n        if (previousEpoch.blocknumber == 0) {\r\n            // The first epoch must be called by the owner of the contract\r\n            require(msg.sender == owner, \"not authorized (first epochs)\");\r\n        }\r\n\r\n        // Require that the epoch interval has passed\r\n        require(block.number >= currentEpoch.blocknumber + minimumEpochInterval, \"epoch interval has not passed\");\r\n        uint256 epochhash = uint256(blockhash(block.number - 1));\r\n\r\n        // Update the epoch hash and timestamp\r\n        previousEpoch = currentEpoch;\r\n        currentEpoch = Epoch({\r\n            epochhash: epochhash,\r\n            blocknumber: block.number\r\n        });\r\n\r\n        // Update the registry information\r\n        numDarknodesPreviousEpoch = numDarknodes;\r\n        numDarknodes = numDarknodesNextEpoch;\r\n\r\n        // If any update functions have been called, update the values now\r\n        if (nextMinimumBond != minimumBond) {\r\n            minimumBond = nextMinimumBond;\r\n            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);\r\n        }\r\n        if (nextMinimumPodSize != minimumPodSize) {\r\n            minimumPodSize = nextMinimumPodSize;\r\n            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);\r\n        }\r\n        if (nextMinimumEpochInterval != minimumEpochInterval) {\r\n            minimumEpochInterval = nextMinimumEpochInterval;\r\n            emit LogMinimumEpochIntervalUpdated(minimumEpochInterval, nextMinimumEpochInterval);\r\n        }\r\n        if (nextSlasher != slasher) {\r\n            slasher = nextSlasher;\r\n            emit LogSlasherUpdated(slasher, nextSlasher);\r\n        }\r\n\r\n        // Emit an event\r\n        emit LogNewEpoch();\r\n    }\r\n\r\n    /// @notice Allows the contract owner to transfer ownership of the\r\n    /// DarknodeRegistryStore.\r\n    /// @param _newOwner The address to transfer the ownership to.\r\n    function transferStoreOwnership(address _newOwner) external onlyOwner {\r\n        store.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum bond.\r\n    /// @param _nextMinimumBond The minimum bond amount that can be submitted by\r\n    ///        a darknode.\r\n    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumBond = _nextMinimumBond;\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum pod size.\r\n    /// @param _nextMinimumPodSize The minimum size of a pod.\r\n    function updateMinimumPodSize(uint256 _nextMinimumPodSize) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumPodSize = _nextMinimumPodSize;\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum epoch interval.\r\n    /// @param _nextMinimumEpochInterval The minimum number of blocks between epochs.\r\n    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumEpochInterval = _nextMinimumEpochInterval;\r\n    }\r\n\r\n    /// @notice Allow the contract owner to update the DarknodeSlasher contract\r\n    /// address.\r\n    /// @param _slasher The new slasher address.\r\n    function updateSlasher(address _slasher) external onlyOwner {\r\n        nextSlasher = _slasher;\r\n    }\r\n\r\n    /// @notice Allow the DarknodeSlasher contract to slash half of a darknode's\r\n    /// bond and deregister it. The bond is distributed as follows:\r\n    ///   1/2 is kept by the guilty prover\r\n    ///   1/8 is rewarded to the first challenger\r\n    ///   1/8 is rewarded to the second challenger\r\n    ///   1/4 becomes unassigned\r\n    /// @param _prover The guilty prover whose bond is being slashed\r\n    /// @param _challenger1 The first of the two darknodes who submitted the challenge\r\n    /// @param _challenger2 The second of the two darknodes who submitted the challenge\r\n    function slash(address _prover, address _challenger1, address _challenger2)\r\n        external\r\n        onlySlasher\r\n    {\r\n        uint256 penalty = store.darknodeBond(_prover) / 2;\r\n        uint256 reward = penalty / 4;\r\n\r\n        // Slash the bond of the failed prover in half\r\n        store.updateDarknodeBond(_prover, penalty);\r\n\r\n        // If the darknode has not been deregistered then deregister it\r\n        if (isDeregisterable(_prover)) {\r\n            store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + minimumEpochInterval);\r\n            numDarknodesNextEpoch -= 1;\r\n            emit LogDarknodeDeregistered(_prover);\r\n        }\r\n\r\n        // Reward the challengers with less than the penalty so that it is not\r\n        // worth challenging yourself\r\n        ren.transfer(store.darknodeOwner(_challenger1), reward);\r\n        ren.transfer(store.darknodeOwner(_challenger2), reward);\r\n    }\r\n\r\n    /// @notice Refund the bond of a deregistered darknode. This will make the\r\n    /// darknode available for registration again. Anyone can call this function\r\n    /// but the bond will always be refunded to the darknode owner.\r\n    ///\r\n    /// @param _darknodeID The darknode ID that will be refunded. The caller\r\n    ///        of this method must be the owner of this darknode.\r\n    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {\r\n        address darknodeOwner = store.darknodeOwner(_darknodeID);\r\n\r\n        // Remember the bond amount\r\n        uint256 amount = store.darknodeBond(_darknodeID);\r\n\r\n        // Erase the darknode from the registry\r\n        store.removeDarknode(_darknodeID);\r\n\r\n        // Refund the owner by transferring REN\r\n        ren.transfer(darknodeOwner, amount);\r\n\r\n        // Emit an event.\r\n        emit LogDarknodeOwnerRefunded(darknodeOwner, amount);\r\n    }\r\n\r\n    /// @notice Retrieves the address of the account that registered a darknode.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the owner for.\r\n    function getDarknodeOwner(address _darknodeID) external view returns (address) {\r\n        return store.darknodeOwner(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves the bond amount of a darknode in 10^-18 REN.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the bond for.\r\n    function getDarknodeBond(address _darknodeID) external view returns (uint256) {\r\n        return store.darknodeBond(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves the encryption public key of the darknode.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the public key for.\r\n    function getDarknodePublicKey(address _darknodeID) external view returns (bytes) {\r\n        return store.darknodePublicKey(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves a list of darknodes which are registered for the\r\n    /// current epoch.\r\n    /// @param _start A darknode ID used as an offset for the list. If _start is\r\n    ///        0x0, the first dark node will be used. _start won't be\r\n    ///        included it is not registered for the epoch.\r\n    /// @param _count The number of darknodes to retrieve starting from _start.\r\n    ///        If _count is 0, all of the darknodes from _start are\r\n    ///        retrieved. If _count is more than the remaining number of\r\n    ///        registered darknodes, the rest of the list will contain\r\n    ///        0x0s.\r\n    function getDarknodes(address _start, uint256 _count) external view returns (address[]) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodes;\r\n        }\r\n        return getDarknodesFromEpochs(_start, count, false);\r\n    }\r\n\r\n    /// @notice Retrieves a list of darknodes which were registered for the\r\n    /// previous epoch. See `getDarknodes` for the parameter documentation.\r\n    function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodesPreviousEpoch;\r\n        }\r\n        return getDarknodesFromEpochs(_start, count, true);\r\n    }\r\n\r\n    /// @notice Returns whether a darknode is scheduled to become registered\r\n    /// at next epoch.\r\n    /// @param _darknodeID The ID of the darknode to return\r\n    function isPendingRegistration(address _darknodeID) external view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the pending deregistered state. In\r\n    /// this state a darknode is still considered registered.\r\n    function isPendingDeregistration(address _darknodeID) external view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the deregistered state.\r\n    function isDeregistered(address _darknodeID) public view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode can be deregistered. This is true if the\r\n    /// darknodes is in the registered state and has not attempted to\r\n    /// deregister yet.\r\n    function isDeregisterable(address _darknodeID) public view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        // The Darknode is currently in the registered state and has not been\r\n        // transitioned to the pending deregistration, or deregistered, state\r\n        return isRegistered(_darknodeID) && deregisteredAt == 0;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the refunded state. This is true\r\n    /// for darknodes that have never been registered, or darknodes that have\r\n    /// been deregistered and refunded.\r\n    function isRefunded(address _darknodeID) public view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return registeredAt == 0 && deregisteredAt == 0;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is refundable. This is true for darknodes\r\n    /// that have been in the deregistered state for one full epoch.\r\n    function isRefundable(address _darknodeID) public view returns (bool) {\r\n        return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the registered state.\r\n    function isRegistered(address _darknodeID) public view returns (bool) {\r\n        return isRegisteredInEpoch(_darknodeID, currentEpoch);\r\n    }\r\n\r\n    /// @notice Returns if a darknode was in the registered state last epoch.\r\n    function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) {\r\n        return isRegisteredInEpoch(_darknodeID, previousEpoch);\r\n    }\r\n\r\n    /// @notice Returns if a darknode was in the registered state for a given\r\n    /// epoch.\r\n    /// @param _darknodeID The ID of the darknode\r\n    /// @param _epoch One of currentEpoch, previousEpoch\r\n    function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber;\r\n        bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber;\r\n        // The Darknode has been registered and has not yet been deregistered,\r\n        // although it might be pending deregistration\r\n        return registered && notDeregistered;\r\n    }\r\n\r\n    /// @notice Returns a list of darknodes registered for either the current\r\n    /// or the previous epoch. See `getDarknodes` for documentation on the\r\n    /// parameters `_start` and `_count`.\r\n    /// @param _usePreviousEpoch If true, use the previous epoch, otherwise use\r\n    ///        the current epoch.\r\n    function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodes;\r\n        }\r\n\r\n        address[] memory nodes = new address[](count);\r\n\r\n        // Begin with the first node in the list\r\n        uint256 n = 0;\r\n        address next = _start;\r\n        if (next == 0x0) {\r\n            next = store.begin();\r\n        }\r\n\r\n        // Iterate until all registered Darknodes have been collected\r\n        while (n < count) {\r\n            if (next == 0x0) {\r\n                break;\r\n            }\r\n            // Only include Darknodes that are currently registered\r\n            bool includeNext;\r\n            if (_usePreviousEpoch) {\r\n                includeNext = isRegisteredInPreviousEpoch(next);\r\n            } else {\r\n                includeNext = isRegistered(next);\r\n            }\r\n            if (!includeNext) {\r\n                next = store.next(next);\r\n                continue;\r\n            }\r\n            nodes[n] = next;\r\n            next = store.next(next);\r\n            n += 1;\r\n        }\r\n        return nodes;\r\n    }\r\n}\r\n\r\n/// @notice The BrokerVerifier interface defines the functions that a settlement\r\n/// layer's broker verifier contract must implement.\r\ninterface BrokerVerifier {\r\n\r\n    /// @notice The function signature that will be called when a trader opens\r\n    /// an order.\r\n    ///\r\n    /// @param _trader The trader requesting the withdrawal.\r\n    /// @param _signature The 65-byte signature from the broker.\r\n    /// @param _orderID The 32-byte order ID.\r\n    function verifyOpenSignature(\r\n        address _trader,\r\n        bytes _signature,\r\n        bytes32 _orderID\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @notice The Settlement interface defines the functions that a settlement\r\n/// layer must implement.\r\n/// Docs: https://github.com/republicprotocol/republic-sol/blob/nightly/docs/05-settlement.md\r\ninterface Settlement {\r\n    function submitOrder(\r\n        bytes _details,\r\n        uint64 _settlementID,\r\n        uint64 _tokens,\r\n        uint256 _price,\r\n        uint256 _volume,\r\n        uint256 _minimumVolume\r\n    ) external;\r\n\r\n    function submissionGasPriceLimit() external view returns (uint256);\r\n\r\n    function settle(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID\r\n    ) external;\r\n\r\n    /// @notice orderStatus should return the status of the order, which should\r\n    /// be:\r\n    ///     0  - Order not seen before\r\n    ///     1  - Order details submitted\r\n    ///     >1 - Order settled, or settlement no longer possible\r\n    function orderStatus(bytes32 _orderID) external view returns (uint8);\r\n}\r\n\r\n/// @notice SettlementRegistry allows a Settlement layer to register the\r\n/// contracts used for match settlement and for broker signature verification.\r\ncontract SettlementRegistry is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    struct SettlementDetails {\r\n        bool registered;\r\n        Settlement settlementContract;\r\n        BrokerVerifier brokerVerifierContract;\r\n    }\r\n\r\n    // Settlement IDs are 64-bit unsigned numbers\r\n    mapping(uint64 => SettlementDetails) public settlementDetails;\r\n\r\n    // Events\r\n    event LogSettlementRegistered(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\r\n    event LogSettlementUpdated(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\r\n    event LogSettlementDeregistered(uint64 settlementID);\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string _VERSION) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Returns the settlement contract of a settlement layer.\r\n    function settlementRegistration(uint64 _settlementID) external view returns (bool) {\r\n        return settlementDetails[_settlementID].registered;\r\n    }\r\n\r\n    /// @notice Returns the settlement contract of a settlement layer.\r\n    function settlementContract(uint64 _settlementID) external view returns (Settlement) {\r\n        return settlementDetails[_settlementID].settlementContract;\r\n    }\r\n\r\n    /// @notice Returns the broker verifier contract of a settlement layer.\r\n    function brokerVerifierContract(uint64 _settlementID) external view returns (BrokerVerifier) {\r\n        return settlementDetails[_settlementID].brokerVerifierContract;\r\n    }\r\n\r\n    /// @param _settlementID A unique 64-bit settlement identifier.\r\n    /// @param _settlementContract The address to use for settling matches.\r\n    /// @param _brokerVerifierContract The decimals to use for verifying\r\n    ///        broker signatures.\r\n    function registerSettlement(uint64 _settlementID, Settlement _settlementContract, BrokerVerifier _brokerVerifierContract) public onlyOwner {\r\n        bool alreadyRegistered = settlementDetails[_settlementID].registered;\r\n        \r\n        settlementDetails[_settlementID] = SettlementDetails({\r\n            registered: true,\r\n            settlementContract: _settlementContract,\r\n            brokerVerifierContract: _brokerVerifierContract\r\n        });\r\n\r\n        if (alreadyRegistered) {\r\n            emit LogSettlementUpdated(_settlementID, _settlementContract, _brokerVerifierContract);\r\n        } else {\r\n            emit LogSettlementRegistered(_settlementID, _settlementContract, _brokerVerifierContract);\r\n        }\r\n    }\r\n\r\n    /// @notice Deregisteres a settlement layer, clearing the details.\r\n    /// @param _settlementID The unique 64-bit settlement identifier.\r\n    function deregisterSettlement(uint64 _settlementID) external onlyOwner {\r\n        require(settlementDetails[_settlementID].registered, \"not registered\");\r\n\r\n        delete settlementDetails[_settlementID];\r\n\r\n        emit LogSettlementDeregistered(_settlementID);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n    );\r\n  }\r\n}\r\n\r\nlibrary Utils {\r\n\r\n    /**\r\n     * @notice Converts a number to its string/bytes representation\r\n     *\r\n     * @param _v the uint to convert\r\n     */\r\n    function uintToBytes(uint256 _v) internal pure returns (bytes) {\r\n        uint256 v = _v;\r\n        if (v == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        uint256 digits = 0;\r\n        uint256 v2 = v;\r\n        while (v2 > 0) {\r\n            v2 /= 10;\r\n            digits += 1;\r\n        }\r\n\r\n        bytes memory result = new bytes(digits);\r\n\r\n        for (uint256 i = 0; i < digits; i++) {\r\n            result[digits - i - 1] = bytes1((v % 10) + 48);\r\n            v /= 10;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the address from a signature\r\n     *\r\n     * @param _hash the message that was signed (any length of bytes)\r\n     * @param _signature the signature (65 bytes)\r\n     */\r\n    function addr(bytes _hash, bytes _signature) internal pure returns (address) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\r\n        bytes memory encoded = abi.encodePacked(prefix, uintToBytes(_hash.length), _hash);\r\n        bytes32 prefixedHash = keccak256(encoded);\r\n\r\n        return ECRecovery.recover(prefixedHash, _signature);\r\n    }\r\n\r\n}\r\n\r\n/// @notice The Orderbook contract stores the state and priority of orders and\r\n/// allows the Darknodes to easily reach consensus. Eventually, this contract\r\n/// will only store a subset of order states, such as cancellation, to improve\r\n/// the throughput of orders.\r\ncontract Orderbook is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice OrderState enumerates the possible states of an order. All\r\n    /// orders default to the Undefined state.\r\n    enum OrderState {Undefined, Open, Confirmed, Canceled}\r\n\r\n    /// @notice Order stores a subset of the public data associated with an order.\r\n    struct Order {\r\n        OrderState state;     // State of the order\r\n        address trader;       // Trader that owns the order\r\n        address confirmer;    // Darknode that confirmed the order in a match\r\n        uint64 settlementID;  // The settlement that signed the order opening\r\n        uint256 priority;     // Logical time priority of this order\r\n        uint256 blockNumber;  // Block number of the most recent state change\r\n        bytes32 matchedOrder; // Order confirmed in a match with this order\r\n    }\r\n\r\n    RepublicToken public ren;\r\n    DarknodeRegistry public darknodeRegistry;\r\n    SettlementRegistry public settlementRegistry;\r\n\r\n    bytes32[] private orderbook;\r\n\r\n    // Order details are exposed through directly accessing this mapping, or\r\n    // through the getter functions below for each of the order's fields.\r\n    mapping(bytes32 => Order) public orders;\r\n\r\n    event LogFeeUpdated(uint256 previousFee, uint256 nextFee);\r\n    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\r\n\r\n    /// @notice Only allow registered dark nodes.\r\n    modifier onlyDarknode(address _sender) {\r\n        require(darknodeRegistry.isRegistered(address(_sender)), \"must be registered darknode\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _renAddress The address of the RepublicToken contract.\r\n    /// @param _darknodeRegistry The address of the DarknodeRegistry contract.\r\n    /// @param _settlementRegistry The address of the SettlementRegistry\r\n    ///        contract.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _renAddress,\r\n        DarknodeRegistry _darknodeRegistry,\r\n        SettlementRegistry _settlementRegistry\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        ren = _renAddress;\r\n        darknodeRegistry = _darknodeRegistry;\r\n        settlementRegistry = _settlementRegistry;\r\n    }\r\n\r\n    /// @notice Allows the owner to update the address of the DarknodeRegistry\r\n    /// contract.\r\n    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) external onlyOwner {\r\n        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\r\n        darknodeRegistry = _newDarknodeRegistry;\r\n    }\r\n\r\n    /// @notice Open an order in the orderbook. The order must be in the\r\n    /// Undefined state.\r\n    ///\r\n    /// @param _signature Signature of the message that defines the trader. The\r\n    ///        message is \"Republic Protocol: open: {orderId}\".\r\n    /// @param _orderID The hash of the order.\r\n    function openOrder(uint64 _settlementID, bytes _signature, bytes32 _orderID) external {\r\n        require(orders[_orderID].state == OrderState.Undefined, \"invalid order status\");\r\n\r\n        address trader = msg.sender;\r\n\r\n        // Verify the order signature\r\n        require(settlementRegistry.settlementRegistration(_settlementID), \"settlement not registered\");\r\n        BrokerVerifier brokerVerifier = settlementRegistry.brokerVerifierContract(_settlementID);\r\n        require(brokerVerifier.verifyOpenSignature(trader, _signature, _orderID), \"invalid broker signature\");\r\n\r\n        orders[_orderID] = Order({\r\n            state: OrderState.Open,\r\n            trader: trader,\r\n            confirmer: 0x0,\r\n            settlementID: _settlementID,\r\n            priority: orderbook.length + 1,\r\n            blockNumber: block.number,\r\n            matchedOrder: 0x0\r\n        });\r\n\r\n        orderbook.push(_orderID);\r\n    }\r\n\r\n    /// @notice Confirm an order match between orders. The confirmer must be a\r\n    /// registered Darknode and the orders must be in the Open state. A\r\n    /// malicious confirmation by a Darknode will result in a bond slash of the\r\n    /// Darknode.\r\n    ///\r\n    /// @param _orderID The hash of the order.\r\n    /// @param _matchedOrderID The hashes of the matching order.\r\n    function confirmOrder(bytes32 _orderID, bytes32 _matchedOrderID) external onlyDarknode(msg.sender) {\r\n        require(orders[_orderID].state == OrderState.Open, \"invalid order status\");\r\n        require(orders[_matchedOrderID].state == OrderState.Open, \"invalid order status\");\r\n\r\n        orders[_orderID].state = OrderState.Confirmed;\r\n        orders[_orderID].confirmer = msg.sender;\r\n        orders[_orderID].matchedOrder = _matchedOrderID;\r\n        orders[_orderID].blockNumber = block.number;\r\n\r\n        orders[_matchedOrderID].state = OrderState.Confirmed;\r\n        orders[_matchedOrderID].confirmer = msg.sender;\r\n        orders[_matchedOrderID].matchedOrder = _orderID;\r\n        orders[_matchedOrderID].blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice Cancel an open order in the orderbook. An order can be cancelled\r\n    /// by the trader who opened the order, or by the broker verifier contract.\r\n    /// This allows the settlement layer to implement their own logic for\r\n    /// cancelling orders without trader interaction (e.g. to ban a trader from\r\n    /// a specific darkpool, or to use multiple order-matching platforms)\r\n    ///\r\n    /// @param _orderID The hash of the order.\r\n    function cancelOrder(bytes32 _orderID) external {\r\n        require(orders[_orderID].state == OrderState.Open, \"invalid order state\");\r\n\r\n        // Require the msg.sender to be the trader or the broker verifier\r\n        address brokerVerifier = address(settlementRegistry.brokerVerifierContract(orders[_orderID].settlementID));\r\n        require(msg.sender == orders[_orderID].trader || msg.sender == brokerVerifier, \"not authorized\");\r\n\r\n        orders[_orderID].state = OrderState.Canceled;\r\n        orders[_orderID].blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice returns status of the given orderID.\r\n    function orderState(bytes32 _orderID) external view returns (OrderState) {\r\n        return orders[_orderID].state;\r\n    }\r\n\r\n    /// @notice returns a list of matched orders to the given orderID.\r\n    function orderMatch(bytes32 _orderID) external view returns (bytes32) {\r\n        return orders[_orderID].matchedOrder;\r\n    }\r\n\r\n    /// @notice returns the priority of the given orderID.\r\n    /// The priority is the index of the order in the orderbook.\r\n    function orderPriority(bytes32 _orderID) external view returns (uint256) {\r\n        return orders[_orderID].priority;\r\n    }\r\n\r\n    /// @notice returns the trader of the given orderID.\r\n    /// Trader is the one who signs the message and does the actual trading.\r\n    function orderTrader(bytes32 _orderID) external view returns (address) {\r\n        return orders[_orderID].trader;\r\n    }\r\n\r\n    /// @notice returns the darknode address which confirms the given orderID.\r\n    function orderConfirmer(bytes32 _orderID) external view returns (address) {\r\n        return orders[_orderID].confirmer;\r\n    }\r\n\r\n    /// @notice returns the block number when the order being last modified.\r\n    function orderBlockNumber(bytes32 _orderID) external view returns (uint256) {\r\n        return orders[_orderID].blockNumber;\r\n    }\r\n\r\n    /// @notice returns the block depth of the orderId\r\n    function orderDepth(bytes32 _orderID) external view returns (uint256) {\r\n        if (orders[_orderID].blockNumber == 0) {\r\n            return 0;\r\n        }\r\n        return (block.number - orders[_orderID].blockNumber);\r\n    }\r\n\r\n    /// @notice returns the number of orders in the orderbook\r\n    function ordersCount() external view returns (uint256) {\r\n        return orderbook.length;\r\n    }\r\n\r\n    /// @notice returns order details of the orders starting from the offset.\r\n    function getOrders(uint256 _offset, uint256 _limit) external view returns (bytes32[], address[], uint8[]) {\r\n        if (_offset >= orderbook.length) {\r\n            return;\r\n        }\r\n\r\n        // If the provided limit is more than the number of orders after the offset,\r\n        // decrease the limit\r\n        uint256 limit = _limit;\r\n        if (_offset + limit > orderbook.length) {\r\n            limit = orderbook.length - _offset;\r\n        }\r\n\r\n        bytes32[] memory orderIDs = new bytes32[](limit);\r\n        address[] memory traderAddresses = new address[](limit);\r\n        uint8[] memory states = new uint8[](limit);\r\n\r\n        for (uint256 i = 0; i < limit; i++) {\r\n            bytes32 order = orderbook[i + _offset];\r\n            orderIDs[i] = order;\r\n            traderAddresses[i] = orders[order].trader;\r\n            states[i] = uint8(orders[order].state);\r\n        }\r\n\r\n        return (orderIDs, traderAddresses, states);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderConfirmer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"},{\"name\":\"_matchedOrderID\",\"type\":\"bytes32\"}],\"name\":\"confirmOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ordersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ren\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_offset\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"confirmer\",\"type\":\"address\"},{\"name\":\"settlementID\",\"type\":\"uint64\"},{\"name\":\"priority\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"matchedOrder\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"darknodeRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderDepth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_settlementID\",\"type\":\"uint64\"},{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"openOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDarknodeRegistry\",\"type\":\"address\"}],\"name\":\"updateDarknodeRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderMatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderTrader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"orderPriority\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"},{\"name\":\"_renAddress\",\"type\":\"address\"},{\"name\":\"_darknodeRegistry\",\"type\":\"address\"},{\"name\":\"_settlementRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextFee\",\"type\":\"uint256\"}],\"name\":\"LogFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousDarknodeRegistry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextDarknodeRegistry\",\"type\":\"address\"}],\"name\":\"LogDarknodeRegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Orderbook","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000021c482f153d0317fe85c60be1f7fa079019fcebd0000000000000000000000003799006a87fde3ccfc7666b3e6553b03ed341c2f000000000000000000000000119da7a8500ade0766f758d934808179dc551036000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://8b46a2bab2e2b6a785006632716bf3b77d037ec2efa43ecc423884670681d95b"}]}