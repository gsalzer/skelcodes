{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/******************************************/\r\n/*       Owned starts here           */\r\n/******************************************/\r\n\r\ncontract owned \r\n{\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == owner, \"Sender not authorized.\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner\r\n    {\r\n        require(_newOwner != address(0), \"0x00 address not allowed.\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public\r\n    {\r\n        require(msg.sender == newOwner, \"Sender not authorized.\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n/******************************************/\r\n/*       TokenERC20 starts here           */\r\n/******************************************/\r\n\r\ncontract TokenERC20\r\n{\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n   \r\n    constructor() public\r\n    {\r\n        decimals = 18;                       // decimals  \r\n        totalSupply = 0;                     // initialSupply\r\n        name = \"LOOiX\";                      // Set the name for display purposes\r\n        symbol = \"LOOIX\";                    // Set the symbol for display purposes\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param _from The address to transfer from.\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function _transfer(address _from, address _to, uint256 _value) internal\r\n    {\r\n        require(_value > 0, \"Transferred value has to be grater than 0.\"); \r\n        require(_to != address(0), \"0x00 address not allowed.\");                      // Prevent transfer to 0x0 address.\r\n        require(balanceOf[_from] >= _value, \"Not enough funds on sender address.\");   // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to], \"Overflow protection.\");    // Check for overflows\r\n        balanceOf[_from] -= _value;                                                   // Subtract from the sender\r\n        balanceOf[_to] += _value;                                                     // Add the same to the recipient\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens\r\n    * @param _to The address of the recipient\r\n    * @param _value the amount to send\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns(bool success)\r\n    {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from other address\r\n    * @param _from The address of the sender\r\n    * @param _to The address of the recipient\r\n    * @param _value the amount to send\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success)\r\n    {\r\n        require(_value <= allowance[_from][msg.sender], \"Funds not approved.\");     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Set allowance for other address\r\n    * @param _spender The address authorized to spend\r\n    * @param _value the max amount they can spend\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns(bool success)\r\n    {\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, \"Approved funds or value are not 0.\");\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/******************************************/\r\n/*       TokenStaking starts here         */\r\n/******************************************/\r\n\r\ncontract TokenStaking\r\n{\r\n\r\n    uint256 internal stakeID;\r\n    uint256 internal threeMonthTime;\r\n    uint256 internal threeMonthPercentage;\r\n    uint256 internal sixMonthTime;\r\n    uint256 internal sixMonthPercentage;\r\n    uint256 internal twelveMonthTime;\r\n    uint256 internal twelveMonthPercentage;\r\n\r\n    struct stakeInfo    // Struct for user vestings\r\n    {\r\n        uint256 endDate;\r\n        uint256 amount;\r\n        address initiator;\r\n        address receiver;\r\n    }\r\n\r\n    mapping(address => uint256) public stakedBalanceOf;\r\n    mapping(uint256 => stakeInfo) internal vestings;\r\n    mapping(address => uint256[]) internal userVestingIDs;\r\n\r\n    enum StakeOption {three, six, twelve}\r\n\r\n    constructor() TokenStaking() public \r\n    { \r\n        stakeID = 0;\r\n       \r\n        threeMonthTime = 91 days;\r\n        threeMonthPercentage = 1005012520859401063; // e**(0.02*0.25)\r\n                               \r\n        sixMonthTime = 182 days;\r\n        sixMonthPercentage = 1020201340026755810; // e**(0.04*0.5)\r\n\r\n        twelveMonthTime = 365 days;\r\n        twelveMonthPercentage = 1061836546545359622; // e**(0.06*1.0)\r\n    }\r\n\r\n    /**\r\n    * @dev Function to get the stake info from a corresponding ID.\r\n    * @param _id uint256 The ID from which the stake info should be read.\r\n    * @return endDate uint256 specifying the seconds since the UNIX Epoch. amount uint256 specifying the amount that was staked plus the stake bonus.\r\n    */\r\n    function getStakeInfo(uint256 _id) external view returns(uint256 endDate, uint256 amount, address receiver, address initiator)\r\n    {\r\n        return (vestings[_id].endDate, vestings[_id].amount, vestings[_id].receiver, vestings[_id].initiator);\r\n    }\r\n    \r\n    /**\r\n    * @dev Function to get the stake IDs from a given address.\r\n    * @param _address address The address which staked tokens.\r\n    * @return Ids uint256[] An array of stake IDs from the given address.\r\n    */\r\n    function getStakeIDs(address _address) external view returns(uint256[] memory Ids)\r\n    {\r\n        return userVestingIDs[_address];\r\n    }\r\n\r\n    /**\r\n    * @dev Stake an amount of tokens with one of three options.\r\n    * @param _amount uint256 The amount of tokens which will be staked.\r\n    * @param _option StakeOption An enum which decides how long a stake will be frozen (only 0, 1 and 2 are valid values).\r\n    * @return totalSupplyIncreaseds uint256 The total increase in supply from the staked tokens.\r\n    */\r\n    function _stake(uint256 _amount, StakeOption _option, address _receiver) internal returns(uint256 totalSupplyIncrease)\r\n    {\r\n        require(_option >= StakeOption.three && _option <= StakeOption.twelve);\r\n        \r\n        stakeInfo memory stakeStruct;\r\n        stakeStruct.endDate = 0;\r\n        stakeStruct.amount = 0;\r\n        stakeStruct.initiator = msg.sender;\r\n        stakeStruct.receiver = address(0);\r\n\r\n        uint256 tempIncrease;\r\n\r\n        if (_option == StakeOption.three) \r\n        {\r\n            stakeStruct.endDate = now + threeMonthTime;\r\n            stakeStruct.amount = _amount * threeMonthPercentage / (10**18);\r\n            stakeStruct.initiator = msg.sender;\r\n            stakeStruct.receiver = _receiver;\r\n            tempIncrease = (_amount * (threeMonthPercentage - (10**18)) / (10**18));\r\n        } \r\n        else if (_option == StakeOption.six)\r\n        {\r\n            stakeStruct.endDate = now + sixMonthTime;\r\n            stakeStruct.amount = _amount * sixMonthPercentage / (10**18);\r\n            stakeStruct.initiator = msg.sender;\r\n            stakeStruct.receiver = _receiver;\r\n            tempIncrease = (_amount * (sixMonthPercentage - (10**18)) / (10**18));\r\n        } \r\n        else if (_option == StakeOption.twelve)\r\n        {\r\n            stakeStruct.endDate = now + twelveMonthTime;\r\n            stakeStruct.amount = _amount * twelveMonthPercentage / (10**18);\r\n            stakeStruct.initiator = msg.sender;\r\n            stakeStruct.receiver = _receiver;\r\n            tempIncrease = (_amount * (twelveMonthPercentage - (10**18)) / (10**18));\r\n        }\r\n\r\n        stakeID = stakeID + 1;\r\n        vestings[stakeID] = stakeStruct;\r\n        _setVestingID(stakeID, stakeStruct.receiver);\r\n        stakedBalanceOf[msg.sender] += stakeStruct.amount;\r\n        return tempIncrease;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to set a new vesting ID on the userVestingIDs mapping. Free ID slots in the array will be overwritten.\r\n    * @param _id uint256 The new ID that has to be written in the corresponding mapping.\r\n    */\r\n    function _setVestingID(uint256 _id, address _receiver) internal\r\n    {\r\n        bool tempEntryWritten = false;\r\n        uint256 arrayLength = userVestingIDs[_receiver].length;\r\n\r\n        if(arrayLength != 0)\r\n        {\r\n            for (uint256 i = 0; i < arrayLength; i++) \r\n            {\r\n                if (userVestingIDs[_receiver][i] == 0) \r\n                {\r\n                    userVestingIDs[_receiver][i] = _id;\r\n                    tempEntryWritten = true;\r\n                    break;\r\n                } \r\n            }\r\n\r\n            if(!tempEntryWritten)\r\n            {\r\n                userVestingIDs[_receiver].push(_id);\r\n            }\r\n        } \r\n        else\r\n        {\r\n            userVestingIDs[_receiver].push(_id);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Redeem the staked tokens.\r\n    * @return amount uint256 The amount that has been redeemed.\r\n    */\r\n    function _redeem() internal returns(uint256 amount)\r\n    {\r\n        uint256[] memory IdArray = userVestingIDs[msg.sender];\r\n        uint256 tempAmount = 0;\r\n        uint256 finalAmount = 0;\r\n        address tempInitiator = address(0);\r\n\r\n        for(uint256 i = 0; i < IdArray.length; i++)\r\n        {\r\n            if(IdArray[i] != 0 && vestings[IdArray[i]].endDate <= now)\r\n            {\r\n                tempInitiator = vestings[IdArray[i]].initiator;\r\n                tempAmount = vestings[IdArray[i]].amount;\r\n\r\n                stakedBalanceOf[tempInitiator] -= tempAmount;\r\n                finalAmount += tempAmount;\r\n\r\n                // delete the vesting history\r\n                delete userVestingIDs[msg.sender][i];\r\n                delete vestings[IdArray[i]];\r\n            }\r\n        }\r\n\r\n        require(finalAmount > 0, \"No funds to redeem.\");\r\n        return finalAmount;\r\n    }\r\n}\r\n\r\n\r\n/******************************************/\r\n/*       LOOiXToken starts here       */\r\n/******************************************/\r\n\r\ncontract LOOiXToken is owned, TokenERC20, TokenStaking\r\n{\r\n\r\n    bool public mintingActive;\r\n    address public mintDelegate;\r\n    uint256 public unlockAt;\r\n    uint256 public ICO_totalSupply;\r\n    uint256 internal constant MAX_UINT = 2**256 - 1;\r\n\r\n    mapping(address => uint256) public allocations;\r\n\r\n    event Stake(address indexed _target, uint256 _amount);\r\n    event Redeem(address indexed _target, uint256 _amount);\r\n\r\n    constructor() TokenERC20() public \r\n    {\r\n        mintingActive = true;\r\n        mintDelegate = address(0);\r\n        unlockAt;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier defines addresses allowed to mint. \r\n    */\r\n    modifier mintingAllowed\r\n    {\r\n        require(msg.sender == owner || msg.sender == mintDelegate, \"Sender not authorized.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal ERC20 transfer.\r\n    */\r\n    function _transfer(address _from, address _to, uint256 _value) internal\r\n    {\r\n        require(_value > 0, \"Transferred value has to be grater than 0.\");            // value has to be greater than 0\r\n        require(_to != address(0), \"0x00 address not allowed.\");                      // Prevent transfer to 0x0 address\r\n        require(balanceOf[_from] >= _value, \"Not enough funds on sender address.\");   // Check if the sender has enough\r\n        require(balanceOf[_to] + _value >= balanceOf[_to], \"Overflow protection.\");   // Check for overflows\r\n        balanceOf[_from] -= _value;                                                   // Subtract from the sender\r\n        balanceOf[_to] += _value;                                                     // Add the same to the recipient\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance.\r\n    * @param _from Address to transfer from.\r\n    * @param _to Address to transfer to.\r\n    * @param _value Amount to transfer.\r\n    * @return Success of transfer.\r\n    */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success)\r\n    {\r\n        uint256 allowanceTemp = allowance[_from][msg.sender];\r\n        \r\n        require(allowanceTemp >= _value, \"Funds not approved.\"); \r\n        require(balanceOf[_from] >= _value, \"Not enough funds on sender address.\");\r\n        require(balanceOf[_to] + _value >= balanceOf[_to], \"Overflow protection.\");\r\n\r\n        balanceOf[_to] += _value;\r\n        balanceOf[_from] -= _value;\r\n\r\n        if (allowanceTemp < MAX_UINT) \r\n        {\r\n            allowance[_from][msg.sender] -= _value;\r\n        }\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Set new mintDelegate address\r\n    * @param _newDelegate The address authorized to mint\r\n    */  \r\n    function setMintDelegate(address _newDelegate) external onlyOwner\r\n    {\r\n        require(_newDelegate != address(0), \"0x00 address not allowed.\");\r\n        mintDelegate = _newDelegate;\r\n    }\r\n    \r\n    /**\r\n    * @dev Set unlimited allowance for other address\r\n    * @param _controllerAddress The address authorized to spend\r\n    */   \r\n    function giveAccess(address _controllerAddress) external\r\n    {\r\n        require(msg.sender != owner, \"Owner of contract can not use this function.\");\r\n        require(_controllerAddress != address(0), \"0x00 address not allowed.\");\r\n        allowance[msg.sender][_controllerAddress] = MAX_UINT;\r\n        emit Approval(msg.sender, _controllerAddress, MAX_UINT);\r\n    }\r\n\r\n    /**\r\n    * @dev Set allowance for other address to 0\r\n    * @param _controllerAddress The address authorized to spend\r\n    */   \r\n    function revokeAccess(address _controllerAddress) external\r\n    {\r\n        require(_controllerAddress != address(0), \"0x00 address not allowed.\");\r\n        allowance[msg.sender][_controllerAddress] = 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw all LOOiX on the contract.\r\n    */ \r\n    function withdrawLOOiX() external onlyOwner\r\n    {\r\n        require(balanceOf[address(this)] > 0, \"No funds available.\");\r\n        _transfer(address(this), owner, balanceOf[address(this)]);\r\n    }\r\n\r\n    /**\r\n    * @dev Bulk mint function for airdrops. \r\n    * @param _address Address array to mint to.\r\n    * @param _mintAmount Amount array to mint.\r\n    */\r\n    function mintTokenBulk(address[] _address, uint256[] _mintAmount) external mintingAllowed\r\n    {\r\n        require(mintingActive, \"The mint functions are not available anymore.\");\r\n        uint256 tempAmount = 0;\r\n\r\n        for (uint256 i = 0; i < _address.length; i++) \r\n        {\r\n            if(balanceOf[_address[i]] + _mintAmount[i] >= balanceOf[_address[i]])\r\n            {\r\n                balanceOf[_address[i]] += _mintAmount[i] * (10**18);\r\n                tempAmount += _mintAmount[i] * (10**18);\r\n\r\n                emit Transfer(address(0), _address[i], _mintAmount[i] * (10**18));\r\n            }\r\n        }\r\n\r\n        totalSupply += tempAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Mint function for creating new tokens. \r\n    * @param _target Address to mint to.\r\n    * @param _mintAmount Amount to mint.\r\n    */\r\n    function mintToken(address _target, uint256 _mintAmount) public mintingAllowed \r\n    {\r\n        require(mintingActive, \"The mint functions are not available anymore.\");\r\n        require(_target != address(0), \"0x00 address not allowed.\");\r\n\r\n        balanceOf[_target] += _mintAmount * (10**18);\r\n        totalSupply += _mintAmount * (10**18);\r\n\r\n        emit Transfer(address(0), _target, _mintAmount * (10**18));\r\n    }\r\n\r\n    /**\r\n    * @dev Stops the minting of the token. After this function is called, no new tokens can be minted using the mintToken or mintTokenBulk functions. Irreversible.\r\n    */\r\n    function terminateMinting() external onlyOwner \r\n    {\r\n        require(mintingActive, \"The mint functions are not available anymore.\");\r\n        uint256 tempTotalSupply = totalSupply;\r\n\r\n        tempTotalSupply = tempTotalSupply + (tempTotalSupply  * 666666666666666666 / 10**18);\r\n        totalSupply = tempTotalSupply;\r\n        ICO_totalSupply = tempTotalSupply;\r\n\r\n        mintingActive = false;\r\n        unlockAt = now + 365 days;\r\n\r\n        // 40% of the total token supply\r\n        allocations[0xefbDBA37BD0e825d43bac88Ce570dcEFf50373C2] = tempTotalSupply * 9500 / 100000;      // 9.5% - Founders Pot.\r\n        allocations[0x75dE233590c8Dd593CE1bB89d68e9f18Ecdf34C8] = tempTotalSupply * 9500 / 100000;      // 9.5% - Development and Management.\r\n        allocations[0x357C2e4253389CE79440e867E9De14E17Bb97D2E] = tempTotalSupply * 3120 / 100000;      // 3.12% - Bonuspool.\r\n        allocations[0xf35FF681cbb69b47488269CE2BA5CaA34133813A] = tempTotalSupply * 14250 / 100000;     // 14.25% - Marketing.\r\n\r\n        balanceOf[0x2A809456adf8bd5A79D598e880f7Bd78e11B4A1c] += tempTotalSupply * 242 / 100000;        \r\n        balanceOf[0x36c321017a8d8655ec7a2b862328678932E53b87] += tempTotalSupply * 242 / 100000;        \r\n        balanceOf[0xc9ebc197Ee00C1E231817b4eb38322C364cFCFCD] += tempTotalSupply * 242 / 100000;\r\n        balanceOf[0x2BE34a67491c6b1f8e0cA3BAA1249c90686CF6FB] += tempTotalSupply * 726 / 100000;\r\n        balanceOf[0x1cF6725538AAcC9574108845D58cF2e89f62bbE9] += tempTotalSupply * 4 / 100000;\r\n        balanceOf[0xc6a3B6ED936bD18FD72e0ae2D50A10B82EF79851] += tempTotalSupply * 130 / 100000;\r\n        balanceOf[0x204Fb77569ca24C09e1425f979141536B89449E3] += tempTotalSupply * 130 / 100000;\r\n\r\n        balanceOf[0xbE3Ece67B61Ef6D3Fd0F8b159d16A80BB04C0F7B] += tempTotalSupply * 164 / 100000;        // Bonuspool.\r\n        balanceOf[0x731953d4c9A01c676fb6b013688AA8D512F5Ec03] += tempTotalSupply * 500 / 100000;        // Development and Management.\r\n        balanceOf[0x84A81f3B42BD99Fd435B1498316F8705f84192bC] += tempTotalSupply * 500 / 100000;        // Founders Pot.\r\n        balanceOf[0xEAeC9b7382e5abEBe76Fc7BDd2Dc22BA1a338918] += tempTotalSupply * 750 / 100000;        // Marketing.\r\n    }\r\n\r\n    /**\r\n    * @dev Public unlock allocated Tokens.\r\n    */\r\n    function unlock() public\r\n    {\r\n        require(!mintingActive, \"Function not available as long as minting is possible.\");\r\n        require(now > unlockAt, \"Unlock date not reached.\");\r\n        require(allocations[msg.sender] > 0, \"No tokens to unlock.\");\r\n        uint256 tempAmount;\r\n\r\n        tempAmount = allocations[msg.sender];\r\n        allocations[msg.sender] = 0;\r\n        balanceOf[msg.sender] += tempAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Public stake function to stake a given amount of tokens for one of the three options.\r\n    * @param _amount Amount to stake.\r\n    * @param _option StakeOption enum with values from 0 to 2.\r\n    * @return Success of stake.\r\n    */\r\n    function stake(uint256 _amount, StakeOption _option, address _receiver) external returns(bool success)\r\n    {\r\n        require(!mintingActive, \"Function not available as long as minting is possible.\");\r\n        require(balanceOf[msg.sender] >= _amount, \"Not enough funds on sender address.\");\r\n        require(_amount >= 100*(10**18), \"Amount is less than 100 token.\");\r\n        require(_receiver != address(0), \"0x00 address not allowed.\");\r\n        uint256 supplyIncrease;\r\n        uint256 finalBalance;\r\n\r\n        supplyIncrease = _stake(_amount, _option, _receiver);\r\n        totalSupply += supplyIncrease;\r\n        balanceOf[msg.sender] -= _amount;\r\n        finalBalance = _amount + supplyIncrease;\r\n\r\n        emit Stake(_receiver, _amount);\r\n        emit Transfer(msg.sender, _receiver, finalBalance);\r\n    \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Public redeem function to redeem all redeemable tokens.\r\n    */\r\n    function redeem() public\r\n    {\r\n        require(userVestingIDs[msg.sender].length > 0, \"No funds to redeem.\");\r\n        uint256 amount;\r\n\r\n        amount = _redeem();\r\n        balanceOf[msg.sender] += amount;\r\n        emit Redeem(msg.sender, amount); \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintDelegate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"name\":\"endDate\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"initiator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address[]\"},{\"name\":\"_mintAmount\",\"type\":\"uint256[]\"}],\"name\":\"mintTokenBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminateMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakeIDs\",\"outputs\":[{\"name\":\"Ids\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_option\",\"type\":\"uint8\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controllerAddress\",\"type\":\"address\"}],\"name\":\"revokeAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDelegate\",\"type\":\"address\"}],\"name\":\"setMintDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controllerAddress\",\"type\":\"address\"}],\"name\":\"giveAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawLOOiX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LOOiXToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://12b4efe5ea2dadb7c14b916891d1fe50e2f749a38113829ecabd71c2433f64ea"}]}