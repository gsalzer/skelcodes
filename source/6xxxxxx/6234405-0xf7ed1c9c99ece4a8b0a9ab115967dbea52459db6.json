{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/nsec3digests/NSEC3Digest.sol\r\n\r\n/**\r\n * @dev Interface for contracts that implement NSEC3 digest algorithms.\r\n */\r\ninterface NSEC3Digest {\r\n    /**\r\n     * @dev Performs an NSEC3 iterated hash.\r\n     * @param salt The salt value to use on each iteration.\r\n     * @param data The data to hash.\r\n     * @param iterations The number of iterations to perform.\r\n     * @return The result of the iterated hash operation.\r\n     */\r\n     function hash(bytes salt, bytes data, uint iterations) external pure returns (bytes32);\r\n}\r\n\r\n// File: @ensdomains/buffer/contracts/Buffer.sol\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n    /**\r\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n    *      a capacity. The capacity may be longer than the current value, in\r\n    *      which case it can be extended without the need to allocate more memory.\r\n    */\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a buffer with an initial capacity.\r\n    * @param buf The buffer to initialize.\r\n    * @param capacity The number of bytes of space to allocate the buffer.\r\n    * @return The buffer, for chaining.\r\n    */\r\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a new buffer from an existing bytes object.\r\n    *      Changes to the buffer may mutate the original value.\r\n    * @param b The bytes object to initialize the buffer with.\r\n    * @return A new buffer.\r\n    */\r\n    function fromBytes(bytes b) internal pure returns(buffer memory) {\r\n        buffer memory buf;\r\n        buf.buf = b;\r\n        buf.capacity = b.length;\r\n        return buf;\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private pure {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets buffer length to 0.\r\n    * @param buf The buffer to truncate.\r\n    * @return The original buffer, for chaining..\r\n    */\r\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n        assembly {\r\n            let bufptr := mload(buf)\r\n            mstore(bufptr, 0)\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The start offset to write to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes data, uint len) internal pure returns(buffer memory) {\r\n        require(len <= data.length);\r\n\r\n        if (off + len + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + offset + sizeof(buffer length)\r\n            dest := add(add(bufptr, 32), off)\r\n            // Update buffer length if we're extending it\r\n            if gt(add(len, off), buflen) {\r\n                mstore(bufptr, add(len, off))\r\n            }\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes data, uint len) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, data.length);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write the byte at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n        if (off > buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + sizeof(buffer length) + off\r\n            let dest := add(add(bufptr, off), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length if we extended it\r\n            if eq(off, buflen) {\r\n                mstore(bufptr, add(buflen, 1))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n        return writeUint8(buf, buf.buf.length, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n    *      exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (left-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        // Right-align data\r\n        data = data >> (8 * (32 - len));\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + sizeof(buffer length) + off + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, off, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chhaining.\r\n    */\r\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, 32);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (right-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + off + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n}\r\n\r\n// File: @ensdomains/solsha1/contracts/SHA1.sol\r\n\r\nlibrary SHA1 {\r\n    event Debug(bytes32 x);\r\n\r\n    function sha1(bytes data) internal pure returns(bytes20 ret) {\r\n        assembly {\r\n            // Get a safe scratch location\r\n            let scratch := mload(0x40)\r\n\r\n            // Get the data length, and point data at the first byte\r\n            let len := mload(data)\r\n            data := add(data, 32)\r\n\r\n            // Find the length after padding\r\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\r\n            switch lt(sub(totallen, len), 9)\r\n            case 1 { totallen := add(totallen, 64) }\r\n\r\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\r\n\r\n            function readword(ptr, off, count) -> result {\r\n                result := 0\r\n                if lt(off, count) {\r\n                    result := mload(add(ptr, off))\r\n                    count := sub(count, off)\r\n                    if lt(count, 32) {\r\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\r\n                        result := and(result, mask)\r\n                    }\r\n                }\r\n            }\r\n\r\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\r\n                mstore(scratch, readword(data, i, len))\r\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\r\n\r\n                // If we loaded the last byte, store the terminator byte\r\n                switch lt(sub(len, i), 64)\r\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\r\n\r\n                // If this is the last block, store the length\r\n                switch eq(i, sub(totallen, 64))\r\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\r\n\r\n                // Expand the 16 32-bit words into 80\r\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\r\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\r\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\r\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\r\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n\r\n                let x := h\r\n                let f := 0\r\n                let k := 0\r\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\r\n                    switch div(j, 20)\r\n                    case 0 {\r\n                        // f = d xor (b and (c xor d))\r\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\r\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x5A827999\r\n                    }\r\n                    case 1{\r\n                        // f = b xor c xor d\r\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x6ED9EBA1\r\n                    }\r\n                    case 2 {\r\n                        // f = (b and c) or (d and (b or c))\r\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := and(div(x, 0x10000000000), f)\r\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\r\n                        k := 0x8F1BBCDC\r\n                    }\r\n                    case 3 {\r\n                        // f = b xor c xor d\r\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0xCA62C1D6\r\n                    }\r\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\r\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\r\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\r\n                    temp := add(f, temp)\r\n                    temp := add(and(x, 0xFFFFFFFF), temp)\r\n                    temp := add(k, temp)\r\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\r\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\r\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\r\n                }\r\n\r\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\r\n            }\r\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/nsec3digests/SHA1NSEC3Digest.sol\r\n\r\n/**\r\n* @dev Implements the DNSSEC iterated SHA1 digest used for NSEC3 records.\r\n*/\r\ncontract SHA1NSEC3Digest is NSEC3Digest {\r\n    using Buffer for Buffer.buffer;\r\n\r\n    function hash(bytes salt, bytes data, uint iterations) external pure returns (bytes32) {\r\n        Buffer.buffer memory buf;\r\n        buf.init(salt.length + data.length + 16);\r\n\r\n        buf.append(data);\r\n        buf.append(salt);\r\n        bytes20 h = SHA1.sha1(buf.buf);\r\n        if (iterations > 0) {\r\n            buf.truncate();\r\n            buf.appendBytes20(bytes20(0));\r\n            buf.append(salt);\r\n\r\n            for (uint i = 0; i < iterations; i++) {\r\n                buf.writeBytes20(0, h);\r\n                h = SHA1.sha1(buf.buf);\r\n            }\r\n        }\r\n\r\n        return bytes32(h);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"iterations\",\"type\":\"uint256\"}],\"name\":\"hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SHA1NSEC3Digest","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://98fe3371a6cce60224e84c55101aba38140a5ed62f8e83c3bd98fc5482c5fdf8"}]}