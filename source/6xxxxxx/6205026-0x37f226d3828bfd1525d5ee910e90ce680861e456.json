{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: contracts/ISimpleCrowdsale.sol\r\n\r\ninterface ISimpleCrowdsale {\r\n    function getSoftCap() external view returns(uint256);\r\n}\r\n\r\n// File: contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract.\r\n    */\r\n    function Ownable(address _owner) public {\r\n        owner = _owner == address(0) ? msg.sender : _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev confirm ownership by a new owner\r\n    */\r\n    function confirmOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// File: contracts/fund/ICrowdsaleFund.sol\r\n\r\n/**\r\n * @title ICrowdsaleFund\r\n * @dev Fund methods used by crowdsale contract\r\n */\r\ninterface ICrowdsaleFund {\r\n    /**\r\n    * @dev Function accepts user`s contributed ether and logs contribution\r\n    * @param contributor Contributor wallet address.\r\n    */\r\n    function processContribution(address contributor) external payable;\r\n    /**\r\n    * @dev Function is called on the end of successful crowdsale\r\n    */\r\n    function onCrowdsaleEnd() external;\r\n    /**\r\n    * @dev Function is called if crowdsale failed to reach soft cap\r\n    */\r\n    function enableCrowdsaleRefund() external;\r\n}\r\n\r\n\r\n// File: contracts/token/IERC20Token.sol\r\n\r\n/**\r\n * @title IERC20Token - ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\r\n    function approve(address _spender, uint256 _value)  public returns (bool success);\r\n    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    /**\r\n    * @dev constructor\r\n    */\r\n    function SafeMath() public {\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/LockedTokens.sol\r\n\r\n/**\r\n * @title LockedTokens\r\n * @dev Lock tokens for certain period of time\r\n */\r\ncontract LockedTokens is SafeMath {\r\n    struct Tokens {\r\n        uint256 amount;\r\n        uint256 lockEndTime;\r\n        bool released;\r\n    }\r\n\r\n    event TokensUnlocked(address _to, uint256 _value);\r\n\r\n    IERC20Token public token;\r\n    address public crowdsaleAddress;\r\n    mapping(address => Tokens[]) public walletTokens;\r\n\r\n    /**\r\n     * @dev LockedTokens constructor\r\n     * @param _token ERC20 compatible token contract\r\n     * @param _crowdsaleAddress Crowdsale contract address\r\n     */\r\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\r\n        token = _token;\r\n        crowdsaleAddress = _crowdsaleAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Functions locks tokens\r\n     * @param _to Wallet address to transfer tokens after _lockEndTime\r\n     * @param _amount Amount of tokens to lock\r\n     * @param _lockEndTime End of lock period\r\n     */\r\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\r\n        require(msg.sender == crowdsaleAddress);\r\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\r\n    }\r\n\r\n    /**\r\n     * @dev Called by owner of locked tokens to release them\r\n     */\r\n    function releaseTokens() public {\r\n        require(walletTokens[msg.sender].length > 0);\r\n\r\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\r\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\r\n                walletTokens[msg.sender][i].released = true;\r\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\r\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ownership/MultiOwnable.sol\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\r\n * functions, this simplifies the implementation of \"users permissions\".\r\n */\r\ncontract MultiOwnable {\r\n    address public manager; // address used to set owners\r\n    address[] public owners;\r\n    mapping(address => bool) public ownerByAddress;\r\n\r\n    event SetOwners(address[] owners);\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerByAddress[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev MultiOwnable constructor sets the manager\r\n     */\r\n    function MultiOwnable() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set owners addresses\r\n     */\r\n    function setOwners(address[] _owners) public {\r\n        require(msg.sender == manager);\r\n        _setOwners(_owners);\r\n\r\n    }\r\n\r\n    function _setOwners(address[] _owners) internal {\r\n        for(uint256 i = 0; i < owners.length; i++) {\r\n            ownerByAddress[owners[i]] = false;\r\n        }\r\n\r\n\r\n        for(uint256 j = 0; j < _owners.length; j++) {\r\n            ownerByAddress[_owners[j]] = true;\r\n        }\r\n        owners = _owners;\r\n        SetOwners(_owners);\r\n    }\r\n\r\n    function getOwners() public constant returns (address[]) {\r\n        return owners;\r\n    }\r\n}\r\n\r\n// File: contracts/token/ERC20Token.sol\r\n\r\n/**\r\n * @title ERC20Token - ERC20 base implementation\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Token is IERC20Token, SafeMath {\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n// File: contracts/token/ITokenEventListener.sol\r\n\r\n/**\r\n * @title ITokenEventListener\r\n * @dev Interface which should be implemented by token listener\r\n */\r\ninterface ITokenEventListener {\r\n    /**\r\n     * @dev Function is called after token transfer/transferFrom\r\n     * @param _from Sender address\r\n     * @param _to Receiver address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function onTokenTransfer(address _from, address _to, uint256 _value) external;\r\n}\r\n\r\n// File: contracts/token/ManagedToken.sol\r\n\r\n/**\r\n * @title ManagedToken\r\n * @dev ERC20 compatible token with issue and destroy facilities\r\n * @dev All transfers can be monitored by token event listener\r\n */\r\ncontract ManagedToken is ERC20Token, MultiOwnable {\r\n    bool public allowTransfers = false;\r\n    bool public issuanceFinished = false;\r\n\r\n    ITokenEventListener public eventListener;\r\n\r\n    event AllowTransfersChanged(bool _newState);\r\n    event Issue(address indexed _to, uint256 _value);\r\n    event Destroy(address indexed _from, uint256 _value);\r\n    event IssuanceFinished();\r\n\r\n    modifier transfersAllowed() {\r\n        require(allowTransfers);\r\n        _;\r\n    }\r\n\r\n    modifier canIssue() {\r\n        require(!issuanceFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev ManagedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     */\r\n    function ManagedToken(address _listener, address[] _owners) public {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        }\r\n        _setOwners(_owners);\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/disable token transfers. Can be called only by owners\r\n     * @param _allowTransfers True - allow False - disable\r\n     */\r\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\r\n        allowTransfers = _allowTransfers;\r\n        AllowTransfersChanged(_allowTransfers);\r\n    }\r\n\r\n    /**\r\n     * @dev Set/remove token event listener\r\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\r\n     */\r\n    function setListener(address _listener) public onlyOwner {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        } else {\r\n            delete eventListener;\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transfer(_to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(_from, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function hasListener() internal view returns(bool) {\r\n        if(eventListener == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Issue tokens to specified wallet\r\n     * @param _to Wallet address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n        totalSupply = safeAdd(totalSupply, _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Issue(_to, _value);\r\n        Transfer(address(0), _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\r\n     * @dev Fund contract address must be in the list of owners to burn token during refund\r\n     * @param _from Wallet address\r\n     * @param _value Amount of tokens to destroy\r\n     */\r\n    function destroy(address _from, uint256 _value) external {\r\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\r\n        require(balances[_from] >= _value);\r\n        totalSupply = safeSub(totalSupply, _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        Transfer(_from, address(0), _value);\r\n        Destroy(_from, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Finish token issuance\r\n     * @return True if success\r\n     */\r\n    function finishIssuance() public onlyOwner returns (bool) {\r\n        issuanceFinished = true;\r\n        IssuanceFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/token/TransferLimitedToken.sol\r\n\r\n/**\r\n * @title TransferLimitedToken\r\n * @dev Token with ability to limit transfers within wallets included in limitedWallets list for certain period of time\r\n */\r\ncontract TransferLimitedToken is ManagedToken {\r\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\r\n\r\n    mapping(address => bool) public limitedWallets;\r\n    uint256 public limitEndDate;\r\n    address public limitedWalletsManager;\r\n    bool public isLimitEnabled;\r\n\r\n    event TransfersEnabled();\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == limitedWalletsManager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if transfer between addresses is available\r\n     * @param _from From address\r\n     * @param _to To address\r\n     */\r\n    modifier canTransfer(address _from, address _to)  {\r\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev TransferLimitedToken constructor\r\n     * @param _limitStartDate Limit start date\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\r\n     */\r\n    function TransferLimitedToken(\r\n        uint256 _limitStartDate,\r\n        address _listener,\r\n        address[] _owners,\r\n        address _limitedWalletsManager\r\n    ) public ManagedToken(_listener, _owners)\r\n    {\r\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\r\n        isLimitEnabled = true;\r\n        limitedWalletsManager = _limitedWalletsManager;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable token transfers\r\n     */\r\n    function enableTransfers() public {\r\n        require(msg.sender == limitedWalletsManager);\r\n        allowTransfers = true;\r\n        TransfersEnabled();\r\n    }\r\n\r\n    /**\r\n     * @dev Add address to limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function addLimitedWalletAddress(address _wallet) public {\r\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\r\n        limitedWallets[_wallet] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Del address from limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\r\n        limitedWallets[_wallet] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Disable transfer limit manually. Can be called only by manager\r\n     */\r\n    function disableLimit() public onlyManager {\r\n        isLimitEnabled = false;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\r\n        return super.approve(_spender,_value);\r\n    }\r\n}\r\n\r\n// File: contracts/Crowdsale.sol\r\n\r\ncontract TheBolthDAICO is Ownable, SafeMath, Pausable, ISimpleCrowdsale {\r\n    enum AdditionalBonusState {\r\n        Unavailable,\r\n        Active,\r\n        Applied\r\n    }\r\n\r\n    uint256 public constant ADDITIONAL_BONUS_NUM = 3;\r\n    uint256 public constant ADDITIONAL_BONUS_DENOM = 100;\r\n\r\n    uint256 public constant ETHER_MIN_CONTRIB = 0.2 ether;\r\n    uint256 public constant ETHER_MAX_CONTRIB = 20 ether;\r\n\r\n    uint256 public constant SALE_START_TIME = 1535529600; // 29.08.2018 08:00:00 UTC\r\n    uint256 public constant SALE_END_TIME = 1536739200; // 12.09.2018 08:00:00 UTC\r\n\r\n    uint256 public constant BONUS_WINDOW_1_END_TIME = SALE_START_TIME + 3 days;\r\n    uint256 public constant BONUS_WINDOW_2_END_TIME = SALE_START_TIME + 6 days;\r\n    uint256 public constant BONUS_WINDOW_3_END_TIME = SALE_START_TIME + 10 days;\r\n\r\n    uint256 public constant MAX_CONTRIB_CHECK_END_TIME = SALE_START_TIME + 1 days;\r\n\r\n    uint256 public tokenPriceNum = 0;\r\n    uint256 public tokenPriceDenom = 0;\r\n    \r\n    TransferLimitedToken public token;\r\n    ICrowdsaleFund public fund;\r\n    LockedTokens public lockedTokens;\r\n\r\n    mapping(address => AdditionalBonusState) public additionalBonusOwnerState;\r\n    mapping(address => uint256) public userTotalContributed;\r\n\r\n    address public mainSaleTokenWallet;\r\n    address public foundationTokenWallet;\r\n    address public advisorsTokenWallet;\r\n    address public teamTokenWallet;\r\n    address public marketingTokenWallet;\r\n\r\n    uint256 public totalEtherContributed = 0;\r\n    uint256 public rawTokenSupply = 0;\r\n\r\n    uint256 public hardCap = 0; // World hard cap will be set right before Token Sale\r\n    uint256 public softCap = 0; // World soft cap will be set right before Token Sale\r\n\r\n    uint256 public tokenMaxSupply;\r\n\r\n    event LogContribution(address contributor, uint256 amountWei, uint256 tokenAmount, uint256 tokenBonus, bool additionalBonusApplied, uint256 timestamp);\r\n\r\n    modifier checkContribution() {\r\n        require(isValidContribution());\r\n        _;\r\n    }\r\n\r\n    modifier checkCap() {\r\n        require(validateCap());\r\n        _;\r\n    }\r\n\r\n    modifier checkTime() {\r\n        require(now >= SALE_START_TIME && now <= SALE_END_TIME);\r\n        _;\r\n    }\r\n\r\n    function TheBolthDAICO(\r\n        address tokenAddress,\r\n        address fundAddress,\r\n        address _mainSaleTokenWallet,\r\n        address _foundationTokenWallet,\r\n        address _advisorsTokenWallet,\r\n        address _teamTokenWallet,\r\n        address _marketingTokenWallet,\r\n        address _owner\r\n    ) public\r\n        Ownable(_owner)\r\n    {\r\n        require(tokenAddress != address(0));\r\n\r\n        token = TransferLimitedToken(tokenAddress);\r\n        fund = ICrowdsaleFund(fundAddress);\r\n\r\n        mainSaleTokenWallet = _mainSaleTokenWallet;\r\n        foundationTokenWallet = _foundationTokenWallet;\r\n        advisorsTokenWallet = _advisorsTokenWallet;\r\n        teamTokenWallet = _teamTokenWallet;\r\n        marketingTokenWallet = _marketingTokenWallet;\r\n\r\n        tokenMaxSupply = 100*10**25; // 1B\r\n    }\r\n\r\n    /**\r\n     * @dev check contribution amount and time\r\n     */\r\n    function isValidContribution() internal view returns(bool) {\r\n        uint256 currentUserContribution = safeAdd(msg.value, userTotalContributed[msg.sender]);\r\n        if(msg.value >= ETHER_MIN_CONTRIB) {\r\n            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB ) {\r\n                    return false;\r\n            }\r\n            return true;\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check hard cap overflow\r\n     */\r\n    function validateCap() internal view returns(bool){\r\n        if(msg.value <= safeSub(hardCap, totalEtherContributed)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Set token price once before start of crowdsale\r\n     */\r\n    function setTokenPrice(uint256 _tokenPriceNum, uint256 _tokenPriceDenom) public onlyOwner {\r\n        require(tokenPriceNum == 0 && tokenPriceDenom == 0);\r\n        require(_tokenPriceNum > 0 && _tokenPriceDenom > 0);\r\n        tokenPriceNum = _tokenPriceNum;\r\n        tokenPriceDenom = _tokenPriceDenom;\r\n    }\r\n\r\n    /**\r\n     * @dev Set hard cap.\r\n     * @param _hardCap - Hard cap value\r\n     */\r\n    function setHardCap(uint256 _hardCap) public onlyOwner {\r\n        require(hardCap == 0);\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Set soft cap.\r\n     * @param _softCap - Soft cap value\r\n     */\r\n    function setSoftCap(uint256 _softCap) public onlyOwner {\r\n        require(softCap == 0);\r\n        softCap = _softCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Get soft cap amount\r\n     **/\r\n    function getSoftCap() external view returns(uint256) {\r\n        return softCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Calc bonus amount by contribution time\r\n     */\r\n    function getBonus() internal constant returns (uint256, uint256) {\r\n        uint256 numerator = 0;\r\n        uint256 denominator = 100;\r\n\r\n        if(now < BONUS_WINDOW_1_END_TIME) {\r\n            numerator = 30;\r\n        } else if(now < BONUS_WINDOW_2_END_TIME) {\r\n            numerator = 15;\r\n        } else if(now < BONUS_WINDOW_3_END_TIME) {\r\n            numerator = 5;\r\n        } else {\r\n            numerator = 0;\r\n        }\r\n\r\n        return (numerator, denominator);\r\n    }\r\n\r\n    function addToLists(\r\n        address _wallet,\r\n        bool isInLimitedList,\r\n        bool hasAdditionalBonus\r\n    ) public onlyOwner {\r\n        if(isInLimitedList) {\r\n            token.addLimitedWalletAddress(_wallet);\r\n        }\r\n        if(hasAdditionalBonus) {\r\n            additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Add wallet to additional bonus members. For contract owner only.\r\n     */\r\n    function addAdditionalBonusMember(address _wallet) public onlyOwner {\r\n        additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\r\n    }\r\n\r\n    /**\r\n     * @dev Set LockedTokens contract address\r\n     */\r\n    function setLockedTokens(address lockedTokensAddress) public onlyOwner {\r\n        lockedTokens = LockedTokens(lockedTokensAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to receive ether contributions\r\n     */\r\n    function () payable public whenNotPaused {\r\n        processContribution(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Process ether contribution. Calc bonuses and issue tokens to contributor.\r\n     */\r\n    function processContribution(address contributor, uint256 amount) private checkTime checkContribution checkCap {\r\n        bool additionalBonusApplied = false;\r\n        uint256 bonusNum = 0;\r\n        uint256 bonusDenom = 100;\r\n        (bonusNum, bonusDenom) = getBonus();\r\n        uint256 tokenBonusAmount = 0;\r\n\r\n        uint256 tokenAmount = safeDiv(safeMul(amount, tokenPriceNum), tokenPriceDenom);\r\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\r\n\r\n        if(bonusNum > 0) {\r\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\r\n        }\r\n\r\n        if(additionalBonusOwnerState[contributor] ==  AdditionalBonusState.Active) {\r\n            additionalBonusOwnerState[contributor] = AdditionalBonusState.Applied;\r\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\r\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\r\n            additionalBonusApplied = true;\r\n        }\r\n\r\n        processPayment(contributor, amount, tokenAmount, tokenBonusAmount, additionalBonusApplied);\r\n    }\r\n\r\n    function processPayment(address contributor, uint256 etherAmount, uint256 tokenAmount, uint256 tokenBonusAmount, bool additionalBonusApplied) internal {\r\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\r\n\r\n        token.issue(contributor, tokenTotalAmount);\r\n        fund.processContribution.value(etherAmount)(contributor);\r\n        totalEtherContributed = safeAdd(totalEtherContributed, etherAmount);\r\n        userTotalContributed[contributor] = safeAdd(userTotalContributed[contributor], etherAmount);\r\n        LogContribution(contributor, etherAmount, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Force crowdsale refund\r\n     */\r\n    function forceCrowdsaleRefund() public onlyOwner {\r\n        pause();\r\n        fund.enableCrowdsaleRefund();\r\n        token.finishIssuance();\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize crowdsale if we reached hard cap or current time > SALE_END_TIME\r\n     */\r\n    function finalizeCrowdsale() public onlyOwner {\r\n        if(\r\n            totalEtherContributed >= hardCap ||\r\n            (now >= SALE_END_TIME && totalEtherContributed >= softCap)\r\n        ) {\r\n            fund.onCrowdsaleEnd();\r\n\r\n            uint256 mintedTokenAmount = token.totalSupply();\r\n            uint256 unmintedTokenAmount = safeSub(tokenMaxSupply, mintedTokenAmount);\r\n\r\n            // Main Sale\r\n            uint256 mainSaleTokenAmount = safeDiv(safeMul(unmintedTokenAmount, 4), 10); // 40 %\r\n            token.issue(address(lockedTokens), mainSaleTokenAmount);\r\n            lockedTokens.addTokens(mainSaleTokenWallet, mainSaleTokenAmount, now + 90 days);\r\n\r\n            // Foundation\r\n            uint256 foundationTokenAmount = safeDiv(safeMul(unmintedTokenAmount, 4), 10); // 40%\r\n            token.issue(foundationTokenWallet, foundationTokenAmount);\r\n\r\n            // Advisors\r\n            uint256 advisorsTokenAmount = safeDiv(safeMul(unmintedTokenAmount, 5), 100); // 5%\r\n            token.issue(address(lockedTokens), advisorsTokenAmount);\r\n            lockedTokens.addTokens(advisorsTokenWallet, advisorsTokenAmount, now + 365 days);\r\n\r\n            // Team\r\n            uint256 teamTokenAmount = safeDiv(safeMul(unmintedTokenAmount, 5), 100); // 5%\r\n            token.issue(address(lockedTokens), teamTokenAmount);\r\n            lockedTokens.addTokens(teamTokenWallet, teamTokenAmount, now + 365 days);\r\n\r\n            // Marketing\r\n            uint256 maketingTokenAmount = safeDiv(safeMul(unmintedTokenAmount, 1), 10); // 10%\r\n            token.issue(marketingTokenWallet, maketingTokenAmount);\r\n\r\n            token.finishIssuance();\r\n\r\n        } else if(now >= SALE_END_TIME) {\r\n            // Enable fund`s crowdsale refund if soft cap is not reached\r\n            fund.enableCrowdsaleRefund();\r\n            token.finishIssuance();\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MIN_CONTRIB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rawTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainSaleTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDITIONAL_BONUS_DENOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addAdditionalBonusMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceCrowdsaleRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"isInLimitedList\",\"type\":\"bool\"},{\"name\":\"hasAdditionalBonus\",\"type\":\"bool\"}],\"name\":\"addToLists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CONTRIB_CHECK_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"additionalBonusOwnerState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lockedTokensAddress\",\"type\":\"address\"}],\"name\":\"setLockedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDITIONAL_BONUS_NUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"name\":\"setHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_softCap\",\"type\":\"uint256\"}],\"name\":\"setSoftCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_2_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_1_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenPriceNum\",\"type\":\"uint256\"},{\"name\":\"_tokenPriceDenom\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MAX_CONTRIB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceDenom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMaxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_3_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"fundAddress\",\"type\":\"address\"},{\"name\":\"_mainSaleTokenWallet\",\"type\":\"address\"},{\"name\":\"_foundationTokenWallet\",\"type\":\"address\"},{\"name\":\"_advisorsTokenWallet\",\"type\":\"address\"},{\"name\":\"_teamTokenWallet\",\"type\":\"address\"},{\"name\":\"_marketingTokenWallet\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"additionalBonusApplied\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TheBolthDAICO","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d5185ddfe672249a1fe9e4accf1da6a08549ff9000000000000000000000000516f02475acf19bad0352ce3759c42adaac0000f00000000000000000000000062f6c1c39edf9f2b5f3d18058713b991761c10a0000000000000000000000000f37a41f6b709aa1efb2ce3ca02f239bf3947ef580000000000000000000000004eb2983ab87efc702212191cbc8ca1bf27ac745f00000000000000000000000058d8a30119f59d38e9b23a02a144f9de70f823cf0000000000000000000000000dceb651b46a6a1bab486cfb9d3a8874adf8e7e60000000000000000000000001b9ecc47fb097a43fb0caf9f0d07dcb5aeaa43d2","Library":"","SwarmSource":"bzzr://eb06ea4bb1b6af6e72218a04f2b99d57c8bb1193b0ac514b5453ce7c20bbb29c"}]}