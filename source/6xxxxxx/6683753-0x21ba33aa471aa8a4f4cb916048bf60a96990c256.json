{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\ncontract DoubleProfit {\r\n    using SafeMath for uint256;\r\n    struct Investor {\r\n        uint256 deposit;\r\n        uint256 paymentTime;\r\n        uint256 withdrawals;\r\n        bool insured;\r\n    }\r\n    uint public countOfInvestors;\r\n    mapping (address => Investor) public investors;\r\n\r\n    uint256 public minimum = 0.01 ether;\r\n    uint step = 5 minutes;\r\n    uint ownerPercent = 2;\r\n    uint promotionPercent = 8;\r\n    uint insurancePercent = 2;\r\n    bool public closed = false;\r\n\r\n    address public ownerAddress = 0x8462372F80b8f1230E2de9e29D173607b8EE6F99;\r\n    address public promotionAddress = 0xefa08884C1e9f7A4A3F87F5134E9D8fe5309Fb59;\r\n    address public insuranceFundAddress;\r\n\r\n    DPInsuranceFund IFContract;\r\n\r\n    event Invest(address indexed investor, uint256 amount);\r\n    event Withdraw(address indexed investor, uint256 amount);\r\n    event UserDelete(address indexed investor);\r\n    event ReturnOfDeposit(address indexed investor, uint256 difference);\r\n\r\n    /**\r\n    * @dev Modifier for access from the InsuranceFund\r\n    */\r\n    modifier onlyIF() {\r\n        require(insuranceFundAddress == msg.sender, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev  Setter the InsuranceFund address. Address can be set only once.\r\n    * @param _insuranceFundAddress Address of the InsuranceFund\r\n    */\r\n    function setInsuranceFundAddress(address _insuranceFundAddress) public{\r\n        require(insuranceFundAddress == address(0x0));\r\n        insuranceFundAddress = _insuranceFundAddress;\r\n        IFContract = DPInsuranceFund(insuranceFundAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev  Set insured from the InsuranceFund.\r\n    * @param _address Investor's address\r\n    * @return Object of investor's information\r\n    */\r\n    function setInsured(address _address) public onlyIF returns(uint256, uint256, bool){\r\n        Investor storage investor = investors[_address];\r\n        investor.insured = true;\r\n        return (investor.deposit, investor.withdrawals, investor.insured);\r\n    }\r\n\r\n    /**\r\n    * @dev  Function for close entrance.\r\n    */\r\n    function closeEntrance() public {\r\n        require(address(this).balance < 0.1 ether && !closed);\r\n        closed = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Get percent depends on balance of contract\r\n    * @return Percent\r\n    */\r\n    function getPhasePercent() view public returns (uint){\r\n        uint contractBalance = address(this).balance;\r\n\r\n        if (contractBalance >= 5000 ether) {\r\n            return(88);\r\n        }\r\n        if (contractBalance >= 2500 ether) {\r\n            return(75);\r\n        }\r\n        if (contractBalance >= 1000 ether) {\r\n            return(60);\r\n        }\r\n        if (contractBalance >= 500 ether) {\r\n            return(50);\r\n        }\r\n        if (contractBalance >= 100 ether) {\r\n            return(42);\r\n        } else {\r\n            return(35);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Allocation budgets\r\n    */\r\n    function allocation() private{\r\n        ownerAddress.transfer(msg.value.mul(ownerPercent).div(100));\r\n        promotionAddress.transfer(msg.value.mul(promotionPercent).div(100));\r\n        insuranceFundAddress.transfer(msg.value.mul(insurancePercent).div(100));\r\n    }\r\n\r\n    /**\r\n    * @dev Evaluate current balance\r\n    * @param _address Address of investor\r\n    * @return Payout amount\r\n    */\r\n    function getUserBalance(address _address) view public returns (uint256) {\r\n        Investor storage investor = investors[_address];\r\n        uint percent = getPhasePercent();\r\n        uint256 differentTime = now.sub(investor.paymentTime).div(step);\r\n        uint256 differentPercent = investor.deposit.mul(percent).div(1000);\r\n        uint256 payout = differentPercent.mul(differentTime).div(288);\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw profit from contract. Investor will be deleted if he will try withdraw after received x2\r\n    */\r\n    function withdraw() private {\r\n        Investor storage investor = investors[msg.sender];\r\n        uint256 balance = getUserBalance(msg.sender);\r\n        if (investor.deposit > 0 && address(this).balance > balance && balance > 0) {\r\n            uint256 tempWithdrawals = investor.withdrawals;\r\n\r\n            investor.withdrawals = investor.withdrawals.add(balance);\r\n            investor.paymentTime = now;\r\n\r\n            if (investor.withdrawals >= investor.deposit.mul(2)){\r\n                investor.deposit = 0;\r\n                investor.paymentTime = 0;\r\n                investor.withdrawals = 0;\r\n                countOfInvestors--;\r\n                if (investor.insured)\r\n                    IFContract.deleteInsured(msg.sender);\r\n                investor.insured = false;\r\n                emit UserDelete(msg.sender);\r\n            } else {\r\n                if (investor.insured && tempWithdrawals < investor.deposit){\r\n                    IFContract.setInfo(msg.sender, investor.deposit, investor.withdrawals);\r\n                }\r\n            }\r\n            msg.sender.transfer(balance);\r\n            emit Withdraw(msg.sender, balance);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev  Payable function for\r\n    * - receive funds (send minimum 0.01 ETH),\r\n    * - calm your profit (send 0 ETH)\r\n    * - withdraw deposit (send 0.00000112 ether)\r\n    */\r\n    function () external payable {\r\n        require(!closed);\r\n        Investor storage investor = investors[msg.sender];\r\n        if (msg.value >= minimum){\r\n\r\n            if (investor.deposit == 0){\r\n                countOfInvestors++;\r\n            } else {\r\n                withdraw();\r\n            }\r\n\r\n            investor.deposit = investor.deposit.add(msg.value);\r\n            investor.paymentTime = now;\r\n\r\n            if (investor.insured){\r\n                IFContract.setInfo(msg.sender, investor.deposit, investor.withdrawals);\r\n            }\r\n            allocation();\r\n            emit Invest(msg.sender, msg.value);\r\n        } else if (msg.value == 0.00000112 ether) {\r\n            returnDeposit();\r\n        } else {\r\n            withdraw();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev  Withdraw your deposit from the project\r\n    */\r\n    function returnDeposit() private {\r\n        Investor storage investor = investors[msg.sender];\r\n        require(investor.deposit > 0);\r\n        withdraw();\r\n        uint withdrawalAmount = investor.deposit.sub(investor.withdrawals).sub(investor.deposit.mul(ownerPercent + promotionPercent + insurancePercent).div(100));\r\n        investor.deposit = 0;\r\n        investor.paymentTime = 0;\r\n        investor.withdrawals = 0;\r\n        countOfInvestors--;\r\n        if (investor.insured)\r\n            IFContract.deleteInsured(msg.sender);\r\n        investor.insured = false;\r\n        emit UserDelete(msg.sender);\r\n        msg.sender.transfer(withdrawalAmount);\r\n        emit ReturnOfDeposit(msg.sender, withdrawalAmount);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\n library SafeMath {\r\n\r\n     function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n         if (_a == 0) {\r\n             return 0;\r\n         }\r\n\r\n         uint256 c = _a * _b;\r\n         require(c / _a == _b);\r\n\r\n         return c;\r\n     }\r\n\r\n     function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n         require(_b > 0);\r\n         uint256 c = _a / _b;\r\n\r\n         return c;\r\n     }\r\n\r\n     function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n         require(_b <= _a);\r\n         uint256 c = _a - _b;\r\n\r\n         return c;\r\n     }\r\n\r\n     function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n         uint256 c = _a + _b;\r\n         require(c >= _a);\r\n\r\n         return c;\r\n     }\r\n\r\n     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n         require(b != 0);\r\n         return a % b;\r\n     }\r\n }\r\n\r\n\r\n/**\r\n* It is insurance smart-contract for the DoubleProfit.\r\n* You can buy insurance for 10% and if you do not take 100% profit when balance of\r\n* the DoubleProfit will be lesser then 0.01 you can receive part of insurance fund depend on your not received money.\r\n*\r\n* To buy insurance:\r\n* Send to the contract address 10% of your deposit, and you will be accounted to.\r\n*\r\n* To receive insurance payout:\r\n* Send to the contract address 0 ETH, and you will receive part of insurance depend on your not received money.\r\n* If you already received 100% from your deposit, you will take error.\r\n*/\r\ncontract DPInsuranceFund {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n    * @dev Structure for evaluating payout\r\n    * @param deposit Duplicated from DoubleProfit deposit\r\n    * @param withdrawals Duplicated from DoubleProfit withdrawals\r\n    * @param insured Flag for available payout\r\n    */\r\n    struct Investor {\r\n        uint256 deposit;\r\n        uint256 withdrawals;\r\n        bool insured;\r\n    }\r\n    mapping (address => Investor) public investors;\r\n    uint public countOfInvestors;\r\n\r\n    bool public startOfPayments = false;\r\n    uint256 public totalSupply;\r\n\r\n    uint256 public totalNotReceived;\r\n    address public DPAddress;\r\n\r\n    DoubleProfit DPContract;\r\n\r\n    event Paid(address investor, uint256 amount, uint256  notRecieve, uint256  partOfNotReceived);\r\n    event SetInfo(address investor, uint256  notRecieve, uint256 deposit, uint256 withdrawals);\r\n\r\n    /**\r\n    * @dev  Modifier for access from the DoubleProfit\r\n    */\r\n    modifier onlyDP() {\r\n        require(msg.sender == DPAddress, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev  Setter the DoubleProfit address. Address can be set only once.\r\n    * @param _DPAddress Address of the DoubleProfit\r\n    */\r\n    function setDPAddress(address _DPAddress) public {\r\n        require(DPAddress == address(0x0));\r\n        DPAddress = _DPAddress;\r\n        DPContract = DoubleProfit(DPAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev  Private setter info about investor. Can be call if payouts not started.\r\n    * Needing for evaluating not received total amount without loops.\r\n    * @param _address Investor's address\r\n    * @param deposit Investor's deposit\r\n    * @param withdrawals Investor's withdrawals\r\n    */\r\n    function privateSetInfo(address _address, uint256 deposit, uint256 withdrawals) private{\r\n        if (!startOfPayments) {\r\n            Investor storage investor = investors[_address];\r\n\r\n            if (investor.deposit != deposit){\r\n                totalNotReceived = totalNotReceived.add(deposit.sub(investor.deposit));\r\n                investor.deposit = deposit;\r\n            }\r\n\r\n            if (investor.withdrawals != withdrawals){\r\n                uint256 different;\r\n\r\n                if (investor.deposit <= withdrawals){\r\n                    different = investor.deposit.sub(investor.withdrawals);\r\n                    if (totalNotReceived >= different && different != 0)\r\n                        totalNotReceived = totalNotReceived.sub(different);\r\n                    else\r\n                        totalNotReceived = 0;\r\n                    withdrawals = investor.deposit;\r\n                } else {\r\n                    different = withdrawals.sub(investor.withdrawals);\r\n                    if (totalNotReceived >= different)\r\n                        totalNotReceived = totalNotReceived.sub(different);\r\n                    else\r\n                        totalNotReceived = 0;\r\n\r\n                }\r\n            }\r\n            investor.withdrawals = withdrawals;\r\n            emit SetInfo(_address, totalNotReceived, investor.deposit, investor.withdrawals);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev  Setter info about investor from the DoubleProfit.\r\n    * @param _address Investor's address\r\n    * @param deposit Investor's deposit\r\n    * @param withdrawals Investor's withdrawals\r\n    */\r\n    function setInfo(address _address, uint256 deposit, uint256 withdrawals) public onlyDP {\r\n        privateSetInfo(_address, deposit, withdrawals);\r\n    }\r\n\r\n    /**\r\n    * @dev  Delete insured from the DoubleProfit.\r\n    * @param _address Investor's address\r\n    */\r\n    function deleteInsured(address _address) public onlyDP {\r\n        Investor storage investor = investors[_address];\r\n        investor.deposit = 0;\r\n        investor.withdrawals = 0;\r\n        investor.insured = false;\r\n        countOfInvestors--;\r\n    }\r\n\r\n    /**\r\n    * @dev  Function for starting payouts and stopping receive funds.\r\n    */\r\n    function beginOfPayments() public {\r\n        require(address(DPAddress).balance < 0.1 ether && !startOfPayments);\r\n        startOfPayments = true;\r\n        totalSupply = address(this).balance;\r\n    }\r\n\r\n    /**\r\n    * @dev  Payable function for receive funds, buying insurance and receive insurance payouts .\r\n    */\r\n    function () external payable {\r\n        Investor storage investor = investors[msg.sender];\r\n        if (msg.value > 0){\r\n            require(!startOfPayments);\r\n            if (msg.sender != DPAddress && msg.value >= 0.1 ether) {\r\n                require(countOfInvestors.add(1) <= DPContract.countOfInvestors().mul(32).div(100));\r\n                uint256 deposit;\r\n                uint256 withdrawals;\r\n                (deposit, withdrawals, investor.insured) = DPContract.setInsured(msg.sender);\r\n                require(msg.value >= deposit.div(10) && deposit > 0);\r\n                if (msg.value > deposit.div(10)) {\r\n                    msg.sender.transfer(msg.value - deposit.div(10));\r\n                }\r\n                countOfInvestors++;\r\n                privateSetInfo(msg.sender, deposit, withdrawals);\r\n            }\r\n        } else if (msg.value == 0){\r\n            uint256 notReceived = investor.deposit.sub(investor.withdrawals);\r\n            uint256 partOfNotReceived = notReceived.mul(100).div(totalNotReceived);\r\n            uint256 payAmount = totalSupply.div(100).mul(partOfNotReceived);\r\n            require(startOfPayments && investor.insured && notReceived > 0);\r\n            investor.insured = false;\r\n            msg.sender.transfer(payAmount);\r\n            emit Paid(msg.sender, payAmount, notReceived, partOfNotReceived);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"closeEntrance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPhasePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setInsured\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_insuranceFundAddress\",\"type\":\"address\"}],\"name\":\"setInsuranceFundAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"withdrawals\",\"type\":\"uint256\"},{\"name\":\"insured\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promotionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insuranceFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"UserDelete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"ReturnOfDeposit\",\"type\":\"event\"}]","ContractName":"DoubleProfit","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://abdf48f03a3df0672d1745a5aac5707f3f1edd6de30e85a2ee190c34d5b7afe9"}]}