{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract F3Devents {\r\n    \r\n  // winner has win round of value\r\n  event Winner(address winner, uint256 round, uint256 value);\r\n  \r\n  event Buy(address buyer, uint256 keys, uint256 cost, uint256 round);\r\n\r\n  event Lucky(address buyer, uint256 round, uint256 lucky, uint256 amount);\r\n  \r\n  event Register(address user, uint256 id, uint256 value, uint256 ref);\r\n  \r\n  event Referer(address referral, uint256 pUser);          //referral has been recommended by pUser\r\n  \r\n  event NewRound(uint256 round, uint256 pool);\r\n  \r\n  event FinalizeRound(uint256 round);\r\n  \r\n  event Withdrawal(address player, uint256 amount, uint256 fee);\r\n}\r\n\r\ncontract F3d is F3Devents {\r\n  using SafeMath for *;\r\n\r\n\r\n  // uint256 public maxProfit;                          // user win maximum                         5\r\n  uint256 public luckyNumber;                           //every luckyNumber user get extra win      888\r\n  \r\n  uint256 public toSpread;                              //percentage goes to holder                 580\r\n  uint256 public toOwner;                               //percentage goes to owner                  20\r\n  uint256 public toNext;                                //percentage goes to next round             50\r\n  uint256 public toRefer;                               //goes to refer                             100\r\n  uint256 public toPool;                                //goes to pool                              250\r\n  \r\n  uint256 public toLucky;                               //goes to lucky guy, which                  294\r\n  \r\n  // uint256 public roundTime;                          //time length of each round                 24 * 60 * 60\r\n  uint256 public timeIncrease;                          //time increase when user buy keys          60\r\n  uint256 public maxRound;                              //the maximum round number                  12\r\n  uint256 public registerFee;                           //fee for register                          0.01ether\r\n  uint256 public withdrawFee;\r\n  uint256 public minimumWithdraw;\r\n  \r\n  uint256 public playersCount;                          //number of registerted players\r\n  \r\n  uint256 public decimals = 10 ** 18;\r\n\r\n  \r\n  bool public pause;\r\n  uint256 public ownerPool;\r\n  address public admin;\r\n\r\n  mapping(address => PlayerStatus) public players;\r\n  mapping(address => uint256) public playerIds;\r\n  mapping(uint256 => address) public id2Players;\r\n  mapping(uint256 => Round) public rounds;\r\n  mapping(address => mapping (uint256 => PlayerRound)) public playerRoundData;\r\n  // uint256 public currentRound;                       seems we don't need this\r\n  uint256 public nextRound;\r\n  \r\n    \r\n  address public owner1=0x6779043e0f2A0bE96D1532fD07EAa1072E018F22;\r\n  address public owner2=0xa8c5Bcb8547b434Dfd55bbAAf0b15d07BCdCa04f;\r\n  bool public owner1OK;\r\n  bool public owner2OK;\r\n  uint256 public ownerWithdraw;\r\n  address public ownerWithdrawTo;\r\n  \r\n  function kill() public{// only allow this action if the account sending the signal is the creator\r\n      if (msg.sender == admin){\r\n          selfdestruct(admin);       // kills this contract and sends remaining funds back to creator\r\n      }  \r\n  }\r\n  function ownerTake(uint256 amount, address to) public onlyOwner {\r\n      require(!owner1OK && !owner2OK);\r\n      ownerWithdrawTo = to;\r\n      ownerWithdraw = amount;\r\n      if (msg.sender == owner1) {\r\n          owner1OK = true;\r\n      }\r\n      if (msg.sender == owner2) {\r\n          owner2OK = true;\r\n      }\r\n  }\r\n  \r\n  function agree(uint256 amount, address to) public onlyOwner {\r\n      require(amount == ownerWithdraw && to == ownerWithdrawTo);\r\n      if(msg.sender == owner1) {\r\n          require(owner2OK);\r\n      }\r\n      if(msg.sender == owner2) {\r\n          require(owner1OK);\r\n      }\r\n      assert(ownerWithdrawTo != address(0));\r\n      require(amount <= ownerPool);\r\n      ownerPool = ownerPool.sub(amount);\r\n      ownerWithdrawTo.transfer(amount);\r\n      owner1OK = false;\r\n      owner2OK = false;\r\n      ownerWithdraw = 0;\r\n      ownerWithdrawTo = address(0);\r\n  }\r\n  \r\n  function cancel() onlyOwner public {\r\n      owner1OK = false;\r\n      owner2OK = false;\r\n      ownerWithdraw = 0;\r\n      ownerWithdrawTo = address(0);\r\n  }\r\n  \r\n  struct PlayerStatus {\r\n    address addr;          //player addr\r\n    uint256 wallet;        //get from spread\r\n    uint256 affiliate;     //get from reference\r\n    uint256 win;           //get from winning\r\n    uint256 lucky;          //eth get from lucky\r\n    uint256 referer;       //who introduced this player\r\n  }\r\n  \r\n  struct PlayerRound {\r\n      uint256 eth;         //eth player added to this round\r\n      uint256 keys;        //keys player bought in this round\r\n      uint256 mask;        //player mask in this round\r\n      uint256 lucky;       //player lucky profit in this round\r\n      uint256 affiliate;   //player affiliate in this round\r\n      uint256 win;        //player pool in this round\r\n  }\r\n  \r\n  struct Round {\r\n      uint256 eth;                //eth to this round\r\n      uint256 keys;               //keys sold in this round\r\n      uint256 mask;               //mask of this round, up by 10**18\r\n      address winner;             //winner of this round\r\n      uint256 pool;               //the amount of pool when ends\r\n      uint256 minimumPool;        //the minimum requirement to open a pool\r\n      uint256 nextLucky;          //the next lucky number\r\n      uint256 luckyCounter;       //count of luckyBuys (buy that is more than 10 keys)\r\n      uint256 luckyPool;          //amount of eth in luckyPool\r\n      uint256 endTime;            //the end time\r\n      uint256 roundTime;          //different round has different round time\r\n      bool    finalized;          //whether this round has been finalized\r\n      bool    activated;          //whether this round has been activated\r\n      // uint256 players;            //count of players in this round\r\n  }\r\n  \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner1 || msg.sender == owner2);\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused() {\r\n    require(!pause);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n      require(msg.sender == admin);\r\n      _;\r\n  }\r\n  \r\n  function setPause(bool _pause) onlyAdmin public {\r\n    pause = _pause;\r\n  }\r\n\r\n  constructor(uint256 _lucky, uint256 _maxRound,\r\n  uint256 _toSpread, uint256 _toOwner, uint256 _toNext, uint256 _toRefer, uint256 _toPool, uint256 _toLucky,\r\n  uint256 _increase,\r\n  uint256 _registerFee, uint256 _withdrawFee) public {\r\n      \r\n    luckyNumber = _lucky;\r\n    maxRound = _maxRound;\r\n\r\n    toSpread = _toSpread;\r\n    toOwner = _toOwner;\r\n    toNext = _toNext;\r\n    toRefer = _toRefer;\r\n    toPool = _toPool;\r\n    toLucky = _toLucky;\r\n    \r\n    timeIncrease = _increase;\r\n\r\n    registerFee = _registerFee;\r\n    withdrawFee = _withdrawFee;\r\n    \r\n    assert(maxRound <= 12); //can't be more than 12, otherwise the game time will be zero\r\n    \r\n    // split less than 100%\r\n    assert(toSpread.add(toOwner).add(toNext).add(toRefer).add(toPool) == 1000);\r\n\r\n    // owner1 = _owner1;\r\n    // owner2 = _owner2;\r\n\r\n    // start from first round\r\n    // currentRound = 1;\r\n    nextRound = 1;\r\n    playersCount = 1;  //by default there is one player\r\n    \r\n    uint256 _miniMumPool = 0;\r\n    for(uint256 i = 0; i < maxRound; i ++) {\r\n        //TESTING uint256 roundTime = 12 * 60 * 60 - 60 * 60 * (i);   //roundTime\r\n        uint256 roundTime = 12 * 60 - 60 * (i);   //roundTime\r\n\r\n        rounds[i] = Round(\r\n          0,                                  //eth\r\n          0,                                  //keys\r\n          0,                                  //mask\r\n          address(0),                         //winner\r\n          0,                                  //pool\r\n          _miniMumPool,                       //minimumPool\r\n          luckyNumber,                        //luckyNumber\r\n          0,                                  //luckyCounter\r\n          0,                                  //luckyPool\r\n          0,                                  //endTime it's not accurate\r\n          roundTime,                          //roundTime\r\n          false,                              //finalized\r\n          false                               //activated\r\n          // 0                                   //players\r\n        );\r\n        if(i == 0) {\r\n          //TESTING _miniMumPool = 100 * (10 ** 18);\r\n          _miniMumPool = 1 * (10 ** 18);\r\n        } else {\r\n          _miniMumPool = _miniMumPool.mul(2);\r\n        }\r\n    }\r\n    admin = msg.sender;\r\n  }\r\n\r\n  function start1stRound() public {\r\n      require(!rounds[0].activated);\r\n      rounds[0].activated = true;\r\n      rounds[0].endTime = block.timestamp.add(rounds[0].roundTime);\r\n  }\r\n\r\n  /*\r\n  function roundProfitByAddr(address _pAddr, uint256 _round) public view returns (uint256) {\r\n      return roundProfit(_pAddr, _round);\r\n  }*/\r\n  \r\n  function roundProfit(address _pAddr, uint256 _round) public view returns (uint256) {\r\n      return calculateMasked(_pAddr, _round);\r\n  }\r\n  \r\n  function totalProfit(address _pAddr) public view returns (uint256) {\r\n      uint256 masked = profit(_pAddr);\r\n      PlayerStatus memory player = players[_pAddr];\r\n      /*\r\n        uint256 wallet;        //get from spread\r\n        uint256 affiliate;     //get from reference\r\n        uint256 win;           //get from winning\r\n        uint256 referer;       //who introduced this player\r\n        uint256 lucky;   \r\n        */\r\n      return masked.add(player.wallet).add(player.affiliate).add(player.win).add(player.lucky);\r\n  }\r\n\r\n  function profit(address _pAddr) public view returns (uint256) {\r\n      uint256 userProfit = 0;\r\n      for(uint256 i = 0; i < nextRound; i ++) {\r\n          userProfit = userProfit.add(roundProfit(_pAddr, i));\r\n      }\r\n      return userProfit;\r\n  }\r\n  \r\n  function calculateMasked(address _pAddr, uint256 _round) private view returns (uint256) {\r\n      PlayerRound memory roundData = playerRoundData[_pAddr][_round];\r\n      return (rounds[_round].mask.mul(roundData.keys) / (10**18)).sub(roundData.mask);\r\n  }\r\n  \r\n  /**\r\n   * user register a link\r\n   */\r\n  function register(uint256 ref) public payable {\r\n      require(playerIds[msg.sender] == 0 && msg.value >= registerFee);\r\n      ownerPool = msg.value.add(ownerPool);\r\n      playerIds[msg.sender] = playersCount;\r\n      id2Players[playersCount] = msg.sender;\r\n      playersCount = playersCount.add(1);\r\n      \r\n      //maybe this player already has some profit\r\n      players[msg.sender].referer = ref;\r\n      \r\n      emit Register(msg.sender, playersCount.sub(1), msg.value, ref);\r\n  }\r\n  \r\n  function logRef(address addr, uint256 ref) public {\r\n      if(players[addr].referer == 0 && ref != 0) {\r\n          players[addr].referer = ref;\r\n    \r\n          emit Referer(addr, ref);\r\n      }\r\n  }\r\n  \r\n  // anyone can finalize a round\r\n  function finalize(uint256 _round) public {\r\n      Round storage round = rounds[_round];\r\n      // round must be finished\r\n      require(block.timestamp > round.endTime && round.activated && !round.finalized);\r\n      \r\n      // register the user if necessary\r\n      // no automated registration now?\r\n      // registerUserIfNeeded(ref);\r\n    \r\n      //finalize this round\r\n      round.finalized = true;\r\n      uint256 pool2Next = 0;\r\n      if(round.winner != address(0)) {\r\n        players[round.winner].win = round.pool.add(players[round.winner].win);\r\n        playerRoundData[round.winner][_round].win = round.pool.add(playerRoundData[round.winner][_round].win);\r\n\r\n        emit Winner(round.winner, _round, round.pool);\r\n      } else {\r\n        // ownerPool = ownerPool.add(round.pool);\r\n        // to next pool\r\n        // if no one wins this round, the money goes to next pool\r\n        pool2Next = round.pool;\r\n      }\r\n      \r\n      emit FinalizeRound(_round);\r\n      \r\n      if (_round == (maxRound.sub(1))) {\r\n          // if we're finalizing the last round\r\n          // things will be a little different\r\n          // first there'll be no more next round\r\n          ownerPool = ownerPool.add(pool2Next);\r\n          return;\r\n      }\r\n\r\n      Round storage next = rounds[nextRound];\r\n      \r\n      if (nextRound == maxRound) {\r\n          next = rounds[maxRound - 1];\r\n      }\r\n      \r\n      next.pool = pool2Next.add(next.pool);\r\n      \r\n      if(!next.activated && nextRound == (_round.add(1))) {\r\n          // if this is the last unactivated round, and there's still next Round\r\n          // activate it\r\n          next.activated = true;\r\n          next.endTime = block.timestamp.add(next.roundTime);\r\n          // next.pool = pool2Next.add(next.pool);\r\n\r\n          emit NewRound(nextRound, next.pool);\r\n\r\n          if(nextRound < maxRound) {\r\n            nextRound = nextRound.add(1);\r\n          }\r\n      }\r\n  }\r\n  \r\n  // _pID spent _eth to buy keys in _round\r\n  function core(uint256 _round, address _pAddr, uint256 _eth) internal {\r\n      require(_round < maxRound);\r\n      Round storage current = rounds[_round];\r\n      require(current.activated && !current.finalized);\r\n\r\n      // new to this round\r\n      // we can't update user profit into one wallet\r\n      // since user may attend mulitple rounds in this mode\r\n      // the client should check each rounds' profit and do withdrawal\r\n      /*\r\n      if (playerRoundData[_pID][_round].keys == 0) {\r\n          updatePlayer(_pID);\r\n      }*/\r\n      \r\n      if (block.timestamp > current.endTime) {\r\n          //we need to do finalzing\r\n          finalize(_round);\r\n          players[_pAddr].wallet = _eth.add(players[_pAddr].wallet);\r\n          return;\r\n          // new round generated, we need to update the user status to the new round \r\n          // no need to update\r\n          /*\r\n          updatePlayer(_pID);\r\n          */\r\n      }\r\n      \r\n      if (_eth < 1000000000) {\r\n          players[_pAddr].wallet = _eth.add(players[_pAddr].wallet);\r\n          return;\r\n      }\r\n      \r\n      // calculate the keys that he could buy\r\n      uint256 _keys = keys(current.eth, _eth);\r\n      \r\n      if (_keys <= 0) {\r\n          // put the eth to the sender\r\n          // sorry, you're bumped\r\n          players[_pAddr].wallet = _eth.add(players[_pAddr].wallet);\r\n          return;\r\n      }\r\n\r\n      if (_keys >= decimals) {\r\n          // buy at least one key to be the winner \r\n          current.winner = _pAddr;\r\n          current.endTime = timeIncrease.add(current.endTime.mul(_keys / decimals));\r\n          if (current.endTime.sub(block.timestamp) > current.roundTime) {\r\n              current.endTime = block.timestamp.add(current.roundTime);\r\n          }\r\n          \r\n          if (_keys >= decimals.mul(10)) {\r\n              // if one has bought more than 10 keys\r\n              current.luckyCounter = current.luckyCounter.add(1);\r\n              if(current.luckyCounter >= current.nextLucky) {\r\n                  players[_pAddr].lucky = current.luckyPool.add(players[_pAddr].lucky);\r\n                  playerRoundData[_pAddr][_round].lucky = current.luckyPool.add(playerRoundData[_pAddr][_round].lucky);\r\n                  \r\n                  emit Lucky(_pAddr, _round, current.nextLucky, current.luckyPool);\r\n                  \r\n                  current.pool = current.pool.sub(current.luckyPool);\r\n                  current.luckyPool = 0;\r\n                  current.nextLucky = luckyNumber.add(current.nextLucky);\r\n                  \r\n              }\r\n          }\r\n      }\r\n      \r\n      //now we do the money distribute\r\n      uint256 toOwnerAmount = _eth.sub(_eth.mul(toSpread) / 1000);\r\n      toOwnerAmount = toOwnerAmount.sub(_eth.mul(toNext) / 1000);\r\n      toOwnerAmount = toOwnerAmount.sub(_eth.mul(toRefer) / 1000);\r\n      toOwnerAmount = toOwnerAmount.sub(_eth.mul(toPool) / 1000);\r\n      current.pool = (_eth.mul(toPool) / 1000).add(current.pool);\r\n      current.luckyPool = ((_eth.mul(toPool) / 1000).mul(toLucky) / 1000).add(current.luckyPool);\r\n      \r\n      if (current.keys == 0) {\r\n          // current no keys to split, send to owner\r\n          toOwnerAmount = toOwnerAmount.add((_eth.mul(toSpread) / 1000));\r\n      } else {\r\n          // the mask is up by 10^18\r\n          current.mask = current.mask.add((_eth.mul(toSpread).mul(10 ** 15)) / current.keys);\r\n          // dust to owner;\r\n          // need to check about the dust\r\n          /*\r\n          uint256 dust = (_eth.mul(toSpread) / 1000)\r\n            .sub( \r\n                (_eth.mul(toSpread).mul(10**15) / current.keys * current.keys) / (10 ** 18) \r\n            );*/\r\n          // forget about the dust\r\n          // ownerPool = toOwnerAmount.add(dust).add(ownerPool);\r\n      }\r\n      ownerPool = toOwnerAmount.add(ownerPool);\r\n\r\n      // the split doesnt include keys that the user just bought\r\n      playerRoundData[_pAddr][_round].keys = _keys.add(playerRoundData[_pAddr][_round].keys);\r\n      current.keys = _keys.add(current.keys);\r\n      current.eth = _eth.add(current.eth);\r\n\r\n      // for the new keys, remove the user's free earnings\r\n      // this may cause some loose\r\n      playerRoundData[_pAddr][_round].mask = (current.mask.mul(_keys) / (10**18)).add(playerRoundData[_pAddr][_round].mask);\r\n      \r\n      // to referer, or to ownerPool\r\n      if (players[_pAddr].referer == 0) {\r\n          ownerPool = ownerPool.add(_eth.mul(toRefer) / 1000);\r\n      } else {\r\n          address _referer = id2Players[players[_pAddr].referer];\r\n          assert(_referer != address(0));\r\n          players[_referer].affiliate = (_eth.mul(toRefer) / 1000).add(players[_referer].affiliate);\r\n          playerRoundData[_referer][_round].affiliate = (_eth.mul(toRefer) / 1000).add(playerRoundData[_referer][_round].affiliate);\r\n      }\r\n\r\n      // to unopened round\r\n      // round 12 will always be the nextRound even after it's been activated\r\n      Round storage next = rounds[nextRound];\r\n      \r\n      if (nextRound >= maxRound) {\t \r\n          next = rounds[maxRound - 1];\t \r\n      }\r\n      \r\n      next.pool = (_eth.mul(toNext) / 1000).add(next.pool);\r\n      // current.luckyPool = _eth.mul(toLucky).add(current.luckyPool);\r\n        \r\n      // open next round if necessary\r\n      if(next.pool >= next.minimumPool && !next.activated) {\r\n        next.activated = true;\r\n        next.endTime = block.timestamp.add(next.roundTime);\r\n        // ??? winner鏄皝\r\n        next.winner = address(0);\r\n\r\n        if(nextRound != maxRound) {\r\n          nextRound = nextRound.add(1);\r\n        }\r\n      }\r\n      \r\n      emit Buy(_pAddr, _keys, _eth, _round);\r\n\r\n  }\r\n  \r\n  // calculate the keys that the user can buy with specified amount of eth\r\n  // return the eth left\r\n  function BuyKeys(uint256 ref, uint256 _round) payable whenNotPaused public {\r\n      logRef(msg.sender, ref);\r\n      core(_round, msg.sender, msg.value);\r\n  }\r\n\r\n  function ReloadKeys(uint256 ref, uint256 _round, uint256 value) whenNotPaused public {\r\n      logRef(msg.sender, ref);\r\n      players[msg.sender].wallet = retrieveEarnings(msg.sender).sub(value);\r\n      core(_round, msg.sender, value);\r\n  }\r\n  \r\n  function reloadRound(address _pAddr, uint256 _round) internal returns (uint256) {\r\n      uint256 _earn = calculateMasked(_pAddr, _round);\r\n      if (_earn > 0) {\r\n          playerRoundData[_pAddr][_round].mask = _earn.add(playerRoundData[_pAddr][_round].mask);\r\n      }\r\n      return _earn;\r\n  }\r\n  \r\n  function retrieveEarnings(address _pAddr) internal returns (uint256) {\r\n      PlayerStatus storage player = players[_pAddr];\r\n      \r\n      uint256 earnings = player.wallet\r\n        .add(player.affiliate)\r\n        .add(player.win)\r\n        .add(player.lucky);\r\n       /*\r\n          address addr;          //player addr\r\n\r\n          uint256 wallet;        //get from spread\r\n          uint256 affiliate;     //get from reference\r\n          uint256 win;           //get from winning\r\n          uint256 lucky;          //eth get from lucky\r\n\r\n          uint256 referer;       //who introduced this player\r\n\r\n        */\r\n      player.wallet = 0;\r\n      player.affiliate = 0;\r\n      player.win = 0;\r\n      player.lucky = 0;\r\n      for(uint256 i = 0; i <= nextRound; i ++) {\r\n          uint256 roundEarnings = reloadRound(_pAddr, i);\r\n          earnings = earnings.add(roundEarnings);\r\n      }\r\n\r\n      return earnings;\r\n  }\r\n  \r\n  /*\r\n  function withdrawalRound(address _pAddr, uint256 _round) public {\r\n      uint256 userProfit = roundProfit(_pAddr, _round);\r\n      if (userProfit == 0) return;\r\n      playerRoundData[_pAddr][_round].mask = userProfit.add(playerRoundData[_pAddr][_round].mask);\r\n      players[_pAddr].wallet = userProfit.add(players[_pAddr].wallet);\r\n      return;\r\n  }*/\r\n  \r\n  // withdrawal all the earning of the game\r\n  function withdrawal() whenNotPaused public {\r\n      uint256 ret = retrieveEarnings(msg.sender);\r\n      require(ret >= minimumWithdraw);\r\n      uint256 fee = ret.mul(withdrawFee) / 1000;\r\n      ownerPool = ownerPool.add(fee);\r\n      ret = ret.sub(fee);\r\n      msg.sender.transfer(ret);\r\n      \r\n      emit Withdrawal(msg.sender, ret, fee);\r\n  }\r\n\r\n  function priceForKeys(uint256 keys, uint256 round) public view returns(uint256) {\r\n      require(round < maxRound);\r\n      return eth(rounds[round].keys, keys);\r\n  }\r\n  \r\n  function remainTime(uint256 _round) public view returns (int256) {\r\n      if (!rounds[_round].activated) {\r\n          return -2;\r\n      }\r\n      \r\n      if (rounds[_round].finalized) {\r\n          return -1;\r\n      }\r\n      \r\n      if (rounds[_round].endTime <= block.timestamp) {\r\n          return 0;\r\n      } else {\r\n          return int256(rounds[_round].endTime - block.timestamp);\r\n      }\r\n  }\r\n\r\n    function keys(uint256 _curEth, uint256 _newEth) internal pure returns(uint256) {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n\r\n    function eth(uint256 _curKeys, uint256 _newKeys) internal pure returns(uint256) {\r\n        return eth((_curKeys).add(_newKeys)).sub(eth(_curKeys));\r\n    }\r\n    \r\n    /**\r\n        * @dev calculates how much eth would be in contract given a number of keys\r\n        * @param _keys number of keys \"in contract\" \r\n        * @return eth that would exists\r\n        */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_pAddr\",\"type\":\"address\"}],\"name\":\"profit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner2OK\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"BuyKeys\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"agree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start1stRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"id2Players\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toLucky\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWithdrawTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pAddr\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"roundProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"},{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReloadKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"priceForKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerRoundData\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"lucky\",\"type\":\"uint256\"},{\"name\":\"affiliate\",\"type\":\"uint256\"},{\"name\":\"win\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ownerTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"pool\",\"type\":\"uint256\"},{\"name\":\"minimumPool\",\"type\":\"uint256\"},{\"name\":\"nextLucky\",\"type\":\"uint256\"},{\"name\":\"luckyCounter\",\"type\":\"uint256\"},{\"name\":\"luckyPool\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"roundTime\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"},{\"name\":\"activated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"remainTime\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pAddr\",\"type\":\"address\"}],\"name\":\"totalProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"logRef\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeIncrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner1OK\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"uint256\"},{\"name\":\"affiliate\",\"type\":\"uint256\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"lucky\",\"type\":\"uint256\"},{\"name\":\"referer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toSpread\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toRefer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toNext\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_lucky\",\"type\":\"uint256\"},{\"name\":\"_maxRound\",\"type\":\"uint256\"},{\"name\":\"_toSpread\",\"type\":\"uint256\"},{\"name\":\"_toOwner\",\"type\":\"uint256\"},{\"name\":\"_toNext\",\"type\":\"uint256\"},{\"name\":\"_toRefer\",\"type\":\"uint256\"},{\"name\":\"_toPool\",\"type\":\"uint256\"},{\"name\":\"_toLucky\",\"type\":\"uint256\"},{\"name\":\"_increase\",\"type\":\"uint256\"},{\"name\":\"_registerFee\",\"type\":\"uint256\"},{\"name\":\"_withdrawFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lucky\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Lucky\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ref\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pUser\",\"type\":\"uint256\"}],\"name\":\"Referer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pool\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"FinalizeRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"F3d","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000378000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000024400000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000001e","Library":"","SwarmSource":"bzzr://1fc43846c2e3476a0e8f9d854b21f564009a67f9f3968e897d0072405824a3e5"}]}