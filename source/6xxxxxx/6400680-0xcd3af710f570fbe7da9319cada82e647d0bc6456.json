{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\n/*\r\n\r\n    Copyright 2018 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/lib/Fraction.sol\r\n\r\n/**\r\n * @title Fraction\r\n * @author dYdX\r\n *\r\n * This library contains implementations for fraction structs.\r\n */\r\nlibrary Fraction {\r\n    struct Fraction128 {\r\n        uint128 num;\r\n        uint128 den;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/FractionMath.sol\r\n\r\n/**\r\n * @title FractionMath\r\n * @author dYdX\r\n *\r\n * This library contains safe math functions for manipulating fractions.\r\n */\r\nlibrary FractionMath {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint128;\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a + b\r\n     *\r\n     * @param  a  The first Fraction128\r\n     * @param  b  The second Fraction128\r\n     * @return    The result (sum)\r\n     */\r\n    function add(\r\n        Fraction.Fraction128 memory a,\r\n        Fraction.Fraction128 memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        uint256 left = a.num.mul(b.den);\r\n        uint256 right = b.num.mul(a.den);\r\n        uint256 denominator = a.den.mul(b.den);\r\n\r\n        // if left + right overflows, prevent overflow\r\n        if (left + right < left) {\r\n            left = left.div(2);\r\n            right = right.div(2);\r\n            denominator = denominator.div(2);\r\n        }\r\n\r\n        return bound(left.add(right), denominator);\r\n    }\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a - (1/2)^d\r\n     *\r\n     * @param  a  The Fraction128\r\n     * @param  d  The power of (1/2)\r\n     * @return    The result\r\n     */\r\n    function sub1Over(\r\n        Fraction.Fraction128 memory a,\r\n        uint128 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        if (a.den % d == 0) {\r\n            return bound(\r\n                a.num.sub(a.den.div(d)),\r\n                a.den\r\n            );\r\n        }\r\n        return bound(\r\n            a.num.mul(d).sub(a.den),\r\n            a.den.mul(d)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a / d\r\n     *\r\n     * @param  a  The first Fraction128\r\n     * @param  d  The divisor\r\n     * @return    The result (quotient)\r\n     */\r\n    function div(\r\n        Fraction.Fraction128 memory a,\r\n        uint128 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        if (a.num % d == 0) {\r\n            return bound(\r\n                a.num.div(d),\r\n                a.den\r\n            );\r\n        }\r\n        return bound(\r\n            a.num,\r\n            a.den.mul(d)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a * b.\r\n     *\r\n     * @param  a  The first Fraction128\r\n     * @param  b  The second Fraction128\r\n     * @return    The result (product)\r\n     */\r\n    function mul(\r\n        Fraction.Fraction128 memory a,\r\n        Fraction.Fraction128 memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        return bound(\r\n            a.num.mul(b.num),\r\n            a.den.mul(b.den)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns a fraction from two uint256's. Fits them into uint128 if necessary.\r\n     *\r\n     * @param  num  The numerator\r\n     * @param  den  The denominator\r\n     * @return      The Fraction128 that matches num/den most closely\r\n     */\r\n    /* solium-disable-next-line security/no-assign-params */\r\n    function bound(\r\n        uint256 num,\r\n        uint256 den\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        uint256 max = num > den ? num : den;\r\n        uint256 first128Bits = (max >> 128);\r\n        if (first128Bits != 0) {\r\n            first128Bits += 1;\r\n            num /= first128Bits;\r\n            den /= first128Bits;\r\n        }\r\n\r\n        assert(den != 0); // coverage-enable-line\r\n        assert(den < 2**128);\r\n        assert(num < 2**128);\r\n\r\n        return Fraction.Fraction128({\r\n            num: uint128(num),\r\n            den: uint128(den)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns an in-memory copy of a Fraction128\r\n     *\r\n     * @param  a  The Fraction128 to copy\r\n     * @return    A copy of the Fraction128\r\n     */\r\n    function copy(\r\n        Fraction.Fraction128 memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        validate(a);\r\n        return Fraction.Fraction128({ num: a.num, den: a.den });\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Asserts that a Fraction128 is valid (i.e. the denominator is non-zero)\r\n     *\r\n     * @param  a  The Fraction128 to validate\r\n     */\r\n    function validate(\r\n        Fraction.Fraction128 memory a\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        assert(a.den != 0); // coverage-enable-line\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Exponent.sol\r\n\r\n/**\r\n * @title Exponent\r\n * @author dYdX\r\n *\r\n * This library contains an implementation for calculating e^X for arbitrary fraction X\r\n */\r\nlibrary Exponent {\r\n    using SafeMath for uint256;\r\n    using FractionMath for Fraction.Fraction128;\r\n\r\n    // ============ Constants ============\r\n\r\n    // 2**128 - 1\r\n    uint128 constant public MAX_NUMERATOR = 340282366920938463463374607431768211455;\r\n\r\n    // Number of precomputed integers, X, for E^((1/2)^X)\r\n    uint256 constant public MAX_PRECOMPUTE_PRECISION = 32;\r\n\r\n    // Number of precomputed integers, X, for E^X\r\n    uint256 constant public NUM_PRECOMPUTED_INTEGERS = 32;\r\n\r\n    // ============ Public Implementation Functions ============\r\n\r\n    /**\r\n     * Returns e^X for any fraction X\r\n     *\r\n     * @param  X                    The exponent\r\n     * @param  precomputePrecision  Accuracy of precomputed terms\r\n     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\r\n     * @return                      e^X\r\n     */\r\n    function exp(\r\n        Fraction.Fraction128 memory X,\r\n        uint256 precomputePrecision,\r\n        uint256 maclaurinPrecision\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        require(\r\n            precomputePrecision <= MAX_PRECOMPUTE_PRECISION,\r\n            \"Exponent#exp: Precompute precision over maximum\"\r\n        );\r\n\r\n        Fraction.Fraction128 memory Xcopy = X.copy();\r\n        if (Xcopy.num == 0) { // e^0 = 1\r\n            return ONE();\r\n        }\r\n\r\n        // get the integer value of the fraction (example: 9/4 is 2.25 so has integerValue of 2)\r\n        uint256 integerX = uint256(Xcopy.num).div(Xcopy.den);\r\n\r\n        // if X is less than 1, then just calculate X\r\n        if (integerX == 0) {\r\n            return expHybrid(Xcopy, precomputePrecision, maclaurinPrecision);\r\n        }\r\n\r\n        // get e^integerX\r\n        Fraction.Fraction128 memory expOfInt =\r\n            getPrecomputedEToThe(integerX % NUM_PRECOMPUTED_INTEGERS);\r\n        while (integerX >= NUM_PRECOMPUTED_INTEGERS) {\r\n            expOfInt = expOfInt.mul(getPrecomputedEToThe(NUM_PRECOMPUTED_INTEGERS));\r\n            integerX -= NUM_PRECOMPUTED_INTEGERS;\r\n        }\r\n\r\n        // multiply e^integerX by e^decimalX\r\n        Fraction.Fraction128 memory decimalX = Fraction.Fraction128({\r\n            num: Xcopy.num % Xcopy.den,\r\n            den: Xcopy.den\r\n        });\r\n        return expHybrid(decimalX, precomputePrecision, maclaurinPrecision).mul(expOfInt);\r\n    }\r\n\r\n    /**\r\n     * Returns e^X for any X < 1. Multiplies precomputed values to get close to the real value, then\r\n     * Maclaurin Series approximation to reduce error.\r\n     *\r\n     * @param  X                    Exponent\r\n     * @param  precomputePrecision  Accuracy of precomputed terms\r\n     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\r\n     * @return                      e^X\r\n     */\r\n    function expHybrid(\r\n        Fraction.Fraction128 memory X,\r\n        uint256 precomputePrecision,\r\n        uint256 maclaurinPrecision\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        assert(precomputePrecision <= MAX_PRECOMPUTE_PRECISION);\r\n        assert(X.num < X.den);\r\n        // will also throw if precomputePrecision is larger than the array length in getDenominator\r\n\r\n        Fraction.Fraction128 memory Xtemp = X.copy();\r\n        if (Xtemp.num == 0) { // e^0 = 1\r\n            return ONE();\r\n        }\r\n\r\n        Fraction.Fraction128 memory result = ONE();\r\n\r\n        uint256 d = 1; // 2^i\r\n        for (uint256 i = 1; i <= precomputePrecision; i++) {\r\n            d *= 2;\r\n\r\n            // if Fraction > 1/d, subtract 1/d and multiply result by precomputed e^(1/d)\r\n            if (d.mul(Xtemp.num) >= Xtemp.den) {\r\n                Xtemp = Xtemp.sub1Over(uint128(d));\r\n                result = result.mul(getPrecomputedEToTheHalfToThe(i));\r\n            }\r\n        }\r\n        return result.mul(expMaclaurin(Xtemp, maclaurinPrecision));\r\n    }\r\n\r\n    /**\r\n     * Returns e^X for any X, using Maclaurin Series approximation\r\n     *\r\n     * e^X = SUM(X^n / n!) for n >= 0\r\n     * e^X = 1 + X/1! + X^2/2! + X^3/3! ...\r\n     *\r\n     * @param  X           Exponent\r\n     * @param  precision   Accuracy of Maclaurin terms\r\n     * @return             e^X\r\n     */\r\n    function expMaclaurin(\r\n        Fraction.Fraction128 memory X,\r\n        uint256 precision\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        Fraction.Fraction128 memory Xcopy = X.copy();\r\n        if (Xcopy.num == 0) { // e^0 = 1\r\n            return ONE();\r\n        }\r\n\r\n        Fraction.Fraction128 memory result = ONE();\r\n        Fraction.Fraction128 memory Xtemp = ONE();\r\n        for (uint256 i = 1; i <= precision; i++) {\r\n            Xtemp = Xtemp.mul(Xcopy.div(uint128(i)));\r\n            result = result.add(Xtemp);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a fraction roughly equaling E^((1/2)^x) for integer x\r\n     */\r\n    function getPrecomputedEToTheHalfToThe(\r\n        uint256 x\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        assert(x <= MAX_PRECOMPUTE_PRECISION);\r\n\r\n        uint128 denominator = [\r\n            125182886983370532117250726298150828301,\r\n            206391688497133195273760705512282642279,\r\n            265012173823417992016237332255925138361,\r\n            300298134811882980317033350418940119802,\r\n            319665700530617779809390163992561606014,\r\n            329812979126047300897653247035862915816,\r\n            335006777809430963166468914297166288162,\r\n            337634268532609249517744113622081347950,\r\n            338955731696479810470146282672867036734,\r\n            339618401537809365075354109784799900812,\r\n            339950222128463181389559457827561204959,\r\n            340116253979683015278260491021941090650,\r\n            340199300311581465057079429423749235412,\r\n            340240831081268226777032180141478221816,\r\n            340261598367316729254995498374473399540,\r\n            340271982485676106947851156443492415142,\r\n            340277174663693808406010255284800906112,\r\n            340279770782412691177936847400746725466,\r\n            340281068849199706686796915841848278311,\r\n            340281717884450116236033378667952410919,\r\n            340282042402539547492367191008339680733,\r\n            340282204661700319870089970029119685699,\r\n            340282285791309720262481214385569134454,\r\n            340282326356121674011576912006427792656,\r\n            340282346638529464274601981200276914173,\r\n            340282356779733812753265346086924801364,\r\n            340282361850336100329388676752133324799,\r\n            340282364385637272451648746721404212564,\r\n            340282365653287865596328444437856608255,\r\n            340282366287113163939555716675618384724,\r\n            340282366604025813553891209601455838559,\r\n            340282366762482138471739420386372790954,\r\n            340282366841710300958333641874363209044\r\n        ][x];\r\n        return Fraction.Fraction128({\r\n            num: MAX_NUMERATOR,\r\n            den: denominator\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a fraction roughly equaling E^(x) for integer x\r\n     */\r\n    function getPrecomputedEToThe(\r\n        uint256 x\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        assert(x <= NUM_PRECOMPUTED_INTEGERS);\r\n\r\n        uint128 denominator = [\r\n            340282366920938463463374607431768211455,\r\n            125182886983370532117250726298150828301,\r\n            46052210507670172419625860892627118820,\r\n            16941661466271327126146327822211253888,\r\n            6232488952727653950957829210887653621,\r\n            2292804553036637136093891217529878878,\r\n            843475657686456657683449904934172134,\r\n            310297353591408453462393329342695980,\r\n            114152017036184782947077973323212575,\r\n            41994180235864621538772677139808695,\r\n            15448795557622704876497742989562086,\r\n            5683294276510101335127414470015662,\r\n            2090767122455392675095471286328463,\r\n            769150240628514374138961856925097,\r\n            282954560699298259527814398449860,\r\n            104093165666968799599694528310221,\r\n            38293735615330848145349245349513,\r\n            14087478058534870382224480725096,\r\n            5182493555688763339001418388912,\r\n            1906532833141383353974257736699,\r\n            701374233231058797338605168652,\r\n            258021160973090761055471434334,\r\n            94920680509187392077350434438,\r\n            34919366901332874995585576427,\r\n            12846117181722897538509298435,\r\n            4725822410035083116489797150,\r\n            1738532907279185132707372378,\r\n            639570514388029575350057932,\r\n            235284843422800231081973821,\r\n            86556456714490055457751527,\r\n            31842340925906738090071268,\r\n            11714142585413118080082437,\r\n            4309392228124372433711936\r\n        ][x];\r\n        return Fraction.Fraction128({\r\n            num: MAX_NUMERATOR,\r\n            den: denominator\r\n        });\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    function ONE()\r\n        private\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        return Fraction.Fraction128({ num: 1, den: 1 });\r\n    }\r\n}\r\n\r\n// File: contracts/lib/MathHelpers.sol\r\n\r\n/**\r\n * @title MathHelpers\r\n * @author dYdX\r\n *\r\n * This library helps with common math functions in Solidity\r\n */\r\nlibrary MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              target * numerator / denominator\r\n     */\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return numerator.mul(target).div(denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              Rounded-up result of target * numerator / denominator\r\n     */\r\n    function getPartialAmountRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return divisionRoundedUp(numerator.mul(target), denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates division given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator.\r\n     * @param  denominator  Denominator.\r\n     * @return              Rounded-up result of numerator / denominator\r\n     */\r\n    function divisionRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(denominator != 0); // coverage-enable-line\r\n        if (numerator == 0) {\r\n            return 0;\r\n        }\r\n        return numerator.sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint256(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint32(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        return 2 ** 32 - 1;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\r\n     *\r\n     * @param  n  The uint256 to get the number of bits in\r\n     * @return    The number of bits in n\r\n     */\r\n    function getNumBits(\r\n        uint256 n\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 first = 0;\r\n        uint256 last = 256;\r\n        while (first < last) {\r\n            uint256 check = (first + last) / 2;\r\n            if ((n >> check) == 0) {\r\n                last = check;\r\n            } else {\r\n                first = check + 1;\r\n            }\r\n        }\r\n        assert(first <= 256);\r\n        return first;\r\n    }\r\n}\r\n\r\n// File: contracts/margin/impl/InterestImpl.sol\r\n\r\n/**\r\n * @title InterestImpl\r\n * @author dYdX\r\n *\r\n * A library that calculates continuously compounded interest for principal, time period, and\r\n * interest rate.\r\n */\r\nlibrary InterestImpl {\r\n    using SafeMath for uint256;\r\n    using FractionMath for Fraction.Fraction128;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant DEFAULT_PRECOMPUTE_PRECISION = 11;\r\n\r\n    uint256 constant DEFAULT_MACLAURIN_PRECISION = 5;\r\n\r\n    uint256 constant MAXIMUM_EXPONENT = 80;\r\n\r\n    uint128 constant E_TO_MAXIUMUM_EXPONENT = 55406223843935100525711733958316613;\r\n\r\n    // ============ Public Implementation Functions ============\r\n\r\n    /**\r\n     * Returns total tokens owed after accruing interest. Continuously compounding and accurate to\r\n     * roughly 10^18 decimal places. Continuously compounding interest follows the formula:\r\n     * I = P * e^(R*T)\r\n     *\r\n     * @param  principal           Principal of the interest calculation\r\n     * @param  interestRate        Annual nominal interest percentage times 10**6.\r\n     *                             (example: 5% = 5e6)\r\n     * @param  secondsOfInterest   Number of seconds that interest has been accruing\r\n     * @return                     Total amount of tokens owed. Greater than tokenAmount.\r\n     */\r\n    function getCompoundedInterest(\r\n        uint256 principal,\r\n        uint256 interestRate,\r\n        uint256 secondsOfInterest\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numerator = interestRate.mul(secondsOfInterest);\r\n        uint128 denominator = (10**8) * (365 * 1 days);\r\n\r\n        // interestRate and secondsOfInterest should both be uint32\r\n        assert(numerator < 2**128);\r\n\r\n        // fraction representing (Rate * Time)\r\n        Fraction.Fraction128 memory rt = Fraction.Fraction128({\r\n            num: uint128(numerator),\r\n            den: denominator\r\n        });\r\n\r\n        // calculate e^(RT)\r\n        Fraction.Fraction128 memory eToRT;\r\n        if (numerator.div(denominator) >= MAXIMUM_EXPONENT) {\r\n            // degenerate case: cap calculation\r\n            eToRT = Fraction.Fraction128({\r\n                num: E_TO_MAXIUMUM_EXPONENT,\r\n                den: 1\r\n            });\r\n        } else {\r\n            // normal case: calculate e^(RT)\r\n            eToRT = Exponent.exp(\r\n                rt,\r\n                DEFAULT_PRECOMPUTE_PRECISION,\r\n                DEFAULT_MACLAURIN_PRECISION\r\n            );\r\n        }\r\n\r\n        // e^X for positive X should be greater-than or equal to 1\r\n        assert(eToRT.num >= eToRT.den);\r\n\r\n        return safeMultiplyUint256ByFraction(principal, eToRT);\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Returns n * f, trying to prevent overflow as much as possible. Assumes that the numerator\r\n     * and denominator of f are less than 2**128.\r\n     */\r\n    function safeMultiplyUint256ByFraction(\r\n        uint256 n,\r\n        Fraction.Fraction128 memory f\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 term1 = n.div(2 ** 128); // first 128 bits\r\n        uint256 term2 = n % (2 ** 128); // second 128 bits\r\n\r\n        // uncommon scenario, requires n >= 2**128. calculates term1 = term1 * f\r\n        if (term1 > 0) {\r\n            term1 = term1.mul(f.num);\r\n            uint256 numBits = MathHelpers.getNumBits(term1);\r\n\r\n            // reduce rounding error by shifting all the way to the left before dividing\r\n            term1 = MathHelpers.divisionRoundedUp(\r\n                term1 << (uint256(256).sub(numBits)),\r\n                f.den);\r\n\r\n            // continue shifting or reduce shifting to get the right number\r\n            if (numBits > 128) {\r\n                term1 = term1 << (numBits.sub(128));\r\n            } else if (numBits < 128) {\r\n                term1 = term1 >> (uint256(128).sub(numBits));\r\n            }\r\n        }\r\n\r\n        // calculates term2 = term2 * f\r\n        term2 = MathHelpers.getPartialAmountRoundedUp(\r\n            f.num,\r\n            f.den,\r\n            term2\r\n        );\r\n\r\n        return term1.add(term2);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"principal\",\"type\":\"uint256\"},{\"name\":\"interestRate\",\"type\":\"uint256\"},{\"name\":\"secondsOfInterest\",\"type\":\"uint256\"}],\"name\":\"getCompoundedInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"InterestImpl","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://261a67c7d048c1459aa23f000c9d4e26318dfe5c5acc1b6dee074ddf99fbdbb9"}]}