{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    hasMintPermission\r\n    canMint\r\n    public\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/NectarToken.sol\r\n\r\ncontract NectarToken is MintableToken {\r\n    string public name = \"Nectar\";\r\n    string public symbol = \"NCT\";\r\n    uint8 public decimals = 18;\r\n\r\n    bool public transfersEnabled = false;\r\n    event TransfersEnabled();\r\n\r\n    // Disable transfers until after the sale\r\n    modifier whenTransfersEnabled() {\r\n        require(transfersEnabled, \"Transfers not enabled\");\r\n        _;\r\n    }\r\n\r\n    modifier whenTransfersNotEnabled() {\r\n        require(!transfersEnabled, \"Transfers enabled\");\r\n        _;\r\n    }\r\n\r\n    function enableTransfers() public onlyOwner whenTransfersNotEnabled {\r\n        transfersEnabled = true;\r\n        emit TransfersEnabled();\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public whenTransfersEnabled returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public whenTransfersEnabled returns (bool) {\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    // Approves and then calls the receiving contract\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        // Call the receiveApproval function on the contract you want to be notified.\r\n        // This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //\r\n        // receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //\r\n        // It is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\r\n        // solium-disable-next-line security/no-low-level-calls, indentation\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))),\r\n            msg.sender, _value, this, _extraData), \"receiveApproval failed\");\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/OfferMultiSig.sol\r\n\r\ncontract OfferMultiSig is Pausable {\r\n    using SafeMath for uint256;\r\n    \r\n    string public constant NAME = \"Offer MultiSig\";\r\n    string public constant VERSION = \"0.0.1\";\r\n    uint256 public constant MIN_SETTLEMENT_PERIOD = 10;\r\n    uint256 public constant MAX_SETTLEMENT_PERIOD = 3600;\r\n\r\n    event CommunicationsSet(\r\n        bytes32 websocketUri\r\n    );\r\n\r\n    event OpenedAgreement(\r\n        address _ambassador\r\n    );\r\n\r\n    event CanceledAgreement(\r\n        address _ambassador\r\n    );\r\n\r\n    event JoinedAgreement(\r\n        address _expert\r\n    );\r\n\r\n    event ClosedAgreement(\r\n        address _expert,\r\n        address _ambassador\r\n    );\r\n\r\n    event FundsDeposited(\r\n        address _ambassador,\r\n        address _expert,\r\n        uint256 ambassadorBalance,\r\n        uint256 expertBalance\r\n    );\r\n\r\n    event StartedSettle(\r\n        address initiator,\r\n        uint sequence,\r\n        uint settlementPeriodEnd\r\n    );\r\n\r\n    event SettleStateChallenged(\r\n        address challenger,\r\n        uint sequence,\r\n        uint settlementPeriodEnd\r\n    );\r\n\r\n    address public nectarAddress; // Address of offer nectar token\r\n    address public ambassador; // Address of first channel participant\r\n    address public expert; // Address of second channel participant\r\n    \r\n    bool public isOpen = false; // true when both parties have joined\r\n    bool public isPending = false; // true when waiting for counterparty to join agreement\r\n\r\n    uint public settlementPeriodLength; // How long challengers have to reply to settle engagement\r\n    uint public isClosed; // if the period has closed\r\n    uint public sequence; // state nonce used in during settlement\r\n    uint public isInSettlementState; // meta channel is in settling 1: Not settling 0\r\n    uint public settlementPeriodEnd; // The time when challenges are no longer accepted after\r\n\r\n    bytes public state; // the current state\r\n    bytes32 public websocketUri; // a geth node running whisper (shh)\r\n\r\n    constructor(address _nectarAddress, address _ambassador, address _expert, uint _settlementPeriodLength) public {\r\n        require(_ambassador != address(0), \"No ambassador lib provided to constructor\");\r\n        require(_expert != address(0), \"No expert provided to constructor\");\r\n        require(_nectarAddress != address(0), \"No token provided to constructor\");\r\n\r\n        // solium-disable-next-line indentation\r\n        require(_settlementPeriodLength >= MIN_SETTLEMENT_PERIOD && _settlementPeriodLength <= MAX_SETTLEMENT_PERIOD,\r\n            \"Settlement period out of range\");\r\n\r\n        ambassador = _ambassador;\r\n        expert = _expert;\r\n        settlementPeriodLength = _settlementPeriodLength;\r\n        nectarAddress = _nectarAddress;\r\n    }\r\n\r\n    /** Function only callable by participants */\r\n    modifier onlyParticipants() {\r\n        require(msg.sender == ambassador || msg.sender == expert, \"msg.sender is not a participant\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador to open channel with _expert \r\n     * \r\n     * @param _state inital offer state\r\n     * @param _v the recovery id from signature of state\r\n     * @param _r output of ECDSA signature of state\r\n     * @param _s output of ECDSA signature of state\r\n     */\r\n    function openAgreement(bytes _state, uint8 _v, bytes32 _r, bytes32 _s) public whenNotPaused {\r\n        // require the channel is not open yet\r\n        require(isOpen == false, \"openAgreement already called, isOpen true\");\r\n        require(isPending == false, \"openAgreement already called, isPending true\");\r\n        require(msg.sender == ambassador, \"msg.sender is not the ambassador\");\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n        require(msg.sender == getPartyA(_state), \"Party A does not match signature recovery\");\r\n\r\n        // check the account opening a channel signed the initial state\r\n        address initiator = getSig(_state, _v, _r, _s);\r\n\r\n        require(ambassador == initiator, \"Initiator in state is not the ambassador\");\r\n\r\n        isPending = true;\r\n\r\n        state = _state;\r\n\r\n        open(_state);\r\n\r\n        emit OpenedAgreement(ambassador);\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador to cancel a channel that hasn't been joined yet\r\n     */\r\n    function cancelAgreement() public whenNotPaused {\r\n        // require the channel is not open yet\r\n        require(isPending == true, \"Only a channel in a pending state can be canceled\");\r\n        require(msg.sender == ambassador, \"Only an ambassador can cancel an agreement\");\r\n\r\n        isPending = false;\r\n\r\n        cancel(nectarAddress);\r\n\r\n        emit CanceledAgreement(ambassador);\r\n    }\r\n\r\n    /**\r\n     * Function called by expert to complete opening the channel with an ambassador defined in the _state\r\n     * \r\n     * @param _state offer state from ambassador\r\n     * @param _v the recovery id from signature of state\r\n     * @param _r output of ECDSA signature  of state\r\n     * @param _s output of ECDSA signature of state\r\n     */\r\n    function joinAgreement(bytes _state, uint8 _v, bytes32 _r, bytes32 _s) public whenNotPaused {\r\n        require(isOpen == false, \"openAgreement already called, isOpen true\");\r\n        require(msg.sender == expert, \"msg.sender is not the expert\");\r\n        require(isPending, \"Offer not pending\");\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n\r\n        // check that the state is signed by the sender and sender is in the state\r\n        address joiningParty = getSig(_state, _v, _r, _s);\r\n\r\n        require(expert == joiningParty, \"Joining party in state is not the expert\");\r\n\r\n        // no longer allow joining functions to be called\r\n        isOpen = true;\r\n\r\n        isPending = false;\r\n\r\n        join(state);\r\n\r\n        emit JoinedAgreement(expert);\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador to update balance and add to escrow\r\n     * by default to escrows the allowed balance\r\n     * @param _state offer state from ambassador\r\n     * @param _sigV the recovery id from signature of state by both parties\r\n     * @param _sigR output of ECDSA signature  of state by both parties\r\n     * @param _sigS output of ECDSA signature of state by both parties\r\n     * @dev index 0 is the ambassador signature\r\n     * @dev index 1 is the expert signature\r\n     */\r\n    function depositFunds(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\r\n        require(isOpen == true, \"Tried adding funds to a closed msig wallet\");\r\n        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\r\n        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n        // Require both signatures\r\n        require(_hasAllSigs(_ambassador, _expert), \"Missing signatures\");\r\n\r\n        state = _state;\r\n\r\n        update(_state);\r\n\r\n        emit FundsDeposited(_ambassador, _expert, getBalanceA(_state), getBalanceB(_state));\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador or expert to close a their channel after a dispute has timedout\r\n     *\r\n     * @param _state final offer state agreed on by both parties through dispute settlement\r\n     * @param _sigV the recovery id from signature of state by both parties\r\n     * @param _sigR output of ECDSA signature  of state by both parties\r\n     * @param _sigS output of ECDSA signature of state by both parties\r\n     * @dev index 0 is the ambassador signature\r\n     * @dev index 1 is the expert signature\r\n     */\r\n    function closeAgreementWithTimeout(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\r\n        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\r\n        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n        require(settlementPeriodEnd <= block.number, \"Settlement period hasn't ended\");\r\n        require(isClosed == 0, \"Offer is closed\");\r\n        require(isInSettlementState == 1, \"Offer is not in settlement state\");\r\n\r\n        require(_hasAllSigs(_ambassador, _expert), \"Missing signatures\");\r\n        require(keccak256(state) == keccak256(_state), \"State hash mismatch\");\r\n\r\n        isClosed = 1;\r\n\r\n        finalize(_state);\r\n        isOpen = false;\r\n\r\n        emit ClosedAgreement(_expert, _ambassador);\r\n    }\r\n\r\n\r\n    /**\r\n     * Function called by ambassador or expert to close a their channel with close flag\r\n     *\r\n     * @param _state final offer state agreed on by both parties with close flag\r\n     * @param _sigV the recovery id from signature of state by both parties\r\n     * @param _sigR output of ECDSA signature  of state by both parties\r\n     * @param _sigS output of ECDSA signature of state by both parties\r\n     * @dev index 0 is the ambassador signature\r\n     * @dev index 1 is the expert signature\r\n     */\r\n    function closeAgreement(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\r\n        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\r\n        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n        require(isClosed == 0, \"Offer is closed\");\r\n        \r\n        /// @dev make sure we're not in dispute\r\n        require(isInSettlementState == 0, \"Offer is in settlement state\");\r\n\r\n        /// @dev must have close flag\r\n        require(_isClosed(_state), \"State did not have a signed close out state\");\r\n        require(_hasAllSigs(_ambassador, _expert), \"Missing signatures\");\r\n\r\n        isClosed = 1;\r\n        state = _state;\r\n\r\n        finalize(_state);\r\n        isOpen = false;\r\n\r\n        emit ClosedAgreement(_expert, _ambassador);\r\n\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador or expert to start initalize a disputed settlement\r\n     * using an agreed upon state. It starts a timeout for a reply using `settlementPeriodLength`\r\n     * \r\n     * @param _state offer state agreed on by both parties\r\n     * @param _sigV the recovery id from signature of state by both parties\r\n     * @param _sigR output of ECDSA signature  of state by both parties\r\n     * @param _sigS output of ECDSA signature of state by both parties\r\n     */\r\n    function startSettle(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\r\n        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\r\n        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n\r\n        require(_hasAllSigs(_ambassador, _expert), \"Missing signatures\");\r\n\r\n        require(isClosed == 0, \"Offer is closed\");\r\n        require(isInSettlementState == 0, \"Offer is in settlement state\");\r\n\r\n        state = _state;\r\n\r\n        sequence = getSequence(_state);\r\n\r\n        isInSettlementState = 1;\r\n        settlementPeriodEnd = block.number.add(settlementPeriodLength);\r\n\r\n        emit StartedSettle(msg.sender, sequence, settlementPeriodEnd);\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador or expert to challenge a disputed state\r\n     * The new state is accepted if it is signed by both parties and has a higher sequence number\r\n     * \r\n     * @param _state offer state agreed on by both parties\r\n     * @param _sigV the recovery id from signature of state by both parties\r\n     * @param _sigR output of ECDSA signature  of state by both parties\r\n     * @param _sigS output of ECDSA signature of state by both parties\r\n     */\r\n    function challengeSettle(bytes _state, uint8[2] _sigV, bytes32[2] _sigR, bytes32[2] _sigS) public onlyParticipants whenNotPaused {\r\n        address _ambassador = getSig(_state, _sigV[0], _sigR[0], _sigS[0]);\r\n        address _expert = getSig(_state, _sigV[1], _sigR[1], _sigS[1]);\r\n        require(getTokenAddress(_state) == nectarAddress, \"Invalid token address\");\r\n        require(_hasAllSigs(_ambassador, _expert), \"Missing signatures\");\r\n\r\n        require(isInSettlementState == 1, \"Offer is not in settlement state\");\r\n        require(block.number < settlementPeriodEnd, \"Settlement period has ended\");\r\n\r\n        require(getSequence(_state) > sequence, \"Sequence number is too old\");\r\n\r\n        settlementPeriodEnd = block.number.add(settlementPeriodLength);\r\n        state = _state;\r\n        sequence = getSequence(_state);\r\n\r\n        emit SettleStateChallenged(msg.sender, sequence, settlementPeriodEnd);\r\n    }\r\n\r\n    /**\r\n     * Return when the settlement period is going to end. This is the amount of time\r\n     * an ambassor or expert has to reply with a new state\r\n     */\r\n    function getSettlementPeriodEnd() public view returns (uint) {\r\n        return settlementPeriodEnd;\r\n    }\r\n\r\n    /**\r\n    * Function to be called by ambassador to set comunication information\r\n    *\r\n    * @param _websocketUri uri of whisper node\r\n    */\r\n    function setCommunicationUri(bytes32 _websocketUri) external whenNotPaused {\r\n        require(msg.sender == ambassador, \"msg.sender is not the ambassador\");\r\n\r\n        websocketUri = _websocketUri;\r\n\r\n        emit CommunicationsSet(websocketUri);\r\n    }\r\n\r\n    /**\r\n     * Function called to get the state sequence/nonce\r\n     *\r\n     * @param _state offer state\r\n     */\r\n    function getSequence(bytes _state) public pure returns (uint _seq) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _seq := mload(add(_state, 64))\r\n        }\r\n    }\r\n\r\n    function isChannelOpen() public view returns (bool) {\r\n        return isOpen;\r\n    }\r\n\r\n    function getWebsocketUri() public view returns (bytes32) {\r\n        return websocketUri;\r\n    }\r\n\r\n    /**\r\n     * A utility function to check if both parties have signed\r\n     *\r\n     * @param _a ambassador address\r\n     * @param _b expert address\r\n     */\r\n\r\n    function _hasAllSigs(address _a, address _b) internal view returns (bool) {\r\n        require(_a == ambassador && _b == expert, \"Signatures do not match parties in state\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * A utility function to check for the closed flag in the offer state\r\n     *\r\n     * @param _state current offer state\r\n     */\r\n    function _isClosed(bytes _state) internal pure returns (bool) {\r\n        require(getCloseFlag(_state) == 1, \"Offer is not closed\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function getCloseFlag(bytes _state) public pure returns (uint8 _flag) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _flag := mload(add(_state, 32))\r\n        }\r\n    }\r\n\r\n    function getPartyA(bytes _state) public pure returns (address _ambassador) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _ambassador := mload(add(_state, 96))\r\n        }\r\n    }\r\n\r\n    function getPartyB(bytes _state) public pure returns (address _expert) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _expert := mload(add(_state, 128))\r\n        }\r\n    }\r\n\r\n    function getBalanceA(bytes _state) public pure returns (uint256 _balanceA) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _balanceA := mload(add(_state, 192))\r\n        }\r\n    }\r\n\r\n    function getBalanceB(bytes _state) public pure returns (uint256 _balanceB) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _balanceB := mload(add(_state, 224))\r\n        }\r\n    }\r\n\r\n    function getTokenAddress(bytes _state) public pure returns (address _token) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            _token := mload(add(_state, 256))\r\n        }\r\n    }\r\n\r\n    function getTotal(bytes _state) public pure returns (uint256) {\r\n        uint256 _a = getBalanceA(_state);\r\n        uint256 _b = getBalanceB(_state);\r\n\r\n        return _a.add(_b);\r\n    }\r\n\r\n    function open(bytes _state) internal returns (bool) {\r\n        require(msg.sender == getPartyA(_state), \"Party A does not match signature recovery\");\r\n\r\n        // get the token instance used to allow funds to msig\r\n        NectarToken _t = NectarToken(getTokenAddress(_state));\r\n\r\n        // ensure the amount sent to open channel matches the signed state balance\r\n        require(_t.allowance(getPartyA(_state), this) == getBalanceA(_state), \"value does not match ambassador state balance\");\r\n\r\n        // complete the tranfer of ambassador approved tokens\r\n        require(_t.transferFrom(getPartyA(_state), this, getBalanceA(_state)), \"failed tranfering approved balance from ambassador\");\r\n        return true;\r\n    }\r\n\r\n    function join(bytes _state) internal view returns (bool) {\r\n        // get the token instance used to allow funds to msig\r\n        NectarToken _t = NectarToken(getTokenAddress(_state));\r\n\r\n        // ensure the amount sent to join channel matches the signed state balance\r\n        require(msg.sender == getPartyB(_state), \"Party B does not match signature recovery\");\r\n\r\n        // Require bonded is the sum of balances in state\r\n        require(getTotal(_state) == _t.balanceOf(this), \"token total deposited does not match state balance\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function update(bytes _state) internal returns (bool) {\r\n        // get the token instance used to allow funds to msig\r\n        NectarToken _t = NectarToken(getTokenAddress(_state));\r\n\r\n        if(_t.allowance(getPartyA(_state), this) > 0) {\r\n            require(_t.transferFrom(getPartyA(_state), this, _t.allowance(getPartyA(_state), this)), \"failed transfering deposit from party A to contract\");\r\n        }\r\n\r\n        require(getTotal(_state) == _t.balanceOf(this), \"token total deposited does not match state balance\");\r\n    }\r\n\r\n    function cancel(address tokenAddress) internal returns (bool) {\r\n        NectarToken _t = NectarToken(tokenAddress);\r\n\r\n        return _t.transfer(msg.sender, _t.balanceOf(this));\r\n    }\r\n\r\n    /**\r\n     * Function called by closeAgreementWithTimeout or closeAgreement to disperse payouts\r\n     *\r\n     * @param _state final offer state agreed on by both parties with close flag\r\n     */\r\n\r\n    function finalize(bytes _state) internal returns (bool) {\r\n        address _a = getPartyA(_state);\r\n        address _b = getPartyB(_state);\r\n\r\n        NectarToken _t = NectarToken(getTokenAddress(_state));\r\n        require(getTotal(_state) == _t.balanceOf(this), \"tried finalizing token state that does not match bonded value\");\r\n\r\n        require(_t.transfer(_a, getBalanceA(_state)), \"failed transfering balance to party A\");\r\n        require(_t.transfer(_b, getBalanceB(_state)), \"failed transfering balance to party B\");\r\n    }\r\n\r\n\r\n    /**\r\n     * A utility function to return the address of the person that signed the state\r\n     *\r\n     * @param _state offer state that was signed\r\n     * @param _v the recovery id from signature of state by both parties\r\n     * @param _r output of ECDSA signature  of state by both parties\r\n     * @param _s output of ECDSA signature of state by both parties\r\n     */\r\n    function getSig(bytes _state, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 h = keccak256(_state);\r\n\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, h));\r\n\r\n        address a = ecrecover(prefixedHash, _v, _r, _s);\r\n\r\n        return a;\r\n    }\r\n}\r\n\r\n// File: contracts/OfferRegistry.sol\r\n\r\n/// @title Creates new Offer Channel contracts and keeps track of them\r\ncontract OfferRegistry is Pausable {\r\n\r\n    struct OfferChannel {\r\n        address msig;\r\n        address ambassador;\r\n        address expert;\r\n    }\r\n\r\n    event InitializedChannel(\r\n        address msig,\r\n        address ambassador,\r\n        address expert,\r\n        uint128 guid\r\n    );\r\n\r\n    uint128[] public channelsGuids;\r\n    mapping (bytes32 => address) public participantsToChannel;\r\n    mapping (uint128 => OfferChannel) public guidToChannel;\r\n\r\n    address public nectarAddress;\r\n\r\n    constructor(address _nectarAddress) public {\r\n        require(_nectarAddress != address(0), \"Invalid token address\");\r\n\r\n        nectarAddress = _nectarAddress;\r\n    }\r\n\r\n    /**\r\n     * Function called by ambassador to initialize an offer contract\r\n     * It deploys a new offer multi sig and saves it for each participant\r\n     *\r\n     * @param _ambassador address of ambassador\r\n     * @param _expert address of expert\r\n     * @param _settlementPeriodLength how long the parties have to dispute the settlement offer channel\r\n     */\r\n    function initializeOfferChannel(uint128 guid, address _ambassador, address _expert, uint _settlementPeriodLength) external whenNotPaused {\r\n        require(address(0) != _expert, \"Invalid expert address\");\r\n        require(address(0) != _ambassador, \"Invalid ambassador address\");\r\n        require(msg.sender == _ambassador, \"Initializer isn't ambassador\");\r\n        require(guidToChannel[guid].msig == address(0), \"GUID already in use\");\r\n\r\n        bytes32 key = getParticipantsHash(_ambassador, _expert);\r\n\r\n        if (participantsToChannel[key] != address(0)) {\r\n            /// @dev check to make sure the participants don't already have an open channel\r\n            // solium-disable-next-line indentation\r\n            require(OfferMultiSig(participantsToChannel[key]).isChannelOpen() == false,\r\n                \"Channel already exists between parties\");\r\n        }\r\n\r\n        address msig = new OfferMultiSig(nectarAddress, _ambassador, _expert, _settlementPeriodLength);\r\n\r\n        participantsToChannel[key] = msig;\r\n\r\n        guidToChannel[guid].msig = msig;\r\n        guidToChannel[guid].ambassador = _ambassador;\r\n        guidToChannel[guid].expert = _expert;\r\n\r\n        channelsGuids.push(guid);\r\n\r\n        emit InitializedChannel(msig, _ambassador, _expert, guid);\r\n    }\r\n\r\n    /**\r\n     * Get the total number of offer channels tracked by the contract\r\n     *\r\n     * @return total number of offer channels\r\n     */\r\n    function getNumberOfOffers() external view returns (uint) {\r\n        return channelsGuids.length;\r\n    }\r\n\r\n    /**\r\n     * Function to get channel participants are on\r\n     *\r\n     * @param _ambassador the address of ambassador\r\n     * @param _expert the address of ambassador\r\n     */\r\n    function getParticipantsChannel(address _ambassador, address _expert) external view returns (address) {\r\n        bytes32 key = getParticipantsHash(_ambassador, _expert);\r\n\r\n        require(participantsToChannel[key] != address(0), \"Channel does not exist between parties\");\r\n\r\n        return participantsToChannel[key];\r\n    }\r\n\r\n    /**\r\n     * Gets all the created channelsGuids\r\n     *\r\n     * @return list of every channel registered\r\n     */\r\n    function getChannelsGuids() external view returns (address[]) {\r\n        require(channelsGuids.length != 0, \"No channels initialized\");\r\n\r\n        address[] memory registeredChannelsGuids = new address[](channelsGuids.length);\r\n\r\n        for (uint i = 0; i < channelsGuids.length; i++) {\r\n            registeredChannelsGuids[i] = channelsGuids[i];\r\n        }\r\n\r\n        return registeredChannelsGuids;\r\n    }\r\n\r\n    /**\r\n     * Pause all channels\r\n     *\r\n     * @return list of every channel registered\r\n     */\r\n    function pauseChannels() external onlyOwner whenNotPaused {\r\n        require(channelsGuids.length != 0, \"No channels initialized\");\r\n\r\n        pause();\r\n\r\n        for (uint i = 0; i < channelsGuids.length; i++) {\r\n            OfferMultiSig(guidToChannel[channelsGuids[i]].msig).pause();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Unpause all channels\r\n     *\r\n     * @return list of every channel registered\r\n     */\r\n\r\n    function unpauseChannels() external onlyOwner whenPaused {\r\n        require(channelsGuids.length != 0, \"No channels initialized\");\r\n\r\n        for (uint i = 0; i < channelsGuids.length; i++) {\r\n            OfferMultiSig(guidToChannel[channelsGuids[i]].msig).unpause();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Return offer information from state\r\n     *\r\n     * @return list of every channel registered\r\n     * @param _state offer state agreed on by both parties\r\n     */\r\n\r\n    function getOfferState(\r\n        bytes _state\r\n    )\r\n    public\r\n    pure\r\n        returns (\r\n            bytes32 _guid,\r\n            uint256 _nonce,\r\n            uint256 _amount,\r\n            address _msigAddress,\r\n            uint256 _balanceA,\r\n            uint256 _balanceB,\r\n            address _ambassador,\r\n            address _expert,\r\n            uint256 _isClosed,\r\n            address _token,\r\n            uint256 _mask,\r\n            uint256 _assertion\r\n        )\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n             _guid := mload(add(_state, 288)) // [256-287] - a globally-unique identifier for the listing\r\n             _nonce:= mload(add(_state, 64)) // [32-63] - the sequence of state\r\n             _amount := mload(add(_state, 320)) // [288-319] - the offer amount awarded to expert for responses\r\n             _msigAddress := mload(add(_state, 160)) // [128-159] - msig address where funds and offer are managed\r\n             _balanceA := mload(add(_state,192)) // [160-191] balance in nectar for ambassador\r\n             _balanceB := mload(add(_state,224)) // [192-223] balance in nectar for expert\r\n             _ambassador := mload(add(_state, 96)) // [64-95] - offer's ambassador address\r\n             _expert := mload(add(_state, 128)) // [96-127] - offer's expert address\r\n             _isClosed := mload(add(_state, 32)) // [0-31] - 0 or 1 for if the state is marked as closed\r\n             _token := mload(add(_state, 256)) // [224-255] - nectar token address\r\n             _mask := mload(add(_state, 480)) // [448-479] - assertion mask\r\n             _assertion := mload(add(_state, 512)) // [480-511] - assertions from expert\r\n        }\r\n    }\r\n\r\n    // Internals\r\n\r\n    /**\r\n     * Utility function to get hash\r\n     *\r\n     * @param _ambassador address of ambassador\r\n     * @param _expert address of expert\r\n     * @return hash of ambassador and expert\r\n     */\r\n\r\n    function getParticipantsHash(address _ambassador, address _expert) internal pure returns (bytes32) {\r\n        string memory str_ambassador = toString(_ambassador);\r\n        string memory str_expert = toString(_expert);\r\n\r\n        return keccak256(abi.encodePacked(strConcat(str_ambassador, str_expert)));\r\n    }\r\n\r\n    function toString(address x) internal pure returns (string) {\r\n        bytes memory b = new bytes(20);\r\n        for (uint i = 0; i < 20; i++) {\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n        }\r\n        return string(b);\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory abcde = new string(_ba.length + _bb.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n\r\n        for (uint i = 0; i < _ba.length; i++) {\r\n            babcde[k++] = _ba[i];\r\n        }\r\n\r\n        for (i = 0; i < _bb.length; i++) {\r\n            babcde[k++] = _bb[i];\r\n        }\r\n\r\n        return string(babcde);\r\n    }\r\n\r\n\r\n    /** Disable usage of the fallback function */\r\n    function() public payable {\r\n        revert(\"Do not allow sending Eth to this contract\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"nectarAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guid\",\"type\":\"uint128\"},{\"name\":\"_ambassador\",\"type\":\"address\"},{\"name\":\"_expert\",\"type\":\"address\"},{\"name\":\"_settlementPeriodLength\",\"type\":\"uint256\"}],\"name\":\"initializeOfferChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"guidToChannel\",\"outputs\":[{\"name\":\"msig\",\"type\":\"address\"},{\"name\":\"ambassador\",\"type\":\"address\"},{\"name\":\"expert\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_state\",\"type\":\"bytes\"}],\"name\":\"getOfferState\",\"outputs\":[{\"name\":\"_guid\",\"type\":\"bytes32\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_msigAddress\",\"type\":\"address\"},{\"name\":\"_balanceA\",\"type\":\"uint256\"},{\"name\":\"_balanceB\",\"type\":\"uint256\"},{\"name\":\"_ambassador\",\"type\":\"address\"},{\"name\":\"_expert\",\"type\":\"address\"},{\"name\":\"_isClosed\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_mask\",\"type\":\"uint256\"},{\"name\":\"_assertion\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChannelsGuids\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseChannels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ambassador\",\"type\":\"address\"},{\"name\":\"_expert\",\"type\":\"address\"}],\"name\":\"getParticipantsChannel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseChannels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"participantsToChannel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"channelsGuids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfOffers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nectarAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msig\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ambassador\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"expert\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"guid\",\"type\":\"uint128\"}],\"name\":\"InitializedChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OfferRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009e46a38f5daabe8683e10793b06749eef7d733d1","Library":"","SwarmSource":"bzzr://2f988933ffad805dd2371e8976ab0e0593152def61367e378aa57611f7fdfb12"}]}