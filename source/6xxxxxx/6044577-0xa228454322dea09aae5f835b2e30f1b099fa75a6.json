{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n */\r\ncontract ERC721 {\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed tokenId\r\n  );\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed approved,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  function implementsERC721() public pure returns (bool);\r\n  function totalSupply() public view returns (uint256 total);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n  function approve(address _to, uint256 _tokenId) external;\r\n  function transfer(address _to, uint256 _tokenId) external;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n *      functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   *      account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the owner to pause, triggers stopped state.\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the owner to unpause, returns to normal state.\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title CurioAuction\r\n * @dev CurioAuction contract implements clock auction for tokens sale.\r\n */\r\ncontract CurioAuction is Pausable {\r\n  event AuctionCreated(\r\n    uint256 indexed tokenId,\r\n    uint256 startingPrice,\r\n    uint256 endingPrice,\r\n    uint256 duration\r\n  );\r\n  event AuctionSuccessful(\r\n    uint256 indexed tokenId,\r\n    uint256 totalPrice,\r\n    address indexed winner\r\n  );\r\n  event AuctionCancelled(uint256 indexed tokenId);\r\n\r\n  // Represents an auction on a token\r\n  struct Auction {\r\n    // Current owner of token\r\n    address seller;\r\n    // Price (in wei) at beginning of auction\r\n    uint128 startingPrice;\r\n    // Price (in wei) at end of auction\r\n    uint128 endingPrice;\r\n    // Duration (in seconds) of auction\r\n    uint64 duration;\r\n    // Time when auction started (0 if this auction has been concluded)\r\n    uint64 startedAt;\r\n  }\r\n\r\n  // Check that this contract is correct for Curio main contract\r\n  bool public isCurioAuction = true;\r\n\r\n  // Reference to token contract\r\n  ERC721 public tokenContract;\r\n\r\n  // Value of fee (1/100 of a percent; 0-10,000 map to 0%-100%)\r\n  uint256 public feePercent;\r\n\r\n  // Map from token ID to auction\r\n  mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n  // Count of release tokens sold by auction\r\n  uint256 public releaseTokensSaleCount;\r\n\r\n  // Limit of start and end prices in wei\r\n  uint256 public auctionPriceLimit;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   * @param _tokenAddress Address of ERC721 token contract (Curio core contract)\r\n   * @param _fee Percent of fee (0-10,000)\r\n   * @param _auctionPriceLimit Limit of start and end price in auction (in wei)\r\n   */\r\n  constructor(\r\n    address _tokenAddress,\r\n    uint256 _fee,\r\n    uint256 _auctionPriceLimit\r\n  )\r\n    public\r\n  {\r\n    require(_fee <= 10000);\r\n    feePercent = _fee;\r\n\r\n    ERC721 candidateContract = ERC721(_tokenAddress);\r\n    require(candidateContract.implementsERC721());\r\n\r\n    tokenContract = candidateContract;\r\n\r\n    require(_auctionPriceLimit == uint256(uint128(_auctionPriceLimit)));\r\n    auctionPriceLimit = _auctionPriceLimit;\r\n  }\r\n\r\n\r\n  // -----------------------------------------\r\n  // External interface\r\n  // -----------------------------------------\r\n\r\n\r\n  /**\r\n   * @dev Creates a new auction.\r\n   * @param _tokenId ID of token to auction, sender must be owner\r\n   * @param _startingPrice Price of item (in wei) at beginning of auction\r\n   * @param _endingPrice Price of item (in wei) at end of auction\r\n   * @param _duration Length of auction (in seconds)\r\n   * @param _seller Seller address\r\n   */\r\n  function createAuction(\r\n    uint256 _tokenId,\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration,\r\n    address _seller\r\n  )\r\n    whenNotPaused\r\n    external\r\n  {\r\n    // Overflow and limitation input check\r\n    require(_startingPrice == uint256(uint128(_startingPrice)));\r\n    require(_startingPrice < auctionPriceLimit);\r\n\r\n    require(_endingPrice == uint256(uint128(_endingPrice)));\r\n    require(_endingPrice < auctionPriceLimit);\r\n\r\n    require(_duration == uint256(uint64(_duration)));\r\n\r\n    // Check call from token contract\r\n    require(msg.sender == address(tokenContract));\r\n\r\n    // Transfer token from seller to this contract\r\n    _deposit(_seller, _tokenId);\r\n\r\n    // Create an auction\r\n    Auction memory auction = Auction(\r\n      _seller,\r\n      uint128(_startingPrice),\r\n      uint128(_endingPrice),\r\n      uint64(_duration),\r\n      uint64(now)\r\n    );\r\n    _addAuction(_tokenId, auction);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns auction info for a token on auction.\r\n   * @param _tokenId ID of token on auction\r\n   */\r\n  function getAuction(uint256 _tokenId) external view\r\n  returns\r\n  (\r\n    address seller,\r\n    uint256 startingPrice,\r\n    uint256 endingPrice,\r\n    uint256 duration,\r\n    uint256 startedAt\r\n  ) {\r\n    // Check token on auction\r\n    Auction storage auction = tokenIdToAuction[_tokenId];\r\n    require(_isOnAuction(auction));\r\n\r\n    return (\r\n      auction.seller,\r\n      auction.startingPrice,\r\n      auction.endingPrice,\r\n      auction.duration,\r\n      auction.startedAt\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current price of an auction.\r\n   * @param _tokenId ID of the token price we are checking\r\n   */\r\n  function getCurrentPrice(uint256 _tokenId) external view returns (uint256) {\r\n    // Check token on auction\r\n    Auction storage auction = tokenIdToAuction[_tokenId];\r\n    require(_isOnAuction(auction));\r\n\r\n    return _currentPrice(auction);\r\n  }\r\n\r\n  /**\r\n   * @dev Bids on an open auction, completing the auction and transferring\r\n   *      ownership of the token if enough Ether is supplied.\r\n   * @param _tokenId ID of token to bid on\r\n   */\r\n  function bid(uint256 _tokenId) external payable whenNotPaused {\r\n    address seller = tokenIdToAuction[_tokenId].seller;\r\n\r\n    // Check auction conditions and transfer Ether to seller\r\n    // _bid verifies token ID size\r\n    _bid(_tokenId, msg.value);\r\n\r\n    // Transfer token from this contract to msg.sender after successful bid\r\n    _transfer(msg.sender, _tokenId);\r\n\r\n    // If seller is tokenContract then increase counter of release tokens\r\n    if (seller == address(tokenContract)) {\r\n      releaseTokensSaleCount++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels an auction. Returns the token to original owner.\r\n   *      This is a state-modifying function that can\r\n   *      be called while the contract is paused.\r\n   * @param _tokenId ID of token on auction\r\n   */\r\n  function cancelAuction(uint256 _tokenId) external {\r\n    // Check token on auction\r\n    Auction storage auction = tokenIdToAuction[_tokenId];\r\n    require(_isOnAuction(auction));\r\n\r\n    // Check sender as seller\r\n    address seller = auction.seller;\r\n    require(msg.sender == seller);\r\n\r\n    _cancelAuction(_tokenId, seller);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels an auction when the contract is paused. Only owner.\r\n   *      Returns the token to seller. This should only be used in emergencies.\r\n   * @param _tokenId ID of the NFT on auction to cancel\r\n   */\r\n  function cancelAuctionWhenPaused(uint256 _tokenId) whenPaused onlyOwner external {\r\n    // Check token on auction\r\n    Auction storage auction = tokenIdToAuction[_tokenId];\r\n    require(_isOnAuction(auction));\r\n\r\n    _cancelAuction(_tokenId, auction.seller);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw all Ether (fee) from auction contract to token contract.\r\n   *      Only auction contract owner.\r\n   */\r\n  function withdrawBalance() external {\r\n    address tokenAddress = address(tokenContract);\r\n\r\n    // Check sender as owner or token contract\r\n    require(msg.sender == owner || msg.sender == tokenAddress);\r\n\r\n    // Send Ether on this contract to token contract\r\n    // Boolean method make sure that even if one fails it will still work\r\n    bool res = tokenAddress.send(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new auction price limit.\r\n   * @param _newAuctionPriceLimit Start and end price limit\r\n   */\r\n  function setAuctionPriceLimit(uint256 _newAuctionPriceLimit) external {\r\n    address tokenAddress = address(tokenContract);\r\n\r\n    // Check sender as owner or token contract\r\n    require(msg.sender == owner || msg.sender == tokenAddress);\r\n\r\n    // Check overflow\r\n    require(_newAuctionPriceLimit == uint256(uint128(_newAuctionPriceLimit)));\r\n\r\n    // Set new auction price limit\r\n    auctionPriceLimit = _newAuctionPriceLimit;\r\n  }\r\n\r\n\r\n  // -----------------------------------------\r\n  // Internal interface\r\n  // -----------------------------------------\r\n\r\n\r\n  /**\r\n   * @dev Returns true if the claimant owns the token.\r\n   * @param _claimant Address claiming to own the token\r\n   * @param _tokenId ID of token whose ownership to verify\r\n   */\r\n  function _owns(\r\n    address _claimant,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (tokenContract.ownerOf(_tokenId) == _claimant);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer token from owner to this contract.\r\n   * @param _owner Current owner address of token to escrow\r\n   * @param _tokenId ID of token whose approval to verify\r\n   */\r\n  function _deposit(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    tokenContract.transferFrom(_owner, this, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers token owned by this contract to another address.\r\n   *      Returns true if the transfer succeeds.\r\n   * @param _receiver Address to transfer token to\r\n   * @param _tokenId ID of token to transfer\r\n   */\r\n  function _transfer(\r\n    address _receiver,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    tokenContract.transfer(_receiver, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds an auction to the list of open auctions.\r\n   * @param _tokenId The ID of the token to be put on auction\r\n   * @param _auction Auction to add\r\n   */\r\n  function _addAuction(\r\n    uint256 _tokenId,\r\n    Auction _auction\r\n  )\r\n    internal\r\n  {\r\n    // Require that all auctions have a duration of at least one minute.\r\n    require(_auction.duration >= 1 minutes);\r\n\r\n    tokenIdToAuction[_tokenId] = _auction;\r\n\r\n    emit AuctionCreated(\r\n      uint256(_tokenId),\r\n      uint256(_auction.startingPrice),\r\n      uint256(_auction.endingPrice),\r\n      uint256(_auction.duration)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Removes an auction from the list of open auctions.\r\n   * @param _tokenId ID of token on auction\r\n   */\r\n  function _removeAuction(uint256 _tokenId) internal {\r\n    delete tokenIdToAuction[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Remove an auction and transfer token from this contract to seller address.\r\n   * @param _tokenId The ID of the token\r\n   * @param _seller Seller address\r\n   */\r\n  function _cancelAuction(\r\n    uint256 _tokenId,\r\n    address _seller\r\n  )\r\n    internal\r\n  {\r\n    // Remove auction from list\r\n    _removeAuction(_tokenId);\r\n\r\n    // Transfer token to seller\r\n    _transfer(_seller, _tokenId);\r\n\r\n    emit AuctionCancelled(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Check token is on auction.\r\n   * @param _auction Auction to check\r\n   */\r\n  function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n    return (_auction.startedAt > 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates fee of a sale.\r\n   * @param _price Token price\r\n   */\r\n  function _calculateFee(uint256 _price) internal view returns (uint256) {\r\n    return _price * feePercent / 10000;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns current price of a token on auction.\r\n   * @param _auction Auction for calculate current price\r\n   */\r\n  function _currentPrice(Auction storage _auction) internal view returns (uint256) {\r\n    uint256 secondsPassed = 0;\r\n\r\n    // Check that auction were started\r\n    // Variable secondsPassed is positive\r\n    if (now > _auction.startedAt) {\r\n      secondsPassed = now - _auction.startedAt;\r\n    }\r\n\r\n    return _calculateCurrentPrice(\r\n      _auction.startingPrice,\r\n      _auction.endingPrice,\r\n      _auction.duration,\r\n      secondsPassed\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate the current price of an auction.\r\n   * @param _startingPrice Price of item (in wei) at beginning of auction\r\n   * @param _endingPrice Price of item (in wei) at end of auction\r\n   * @param _duration Length of auction (in seconds)\r\n   * @param _secondsPassed Seconds passed after auction start\r\n   */\r\n  function _calculateCurrentPrice(\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration,\r\n    uint256 _secondsPassed\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (_secondsPassed >= _duration) {\r\n      // The auction lasts longer duration\r\n      // Return end price\r\n      return _endingPrice;\r\n    } else {\r\n      // totalPriceChange can be negative\r\n      int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n      // This multiplication can't overflow, _secondsPassed will easily fit within\r\n      // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n      // will always fit within 256-bits.\r\n      int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n      // currentPriceChange can be negative, but if so, will have a magnitude\r\n      // less that _startingPrice. Thus, this result will always end up positive.\r\n      int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n      return uint256(currentPrice);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate auction price and transfers winnings. Does NOT transfer ownership of token.\r\n   * @param _tokenId The ID of the token\r\n   * @param _bidAmount Amount (in wei) offered for auction\r\n   */\r\n  function _bid(\r\n    uint256 _tokenId,\r\n    uint256 _bidAmount\r\n  )\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n    // Check that this auction is currently live\r\n    require(_isOnAuction(auction));\r\n\r\n    // Check that the incoming bid is higher than the current price\r\n    uint256 price = _currentPrice(auction);\r\n    require(_bidAmount >= price);\r\n\r\n    address seller = auction.seller;\r\n\r\n    _removeAuction(_tokenId);\r\n\r\n    // Transfer proceeds to seller\r\n    if (price > 0) {\r\n      uint256 fee = _calculateFee(price);\r\n\r\n      uint256 sellerProceeds = price - fee;\r\n\r\n      // Transfer proceeds to seller\r\n      seller.transfer(sellerProceeds);\r\n    }\r\n\r\n    // Calculate excess funds and transfer it back to bidder\r\n    uint256 bidExcess = _bidAmount - price;\r\n    msg.sender.transfer(bidExcess);\r\n\r\n    emit AuctionSuccessful(_tokenId, price, msg.sender);\r\n\r\n    return price;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCurioAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionPriceLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAuctionPriceLimit\",\"type\":\"uint256\"}],\"name\":\"setAuctionPriceLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseTokensSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_auctionPriceLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CurioAuction","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c22faf9f506e63e6f4f0088d15e9197b27c77ac700000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000053444835ec580000","Library":"","SwarmSource":"bzzr://95f6191f424b8743a9cdcc6afe5a39e658b6c4eb96ba26e50cf9c73be99be178"}]}