{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Tokensale.sol\r\n * Mt Pelerin Share (MPS) token sale : public phase.\r\n\r\n * More info about MPS : https://github.com/MtPelerin/MtPelerin-share-MPS\r\n\r\n * The unflattened code is available through this github tag:\r\n * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-2\r\n\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n\r\n * @notice All matters regarding the intellectual property of this code \r\n * @notice or software are subject to Swiss Law without reference to its \r\n * @notice conflicts of law rules.\r\n\r\n * @notice License for each contract is available in the respective file\r\n * @notice or in the LICENSE.md file.\r\n * @notice https://github.com/MtPelerin/\r\n\r\n * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:\r\n * @notice https://github.com/OpenZeppelin/openzeppelin-solidity\r\n */\r\n\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/interface/IUserRegistry.sol\r\n\r\n/**\r\n * @title IUserRegistry\r\n * @dev IUserRegistry interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IUserRegistry {\r\n\r\n  function registerManyUsers(address[] _addresses, uint256 _validUntilTime)\r\n    public;\r\n\r\n  function attachManyAddresses(uint256[] _userIds, address[] _addresses)\r\n    public;\r\n\r\n  function detachManyAddresses(address[] _addresses)\r\n    public;\r\n\r\n  function userCount() public view returns (uint256);\r\n  function userId(address _address) public view returns (uint256);\r\n  function addressConfirmed(address _address) public view returns (bool);\r\n  function validUntilTime(uint256 _userId) public view returns (uint256);\r\n  function suspended(uint256 _userId) public view returns (bool);\r\n  function extended(uint256 _userId, uint256 _key)\r\n    public view returns (uint256);\r\n\r\n  function isAddressValid(address _address) public view returns (bool);\r\n  function isValid(uint256 _userId) public view returns (bool);\r\n\r\n  function registerUser(address _address, uint256 _validUntilTime) public;\r\n  function attachAddress(uint256 _userId, address _address) public;\r\n  function confirmSelf() public;\r\n  function detachAddress(address _address) public;\r\n  function detachSelf() public;\r\n  function detachSelfAddress(address _address) public;\r\n  function suspendUser(uint256 _userId) public;\r\n  function unsuspendUser(uint256 _userId) public;\r\n  function suspendManyUsers(uint256[] _userIds) public;\r\n  function unsuspendManyUsers(uint256[] _userIds) public;\r\n  function updateUser(uint256 _userId, uint256 _validUntil, bool _suspended)\r\n    public;\r\n\r\n  function updateManyUsers(\r\n    uint256[] _userIds,\r\n    uint256 _validUntil,\r\n    bool _suspended) public;\r\n\r\n  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\r\n    public;\r\n\r\n  function updateManyUsersExtended(\r\n    uint256[] _userIds,\r\n    uint256 _key,\r\n    uint256 _value) public;\r\n}\r\n\r\n// File: contracts/interface/IRatesProvider.sol\r\n\r\n/**\r\n * @title IRatesProvider\r\n * @dev IRatesProvider interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract IRatesProvider {\r\n  function rateWEIPerCHFCent() public view returns (uint256);\r\n  function convertWEIToCHFCent(uint256 _amountWEI)\r\n    public view returns (uint256);\r\n\r\n  function convertCHFCentToWEI(uint256 _amountCHFCent)\r\n    public view returns (uint256);\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/interface/ITokensale.sol\r\n\r\n/**\r\n * @title ITokensale\r\n * @dev ITokensale interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract ITokensale {\r\n\r\n  function () external payable;\r\n\r\n  uint256 constant MINIMAL_AUTO_WITHDRAW = 0.5 ether;\r\n  uint256 constant MINIMAL_BALANCE = 0.5 ether;\r\n  uint256 constant MINIMAL_INVESTMENT = 50; // tokens\r\n  uint256 constant BASE_PRICE_CHF_CENT = 500;\r\n  uint256 constant KYC_LEVEL_KEY = 1;\r\n\r\n  function minimalAutoWithdraw() public view returns (uint256);\r\n  function minimalBalance() public view returns (uint256);\r\n  function basePriceCHFCent() public view returns (uint256);\r\n\r\n  /* General sale details */\r\n  function token() public view returns (ERC20);\r\n  function vaultETH() public view returns (address);\r\n  function vaultERC20() public view returns (address);\r\n  function userRegistry() public view returns (IUserRegistry);\r\n  function ratesProvider() public view returns (IRatesProvider);\r\n  function sharePurchaseAgreementHash() public view returns (bytes32);\r\n\r\n  /* Sale status */\r\n  function startAt() public view returns (uint256);\r\n  function endAt() public view returns (uint256);\r\n  function raisedETH() public view returns (uint256);\r\n  function raisedCHF() public view returns (uint256);\r\n  function totalRaisedCHF() public view returns (uint256);\r\n  function totalUnspentETH() public view returns (uint256);\r\n  function totalRefundedETH() public view returns (uint256);\r\n  function availableSupply() public view returns (uint256);\r\n\r\n  /* Investor specific attributes */\r\n  function investorUnspentETH(uint256 _investorId)\r\n    public view returns (uint256);\r\n\r\n  function investorInvestedCHF(uint256 _investorId)\r\n    public view returns (uint256);\r\n\r\n  function investorAcceptedSPA(uint256 _investorId)\r\n    public view returns (bool);\r\n\r\n  function investorAllocations(uint256 _investorId)\r\n    public view returns (uint256);\r\n\r\n  function investorTokens(uint256 _investorId) public view returns (uint256);\r\n  function investorCount() public view returns (uint256);\r\n\r\n  function investorLimit(uint256 _investorId) public view returns (uint256);\r\n\r\n  /* Share Purchase Agreement */\r\n  function defineSPA(bytes32 _sharePurchaseAgreementHash)\r\n    public returns (bool);\r\n\r\n  function acceptSPA(bytes32 _sharePurchaseAgreementHash)\r\n    public payable returns (bool);\r\n\r\n  /* Investment */\r\n  function investETH() public payable;\r\n  function addOffChainInvestment(address _investor, uint256 _amountCHF)\r\n    public;\r\n\r\n  /* Schedule */\r\n  function updateSchedule(uint256 _startAt, uint256 _endAt) public;\r\n\r\n  /* Allocations admin */\r\n  function allocateTokens(address _investor, uint256 _amount)\r\n    public returns (bool);\r\n\r\n  function allocateManyTokens(address[] _investors, uint256[] _amounts)\r\n    public returns (bool);\r\n\r\n  /* ETH administration */\r\n  function fundETH() public payable;\r\n  function refundManyUnspentETH(address[] _receivers) public;\r\n  function refundUnspentETH(address _receiver) public;\r\n  function withdrawETHFunds() public;\r\n\r\n  event SalePurchaseAgreementHash(bytes32 sharePurchaseAgreement);\r\n  event Allocation(\r\n    uint256 investorId,\r\n    uint256 tokens\r\n  );\r\n  event Investment(\r\n    uint256 investorId,\r\n    uint256 spentCHF\r\n  );\r\n  event ChangeETHCHF(\r\n    address investor,\r\n    uint256 amount,\r\n    uint256 converted,\r\n    uint256 rate\r\n  );\r\n  event FundETH(uint256 amount);\r\n  event WithdrawETH(address receiver, uint256 amount);\r\n}\r\n\r\n// File: contracts/zeppelin/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/Authority.sol\r\n\r\n/**\r\n * @title Authority\r\n * @dev The Authority contract has an authority address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * Authority means to represent a legal entity that is entitled to specific rights\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * AU01: Message sender must be an authority\r\n */\r\ncontract Authority is Ownable {\r\n\r\n  address authority;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the authority.\r\n   */\r\n  modifier onlyAuthority {\r\n    require(msg.sender == authority, \"AU01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address associated to the authority\r\n   */\r\n  function authorityAddress() public view returns (address) {\r\n    return authority;\r\n  }\r\n\r\n  /** Define an address as authority, with an arbitrary name included in the event\r\n   * @dev returns the authority of the\r\n   * @param _name the authority name\r\n   * @param _address the authority address.\r\n   */\r\n  function defineAuthority(string _name, address _address) public onlyOwner {\r\n    emit AuthorityDefined(_name, _address);\r\n    authority = _address;\r\n  }\r\n\r\n  event AuthorityDefined(\r\n    string name,\r\n    address _address\r\n  );\r\n}\r\n\r\n// File: contracts/tokensale/Tokensale.sol\r\n\r\n/**\r\n * @title Tokensale\r\n * @dev Tokensale contract\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * TOS01: It must be before the sale is opened\r\n * TOS02: Sale must be open\r\n * TOS03: It must be before the sale is closed\r\n * TOS04: It must be after the sale is closed\r\n * TOS05: No data must be sent while sending ETH\r\n * TOS06: Share Purchase Agreement Hashes must match\r\n * TOS07: User/Investor must exist\r\n * TOS08: SPA must be accepted before any ETH investment\r\n * TOS09: Cannot update schedule once started\r\n * TOS10: Investor must exist\r\n * TOS11: Cannot allocate more tokens than available supply\r\n * TOS12: Length of InvestorIds and amounts arguments must match\r\n * TOS13: Investor must exist\r\n * TOS14: Must refund ETH unspent\r\n * TOS15: Must withdraw ETH to vaultETH\r\n * TOS16: Cannot invest onchain and offchain at the same time\r\n * TOS17: A ETHCHF rate must exist to invest\r\n * TOS18: User must be valid\r\n * TOS19: Cannot invest if no tokens are available\r\n * TOS20: Investment is below the minimal investment\r\n * TOS21: Cannot unspend more CHF than BASE_TOKEN_PRICE_CHF\r\n * TOS22: Token transfer must be successful\r\n */\r\ncontract Tokensale is ITokensale, Authority, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  uint32[5] contributionLimits = [\r\n    5000,\r\n    500000,\r\n    1500000,\r\n    10000000,\r\n    25000000\r\n  ];\r\n\r\n  /* General sale details */\r\n  ERC20 public token;\r\n  address public vaultETH;\r\n  address public vaultERC20;\r\n  IUserRegistry public userRegistry;\r\n  IRatesProvider public ratesProvider;\r\n\r\n  uint256 public minimalBalance = MINIMAL_BALANCE;\r\n  bytes32 public sharePurchaseAgreementHash;\r\n\r\n  uint256 public startAt = 4102441200;\r\n  uint256 public endAt = 4102441200;\r\n  uint256 public raisedETH;\r\n  uint256 public raisedCHF;\r\n  uint256 public totalRaisedCHF;\r\n  uint256 public totalUnspentETH;\r\n  uint256 public totalRefundedETH;\r\n  uint256 public allocatedTokens;\r\n\r\n  struct Investor {\r\n    uint256 unspentETH;\r\n    uint256 investedCHF;\r\n    bool acceptedSPA;\r\n    uint256 allocations;\r\n    uint256 tokens;\r\n  }\r\n  mapping(uint256 => Investor) investors;\r\n  mapping(uint256 => uint256) investorLimits;\r\n  uint256 public investorCount;\r\n\r\n  /**\r\n   * @dev Throws unless before sale opening\r\n   */\r\n  modifier beforeSaleIsOpened {\r\n    require(currentTime() < startAt, \"TOS01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if sale is not open\r\n   */\r\n  modifier saleIsOpened {\r\n    require(currentTime() >= startAt && currentTime() <= endAt, \"TOS02\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws once the sale is closed\r\n   */\r\n  modifier beforeSaleIsClosed {\r\n    require(currentTime() <= endAt, \"TOS03\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(\r\n    ERC20 _token,\r\n    IUserRegistry _userRegistry,\r\n    IRatesProvider _ratesProvider,\r\n    address _vaultERC20,\r\n    address _vaultETH\r\n  ) public\r\n  {\r\n    token = _token;\r\n    userRegistry = _userRegistry;\r\n    ratesProvider = _ratesProvider;\r\n    vaultERC20 = _vaultERC20;\r\n    vaultETH = _vaultETH;\r\n  }\r\n\r\n  /**\r\n   * @dev fallback function\r\n   */\r\n  function () external payable {\r\n    require(msg.data.length == 0, \"TOS05\");\r\n    investETH();\r\n  }\r\n\r\n  /**\r\n   * @dev returns the token sold\r\n   */\r\n  function token() public view returns (ERC20) {\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the vault use to\r\n   */\r\n  function vaultETH() public view returns (address) {\r\n    return vaultETH;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the vault to receive ETH\r\n   */\r\n  function vaultERC20() public view returns (address) {\r\n    return vaultERC20;\r\n  }\r\n\r\n  function userRegistry() public view returns (IUserRegistry) {\r\n    return userRegistry;\r\n  }\r\n\r\n  function ratesProvider() public view returns (IRatesProvider) {\r\n    return ratesProvider;\r\n  }\r\n\r\n  function sharePurchaseAgreementHash() public view returns (bytes32) {\r\n    return sharePurchaseAgreementHash;\r\n  }\r\n\r\n  /* Sale status */\r\n  function startAt() public view returns (uint256) {\r\n    return startAt;\r\n  }\r\n\r\n  function endAt() public view returns (uint256) {\r\n    return endAt;\r\n  }\r\n\r\n  function raisedETH() public view returns (uint256) {\r\n    return raisedETH;\r\n  }\r\n\r\n  function raisedCHF() public view returns (uint256) {\r\n    return raisedCHF;\r\n  }\r\n\r\n  function totalRaisedCHF() public view returns (uint256) {\r\n    return totalRaisedCHF;\r\n  }\r\n\r\n  function totalUnspentETH() public view returns (uint256) {\r\n    return totalUnspentETH;\r\n  }\r\n\r\n  function totalRefundedETH() public view returns (uint256) {\r\n    return totalRefundedETH;\r\n  }\r\n\r\n  function availableSupply() public view returns (uint256) {\r\n    uint256 vaultSupply = token.balanceOf(vaultERC20);\r\n    uint256 allowance = token.allowance(vaultERC20, address(this));\r\n    return (vaultSupply < allowance) ? vaultSupply : allowance;\r\n  }\r\n \r\n  /* Investor specific attributes */\r\n  function investorUnspentETH(uint256 _investorId)\r\n    public view returns (uint256)\r\n  {\r\n    return investors[_investorId].unspentETH;\r\n  }\r\n\r\n  function investorInvestedCHF(uint256 _investorId)\r\n    public view returns (uint256)\r\n  {\r\n    return investors[_investorId].investedCHF;\r\n  }\r\n\r\n  function investorAcceptedSPA(uint256 _investorId)\r\n    public view returns (bool)\r\n  {\r\n    return investors[_investorId].acceptedSPA;\r\n  }\r\n\r\n  function investorAllocations(uint256 _investorId)\r\n    public view returns (uint256)\r\n  {\r\n    return investors[_investorId].allocations;\r\n  }\r\n\r\n  function investorTokens(uint256 _investorId) public view returns (uint256) {\r\n    return investors[_investorId].tokens;\r\n  }\r\n\r\n  function investorCount() public view returns (uint256) {\r\n    return investorCount;\r\n  }\r\n\r\n  function investorLimit(uint256 _investorId) public view returns (uint256) {\r\n    return investorLimits[_investorId];\r\n  }\r\n\r\n  /**\r\n   * @dev get minimak auto withdraw threshold\r\n   */\r\n  function minimalAutoWithdraw() public view returns (uint256) {\r\n    return MINIMAL_AUTO_WITHDRAW;\r\n  }\r\n\r\n  /**\r\n   * @dev get minimal balance to maintain in contract\r\n   */\r\n  function minimalBalance() public view returns (uint256) {\r\n    return minimalBalance;\r\n  }\r\n\r\n  /**\r\n   * @dev get base price in CHF cents\r\n   */\r\n  function basePriceCHFCent() public view returns (uint256) {\r\n    return BASE_PRICE_CHF_CENT;\r\n  }\r\n\r\n  /**\r\n   * @dev contribution limit based on kyc level\r\n   */\r\n  function contributionLimit(uint256 _investorId)\r\n    public view returns (uint256)\r\n  {\r\n    uint256 kycLevel = userRegistry.extended(_investorId, KYC_LEVEL_KEY);\r\n    uint256 limit = 0;\r\n    if (kycLevel < 5) {\r\n      limit = contributionLimits[kycLevel];\r\n    } else {\r\n      limit = (investorLimits[_investorId] > 0\r\n        ) ? investorLimits[_investorId] : contributionLimits[4];\r\n    }\r\n    return limit.sub(investors[_investorId].investedCHF);\r\n  }\r\n\r\n  /**\r\n   * @dev update minimal balance to be kept in contract\r\n   */\r\n  function updateMinimalBalance(uint256 _minimalBalance)\r\n    public returns (uint256)\r\n  {\r\n    minimalBalance = _minimalBalance;\r\n  }\r\n\r\n  /**\r\n   * @dev define investor limit\r\n   */\r\n  function updateInvestorLimits(uint256[] _investorIds, uint256 _limit)\r\n    public returns (uint256)\r\n  {\r\n    for (uint256 i = 0; i < _investorIds.length; i++) {\r\n      investorLimits[_investorIds[i]] = _limit;\r\n    }\r\n  }\r\n\r\n  /* Share Purchase Agreement */\r\n  /**\r\n   * @dev define SPA\r\n   */\r\n  function defineSPA(bytes32 _sharePurchaseAgreementHash)\r\n    public onlyOwner returns (bool)\r\n  {\r\n    sharePurchaseAgreementHash = _sharePurchaseAgreementHash;\r\n    emit SalePurchaseAgreementHash(_sharePurchaseAgreementHash);\r\n  }\r\n\r\n  /**\r\n   * @dev Accept SPA and invest if msg.value > 0\r\n   */\r\n  function acceptSPA(bytes32 _sharePurchaseAgreementHash)\r\n    public beforeSaleIsClosed payable returns (bool)\r\n  {\r\n    require(\r\n      _sharePurchaseAgreementHash == sharePurchaseAgreementHash, \"TOS06\");\r\n    uint256 investorId = userRegistry.userId(msg.sender);\r\n    require(investorId > 0, \"TOS07\");\r\n    investors[investorId].acceptedSPA = true;\r\n    investorCount++;\r\n\r\n    if (msg.value > 0) {\r\n      investETH();\r\n    }\r\n  }\r\n\r\n  /* Investment */\r\n  function investETH() public\r\n    saleIsOpened whenNotPaused payable\r\n  {\r\n    //Accepting SharePurchaseAgreement is temporarily offchain\r\n    //uint256 investorId = userRegistry.userId(msg.sender);\r\n    //require(investors[investorId].acceptedSPA, \"TOS08\");\r\n    investInternal(msg.sender, msg.value, 0);\r\n    withdrawETHFundsInternal();\r\n  }\r\n\r\n  /**\r\n   * @dev add off chain investment\r\n   */\r\n  function addOffChainInvestment(address _investor, uint256 _amountCHF)\r\n    public onlyAuthority\r\n  {\r\n    investInternal(_investor, 0, _amountCHF);\r\n  }\r\n\r\n  /* Schedule */ \r\n  /**\r\n   * @dev update schedule\r\n   */\r\n  function updateSchedule(uint256 _startAt, uint256 _endAt)\r\n    public onlyAuthority beforeSaleIsOpened\r\n  {\r\n    require(_startAt < _endAt, \"TOS09\");\r\n    startAt = _startAt;\r\n    endAt = _endAt;\r\n  }\r\n\r\n  /* Allocations admin */\r\n  /**\r\n   * @dev allocate\r\n   */\r\n  function allocateTokens(address _investor, uint256 _amount)\r\n    public onlyAuthority beforeSaleIsClosed returns (bool)\r\n  {\r\n    uint256 investorId = userRegistry.userId(_investor);\r\n    require(investorId > 0, \"TOS10\");\r\n    Investor storage investor = investors[investorId];\r\n    \r\n    allocatedTokens = allocatedTokens.sub(investor.allocations).add(_amount);\r\n    require(allocatedTokens <= availableSupply(), \"TOS11\");\r\n\r\n    investor.allocations = _amount;\r\n    emit Allocation(investorId, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev allocate many\r\n   */\r\n  function allocateManyTokens(address[] _investors, uint256[] _amounts)\r\n    public onlyAuthority beforeSaleIsClosed returns (bool)\r\n  {\r\n    require(_investors.length == _amounts.length, \"TOS12\");\r\n    for (uint256 i = 0; i < _investors.length; i++) {\r\n      allocateTokens(_investors[i], _amounts[i]);\r\n    }\r\n  }\r\n\r\n  /* ETH administration */\r\n  /**\r\n   * @dev fund ETH\r\n   */\r\n  function fundETH() public payable onlyAuthority {\r\n    emit FundETH(msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev refund unspent ETH many\r\n   */\r\n  function refundManyUnspentETH(address[] _receivers) public onlyAuthority {\r\n    for (uint256 i = 0; i < _receivers.length; i++) {\r\n      refundUnspentETH(_receivers[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev refund unspent ETH\r\n   */\r\n  function refundUnspentETH(address _receiver) public onlyAuthority {\r\n    uint256 investorId = userRegistry.userId(_receiver);\r\n    require(investorId != 0, \"TOS13\");\r\n    Investor storage investor = investors[investorId];\r\n\r\n    if (investor.unspentETH > 0) {\r\n      // solium-disable-next-line security/no-send\r\n      require(_receiver.send(investor.unspentETH), \"TOS14\");\r\n      totalRefundedETH = totalRefundedETH.add(investor.unspentETH);\r\n      emit WithdrawETH(_receiver, investor.unspentETH);\r\n      totalUnspentETH = totalUnspentETH.sub(investor.unspentETH);\r\n      investor.unspentETH = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev withdraw ETH funds\r\n   */\r\n  function withdrawETHFunds() public onlyAuthority {\r\n    withdrawETHFundsInternal();\r\n  }\r\n\r\n  /**\r\n   * @dev withdraw all ETH funds\r\n   */\r\n  function withdrawAllETHFunds() public onlyAuthority {\r\n    uint256 balance = address(this).balance;\r\n    // solium-disable-next-line security/no-send\r\n    require(vaultETH.send(balance), \"TOS15\");\r\n    emit WithdrawETH(vaultETH, balance);\r\n  }\r\n\r\n  /**\r\n   * @dev allowed token investment\r\n   */\r\n  function allowedTokenInvestment(\r\n    uint256 _investorId, uint256 _contributionCHF)\r\n    public view returns (uint256)\r\n  {\r\n    uint256 tokens = 0;\r\n    uint256 allowedContributionCHF = contributionLimit(_investorId);\r\n    if (_contributionCHF < allowedContributionCHF) {\r\n      allowedContributionCHF = _contributionCHF;\r\n    }\r\n    tokens = allowedContributionCHF.div(BASE_PRICE_CHF_CENT);\r\n    uint256 availableTokens = availableSupply().sub(\r\n      allocatedTokens).add(investors[_investorId].allocations);\r\n    if (tokens > availableTokens) {\r\n      tokens = availableTokens;\r\n    }\r\n    if (tokens < MINIMAL_INVESTMENT) {\r\n      tokens = 0;\r\n    }\r\n    return tokens;\r\n  }\r\n\r\n  /**\r\n   * @dev withdraw ETH funds internal\r\n   */\r\n  function withdrawETHFundsInternal() internal {\r\n    uint256 balance = address(this).balance;\r\n\r\n    if (balance > totalUnspentETH && balance > minimalBalance) {\r\n      uint256 amount = balance.sub(minimalBalance);\r\n      // solium-disable-next-line security/no-send\r\n      require(vaultETH.send(amount), \"TOS15\");\r\n      emit WithdrawETH(vaultETH, amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev invest internal\r\n   */\r\n  function investInternal(\r\n    address _investor, uint256 _amountETH, uint256 _amountCHF)\r\n    private\r\n  {\r\n    // investment with _amountETH is decentralized\r\n    // investment with _amountCHF is centralized\r\n    // They are mutually exclusive\r\n    bool isInvesting = (\r\n        _amountETH != 0 && _amountCHF == 0\r\n      ) || (\r\n      _amountETH == 0 && _amountCHF != 0\r\n      );\r\n    require(isInvesting, \"TOS16\");\r\n    require(ratesProvider.rateWEIPerCHFCent() != 0, \"TOS17\");\r\n    uint256 investorId = userRegistry.userId(_investor);\r\n    require(userRegistry.isValid(investorId), \"TOS18\");\r\n\r\n    Investor storage investor = investors[investorId];\r\n\r\n    uint256 contributionCHF = ratesProvider.convertWEIToCHFCent(\r\n      investor.unspentETH);\r\n\r\n    if (_amountETH > 0) {\r\n      contributionCHF = contributionCHF.add(\r\n        ratesProvider.convertWEIToCHFCent(_amountETH));\r\n    }\r\n    if (_amountCHF > 0) {\r\n      contributionCHF = contributionCHF.add(_amountCHF);\r\n    }\r\n\r\n    uint256 tokens = allowedTokenInvestment(investorId, contributionCHF);\r\n    require(tokens != 0, \"TOS19\");\r\n\r\n    /** Calculating unspentETH value **/\r\n    uint256 investedCHF = tokens.mul(BASE_PRICE_CHF_CENT);\r\n    uint256 unspentContributionCHF = contributionCHF.sub(investedCHF);\r\n\r\n    uint256 unspentETH = 0;\r\n    if (unspentContributionCHF != 0) {\r\n      if (_amountCHF > 0) {\r\n        // Prevent CHF investment LARGER than available supply\r\n        // from creating a too large and dangerous unspentETH value\r\n        require(unspentContributionCHF < BASE_PRICE_CHF_CENT, \"TOS21\");\r\n      }\r\n      unspentETH = ratesProvider.convertCHFCentToWEI(\r\n        unspentContributionCHF);\r\n    }\r\n\r\n    /** Spent ETH **/\r\n    uint256 spentETH = 0;\r\n    if (investor.unspentETH == unspentETH) {\r\n      spentETH = _amountETH;\r\n    } else {\r\n      uint256 unspentETHDiff = (unspentETH > investor.unspentETH)\r\n        ? unspentETH.sub(investor.unspentETH)\r\n        : investor.unspentETH.sub(unspentETH);\r\n\r\n      if (_amountCHF > 0) {\r\n        if (unspentETH < investor.unspentETH) {\r\n          spentETH = unspentETHDiff;\r\n        }\r\n        // if unspentETH > investor.unspentETH\r\n        // then CHF has been converted into ETH\r\n        // and no ETH were spent\r\n      }\r\n      if (_amountETH > 0) {\r\n        spentETH = (unspentETH > investor.unspentETH)\r\n          ? _amountETH.sub(unspentETHDiff)\r\n          : _amountETH.add(unspentETHDiff);\r\n      }\r\n    }\r\n\r\n    totalUnspentETH = totalUnspentETH.sub(\r\n      investor.unspentETH).add(unspentETH);\r\n    investor.unspentETH = unspentETH;\r\n    investor.investedCHF = investor.investedCHF.add(investedCHF);\r\n    investor.tokens = investor.tokens.add(tokens);\r\n    raisedCHF = raisedCHF.add(_amountCHF);\r\n    raisedETH = raisedETH.add(spentETH);\r\n    totalRaisedCHF = totalRaisedCHF.add(investedCHF);\r\n\r\n    allocatedTokens = allocatedTokens.sub(investor.allocations);\r\n    investor.allocations = (investor.allocations > tokens)\r\n      ? investor.allocations.sub(tokens) : 0;\r\n    allocatedTokens = allocatedTokens.add(investor.allocations);\r\n    require(\r\n      token.transferFrom(vaultERC20, _investor, tokens),\r\n      \"TOS22\");\r\n\r\n    if (spentETH > 0) {\r\n      emit ChangeETHCHF(\r\n        _investor,\r\n        spentETH,\r\n        ratesProvider.convertWEIToCHFCent(spentETH),\r\n        ratesProvider.rateWEIPerCHFCent());\r\n    }\r\n    emit Investment(investorId, investedCHF);\r\n  }\r\n\r\n  /* Util */\r\n  /**\r\n   * @dev current time\r\n   */\r\n  function currentTime() private view returns (uint256) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return now;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"allocatedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"investorTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisedCHF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sharePurchaseAgreementHash\",\"type\":\"bytes32\"}],\"name\":\"defineSPA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUnspentETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"investorLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sharePurchaseAgreementHash\",\"type\":\"bytes32\"}],\"name\":\"acceptSPA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"}],\"name\":\"refundManyUnspentETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaisedCHF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"contributionLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"investorAcceptedSPA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratesProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETHFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"investorInvestedCHF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"investorAllocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allocateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefundedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sharePurchaseAgreementHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"},{\"name\":\"_contributionCHF\",\"type\":\"uint256\"}],\"name\":\"allowedTokenInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalAutoWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePriceCHFCent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"allocateManyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"refundUnspentETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorIds\",\"type\":\"uint256[]\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"updateInvestorLimits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amountCHF\",\"type\":\"uint256\"}],\"name\":\"addOffChainInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startAt\",\"type\":\"uint256\"},{\"name\":\"_endAt\",\"type\":\"uint256\"}],\"name\":\"updateSchedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllETHFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investorId\",\"type\":\"uint256\"}],\"name\":\"investorUnspentETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"defineAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimalBalance\",\"type\":\"uint256\"}],\"name\":\"updateMinimalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_userRegistry\",\"type\":\"address\"},{\"name\":\"_ratesProvider\",\"type\":\"address\"},{\"name\":\"_vaultERC20\",\"type\":\"address\"},{\"name\":\"_vaultETH\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AuthorityDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharePurchaseAgreement\",\"type\":\"bytes32\"}],\"name\":\"SalePurchaseAgreementHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investorId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Allocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investorId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"spentCHF\",\"type\":\"uint256\"}],\"name\":\"Investment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"converted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"ChangeETHCHF\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawETH\",\"type\":\"event\"}]","ContractName":"Tokensale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096c645d3d3706f793ef52c19bbace441900ed47d0000000000000000000000004e19d015b2b4ff6c0aefc078c9ae1c079bb6a64a00000000000000000000000065d30deca4f8bca6ad637df2804213722859063000000000000000000000000009519a92007e055c8a727df194cd951da654b61600000000000000000000000074e6acf300e8c8d8ef7c1f85d2589fc1fcc8a500","Library":"","SwarmSource":"bzzr://69f6dd03eb23520cca541390b68fe6fcca8f7a581b19e392ddc767e88e0cb7ac"}]}