{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Interface that every module contract should implement\r\n */\r\ninterface IModule {\r\n\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() external pure returns (bytes4);\r\n\r\n    /**\r\n     * @notice Return the permission flags that are associated with a module\r\n     */\r\n    function getPermissions() external view returns(bytes32[]);\r\n\r\n    /**\r\n     * @notice Used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) external returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module factory contract should implement\r\n */\r\ninterface IModuleFactory {\r\n\r\n    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\r\n    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\r\n    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\r\n    event GenerateModuleFromFactory(\r\n        address _module,\r\n        bytes32 indexed _moduleName,\r\n        address indexed _moduleFactory,\r\n        address _creator,\r\n        uint256 _setupCost,\r\n        uint256 _timestamp\r\n    );\r\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    //Should create an instance of the Module, or throw\r\n    function deploy(bytes _data) external returns(address);\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[]);\r\n\r\n    /**\r\n     * @notice Get the name of the Module\r\n     */\r\n    function getName() external view returns(bytes32);\r\n\r\n    /**\r\n     * @notice Returns the instructions associated with the module\r\n     */\r\n    function getInstructions() external view returns (string);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns (bytes32[]);\r\n\r\n    /**\r\n     * @notice Used to change the setup fee\r\n     * @param _newSetupCost New setup fee\r\n     */\r\n    function changeFactorySetupFee(uint256 _newSetupCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the usage fee\r\n     * @param _newUsageCost New usage fee\r\n     */\r\n    function changeFactoryUsageFee(uint256 _newUsageCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the subscription fee\r\n     * @param _newSubscriptionCost New subscription fee\r\n     */\r\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) external;\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion New version array\r\n     */\r\n    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external;\r\n\r\n   /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function getSetupCost() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return Lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Used to get the upper bound\r\n     * @return Upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[]);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Module Registry contract\r\n */\r\ninterface IModuleRegistry {\r\n\r\n    /**\r\n     * @notice Called by a security token to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     */\r\n    function useModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityToken to use\r\n     * @param _moduleFactory is the address of the module factory to be registered\r\n     */\r\n    function registerModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory\r\n     * @param _moduleFactory is the address of the module factory to be deleted\r\n     */\r\n    function removeModule(address _moduleFactory) external;\r\n\r\n    /**\r\n    * @notice Called by Polymath to verify modules for SecurityToken to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\r\n    * @param _moduleFactory is the address of the module factory to be registered\r\n    */\r\n    function verifyModule(address _moduleFactory, bool _verified) external;\r\n\r\n    /**\r\n     * @notice Used to get the reputation of a Module Factory\r\n     * @param _factoryAddress address of the Module Factory\r\n     * @return address array which has the list of securityToken's uses that module factory\r\n     */\r\n    function getReputationByFactory(address _factoryAddress) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @param _securityToken is the token\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(bytes32[], address[]);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByType(uint8 _moduleType) external view returns(bytes32[], address[]);\r\n\r\n    /**\r\n     * @notice Returns the list of addresses of Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getModulesByType(uint8 _moduleType) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\r\n     * @param _moduleType is the module type to look for\r\n     * @param _securityToken is the address of SecurityToken\r\n     * @return address array that contains the list of available addresses of module factory contracts.\r\n     */\r\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Use to get the latest contract address of the regstries\r\n     */\r\n    function updateFromRegistry() external;\r\n\r\n    /**\r\n     * @notice Get the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address);\r\n\r\n    /**\r\n     * @notice Check whether the contract operations is paused or not\r\n     * @return bool \r\n     */\r\n    function isPaused() external view returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for managing polymath feature switches\r\n */\r\ninterface IFeatureRegistry {\r\n\r\n    /**\r\n     * @notice Get the status of a feature\r\n     * @param _nameKey is the key for the feature status mapping\r\n     * @return bool\r\n     */\r\n    function getFeatureStatus(string _nameKey) external view returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract to allow pausing and unpausing of certain functions\r\n */\r\ncontract Pausable {\r\n\r\n    event Pause(uint256 _timestammp);\r\n    event Unpause(uint256 _timestamp);\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n   /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(now);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to unpause, returns to normal state\r\n    */\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(now);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n\r\n    // Standard ERC20 interface\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //transfer, transferFrom must respect the result of verifyTransfer\r\n    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is the amount of tokens that will be minted to the investor\r\n     */\r\n    function mint(address _investor, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is The amount of tokens that will be minted to the investor\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken on behalf of someone else\r\n     * @param _from Address for whom to burn tokens\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnWithData(uint256 _value, bytes _data) external;\r\n\r\n    event Minted(address indexed _to, uint256 _value);\r\n    event Burnt(address indexed _burner, uint256 _value);\r\n\r\n    // Permissions this to a Permission module, which has a key of 1\r\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\r\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Module type\r\n     * @return uint256 Module index\r\n     * @return uint256 Name index\r\n\r\n     */\r\n    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8, uint256, uint256);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets length of investors array\r\n     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\r\n     * @return Length\r\n     */\r\n    function getInvestors() external view returns (address[]);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);\r\n    \r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Gets an investor at a particular index\r\n    * @param _index Index to return address from\r\n    * @return Investor address\r\n    */\r\n    function investors(uint256 _index) external view returns (address);\r\n\r\n   /**\r\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _tokenContract Address of the ERC20Basic compliance token\r\n    * @param _value Amount of POLY to withdraw\r\n    */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to approve more POLY to one of the modules\r\n    * @param _module Module address\r\n    * @param _budget New budget\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _budget) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n    * @notice Removes addresses with zero balances from the investors list\r\n    * @param _start Index in investors list at which to start removing zero balances\r\n    * @param _iters Max number of iterations of the for loop\r\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\r\n    */\r\n    function pruneInvestors(uint256 _start, uint256 _iters) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Ends token minting period permanently\r\n     */\r\n    function freezeMinting() external;\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target investors.\r\n     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\r\n     * @param _investors A list of addresses to whom the minted tokens will be delivered\r\n     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\r\n     * @return Success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced transfer\r\n     * @param _from address from which to take tokens\r\n     * @param _to address where to send tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a foced burn\r\n     * @param _from address from which to take tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n     function disableController() external;\r\n\r\n     /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n     function getVersion() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Gets the investor count\r\n     */\r\n     function getInvestorCount() external view returns(uint256);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\r\n\r\n     /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n     function granularity() external view returns(uint256);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Interface that any module contract should implement\r\n * @notice Contract is abstract\r\n */\r\ncontract Module is IModule {\r\n\r\n    address public factory;\r\n\r\n    address public securityToken;\r\n\r\n    bytes32 public constant FEE_ADMIN = \"FEE_ADMIN\";\r\n\r\n    IERC20 public polyToken;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public {\r\n        securityToken = _securityToken;\r\n        factory = msg.sender;\r\n        polyToken = IERC20(_polyAddress);\r\n    }\r\n\r\n    //Allows owner, factory or permissioned delegate\r\n    modifier withPerm(bytes32 _perm) {\r\n        bool isOwner = msg.sender == Ownable(securityToken).owner();\r\n        bool isFactory = msg.sender == factory;\r\n        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), \"Permission check failed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == Ownable(securityToken).owner(), \"Sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory {\r\n        require(msg.sender == factory, \"Sender is not factory\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOwner {\r\n        require(msg.sender == Ownable(factory).owner(), \"Sender is not factory owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOrOwner {\r\n        require((msg.sender == Ownable(securityToken).owner()) || (msg.sender == factory), \"Sender is not factory or owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {\r\n        require(polyToken.transferFrom(securityToken, Ownable(factory).owner(), _amount), \"Unable to take fee\");\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all Transfer Manager modules\r\n * @dev abstract contract\r\n */\r\ncontract ITransferManager is Module, Pausable {\r\n\r\n    //If verifyTransfer returns:\r\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\r\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\r\n    //  VALID, then the transfer is valid for this TM\r\n    //  NA, then the result from this TM is ignored\r\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\r\n\r\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes _data, bool _isTransfer) public returns(Result);\r\n\r\n    function unpause() public onlyOwner {\r\n        super._unpause();\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        super._pause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\r\n */\r\ncontract ReclaimTokens is Ownable {\r\n\r\n    /**\r\n    * @notice Reclaim all ERC20Basic compatible tokens\r\n    * @param _tokenContract The address of the token contract\r\n    */\r\n    function reclaimERC20(address _tokenContract) external onlyOwner {\r\n        require(_tokenContract != address(0), \"Invalid address\");\r\n        IERC20 token = IERC20(_tokenContract);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(owner, balance), \"Transfer failed\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title Core functionality for registry upgradability\r\n */\r\ncontract PolymathRegistry is ReclaimTokens {\r\n\r\n    mapping (bytes32 => address) public storedAddresses;\r\n\r\n    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\r\n\r\n    /**\r\n     * @notice Gets the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @return address\r\n     */\r\n    function getAddress(string _nameKey) external view returns(address) {\r\n        bytes32 key = keccak256(bytes(_nameKey));\r\n        require(storedAddresses[key] != address(0), \"Invalid address key\");\r\n        return storedAddresses[key];\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @param _newAddress is the new contract address\r\n     */\r\n    function changeAddress(string _nameKey, address _newAddress) external onlyOwner {\r\n        bytes32 key = keccak256(bytes(_nameKey));\r\n        emit ChangeAddress(_nameKey, storedAddresses[key], _newAddress);\r\n        storedAddresses[key] = _newAddress;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract RegistryUpdater is Ownable {\r\n\r\n    address public polymathRegistry;\r\n    address public moduleRegistry;\r\n    address public securityTokenRegistry;\r\n    address public featureRegistry;\r\n    address public polyToken;\r\n\r\n    constructor (address _polymathRegistry) public {\r\n        require(_polymathRegistry != address(0), \"Invalid address\");\r\n        polymathRegistry = _polymathRegistry;\r\n    }\r\n\r\n    function updateFromRegistry() public onlyOwner {\r\n        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress(\"ModuleRegistry\");\r\n        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress(\"SecurityTokenRegistry\");\r\n        featureRegistry = PolymathRegistry(polymathRegistry).getAddress(\"FeatureRegistry\");\r\n        polyToken = PolymathRegistry(polymathRegistry).getAddress(\"PolyToken\");\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract for reusable code\r\n */\r\nlibrary Util {\r\n\r\n   /**\r\n    * @notice Changes a string to upper case\r\n    * @param _base String to change\r\n    */\r\n    function upper(string _base) internal pure returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            bytes1 b1 = _baseBytes[i];\r\n            if (b1 >= 0x61 && b1 <= 0x7A) {\r\n                b1 = bytes1(uint8(b1)-32);\r\n            }\r\n            _baseBytes[i] = b1;\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the string into bytes32\r\n     * @param _source String that need to convert into bytes32\r\n     */\r\n    /// Notice - Maximum Length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function stringToBytes32(string memory _source) internal pure returns (bytes32) {\r\n        return bytesToBytes32(bytes(_source), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes bytes into bytes32\r\n     * @param _b Bytes that need to convert into bytes32\r\n     * @param _offset Offset from which to begin conversion\r\n     */\r\n    /// Notice - Maximum length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function bytesToBytes32(bytes _b, uint _offset) internal pure returns (bytes32) {\r\n        bytes32 result;\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            result |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the bytes32 into string\r\n     * @param _source that need to convert into string\r\n     */\r\n    function bytes32ToString(bytes32 _source) internal pure returns (string result) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_source) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets function signature from _data\r\n     * @param _data Passed data\r\n     * @return bytes4 sig\r\n     */\r\n    function getSig(bytes _data) internal pure returns (bytes4 sig) {\r\n        uint len = _data.length < 4 ? _data.length : 4;\r\n        for (uint i = 0; i < len; i++) {\r\n            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all permission manager modules\r\n */\r\ninterface IPermissionManager {\r\n\r\n    /**\r\n    * @notice Used to check the permission on delegate corresponds to module contract address\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @return bool\r\n    */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool);\r\n\r\n    /**\r\n    * @notice Used to add a delegate\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _details Details about the delegate i.e `Belongs to financial firm`\r\n    */\r\n    function addDelegate(address _delegate, bytes32 _details) external;\r\n\r\n    /**\r\n    * @notice Used to delete a delegate\r\n    * @param _delegate Ethereum address of the delegate\r\n    */\r\n    function deleteDelegate(address _delegate) external;\r\n\r\n    /**\r\n    * @notice Used to check if an address is a delegate or not\r\n    * @param _potentialDelegate the address of potential delegate\r\n    * @return bool\r\n    */\r\n    function checkDelegate(address _potentialDelegate) external view returns(bool);\r\n\r\n    /**\r\n    * @notice Used to provide/change the permission to the delegate corresponds to the module contract\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @param _valid Bool flag use to switch on/off the permission\r\n    * @return bool\r\n    */\r\n    function changePermission(\r\n        address _delegate,\r\n        address _module,\r\n        bytes32 _perm,\r\n        bool _valid\r\n    )\r\n    external;\r\n\r\n    /**\r\n    * @notice Used to change one or more permissions for a single delegate at once\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _modules Multiple module matching the multiperms, needs to be same length\r\n    * @param _perms Multiple permission flag needs to be changed\r\n    * @param _valids Bool array consist the flag to switch on/off the permission\r\n    * @return nothing\r\n    */\r\n    function changePermissionMulti(\r\n        address _delegate,\r\n        address[] _modules,\r\n        bytes32[] _perms,\r\n        bool[] _valids\r\n    )\r\n    external;\r\n\r\n    /**\r\n    * @notice Used to return all delegates with a given permission and module\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @return address[]\r\n    */\r\n    function getAllDelegatesWithPerm(address _module, bytes32 _perm) external view returns(address[]);\r\n\r\n     /**\r\n    * @notice Used to return all permission of a single or multiple module\r\n    * @dev possible that function get out of gas is there are lot of modules and perm related to them\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _types uint8[] of types\r\n    * @return address[] the address array of Modules this delegate has permission\r\n    * @return bytes32[] the permission array of the corresponding Modules\r\n    */\r\n    function getAllModulesAndPermsFromTypes(address _delegate, uint8[] _types) external view returns(address[], bytes32[]);\r\n\r\n    /**\r\n    * @notice Used to get the Permission flag related the `this` contract\r\n    * @return Array of permission flags\r\n    */\r\n    function getPermissions() external view returns(bytes32[]);\r\n\r\n    /**\r\n    * @notice Used to get all delegates\r\n    * @return address[]\r\n    */\r\n    function getAllDelegates() external view returns(address[]);\r\n\r\n}\r\n\r\nlibrary TokenLib {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Struct for module data\r\n    struct ModuleData {\r\n        bytes32 name;\r\n        address module;\r\n        address moduleFactory;\r\n        bool isArchived;\r\n        uint8[] moduleTypes;\r\n        uint256[] moduleIndexes;\r\n        uint256 nameIndex;\r\n    }\r\n\r\n    // Structures to maintain checkpoints of balances for governance / dividends\r\n    struct Checkpoint {\r\n        uint256 checkpointId;\r\n        uint256 value;\r\n    }\r\n\r\n    struct InvestorDataStorage {\r\n        // List of investors who have ever held a non-zero token balance\r\n        mapping (address => bool) investorListed;\r\n        // List of token holders\r\n        address[] investors;\r\n        // Total number of non-zero token holders\r\n        uint256 investorCount;\r\n    }\r\n\r\n    // Emit when Module is archived from the SecurityToken\r\n    event ModuleArchived(uint8[] _types, address _module, uint256 _timestamp);\r\n    // Emit when Module is unarchived from the SecurityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module, uint256 _timestamp);\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    * @param _module Address of module to archive\r\n    */\r\n    function archiveModule(ModuleData storage _moduleData, address _module) public {\r\n        require(!_moduleData.isArchived, \"Module archived\");\r\n        require(_moduleData.module != address(0), \"Module missing\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleArchived(_moduleData.moduleTypes, _module, now);\r\n        _moduleData.isArchived = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    * @param _module Address of module to unarchive\r\n    */\r\n    function unarchiveModule(ModuleData storage _moduleData, address _module) public {\r\n        require(_moduleData.isArchived, \"Module unarchived\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleUnarchived(_moduleData.moduleTypes, _module, now);\r\n        _moduleData.isArchived = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates permissions with PermissionManager if it exists. If there's no permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions by default\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _modules is the modules to check permissions on\r\n     * @param _delegate is the address of the delegate\r\n     * @param _module is the address of the PermissionManager module\r\n     * @param _perm is the permissions data\r\n     * @return success\r\n     */\r\n    function checkPermission(address[] storage _modules, address _delegate, address _module, bytes32 _perm) public view returns(bool) {\r\n        if (_modules.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < _modules.length; i++) {\r\n            if (IPermissionManager(_modules[i]).checkPermission(_delegate, _module, _perm)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Queries a value at a defined checkpoint\r\n     * @param _checkpoints is array of Checkpoint objects\r\n     * @param _checkpointId is the Checkpoint ID to query\r\n     * @param _currentValue is the Current value of checkpoint\r\n     * @return uint256\r\n     */\r\n    function getValueAt(Checkpoint[] storage _checkpoints, uint256 _checkpointId, uint256 _currentValue) public view returns(uint256) {\r\n        //Checkpoint id 0 is when the token is first created - everyone has a zero balance\r\n        if (_checkpointId == 0) {\r\n            return 0;\r\n        }\r\n        if (_checkpoints.length == 0) {\r\n            return _currentValue;\r\n        }\r\n        if (_checkpoints[0].checkpointId >= _checkpointId) {\r\n            return _checkpoints[0].value;\r\n        }\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId < _checkpointId) {\r\n            return _currentValue;\r\n        }\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId == _checkpointId) {\r\n            return _checkpoints[_checkpoints.length - 1].value;\r\n        }\r\n        uint256 min = 0;\r\n        uint256 max = _checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint256 mid = (max + min) / 2;\r\n            if (_checkpoints[mid].checkpointId == _checkpointId) {\r\n                max = mid;\r\n                break;\r\n            }\r\n            if (_checkpoints[mid].checkpointId < _checkpointId) {\r\n                min = mid + 1;\r\n            } else {\r\n                max = mid;\r\n            }\r\n        }\r\n        return _checkpoints[max].value;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores the changes to the checkpoint objects\r\n     * @param _checkpoints is the affected checkpoint object array\r\n     * @param _newValue is the new value that needs to be stored\r\n     */\r\n    function adjustCheckpoints(TokenLib.Checkpoint[] storage _checkpoints, uint256 _newValue, uint256 _currentCheckpointId) public {\r\n        //No checkpoints set yet\r\n        if (_currentCheckpointId == 0) {\r\n            return;\r\n        }\r\n        //No new checkpoints since last update\r\n        if ((_checkpoints.length > 0) && (_checkpoints[_checkpoints.length - 1].checkpointId == _currentCheckpointId)) {\r\n            return;\r\n        }\r\n        //New checkpoint, so record balance\r\n        _checkpoints.push(\r\n            TokenLib.Checkpoint({\r\n                checkpointId: _currentCheckpointId,\r\n                value: _newValue\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Keeps track of the number of non-zero token holders\r\n    * @param _investorData Date releated to investor metrics\r\n    * @param _from Sender of transfer\r\n    * @param _to Receiver of transfer\r\n    * @param _value Value of transfer\r\n    * @param _balanceTo Balance of the _to address\r\n    * @param _balanceFrom Balance of the _from address\r\n    */\r\n    function adjustInvestorCount(\r\n        InvestorDataStorage storage _investorData,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _balanceTo,\r\n        uint256 _balanceFrom\r\n        ) public  {\r\n        if ((_value == 0) || (_from == _to)) {\r\n            return;\r\n        }\r\n        // Check whether receiver is a new token holder\r\n        if ((_balanceTo == 0) && (_to != address(0))) {\r\n            _investorData.investorCount = (_investorData.investorCount).add(1);\r\n        }\r\n        // Check whether sender is moving all of their tokens\r\n        if (_value == _balanceFrom) {\r\n            _investorData.investorCount = (_investorData.investorCount).sub(1);\r\n        }\r\n        //Also adjust investor list\r\n        if (!_investorData.investorListed[_to] && (_to != address(0))) {\r\n            _investorData.investors.push(_to);\r\n            _investorData.investorListed[_to] = true;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title Security Token contract\r\n* @notice SecurityToken is an ERC20 token with added capabilities:\r\n* @notice - Implements the ST-20 Interface\r\n* @notice - Transfers are restricted\r\n* @notice - Modules can be attached to it to control its behaviour\r\n* @notice - ST should not be deployed directly, but rather the SecurityTokenRegistry should be used\r\n* @notice - ST does not inherit from ISecurityToken due to:\r\n* @notice - https://github.com/ethereum/solidity/issues/4847\r\n*/\r\ncontract SecurityToken is StandardToken, DetailedERC20, ReentrancyGuard, RegistryUpdater {\r\n    using SafeMath for uint256;\r\n\r\n    TokenLib.InvestorDataStorage investorData;\r\n\r\n    // Used to hold the semantic version data\r\n    struct SemanticVersion {\r\n        uint8 major;\r\n        uint8 minor;\r\n        uint8 patch;\r\n    }\r\n\r\n    SemanticVersion securityTokenVersion;\r\n\r\n    // off-chain data\r\n    string public tokenDetails;\r\n\r\n    uint8 constant PERMISSION_KEY = 1;\r\n    uint8 constant TRANSFER_KEY = 2;\r\n    uint8 constant MINT_KEY = 3;\r\n    uint8 constant CHECKPOINT_KEY = 4;\r\n    uint8 constant BURN_KEY = 5;\r\n\r\n    uint256 public granularity;\r\n\r\n    // Value of current checkpoint\r\n    uint256 public currentCheckpointId;\r\n\r\n    // Used to temporarily halt all transactions\r\n    bool public transfersFrozen;\r\n\r\n    // Used to permanently halt all minting\r\n    bool public mintingFrozen;\r\n\r\n    // Used to permanently halt controller actions\r\n    bool public controllerDisabled;\r\n\r\n    // Address whitelisted by issuer as controller\r\n    address public controller;\r\n\r\n    // Records added modules - module list should be order agnostic!\r\n    mapping (uint8 => address[]) modules;\r\n\r\n    // Records information about the module\r\n    mapping (address => TokenLib.ModuleData) modulesToData;\r\n\r\n    // Records added module names - module list should be order agnostic!\r\n    mapping (bytes32 => address[]) names;\r\n\r\n    // Map each investor to a series of checkpoints\r\n    mapping (address => TokenLib.Checkpoint[]) checkpointBalances;\r\n\r\n    // List of checkpoints that relate to total supply\r\n    TokenLib.Checkpoint[] checkpointTotalSupply;\r\n\r\n    // Times at which each checkpoint was created\r\n    uint256[] checkpointTimes;\r\n\r\n    // Emit at the time when module get added\r\n    event ModuleAdded(\r\n        uint8[] _types,\r\n        bytes32 _name,\r\n        address _moduleFactory,\r\n        address _module,\r\n        uint256 _moduleCost,\r\n        uint256 _budget,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    // Emit when the token details get updated\r\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\r\n    // Emit when the granularity get changed\r\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\r\n    // Emit when Module get archived from the securityToken\r\n    event ModuleArchived(uint8[] _types, address _module, uint256 _timestamp);\r\n    // Emit when Module get unarchived from the securityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module, uint256 _timestamp);\r\n    // Emit when Module get removed from the securityToken\r\n    event ModuleRemoved(uint8[] _types, address _module, uint256 _timestamp);\r\n    // Emit when the budget allocated to a module is changed\r\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget);\r\n    // Emit when transfers are frozen or unfrozen\r\n    event FreezeTransfers(bool _status, uint256 _timestamp);\r\n    // Emit when new checkpoint created\r\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _timestamp);\r\n    // Emit when is permanently frozen by the issuer\r\n    event FreezeMinting(uint256 _timestamp);\r\n    // Events to log minting and burning\r\n    event Minted(address indexed _to, uint256 _value);\r\n    event Burnt(address indexed _from, uint256 _value);\r\n\r\n    // Events to log controller actions\r\n    event SetController(address indexed _oldController, address indexed _newController);\r\n    event ForceTransfer(\r\n        address indexed _controller,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bool _verifyTransfer,\r\n        bytes _data\r\n    );\r\n    event ForceBurn(\r\n        address indexed _controller,\r\n        address indexed _from,\r\n        uint256 _value,\r\n        bool _verifyTransfer,\r\n        bytes _data\r\n    );\r\n    event DisableController(uint256 _timestamp);\r\n\r\n    function _isModule(address _module, uint8 _type) internal view returns (bool) {\r\n        require(modulesToData[_module].module == _module, \"Wrong address\");\r\n        require(!modulesToData[_module].isArchived, \"Module archived\");\r\n        for (uint256 i = 0; i < modulesToData[_module].moduleTypes.length; i++) {\r\n            if (modulesToData[_module].moduleTypes[i] == _type) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Require msg.sender to be the specified module type\r\n    modifier onlyModule(uint8 _type) {\r\n        require(_isModule(msg.sender, _type));\r\n        _;\r\n    }\r\n\r\n    // Require msg.sender to be the specified module type or the owner of the token\r\n    modifier onlyModuleOrOwner(uint8 _type) {\r\n        if (msg.sender == owner) {\r\n            _;\r\n        } else {\r\n            require(_isModule(msg.sender, _type));\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier checkGranularity(uint256 _value) {\r\n        require(_value % granularity == 0, \"Invalid granularity\");\r\n        _;\r\n    }\r\n\r\n    modifier isMintingAllowed() {\r\n        require(!mintingFrozen, \"Minting frozen\");\r\n        _;\r\n    }\r\n\r\n    modifier isEnabled(string _nameKey) {\r\n        require(IFeatureRegistry(featureRegistry).getFeatureStatus(_nameKey));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Revert if called by an account which is not a controller\r\n     */\r\n    modifier onlyController() {\r\n        require(msg.sender == controller, \"Not controller\");\r\n        require(!controllerDisabled, \"Controller disabled\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _name Name of the SecurityToken\r\n     * @param _symbol Symbol of the Token\r\n     * @param _decimals Decimals for the securityToken\r\n     * @param _granularity granular level of the token\r\n     * @param _tokenDetails Details of the token that are stored off-chain\r\n     * @param _polymathRegistry Contract address of the polymath registry\r\n     */\r\n    constructor (\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        uint256 _granularity,\r\n        string _tokenDetails,\r\n        address _polymathRegistry\r\n    )\r\n    public\r\n    DetailedERC20(_name, _symbol, _decimals)\r\n    RegistryUpdater(_polymathRegistry)\r\n    {\r\n        //When it is created, the owner is the STR\r\n        updateFromRegistry();\r\n        tokenDetails = _tokenDetails;\r\n        granularity = _granularity;\r\n        securityTokenVersion = SemanticVersion(2,0,0);\r\n    }\r\n\r\n    /**\r\n     * @notice Attachs a module to the SecurityToken\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to the module.\r\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external onlyOwner nonReentrant {\r\n        //Check that the module factory exists in the ModuleRegistry - will throw otherwise\r\n        IModuleRegistry(moduleRegistry).useModule(_moduleFactory);\r\n        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\r\n        uint8[] memory moduleTypes = moduleFactory.getTypes();\r\n        uint256 moduleCost = moduleFactory.getSetupCost();\r\n        require(moduleCost <= _maxCost, \"Invalid cost\");\r\n        //Approve fee for module\r\n        ERC20(polyToken).approve(_moduleFactory, moduleCost);\r\n        //Creates instance of module from factory\r\n        address module = moduleFactory.deploy(_data);\r\n        require(modulesToData[module].module == address(0), \"Module exists\");\r\n        //Approve ongoing budget\r\n        ERC20(polyToken).approve(module, _budget);\r\n        //Add to SecurityToken module map\r\n        bytes32 moduleName = moduleFactory.getName();\r\n        uint256[] memory moduleIndexes = new uint256[](moduleTypes.length);\r\n        uint256 i;\r\n        for (i = 0; i < moduleTypes.length; i++) {\r\n            moduleIndexes[i] = modules[moduleTypes[i]].length;\r\n            modules[moduleTypes[i]].push(module);\r\n        }\r\n        modulesToData[module] = TokenLib.ModuleData(\r\n            moduleName, module, _moduleFactory, false, moduleTypes, moduleIndexes, names[moduleName].length\r\n        );\r\n        names[moduleName].push(module);\r\n        //Emit log event\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleAdded(moduleTypes, moduleName, _moduleFactory, module, moduleCost, _budget, now);\r\n    }\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external onlyOwner {\r\n        TokenLib.archiveModule(modulesToData[_module], _module);\r\n    }\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external onlyOwner {\r\n        TokenLib.unarchiveModule(modulesToData[_module], _module);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function removeModule(address _module) external onlyOwner {\r\n        require(modulesToData[_module].isArchived, \"Not archived\");\r\n        require(modulesToData[_module].module != address(0), \"Module missing\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleRemoved(modulesToData[_module].moduleTypes, _module, now);\r\n        // Remove from module type list\r\n        uint8[] memory moduleTypes = modulesToData[_module].moduleTypes;\r\n        for (uint256 i = 0; i < moduleTypes.length; i++) {\r\n            _removeModuleWithIndex(moduleTypes[i], modulesToData[_module].moduleIndexes[i]);\r\n            /* modulesToData[_module].moduleType[moduleTypes[i]] = false; */\r\n        }\r\n        // Remove from module names list\r\n        uint256 index = modulesToData[_module].nameIndex;\r\n        bytes32 name = modulesToData[_module].name;\r\n        uint256 length = names[name].length;\r\n        names[name][index] = names[name][length - 1];\r\n        names[name].length = length - 1;\r\n        if ((length - 1) != index) {\r\n            modulesToData[names[name][index]].nameIndex = index;\r\n        }\r\n        // Remove from modulesToData\r\n        delete modulesToData[_module];\r\n    }\r\n\r\n    /**\r\n    * @notice Internal - Removes a module attached to the SecurityToken by index\r\n    */\r\n    function _removeModuleWithIndex(uint8 _type, uint256 _index) internal {\r\n        uint256 length = modules[_type].length;\r\n        modules[_type][_index] = modules[_type][length - 1];\r\n        modules[_type].length = length - 1;\r\n\r\n        if ((length - 1) != _index) {\r\n            //Need to find index of _type in moduleTypes of module we are moving\r\n            uint8[] memory newTypes = modulesToData[modules[_type][_index]].moduleTypes;\r\n            for (uint256 i = 0; i < newTypes.length; i++) {\r\n                if (newTypes[i] == _type) {\r\n                    modulesToData[modules[_type][_index]].moduleIndexes[i] = _index;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the data associated to a module\r\n     * @param _module address of the module\r\n     * @return bytes32 name\r\n     * @return address module address\r\n     * @return address module factory address\r\n     * @return bool module archived\r\n     * @return uint8 module type\r\n     */\r\n    function getModule(address _module) external view returns (bytes32, address, address, bool, uint8[]) {\r\n        return (modulesToData[_module].name,\r\n        modulesToData[_module].module,\r\n        modulesToData[_module].moduleFactory,\r\n        modulesToData[_module].isArchived,\r\n        modulesToData[_module].moduleTypes);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a list of modules that match the provided name\r\n     * @param _name name of the module\r\n     * @return address[] list of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns (address[]) {\r\n        return names[_name];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a list of modules that match the provided module type\r\n     * @param _type type of the module\r\n     * @return address[] list of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns (address[]) {\r\n        return modules[_type];\r\n    }\r\n\r\n   /**\r\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _tokenContract Address of the ERC20Basic compliance token\r\n    * @param _value amount of POLY to withdraw\r\n    */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external onlyOwner {\r\n        require(_tokenContract != address(0));\r\n        IERC20 token = IERC20(_tokenContract);\r\n        require(token.transfer(owner, _value));\r\n    }\r\n\r\n    /**\r\n\r\n    * @notice allows owner to increase/decrease POLY approval of one of the modules\r\n    * @param _module module address\r\n    * @param _change change in allowance\r\n    * @param _increase true if budget has to be increased, false if decrease\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external onlyOwner {\r\n        require(modulesToData[_module].module != address(0), \"Module missing\");\r\n        uint256 currentAllowance = IERC20(polyToken).allowance(address(this), _module);\r\n        uint256 newAllowance;\r\n        if (_increase) {\r\n            require(IERC20(polyToken).increaseApproval(_module, _change), \"IncreaseApproval fail\");\r\n            newAllowance = currentAllowance.add(_change);\r\n        } else {\r\n            require(IERC20(polyToken).decreaseApproval(_module, _change), \"Insufficient allowance\");\r\n            newAllowance = currentAllowance.sub(_change);\r\n        }\r\n        emit ModuleBudgetChanged(modulesToData[_module].moduleTypes, _module, currentAllowance, newAllowance);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the tokenDetails associated with the token\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) external onlyOwner {\r\n        emit UpdateTokenDetails(tokenDetails, _newTokenDetails);\r\n        tokenDetails = _newTokenDetails;\r\n    }\r\n\r\n    /**\r\n    * @notice Allows owner to change token granularity\r\n    * @param _granularity granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external onlyOwner {\r\n        require(_granularity != 0, \"Invalid granularity\");\r\n        emit GranularityChanged(granularity, _granularity);\r\n        granularity = _granularity;\r\n    }\r\n\r\n    /**\r\n    * @notice Keeps track of the number of non-zero token holders\r\n    * @param _from sender of transfer\r\n    * @param _to receiver of transfer\r\n    * @param _value value of transfer\r\n    */\r\n    function _adjustInvestorCount(address _from, address _to, uint256 _value) internal {\r\n        TokenLib.adjustInvestorCount(investorData, _from, _to, _value, balanceOf(_to), balanceOf(_from));\r\n    }\r\n\r\n    /**\r\n     * @notice returns an array of investors\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @return list of addresses\r\n     */\r\n    function getInvestors() external view returns(address[]) {\r\n        return investorData.investors;\r\n    }\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]) {\r\n        uint256 count = 0;\r\n        uint256 i;\r\n        for (i = 0; i < investorData.investors.length; i++) {\r\n            if (balanceOfAt(investorData.investors[i], _checkpointId) > 0) {\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory investors = new address[](count);\r\n        count = 0;\r\n        for (i = 0; i < investorData.investors.length; i++) {\r\n            if (balanceOfAt(investorData.investors[i], _checkpointId) > 0) {\r\n                investors[count] = investorData.investors[i];\r\n                count++;\r\n            }\r\n        }\r\n        return investors;\r\n    }\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]) {\r\n        require(_end <= investorData.investors.length, \"Invalid end\");\r\n        address[] memory investors = new address[](_end.sub(_start));\r\n        uint256 index = 0;\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            investors[index] = investorData.investors[i];\r\n            index++;\r\n        }\r\n        return investors;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the investor count\r\n     * @return Investor count\r\n     */\r\n    function getInvestorCount() external view returns(uint256) {\r\n        return investorData.investorCount;\r\n    }\r\n\r\n    /**\r\n     * @notice freezes transfers\r\n     */\r\n    function freezeTransfers() external onlyOwner {\r\n        require(!transfersFrozen, \"Already frozen\");\r\n        transfersFrozen = true;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit FreezeTransfers(true, now);\r\n    }\r\n\r\n    /**\r\n     * @notice Unfreeze transfers\r\n     */\r\n    function unfreezeTransfers() external onlyOwner {\r\n        require(transfersFrozen, \"Not frozen\");\r\n        transfersFrozen = false;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit FreezeTransfers(false, now);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - adjusts totalSupply at checkpoint after minting or burning tokens\r\n     */\r\n    function _adjustTotalSupplyCheckpoints() internal {\r\n        TokenLib.adjustCheckpoints(checkpointTotalSupply, totalSupply(), currentCheckpointId);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - adjusts token holder balance at checkpoint after a token transfer\r\n     * @param _investor address of the token holder affected\r\n     */\r\n    function _adjustBalanceCheckpoints(address _investor) internal {\r\n        TokenLib.adjustCheckpoints(checkpointBalances[_investor], balanceOf(_investor), currentCheckpointId);\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded version of the transfer function\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @return bool success\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        return transferWithData(_to, _value, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded version of the transfer function\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @param _data data to indicate validation\r\n     * @return bool success\r\n     */\r\n    function transferWithData(address _to, uint256 _value, bytes _data) public returns (bool success) {\r\n        require(_updateTransfer(msg.sender, _to, _value, _data), \"Transfer invalid\");\r\n        require(super.transfer(_to, _value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded version of the transferFrom function\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @return bool success\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\r\n        return transferFromWithData(_from, _to, _value, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded version of the transferFrom function\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @param _data data to indicate validation\r\n     * @return bool success\r\n     */\r\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) public returns(bool) {\r\n        require(_updateTransfer(_from, _to, _value, _data), \"Transfer invalid\");\r\n        require(super.transferFrom(_from, _to, _value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates internal variables when performing a transfer\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @param _data data to indicate validation\r\n     * @return bool success\r\n     */\r\n    function _updateTransfer(address _from, address _to, uint256 _value, bytes _data) internal nonReentrant returns(bool) {\r\n        // NB - the ordering in this function implies the following:\r\n        //  - investor counts are updated before transfer managers are called - i.e. transfer managers will see\r\n        //investor counts including the current transfer.\r\n        //  - checkpoints are updated after the transfer managers are called. This allows TMs to create\r\n        //checkpoints as though they have been created before the current transactions,\r\n        //  - to avoid the situation where a transfer manager transfers tokens, and this function is called recursively,\r\n        //the function is marked as nonReentrant. This means that no TM can transfer (or mint / burn) tokens.\r\n        _adjustInvestorCount(_from, _to, _value);\r\n        bool verified = _verifyTransfer(_from, _to, _value, _data, true);\r\n        _adjustBalanceCheckpoints(_from);\r\n        _adjustBalanceCheckpoints(_to);\r\n        return verified;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate transfer with TransferManager module if it exists\r\n     * @dev TransferManager module has a key of 2\r\n     * @dev _isTransfer boolean flag is the deciding factor for whether the\r\n     * state variables gets modified or not within the different modules. i.e isTransfer = true\r\n     * leads to change in the modules environment otherwise _verifyTransfer() works as a read-only\r\n     * function (no change in the state).\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @param _data data to indicate validation\r\n     * @param _isTransfer whether transfer is being executed\r\n     * @return bool\r\n     */\r\n    function _verifyTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bool _isTransfer\r\n    ) internal checkGranularity(_value) returns (bool) {\r\n        if (!transfersFrozen) {\r\n            bool isInvalid = false;\r\n            bool isValid = false;\r\n            bool isForceValid = false;\r\n            bool unarchived = false;\r\n            address module;\r\n            for (uint256 i = 0; i < modules[TRANSFER_KEY].length; i++) {\r\n                module = modules[TRANSFER_KEY][i];\r\n                if (!modulesToData[module].isArchived) {\r\n                    unarchived = true;\r\n                    ITransferManager.Result valid = ITransferManager(module).verifyTransfer(_from, _to, _value, _data, _isTransfer);\r\n                    if (valid == ITransferManager.Result.INVALID) {\r\n                        isInvalid = true;\r\n                    } else if (valid == ITransferManager.Result.VALID) {\r\n                        isValid = true;\r\n                    } else if (valid == ITransferManager.Result.FORCE_VALID) {\r\n                        isForceValid = true;\r\n                    }\r\n                }\r\n            }\r\n            // If no unarchived modules, return true by default\r\n            return unarchived ? (isForceValid ? true : (isInvalid ? false : isValid)) : true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates a transfer with a TransferManager module if it exists\r\n     * @dev TransferManager module has a key of 2\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @param _data data to indicate validation\r\n     * @return bool\r\n     */\r\n    function verifyTransfer(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\r\n        return _verifyTransfer(_from, _to, _value, _data, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Permanently freeze minting of this security token.\r\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\r\n     */\r\n    function freezeMinting() external isMintingAllowed() isEnabled(\"freezeMintingAllowed\") onlyOwner {\r\n        mintingFrozen = true;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit FreezeMinting(now);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * @dev Can only be called by the issuer or STO attached to the token\r\n     * @param _investor Address where the minted tokens will be delivered\r\n     * @param _value Number of tokens be minted\r\n     * @return success\r\n     */\r\n    function mint(address _investor, uint256 _value) public returns (bool success) {\r\n        return mintWithData(_investor, _value, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice mints new tokens and assigns them to the target _investor.\r\n     * @dev Can only be called by the issuer or STO attached to the token\r\n     * @param _investor Address where the minted tokens will be delivered\r\n     * @param _value Number of tokens be minted\r\n     * @param _data data to indicate validation\r\n     * @return success\r\n     */\r\n    function mintWithData(\r\n        address _investor,\r\n        uint256 _value,\r\n        bytes _data\r\n        ) public onlyModuleOrOwner(MINT_KEY) isMintingAllowed() returns (bool success) {\r\n        require(_investor != address(0), \"Investor is 0\");\r\n        require(_updateTransfer(address(0), _investor, _value, _data), \"Transfer invalid\");\r\n        _adjustTotalSupplyCheckpoints();\r\n        totalSupply_ = totalSupply_.add(_value);\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        emit Minted(_investor, _value);\r\n        emit Transfer(address(0), _investor, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * @dev Can only be called by the issuer or STO attached to the token.\r\n     * @param _investors A list of addresses to whom the minted tokens will be dilivered\r\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _investor[] list\r\n     * @return success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success) {\r\n        require(_investors.length == _values.length, \"Incorrect inputs\");\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            mint(_investors[i], _values[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool) {\r\n        for (uint256 i = 0; i < modules[PERMISSION_KEY].length; i++) {\r\n            if (!modulesToData[modules[PERMISSION_KEY][i]].isArchived)\r\n                return TokenLib.checkPermission(modules[PERMISSION_KEY], _delegate, _module, _perm);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _burn(address _from, uint256 _value, bytes _data) internal returns(bool) {\r\n        require(_value <= balances[_from], \"Value too high\");\r\n        bool verified = _updateTransfer(_from, address(0), _value, _data);\r\n        _adjustTotalSupplyCheckpoints();\r\n        balances[_from] = balances[_from].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burnt(_from, _value);\r\n        emit Transfer(_from, address(0), _value);\r\n        return verified;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn function used to burn the securityToken\r\n     * @param _value No. of tokens that get burned\r\n     * @param _data data to indicate validation\r\n     */\r\n    function burnWithData(uint256 _value, bytes _data) public onlyModule(BURN_KEY) {\r\n        require(_burn(msg.sender, _value, _data), \"Burn invalid\");\r\n    }\r\n\r\n    /**\r\n     * @notice Burn function used to burn the securityToken on behalf of someone else\r\n     * @param _from Address for whom to burn tokens\r\n     * @param _value No. of tokens that get burned\r\n     * @param _data data to indicate validation\r\n     */\r\n    function burnFromWithData(address _from, uint256 _value, bytes _data) public onlyModule(BURN_KEY) {\r\n        require(_value <= allowed[_from][msg.sender], \"Value too high\");\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        require(_burn(_from, _value, _data), \"Burn invalid\");\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     * @return uint256\r\n     */\r\n    function createCheckpoint() external onlyModuleOrOwner(CHECKPOINT_KEY) returns(uint256) {\r\n        require(currentCheckpointId < 2**256 - 1);\r\n        currentCheckpointId = currentCheckpointId + 1;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        checkpointTimes.push(now);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit CheckpointCreated(currentCheckpointId, now);\r\n        return currentCheckpointId;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets list of times that checkpoints were created\r\n     * @return List of checkpoint times\r\n     */\r\n    function getCheckpointTimes() external view returns(uint256[]) {\r\n        return checkpointTimes;\r\n    }\r\n\r\n    /**\r\n     * @notice Queries totalSupply as of a defined checkpoint\r\n     * @param _checkpointId Checkpoint ID to query\r\n     * @return uint256\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256) {\r\n        require(_checkpointId <= currentCheckpointId);\r\n        return TokenLib.getValueAt(checkpointTotalSupply, _checkpointId, totalSupply());\r\n    }\r\n\r\n    /**\r\n     * @notice Queries balances as of a defined checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256) {\r\n        require(_checkpointId <= currentCheckpointId);\r\n        return TokenLib.getValueAt(checkpointBalances[_investor], _checkpointId, balanceOf(_investor));\r\n    }\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) public onlyOwner {\r\n        require(!controllerDisabled);\r\n        emit SetController(controller, _controller);\r\n        controller = _controller;\r\n    }\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n    function disableController() external isEnabled(\"disableControllerAllowed\") onlyOwner {\r\n        require(!controllerDisabled);\r\n        controllerDisabled = true;\r\n        delete controller;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit DisableController(now);\r\n    }\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced transfer\r\n     * @param _from address from which to take tokens\r\n     * @param _to address where to send tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) public onlyController {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        bool verified = _updateTransfer(_from, _to, _value, _data);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced burn\r\n     * @param _from address from which to take tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) public onlyController {\r\n        bool verified = _burn(_from, _value, _data);\r\n        emit ForceBurn(msg.sender, _from, _value, verified, _log);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the version of the SecurityToken\r\n     */\r\n    function getVersion() external view returns(uint8[]) {\r\n        uint8[] memory _version = new uint8[](3);\r\n        _version[0] = securityTokenVersion.major;\r\n        _version[1] = securityTokenVersion.minor;\r\n        _version[2] = securityTokenVersion.patch;\r\n        return _version;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"freezeTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"unarchiveModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_granularity\",\"type\":\"uint256\"}],\"name\":\"changeGranularity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"iterateInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreezeTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"archiveModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_log\",\"type\":\"bytes\"}],\"name\":\"forceBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"burnWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_checkpointId\",\"type\":\"uint256\"}],\"name\":\"getInvestorsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"mintMulti\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCheckpointTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_checkpointId\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCheckpointId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_log\",\"type\":\"bytes\"}],\"name\":\"forceTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_module\",\"type\":\"address\"},{\"name\":\"_change\",\"type\":\"uint256\"},{\"name\":\"_increase\",\"type\":\"bool\"}],\"name\":\"changeModuleBudget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenDetails\",\"type\":\"string\"}],\"name\":\"updateTokenDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getModulesByName\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polymathRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"burnFromWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_module\",\"type\":\"address\"},{\"name\":\"_perm\",\"type\":\"bytes32\"}],\"name\":\"checkPermission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mintWithData\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_checkpointId\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"removeModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"getModulesByType\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"getModule\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moduleRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"featureRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityTokenRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"verifyTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateFromRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_maxCost\",\"type\":\"uint256\"},{\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"addModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createCheckpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_granularity\",\"type\":\"uint256\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_polymathRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_moduleCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_budget\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldDetails\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_newDetails\",\"type\":\"string\"}],\"name\":\"UpdateTokenDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldGranularity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newGranularity\",\"type\":\"uint256\"}],\"name\":\"GranularityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ModuleArchived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ModuleUnarchived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ModuleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_moduleTypes\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldBudget\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"ModuleBudgetChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_status\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"FreezeTransfers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_checkpointId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"CheckpointCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"FreezeMinting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldController\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_verifyTransfer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"ForceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_verifyTransfer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"ForceBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"DisableController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SecurityToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000140000000000000000000000000dfabf3e4793cd30affb47ab6fa4cf4eef26bbc27000000000000000000000000000000000000000000000000000000000000000161000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016100000000000000000000000000000000000000000000000000000000000000","Library":"TokenLib:220f27e198d0dbaf823e677b52374ae46f4cc71b","SwarmSource":"bzzr://fd8a7c73ca77a4463586f860b26876199315b2a3308bd5450c398a9952978cf4"}]}