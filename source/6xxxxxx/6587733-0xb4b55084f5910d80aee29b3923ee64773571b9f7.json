{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/* - version: 1.0.0\r\n*  - Ref bonuses 2-3%\r\n*  - Invest dividends 3-4% if you invest more than 10 ETH you'll get 4%!\r\n*\r\n*/\r\ncontract MainContract {\r\n    address owner;\r\n\r\n    address advertisingAddress;\r\n\r\n    uint private constant minInvest = 5 finney; // 0.005 eth\r\n    using Calc for uint;\r\n    using PercentCalc for PercentCalc.percent;\r\n    using Zero for *;\r\n    using compileLibrary for *;\r\n\r\n    struct User {\r\n        uint idx;\r\n        uint value;\r\n        uint bonus;\r\n        bool invested10Eth;\r\n        uint payTime;\r\n    }\r\n\r\n    mapping(address => User) investorsStorage;\r\n\r\n    address[] users;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    event logsDataPayable(uint value, uint time, address indexed addr);\r\n\r\n    event logsDataConstructor(address creater, uint when, string text);\r\n\r\n    event newInvestor(address indexed addr, uint when, uint value);\r\n\r\n    event investToProject(address creater, uint when, string text);\r\n\r\n    event logPayDividends(uint value, uint when, address indexed addr, string text);\r\n\r\n    event logPayBonus(uint value, uint when, address indexed addr, string text);\r\n\r\n    event notEnoughETH(uint when, string text);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        users.length++;\r\n        emit logsDataConstructor(msg.sender, now, \"constructor\");\r\n    }\r\n\r\n    //     PercentCalc\r\n    PercentCalc.percent private dividendPercent = PercentCalc.percent(3); // 3%\r\n    PercentCalc.percent private refPercent = PercentCalc.percent(2); // 2%\r\n    PercentCalc.percent private advertisingPercent = PercentCalc.percent(8); // 8%\r\n    PercentCalc.percent private ownerPercent = PercentCalc.percent(5); // 5%\r\n\r\n    // dividend percent Bonus\r\n    PercentCalc.percent private dividendPercentBonus = PercentCalc.percent(4); // 4%\r\n    PercentCalc.percent private refPercentBonus = PercentCalc.percent(3); // 3%\r\n    //     PercentCalc\r\n\r\n    function() public payable {\r\n        if (msg.value == 0) {\r\n            fetchDividends();\r\n            return;\r\n        }\r\n\r\n        require(msg.value >= minInvest, \"value can't be < than 0.005\");\r\n\r\n        if (investorsStorage[msg.sender].idx > 0) {\r\n            investorsStorage[msg.sender].value += msg.value;\r\n            \r\n            if (!investorsStorage[msg.sender].invested10Eth && msg.value >= 10 ether) {\r\n                investorsStorage[msg.sender].invested10Eth = true;\r\n            }\r\n        } else {\r\n            address ref = msg.data.toAddr();\r\n            uint idx = investorsStorage[msg.sender].idx;\r\n            uint value = msg.value;\r\n            idx = users.length++;\r\n            if (ref.notZero() && investorsStorage[ref].idx > 0) {\r\n                setUserBonus(ref, msg.value);\r\n                value += refPercent.getValueByPercent(value);\r\n            }\r\n            emit newInvestor(msg.sender, now, msg.value);\r\n            investorsStorage[msg.sender] = User({\r\n                idx : idx,\r\n                value : value,\r\n                bonus : 0,\r\n                invested10Eth: msg.value >= 10 ether,\r\n                payTime : now\r\n            });\r\n        }\r\n\r\n        sendValueToOwner(msg.value);\r\n        sendValueToAdv(msg.value);\r\n\r\n        emit logsDataPayable(msg.value, now, msg.sender);\r\n    }\r\n\r\n\r\n    function setUserBonus(address addr, uint value) private {\r\n        uint bonus = refPercent.getValueByPercent(value);\r\n        if (investorsStorage[addr].idx > 0) {\r\n            if (investorsStorage[addr].invested10Eth) bonus = refPercentBonus.getValueByPercent(value);\r\n            investorsStorage[addr].bonus += bonus;\r\n            emit logPayBonus(bonus, now, addr, \"investor got bonuses!\");\r\n        } else {\r\n            sendValueToAdv(bonus);\r\n        }\r\n    }\r\n\r\n    function fetchDividends() private {\r\n        User memory inv = findInvestorByAddress(msg.sender);\r\n        require(inv.idx > 0, \"payer is not investor\");\r\n        uint payValueByTime = now.sub(inv.payTime).getDiffValue(12 hours);\r\n        require(payValueByTime > 0, \"the payment was earlier than 12 hours\");\r\n\r\n        uint dividendValue = (dividendPercent.getValueByPercent(inv.value) * payValueByTime) / 2;\r\n        if (inv.invested10Eth) dividendValue = (dividendPercentBonus.getValueByPercent(inv.value) * payValueByTime) / 2;\r\n\r\n        if (address(this).balance < dividendValue + inv.bonus) {\r\n            emit notEnoughETH(now, \"not enough eth\");\r\n            return;\r\n        }\r\n\r\n        if (inv.bonus > 0) {\r\n            sendDividendsWithBonus(msg.sender, dividendValue, inv.bonus);\r\n        } else {\r\n            sendDividends(msg.sender, dividendValue);\r\n        }\r\n    }\r\n\r\n\r\n    function setAdvertisingAddress(address addr) public onlyOwner {\r\n        advertisingAddress = addr;\r\n    }\r\n\r\n\r\n    function sendDividends(address addr, uint value) private {\r\n        updatePayTime(addr, now);\r\n        emit logPayDividends(value, now, addr, \"dividends\");\r\n        addr.transfer(value);\r\n    }\r\n\r\n    function sendDividendsWithBonus(address addr, uint value, uint bonus) private {\r\n        updatePayTime(addr, now);\r\n        emit logPayDividends(value + bonus, now, addr, \"dividends with bonus\");\r\n        addr.transfer(value + bonus);\r\n        investorsStorage[addr].bonus = 0;\r\n    }\r\n\r\n    function findInvestorByAddress(address addr) internal view returns (User) {\r\n        return User(\r\n            investorsStorage[addr].idx,\r\n            investorsStorage[addr].value,\r\n            investorsStorage[addr].bonus,\r\n            investorsStorage[addr].invested10Eth,\r\n            investorsStorage[addr].payTime\r\n        );\r\n    }\r\n\r\n    function sendValueToOwner(uint val) private {\r\n        owner.transfer(ownerPercent.getValueByPercent(val));\r\n    }\r\n\r\n    function sendValueToAdv(uint val) private {\r\n        advertisingAddress.transfer(advertisingPercent.getValueByPercent(val));\r\n    }\r\n\r\n\r\n    function updatePayTime(address addr, uint time) private returns (bool) {\r\n        if (investorsStorage[addr].idx == 0) return false;\r\n        investorsStorage[addr].payTime = time;\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Calc library\r\nlibrary Calc {\r\n    function getDiffValue(uint _a, uint _b) internal pure returns (uint) {\r\n        require(_b > 0);\r\n        uint c = _a / _b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint _a, uint _b) internal pure returns (uint) {\r\n        require(_b <= _a);\r\n        uint c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n}\r\n// Percent Calc library\r\nlibrary PercentCalc {\r\n    struct percent {\r\n        uint val;\r\n    }\r\n\r\n    function getValueByPercent(percent storage p, uint a) internal view returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a * p.val / 100;\r\n    }\r\n}\r\n\r\nlibrary Zero {\r\n    function notZero(address addr) internal pure returns (bool) {\r\n        return !(addr == address(0));\r\n    }\r\n}\r\n\r\n\r\nlibrary compileLibrary {\r\n    function toAddr(bytes source) internal pure returns (address addr) {\r\n        assembly {addr := mload(add(source, 0x14))}\r\n        return addr;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"logsDataPayable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logsDataConstructor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"newInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"investToProject\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"logPayBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"notEnoughETH\",\"type\":\"event\"}]","ContractName":"MainContract","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2eb74b9c05856a289f084e95c9ac8bd4ac7575da51ad3ded5d50ff1effb41558"}]}