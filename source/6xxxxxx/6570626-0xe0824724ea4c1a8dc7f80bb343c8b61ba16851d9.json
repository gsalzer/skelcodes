{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/interfaces/Token.sol\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\n// File: contracts/interfaces/TokenConverter.sol\r\n\r\ncontract TokenConverter {\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);\r\n    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);\r\n}\r\n\r\n// File: contracts/interfaces/AvailableProvider.sol\r\n\r\ninterface AvailableProvider {\r\n   function isAvailable(Token _from, Token _to, uint256 _amount) external view returns (bool);\r\n}\r\n\r\n// File: contracts/utils/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event SetOwner(address _owner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"msg.sender is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit SetOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev Transfers the ownership of the contract.\r\n\r\n        @param _to Address of the new owner\r\n    */\r\n    function transferTo(address _to) public onlyOwner returns (bool) {\r\n        require(_to != address(0), \"Can't transfer to address 0x0\");\r\n        emit SetOwner(_to);\r\n        owner = _to;\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenConverterRouter.sol\r\n\r\ncontract TokenConverterRouter is TokenConverter, Ownable {\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n\r\n    TokenConverter[] public converters;\r\n    \r\n    mapping(address => uint256) private converterToIndex;    \r\n    mapping (address => AvailableProvider) public availability;\r\n\r\n    uint256 extraLimit;\r\n    \r\n    event AddedConverter(address _converter);\r\n    event Converted(address _converter, uint256 _evaluated, address _from, address _to, uint256 _amount, uint256 _return);\r\n    event SetAvailableProvider(address _converter, address _provider);\r\n    event SetExtraLimit(uint256 _extraLimit);\r\n    event RemovedConverter(address _converter);\r\n    \r\n    event WithdrawTokens(address _token, address _to, uint256 _amount);\r\n    event WithdrawEth(address _to, uint256 _amount);\r\n\r\n    /*\r\n     *  @notice External function isWorker.\r\n     *  @dev Takes _worker, checks if the worker is valid. \r\n     *  @param _worker Worker address.\r\n     *  @return bool True if worker is valid, false otherwise.\r\n     */\r\n    function _issetConverter(address _converter) internal view returns (bool) {\r\n        return converterToIndex[_converter] != 0;\r\n    }\r\n    \r\n    /*\r\n    *  @notice External function allConverters.\r\n    *  @dev Return all convertes.\r\n    *  @return array with all address the converters.\r\n    */\r\n    function getConverters() external view returns (address[] memory result) {\r\n        result = new address[](converters.length - 1);\r\n        for (uint256 i = 1; i < converters.length; i++) {\r\n            result[i - 1] = converters[i];\r\n        }\r\n    }\r\n    \r\n    /*\r\n     *  @notice External function addConverter.\r\n     *  @dev Takes _converter.\r\n     *       Add converter.\r\n     *  @param _converter Converter address.\r\n     *  @return bool True if converter is added, false otherwise.\r\n     */\r\n    function addConverter(TokenConverter _converter) external onlyOwner returns (bool) {\r\n        require(!_issetConverter(_converter), \"The converter it already exist\");\r\n        uint256 index = converters.push(_converter) - 1;\r\n        converterToIndex[_converter] = index;\r\n        emit AddedConverter(_converter);\r\n        return true;\r\n    }\r\n    \r\n    /*\r\n     *  @notice External function removeConverter.\r\n     *  @dev Takes _converter and removes the converter.\r\n     *  @param _worker Converter address.\r\n     *  @return bool true if existed, false otherwise.\r\n     */\r\n    function removeConverter(address _converter) external onlyOwner returns (bool) {\r\n        require(_issetConverter(_converter), \"The converter is not exist.\");\r\n        uint256 index = converterToIndex[_converter];\r\n        TokenConverter lastConverter = converters[converters.length - 1];\r\n        converterToIndex[lastConverter] = index;\r\n        converters[index] = lastConverter;\r\n        converters.length--;\r\n        delete converterToIndex[_converter];\r\n        emit RemovedConverter(_converter);\r\n        return true;\r\n    }\r\n    \r\n    function setAvailableProvider(\r\n        TokenConverter _converter,\r\n        AvailableProvider _provider\r\n    ) external onlyOwner {\r\n        emit SetAvailableProvider(_converter, _provider);\r\n        availability[_converter] = _provider;        \r\n    }\r\n    \r\n    function setExtraLimit(uint256 _extraLimit) external onlyOwner {\r\n        emit SetExtraLimit(_extraLimit);\r\n        extraLimit = _extraLimit;\r\n    }\r\n\r\n    function convert(Token _from, Token _to, uint256 _amount, uint256 _minReturn) external payable returns (uint256) {\r\n        (TokenConverter converter, uint256 evaluated) = _getBestConverter(_from, _to, _amount);\r\n\r\n        if (_from == ETH_ADDRESS) {\r\n            require(msg.value == _amount, \"ETH not enought\");\r\n        } else {\r\n            require(msg.value == 0, \"ETH not required\");\r\n            require(_from.transferFrom(msg.sender, this, _amount), \"Error pulling Token amount\");\r\n            require(_from.approve(converter, _amount), \"Error approving token transfer\");\r\n        }\r\n\r\n        uint256 result = converter.convert.value(msg.value)(_from, _to, _amount, _minReturn);\r\n        require(result >= _minReturn, \"Funds received below min return\");\r\n\r\n        emit Converted({\r\n            _converter: converter,\r\n            _from: _from,\r\n            _to: _to,\r\n            _amount: _amount,\r\n            _return: result,\r\n            _evaluated: evaluated\r\n        });\r\n\r\n        if (_from != ETH_ADDRESS) {\r\n            require(_from.approve(converter, 0), \"Error removing approve\");\r\n        }\r\n\r\n        if (_to == ETH_ADDRESS) {\r\n            msg.sender.transfer(result);\r\n        } else {\r\n            require(_to.transfer(msg.sender, result), \"Error sending tokens\");\r\n        }\r\n\r\n        if (_isSimulation()) {\r\n            // this is a simulation, we need a pessimistic simulation we add\r\n            // the extraLimit. reasons: this algorithm is not deterministic\r\n            // different gas depending on the best route (Kyber, Bancor, etc)\r\n            _addExtraGasLimit();\r\n        }\r\n    }\r\n\r\n    function getReturn(Token _from, Token _to, uint256 _amount) external view returns (uint256) {\r\n        (TokenConverter best, ) = _getBestConverter(_from, _to, _amount);\r\n        return best.getReturn(_from, _to, _amount);\r\n    }\r\n\r\n    function _isSimulation() internal view returns (bool) {\r\n        return gasleft() > block.gaslimit;\r\n    }\r\n    \r\n    function _addExtraGasLimit() internal view {\r\n        uint256 limit;\r\n        uint256 startGas;\r\n        while (limit < extraLimit) {          \r\n            startGas = gasleft();\r\n            assembly {\r\n                let x := mload(0x0)\r\n            }\r\n            limit += startGas - gasleft();\r\n        }\r\n    }\r\n\r\n    function _getBestConverter(Token _from, Token _to, uint256 _amount) internal view returns (TokenConverter, uint256) {\r\n        uint maxRate;\r\n        TokenConverter converter;\r\n        TokenConverter best;\r\n        uint length = converters.length;\r\n        uint256 evaluated;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            converter = converters[i];\r\n            if (_isAvailable(converter, _from, _to, _amount)) {\r\n                evaluated++;\r\n                uint newRate = converter.getReturn(_from, _to, _amount);\r\n                if (newRate > maxRate) {\r\n                    maxRate = newRate;\r\n                    best = converter;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (best, evaluated);\r\n    }\r\n\r\n    function _isAvailable(address converter, Token _from, Token _to, uint256 _amount) internal view returns (bool) {\r\n        AvailableProvider provider = availability[converter];\r\n        return provider != address(0) ? provider.isAvailable(_from, _to, _amount) : true;\r\n    }\r\n\r\n    function withdrawEther(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        emit WithdrawEth(_to, _amount);\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function withdrawTokens(\r\n        Token _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner returns (bool) {\r\n        emit WithdrawTokens(_token, _to, _amount);\r\n        return _token.transfer(_to, _amount);\r\n    }\r\n\r\n    function() external payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_extraLimit\",\"type\":\"uint256\"}],\"name\":\"setExtraLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConverters\",\"outputs\":[{\"name\":\"result\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"converters\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"addConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"removeConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"availability\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"setAvailableProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"AddedConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_evaluated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_return\",\"type\":\"uint256\"}],\"name\":\"Converted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"SetAvailableProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_extraLimit\",\"type\":\"uint256\"}],\"name\":\"SetExtraLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"RemovedConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"}]","ContractName":"TokenConverterRouter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dd2f93d2364abd72c2c62a2bac3e338e968fd5470952d58779f89f0880d08860"}]}