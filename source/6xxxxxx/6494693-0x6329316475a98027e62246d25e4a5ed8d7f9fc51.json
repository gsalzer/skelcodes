{"status":"1","message":"OK","result":[{"SourceCode":"contract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n  // mitigate short address attack\r\n  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\r\n  // TODO: doublecheck implication of >= compared to ==\r\n  modifier onlyPayloadSize(uint numWords) {\r\n     assert(msg.data.length >= numWords * 32 + 4);\r\n     _;\r\n  }\r\n}\r\ncontract Token { // ERC20 standard\r\n\t\tfunction balanceOf(address _owner) public  view returns (uint256 balance);\r\n\t\tfunction transfer(address _to, uint256 _value) public  returns (bool success);\r\n\t\tfunction transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\r\n\t\tfunction approve(address _spender, uint256 _value)  returns (bool success);\r\n\t\tfunction allowance(address _owner, address _spender) public  view returns (uint256 remaining);\r\n\t\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\t\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t}\t\r\ncontract STC is Token{\r\n\tPrice public currentPrice;\r\n\tuint256 public fundingEndTime;\r\n\taddress public fundWallet;\r\n\tfunction() payable {\r\n\t\t\trequire(tx.origin == msg.sender);\r\n\t\t\tbuyTo(msg.sender);\r\n\t}\r\n\tfunction buyTo(address participant) public payable; \r\n\tfunction icoDenominatorPrice() public view returns (uint256);\r\n\tstruct Price { // tokensPerEth\r\n\t\t\tuint256 numerator;\r\n\t\t\tuint256 denominator;\r\n\t}\r\n}\t\r\ncontract STCDR is Token{\r\n\t//function burnMyTokens(uint256 amountTokens);\r\n}\t\r\ncontract OwnerControl is SafeMath {\r\n\tbool public halted = false;\r\n\taddress public controlWallet;\t\r\n\t//event\r\n\tevent AddLiquidity(uint256 ethAmount);\r\n\tevent RemoveLiquidity(uint256 ethAmount);\r\n\t//modifier\r\n\tmodifier onlyControlWallet {\r\n\t\t\trequire(msg.sender == controlWallet);\r\n\t\t\t_;\r\n\t}\r\n\t// allow controlWallet  to add ether to contract\r\n\tfunction addLiquidity() external onlyControlWallet payable {\r\n\t\t\trequire(msg.value > 0);\r\n\t\t\tAddLiquidity(msg.value);\r\n\t}\r\n\t// allow controlWallet to remove ether from contract\r\n\tfunction removeLiquidity(uint256 amount) external onlyControlWallet {\r\n\t\t\trequire(amount <= this.balance);\r\n\t\t\tcontrolWallet.transfer(amount);\r\n\t\t\tRemoveLiquidity(amount);\r\n\t}\r\n\tfunction changeControlWallet(address newControlWallet) external onlyControlWallet {\r\n\t\t\trequire(newControlWallet != address(0));\r\n\t\t\tcontrolWallet = newControlWallet;\r\n\t}\r\n\tfunction halt() external onlyControlWallet {\r\n\t\t\thalted = true;\r\n\t}\r\n\tfunction unhalt() external onlyControlWallet {\r\n\t\t\thalted = false;\r\n\t}\r\n\tfunction claimTokens(address _token) external onlyControlWallet {\r\n\t\t\trequire(_token != address(0));\r\n\t\t\tToken token = Token(_token);\r\n\t\t\tuint256 balance = token.balanceOf(this);\r\n\t\t\ttoken.transfer(controlWallet, balance);\r\n\t}\r\n\t\r\n}\r\ncontract SWAP is OwnerControl {\r\n\tstring public name = \"SWAP STCDR-STC\";\t\r\n\tSTC public STCToken;\r\n\tSTCDR public STCDRToken;\r\n\tuint256 public discount = 5;\r\n\tuint256 public stcdr2stc_Ratio = 40;\r\n\t//event\r\n\t event TokenSwaped(address indexed _from,  uint256 _stcBuy, uint256 _stcBonus, uint256 _stcdrBurn, uint256 _ethPrice, uint256 _stcPrice);\r\n\t//modifier\r\n\t//Initialize\r\n\tfunction SWAP(address _STCToken,address _STCDRToken) public  {\r\n\t\t\tcontrolWallet = msg.sender;\r\n\t\t\tSTCToken = STC(_STCToken);\r\n\t\t\tSTCDRToken = STCDR(_STCDRToken);\r\n\t}\t\r\n\tfunction() payable {\r\n\t\t\trequire(tx.origin == msg.sender);\r\n\t\t\tbuyTo(msg.sender);\r\n\t}\r\n\tfunction transferTokensAfterEndTime(address participant, uint256 _tokens ,uint256 _tokenBonus , uint256 _tokensToBurn) private\r\n\t{\r\n\t\trequire(this.balance>=msg.value);\r\n\t\t//Check if STC token are available to transfer\r\n\t\trequire(availableSTCTokens() > safeAdd(_tokens,_tokenBonus));\r\n\t\t//Burn Tokens\t\t\r\n\t\tSTCDRToken.transferFrom(participant,this,_tokensToBurn);\r\n\t\tSTCDRToken.transfer(controlWallet, _tokensToBurn);\r\n\t\t//Transfer STC Tokens\r\n\t\tSTCToken.transferFrom(controlWallet,this,safeAdd(_tokens,_tokenBonus));\r\n\t\tSTCToken.transfer(participant, _tokens);\r\n\t\tSTCToken.transfer(participant, _tokenBonus);\r\n\t\t//TransferMoney\r\n\t\tSTCToken.fundWallet().transfer(msg.value);\r\n\t}\r\n\tfunction addEthBonusToBuy(address participant, uint256 _ethBonus , uint256 _tokensToBurn ) private {\r\n\t\t//Check If SWAP contract have enaf ether for this opertion\r\n\t\trequire(this.balance>=safeAdd(msg.value, _ethBonus));\t\r\n\t    //Burn Tokens\t\t\t\r\n\t\tSTCDRToken.transferFrom(participant,this,_tokensToBurn);\r\n\t\tSTCDRToken.transfer(controlWallet, _tokensToBurn);\r\n\t\t//Forward Etherium in to STC contract\r\n\t\tSTCToken.buyTo.value(safeAdd(msg.value, _ethBonus))(participant);\r\n\t}\r\n\tfunction buyTo(address participant) public payable {\r\n\t\trequire(!halted);\t\t\r\n\t\trequire(msg.value > 0);\r\n\t\t\r\n\t\t//Get STCDR tokens that can be transfer and burn\r\n\t\tuint256 availableTokenSTCDR = availableSTCDRTokensOF(participant);\r\n\t\trequire(availableTokenSTCDR > 0);\r\n\t\t//Last ETH-USD price\r\n\t\tuint256 _numerator = currentETHPrice();\r\n\t\trequire(_numerator > 0);\r\n\t\t//GetEnd Time\r\n\t\tuint256 _fundingEndTime = STCToken.fundingEndTime();\r\n\t\t//STC Denominator price\r\n\t\tuint256 _denominator = currentSTCPrice();\t\r\n\t\trequire(_denominator > 0);\t\r\n\t\t//Max STC that can be as used to callculated bonus\r\n\t\tuint256 _stcMaxBonus = safeMul(availableTokenSTCDR,10000000000) / stcdr2stc_Ratio; //stcMaxBonus(availableTokenSTCDR);\r\n\t\trequire(_stcMaxBonus > 0);\r\n\t\t//Calculated STC that user buy for ETH\r\n\t\tuint256 _stcOrginalBuy = safeMul(msg.value,_numerator) / _denominator; //stcOrginalBuy(msg.value);\t\r\n\t\trequire(_stcOrginalBuy > 0);\r\n\t\t\r\n\t\tuint256 _tokensToBurn =0 ;\r\n\t\tuint256 _tokensBonus =0 ;\r\n\t\tif (_stcOrginalBuy >= _stcMaxBonus){\r\n\t\t\t_tokensToBurn =  availableTokenSTCDR;\r\n\t\t\t_tokensBonus= safeSub(safeMul((_stcMaxBonus / safeSub(100,discount)),100),_stcMaxBonus); //safeMul(_stcMaxBonus,discount)/100;\r\n\t\t} else {\r\n\t\t\t_tokensToBurn = safeMul(_stcOrginalBuy,stcdr2stc_Ratio)/10000000000;\t\r\n\t\t\t_tokensBonus =  safeSub(safeMul((_stcOrginalBuy / safeSub(100,discount)),100),_stcOrginalBuy);  // safeMul(_stcOrginalBuy,discount)/100;\t\t\t\t\t\r\n\t\t} \r\n\t\trequire(_tokensToBurn > 0);\r\n\t\trequire(_tokensBonus > 0);\r\n\t\trequire(_tokensBonus < _stcOrginalBuy);\r\n\t\t\r\n\t\tif (now < _fundingEndTime) {\r\n\t\t\t//Method 1 Before End Date\r\n\t\t\t//Convert Token in to EthValue\r\n\t\t\tuint256 _ethBonus=safeMul(_tokensBonus, _denominator) / _numerator ;\r\n\t\t\taddEthBonusToBuy(participant,_ethBonus,_tokensToBurn);\r\n\t\t//----\t\r\n\t\t} else {\r\n\t\t\t//Method 2\r\n\t\t\ttransferTokensAfterEndTime(participant,_stcOrginalBuy,_tokensBonus ,_tokensToBurn);\r\n\t\t\t//----\r\n\t\t}\r\n\r\n\tTokenSwaped(participant,  _stcOrginalBuy , _tokensBonus,_tokensToBurn, _numerator ,_denominator);\r\n\t}\t\r\n\tfunction currentETHPrice() public view returns (uint256 numerator)\r\n\t{\r\n\t\tvar (a, b) = STCToken.currentPrice();\r\n\t\treturn STC.Price(a, b).numerator;\r\n\t}\t\r\n\tfunction currentSTCPrice() public view returns (uint256 numerator)\r\n\t{\r\n\t\treturn STCToken.icoDenominatorPrice();\r\n\t}\r\n\t//Information Tokens Transfered to control wallet for burn.\r\n\tfunction tokenSTCDRforBurnInControlWallett() view returns (uint256 numerator) {\r\n\t\treturn  STCDRToken.balanceOf(controlWallet);\r\n\t}\r\n\t//Information STCDR allowed for user to burn\r\n\tfunction availableSTCDRTokensOF(address _owner) view returns (uint256 numerator) {\r\n\t\tuint256 alowedTokenSTCDR = STCDRToken.allowance(_owner, this);\r\n\t\tuint256 balanceTokenSTCDR = STCDRToken.balanceOf(_owner);\r\n\t\tif (alowedTokenSTCDR>balanceTokenSTCDR) {\r\n\t\t\treturn balanceTokenSTCDR;\t\r\n\t\t} else {\r\n\t\t\treturn alowedTokenSTCDR;\r\n\t\t}\r\n\t}\r\n\t//Information available STC tokens to assign after fundenttime when user use STCDR\r\n\tfunction availableSTCTokens() view returns (uint256 numerator) {\r\n\t\tuint256 alowedTokenSTC = STCToken.allowance(controlWallet, this);\r\n\t\tuint256 balanceTokenSTC = STCToken.balanceOf(controlWallet);\r\n\t\tif (alowedTokenSTC>balanceTokenSTC) {\r\n\t\t\treturn balanceTokenSTC;\t\r\n\t\t} else {\r\n\t\t\treturn alowedTokenSTC;\r\n\t\t}\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSTCTokens\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newControlWallet\",\"type\":\"address\"}],\"name\":\"changeControlWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"availableSTCDRTokensOF\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STCToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSTCDRforBurnInControlWallett\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controlWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSTCPrice\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stcdr2stc_Ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"buyTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STCDRToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentETHPrice\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_STCToken\",\"type\":\"address\"},{\"name\":\"_STCDRToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_stcBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stcBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stcdrBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ethPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stcPrice\",\"type\":\"uint256\"}],\"name\":\"TokenSwaped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"}]","ContractName":"SWAP","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000083dc8423170e95ee18b770bbdd6b3becb73c9c300000000000000000000000008d2da938d6f717eb5d84f68bb0eca7584c8faf2a","Library":"","SwarmSource":"bzzr://967dc0ff26267e8ca4064f79c8d0969dcf116fe166e9e1dd8ddafbf0cd4ad723"}]}