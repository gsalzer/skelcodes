{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * SuperFOMO - зарабатывай до 11,5% в сутки!\r\n *\r\n * Мин. размер депозита 0.05 eth\r\n * Мин. размер депозита для участия в розыгрыше джек-пота: 1eth\r\n *\r\n * Схема распределения входящих средств:\r\n * 100% на выплаты участникам\r\n *\r\n * ИНВЕСТИЦИОННЫЙ ПЛАН:\r\n * чем позже зашел - тем больше заработал!\r\n *\r\n * Каждый депозит работает отдельно до своего удвоения\r\n *\r\n * Депозиты сделанные в период с 1 по 12 день жизни контракта: 2,5% в день\r\n * Депозиты сделанные в период с 12 по 18 день жизни контракта: 3,5% в день\r\n * Депозиты сделанные в период с 18 по 24 день жизни контракта: 4,5% в день\r\n * Депозиты сделанные в период с 24 по 30 день жизни контракта: 5,5% в день\r\n * Депозиты сделанные в период с 30 по 36 день жизни контракта: 6,5% в день\r\n * Депозиты сделанные в период с 36 по 42 день жизни контракта: 7,5% в день\r\n * Депозиты сделанные в период с 42 по 48 день жизни контракта: 8,5% в день\r\n * Депозиты сделанные в период с 48 по 54 день жизни контракта: 9,5% в день\r\n * Депозиты сделанные в период с 54 дня жизни контракта: 10% в день\r\n *\r\n * БОНУС ХОЛДЕРАМ:\r\n * Тем, кто не заказывает вывод процентов в течение 48 часов включается бонус на все депозиты +1,5% в сутки каждый день.\r\n *\r\n * ДЖЕК-ПОТ:\r\n * С каждого депозита 3% \"замораживается\" на балансе контракта в фонд джек-пота.\r\n *\r\n * Условия розыгрыша:\r\n * При отсутствии новых депозитов (от 1 eth и более) более 24 часов фонд джек-пота распределяется между последними 5 вкладчиками с депозитом 1 eth и более.\r\n * 60% джек-пота начисляются для вывода последнему вкладчику и по 10% еще 4м вкладчикам с депозитами от  1 eth и более.\r\n * После розыгрыша джек-пот начинает накапливаться заново.\r\n *\r\n * Партнерская программа:\r\n * Для участия в партнерской программе у вас должен быть свой депозит, по которому вы получаете начисления.\r\n * Для получения вознаграждения ваш приглашенный должен указать адрес вашего кошелька eth в поле data.\r\n *\r\n * Бонус приглашенному: вносимый депозит увечивается на 2%\r\n * Бонус пригласителю: автоматически выплачивается 5% от суммы пополнения\r\n *\r\n * ИНСТРУКЦИЯ:\r\n * *  1. Отправить eth (больше 0.05) для создания депозита.\r\n * *  2. Для получения выплаты по всем депозитам необходимо отправить от 0 до 0,05 eth на адрес смарт контракта, счетчик холда при это сбрасывается.\r\n * *  3. Если отправлено 0,05 или более eth создается новый депозит, но начисленные проценты не выплачиваются и счетчик холда не сбрасывается. С каждой выплаты 12% отправляется на рекламу и 3% на тех. поддержку проекта.\r\n *\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Storage {\r\n\r\n    address private owner;\r\n\r\n    mapping (address => Investor) investors;\r\n\r\n    struct Investor {\r\n        uint index;\r\n        mapping (uint => uint) deposit;\r\n        mapping (uint => uint) interest;\r\n        mapping (uint => uint) withdrawals;\r\n        mapping (uint => uint) start;\r\n        uint checkpoint;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function updateInfo(address _address, uint _value, uint _interest) external onlyOwner {\r\n        investors[_address].deposit[investors[_address].index] += _value;\r\n        investors[_address].start[investors[_address].index] = block.timestamp;\r\n        investors[_address].interest[investors[_address].index] = _interest;\r\n    }\r\n\r\n    function updateCheckpoint(address _address) external onlyOwner {\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function updateWithdrawals(address _address, uint _index, uint _withdrawal) external onlyOwner {\r\n        investors[_address].withdrawals[_index] += _withdrawal;\r\n    }\r\n\r\n    function updateIndex(address _address) external onlyOwner {\r\n        investors[_address].index += 1;\r\n    }\r\n\r\n    function ind(address _address) external view returns(uint) {\r\n        return investors[_address].index;\r\n    }\r\n\r\n    function d(address _address, uint _index) external view returns(uint) {\r\n        return investors[_address].deposit[_index];\r\n    }\r\n\r\n    function i(address _address, uint _index) external view returns(uint) {\r\n        return investors[_address].interest[_index];\r\n    }\r\n\r\n    function w(address _address, uint _index) external view returns(uint) {\r\n        return investors[_address].withdrawals[_index];\r\n    }\r\n\r\n    function s(address _address, uint _index) external view returns(uint) {\r\n        return investors[_address].start[_index];\r\n    }\r\n\r\n    function c(address _address) external view returns(uint) {\r\n        return investors[_address].checkpoint;\r\n    }\r\n}\r\n\r\ncontract SuperFOMO {\r\n    using SafeMath for uint;\r\n\r\n    address public owner;\r\n    address advertising;\r\n    address techsupport;\r\n\r\n    uint waveStartUp;\r\n    uint jackPot;\r\n    uint lastLeader;\r\n\r\n    address[] top;\r\n\r\n    Storage x;\r\n\r\n    event LogInvestment(address indexed _addr, uint _value);\r\n    event LogPayment(address indexed _addr, uint _value);\r\n    event LogReferralInvestment(address indexed _referrer, address indexed _referral, uint _value);\r\n    event LogGift(address _firstAddr, address _secondAddr, address _thirdAddr, address _fourthAddr, address _fifthAddr);\r\n    event LogNewWave(uint _waveStartUp);\r\n    event LogNewLeader(address _leader);\r\n\r\n    modifier notOnPause() {\r\n        require(waveStartUp <= block.timestamp);\r\n        _;\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        address addr = msg.sender;\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size <= 0);\r\n        _;\r\n    }\r\n\r\n    constructor(address _advertising, address _techsupport) public {\r\n        owner = msg.sender;\r\n        advertising = _advertising;\r\n        techsupport = _techsupport;\r\n        waveStartUp = block.timestamp;\r\n        x = new Storage();\r\n    }\r\n\r\n    function renounceOwnership() external {\r\n        require(msg.sender == owner);\r\n        owner = 0x0;\r\n    }\r\n\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {\r\n        assembly {\r\n            parsedreferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedreferrer;\r\n    }\r\n\r\n    function setRef() internal returns(uint) {\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\n        if (_referrer != msg.sender && getDividends(_referrer) > 0) {\r\n            _referrer.transfer(msg.value / 20);\r\n\r\n            emit LogReferralInvestment(_referrer, msg.sender, msg.value);\r\n            return(msg.value / 50);\r\n        } else {\r\n            advertising.transfer(msg.value / 20);\r\n            return(0);\r\n        }\r\n    }\r\n\r\n    function getInterest() public view returns(uint) {\r\n        uint multiplier = (block.timestamp.sub(waveStartUp)) / 6 days;\r\n        if (multiplier == 0) {\r\n            return 25;\r\n        }\r\n        if (multiplier <= 8){\r\n            return(15 + (multiplier * 10));\r\n        } else {\r\n            return 100;\r\n        }\r\n    }\r\n\r\n    function toTheTop() internal {\r\n        top.push(msg.sender);\r\n        lastLeader = block.timestamp;\r\n\r\n        emit LogNewLeader(msg.sender);\r\n    }\r\n\r\n    function payDay() internal {\r\n        top[top.length - 1].transfer(jackPot * 3 / 5);\r\n        top[top.length - 2].transfer(jackPot / 10);\r\n        top[top.length - 3].transfer(jackPot / 10);\r\n        top[top.length - 4].transfer(jackPot / 10);\r\n        top[top.length - 5].transfer(jackPot / 10);\r\n        jackPot = 0;\r\n        lastLeader = block.timestamp;\r\n        emit LogGift(top[top.length - 1], top[top.length - 2], top[top.length - 3], top[top.length - 4], top[top.length - 5]);\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value < 50000000000000000) {\r\n            msg.sender.transfer(msg.value);\r\n            withdraw();\r\n        } else {\r\n            invest();\r\n        }\r\n    }\r\n\r\n    function invest() public payable notOnPause notFromContract {\r\n\r\n        require(msg.value >= 0.05 ether);\r\n        jackPot += msg.value * 3 / 100;\r\n\r\n        if (x.d(msg.sender, 0) > 0) {\r\n            x.updateIndex(msg.sender);\r\n        } else {\r\n            x.updateCheckpoint(msg.sender);\r\n        }\r\n\r\n        if (msg.data.length == 20) {\r\n            uint addend = setRef();\r\n        } else {\r\n            advertising.transfer(msg.value / 20);\r\n        }\r\n\r\n        x.updateInfo(msg.sender, msg.value + addend, getInterest());\r\n\r\n\r\n        if (msg.value >= 1 ether) {\r\n            toTheTop();\r\n        }\r\n\r\n        emit LogInvestment(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw() public {\r\n\r\n        uint _payout;\r\n\r\n        uint _multiplier;\r\n\r\n        if (block.timestamp > x.c(msg.sender) + 2 days) {\r\n            _multiplier = 1;\r\n        }\r\n\r\n        for (uint i = 0; i <= x.ind(msg.sender); i++) {\r\n            if (x.w(msg.sender, i) < x.d(msg.sender, i) * 2) {\r\n                if (x.s(msg.sender, i) <= x.c(msg.sender)) {\r\n                    uint dividends = (x.d(msg.sender, i).mul(_multiplier.mul(15).add(x.i(msg.sender, i))).div(1000)).mul(block.timestamp.sub(x.c(msg.sender).add(_multiplier.mul(2 days)))).div(1 days);\r\n                    dividends = dividends.add(x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000).mul(_multiplier).mul(2));\r\n                    if (x.w(msg.sender, i) + dividends <= x.d(msg.sender, i) * 2) {\r\n                        x.updateWithdrawals(msg.sender, i, dividends);\r\n                        _payout = _payout.add(dividends);\r\n                    } else {\r\n                        _payout = _payout.add((x.d(msg.sender, i).mul(2)).sub(x.w(msg.sender, i)));\r\n                        x.updateWithdrawals(msg.sender, i, x.d(msg.sender, i) * 2);\r\n                    }\r\n                } else {\r\n                    if (x.s(msg.sender, i) + 2 days >= block.timestamp) {\r\n                        dividends = (x.d(msg.sender, i).mul(_multiplier.mul(15).add(x.i(msg.sender, i))).div(1000)).mul(block.timestamp.sub(x.s(msg.sender, i).add(_multiplier.mul(2 days)))).div(1 days);\r\n                        dividends = dividends.add(x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000).mul(_multiplier).mul(2));\r\n                        if (x.w(msg.sender, i) + dividends <= x.d(msg.sender, i) * 2) {\r\n                            x.updateWithdrawals(msg.sender, i, dividends);\r\n                            _payout = _payout.add(dividends);\r\n                        } else {\r\n                            _payout = _payout.add((x.d(msg.sender, i).mul(2)).sub(x.w(msg.sender, i)));\r\n                            x.updateWithdrawals(msg.sender, i, x.d(msg.sender, i) * 2);\r\n                        }\r\n                    } else {\r\n                        dividends = (x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000)).mul(block.timestamp.sub(x.s(msg.sender, i))).div(1 days);\r\n                        x.updateWithdrawals(msg.sender, i, dividends);\r\n                        _payout = _payout.add(dividends);\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        if (_payout > 0) {\r\n            if (_payout > address(this).balance && address(this).balance <= 0.1 ether) {\r\n                nextWave();\r\n                return;\r\n            }\r\n            x.updateCheckpoint(msg.sender);\r\n            advertising.transfer(_payout * 3 / 25);\r\n            techsupport.transfer(_payout * 3 / 100);\r\n            msg.sender.transfer(_payout * 17 / 20);\r\n\r\n            emit LogPayment(msg.sender, _payout * 17 / 20);\r\n        }\r\n\r\n        if (block.timestamp >= lastLeader + 1 days && top.length >= 5) {\r\n            payDay();\r\n        }\r\n    }\r\n\r\n    function nextWave() private {\r\n        top.length = 0;\r\n        x = new Storage();\r\n        waveStartUp = block.timestamp + 10 days;\r\n        emit LogNewWave(waveStartUp);\r\n    }\r\n\r\n    function getDeposits(address _address) public view returns(uint Invested) {\r\n        uint _sum;\r\n        for (uint i = 0; i <= x.ind(_address); i++) {\r\n            if (x.w(_address, i) < x.d(_address, i) * 2) {\r\n                _sum += x.d(_address, i);\r\n            }\r\n        }\r\n        Invested = _sum;\r\n    }\r\n\r\n    function getDepositN(address _address, uint _number) public view returns(uint Deposit_N) {\r\n        if (x.w(_address, _number - 1) < x.d(_address, _number - 1) * 2) {\r\n            Deposit_N = x.d(_address, _number - 1);\r\n        } else {\r\n            Deposit_N = 0;\r\n        }\r\n    }\r\n\r\n    function getDividends(address _address) public view returns(uint Dividends) {\r\n\r\n        uint _payout;\r\n        uint _multiplier;\r\n\r\n        if (block.timestamp > x.c(_address) + 2 days) {\r\n            _multiplier = 1;\r\n        }\r\n\r\n        for (uint i = 0; i <= x.ind(_address); i++) {\r\n            if (x.w(_address, i) < x.d(_address, i) * 2) {\r\n                if (x.s(_address, i) <= x.c(_address)) {\r\n                    uint dividends = (x.d(_address, i).mul(_multiplier.mul(15).add(x.i(_address, i))).div(1000)).mul(block.timestamp.sub(x.c(_address).add(_multiplier.mul(2 days)))).div(1 days);\r\n                    dividends += (x.d(_address, i).mul(x.i(_address, i)).div(1000).mul(_multiplier).mul(2));\r\n                    if (x.w(_address, i) + dividends <= x.d(_address, i) * 2) {\r\n                        _payout = _payout.add(dividends);\r\n                    } else {\r\n                        _payout = _payout.add((x.d(_address, i).mul(2)).sub(x.w(_address, i)));\r\n                    }\r\n                } else {\r\n                    if (x.s(_address, i) + 2 days >= block.timestamp) {\r\n                        dividends = (x.d(_address, i).mul(_multiplier.mul(15).add(x.i(_address, i))).div(1000)).mul(block.timestamp.sub(x.s(_address, i).add(_multiplier.mul(2 days)))).div(1 days);\r\n                        dividends += (x.d(_address, i).mul(x.i(_address, i)).div(1000).mul(_multiplier).mul(2));\r\n                        if (x.w(_address, i) + dividends <= x.d(_address, i) * 2) {\r\n                            _payout = _payout.add(dividends);\r\n                        } else {\r\n                            _payout = _payout.add((x.d(_address, i).mul(2)).sub(x.w(_address, i)));\r\n                        }\r\n                    } else {\r\n                        dividends = (x.d(_address, i).mul(x.i(_address, i)).div(1000)).mul(block.timestamp.sub(x.s(_address, i))).div(1 days);\r\n                        _payout = _payout.add(dividends);\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        Dividends = _payout * 17 / 20;\r\n    }\r\n\r\n    function getWithdrawals(address _address) external view returns(uint) {\r\n        uint _sum;\r\n        for (uint i = 0; i <= x.ind(_address); i++) {\r\n            _sum += x.w(_address, i);\r\n        }\r\n        return(_sum);\r\n    }\r\n\r\n    function getTop() external view returns(address, address, address, address, address) {\r\n        return(top[top.length - 1], top[top.length - 2], top[top.length - 3], top[top.length - 4], top[top.length - 5]);\r\n    }\r\n\r\n    function getJackPot() external view returns(uint) {\r\n        return(jackPot);\r\n    }\r\n\r\n    function getNextPayDay() external view returns(uint) {\r\n        return(lastLeader + 1 days);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDividends\",\"outputs\":[{\"name\":\"Dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextPayDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"name\":\"Invested\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getDepositN\",\"outputs\":[{\"name\":\"Deposit_N\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJackPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_advertising\",\"type\":\"address\"},{\"name\":\"_techsupport\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogReferralInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_firstAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_secondAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_thirdAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fourthAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fifthAddr\",\"type\":\"address\"}],\"name\":\"LogGift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_waveStartUp\",\"type\":\"uint256\"}],\"name\":\"LogNewWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_leader\",\"type\":\"address\"}],\"name\":\"LogNewLeader\",\"type\":\"event\"}]","ContractName":"SuperFOMO","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008359e94ff790a642551a550c1ef9c0ac6adee68b000000000000000000000000ba2b9b096afb16d8d9b450c57b8ca6ba5f4b5d44","Library":"","SwarmSource":"bzzr://8a6154ae665687a9fe161e469c255d9338322b0a040a674b798976d5749cf37f"}]}