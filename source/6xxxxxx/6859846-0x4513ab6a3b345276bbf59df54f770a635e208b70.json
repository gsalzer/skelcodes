{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract FiftyFifty{\r\n    using SafeMath for uint; // using SafeMath\r\n    //rate to 0.125 ETH.  0.125:1, 0.250:2, 0.500:4, 1.00:8, 2.00:16, 4.00:32, 8.00: 64, 16.00:128, 32.00:256, 64.00:512\r\n    uint[11] betValues = [0.125 ether, 0.250 ether, 0.500 ether, 1.00 ether, 2.00 ether, 4.00 ether, 8.00 ether, 16.00 ether, 32.00 ether, 64.00 ether];\r\n    // return value is 95 % of two people.\r\n    uint[11] returnValues = [0.2375 ether, 0.475 ether, 0.950 ether, 1.90 ether, 3.80 ether, 7.60 ether, 15.20 ether, 30.40 ether, 60.80 ether, 121.60 ether];\r\n    // jackpot value is 4 % of total value\r\n    uint[11] jackpotValues = [0.05 ether, 0.010 ether, 0.020 ether, 0.04 ether, 0.08 ether, 0.16 ether, 0.32 ether, 0.64 ether, 1.28 ether, 2.56 ether];\r\n    // fee 1 %\r\n    uint[11] fees = [0.0025 ether, 0.005 ether, 0.010 ether, 0.020 ether, 0.040 ether, 0.080 ether, 0.16 ether, 0.32 ether, 0.64 ether, 1.28 ether];\r\n    uint roundNumber; // number of round that jackpot is paid\r\n    mapping(uint => uint) jackpot;\r\n    //round -> betValue -> user address\r\n    mapping(uint => mapping(uint => address[])) roundToBetValueToUsers;\r\n    //round -> betValue -> totalBet\r\n    mapping(uint => mapping(uint => uint)) roundToBetValueToTotalBet;\r\n    //round -> totalBet\r\n    mapping(uint => uint) public roundToTotalBet;\r\n    // current user who bet for the value\r\n    mapping(uint => address) currentUser;\r\n    address owner;\r\n    uint ownerDeposit;\r\n\r\n    // Event\r\n    event Jackpot(address indexed _user, uint _value, uint indexed _round, uint _now);\r\n    event Bet(address indexed _winner,address indexed _user,uint _bet, uint _payBack, uint _now);\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        roundNumber = 1;\r\n    }\r\n\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) external onlyOwner{\r\n        owner = _owner;\r\n    }\r\n\r\n    // fallback function that\r\n\r\n    function() public payable {\r\n        // check if msg.value is equal to specified amount of value.\r\n        uint valueNumber = checkValue(msg.value);\r\n        /**\r\n            jackpot starts when block hash % 10000 < 0\r\n        */\r\n        uint randJackpot = (uint(blockhash(block.number - 1)) + roundNumber) % 10000;\r\n        if(jackpot[roundNumber] != 0 && randJackpot <= 1){\r\n            // Random number that is under contract total bet amount\r\n            uint randJackpotBetValue = uint(blockhash(block.number - 1)) % roundToTotalBet[roundNumber];\r\n            //betNum\r\n            uint betNum=0;\r\n            uint addBetValue = 0;\r\n            // Loop until addBetValue exceeds randJackpotBetValue\r\n            while(randJackpotBetValue > addBetValue){\r\n                // Select bet number which is equal to\r\n                addBetValue += roundToBetValueToTotalBet[roundNumber][betNum];\r\n                betNum++;\r\n            }\r\n            //  betNum.sub(1)のindexに含まれているuserの数未満のランダム番号を生成する\r\n            uint randJackpotUser = uint(blockhash(block.number - 1)) % roundToBetValueToUsers[roundNumber][betNum.sub(1)].length;\r\n            address user = roundToBetValueToUsers[roundNumber][valueNumber][randJackpotUser];\r\n            uint jp = jackpot[roundNumber];\r\n            user.transfer(jp);\r\n            emit Jackpot(user, jp, roundNumber, now);\r\n            roundNumber = roundNumber.add(1);\r\n        }\r\n        if(currentUser[valueNumber] == address(0)){\r\n            //when current user does not exists\r\n            currentUser[valueNumber] = msg.sender;\r\n            emit Bet(address(0), msg.sender, betValues[valueNumber], 0, now);\r\n        }else{\r\n            // when current user exists\r\n            uint rand = uint(blockhash(block.number-1)) % 2;\r\n            ownerDeposit = ownerDeposit.add(fees[valueNumber]);\r\n            if(rand == 0){\r\n                // When the first user win\r\n                currentUser[valueNumber].transfer(returnValues[valueNumber]);\r\n                emit Bet(currentUser[valueNumber], msg.sender, betValues[valueNumber], returnValues[valueNumber], now);\r\n            }else{\r\n                // When the last user win\r\n                msg.sender.transfer(returnValues[valueNumber]);\r\n                emit Bet(msg.sender, msg.sender, betValues[valueNumber], returnValues[valueNumber], now);\r\n            }\r\n            // delete current user\r\n            delete currentUser[valueNumber];\r\n        }\r\n        // common in each contracts\r\n        jackpot[roundNumber] = jackpot[roundNumber].add(jackpotValues[valueNumber]);\r\n        roundToBetValueToUsers[roundNumber][valueNumber].push(currentUser[valueNumber]);\r\n        roundToTotalBet[roundNumber] = roundToTotalBet[roundNumber].add(betValues[valueNumber]);\r\n        roundToBetValueToTotalBet[roundNumber][valueNumber] = roundToBetValueToTotalBet[roundNumber][valueNumber].add(betValues[valueNumber]);\r\n    }\r\n\r\n    /**\r\n        @param sendValue is ETH that is sent to this contract.\r\n        @return num is index that represent value that is sent.\r\n    */\r\n    function checkValue(uint sendValue) internal view returns(uint) {\r\n        /**\r\n            Check sendValue is match prepared values. Revert if sendValue doesn't match any values.\r\n        */\r\n        uint num = 0;\r\n        while (sendValue != betValues[num]){\r\n            if(num == 11){\r\n                revert();\r\n            }\r\n            num++;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    function roundToBetValueToUsersLength(uint _roundNum, uint _betNum) public view returns(uint){\r\n        return roundToBetValueToUsers[_roundNum][_betNum].length;\r\n    }\r\n\r\n    function withdrawDeposit() public onlyOwner{\r\n        owner.transfer(ownerDeposit);\r\n        ownerDeposit = 0;\r\n    }\r\n\r\n    function currentJackpot() public view  returns(uint){\r\n        return jackpot[roundNumber];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundNum\",\"type\":\"uint256\"},{\"name\":\"_betNum\",\"type\":\"uint256\"}],\"name\":\"roundToBetValueToUsersLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundToTotalBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"Jackpot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_payBack\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"}]","ContractName":"FiftyFifty","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1935be59c9b39d196b4761347109992cffbf2872e147e1ca830c89f283ee1c6d"}]}