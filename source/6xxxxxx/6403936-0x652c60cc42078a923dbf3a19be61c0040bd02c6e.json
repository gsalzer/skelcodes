{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// *-----------------------------------------------------------------------*\r\n//       __ _    ________   __________  _____   __\r\n//      / /| |  / / ____/  / ____/ __ \\/  _/ | / /\r\n//     / / | | / / __/    / /   / / / // //  |/ / \r\n//    / /__| |/ / /___   / /___/ /_/ // // /|  /  \r\n//   /_____/___/_____/   \\____/\\____/___/_/ |_/  \r\n// *-----------------------------------------------------------------------*\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n    \r\n    // _from: oldOwner _to: newOwner\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Modifier onlyOwner\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"\");\r\n        _;\r\n    }\r\n\r\n    // Transfer owner\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused {\r\n        require(!paused, \"\");\r\n        _;\r\n    }\r\n    modifier whenPaused {\r\n        require(paused, \"\");\r\n        _;\r\n    }\r\n\r\n    // Pause contract\r\n    function pause() public onlyOwner whenNotPaused returns (bool) {\r\n        paused = true;\r\n        emit Pause();\r\n        return true;\r\n    }\r\n\r\n    // Unpause contract\r\n    function unpause() public onlyOwner whenPaused returns (bool) {\r\n        paused = false;\r\n        emit Unpause();\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface LVECoin {\r\n    function transfer(address _to, uint256 _value) external returns(bool);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title FoundingTeam\r\n */\r\ncontract FoundingTeam is Pausable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // token contract\r\n    LVECoin private tokenContract;\r\n    // token issue all amount\r\n    uint256 private totalToken              = 2000000000 * (10 ** 18);\r\n    // token supply amount\r\n    uint256 public  tokenSupplyQuota        = totalToken.mul(50).div(1000);\r\n    // lock end time\r\n    uint256 public tokenLockEndTime;\r\n    // alreary sold token\r\n    uint256 public tokensSold               = 0;\r\n\r\n\r\n    // Investor list\r\n    struct Investor{\r\n        uint256 endTime;        // token locked end time\r\n        address addr;           // locked address\r\n        bool isLocked;          // is lock address\r\n        uint256 lockAmount;     // locked token amount\r\n        uint256 investAmount;   // invest token amount\r\n    }\r\n    // investor mapping\r\n    mapping(address => Investor) public investorMap;\r\n    // freeze account mapping\r\n    mapping(address => bool) public freezeAccountMap;\r\n    // investor address list\r\n    address[] public investorsList;\r\n\r\n    // _to: _locker\r\n    event Lock(address indexed _to, uint256 _amount, uint _endTime);\r\n    // _to: _unlocker\r\n    event UnLock(address indexed _to, uint256 _amount);\r\n     // _to: _freezeAddr\r\n    event Freeze(address indexed _to);\r\n    // _to: _unfreezeAddr\r\n    event Unfreeze(address indexed _to);\r\n    event WithdrawalToken(address indexed _to, uint256 _amount);\r\n    event WithdrawalEther(address indexed _to, uint256 _amount);\r\n\r\n    constructor(address _tokenAddr, uint256 _tokenLockEndTime) public{\r\n        require(_tokenAddr != address(0), \"\");\r\n        require(_tokenLockEndTime > now, \"\");\r\n        tokenLockEndTime = _tokenLockEndTime;\r\n        tokenContract = LVECoin(_tokenAddr);\r\n    }\r\n\r\n    \r\n    // is token on sale\r\n    modifier isOnSale() {\r\n        // 供給總Token額度 > 目前已售出token數量 => true, 販售中\r\n        require(tokenSupplyQuota > tokensSold, \"\");\r\n        _;\r\n    }\r\n    // is freezeable account\r\n    modifier freezeable(address _addr) {\r\n        require(_addr != address(0), \"\");\r\n        require(!freezeAccountMap[_addr], \"\");\r\n        _;\r\n    }\r\n\r\n\r\n    // get contract own token amount\r\n    function getContractTokenBalance() public view returns(uint256 _rContractTokenAmount){\r\n        return tokenContract.balanceOf(address(this));\r\n    }\r\n\r\n   \r\n    // transfer token and lock\r\n    function transferTokenAndLock(address _beneficiary, uint256 _amount) public onlyOwner isOnSale freezeable(_beneficiary){\r\n        require(_beneficiary != address(0), \"\");\r\n        // 目前已售出token數量\r\n        tokensSold = tokensSold.add(_amount);\r\n        // 判斷是否有超過總供給Token額度\r\n        require(tokenSupplyQuota >= tokensSold, \"\");\r\n        // add investor token locktime\r\n        addlockAccount(_beneficiary, tokenLockEndTime, _amount);\r\n    }\r\n\r\n\r\n    // locked warehouse function \r\n    function addlockAccount(address _lockAddr, uint256 _endTime, uint256 _lockAmount) internal returns(bool){\r\n        require(_lockAddr != address(0), \"\");\r\n        require(_endTime >= now, \"\");\r\n        require(_lockAmount > 0, \"\");\r\n        if(investorMap[_lockAddr].addr != _lockAddr){\r\n            investorsList.push(_lockAddr);\r\n        }\r\n        Investor memory investor;\r\n        investor.endTime = _endTime;\r\n        investor.addr = _lockAddr;\r\n        investor.isLocked = true;\r\n        investor.lockAmount = investorMap[_lockAddr].lockAmount.add(_lockAmount);\r\n        investor.investAmount = investorMap[_lockAddr].investAmount.add(_lockAmount);\r\n        investorMap[_lockAddr] = investor;\r\n\r\n        emit Lock(_lockAddr, _lockAmount, _endTime);\r\n        return true;\r\n    }\r\n\r\n    // freeze account\r\n    function freezeAccount(address _freezeAddr) public onlyOwner returns (bool) {\r\n        require(_freezeAddr != address(0), \"\");\r\n        freezeAccountMap[_freezeAddr] = true;\r\n        emit Freeze(_freezeAddr);\r\n        return true;\r\n    }\r\n    \r\n    // unfreeze account\r\n    function unfreezeAccount(address _freezeAddr) public onlyOwner returns (bool) {\r\n        require(_freezeAddr != address(0), \"\");\r\n        freezeAccountMap[_freezeAddr] = false;\r\n        emit Unfreeze(_freezeAddr);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    // get single investor invest information\r\n    function getSingleInvestor(address _addr) public view returns(uint256 _rEndTime, address _rAddr, bool _rIsLocked, uint256 _rLockAmount, uint256 _rInvestAmount){\r\n        require(_addr != address(0), \"\");\r\n        Investor memory investor = investorMap[_addr];\r\n        return(investor.endTime, investor.addr, investor.isLocked, investor.lockAmount, investor.investAmount);\r\n    }\r\n\r\n    // get investor count\r\n    function getInvestorCount() public view returns(uint256 _rInvestorCount){\r\n        return investorsList.length;\r\n    }\r\n\r\n    // get investor address\r\n    function getInvestorAddr(uint256 _index) public view returns(address _rInvestorAddr){\r\n        return investorsList[_index];\r\n    }\r\n\r\n    // after tokenLockEndTime owner Token\r\n    function withdrawTokenToInvestorOwner(address _investorAddr) public onlyOwner returns(bool){\r\n        require(_investorAddr != address(0), \"\");\r\n        require(now > tokenLockEndTime, \"\");\r\n        Investor memory investor = investorMap[_investorAddr];\r\n        if(investor.isLocked && now > investor.endTime && !freezeAccountMap[investor.addr]){\r\n            require(tokenContract.transfer(investor.addr, investor.lockAmount), \"\");\r\n            emit WithdrawalToken(investor.addr, investor.lockAmount);\r\n            investor.endTime = 0;\r\n            investor.isLocked = false;\r\n            investor.lockAmount = 0;\r\n            investorMap[investor.addr] = investor;\r\n            emit UnLock(investor.addr, investor.lockAmount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // after tokenLockEndTime batch Token\r\n    function withdrawBatchTokenToInvestor() public onlyOwner returns(bool){\r\n        require(now > tokenLockEndTime, \"\");\r\n        // count investor nums\r\n        uint256 investorCount = getInvestorCount();\r\n        require(investorCount > 0, \"\");\r\n        for (uint256 i = 0; i < investorCount; i++) {\r\n            address investorAddr = investorsList[i];\r\n            Investor memory investor = investorMap[investorAddr];\r\n            if(investor.isLocked && now > investor.endTime && !freezeAccountMap[investor.addr]){\r\n\r\n                require(tokenContract.transfer(investor.addr, investor.lockAmount), \"\");\r\n                emit WithdrawalToken(investor.addr, investor.lockAmount);\r\n                investor.endTime = 0;\r\n                investor.isLocked = false;\r\n                investor.lockAmount = 0;\r\n                investorMap[investor.addr] = investor;\r\n                emit UnLock(investor.addr, investor.lockAmount);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // recycling Remain Token to wallet address\r\n    function recyclingRemainToken() public onlyOwner whenNotPaused returns(bool){\r\n        require(now > tokenLockEndTime, \"\");\r\n        uint256 remainToken = tokenSupplyQuota.sub(tokensSold);\r\n        require(remainToken > 0, \"\");\r\n        require (tokenContract.transfer(msg.sender, remainToken), \"\");\r\n        pause();\r\n        return true;   \r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenSupplyQuota\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBatchTokenToInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractTokenBalance\",\"outputs\":[{\"name\":\"_rContractTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorMap\",\"outputs\":[{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"isLocked\",\"type\":\"bool\"},{\"name\":\"lockAmount\",\"type\":\"uint256\"},{\"name\":\"investAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokenAndLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recyclingRemainToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freezeAddr\",\"type\":\"address\"}],\"name\":\"unfreezeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getInvestorAddr\",\"outputs\":[{\"name\":\"_rInvestorAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCount\",\"outputs\":[{\"name\":\"_rInvestorCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorAddr\",\"type\":\"address\"}],\"name\":\"withdrawTokenToInvestorOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getSingleInvestor\",\"outputs\":[{\"name\":\"_rEndTime\",\"type\":\"uint256\"},{\"name\":\"_rAddr\",\"type\":\"address\"},{\"name\":\"_rIsLocked\",\"type\":\"bool\"},{\"name\":\"_rLockAmount\",\"type\":\"uint256\"},{\"name\":\"_rInvestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLockEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeAccountMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freezeAddr\",\"type\":\"address\"}],\"name\":\"freezeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_tokenLockEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"UnLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FoundingTeam","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000428d941e0a014bb5cdeb09bb00bc7b245221bdb0000000000000000000000000000000000000000000000000000000005fef46ff","Library":"","SwarmSource":"bzzr://0b9ee1548c294fbae59842ac2782847b497f592c92807b9789c7ec87ead8512c"}]}