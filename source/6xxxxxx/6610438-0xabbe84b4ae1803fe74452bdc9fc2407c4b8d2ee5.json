{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Token{\r\n    using SafeMath for *;\r\n    uint256 public totalSupply;\r\n    string public name;                 //name of token\r\n    string public symbol;               //symbol of token\r\n    uint256 public decimals;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns\r\n    (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256  _value);\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n    bool public paused;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier normal {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    function upgradeOwner(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setPaused(bool _paused) onlyOwner public {\r\n        paused = _paused;\r\n    }\r\n}\r\n\r\ncontract BonusState{\r\n    function BonusState(address _tokenAddress) public{\r\n        tokenAddress = _tokenAddress;\r\n        settlementTime = 10 days + now;\r\n    }\r\n\r\n    //balance for bonus compute withdraw, when withdraw and balance is zero means\r\n    //1. no balance for owner\r\n    //2. nerver update state\r\n    //so when withdraw, check balance state, when state is zero, check token balance\r\n    mapping(address=>uint256) balanceState;\r\n    //state is true while withdrawed\r\n    mapping(address=>bool) withdrawState;\r\n    //computedTotalBalance means this amount has been locked for withdraw, so when computing lockBonus,base amount will exclude this amount\r\n    uint256 computedTotalBalance = 0;\r\n    //price for token holder use this to compute withdrawable bonus for unit amount(unit amount means one exclude decimals)\r\n    uint256 computedUnitPrice = 0;\r\n    //while times up, next transaction for contract will auto settle bonus\r\n    uint256 settlementTime = 0;\r\n\r\n\r\n    //token contract address, only contract can operate this state contract\r\n    address public tokenAddress;\r\n    modifier onlyToken {\r\n        require(msg.sender == tokenAddress);\r\n        _;\r\n    }\r\n\r\n    function getSettlementTime() public view returns(uint256 _time){\r\n        return settlementTime;\r\n    }\r\n\r\n    function setBalanceState(address _target,uint256 _amount) public onlyToken{\r\n        balanceState[_target] = _amount;\r\n    }\r\n\r\n    function getBalanceState(address _target) public view returns (uint256 _balance) {\r\n        return balanceState[_target];\r\n    }\r\n\r\n\r\n    function setWithdrawState(address _target,bool _state) public onlyToken{\r\n        withdrawState[_target] = _state;\r\n    }\r\n\r\n    function getWithdrawState(address _target) public view returns (bool _state) {\r\n        return withdrawState[_target];\r\n    }\r\n\r\n\r\n    function setComputedTotalBalance(uint256 _amount) public onlyToken{\r\n        computedTotalBalance = _amount;\r\n    }\r\n\r\n    function setComputedUnitPrice(uint256 _amount) public onlyToken{\r\n        computedUnitPrice = _amount;\r\n    }\r\n\r\n    function getComputedTotalBalance() public view returns(uint256){\r\n        return computedTotalBalance;\r\n    }\r\n\r\n    function getComputedUnitPrice() public view returns(uint256){\r\n        return computedUnitPrice;\r\n    }\r\n\r\n}\r\n\r\ncontract EssToken is Token,owned {\r\n\r\n    //bonus state never change for withdraw;\r\n    address public bonusState_fixed;\r\n\r\n    //bonus state change while balance modified by transfer\r\n    address public bonusState;\r\n\r\n    //transfer eth to contract means incharge the bonus\r\n    function() public payable normal{\r\n        computeBonus(msg.value);\r\n    }\r\n    function incharge() public payable normal{\r\n        computeBonus(msg.value);\r\n    }\r\n\r\n    uint256 public icoTotal;\r\n\r\n    uint256 public airdropTotal;\r\n\r\n    //empty token while deploy the contract, token will minted by ico or minted by owner after ico\r\n    function EssToken() public {\r\n        decimals = 18;\r\n        name = \"Ether Sesame\";\r\n        symbol = \"ESS\";\r\n        totalSupply = 100000000 * 10 ** decimals;\r\n        icoTotal = totalSupply * 30 / 100; //30% for ico\r\n        airdropTotal = totalSupply * 20 / 100;  //20% for airdrop\r\n        uint256 _initAmount = totalSupply - icoTotal - airdropTotal;\r\n        bonusState = new BonusState(address(this));\r\n        _mintToken(msg.sender,_initAmount);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public normal returns (bool success) {\r\n        computeBonus(0);\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public normal returns\r\n    (bool success) {\r\n        computeBonus(0);\r\n        require(_value <= allowed[_from][msg.sender]);     // Check allowed\r\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public normal returns (bool success)\r\n    {\r\n        computeBonus(0);\r\n        allowed[tx.origin][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];//允许_spender从_owner中转出的token数\r\n    }\r\n    //end for ERC20 Token standard\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[_from] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        // Subtract from the sender\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balances[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n\r\n        //update bonus state when balance changed\r\n        BonusState(bonusState).setBalanceState(_from,balances[_from]);\r\n        BonusState(bonusState).setBalanceState(_to,balances[_to]);\r\n    }\r\n\r\n    //mint token for ico purchase or airdrop\r\n    function _mintToken(address _target, uint256 _mintAmount) internal {\r\n        require(_mintAmount>0);\r\n        balances[this] = (balances[this]).add(_mintAmount);\r\n        //update bonus state when balance changed\r\n        BonusState(bonusState).setBalanceState(address(this),balances[this]);\r\n        _transfer(this,_target,_mintAmount);\r\n    }\r\n\r\n    //check lockbonus for target\r\n    function lockedBonus(address _target) public view returns(uint256 bonus){\r\n        if(BonusState(bonusState).getSettlementTime()<=now)\r\n\t    {\r\n\t        return 0;\r\n\t    }\r\n\t    else{\r\n\t        uint256 _balance = balances[_target];\r\n            uint256 _fixedBonusTotal = lockBonusTotal();\r\n\r\n            uint256 _unitPrice = ((address(this).balance).sub(_fixedBonusTotal)).div(totalSupply.div(10**decimals));\r\n            return _balance.mul(_unitPrice).div(10**decimals);\r\n\t    }\r\n    }\r\n\r\n\tfunction lockBonusTotal() public view returns(uint256 bonus){\r\n\t    if(BonusState(bonusState).getSettlementTime()<=now)\r\n\t    {\r\n\t        return address(this).balance;\r\n\t    }\r\n\t    else{\r\n\t        uint256 _fixedBonusTotal = 0;\r\n            if(bonusState_fixed!=address(0x0))\r\n            {\r\n                _fixedBonusTotal = BonusState(bonusState_fixed).getComputedTotalBalance();\r\n            }\r\n    \t\treturn _fixedBonusTotal;\r\n\t    }\r\n\t}\r\n\r\n    function _withdrawableBonus(address _target) internal view returns(uint256 bonus){\r\n        uint256 _unitPrice;\r\n        uint256 _bonusBalance;\r\n        if(BonusState(bonusState).getSettlementTime()<=now){\r\n            _unitPrice = (address(this).balance).div(totalSupply.div(10**decimals));\r\n            _bonusBalance = balances[_target];\r\n            return _bonusBalance.mul(_unitPrice).div(10**decimals);\r\n        }\r\n        else{\r\n            if(bonusState_fixed==address(0x0))\r\n            {\r\n                return 0;\r\n            }\r\n            else{\r\n                bool _withdrawState = BonusState(bonusState_fixed).getWithdrawState(_target);\r\n        \t\t//withdraw only once for each bonus compute\r\n        \t\tif(_withdrawState)\r\n        \t\t\treturn 0;\r\n        \t\telse\r\n        \t\t{\r\n        \t\t\t_unitPrice = BonusState(bonusState_fixed).getComputedUnitPrice();\r\n        \t\t\t_bonusBalance = BonusState(bonusState_fixed).getBalanceState(_target);\r\n        \t\t\t//when bonus balance is zero and withdraw state is false means possibly state never changed after last compute bonus\r\n        \t\t\t//so try to check token balance,if balance has token means never change state\r\n        \t\t\tif(_bonusBalance==0){\r\n        \t\t\t\t_bonusBalance = balances[_target];\r\n        \t\t\t}\r\n        \t\t\treturn _bonusBalance.mul(_unitPrice).div(10**decimals);\r\n        \t\t}\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawableBonus(address _target)  public view returns(uint256 bonus){\r\n        return _withdrawableBonus(_target);\r\n    }\r\n\r\n    //compute bonus for withdraw and reset bonus state\r\n    function computeBonus(uint256 _incharge) internal {\r\n        if(BonusState(bonusState).getSettlementTime()<=now){\r\n            BonusState(bonusState).setComputedTotalBalance((address(this).balance).sub(_incharge));\r\n            BonusState(bonusState).setComputedUnitPrice((address(this).balance).sub(_incharge).div(totalSupply.div(10**decimals)));\r\n            bonusState_fixed = bonusState; //set current bonus as fixed bonus state\r\n            bonusState = new BonusState(address(this)); //deploy a new bonus state contract\r\n        }\r\n    }\r\n\r\n    function getSettlementTime() public view returns(uint256 _time){\r\n        return BonusState(bonusState).getSettlementTime();\r\n    }\r\n\r\n    //withdraw the bonus\r\n    function withdraw() public normal{\r\n        computeBonus(0);\r\n        //calc the withdrawable amount\r\n        uint256 _bonusAmount = _withdrawableBonus(msg.sender);\r\n        msg.sender.transfer(_bonusAmount);\r\n\r\n        //set withdraw state to true,means bonus has withdrawed\r\n        BonusState(bonusState_fixed).setWithdrawState(msg.sender,true);\r\n        uint256 _fixedBonusTotal = 0;\r\n        if(bonusState_fixed!=address(0x0))\r\n        {\r\n            _fixedBonusTotal = BonusState(bonusState_fixed).getComputedTotalBalance();\r\n        }\r\n        BonusState(bonusState_fixed).setComputedTotalBalance(_fixedBonusTotal.sub(_bonusAmount));\r\n    }\r\n\r\n}\r\n\r\ncontract ESSAdvance is EssToken{\r\n\r\n    //about ico\r\n    uint256 public icoCount;\r\n\r\n\r\n    uint256 public beginTime;\r\n    uint256 public endTime;\r\n\r\n    uint256 public offeredAmount;\r\n\r\n    //the eth price(wei) of one ess(one ess means number exclude the decimals)\r\n    uint256 public icoPrice;\r\n\r\n    function isOffering() public view returns(bool){\r\n        return beginTime>0&&now>beginTime&&now<endTime&&icoTotal>0;\r\n    }\r\n\r\n    function startIco(uint256 _beginTime,uint256 _endTime,uint256 _icoPrice) public onlyOwner{\r\n        require(_beginTime>0&&_endTime>_beginTime&&_icoPrice>0);\r\n        beginTime  = _beginTime;\r\n        endTime  = _endTime;\r\n        icoPrice = _icoPrice;\r\n        icoCount++;\r\n    }\r\n\r\n    function buy() public payable normal{\r\n        computeBonus(msg.value);\r\n        //ico activity is started and must buy one ess at least\r\n        require(isOffering()&&msg.value>=icoPrice);\r\n        uint256 _amount = (msg.value).div(icoPrice).mul(10**decimals);\r\n        offeredAmount = offeredAmount.add(_amount);  //increase the offeredAmount for this round\r\n        icoTotal = icoTotal.sub(_amount);\r\n        owner.transfer(msg.value);\r\n        _mintToken(msg.sender,_amount);\r\n    }\r\n    //end ico\r\n\r\n    //about airdrop\r\n    //authed address for airdrop\r\n    address public airdropAuthAddress;\r\n    //update airdrop auth\r\n    function upgradeAirdropAuthAddress(address newAirdropAuthAddress) onlyOwner public {\r\n        airdropAuthAddress = newAirdropAuthAddress;\r\n    }\r\n    modifier airdropAuthed {\r\n        require(msg.sender == airdropAuthAddress);\r\n        _;\r\n    }\r\n\r\n    //airdrop to player amount: (_ethPayment/_airdropPrice)\r\n    function airdrop(uint256 _airdropPrice,uint256 _ethPayment) public airdropAuthed normal returns(uint256){\r\n        computeBonus(0);\r\n        if(_airdropPrice>0&&_ethPayment/_airdropPrice>0&&airdropTotal>0){\r\n            uint256 _airdropAmount = _ethPayment.div(_airdropPrice);\r\n            if(_airdropAmount>=airdropTotal){\r\n                _airdropAmount = airdropTotal;\r\n            }\r\n            if(_airdropAmount>0)\r\n            {\r\n                _airdropAmount = _airdropAmount.mul(10 ** decimals);\r\n                airdropTotal-=_airdropAmount;\r\n                _mintToken(tx.origin,_airdropAmount);\r\n            }\r\n            return _airdropAmount;\r\n        }\r\n        else{\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev divide two numbers, throws on overflow.\r\n    */\r\n    function div(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        require(b > 0);\r\n        c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettlementTime\",\"outputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusState_fixed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropAuthAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beginTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_icoPrice\",\"type\":\"uint256\"}],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incharge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAirdropAuthAddress\",\"type\":\"address\"}],\"name\":\"upgradeAirdropAuthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_airdropPrice\",\"type\":\"uint256\"},{\"name\":\"_ethPayment\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beginTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"withdrawableBonus\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOffering\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockBonusTotal\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"offeredAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"lockedBonus\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"upgradeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ESSAdvance","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://163513d40591b8c1cc21cac1726c6cb7c0e5910852f4f97db1c5dea3850478f7"}]}