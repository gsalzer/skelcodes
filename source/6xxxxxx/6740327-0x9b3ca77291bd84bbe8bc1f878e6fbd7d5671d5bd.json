{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) public returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public returns (address _addr);\r\n}\r\n\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofType_Android = 0x20;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\r\n            oraclize_setNetwork(networkID_auto);\r\n\r\n        if(address(oraclize) != OAR.getAddress())\r\n            oraclize = OraclizeI(OAR.getAddress());\r\n\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n      return oraclize_setNetwork();\r\n      networkID; // silence the warning and remain backwards compatible\r\n    }\r\n    function oraclize_setNetwork() internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) public {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    \r\n   function __callback(bytes32 myid, string result, bytes proof) public {\r\n       \r\n   }\r\n\r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function parseAddr(string _a) internal pure returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b) internal pure returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal pure returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\r\n            uint arrlen = arr.length;\r\n\r\n            // get correct cbor output length\r\n            uint outputlen = 0;\r\n            bytes[] memory elemArray = new bytes[](arrlen);\r\n            for (uint i = 0; i < arrlen; i++) {\r\n                elemArray[i] = (bytes(arr[i]));\r\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n            }\r\n            uint ctr = 0;\r\n            uint cborlen = arrlen + 0x80;\r\n            outputlen += byte(cborlen).length;\r\n            bytes memory res = new bytes(outputlen);\r\n\r\n            while (byte(cborlen).length > ctr) {\r\n                res[ctr] = byte(cborlen)[ctr];\r\n                ctr++;\r\n            }\r\n            for (i = 0; i < arrlen; i++) {\r\n                res[ctr] = 0x5F;\r\n                ctr++;\r\n                for (uint x = 0; x < elemArray[i].length; x++) {\r\n                    // if there's a bug with larger strings, this may be the culprit\r\n                    if (x % 23 == 0) {\r\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                        elemcborlen += 0x40;\r\n                        uint lctr = ctr;\r\n                        while (byte(elemcborlen).length > ctr - lctr) {\r\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                            ctr++;\r\n                        }\r\n                    }\r\n                    res[ctr] = elemArray[i][x];\r\n                    ctr++;\r\n                }\r\n                res[ctr] = 0xFF;\r\n                ctr++;\r\n            }\r\n            return res;\r\n        }\r\n\r\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\r\n            uint arrlen = arr.length;\r\n\r\n            // get correct cbor output length\r\n            uint outputlen = 0;\r\n            bytes[] memory elemArray = new bytes[](arrlen);\r\n            for (uint i = 0; i < arrlen; i++) {\r\n                elemArray[i] = (bytes(arr[i]));\r\n                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n            }\r\n            uint ctr = 0;\r\n            uint cborlen = arrlen + 0x80;\r\n            outputlen += byte(cborlen).length;\r\n            bytes memory res = new bytes(outputlen);\r\n\r\n            while (byte(cborlen).length > ctr) {\r\n                res[ctr] = byte(cborlen)[ctr];\r\n                ctr++;\r\n            }\r\n            for (i = 0; i < arrlen; i++) {\r\n                res[ctr] = 0x5F;\r\n                ctr++;\r\n                for (uint x = 0; x < elemArray[i].length; x++) {\r\n                    // if there's a bug with larger strings, this may be the culprit\r\n                    if (x % 23 == 0) {\r\n                        uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                        elemcborlen += 0x40;\r\n                        uint lctr = ctr;\r\n                        while (byte(elemcborlen).length > ctr - lctr) {\r\n                            res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                            ctr++;\r\n                        }\r\n                    }\r\n                    res[ctr] = elemArray[i][x];\r\n                    ctr++;\r\n                }\r\n                res[ctr] = 0xFF;\r\n                ctr++;\r\n            }\r\n            return res;\r\n        }\r\n\r\n\r\n    string oraclize_network_name;\r\n    function oraclize_setNetworkName(string _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal view returns (string) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\r\n        require((_nbytes > 0) && (_nbytes <= 32));\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(_nbytes);\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\r\n        bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\r\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(bytes8(_delay), args[1], sha256(args[0]), args[2])));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\r\n        oraclize_randomDS_args[queryId] = commitment;\r\n    }\r\n\r\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\r\n        bool sigok;\r\n        address signer;\r\n\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4+(uint(dersig[3]) - 0x20);\r\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\r\n\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n\r\n\r\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\r\n        if (address(keccak256(pubkey)) == signer) return true;\r\n        else {\r\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\r\n            return (address(keccak256(pubkey)) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\r\n        bool sigok;\r\n\r\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\r\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\r\n\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\r\n\r\n        bytes memory tosign2 = new bytes(1+65+32);\r\n        tosign2[0] = byte(1); //role\r\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n\r\n        if (sigok == false) return false;\r\n\r\n\r\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n\r\n        bytes memory tosign3 = new bytes(1+65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(proof, 3, 65, tosign3, 1);\r\n\r\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\r\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\r\n\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n\r\n        return sigok;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        require(proofVerified);\r\n\r\n        _;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (proofVerified == false) return 2;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\r\n        bool match_ = true;\r\n        \r\n\r\n        for (uint256 i=0; i< n_random_bytes; i++) {\r\n            if (content[i] != prefix[i]) match_ = false;\r\n        }\r\n\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\r\n\r\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\r\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\r\n\r\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\r\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\r\n\r\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\r\n\r\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\r\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\r\n\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\r\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\r\n\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[queryId];\r\n        } else return false;\r\n\r\n\r\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32+8+1+32);\r\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\r\n\r\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\r\n        }\r\n\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\r\n        uint minLength = length + toOffset;\r\n\r\n        // Buffer too small\r\n        require(to.length >= minLength); // Should be a better way?\r\n\r\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint i = 32 + fromOffset;\r\n        uint j = 32 + toOffset;\r\n\r\n        while (i < (32 + fromOffset + length)) {\r\n            assembly {\r\n                let tmp := mload(add(from, i))\r\n                mstore(add(to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n          return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28]\r\n        //\r\n        // geth uses [0, 1] and some clients have followed. This might change, see:\r\n        //  https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27)\r\n          v += 27;\r\n\r\n        if (v != 27 && v != 28)\r\n            return (false, 0);\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n}\r\n\r\ncontract Mortal {\r\n    /* Define variable owner of the type address */\r\n    address owner;\r\n\r\n    /* This function is executed at initialization and sets the owner of the contract */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /* Function to recover the funds on the contract */\r\n    function kill() public {\r\n        if (msg.sender == owner) {\r\n            selfdestruct(owner);\r\n        }\r\n    }\r\n}\r\n\r\ncontract BucketContract is Mortal {\r\n\tmapping (address => uint) public betAmount;\r\n\tmapping (address => bool) public hasBet;\r\n\taddress[] public betters;\r\n\tuint[] public amountWon;\r\n\tuint[] public amountBid;\r\n\taddress public owner;\r\n\tuint256 public totalBid;\r\n\tbool public payoutComplete;\r\n\tbool public isWinner;\r\n\tuint256 public gameId;\r\n\tuint256 public referralAmount;\r\n\tuint256 public settlementType;\r\n\tuint256 public processed;/* no of payouts processed */\r\n\tuint256 public remaining;/* no of payouts remaining */\r\n\tuint256 public totalBalance;\r\n\r\n\tGameContract public gameContractObject;\r\n\r\n\tevent StateChanged(bool status, string message);\r\n\tevent SendReward(address winner, uint amount);\r\n\r\n\tmodifier onlyGameContractOrOwner {\r\n\t\trequire (msg.sender == address(gameContractObject) || msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyGameContract {\r\n\t\trequire (msg.sender == address(gameContractObject));\r\n\t\t_;\r\n\t}\r\n\r\n  modifier onlyOwner {\r\n\t  require(msg.sender == owner);\r\n\t  _;\r\n  }\r\n\r\n  constructor(address gcAddress/*, uint256 _gameId*/) public {\r\n\t\towner = msg.sender;\r\n\t\t// gameId = _gameId;\r\n\t\tgameContractObject = GameContract(gcAddress);\r\n\t\temit StateChanged(true, \"bucket contract deployed\");\r\n\t}\r\n\r\n\tfunction getBettersArrayLength() public view returns(uint256) {\r\n\t\treturn betters.length;\r\n\t}\r\n\r\n\tfunction getBetter() public view returns(address[]) {\r\n\t\treturn betters;\r\n\t} \r\n\r\n\tfunction getWinningAmount() public view returns(uint[]) {\r\n\t\treturn amountWon;\r\n\t}\r\n\r\n\tfunction getBidAmount() public view returns(uint[]) {\r\n\t\treturn amountBid;\r\n\t}\r\n\r\n\tfunction setGameId(uint256 _gameId) public onlyGameContract {\r\n\t\tassert(gameId == 0);\r\n\t\tgameId = _gameId;\r\n\t}\r\n\r\n\tfunction bet() public payable /*gameRunning*/ {\r\n\t\trequire (msg.value >= gameContractObject.getPrice(), \"Too small bet\");\r\n\t\tassert(gameContractObject.canBet());\r\n\t\tif (hasBet[msg.sender] == false) {\r\n\t\t\tbetters.push(msg.sender);\r\n\t\t\thasBet[msg.sender] = true;\r\n\t\t}\r\n\t\tbetAmount[msg.sender] += msg.value;\r\n\t\ttotalBid += msg.value;\r\n\t\temit StateChanged(true,\"Bet submitted\");\r\n\t}\r\n\r\n\tfunction transferToOtherBucketContract(address _bucketContract) public onlyGameContractOrOwner {\r\n\t\t_bucketContract.transfer(address(this).balance);\r\n\t}\r\n\r\n\tfunction () public payable {\r\n\t\temit StateChanged(true, \"Ether Received\");\r\n\t}\r\n\r\n\t/* setWinner function - set the winning contract */\r\n\tfunction setWinner(uint256 _gameId) public onlyGameContractOrOwner {\r\n\t\trequire(_gameId == gameContractObject.gameId());\r\n\t\tassert(gameContractObject.state() == GameContract.GameState.RandomReceived);\r\n\t\tassert(!isWinner);\r\n\t\tisWinner = true;\r\n\t\taddress houseAddressOne = gameContractObject.getHouseAddressOne();\r\n\t\taddress houseAddressTwo = gameContractObject.getHouseAddressTwo();\r\n\t\taddress referralAddress = gameContractObject.getReferralAddress();\r\n\t\tif (totalBid == 0) {\r\n\t\t\thouseAddressOne.transfer((address(this).balance * 70)/100);\r\n\t\t\thouseAddressTwo.transfer(address(this).balance);\r\n      settlementType = 0;\r\n\t\t} else if (totalBid == address(this).balance) {\r\n\t\t    settlementType = 1;\r\n\t\t} else {\r\n\t\t\ttotalBalance = address(this).balance - totalBid;\r\n\t\t\tuint256 houseAddressShare = gameContractObject.getHouseAddressShare();\r\n\t\t\thouseAddressOne.transfer((totalBalance * houseAddressShare * 70) / 10000);/* 70 percent of house share goes to bucket one */\r\n\t\t\thouseAddressTwo.transfer((totalBalance * houseAddressShare * 30) / 10000);/* 30 percent of house share goes to bucket one */\r\n\t\t\treferralAmount = (totalBalance * gameContractObject.getReferralAddressShare())/100;\t\r\n\t\t\treferralAddress.transfer(referralAmount);\r\n\t\t\ttotalBalance = address(this).balance;\r\n\t\t\tsettlementType = 2;\r\n\t\t}\r\n\t\tprocessed = 0;\r\n\t\tremaining = betters.length;\r\n\t}\r\n\r\n\tfunction payout() public onlyGameContract {\r\n\t\tassert(!payoutComplete);\r\n\t\tassert(isWinner);\r\n\t\tuint256 batchsize = gameContractObject.getBatchSize();\r\n\t\tuint256 i;\r\n\t\tif (betters.length - processed <= batchsize) {\r\n\t\t\tbatchsize = remaining;\r\n\t\t}\r\n\t\tuint256 processLimit = processed + batchsize;\r\n\t\tif (settlementType == 0) {\r\n\t\t    gameContractObject.finishGame();\r\n\t\t    return;\r\n\t\t}\r\n\t\telse if (settlementType == 1) {\r\n\t\t\tfor (i = processed; i < processLimit && i < betters.length; i++) {\r\n\t\t\t\taddress better = betters[i];\r\n\t\t\t\tuint amount = betAmount[better];\r\n\t\t\t\tbetter.transfer(amount);\r\n\t\t\t\temit SendReward(better, amount);\r\n\t\t\t\tamountWon.push(amount);\r\n\t\t\t}\r\n\t\t\r\n\t\t} else if (settlementType == 2) {\r\n\t\t\tfor (i = processed; i < processLimit && i < betters.length; i++) {\r\n\t\t\t\taddress better2 = betters[i];\r\n\t\t\t\tuint amountToTransfer = (betAmount[better2]*totalBalance)/totalBid;\r\n\t\t\t\tbetter2.transfer(amountToTransfer); \r\n\t\t\t\temit SendReward(better2, amountToTransfer);\r\n\t\t\t\tamountWon.push(amountToTransfer - betAmount[better2]);\r\n\t\t\t\tamountBid.push(betAmount[better2]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tprocessed = i;\t\r\n\t\tremaining = betters.length - processed;\r\n\t\tif (processed > betters.length - 1) {\r\n\t\t\tpayoutComplete = true;\r\n\t\t\tgameContractObject.getHouseAddressOne().transfer(address(this).balance);\r\n\t\t\tgameContractObject.finishGame();\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction resetBucket() public onlyGameContract {\r\n\t    assert(gameContractObject.state() == GameContract.GameState.Finishing);\r\n\t    uint256 i;\r\n\t    for (i = 0; i < betters.length; i++) {\r\n\t        delete betAmount[betters[i]];\r\n\t        delete hasBet[betters[i]];\r\n\t    }\r\n\t    delete betters;\r\n\t    delete amountWon;\r\n\t    delete amountBid;\r\n\t    totalBid = 0;\r\n\t    payoutComplete = false;\r\n        isWinner = false;\r\n\t    gameId = 0;\r\n\t\t\treferralAmount = 0;\r\n\t    settlementType = 0;\r\n\t    processed = 0;/* no of payouts processed */\r\n\t\t\tremaining = 0;/* no of payouts remaining */ \r\n\t    totalBalance = 0;\r\n\t}\r\n\t\r\n\tfunction drain() public onlyGameContractOrOwner {\r\n\t\tassert(gameContractObject.state() == GameContract.GameState.Deployed || gameContractObject.state() == GameContract.GameState.Finished);\r\n\t\tgameContractObject.getHouseAddressOne().transfer((address(this).balance * 7) / 10);\r\n\t\tgameContractObject.getHouseAddressTwo().transfer(address(this).balance);\r\n\t\temit StateChanged(true, \"Drain Successful\");\r\n\t}\r\n\r\n}\r\n\r\ncontract GameContract is usingOraclize, Mortal {\r\n\tenum GameState {\r\n\t\tDeployed,\r\n\t\tStarted,\r\n\t\tRandomRequesting,\r\n\t\tRandomReceived,\r\n\t\tSettled,\r\n\t\tFinishing,\r\n\t\tFinished\r\n\t}\r\n\r\n\taddress public owner;\r\n\taddress public otherSettingOwner;\r\n\tuint256 public price = 1e16;\r\n\tuint256 public gameId;\r\n\tuint public startTime = 0;\r\n\taddress public houseAddressOne;\r\n\taddress public houseAddressTwo;\t\r\n\taddress public referralAddress;\r\n\taddress public recentWinnerContract;\r\n\tuint256 public shareOfHouseAddress = 10;\r\n\tuint256 public shareOfReferralAddress = 20;\r\n\tuint256 public batchSize = 50;\r\n\tuint256 public callbackGas = 100000; /* The gas amount required to call oraclize function */\r\n  \r\n    GameContract.GameState public state = GameContract.GameState.Deployed;\r\n\r\n\tmapping (uint256 => bool) public isGameSettled;\r\n\tmapping (uint256 => address) public winningContract;\r\n\tmapping (uint256 => uint256) public typeOfWinnerContract;\r\n\tmapping (uint256 => uint256) public randomValue;\r\n\tmapping (bytes32 => uint256) public oraclizeQueryData;\r\n\tmapping (uint256 => bool) public oraclizeValueReceived;\r\n\tmapping (uint256 => bool) public settlement;\r\n \t \r\n\tBucketContract public bucketOneContractObject;\r\n\tBucketContract public bucketTwoContractObject;\r\n\r\n\tevent StateChanged(bool state, string status);\r\n\tevent CallbackEvent(uint256 number);\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOtherSettingOwner {\r\n\t\trequire(msg.sender == otherSettingOwner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier onlyContractOrOwner {\r\n\t\trequire (msg.sender == address(this) || msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor( address _houseAddressOne, address _houseAddressTwo, address _referralAddress, address _otherSettingOwner) public {\r\n      require(_houseAddressOne != address(0) && _houseAddressTwo != address(0) && _referralAddress != address(0) && _otherSettingOwner != address(0));\r\n      owner = msg.sender;\r\n\t  houseAddressOne = _houseAddressOne;\r\n      houseAddressTwo = _houseAddressTwo;\r\n      referralAddress = _referralAddress;\r\n      otherSettingOwner = _otherSettingOwner;\r\n      bucketOneContractObject = new BucketContract(address(this));\r\n      bucketTwoContractObject = new BucketContract(address(this));\r\n      emit StateChanged(true, \"Contract deployed\");\r\n\t}\r\n\r\n\t\tfunction kill() public onlyOwner {\r\n\t\t\t// kill buckets first\r\n\t\t\tif (address(bucketOneContractObject) != 0) {\r\n\t\t\t\tbucketOneContractObject.kill();\r\n\t\t\t}\r\n\t\t\tif (address(bucketTwoContractObject) != 0) {\r\n\t\t\t\tbucketTwoContractObject.kill();\r\n\t\t\t}\r\n\t\t\tsuper.kill();\r\n\t\t}\r\n\r\n\t/*House Share will be value between 1-100*/\r\n\tfunction setHouseAddressShare (uint _share) public onlyOtherSettingOwner {\r\n\t\trequire(_share >= 1 && _share <= 100);\r\n\t\trequire(_share + shareOfReferralAddress <= 100);\r\n\t\tshareOfHouseAddress = _share;\r\n\t}\r\n\r\n\tfunction setReferralAddressShare (uint _share) public onlyOtherSettingOwner {\r\n\t\trequire(_share >= 1 && _share <= 100);\r\n\t\trequire(_share + shareOfHouseAddress <= 100);\t\t\r\n\t\tshareOfReferralAddress = _share;\r\n\t}\r\n\r\n\tfunction getHouseAddressShare() public view returns(uint) {\r\n\t\treturn shareOfHouseAddress;\r\n\t}\r\n\r\n\tfunction getReferralAddressShare() public view returns(uint) {\r\n\t\treturn shareOfReferralAddress;\r\n\t}\r\n\r\n\tfunction setPrice (uint256 _price) public onlyOtherSettingOwner {\r\n\t\trequire(_price != 0);\r\n\t\tprice = _price;\r\n\t}\r\n\r\n\tfunction setHouseAddressOne(address _houseAddress) public onlyOtherSettingOwner {\r\n\t\trequire(_houseAddress != address(0));\r\n\t\thouseAddressOne = _houseAddress;\r\n\t}\r\n\r\n\tfunction setHouseAddressTwo(address _houseAddress) public onlyOtherSettingOwner {\r\n\t\trequire(_houseAddress != address(0));\r\n\t\thouseAddressTwo = _houseAddress;\r\n\t}\r\n\r\n\tfunction setReferralAddress(address _referralAddress) public onlyOtherSettingOwner {\r\n\t\trequire(_referralAddress != address(0));\r\n\t\treferralAddress = _referralAddress;\r\n\t}\r\n\r\n\tfunction setCallbackGas(uint256 _value) public onlyOtherSettingOwner {\r\n\t\trequire(_value > 0);\r\n\t\tcallbackGas = _value;\r\n\t}\r\n\r\n\tfunction setBatchSize(uint256 _size) public onlyOtherSettingOwner {\r\n\t\trequire(_size != 0);\r\n\t\tbatchSize = _size;\r\n\t}\r\n\r\n\tfunction setOwner(address _owner) public onlyOwner {\r\n\t\trequire(_owner != address(0));\r\n\t\towner = _owner;\r\n\t}\r\n\r\n\tfunction setOtherSettingOwner(address _otherSettingOwner) public onlyOtherSettingOwner {\r\n\t\trequire(_otherSettingOwner != address(0));\r\n\t\totherSettingOwner = _otherSettingOwner;\r\n\t}\r\n\r\n\tfunction getPrice () public view returns (uint256 _price) {\r\n\t\treturn price;\r\n\t}\r\n\r\n\tfunction getGameId() public view returns (uint256 _gameId) {\r\n\t\treturn gameId;\r\n\t}\r\n\t\r\n\tfunction getHouseAddressOne() public view returns (address _houseAddress) {\r\n\t\treturn houseAddressOne;\r\n\t}\r\n\r\n\tfunction getHouseAddressTwo() public view returns (address _houseAddress) {\r\n\t\treturn houseAddressTwo;\r\n\t}\r\n\r\n\tfunction getReferralAddress() public view returns(address _referralAddress) {\r\n\t\treturn referralAddress;\r\n\t}\r\n\r\n\tfunction getWinnerContractAddress(uint256 _gameId) public view returns(address) {\r\n\t\treturn winningContract[_gameId];\r\n\t}\r\n\r\n\tfunction getWinnerType(uint256 _gameId) public view returns(uint256) {\r\n\t\treturn typeOfWinnerContract[_gameId];\r\n\t}\r\n\r\n\tfunction getBatchSize() public view returns(uint256) {\r\n\t\treturn batchSize;\r\n\t}\r\n\r\n    function beginGame (uint256 _gameId) public payable onlyOwner {\r\n        require(_gameId != 0);\r\n        require(isGameSettled[_gameId] != true);\r\n        assert(state == GameContract.GameState.Deployed || state == GameContract.GameState.Finished);\r\n        gameId = _gameId;\r\n            bucketOneContractObject.setGameId(_gameId);\r\n            bucketTwoContractObject.setGameId(_gameId);\r\n        startTime = block.timestamp; // solium-disable-line\r\n        state = GameContract.GameState.Started;\r\n        emit StateChanged(true, \"game started\");\r\n    }\r\n\r\n\tfunction () public payable {\r\n\t\temit StateChanged(true, \"Ether Received\");\r\n\t}\r\n\r\n\tfunction finalize() public onlyOwner {\r\n\t\trequire(oraclizeValueReceived[gameId] == false);\r\n\t\tbytes32 queryId = oraclize_newRandomDSQuery(0, 7, callbackGas);\r\n\t\toraclizeQueryData[queryId] = gameId;\r\n\t\tstate = GameContract.GameState.RandomRequesting;\r\n\t}\r\n\r\n\tfunction __callback(bytes32 _queryId, string _result) public {\r\n\t\trequire(msg.sender == oraclize_cbAddress());\r\n\t\tassert(oraclizeValueReceived[oraclizeQueryData[_queryId]] == false);\r\n\t\tuint256 maxRange = 2**(8*7);\r\n\t\tuint256 randomNumber = uint256(keccak256(abi.encodePacked(_result))) % maxRange;\r\n\t\trandomValue[oraclizeQueryData[_queryId]] = randomNumber;\r\n\t\toraclizeValueReceived[oraclizeQueryData[_queryId]] = true;\r\n\t\tstate = GameContract.GameState.RandomReceived;\r\n\t\temit CallbackEvent(randomNumber);\r\n\t}\r\n\r\n\tfunction startSettlement() public onlyOwner {\r\n\t\trequire(state == GameContract.GameState.RandomReceived);\r\n\t\tassert(oraclizeValueReceived[gameId]);\r\n\t\tassert(settlement[gameId] == false);\r\n\t\tuint256 randomNumber = randomValue[gameId];\r\n\t\tif (randomNumber % 2 == 0) {\r\n\t\t\tbucketTwoContractObject.transferToOtherBucketContract(address(bucketOneContractObject));\r\n\t\t\trecentWinnerContract = address(bucketOneContractObject);\r\n\t\t\twinningContract[gameId] = address(bucketOneContractObject);\r\n\t\t\tbucketOneContractObject.setWinner(gameId);\r\n\t\t\tsettlement[gameId] = true;\r\n\t\t\tstate = GameContract.GameState.Settled;\r\n\t\t} else {\r\n\t\t\tbucketOneContractObject.transferToOtherBucketContract(address(bucketTwoContractObject));\r\n\t\t\trecentWinnerContract = address(bucketTwoContractObject);\r\n\t\t\twinningContract[gameId] = address(bucketTwoContractObject);\r\n\t\t\tbucketTwoContractObject.setWinner(gameId);\r\n\t\t\tsettlement[gameId] = true;\r\n\t\t\tstate = GameContract.GameState.Settled;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction payout() public onlyOwner {\r\n\t\trequire(state == GameContract.GameState.Settled);\r\n\t\tBucketContract(recentWinnerContract).payout();\r\n\t}\r\n\r\n\tfunction canBet() public view returns (bool) {\r\n      return state == GameContract.GameState.Started;\r\n\t}\r\n\r\n\tfunction finishGame() public {\r\n\t\trequire(msg.sender == winningContract[gameId] || msg.sender == recentWinnerContract);\r\n\t\tisGameSettled[gameId] = true;\r\n\t\tstate = GameContract.GameState.Finishing;\r\n\t\temit StateChanged(true, \"game finished\");\r\n\t}\r\n\r\n\tfunction reset() public onlyOwner {\r\n\t\trequire(state == GameContract.GameState.Finishing);\r\n\t\tbucketOneContractObject.resetBucket();\r\n\t\tbucketTwoContractObject.resetBucket();\r\n\t\tstate = GameContract.GameState.Finished;\r\n\t\temit StateChanged(true, \"game reset\");\r\n\t}\r\n\t\r\n\tfunction drain() public onlyOwner {\r\n\t\thouseAddressOne.transfer((address(this).balance * 7) / 10);\r\n\t\thouseAddressTwo.transfer(address(this).balance);\r\n\t\temit StateChanged(true, \"Drain Successful\");\r\n\t}\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setCallbackGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winningContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseAddressOne\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"beginGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oraclizeQueryData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"name\":\"_result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"otherSettingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseAddressTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReferralAddress\",\"outputs\":[{\"name\":\"_referralAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReferralAddressShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHouseAddressShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getWinnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bucketOneContractObject\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"setBatchSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settlement\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recentWinnerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHouseAddressTwo\",\"outputs\":[{\"name\":\"_houseAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_houseAddress\",\"type\":\"address\"}],\"name\":\"setHouseAddressTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"typeOfWinnerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_share\",\"type\":\"uint256\"}],\"name\":\"setHouseAddressShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getWinnerContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"callbackGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBatchSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareOfHouseAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_houseAddress\",\"type\":\"address\"}],\"name\":\"setHouseAddressOne\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_share\",\"type\":\"uint256\"}],\"name\":\"setReferralAddressShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"setReferralAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareOfReferralAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameId\",\"outputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isGameSettled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bucketTwoContractObject\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHouseAddressOne\",\"outputs\":[{\"name\":\"_houseAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_otherSettingOwner\",\"type\":\"address\"}],\"name\":\"setOtherSettingOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oraclizeValueReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_houseAddressOne\",\"type\":\"address\"},{\"name\":\"_houseAddressTwo\",\"type\":\"address\"},{\"name\":\"_referralAddress\",\"type\":\"address\"},{\"name\":\"_otherSettingOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"string\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"CallbackEvent\",\"type\":\"event\"}]","ContractName":"GameContract","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000010c494b0aa052d82b1910449ab2d3e88f8c89e8f000000000000000000000000817178a29c5fc05584b0d039fdf000048f1bf125000000000000000000000000b4ce4486898370cf70ee4788b62d296bc764ef440000000000000000000000005a757b51e8923cfa6849eb8d6217078886fcf7cf","Library":"","SwarmSource":"bzzr://442ed2b459e10c6f07d76c20547225e07da966621a64ecabda83e7af9168dcd8"}]}