{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n// File: contracts/ERC777/ERC20Token.sol\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla external\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n *\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\ninterface ERC20Token {\r\n  function name() external view returns (string);\r\n  function symbol() external view returns (string);\r\n  function decimals() external view returns (uint8);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 amount);\r\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n// File: contracts/ERC820/ERC820Client.sol\r\n\r\ncontract ERC820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns(address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC820Client {\r\n    ERC820Registry erc820Registry = ERC820Registry(0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7);\r\n\r\n    function setInterfaceImplementation(string _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        erc820Registry.setInterfaceImplementer(this, interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return erc820Registry.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        erc820Registry.setManager(this, _newManager);\r\n    }\r\n}\r\n\r\n// File: contracts/openzeppelin-solidity/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/openzeppelin-solidity/Address.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param account address of the account to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/ERC777/ERC777Token.sol\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla external\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n *\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\ninterface ERC777Token {\r\n  function name() external view returns (string);\r\n  function symbol() external view returns (string);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function granularity() external view returns (uint256);\r\n\r\n  function defaultOperators() external view returns (address[]);\r\n  function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n\r\n  function send(address to, uint256 amount, bytes holderData) external;\r\n  function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) external;\r\n\r\n  function burn(uint256 amount, bytes holderData) external;\r\n  function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) external;\r\n\r\n  event Sent(\r\n    address indexed operator,\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 amount,\r\n    bytes holderData,\r\n    bytes operatorData\r\n  );\r\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n// File: contracts/ERC777/ERC777TokensSender.sol\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n *\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\ninterface ERC777TokensSender {\r\n  function tokensToSend(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint amount,\r\n    bytes userData,\r\n    bytes operatorData\r\n  ) external;\r\n}\r\n\r\n// File: contracts/ERC777/ERC777TokensRecipient.sol\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n *\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\ninterface ERC777TokensRecipient {\r\n  function tokensReceived(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint amount,\r\n    bytes userData,\r\n    bytes operatorData\r\n  ) external;\r\n}\r\n\r\n// File: contracts/ERC777/ERC777BaseToken.sol\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n* License, v. 2.0. If a copy of the MPL was not distributed with this\r\n* file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC777BaseToken is ERC777Token, ERC820Client {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  string internal mName;\r\n  string internal mSymbol;\r\n  uint256 internal mGranularity;\r\n  uint256 internal mTotalSupply;\r\n\r\n\r\n  mapping(address => uint) internal mBalances;\r\n  mapping(address => mapping(address => bool)) internal mAuthorized;\r\n\r\n  address[] internal mDefaultOperators;\r\n  mapping(address => bool) internal mIsDefaultOperator;\r\n  mapping(address => mapping(address => bool)) internal mRevokedDefaultOperator;\r\n\r\n  /* -- Constructor -- */\r\n  //\r\n  /// @notice Constructor to create a SelfToken\r\n  /// @param _name Name of the new token\r\n  /// @param _symbol Symbol of the new token.\r\n  /// @param _granularity Minimum transferable chunk.\r\n  constructor(\r\n    string _name,\r\n    string _symbol,\r\n    uint256 _granularity,\r\n    address[] _defaultOperators\r\n  )\r\n    internal\r\n  {\r\n    mName = _name;\r\n    mSymbol = _symbol;\r\n    mTotalSupply = 0;\r\n    require(_granularity >= 1);\r\n    mGranularity = _granularity;\r\n\r\n    mDefaultOperators = _defaultOperators;\r\n    for (uint i = 0; i < mDefaultOperators.length; i++) {\r\n      mIsDefaultOperator[mDefaultOperators[i]] = true;\r\n    }\r\n\r\n    setInterfaceImplementation(\"ERC777Token\", this);\r\n  }\r\n\r\n  /* -- ERC777 Interface Implementation -- */\r\n\r\n  /// @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  function send(address _to, uint256 _amount, bytes _userData) external {\r\n    doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\r\n  }\r\n\r\n  /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  /// @param _userData Data generated by the user to be sent to the recipient\r\n  /// @param _operatorData Data generated by the operator to be sent to the recipient\r\n  function operatorSend(address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData) external {\r\n    require(isOperatorFor(msg.sender, _from));\r\n    doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\r\n  }\r\n\r\n  function burn(uint256 _amount, bytes _holderData) external {\r\n    doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\r\n  }\r\n\r\n  function operatorBurn(address _tokenHolder, uint256 _amount, bytes _holderData, bytes _operatorData) external {\r\n    require(isOperatorFor(msg.sender, _tokenHolder));\r\n    doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\r\n  }\r\n\r\n  /// @return the name of the token\r\n  function name() external view returns (string) { return mName; }\r\n\r\n  /// @return the symbol of the token\r\n  function symbol() external view returns (string) { return mSymbol; }\r\n\r\n  /// @return the granularity of the token\r\n  function granularity() external view returns (uint256) { return mGranularity; }\r\n\r\n  /// @return the total supply of the token\r\n  function totalSupply() public view returns (uint256) { return mTotalSupply; }\r\n\r\n  /// @notice Return the account balance of some account\r\n  /// @param _tokenHolder Address for which the balance is returned\r\n  /// @return the balance of `_tokenAddress`.\r\n  function balanceOf(address _tokenHolder) public view returns (uint256) { return mBalances[_tokenHolder]; }\r\n\r\n  /// @notice Return the list of default operators\r\n  /// @return the list of all the default operators\r\n  function defaultOperators() external view returns (address[]) { return mDefaultOperators; }\r\n\r\n  /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens. An operator cannot be reauthorized\r\n  /// @param _operator The operator that wants to be Authorized\r\n  function authorizeOperator(address _operator) external {\r\n    require(_operator != msg.sender);\r\n    require(!mAuthorized[_operator][msg.sender]);\r\n\r\n    if (mIsDefaultOperator[_operator]) {\r\n      mRevokedDefaultOperator[_operator][msg.sender] = false;\r\n    } else {\r\n      mAuthorized[_operator][msg.sender] = true;\r\n    }\r\n    emit AuthorizedOperator(_operator, msg.sender);\r\n  }\r\n\r\n  /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\r\n  /// @param _operator The operator that wants to be Revoked\r\n  function revokeOperator(address _operator) external {\r\n    require(_operator != msg.sender);\r\n    require(mAuthorized[_operator][msg.sender]);\r\n\r\n    if (mIsDefaultOperator[_operator]) {\r\n      mRevokedDefaultOperator[_operator][msg.sender] = true;\r\n    } else {\r\n      mAuthorized[_operator][msg.sender] = false;\r\n    }\r\n    emit RevokedOperator(_operator, msg.sender);\r\n  }\r\n\r\n  /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\r\n  /// @param _operator address to check if it has the right to manage the tokens\r\n  /// @param _tokenHolder address which holds the tokens to be managed\r\n  /// @return `true` if `_operator` is authorized for `_tokenHolder`\r\n  function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\r\n    return (\r\n      _operator == _tokenHolder\r\n      || mAuthorized[_operator][_tokenHolder]\r\n      || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder])\r\n    );\r\n  }\r\n\r\n  /* -- Helper Functions -- */\r\n  //\r\n  /// @notice Internal function that ensures `_amount` is multiple of the granularity\r\n  /// @param _amount The quantity that want's to be checked\r\n  function requireMultiple(uint256 _amount) internal view {\r\n    require(_amount.div(mGranularity).mul(mGranularity) == _amount);\r\n  }\r\n\r\n  /// @notice Helper function actually performing the sending of tokens.\r\n  /// @param _operator The address performing the send\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n  ///  implementing `ERC777TokensRecipient`.\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function doSend(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  )\r\n    internal\r\n  {\r\n    requireMultiple(_amount);\r\n\r\n    callSender(_operator, _from, _to, _amount, _userData, _operatorData);\r\n\r\n    require(_to != address(0));          // forbid sending to 0x0 (=burning)\r\n    require(mBalances[_from] >= _amount); // ensure enough funds\r\n\r\n    mBalances[_from] = mBalances[_from].sub(_amount);\r\n    mBalances[_to] = mBalances[_to].add(_amount);\r\n\r\n    callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\r\n\r\n    emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);\r\n  }\r\n\r\n  /// @notice Helper function actually performing the burning of tokens.\r\n  /// @param _operator The address performing the burn\r\n  /// @param _tokenHolder The address holding the tokens being burn\r\n  /// @param _amount The number of tokens to be burnt\r\n  /// @param _holderData Data generated by the token holder\r\n  /// @param _operatorData Data generated by the operator\r\n  function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes _holderData, bytes _operatorData)\r\n    internal\r\n  {\r\n    requireMultiple(_amount);\r\n    require(balanceOf(_tokenHolder) >= _amount);\r\n\r\n    mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\r\n    mTotalSupply = mTotalSupply.sub(_amount);\r\n\r\n    callSender(_operator, _tokenHolder, 0x0, _amount, _holderData, _operatorData);\r\n    emit Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);\r\n  }\r\n\r\n  /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\r\n  ///  May throw according to `_preventLocking`\r\n  /// @param _operator The address performing the send or mint\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n  ///  implementing `ERC777TokensRecipient`.\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function callRecipient(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  )\r\n    internal\r\n  {\r\n    address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\r\n    if (recipientImplementation != 0) {\r\n      ERC777TokensRecipient(recipientImplementation).tokensReceived(\r\n        _operator, _from, _to, _amount, _userData, _operatorData);\r\n    } else if (_preventLocking) {\r\n      require(!_to.isContract());\r\n    }\r\n  }\r\n\r\n  /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\r\n  ///  May throw according to `_preventLocking`\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The amount of tokens to be sent\r\n  /// @param _userData Data generated by the user to be passed to the recipient\r\n  /// @param _operatorData Data generated by the operator to be passed to the recipient\r\n  ///  implementing `ERC777TokensSender`.\r\n  ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n  ///  functions SHOULD set this parameter to `false`.\r\n  function callSender(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData\r\n  )\r\n    internal\r\n  {\r\n    address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\r\n    if (senderImplementation == 0) {\r\n      return;\r\n    }\r\n    ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);\r\n  }\r\n}\r\n\r\n// File: contracts/ERC777/ERC777ERC20BaseToken.sol\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\r\n\r\n\r\n\r\n\r\ncontract ERC777ERC20BaseToken is ERC20Token, ERC777BaseToken {\r\n  bool internal mErc20compatible;\r\n\r\n  mapping(address => mapping(address => uint256)) internal mAllowed;\r\n\r\n  constructor(\r\n    string _name,\r\n    string _symbol,\r\n    uint256 _granularity,\r\n    address[] _defaultOperators\r\n  )\r\n    internal ERC777BaseToken(_name, _symbol, _granularity, _defaultOperators)\r\n  {\r\n    mErc20compatible = true;\r\n    setInterfaceImplementation(\"ERC20Token\", this);\r\n  }\r\n\r\n  /// @notice This modifier is applied to erc20 obsolete methods that are\r\n  ///  implemented only to maintain backwards compatibility. When the erc20\r\n  ///  compatibility is disabled, this methods will fail.\r\n  modifier erc20 () {\r\n    require(mErc20compatible);\r\n    _;\r\n  }\r\n\r\n  /// @notice For Backwards compatibility\r\n  /// @return The decimls of the token. Forced to 18 in ERC777.\r\n  function decimals() external erc20 view returns (uint8) { return uint8(18); }\r\n\r\n  /// @notice ERC20 backwards compatible transfer.\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be transferred\r\n  /// @return `true`, if the transfer can't be done, it should fail.\r\n  function transfer(address _to, uint256 _amount) public erc20 returns (bool success) {\r\n    doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\r\n    return true;\r\n  }\r\n\r\n  /// @notice ERC20 backwards compatible transferFrom.\r\n  /// @param _from The address holding the tokens being transferred\r\n  /// @param _to The address of the recipient\r\n  /// @param _amount The number of tokens to be transferred\r\n  /// @return `true`, if the transfer can't be done, it should fail.\r\n  function transferFrom(address _from, address _to, uint256 _amount) public erc20 returns (bool success) {\r\n    require(_amount <= mAllowed[_from][msg.sender]);\r\n\r\n    // Cannot be after doSend because of tokensReceived re-entry\r\n    mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\r\n    doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\r\n    return true;\r\n  }\r\n\r\n  /// @notice ERC20 backwards compatible approve.\r\n  ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _amount The number of tokens to be approved for transfer\r\n  /// @return `true`, if the approve can't be done, it should fail.\r\n  function approve(address _spender, uint256 _amount) public erc20 returns (bool success) {\r\n    mAllowed[msg.sender][_spender] = _amount;\r\n    emit Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /// @notice ERC20 backwards compatible allowance.\r\n  ///  This function makes it easy to read the `allowed[]` map\r\n  /// @param _owner The address of the account that owns the token\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n  ///  to spend\r\n  function allowance(address _owner, address _spender) public erc20 view returns (uint256 remaining) {\r\n    return mAllowed[_owner][_spender];\r\n  }\r\n\r\n  function doSend(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  )\r\n    internal\r\n  {\r\n    super.doSend(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\r\n    if (mErc20compatible) {\r\n      emit Transfer(_from, _to, _amount);\r\n    }\r\n  }\r\n\r\n  function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes _holderData, bytes _operatorData)\r\n    internal\r\n  {\r\n    super.doBurn(_operator, _tokenHolder, _amount, _holderData, _operatorData);\r\n    if (mErc20compatible) {\r\n      emit Transfer(_tokenHolder, 0x0, _amount);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/openzeppelin-solidity/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/openzeppelin-solidity/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/utils/Freezable.sol\r\n\r\n/// @title An inheritable extension for a contract to freeze accessibility of any specific addresses\r\n/// @author Jeff Hu\r\n/// @notice Have a contract inherited from this to use the modifiers: whenAccountFrozen(), whenAccountNotFrozen()\r\n/// @dev Concern: Ownable may cause multiple owners; You need to pass in msg.sender when using modifiers\r\ncontract Freezable is Ownable {\r\n\r\n  event AccountFrozen(address indexed _account);\r\n  event AccountUnfrozen(address indexed _account);\r\n\r\n  // frozen status of all accounts\r\n  mapping(address=>bool) public frozenAccounts;\r\n\r\n\r\n   /**\r\n   * @dev Modifier to make a function callable only when the address is frozen.\r\n   */\r\n  modifier whenAccountFrozen(address _account) {\r\n    require(frozenAccounts[_account] == true);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the address is not frozen.\r\n   */\r\n  modifier whenAccountNotFrozen(address _account) {\r\n    require(frozenAccounts[_account] == false);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Function to freeze an account from transactions\r\n   */\r\n  function freeze(address _account)\r\n    external\r\n    onlyOwner\r\n    whenAccountNotFrozen(_account)\r\n    returns (bool)\r\n  {\r\n    frozenAccounts[_account] = true;\r\n    emit AccountFrozen(_account);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to unfreeze an account form frozen state\r\n   */\r\n  function unfreeze(address _account)\r\n    external\r\n    onlyOwner\r\n    whenAccountFrozen(_account)\r\n    returns (bool)\r\n  {\r\n    frozenAccounts[_account] = false;\r\n    emit AccountUnfrozen(_account);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev A user can choose to freeze her account (not unfreezable)\r\n   */\r\n  function freezeMyAccount()\r\n    external\r\n    whenAccountNotFrozen(msg.sender)\r\n    returns (bool)\r\n  {\r\n    // require(msg.sender != owner);       // Only the owner cannot freeze herself\r\n\r\n    frozenAccounts[msg.sender] = true;\r\n    emit AccountFrozen(msg.sender);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/PausableFreezableERC777ERC20Token.sol\r\n\r\n/// @dev The owner can pause/unpause the token.\r\n/// When paused, all functions that may change the token balances are prohibited.\r\n/// Function approve is prohibited too.\r\ncontract PausableFreezableERC777ERC20Token is ERC777ERC20BaseToken, Pausable, Freezable {\r\n\r\n  // ERC777 methods\r\n\r\n  /// @dev We can not call super.send() because send() is an external function.\r\n  /// We can only override it.\r\n  function send(address _to, uint256 _amount, bytes _userData)\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_to)\r\n  {\r\n    doSend(msg.sender, msg.sender, _to, _amount, _userData, \"\", true);\r\n  }\r\n\r\n  function operatorSend(address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData)\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_from)\r\n    whenAccountNotFrozen(_to)\r\n  {\r\n    require(isOperatorFor(msg.sender, _from));\r\n    doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);\r\n  }\r\n\r\n  function burn(uint256 _amount, bytes _holderData)\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n  {\r\n    doBurn(msg.sender, msg.sender, _amount, _holderData, \"\");\r\n  }\r\n\r\n  function operatorBurn(address _tokenHolder, uint256 _amount, bytes _holderData, bytes _operatorData)\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_tokenHolder)\r\n  {\r\n    require(isOperatorFor(msg.sender, _tokenHolder));\r\n    doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);\r\n  }\r\n\r\n  // ERC20 methods\r\n\r\n  function transfer(address _to, uint256 _amount)\r\n    public\r\n    erc20\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_to)\r\n    returns (bool success)\r\n  {\r\n    return super.transfer(_to, _amount);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _amount)\r\n    public\r\n    erc20\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_from)\r\n    whenAccountNotFrozen(_to)\r\n    returns (bool success)\r\n  {\r\n    return super.transferFrom(_from, _to, _amount);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _amount)\r\n    public\r\n    erc20\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_spender)\r\n    returns (bool success)\r\n  {\r\n    return super.approve(_spender, _amount);\r\n  }\r\n\r\n  /// @dev allow Owner to transfer funds from a Frozen account\r\n  /// @notice the \"_from\" account must be frozen\r\n  /// @notice only the owner can trigger this function\r\n  /// @notice super.doSend to skip \"_from\" frozen checking\r\n  function transferFromFrozenAccount(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    whenAccountFrozen(_from)\r\n    whenAccountNotFrozen(_to)\r\n    whenAccountNotFrozen(msg.sender)\r\n  {\r\n    super.doSend(msg.sender, _from, _to, _amount, \"\", \"\", true);\r\n  }\r\n\r\n  function doSend(\r\n    address _operator,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes _userData,\r\n    bytes _operatorData,\r\n    bool _preventLocking\r\n  )\r\n    internal\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_operator)\r\n    whenAccountNotFrozen(_from)\r\n    whenAccountNotFrozen(_to)\r\n  {\r\n    super.doSend(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\r\n  }\r\n\r\n  function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes _holderData, bytes _operatorData)\r\n    internal\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_operator)\r\n    whenAccountNotFrozen(_tokenHolder)\r\n  {\r\n    super.doBurn(_operator, _tokenHolder, _amount, _holderData, _operatorData);\r\n  }\r\n}\r\n\r\n// File: contracts/ERC777ERC20TokenWithOfficialOperators.sol\r\n\r\n/// @title ERC777 ERC20 Token with Official Operators\r\n/// @author Roger-Wu\r\n/// @notice Official operators are officially recommended operator contracts.\r\n/// By adding new official operators, we can keep adding new features to\r\n/// an already deployed token contract, which can be viewed as a way to\r\n/// upgrade the token contract.\r\n/// Rules of official operators:\r\n/// 1. An official operator must be a contract.\r\n/// 2. An official operator can only be added or removed by the contract owner.\r\n/// 3. A token holder can either accept all official operators or not.\r\n///    By default, a token holder accepts all official operators, including\r\n///    the official operators added in the future.\r\n/// 4. If a token holder accepts all official operators, it works as if all\r\n///    the addresses of official operators has been authorized to be his operator.\r\n///    In this case, an official operator will always be the token holder's\r\n///    operator even if he tries to revoke it by sending `revokeOperator` transactions.\r\n/// 5. If a token holder chooses not to accept all official operators, it works as if\r\n///    there is no official operator at all for him. The token holder can still authorize\r\n///    any addresses, including which of official operators, to be his operators.\r\ncontract ERC777ERC20TokenWithOfficialOperators is ERC777ERC20BaseToken, Ownable {\r\n  using Address for address;\r\n\r\n  mapping(address => bool) internal mIsOfficialOperator;\r\n  mapping(address => bool) internal mIsUserNotAcceptingAllOfficialOperators;\r\n\r\n  event OfficialOperatorAdded(address operator);\r\n  event OfficialOperatorRemoved(address operator);\r\n  event OfficialOperatorsAcceptedByUser(address indexed user);\r\n  event OfficialOperatorsRejectedByUser(address indexed user);\r\n\r\n  /// @notice Add an address into the list of official operators.\r\n  /// @param _operator The address of a new official operator.\r\n  /// An official operator must be a contract.\r\n  function addOfficialOperator(address _operator) external onlyOwner {\r\n    require(_operator.isContract(), \"An official operator must be a contract.\");\r\n    require(!mIsOfficialOperator[_operator], \"_operator is already an official operator.\");\r\n\r\n    mIsOfficialOperator[_operator] = true;\r\n    emit OfficialOperatorAdded(_operator);\r\n  }\r\n\r\n  /// @notice Delete an address from the list of official operators.\r\n  /// @param _operator The address of an official operator.\r\n  function removeOfficialOperator(address _operator) external onlyOwner {\r\n    require(mIsOfficialOperator[_operator], \"_operator is not an official operator.\");\r\n\r\n    mIsOfficialOperator[_operator] = false;\r\n    emit OfficialOperatorRemoved(_operator);\r\n  }\r\n\r\n  /// @notice Unauthorize all official operators to manage `msg.sender`'s tokens.\r\n  function rejectAllOfficialOperators() external {\r\n    require(!mIsUserNotAcceptingAllOfficialOperators[msg.sender], \"Official operators are already rejected by msg.sender.\");\r\n\r\n    mIsUserNotAcceptingAllOfficialOperators[msg.sender] = true;\r\n    emit OfficialOperatorsRejectedByUser(msg.sender);\r\n  }\r\n\r\n  /// @notice Authorize all official operators to manage `msg.sender`'s tokens.\r\n  function acceptAllOfficialOperators() external {\r\n    require(mIsUserNotAcceptingAllOfficialOperators[msg.sender], \"Official operators are already accepted by msg.sender.\");\r\n\r\n    mIsUserNotAcceptingAllOfficialOperators[msg.sender] = false;\r\n    emit OfficialOperatorsAcceptedByUser(msg.sender);\r\n  }\r\n\r\n  /// @return true if the address is an official operator, false if not.\r\n  function isOfficialOperator(address _operator) external view returns(bool) {\r\n    return mIsOfficialOperator[_operator];\r\n  }\r\n\r\n  /// @return true if a user is accepting all official operators, false if not.\r\n  function isUserAcceptingAllOfficialOperators(address _user) external view returns(bool) {\r\n    return !mIsUserNotAcceptingAllOfficialOperators[_user];\r\n  }\r\n\r\n  /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\r\n  /// @param _operator address to check if it has the right to manage the tokens\r\n  /// @param _tokenHolder address which holds the tokens to be managed\r\n  /// @return `true` if `_operator` is authorized for `_tokenHolder`\r\n  function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\r\n    return (\r\n      _operator == _tokenHolder\r\n      || (!mIsUserNotAcceptingAllOfficialOperators[_tokenHolder] && mIsOfficialOperator[_operator])\r\n      || mAuthorized[_operator][_tokenHolder]\r\n      || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder])\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/ApprovalRecipient.sol\r\n\r\ninterface ApprovalRecipient {\r\n  function receiveApproval(\r\n    address _from,\r\n    uint256 _value,\r\n    address _token,\r\n    bytes _extraData\r\n  ) external;\r\n}\r\n\r\n// File: contracts/ERC777ERC20TokenWithApproveAndCall.sol\r\n\r\ncontract ERC777ERC20TokenWithApproveAndCall is PausableFreezableERC777ERC20Token {\r\n  /// Set allowance for other address and notify\r\n  /// Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n  /// From https://www.ethereum.org/token\r\n  /// @param _spender The address authorized to spend\r\n  /// @param _value the max amount they can spend\r\n  /// @param _extraData some extra information to send to the approved contract\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_spender)\r\n    returns (bool success)\r\n  {\r\n    ApprovalRecipient spender = ApprovalRecipient(_spender);\r\n    if (approve(_spender, _value)) {\r\n      spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ERC777ERC20TokenWithBatchTransfer.sol\r\n\r\ncontract ERC777ERC20TokenWithBatchTransfer is PausableFreezableERC777ERC20Token {\r\n  /// @notice ERC20 backwards compatible batch transfer.\r\n  /// The transaction will revert if any of the recipients is frozen.\r\n  /// We check whether a recipient is frozen in `doSend`.\r\n  /// @param _recipients The addresses of the recipients\r\n  /// @param _amounts The numbers of tokens to be transferred\r\n  /// @return `true`, if the transfer can't be done, it should fail.\r\n  function batchTransfer(address[] _recipients, uint256[] _amounts)\r\n    external\r\n    erc20\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    returns (bool success)\r\n  {\r\n    require(\r\n      _recipients.length == _amounts.length,\r\n      \"The lengths of _recipients and _amounts should be the same.\"\r\n    );\r\n\r\n    for (uint256 i = 0; i < _recipients.length; i++) {\r\n      doSend(msg.sender, msg.sender, _recipients[i], _amounts[i], \"\", \"\", false);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @notice Send tokens to multiple recipients.\r\n  /// The transaction will revert if any of the recipients is frozen.\r\n  /// We check whether a recipient is frozen in `doSend`.\r\n  /// @param _recipients The addresses of the recipients\r\n  /// @param _amounts The numbers of tokens to be transferred\r\n  /// @param _userData Data generated by the user to be sent to the recipient\r\n  function batchSend(\r\n    address[] _recipients,\r\n    uint256[] _amounts,\r\n    bytes _userData\r\n  )\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n  {\r\n    require(\r\n      _recipients.length == _amounts.length,\r\n      \"The lengths of _recipients and _amounts should be the same.\"\r\n    );\r\n\r\n    for (uint256 i = 0; i < _recipients.length; i++) {\r\n      doSend(msg.sender, msg.sender, _recipients[i], _amounts[i], _userData, \"\", true);\r\n    }\r\n  }\r\n\r\n  /// @notice Send tokens to multiple recipients on behalf of the address `from`\r\n  /// The transaction will revert if any of the recipients is frozen.\r\n  /// We check whether a recipient is frozen in `doSend`.\r\n  /// @param _from The address holding the tokens being sent\r\n  /// @param _recipients The addresses of the recipients\r\n  /// @param _amounts The numbers of tokens to be transferred\r\n  /// @param _userData Data generated by the user to be sent to the recipient\r\n  /// @param _operatorData Data generated by the operator to be sent to the recipient\r\n  function operatorBatchSend(\r\n    address _from,\r\n    address[] _recipients,\r\n    uint256[] _amounts,\r\n    bytes _userData,\r\n    bytes _operatorData\r\n  )\r\n    external\r\n    whenNotPaused\r\n    whenAccountNotFrozen(msg.sender)\r\n    whenAccountNotFrozen(_from)\r\n  {\r\n    require(\r\n      _recipients.length == _amounts.length,\r\n      \"The lengths of _recipients and _amounts should be the same.\"\r\n    );\r\n    require(isOperatorFor(msg.sender, _from));\r\n\r\n    for (uint256 i = 0; i < _recipients.length; i++) {\r\n      doSend(msg.sender, _from, _recipients[i], _amounts[i], _userData, _operatorData, true);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/CappedMintableERC777ERC20Token.sol\r\n\r\n/// @title Capped Mintable ERC777 ERC20 Token\r\n/// @author Roger-Wu\r\n/// @dev Mintable token with a minting cap.\r\n///  The owner can mint any amount of tokens until the cap is reached.\r\ncontract CappedMintableERC777ERC20Token is ERC777ERC20BaseToken, Ownable {\r\n  uint256 internal mTotalSupplyCap;\r\n\r\n  constructor(uint256 _totalSupplyCap) public {\r\n    mTotalSupplyCap = _totalSupplyCap;\r\n  }\r\n\r\n  /// @return the cap of total supply\r\n  function totalSupplyCap() external view returns(uint _totalSupplyCap) {\r\n    return mTotalSupplyCap;\r\n  }\r\n\r\n  /// @dev Generates `_amount` tokens to be assigned to `_tokenHolder`\r\n  ///  Sample mint function to showcase the use of the `Minted` event and the logic to notify the recipient.\r\n  ///  Reference: https://github.com/jacquesd/ERC777/blob/devel/contracts/examples/SelfToken.sol\r\n  /// @param _tokenHolder The address that will be assigned the new tokens\r\n  /// @param _amount The quantity of tokens generated\r\n  /// @param _operatorData Data that will be passed to the recipient as a first transfer\r\n  function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) external onlyOwner {\r\n    requireMultiple(_amount);\r\n    require(mTotalSupply.add(_amount) <= mTotalSupplyCap);\r\n\r\n    mTotalSupply = mTotalSupply.add(_amount);\r\n    mBalances[_tokenHolder] = mBalances[_tokenHolder].add(_amount);\r\n\r\n    callRecipient(msg.sender, address(0), _tokenHolder, _amount, \"\", _operatorData, true);\r\n\r\n    emit Minted(msg.sender, _tokenHolder, _amount, _operatorData);\r\n    if (mErc20compatible) {\r\n      emit Transfer(0x0, _tokenHolder, _amount);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ERC777ERC20TokenWithOperatorApprove.sol\r\n\r\n/// @title ERC777 ERC20 Token with Operator Approve\r\n/// @author Roger-Wu\r\n/// @notice Allow an operator to approve tokens for a token holder.\r\ncontract ERC777ERC20TokenWithOperatorApprove is ERC777ERC20BaseToken {\r\n  function operatorApprove(\r\n    address _tokenHolder,\r\n    address _spender,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    erc20\r\n    returns (bool success)\r\n  {\r\n    require(\r\n      isOperatorFor(msg.sender, _tokenHolder),\r\n      \"msg.sender is not an operator for _tokenHolder\"\r\n    );\r\n\r\n    mAllowed[_tokenHolder][_spender] = _amount;\r\n    emit Approval(_tokenHolder, _spender, _amount);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/openzeppelin-solidity/ownership/Claimable.sol\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// File: contracts/SelfToken.sol\r\n\r\n/// @title SelfToken\r\n/// @author Roger Wu (Roger-Wu), Tina Lee (tina1998612), Jeff Hu (yhuag)\r\n/// @dev The inheritance order is important.\r\ncontract SelfToken is\r\n  ERC777ERC20BaseToken,\r\n  PausableFreezableERC777ERC20Token,\r\n  ERC777ERC20TokenWithOfficialOperators,\r\n  ERC777ERC20TokenWithApproveAndCall,\r\n  ERC777ERC20TokenWithBatchTransfer,\r\n  CappedMintableERC777ERC20Token,\r\n  ERC777ERC20TokenWithOperatorApprove,\r\n  Claimable\r\n{\r\n  constructor()\r\n    public\r\n    ERC777ERC20BaseToken(\"SELF TOKEN\", \"SELF\", 1, new address[](0))\r\n    CappedMintableERC777ERC20Token(1e9 * 1e18)\r\n  {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"defaultOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"operatorApprove\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addOfficialOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeMyAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"batchSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unfreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFromFrozenAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rejectAllOfficialOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isOfficialOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptAllOfficialOperators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeOfficialOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyCap\",\"outputs\":[{\"name\":\"_totalSupplyCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isUserAcceptingAllOfficialOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_userData\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBatchSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_holderData\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_holderData\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OfficialOperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OfficialOperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"OfficialOperatorsAcceptedByUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"OfficialOperatorsRejectedByUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"AccountFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"AccountUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"holderData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"holderData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SelfToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ce7b008a531dcb9b84c92c7c60cb3ec229eb837fdff63e98d15b3194279d143d"}]}