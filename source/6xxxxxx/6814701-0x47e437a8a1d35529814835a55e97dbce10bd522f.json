{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Kryptium Oracle Smart Contract v.1.0.0\r\n * Copyright © 2018 Kryptium Team <info@kryptium.io>\r\n * Author: Giannis Zarifis <jzarifis@kryptium.io>\r\n * \r\n * The Oracle smart contract is used by the House smart contract (and, in turn, \r\n * the betting app) as a “trusted source of truth” for upcoming events and their \r\n * outcomes. It is managed by an entity trusted by the owner of the House.\r\n *\r\n * This program is free to use according the Terms and Conditions available at\r\n * <https://kryptium.io/terms-and-conditions/>. You cannot resell it or copy any\r\n * part of it or modify it without permission from the Kryptium Team.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT \r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the Terms and Conditions for more details.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * SafeMath\r\n * Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b != 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mulByFraction(uint256 number, uint256 numerator, uint256 denominator) internal pure returns (uint256) {\r\n        return div(mul(number, numerator), denominator);\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0x0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*\r\n * Kryptium Oracle Smart Contract.  \r\n */\r\ncontract Oracle is SafeMath, Owned {\r\n\r\n    enum EventOutputType { stringarray, numeric }\r\n\r\n    uint private eventNextId;\r\n    uint private subcategoryNextId;\r\n\r\n    struct Event { \r\n        uint id;\r\n        string  title;\r\n        uint  startDateTime;   \r\n        uint  endDateTime;\r\n        uint  subcategoryId;   \r\n        uint  categoryId;   \r\n        uint closeDateTime;     \r\n        uint freezeDateTime;\r\n        bool isCancelled;\r\n        string announcement;\r\n        uint totalAvailableOutputs;\r\n    } \r\n\r\n    struct EventOutcome {\r\n        uint256 outcome1;\r\n        uint256 outcome2;\r\n        uint256 outcome3;\r\n        uint256 outcome4;\r\n        uint256 outcome5;\r\n        uint256 outcome6;\r\n    }\r\n\r\n\r\n\r\n    struct EventOutput {\r\n        bool isSet;\r\n        string title;\r\n        uint possibleResultsCount;\r\n        EventOutputType  eventOutputType;\r\n        string announcement; \r\n        uint decimals;\r\n    }\r\n\r\n\r\n    struct OracleData { \r\n        string  name;\r\n        string  creatorName;\r\n        uint  closeBeforeStartTime;   \r\n        uint  closeEventOutcomeTime;\r\n        uint version;      \r\n    } \r\n\r\n    struct Subcategory {\r\n        uint id;\r\n        uint  categoryId; \r\n        string name;\r\n        string country;\r\n        bool hidden;\r\n    }\r\n\r\n    OracleData public oracleData;  \r\n\r\n    // This creates an array with all sucategories\r\n    mapping (uint => Subcategory) public subcategories;\r\n\r\n    // This creates an array with all events\r\n    mapping (uint => Event) public events;\r\n\r\n    // Event output possible results\r\n    mapping (uint =>mapping (uint => mapping (uint => bytes32))) public eventOutputPossibleResults;  \r\n\r\n    // Event output Outcome\r\n    mapping (uint => mapping (uint => EventOutput)) public eventOutputs;\r\n\r\n    //Event output outcome\r\n    mapping (uint => mapping (uint => uint)) public eventOutcome;\r\n\r\n    //Event output outcome numeric\r\n    mapping (uint => mapping (uint => EventOutcome)) public eventNumericOutcomes;\r\n\r\n\r\n\r\n    // Notifies clients that a new Oracle was launched\r\n    event OracleCreated();\r\n\r\n    // Notifies clients that the details of an Oracle were changed\r\n    event OraclePropertiesUpdated();    \r\n\r\n    // Notifies clients that an Oracle subcategory was added\r\n    event OracleSubcategoryAdded(uint id);    \r\n\r\n    // Notifies clients that an Oracle subcategory was changed\r\n    event OracleSubcategoryUpdated(uint id);    \r\n    \r\n    // Notifies clients that an Oracle Event was changed\r\n    event UpcomingEventUpdated(uint id,uint closeDateTime);\r\n\r\n\r\n\r\n    /**\r\n     * Constructor function\r\n     * Initializes Oracle contract\r\n     */\r\n    constructor(string memory oracleName, string memory oracleCreatorName, uint closeBeforeStartTime, uint closeEventOutcomeTime, uint version) public {\r\n        oracleData.name = oracleName;\r\n        oracleData.creatorName = oracleCreatorName;\r\n        oracleData.closeBeforeStartTime = closeBeforeStartTime;\r\n        oracleData.closeEventOutcomeTime = closeEventOutcomeTime;\r\n        oracleData.version = version;\r\n        emit OracleCreated();\r\n    }\r\n\r\n     /**\r\n     * Update Oracle Data function\r\n     *\r\n     * Updates Oracle Data\r\n     */\r\n    function updateOracleNames(string memory newName, string memory newCreatorName) onlyOwner public {\r\n        oracleData.name = newName;\r\n        oracleData.creatorName = newCreatorName;\r\n        emit OraclePropertiesUpdated();\r\n    }    \r\n\r\n     /**\r\n     * Update Oracle Time Constants function\r\n     *\r\n     * Updates Oracle Time Constants\r\n     */\r\n    function setTimeConstants(uint closeBeforeStartTime, uint closeEventOutcomeTime) onlyOwner public {\r\n        oracleData.closeBeforeStartTime = closeBeforeStartTime;\r\n        oracleData.closeEventOutcomeTime = closeEventOutcomeTime;\r\n        emit OraclePropertiesUpdated();\r\n    }      \r\n\r\n\r\n    /**\r\n     * Adds an Oracle Subcategory\r\n     */\r\n    function setSubcategory(uint id, uint categoryId, string memory name,string memory country,bool hidden) onlyOwner public {\r\n        if (id==0) {\r\n            subcategoryNextId += 1;\r\n            id = subcategoryNextId;\r\n        }\r\n        subcategories[id].id = id;\r\n        subcategories[id].categoryId = categoryId;\r\n        subcategories[id].name = name;\r\n        subcategories[id].country = country;\r\n        subcategories[id].hidden = hidden;\r\n        emit OracleSubcategoryAdded(id);\r\n    }  \r\n\r\n    /**\r\n     * Hides an Oracle Subcategory\r\n     */\r\n    function hideSubcategory(uint id) onlyOwner public {\r\n        subcategories[id].hidden = true;\r\n        emit OracleSubcategoryUpdated(id);\r\n    }   \r\n\r\n\r\n    /**\r\n     * Adds an Upcoming Event\r\n     */\r\n    function addUpcomingEvent(uint id, string memory title, uint startDateTime, uint endDateTime, uint subcategoryId, uint categoryId, string memory outputTitle, EventOutputType eventOutputType, bytes32[] memory _possibleResults,uint decimals) onlyOwner public {        \r\n        if (id==0) {\r\n            eventNextId += 1;\r\n            id = eventNextId;\r\n        }\r\n        \r\n        uint closeDateTime = startDateTime - oracleData.closeBeforeStartTime * 1 minutes;\r\n        uint freezeDateTime = endDateTime + oracleData.closeEventOutcomeTime * 1 minutes;\r\n        require(closeDateTime >= now,\"Close time should be greater than now\");\r\n        events[id].id = id;\r\n        events[id].title = title;\r\n        events[id].startDateTime = startDateTime;\r\n        events[id].endDateTime = endDateTime;\r\n        events[id].subcategoryId = subcategoryId;\r\n        events[id].categoryId = categoryId;\r\n        events[id].closeDateTime = closeDateTime;\r\n        events[id].freezeDateTime = freezeDateTime;\r\n        eventOutputs[id][0].title = outputTitle;\r\n        eventOutputs[id][0].possibleResultsCount = _possibleResults.length;\r\n        eventOutputs[id][0].eventOutputType = eventOutputType;\r\n        eventOutputs[id][0].decimals = decimals;\r\n        for (uint j = 0; j<_possibleResults.length; j++) {\r\n            eventOutputPossibleResults[id][0][j] = _possibleResults[j];            \r\n        }\r\n        if (events[id].totalAvailableOutputs < 1) {\r\n            events[id].totalAvailableOutputs = 1;\r\n        }      \r\n        emit UpcomingEventUpdated(id,closeDateTime);\r\n    }  \r\n\r\n    /**\r\n     * Adds a new output to existing an Upcoming Event\r\n     */\r\n    function addUpcomingEventOutput(uint id, string memory outputTitle, EventOutputType eventOutputType, bytes32[] memory _possibleResults,uint decimals) onlyOwner public {\r\n        require(events[id].closeDateTime >= now,\"Close time should be greater than now\");\r\n        eventOutputs[id][events[id].totalAvailableOutputs].title = outputTitle;\r\n        eventOutputs[id][events[id].totalAvailableOutputs].possibleResultsCount = _possibleResults.length;\r\n        eventOutputs[id][events[id].totalAvailableOutputs].eventOutputType = eventOutputType;\r\n        eventOutputs[id][events[id].totalAvailableOutputs].decimals = decimals;\r\n        for (uint j = 0; j<_possibleResults.length; j++) {\r\n            eventOutputPossibleResults[id][events[id].totalAvailableOutputs][j] = _possibleResults[j];\r\n        }  \r\n        events[id].totalAvailableOutputs += 1;             \r\n        emit UpcomingEventUpdated(id,events[id].closeDateTime);\r\n    }\r\n\r\n    /**\r\n     * Updates an Upcoming Event\r\n     */\r\n    function updateUpcomingEvent(uint id, string memory title, uint startDateTime, uint endDateTime, uint subcategoryId, uint categoryId) onlyOwner public {\r\n        uint closeDateTime = startDateTime - oracleData.closeBeforeStartTime * 1 minutes;\r\n        uint freezeDateTime = endDateTime + oracleData.closeEventOutcomeTime * 1 minutes;\r\n        events[id].title = title;\r\n        events[id].startDateTime = startDateTime;\r\n        events[id].endDateTime = endDateTime;\r\n        events[id].subcategoryId = subcategoryId;\r\n        events[id].categoryId = categoryId;\r\n        events[id].closeDateTime = closeDateTime;\r\n        events[id].freezeDateTime = freezeDateTime;\r\n        if (closeDateTime < now) {\r\n            events[id].isCancelled = true;\r\n        }  \r\n        emit UpcomingEventUpdated(id,closeDateTime); \r\n    }     \r\n\r\n    /**\r\n     * Cancels an Upcoming Event\r\n     */\r\n    function cancelUpcomingEvent(uint id) onlyOwner public {\r\n        require(events[id].freezeDateTime >= now,\"Freeze time should be greater than now\");\r\n        events[id].isCancelled = true;\r\n        emit UpcomingEventUpdated(id,events[id].closeDateTime); \r\n    }  \r\n\r\n\r\n    /**\r\n     * Set the numeric type outcome of Event output\r\n     */\r\n    function setEventOutcomeNumeric(uint eventId, uint outputId, string memory announcement, bool setEventAnnouncement, uint256 outcome1, uint256 outcome2,uint256 outcome3,uint256 outcome4, uint256 outcome5, uint256 outcome6) onlyOwner public {\r\n        require(events[eventId].freezeDateTime > now,\"Freeze time should be greater than now\");\r\n        require(!events[eventId].isCancelled,\"Cancelled Event\");\r\n        require(eventOutputs[eventId][outputId].eventOutputType == EventOutputType.numeric,\"Required numeric Event type\");\r\n        eventNumericOutcomes[eventId][outputId].outcome1 = outcome1;\r\n        eventNumericOutcomes[eventId][outputId].outcome2 = outcome2;\r\n        eventNumericOutcomes[eventId][outputId].outcome3 = outcome3;\r\n        eventNumericOutcomes[eventId][outputId].outcome4 = outcome4;\r\n        eventNumericOutcomes[eventId][outputId].outcome5 = outcome5;\r\n        eventNumericOutcomes[eventId][outputId].outcome6 = outcome6;\r\n        eventOutputs[eventId][outputId].isSet = true;\r\n        eventOutputs[eventId][outputId].announcement = announcement;\r\n        if (setEventAnnouncement) {\r\n            events[eventId].announcement = announcement;\r\n        }     \r\n        emit UpcomingEventUpdated(eventId,events[eventId].closeDateTime); \r\n    }  \r\n\r\n     /**\r\n     * Set the outcome of Event output\r\n     */\r\n    function setEventOutcome(uint eventId, uint outputId, string memory announcement, bool setEventAnnouncement, uint _eventOutcome ) onlyOwner public {\r\n        require(events[eventId].freezeDateTime > now,\"Freeze time should be greater than now\");\r\n        require(!events[eventId].isCancelled,\"Cancelled Event\");\r\n        require(eventOutputs[eventId][outputId].eventOutputType == EventOutputType.stringarray,\"Required array of options Event type\");\r\n        eventOutputs[eventId][outputId].isSet = true;\r\n        eventOutcome[eventId][outputId] = _eventOutcome;\r\n        eventOutputs[eventId][outputId].announcement = announcement;\r\n        if (setEventAnnouncement) {\r\n            events[eventId].announcement = announcement;\r\n        } \r\n        emit UpcomingEventUpdated(eventId,events[eventId].closeDateTime); \r\n    } \r\n\r\n\r\n    /**\r\n     * set a new freeze datetime of an Event\r\n     */\r\n    function freezeEventOutcome(uint id, uint newFreezeDateTime) onlyOwner public {\r\n        require(!events[id].isCancelled,\"Cancelled Event\");\r\n        if (newFreezeDateTime > now) {\r\n            events[id].freezeDateTime = newFreezeDateTime;\r\n        } else {\r\n            events[id].freezeDateTime = now;\r\n        }\r\n        emit UpcomingEventUpdated(id,events[id].closeDateTime);\r\n    } \r\n\r\n    /**\r\n     * Get event outcome numeric\r\n     */\r\n    function getEventOutcomeNumeric(uint eventId, uint outputId) public view returns(uint256 outcome1, uint256 outcome2,uint256 outcome3,uint256 outcome4, uint256 outcome5, uint256 outcome6) {\r\n        require(eventOutputs[eventId][outputId].isSet && eventOutputs[eventId][outputId].eventOutputType==EventOutputType.numeric);\r\n        return (eventNumericOutcomes[eventId][outputId].outcome1,eventNumericOutcomes[eventId][outputId].outcome2,eventNumericOutcomes[eventId][outputId].outcome3,eventNumericOutcomes[eventId][outputId].outcome4,eventNumericOutcomes[eventId][outputId].outcome5,eventNumericOutcomes[eventId][outputId].outcome6);\r\n    }\r\n\r\n    /**\r\n     * Get event outcome\r\n     */\r\n    function getEventOutcome(uint eventId, uint outputId) public view returns(uint outcome) {\r\n        require(eventOutputs[eventId][outputId].isSet && eventOutputs[eventId][outputId].eventOutputType==EventOutputType.stringarray);\r\n        return (eventOutcome[eventId][outputId]);\r\n    }\r\n\r\n     /**\r\n     * Get event outcome is Set\r\n     */\r\n    function getEventOutcomeIsSet(uint eventId, uint outputId) public view returns(bool isSet) {\r\n        return (eventOutputs[eventId][outputId].isSet);\r\n    }\r\n\r\n\r\n    /**\r\n     * Get event Info for Houses\r\n     */\r\n    function getEventForHousePlaceBet(uint id) public view returns(uint closeDateTime, uint freezeDateTime, bool isCancelled) {\r\n        return (events[id].closeDateTime,events[id].freezeDateTime, events[id].isCancelled);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"}],\"name\":\"getEventOutcome\",\"outputs\":[{\"name\":\"outcome\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"events\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"startDateTime\",\"type\":\"uint256\"},{\"name\":\"endDateTime\",\"type\":\"uint256\"},{\"name\":\"subcategoryId\",\"type\":\"uint256\"},{\"name\":\"categoryId\",\"type\":\"uint256\"},{\"name\":\"closeDateTime\",\"type\":\"uint256\"},{\"name\":\"freezeDateTime\",\"type\":\"uint256\"},{\"name\":\"isCancelled\",\"type\":\"bool\"},{\"name\":\"announcement\",\"type\":\"string\"},{\"name\":\"totalAvailableOutputs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subcategories\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"categoryId\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"country\",\"type\":\"string\"},{\"name\":\"hidden\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"outputTitle\",\"type\":\"string\"},{\"name\":\"eventOutputType\",\"type\":\"uint8\"},{\"name\":\"_possibleResults\",\"type\":\"bytes32[]\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"addUpcomingEventOutput\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"startDateTime\",\"type\":\"uint256\"},{\"name\":\"endDateTime\",\"type\":\"uint256\"},{\"name\":\"subcategoryId\",\"type\":\"uint256\"},{\"name\":\"categoryId\",\"type\":\"uint256\"}],\"name\":\"updateUpcomingEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleData\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"creatorName\",\"type\":\"string\"},{\"name\":\"closeBeforeStartTime\",\"type\":\"uint256\"},{\"name\":\"closeEventOutcomeTime\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getEventForHousePlaceBet\",\"outputs\":[{\"name\":\"closeDateTime\",\"type\":\"uint256\"},{\"name\":\"freezeDateTime\",\"type\":\"uint256\"},{\"name\":\"isCancelled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"categoryId\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"country\",\"type\":\"string\"},{\"name\":\"hidden\",\"type\":\"bool\"}],\"name\":\"setSubcategory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"newFreezeDateTime\",\"type\":\"uint256\"}],\"name\":\"freezeEventOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"hideSubcategory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelUpcomingEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"announcement\",\"type\":\"string\"},{\"name\":\"setEventAnnouncement\",\"type\":\"bool\"},{\"name\":\"_eventOutcome\",\"type\":\"uint256\"}],\"name\":\"setEventOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"closeBeforeStartTime\",\"type\":\"uint256\"},{\"name\":\"closeEventOutcomeTime\",\"type\":\"uint256\"}],\"name\":\"setTimeConstants\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"}],\"name\":\"getEventOutcomeIsSet\",\"outputs\":[{\"name\":\"isSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"}],\"name\":\"getEventOutcomeNumeric\",\"outputs\":[{\"name\":\"outcome1\",\"type\":\"uint256\"},{\"name\":\"outcome2\",\"type\":\"uint256\"},{\"name\":\"outcome3\",\"type\":\"uint256\"},{\"name\":\"outcome4\",\"type\":\"uint256\"},{\"name\":\"outcome5\",\"type\":\"uint256\"},{\"name\":\"outcome6\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventOutputPossibleResults\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"announcement\",\"type\":\"string\"},{\"name\":\"setEventAnnouncement\",\"type\":\"bool\"},{\"name\":\"outcome1\",\"type\":\"uint256\"},{\"name\":\"outcome2\",\"type\":\"uint256\"},{\"name\":\"outcome3\",\"type\":\"uint256\"},{\"name\":\"outcome4\",\"type\":\"uint256\"},{\"name\":\"outcome5\",\"type\":\"uint256\"},{\"name\":\"outcome6\",\"type\":\"uint256\"}],\"name\":\"setEventOutcomeNumeric\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"startDateTime\",\"type\":\"uint256\"},{\"name\":\"endDateTime\",\"type\":\"uint256\"},{\"name\":\"subcategoryId\",\"type\":\"uint256\"},{\"name\":\"categoryId\",\"type\":\"uint256\"},{\"name\":\"outputTitle\",\"type\":\"string\"},{\"name\":\"eventOutputType\",\"type\":\"uint8\"},{\"name\":\"_possibleResults\",\"type\":\"bytes32[]\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"addUpcomingEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventOutcome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventNumericOutcomes\",\"outputs\":[{\"name\":\"outcome1\",\"type\":\"uint256\"},{\"name\":\"outcome2\",\"type\":\"uint256\"},{\"name\":\"outcome3\",\"type\":\"uint256\"},{\"name\":\"outcome4\",\"type\":\"uint256\"},{\"name\":\"outcome5\",\"type\":\"uint256\"},{\"name\":\"outcome6\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventOutputs\",\"outputs\":[{\"name\":\"isSet\",\"type\":\"bool\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"possibleResultsCount\",\"type\":\"uint256\"},{\"name\":\"eventOutputType\",\"type\":\"uint8\"},{\"name\":\"announcement\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newName\",\"type\":\"string\"},{\"name\":\"newCreatorName\",\"type\":\"string\"}],\"name\":\"updateOracleNames\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"oracleName\",\"type\":\"string\"},{\"name\":\"oracleCreatorName\",\"type\":\"string\"},{\"name\":\"closeBeforeStartTime\",\"type\":\"uint256\"},{\"name\":\"closeEventOutcomeTime\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OracleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OraclePropertiesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OracleSubcategoryAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OracleSubcategoryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closeDateTime\",\"type\":\"uint256\"}],\"name\":\"UpcomingEventUpdated\",\"type\":\"event\"}]","ContractName":"Oracle","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000003c0000000000000000000000000000000000000000000000000000000000000066000000000000000000000000000000000000000000000000000000000000000d4e6577426574204576656e747300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b4e6577426574205465616d000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://479a08220aeb20837c6fa0f7ed6854624de0e25960dc9072185b1ff6bd0c2cb4"}]}