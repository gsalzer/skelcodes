{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/***\r\n * @title -ETH4 v0.1.0\r\n * \r\n *\r\n * .----------------.  .----------------.  .----------------.  .----------------. \r\n * | .--------------. || .--------------. || .--------------. || .--------------. |\r\n * | |  _________   | || |  _________   | || |  ____  ____  | || |   _    _     | |\r\n * | | |_   ___  |  | || | |  _   _  |  | || | |_   ||   _| | || |  | |  | |    | |\r\n * | |   | |_  \\_|  | || | |_/ | | \\_|  | || |   | |__| |   | || |  | |__| |_   | |\r\n * | |   |  _|  _   | || |     | |      | || |   |  __  |   | || |  |____   _|  | |\r\n * | |  _| |___/ |  | || |    _| |_     | || |  _| |  | |_  | || |      _| |_   | |\r\n * | | |_________|  | || |   |_____|    | || | |____||____| | || |     |_____|  | |\r\n * | |              | || |              | || |              | || |              | |\r\n * | '--------------' || '--------------' || '--------------' || '--------------' |\r\n * '----------------'  '----------------'  '----------------'  '----------------' \r\n *                                  ┌───────────────────────────────────────┐  \r\n *                                  │   Website:  http://Eth4.club          │\r\n *                                  │   Discord:  https://discord.gg/Uj72bZR│  \r\n *                                  │   Telegram: https://t.me/eth4_club    │\r\n *                                  │CN Telegram: https://t.me/eth4_club_CN │\r\n *                                  │RU Telegram: https://t.me/Eth4_Club_RU │\r\n *                                  └───────────────────────────────────────┘  \r\n *\r\n * This product is provided for public use without any guarantee or recourse to appeal\r\n * \r\n * Payouts are collectible daily after 00:00 UTC\r\n * Referral rewards are distributed automatically.\r\n * The last 5 in before 00:00 UTC win the midnight prize.\r\n * \r\n * By sending ETH to this contract you are agreeing to the terms set out in the logic listed below.\r\n *\r\n * WARNING1:  Do not invest more than you can afford. \r\n * WARNING2:  You can earn. \r\n */\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n/***\r\n *     __ __  __  _ __  _    ___ __  __  _ _____ ___  __   ________\r\n *    |  V  |/  \\| |  \\| |  / _//__\\|  \\| |_   _| _ \\/  \\ / _/_   _|\r\n *    | \\_/ | /\\ | | | ' | | \\_| \\/ | | ' | | | | v / /\\ | \\__ | |\r\n *    |_| |_|_||_|_|_|\\__|  \\__/\\__/|_|\\__| |_| |_|_\\_||_|\\__/ |_|\r\n */\r\ncontract ETH4CLUB is Ownable {\r\n  using SafeMath\r\n  for uint;\r\n\r\n  modifier isHuman() {\r\n    uint32 size;\r\n    address investor = msg.sender;\r\n    assembly {\r\n      size: = extcodesize(investor)\r\n    }\r\n    if (size > 0) {\r\n      revert(\"Inhuman\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  event DailyDividendPayout(address indexed _address, uint value, uint periodCount, uint percent, uint time);\r\n  event ReferralPayout(address indexed _addressFrom, address indexed _addressTo, uint value, uint percent, uint time);\r\n  event MidnightRunPayout(address indexed _address, uint value, uint totalValue, uint userValue, uint time);\r\n\r\n  uint public period = 24 hours;\r\n  uint public startTime = 1538186400; //  Fri, 29 Sep 2018 02:00:00 +0000 UTC\r\n\r\n  uint public dailyDividendPercent = 300; //3%\r\n  uint public referredDividendPercent = 400; //4%\r\n\r\n  uint public referrerPercent = 300; //3%\r\n  uint public minBetLevel = 0.01 ether;\r\n\r\n  uint public referrerAndOwnerPercent = 2000; //20%\r\n  uint public currentStakeID = 1;\r\n\r\n  struct DepositInfo {\r\n    uint value;\r\n    uint firstBetTime;\r\n    uint lastBetTime;\r\n    uint lastPaymentTime;\r\n    uint nextPayAfterTime;\r\n    bool isExist;\r\n    uint id;\r\n    uint referrerID;\r\n  }\r\n\r\n  mapping(address => DepositInfo) public investorToDepostIndex;\r\n  mapping(uint => address) public idToAddressIndex;\r\n\r\n  // Jackpot\r\n  uint public midnightPrizePercent = 1000; //10%\r\n  uint public midnightPrize = 0;\r\n  uint public nextPrizeTime = startTime + period;\r\n\r\n  uint public currentPrizeStakeID = 0;\r\n\r\n  struct MidnightRunDeposit {\r\n    uint value;\r\n    address user;\r\n  }\r\n  mapping(uint => MidnightRunDeposit) public stakeIDToDepositIndex;\r\n\r\n /**\r\n  * Constructor no need for unnecessary work in here.\r\n  */\r\n  constructor() public {\r\n  }\r\n\r\n  /**\r\n   * Fallback and entrypoint for deposits.\r\n   */\r\n  function() public payable isHuman {\r\n    if (msg.value == 0) {\r\n      collectPayoutForAddress(msg.sender);\r\n    } else {\r\n      uint refId = 1;\r\n      address referrer = bytesToAddress(msg.data);\r\n      if (investorToDepostIndex[referrer].isExist) {\r\n        refId = investorToDepostIndex[referrer].id;\r\n      }\r\n      deposit(refId);\r\n    }\r\n  }\r\n\r\n/**\r\n * Reads the given bytes into an addtress\r\n */\r\n  function bytesToAddress(bytes bys) private pure returns(address addr) {\r\n    assembly {\r\n      addr: = mload(add(bys, 20))\r\n    }\r\n  }\r\n\r\n/**\r\n * Put some funds into the contract for the prize\r\n */\r\n  function addToMidnightPrize() public payable onlyOwner {\r\n    midnightPrize += msg.value;\r\n  }\r\n\r\n/**\r\n * Get the time of the next payout - calculated\r\n */\r\n  function getNextPayoutTime() public view returns(uint) {\r\n    if (now<startTime) return startTime + period;\r\n    return startTime + ((now.sub(startTime)).div(period)).mul(period) + period;\r\n  }\r\n\r\n/**\r\n * Make a deposit into the contract\r\n */\r\n  function deposit(uint _referrerID) public payable isHuman {\r\n    require(_referrerID <= currentStakeID, \"Who referred you?\");\r\n    require(msg.value >= minBetLevel, \"Doesn't meet minimum stake.\");\r\n\r\n    // when is next midnight ?\r\n    uint nextPayAfterTime = getNextPayoutTime();\r\n\r\n    if (investorToDepostIndex[msg.sender].isExist) {\r\n      if (investorToDepostIndex[msg.sender].nextPayAfterTime < now) {\r\n        collectPayoutForAddress(msg.sender);\r\n      }\r\n      investorToDepostIndex[msg.sender].value += msg.value;\r\n      investorToDepostIndex[msg.sender].lastBetTime = now;\r\n    } else {\r\n      DepositInfo memory newDeposit;\r\n\r\n      newDeposit = DepositInfo({\r\n        value: msg.value,\r\n        firstBetTime: now,\r\n        lastBetTime: now,\r\n        lastPaymentTime: 0,\r\n        nextPayAfterTime: nextPayAfterTime,\r\n        isExist: true,\r\n        id: currentStakeID,\r\n        referrerID: _referrerID\r\n      });\r\n\r\n      investorToDepostIndex[msg.sender] = newDeposit;\r\n      idToAddressIndex[currentStakeID] = msg.sender;\r\n\r\n      currentStakeID++;\r\n    }\r\n\r\n    if (now > nextPrizeTime) {\r\n      doMidnightRun();\r\n    }\r\n\r\n    currentPrizeStakeID++;\r\n\r\n    MidnightRunDeposit memory midnitrunDeposit;\r\n    midnitrunDeposit.user = msg.sender;\r\n    midnitrunDeposit.value = msg.value;\r\n\r\n    stakeIDToDepositIndex[currentPrizeStakeID] = midnitrunDeposit;\r\n\r\n    // contribute to the Midnight Run Prize\r\n    midnightPrize += msg.value.mul(midnightPrizePercent).div(10000);\r\n    // Is there a referrer to be paid?\r\n    if (investorToDepostIndex[msg.sender].referrerID != 0) {\r\n\r\n      uint refToPay = msg.value.mul(referrerPercent).div(10000);\r\n      // Referral Fee\r\n      idToAddressIndex[investorToDepostIndex[msg.sender].referrerID].transfer(refToPay);\r\n      // Team and advertising fee\r\n      owner().transfer(msg.value.mul(referrerAndOwnerPercent - referrerPercent).div(10000));\r\n      emit ReferralPayout(msg.sender, idToAddressIndex[investorToDepostIndex[msg.sender].referrerID], refToPay, referrerPercent, now);\r\n    } else {\r\n      // Team and advertising fee\r\n      owner().transfer(msg.value.mul(referrerAndOwnerPercent).div(10000));\r\n    }\r\n  }\r\n\r\n\r\n\r\n/**\r\n * Collect payout for the msg.sender\r\n */\r\n  function collectPayout() public isHuman {\r\n    collectPayoutForAddress(msg.sender);\r\n  }\r\n\r\n/**\r\n * Collect payout for the given address\r\n */\r\n  function getRewardForAddress(address _address) public onlyOwner {\r\n    collectPayoutForAddress(_address);\r\n  }\r\n\r\n/**\r\n *\r\n */\r\n  function collectPayoutForAddress(address _address) internal {\r\n    require(investorToDepostIndex[_address].isExist == true, \"Who are you?\");\r\n    require(investorToDepostIndex[_address].nextPayAfterTime < now, \"Not yet.\");\r\n\r\n    uint periodCount = now.sub(investorToDepostIndex[_address].nextPayAfterTime).div(period).add(1);\r\n    uint percent = dailyDividendPercent;\r\n\r\n    if (investorToDepostIndex[_address].referrerID > 0) {\r\n      percent = referredDividendPercent;\r\n    }\r\n\r\n    uint toPay = periodCount.mul(investorToDepostIndex[_address].value).div(10000).mul(percent);\r\n\r\n    investorToDepostIndex[_address].lastPaymentTime = now;\r\n    investorToDepostIndex[_address].nextPayAfterTime += periodCount.mul(period);\r\n\r\n    // protect contract - this could result in some bad luck - but not much\r\n    if (toPay.add(midnightPrize) < address(this).balance.sub(msg.value))\r\n    {\r\n      _address.transfer(toPay);\r\n      emit DailyDividendPayout(_address, toPay, periodCount, percent, now);\r\n    }\r\n  }\r\n\r\n/**\r\n * Perform the Midnight Run\r\n */\r\n  function doMidnightRun() public isHuman {\r\n    require(now>nextPrizeTime , \"Not yet\");\r\n\r\n    // set the next prize time to the next payout time (MidnightRun)\r\n    nextPrizeTime = getNextPayoutTime();\r\n\r\n    if (currentPrizeStakeID > 5) {\r\n      uint toPay = midnightPrize;\r\n      midnightPrize = 0;\r\n\r\n      if (toPay > address(this).balance){\r\n        toPay = address(this).balance;\r\n      }\r\n\r\n      uint totalValue = stakeIDToDepositIndex[currentPrizeStakeID].value + stakeIDToDepositIndex[currentPrizeStakeID - 1].value + stakeIDToDepositIndex[currentPrizeStakeID - 2].value + stakeIDToDepositIndex[currentPrizeStakeID - 3].value + stakeIDToDepositIndex[currentPrizeStakeID - 4].value;\r\n\r\n      stakeIDToDepositIndex[currentPrizeStakeID].user.transfer(toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID].value).div(totalValue));\r\n      emit MidnightRunPayout(stakeIDToDepositIndex[currentPrizeStakeID].user, toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID].value).div(totalValue), totalValue, stakeIDToDepositIndex[currentPrizeStakeID].value, now);\r\n\r\n      stakeIDToDepositIndex[currentPrizeStakeID - 1].user.transfer(toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 1].value).div(totalValue));\r\n      emit MidnightRunPayout(stakeIDToDepositIndex[currentPrizeStakeID - 1].user, toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 1].value).div(totalValue), totalValue, stakeIDToDepositIndex[currentPrizeStakeID - 1].value, now);\r\n\r\n      stakeIDToDepositIndex[currentPrizeStakeID - 2].user.transfer(toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 2].value).div(totalValue));\r\n      emit MidnightRunPayout(stakeIDToDepositIndex[currentPrizeStakeID - 2].user, toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 2].value).div(totalValue), totalValue, stakeIDToDepositIndex[currentPrizeStakeID - 2].value, now);\r\n\r\n      stakeIDToDepositIndex[currentPrizeStakeID - 3].user.transfer(toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 3].value).div(totalValue));\r\n      emit MidnightRunPayout(stakeIDToDepositIndex[currentPrizeStakeID - 3].user, toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 3].value).div(totalValue), totalValue, stakeIDToDepositIndex[currentPrizeStakeID - 3].value, now);\r\n\r\n      stakeIDToDepositIndex[currentPrizeStakeID - 4].user.transfer(toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 4].value).div(totalValue));\r\n      emit MidnightRunPayout(stakeIDToDepositIndex[currentPrizeStakeID - 4].user, toPay.mul(stakeIDToDepositIndex[currentPrizeStakeID - 4].value).div(totalValue), totalValue, stakeIDToDepositIndex[currentPrizeStakeID - 4].value, now);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"addToMidnightPrize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeIDToDepositIndex\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBetLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doMidnightRun\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddressIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrizeStakeID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referredDividendPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"midnightPrizePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRewardForAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyDividendPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorToDepostIndex\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"firstBetTime\",\"type\":\"uint256\"},{\"name\":\"lastBetTime\",\"type\":\"uint256\"},{\"name\":\"lastPaymentTime\",\"type\":\"uint256\"},{\"name\":\"nextPayAfterTime\",\"type\":\"uint256\"},{\"name\":\"isExist\",\"type\":\"bool\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"referrerID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerAndOwnerPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStakeID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"midnightPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPrizeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextPayoutTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"periodCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"percent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DailyDividendPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addressFrom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addressTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"percent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ReferralPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MidnightRunPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ETH4CLUB","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cb53958502260d8e8d6ee4e066782ceebac03ab013e1786eaa67e1bd7abaa557"}]}