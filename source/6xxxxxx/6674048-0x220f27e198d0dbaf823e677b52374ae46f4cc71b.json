{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/modules/PermissionManager/IPermissionManager.sol\r\n\r\n/**\r\n * @title Interface to be implemented by all permission manager modules\r\n */\r\ninterface IPermissionManager {\r\n\r\n    /**\r\n    * @notice Used to check the permission on delegate corresponds to module contract address\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @return bool\r\n    */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool);\r\n\r\n    /**\r\n    * @notice Used to add a delegate\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _details Details about the delegate i.e `Belongs to financial firm`\r\n    */\r\n    function addDelegate(address _delegate, bytes32 _details) external;\r\n\r\n    /**\r\n    * @notice Used to delete a delegate\r\n    * @param _delegate Ethereum address of the delegate\r\n    */\r\n    function deleteDelegate(address _delegate) external;\r\n\r\n    /**\r\n    * @notice Used to check if an address is a delegate or not\r\n    * @param _potentialDelegate the address of potential delegate\r\n    * @return bool\r\n    */\r\n    function checkDelegate(address _potentialDelegate) external view returns(bool);\r\n\r\n    /**\r\n    * @notice Used to provide/change the permission to the delegate corresponds to the module contract\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @param _valid Bool flag use to switch on/off the permission\r\n    * @return bool\r\n    */\r\n    function changePermission(\r\n        address _delegate,\r\n        address _module,\r\n        bytes32 _perm,\r\n        bool _valid\r\n    )\r\n    external;\r\n\r\n    /**\r\n    * @notice Used to change one or more permissions for a single delegate at once\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _modules Multiple module matching the multiperms, needs to be same length\r\n    * @param _perms Multiple permission flag needs to be changed\r\n    * @param _valids Bool array consist the flag to switch on/off the permission\r\n    * @return nothing\r\n    */\r\n    function changePermissionMulti(\r\n        address _delegate,\r\n        address[] _modules,\r\n        bytes32[] _perms,\r\n        bool[] _valids\r\n    )\r\n    external;\r\n\r\n    /**\r\n    * @notice Used to return all delegates with a given permission and module\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @return address[]\r\n    */\r\n    function getAllDelegatesWithPerm(address _module, bytes32 _perm) external view returns(address[]);\r\n\r\n     /**\r\n    * @notice Used to return all permission of a single or multiple module\r\n    * @dev possible that function get out of gas is there are lot of modules and perm related to them\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _types uint8[] of types\r\n    * @return address[] the address array of Modules this delegate has permission\r\n    * @return bytes32[] the permission array of the corresponding Modules\r\n    */\r\n    function getAllModulesAndPermsFromTypes(address _delegate, uint8[] _types) external view returns(address[], bytes32[]);\r\n\r\n    /**\r\n    * @notice Used to get the Permission flag related the `this` contract\r\n    * @return Array of permission flags\r\n    */\r\n    function getPermissions() external view returns(bytes32[]);\r\n\r\n    /**\r\n    * @notice Used to get all delegates\r\n    * @return address[]\r\n    */\r\n    function getAllDelegates() external view returns(address[]);\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/libraries/TokenLib.sol\r\n\r\nlibrary TokenLib {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Struct for module data\r\n    struct ModuleData {\r\n        bytes32 name;\r\n        address module;\r\n        address moduleFactory;\r\n        bool isArchived;\r\n        uint8[] moduleTypes;\r\n        uint256[] moduleIndexes;\r\n        uint256 nameIndex;\r\n    }\r\n\r\n    // Structures to maintain checkpoints of balances for governance / dividends\r\n    struct Checkpoint {\r\n        uint256 checkpointId;\r\n        uint256 value;\r\n    }\r\n\r\n    struct InvestorDataStorage {\r\n        // List of investors who have ever held a non-zero token balance\r\n        mapping (address => bool) investorListed;\r\n        // List of token holders\r\n        address[] investors;\r\n        // Total number of non-zero token holders\r\n        uint256 investorCount;\r\n    }\r\n\r\n    // Emit when Module is archived from the SecurityToken\r\n    event ModuleArchived(uint8[] _types, address _module, uint256 _timestamp);\r\n    // Emit when Module is unarchived from the SecurityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module, uint256 _timestamp);\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    * @param _module Address of module to archive\r\n    */\r\n    function archiveModule(ModuleData storage _moduleData, address _module) public {\r\n        require(!_moduleData.isArchived, \"Module archived\");\r\n        require(_moduleData.module != address(0), \"Module missing\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleArchived(_moduleData.moduleTypes, _module, now);\r\n        _moduleData.isArchived = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    * @param _module Address of module to unarchive\r\n    */\r\n    function unarchiveModule(ModuleData storage _moduleData, address _module) public {\r\n        require(_moduleData.isArchived, \"Module unarchived\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleUnarchived(_moduleData.moduleTypes, _module, now);\r\n        _moduleData.isArchived = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates permissions with PermissionManager if it exists. If there's no permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions by default\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _modules is the modules to check permissions on\r\n     * @param _delegate is the address of the delegate\r\n     * @param _module is the address of the PermissionManager module\r\n     * @param _perm is the permissions data\r\n     * @return success\r\n     */\r\n    function checkPermission(address[] storage _modules, address _delegate, address _module, bytes32 _perm) public view returns(bool) {\r\n        if (_modules.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < _modules.length; i++) {\r\n            if (IPermissionManager(_modules[i]).checkPermission(_delegate, _module, _perm)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Queries a value at a defined checkpoint\r\n     * @param _checkpoints is array of Checkpoint objects\r\n     * @param _checkpointId is the Checkpoint ID to query\r\n     * @param _currentValue is the Current value of checkpoint\r\n     * @return uint256\r\n     */\r\n    function getValueAt(Checkpoint[] storage _checkpoints, uint256 _checkpointId, uint256 _currentValue) public view returns(uint256) {\r\n        //Checkpoint id 0 is when the token is first created - everyone has a zero balance\r\n        if (_checkpointId == 0) {\r\n            return 0;\r\n        }\r\n        if (_checkpoints.length == 0) {\r\n            return _currentValue;\r\n        }\r\n        if (_checkpoints[0].checkpointId >= _checkpointId) {\r\n            return _checkpoints[0].value;\r\n        }\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId < _checkpointId) {\r\n            return _currentValue;\r\n        }\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId == _checkpointId) {\r\n            return _checkpoints[_checkpoints.length - 1].value;\r\n        }\r\n        uint256 min = 0;\r\n        uint256 max = _checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint256 mid = (max + min) / 2;\r\n            if (_checkpoints[mid].checkpointId == _checkpointId) {\r\n                max = mid;\r\n                break;\r\n            }\r\n            if (_checkpoints[mid].checkpointId < _checkpointId) {\r\n                min = mid + 1;\r\n            } else {\r\n                max = mid;\r\n            }\r\n        }\r\n        return _checkpoints[max].value;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores the changes to the checkpoint objects\r\n     * @param _checkpoints is the affected checkpoint object array\r\n     * @param _newValue is the new value that needs to be stored\r\n     */\r\n    function adjustCheckpoints(TokenLib.Checkpoint[] storage _checkpoints, uint256 _newValue, uint256 _currentCheckpointId) public {\r\n        //No checkpoints set yet\r\n        if (_currentCheckpointId == 0) {\r\n            return;\r\n        }\r\n        //No new checkpoints since last update\r\n        if ((_checkpoints.length > 0) && (_checkpoints[_checkpoints.length - 1].checkpointId == _currentCheckpointId)) {\r\n            return;\r\n        }\r\n        //New checkpoint, so record balance\r\n        _checkpoints.push(\r\n            TokenLib.Checkpoint({\r\n                checkpointId: _currentCheckpointId,\r\n                value: _newValue\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Keeps track of the number of non-zero token holders\r\n    * @param _investorData Date releated to investor metrics\r\n    * @param _from Sender of transfer\r\n    * @param _to Receiver of transfer\r\n    * @param _value Value of transfer\r\n    * @param _balanceTo Balance of the _to address\r\n    * @param _balanceFrom Balance of the _from address\r\n    */\r\n    function adjustInvestorCount(\r\n        InvestorDataStorage storage _investorData,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _balanceTo,\r\n        uint256 _balanceFrom\r\n        ) public  {\r\n        if ((_value == 0) || (_from == _to)) {\r\n            return;\r\n        }\r\n        // Check whether receiver is a new token holder\r\n        if ((_balanceTo == 0) && (_to != address(0))) {\r\n            _investorData.investorCount = (_investorData.investorCount).add(1);\r\n        }\r\n        // Check whether sender is moving all of their tokens\r\n        if (_value == _balanceFrom) {\r\n            _investorData.investorCount = (_investorData.investorCount).sub(1);\r\n        }\r\n        //Also adjust investor list\r\n        if (!_investorData.investorListed[_to] && (_to != address(0))) {\r\n            _investorData.investors.push(_to);\r\n            _investorData.investorListed[_to] = true;\r\n        }\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_checkpoints\",\"type\":\"TokenLib.Checkpoint[] storage\"},{\"name\":\"_newValue\",\"type\":\"uint256\"},{\"name\":\"_currentCheckpointId\",\"type\":\"uint256\"}],\"name\":\"adjustCheckpoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorData\",\"type\":\"TokenLib.InvestorDataStorage storage\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_balanceTo\",\"type\":\"uint256\"},{\"name\":\"_balanceFrom\",\"type\":\"uint256\"}],\"name\":\"adjustInvestorCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleData\",\"type\":\"TokenLib.ModuleData storage\"},{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"unarchiveModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_modules\",\"type\":\"address[] storage\"},{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_module\",\"type\":\"address\"},{\"name\":\"_perm\",\"type\":\"bytes32\"}],\"name\":\"checkPermission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_checkpoints\",\"type\":\"TokenLib.Checkpoint[] storage\"},{\"name\":\"_checkpointId\",\"type\":\"uint256\"},{\"name\":\"_currentValue\",\"type\":\"uint256\"}],\"name\":\"getValueAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moduleData\",\"type\":\"TokenLib.ModuleData storage\"},{\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"archiveModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ModuleArchived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ModuleUnarchived\",\"type\":\"event\"}]","ContractName":"TokenLib","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5dd4eb6be3dbfea33e4229e7270256b8b0d5de179cf785ac1b62b523214ea195"}]}