{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/**\r\n * @title -Heaven-3D v0.1.0\r\n * This work is inspired by the admirable Team JUST, we aimed to perfect their work by making this platform a heaven for everyone.\r\n * Specifically, we aimed to create a platform in which players can earn money from it but hard to lose their money.\r\n * We believe that this could be achieved by carefully creating a set of rules that favor this result.\r\n * We done this for the world, and also as an experiment for ourselves to understand the world.\r\n * We are Team DREAM. \r\n */\r\n\r\n//==============================================================================\r\n//     _    _  _ _|_ _  .\r\n//    (/_\\/(/_| | | _\\  .\r\n//==============================================================================\r\ncontract H3Devents {\r\n\t// fired whenever new decision is made\r\n\tevent onNewDecision\r\n    (\r\n        address senderAddress,\r\n\t\tuint256 randNum,\r\n        bool decision\r\n    );\r\n\t\r\n    // fired whenever a player registers a name\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired at end of buy or reload\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount,\r\n        uint256 potAmount,\r\n        uint256 airDropPot\r\n    );\r\n    \r\n\t// fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a withdraw forces end round to be ran\r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n\t\r\n\t// fired whenever a withdraw forces end round to be ran\r\n    event onDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // (Heaven3D long only) fired whenever a player tries a buy after round timer \r\n    // hit zero, and causes end round to be ran.\r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // (Heaven3D long only) fired whenever a player tries a reload after round timer \r\n    // hit zero, and causes end round to be ran.\r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // fired whenever an affiliate is paid\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // received pot swap deposit\r\n    event onPotSwapDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n}\r\n\r\n//==============================================================================\r\n//   _ _  _ _|_ _ _  __|_   _ _ _|_    _   .\r\n//  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  .\r\n//====================================|=========================================\r\n\r\ncontract modularLong is H3Devents {}\r\n\r\ncontract Heaven3D is modularLong {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    using H3DKeysCalcLong for uint256;\r\n\t\r\n\tTeamDreamHubInterface public TeamDreamHub_;\r\n\tPlayerBookInterface public PlayerBook;\r\n//==============================================================================\r\n//     _ _  _  |`. _     _ _ |_ | _  _  .\r\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n//=================_|===========================================================\r\n    string constant public name = \"Heaven3D Official\";\r\n    string constant public symbol = \"H3D\";\r\n\taddress private owner;\r\n\tuint256 constant private rndExtra_ = 0 hours;     // length of the very first ICO \r\n    uint256 constant private rndGap_ = 0 hours;         // length of ICO phase, set to 1 year for EOS.\r\n    uint256 constant private rndInit_ = 1 hours;                // round timer starts at this\r\n    uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer\r\n\tuint256 constant private rndDeciExt_ = 360 seconds;              // round extension time decide by random decision\r\n    uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be\r\n\t\r\n\tuint256 constant private rule_limit_latestPlayersCnt = 10; \t// should smaller than latestPlayers.length\r\n\tuint256 constant private rule_limit_heavyPlayersCnt = 10; \t// should smaller than heavyPlayers.length\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes)\r\n//=============================|================================================\r\n\tuint256 public airDropPot_;             // person who gets the airdrop wins part of this pot\r\n\tuint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n//****************\r\n// FLOW CONTROL\r\n//****************\t\r\n\tbool public noMoreNextRound_ = false; \t// if this flag enabled, in the end of the round the developers are going to update the smart contract of the game, in order to perfect players' gaming experience.\r\n\tuint256 public randomDecisionPhase_ = 100;\r\n\tbool private endRoundDecisionResult_ = false;\r\n\taddress private address_of_last_rand_gen_source_ = address(0);\r\n\tmapping (uint256 => uint256) pPAIDxID_;          // (pID => paid eth) returns paid eth by player id\r\n//****************\r\n// PLAYER DATA \r\n//****************\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => H3Ddatasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => H3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own)\t\r\n//****************\r\n// ROUND DATA \r\n//****************\r\n    mapping (uint256 => H3Ddatasets.Round) public round_;   // (rID => data) round data\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================\r\n    constructor(address _TeamDreamHubSCaddress, address _PlayerBookSCaddress)\r\n        public\r\n    {\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t\tTeamDreamHub_ = TeamDreamHubInterface(_TeamDreamHubSCaddress);\r\n\t\tPlayerBook = PlayerBookInterface(_PlayerBookSCaddress);\r\n\t}\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has \r\n     * been activated. \r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); \r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev prevents contracts from interacting with Heaven3D \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n\t\trequire (_addr == tx.origin);\r\n\t\t\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n    \r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================\r\n    /**\r\n     * @dev fallback function\r\n\t * emergency buy uses last stored affiliate ID and team snek\r\n     */\r\n    function()\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        H3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n            \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // buy core \r\n        buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev converts all incoming ethereum to keys.\r\n     * -functionhash- 0x8f38f309 (using ID for affiliate)\r\n     * -functionhash- 0x98a0871d (using address for affiliate)\r\n     * -functionhash- 0xa65b37a1 (using name for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _team what team is the player playing for?\r\n     */\r\n    function buyXid(uint256 _affCode, uint256 _team)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        H3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code \r\n            _affCode = plyr_[_pID].laff;\r\n            \r\n        // if affiliate code was given & its not the same as previously stored \r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affCode, _team, _eventData_);\r\n    }\r\n    \r\n    function buyXaddr(address _affCode, uint256 _team)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        H3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affID, _team, _eventData_);\r\n    }\r\n    \r\n    function buyXname(bytes32 _affCode, uint256 _team)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        H3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given\r\n        } else {\r\n            // get affiliate ID from aff Code\r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored\r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affID, _team, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev essentially the same as buy, but instead of you sending ether \r\n     * from your wallet, it uses your unwithdrawn earnings.\r\n     * -functionhash- 0x349cdcac (using ID for affiliate)\r\n     * -functionhash- 0x82bfc739 (using address for affiliate)\r\n     * -functionhash- 0x079ce327 (using name for affiliate)\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _team what team is the player playing for?\r\n     * @param _eth amount of earnings to use (remainder returned to gen vault)\r\n     */\r\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        H3Ddatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code \r\n            _affCode = plyr_[_pID].laff;\r\n            \r\n        // if affiliate code was given & its not the same as previously stored \r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n\r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n\r\n        // reload core\r\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\r\n    }\r\n    \r\n    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        H3Ddatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // reload core\r\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\r\n    }\r\n    \r\n    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        H3Ddatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given\r\n        } else {\r\n            // get affiliate ID from aff Code\r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored\r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // verify a valid team was selected\r\n        _team = verifyTeam(_team);\r\n        \r\n        // reload core\r\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\r\n    }\r\n\r\n\t/**\r\n     * @dev set the flag noMoreNextRound_\r\n     */\r\n    function noMoreNextRoundSetting(bool _noMoreNextRound)\r\n        isActivated()\r\n\t\tisHuman()\r\n        public\r\n\t{\r\n        // only Team Dream can activate \r\n        require(\r\n            msg.sender == owner,\r\n            \"only Team Dream can activate\"\r\n        );\r\n\t\t\r\n\t\tnoMoreNextRound_ = _noMoreNextRound;\r\n\t}\t\t\r\n\t\t\t\r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- 0x3ccfd60b\r\n     */\r\n    function withdraw()\r\n        isActivated()\r\n        isHuman()\r\n        public\r\n    {\r\n        // setup local rID \r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // set up our tx event data\r\n            H3Ddatasets.EventReturns memory _eventData_;\r\n            endRoundControl(_eventData_);            \r\n\t\t\t\r\n\t\t\t// get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);    \r\n            \r\n\t\t\tif(round_[_rID].ended == true)\r\n\t\t\t{\r\n\t            // build event data\r\n\t            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n\t            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n            \r\n\t            // fire withdraw and distribute event\r\n\t            emit H3Devents.onWithdrawAndDistribute\r\n\t            (\r\n\t                msg.sender, \r\n\t                plyr_[_pID].name, \r\n\t                _eth, \r\n\t                _eventData_.compressedData, \r\n\t                _eventData_.compressedIDs, \r\n\t                _eventData_.winnerAddr, \r\n\t                _eventData_.winnerName, \r\n\t                _eventData_.amountWon, \r\n\t                _eventData_.newPot, \r\n\t                _eventData_.P3DAmount, \r\n\t                _eventData_.genAmount\r\n\t            );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// fire withdraw event\r\n            \temit H3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n\t\t\t}            \r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            \r\n            // fire withdraw event\r\n            emit H3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev use these to register names.  they are just wrappers that will send the\r\n     * registration requests to the PlayerBook contract.  So registering here is the \r\n     * same as registering there.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate \r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space \r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x \r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who referred you\r\n     * @param _all set to true if you want this to push your info to all games \r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit H3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit H3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit H3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n//==============================================================================\r\n//     _  _ _|__|_ _  _ _  .\r\n//    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n//=====_|=======================================================================\r\n    /**\r\n     * @dev return the price buyer will pay for next 1 individual key.\r\n     * -functionhash- 0x018a25e8\r\n     * @return price for next key bought (in wei format)\r\n     */\r\n    function getBuyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {  \r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    \r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node \r\n     * provider\r\n     * -functionhash- 0xc7e284b8\r\n     * @return time left in seconds\r\n     */\r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt + rndGap_)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].strt + rndGap_).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev returns player earnings per vaults \r\n     * -functionhash- 0x63066434\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n     */\r\n    function getPlayerVaults(uint256 _pID)\r\n        public\r\n        view\r\n        returns(uint256 ,uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID)\r\n            {\r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return\r\n                (\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return\r\n            (\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n                plyr_[_pID].aff\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * solidity hates stack limits.  this lets us avoid that hate \r\n     */\r\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  ((((round_[_rID].mask)).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\r\n    }\r\n    \r\n    /**\r\n     * @dev returns all current round info needed for front end\r\n     * -functionhash- 0x747dff42\r\n     * @return eth invested during ICO phase\r\n     * @return round id \r\n     * @return total keys for round \r\n     * @return time round ends\r\n     * @return time round started\r\n     * @return current pot \r\n     * @return current team ID & player ID in lead \r\n     * @return current player in leads address \r\n     * @return current player in leads name\r\n     * @return whales eth in for round\r\n     * @return bears eth in for round\r\n     * @return sneks eth in for round\r\n     * @return bulls eth in for round\r\n     * @return airdrop tracker # & airdrop pot\r\n     */\r\n    function getCurrentRoundInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        return\r\n        (\r\n            round_[_rID].ico,               //0\r\n            _rID,                           //1\r\n            round_[_rID].keys,              //2\r\n            round_[_rID].end,               //3\r\n            round_[_rID].strt,              //4\r\n            round_[_rID].pot,               //5\r\n            (round_[_rID].team + (round_[_rID].plyr * 10)),     //6\r\n            plyr_[round_[_rID].plyr].addr,  //7\r\n            plyr_[round_[_rID].plyr].name,  //8\r\n            rndTmEth_[_rID][0],             //9\r\n            rndTmEth_[_rID][1],             //10\r\n            rndTmEth_[_rID][2],             //11\r\n            rndTmEth_[_rID][3],             //12\r\n            randomDecisionPhase_            //13\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will \r\n     * use msg.sender \r\n     * -functionhash- 0xee0b5d8b\r\n     * @param _addr address of the player you want to lookup \r\n     * @return player ID \r\n     * @return player name\r\n     * @return keys owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault \r\n     * @return affiliate vault \r\n\t * @return player round eth\r\n     */\r\n    function getPlayerInfoByAddress(address _addr)\r\n        public \r\n        view \r\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\t\t\r\n\t\tuint256 limitedDividends = (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd));\r\n\t\tif(limitedDividends > plyrRnds_[_pID][_rID].eth.mul(3))\r\n\t\t\tlimitedDividends = plyrRnds_[_pID][_rID].eth.mul(3);\r\n        \r\n        return\r\n        (\r\n            _pID,                               //0\r\n            plyr_[_pID].name,                   //1\r\n            plyrRnds_[_pID][_rID].keys,         //2\r\n            plyr_[_pID].win,                    //3\r\n            limitedDividends,       //4\r\n            plyr_[_pID].aff,                    //5\r\n            plyrRnds_[_pID][_rID].eth           //6\r\n        );\r\n    }\r\n\r\n//==============================================================================\r\n//     _ _  _ _   | _  _ . _  .\r\n//    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine)\r\n//=====================_|=======================================================\r\n\r\n    function endRoundControl(H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n\t{\r\n\t    // setup local rID \r\n        uint256 _rID = rID_;\r\n\t\t\r\n\t\trandomDecisionPhase_ = 101; // set true for randomDecisionPhase_ we're in!\r\n        \r\n        // setup local address_of_last_rand_gen_source_ \r\n        address _address_of_last_rand_gen_source_ = address_of_last_rand_gen_source_;\r\n        \r\n\t\tbool goMakeDecision = true;\r\n\t\t\r\n\t\tif((_address_of_last_rand_gen_source_ == address(0)) || (_address_of_last_rand_gen_source_ == msg.sender)) // 1st time to make decision OR sender is also the validator\r\n\t\t{\r\n\t\t\tgoMakeDecision = true; // prior check FAILED\t\t\r\n\t\t}\r\n\t\telse // prior check PASS\r\n\t\t{\r\n\t\t\tif(checkNotSmartContract(_address_of_last_rand_gen_source_)) // last sender is human\r\n\t\t\t{\t\t\t\t\t\t\t\r\n\t\t\t\tif(endRoundDecisionResult_ == true) // the decision generated is true\r\n\t\t\t\t{\t\t\t\t\t\t\t\r\n\t\t\t\t\t// end the round (distributes pot) & start new round\r\n\t\t\t\t\tround_[_rID].ended = true;\r\n\t\t\t\t\t_eventData_ = endRound(_eventData_);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\trandomDecisionPhase_ = 100;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// grab time\r\n\t\t\t\t\tuint256 _now = now;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// set new end time by adding rndDeciExt_ to NOW\r\n\t\t\t\t\tround_[_rID].end = rndDeciExt_.add(_now);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//reset all flags -- because we're leaving endGamePrcoess and not going to come back within a period of time.\r\n\t\t\t\tendRoundDecisionResult_ = false;\r\n\t\t\t\taddress_of_last_rand_gen_source_ = address(0);\r\n\t\t\t\tgoMakeDecision = false;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tgoMakeDecision = true; // because last sender is SC.\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(goMakeDecision == true)\r\n\t\t{\r\n\t\t\t//make a decision\r\n\t\t\taddress_of_last_rand_gen_source_ = msg.sender;\r\n\t\t\tendRoundDecisionResult_ = endRoundDecision();\t\r\n\t\t}\t\t\t\t\r\n\t}\r\n\r\n    /**\r\n     * @dev logic runs whenever a buy order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not\r\n     */\r\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // call core \r\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_);\r\n        \r\n        // if round is not active     \r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) \r\n            {\r\n                endRoundControl(_eventData_); \r\n\t\t\t\t\r\n\t\t\t\tif(round_[_rID].ended == true)\r\n\t\t\t\t{\r\n\t                // build event data\r\n\t                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n\t                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                \r\n\t                // fire buy and distribute event \r\n\t                emit H3Devents.onBuyAndDistribute\r\n\t                (\r\n\t                    msg.sender, \r\n\t                    plyr_[_pID].name, \r\n\t                    msg.value, \r\n\t                    _eventData_.compressedData, \r\n\t                    _eventData_.compressedIDs, \r\n\t                    _eventData_.winnerAddr, \r\n\t                    _eventData_.winnerName, \r\n\t                    _eventData_.amountWon, \r\n\t                    _eventData_.newPot, \r\n\t                    _eventData_.P3DAmount, \r\n\t                    _eventData_.genAmount\r\n\t                );\r\n\t\t\t\t}\r\n            }\r\n            \r\n            // put eth in players vault \r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev logic runs whenever a reload order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not \r\n     */\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // get earnings from all vaults and return unused to gen vault\r\n            // because we use a custom safemath library.  this will throw if player \r\n            // tried to spend more eth than they have.\r\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            \r\n            // call core \r\n            core(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n        \r\n        // if round is not active and end round needs to be ran   \r\n        } else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n\t\t\t\r\n\t\t\tendRoundControl(_eventData_); \r\n\t\t\t\r\n\t\t\tif(round_[_rID].ended == true)\r\n\t\t\t{\t            // build event data\r\n\t            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n\t            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                \r\n\t            // fire buy and distribute event \r\n\t            emit H3Devents.onReLoadAndDistribute\r\n\t            (\r\n\t                msg.sender, \r\n\t                plyr_[_pID].name, \r\n\t                _eventData_.compressedData, \r\n\t                _eventData_.compressedIDs, \r\n\t                _eventData_.winnerAddr, \r\n\t                _eventData_.winnerName, \r\n\t                _eventData_.amountWon, \r\n\t                _eventData_.newPot, \r\n\t                _eventData_.P3DAmount, \r\n\t                _eventData_.genAmount\r\n\t            );\r\n\t\t\t}\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev this is the core logic for any buy/reload that happens while a round \r\n     * is live.\r\n     */\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // if player is new to round\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_); // don't have to do updateGenVault again because we have it in managePlayer()\r\n\t\telse // if not, can use _rID directly, but we decided to still go with plyr_[_pID].lrnd\r\n\t\t\tupdateGenVault(_pID, plyr_[_pID].lrnd);\t\r\n        \r\n        // early round eth limiter \r\n        if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\r\n        {\r\n            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\r\n            uint256 _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        \r\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\r\n        if (_eth > 1000000000) \r\n        {            \r\n            // mint the new keys\r\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\r\n            \r\n            // if they bought at least 1 whole key\r\n            if (_keys >= 1000000000000000000)\r\n            {\r\n\t\t\t\tupdateTimer(_keys, _rID);\r\n\r\n\t\t\t\t// set new leaders\r\n\t\t\t\tif (round_[_rID].plyr != _pID)\r\n\t\t\t\t\tround_[_rID].plyr = _pID;  \r\n\t\t\t\tif (round_[_rID].team != _team)\r\n\t\t\t\t\tround_[_rID].team = _team; \r\n\t\t\t\t\r\n\t\t\t\t// set the new leader bool to true\r\n\t\t\t\t_eventData_.compressedData = _eventData_.compressedData + 100;\r\n\t\t\t}            \r\n    \r\n            // store the air drop tracker number (number of buys since last airdrop)\r\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\r\n            \r\n            // update player \r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n            \r\n            // update round\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\r\n    \r\n            // distribute eth\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);\r\n\t\t\t\r\n\t\t\tinternalNoter(_rID, _pID);\r\n\t\t\t\r\n            // call end tx function to fire end tx event.\r\n\t\t    endTx(_pID, _team, _eth, _keys, _eventData_);\r\n        }\r\n    }\r\n//==============================================================================\r\n//     _ _ | _   | _ _|_ _  _ _  .\r\n//    (_(_||(_|_||(_| | (_)| _\\  .\r\n//==============================================================================\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns the amount of keys you would get given an amount of eth. \r\n     * -functionhash- 0xce89c80c\r\n     * @param _rID round ID you want price for\r\n     * @param _eth amount of eth sent in \r\n     * @return keys received \r\n     */\r\n    function calcKeysReceived(uint256 _rID, uint256 _eth)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns current eth price for X keys.  \r\n     * -functionhash- 0xcf808000\r\n     * @param _keys number of keys desired (in 18 decimal format)\r\n     * @return amount of eth needed to send\r\n     */\r\n    function iWantXKeys(uint256 _keys)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n//==============================================================================\r\n//    _|_ _  _ | _  .\r\n//     | (_)(_)|_\\  .\r\n//==============================================================================\r\n    /**\r\n\t * @dev receives name/player info from names contract \r\n     */\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\r\n        external\r\n    {\r\n        require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (pIDxName_[_name] != _pID)\r\n            pIDxName_[_name] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n        if (plyr_[_pID].name != _name)\r\n            plyr_[_pID].name = _name;\r\n        if (plyr_[_pID].laff != _laff)\r\n            plyr_[_pID].laff = _laff;\r\n        if (plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n    \r\n    /**\r\n     * @dev receives entire player name list \r\n     */\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name)\r\n        external\r\n    {\r\n        require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if(plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }   \r\n        \r\n    /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID \r\n     */\r\n    function determinePID(H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (H3Ddatasets.EventReturns)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        // if player is new to this version of Heaven3D\r\n        if (_pID == 0)\r\n        {\r\n            // grab their player ID, name and last aff ID, from player names contract \r\n            _pID = PlayerBook.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBook.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBook.getPlayerLAff(_pID);\r\n            \r\n            // set up player account \r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            \r\n            if (_name != \"\")\r\n            {\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n            \r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n            \r\n            // set the new player bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 1;\r\n        } \r\n        return (_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev checks to make sure user picked a valid team.  if not sets team \r\n     * to default (sneks)\r\n     */\r\n    function verifyTeam(uint256 _team)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_team < 0 || _team > 3)\r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n    \r\n    /**\r\n     * @dev decides if round end needs to be run & new round started.  and if \r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer(uint256 _pID, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (H3Ddatasets.EventReturns)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n            \r\n        // set the joined round bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev ends the round. manages paying out winner/splitting up pot\r\n     */\r\n    function endRound(H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (H3Ddatasets.EventReturns)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab our winning player and team id's\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n        \r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot;\r\n        \r\n        // calculate our winner share, community rewards, gen share, \r\n        // p3d share, and amount reserved for next pot \r\n        uint256 _win = (_pot.mul(68)) / 100; // for all winners\r\n        uint256 _com = (_pot.mul(10)) / 100; // for community \r\n        uint256 _gen = 0; \r\n        uint256 _p3d = 0;\r\n\t\t\r\n\t\t// community rewards\r\n\t\tTeamDreamHub_.deposit.value(_com)();\r\n\t\t\r\n\t\tuint256 _res = ((_pot.sub(_com)).sub(_gen)).sub(_p3d); // _win should be handled later.        \r\n\t\t(_res,_eventData_) = winnersProfitDistributor(_rID, _win, _res, _eventData_); // distribute to all winners\r\n\t\t\r\n\t\t// if update in smart contract is neccessary, the developers will trigger this mechanism.\r\n\t\t// in this condition we're going into maintenance mode in order to update the smart contract on the blockchain\r\n\t\t// we developers will put _res into the next pot manually when H3D is going online again.\r\n\t\t// the down time is expected to be short.\r\n\t\tif(noMoreNextRound_ == true)\r\n\t\t{\r\n\t\t\towner.transfer(_res);\r\n\t\t\t_res = 0;\r\n\t\t}\r\n            \r\n        // prepare event data\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.P3DAmount = _p3d;\r\n        _eventData_.newPot = _res;\r\n        \r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndInit_).add(rndGap_);\r\n        round_[_rID].pot = _res; // the rest goes to next pot\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 dividend_yet_distribute = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (dividend_yet_distribute > 0)\r\n        {\t\t\t\r\n\t\t\tuint256 _earnings;\r\n\t\t\tuint256 all_dividend_earned = dividend_yet_distribute.add(plyrRnds_[_pID][_rIDlast].eth_went_to_gen);\r\n\t\t\t//check 3x limit\r\n\t\t\tif (all_dividend_earned > (plyrRnds_[_pID][_rIDlast].eth).mul(3))\r\n\t\t\t{\t\r\n\t\t\t\t//===adjustment done accordingly===\r\n\t\t\t\t\r\n\t\t\t\t//seperate exceeds_part from dividend_yet_distribute\r\n\t\t\t\tuint256 remain_quota = (plyrRnds_[_pID][_rIDlast].eth).mul(3).sub(plyrRnds_[_pID][_rIDlast].eth_went_to_gen); // can only provide the dividend withing 3x of inputed eth.\r\n\t\t\t\tuint256 exceeds_part = dividend_yet_distribute.sub(remain_quota);\r\n\r\n\t\t\t\t_earnings = remain_quota;\r\n\t\t\t\t\r\n\t\t        // add exceeds_part as new profit to the current round and adjust round.mask accordingly\t\t\t\t\r\n\t\t\t\tuint256 _dust = updateMasks(rID_, _pID, exceeds_part, 0); // keys = 0 because didn't add new key.\r\n\t\t\t\tif (_dust > 0) // add dust to pot\r\n\t\t\t\t\tround_[rID_].pot = round_[rID_].pot.add(_dust);\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t_earnings = dividend_yet_distribute;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// put in gen vault\r\n\t\t\tplyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n\t\t\t\r\n\t\t\t//note to eth_went_to_gen, in order to estimate all eth passed to geb vault in the current round.\r\n\t\t\tplyrRnds_[_pID][_rIDlast].eth_went_to_gen = _earnings.add(plyrRnds_[_pID][_rIDlast].eth_went_to_gen);\t\t\t\r\n\t\t\t\r\n\t\t\t// zero out their earnings by updating mask\r\n\t\t\tplyrRnds_[_pID][_rIDlast].mask = dividend_yet_distribute.add(plyrRnds_[_pID][_rIDlast].mask);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev updates round timer based on number of whole keys bought.\r\n     */\r\n    function updateTimer(uint256 _keys, uint256 _rID)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n        \r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev generates a random number in order to make a decision\r\n     * @return PASS or REJECT?\r\n     */\r\n    function endRoundDecision()\r\n        private \r\n        returns(bool)\r\n    {\r\n\t\tbool decision = false;\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        \r\n\t\tuint256 randNum = (seed - ((seed / 1000) * 1000));\r\n\t\tif(randNum < 50) // 5% probability\r\n            decision = true;\r\n\t\t\r\n\t\t// fire event\r\n\t\temit H3Devents.onNewDecision(msg.sender,randNum,decision);\r\n\t\t\r\n\t\treturn decision;\r\n    }\t\r\n\t\r\n\t/**\r\n     * @dev check if an address is smart contract\r\n     * @return true (Not smart contract) or false\r\n     */\r\n    function checkNotSmartContract(address targetAddr)\r\n        private \r\n        returns(bool)\r\n    {\r\n\t\tuint256 _codeLength;        \r\n\t\tassembly {\r\n\t\t\t_codeLength := extcodesize(targetAddr)\r\n\t\t}\r\n\t\t\r\n\t\tif(_codeLength == 0) // last sender is human\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n    }\t\r\n    \r\n\r\n    /**\r\n     * @dev distributes eth based on fees to com, aff, and p3d\r\n     */\r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(H3Ddatasets.EventReturns)\r\n    {\r\n        // pay 10% out to community fund\r\n        uint256 _com = (_eth.mul(10)) / 100;\r\n        uint256 _p3d = 0;\r\n                \r\n        // distribute share to affiliate\r\n        uint256 _aff = _eth / 10;\r\n        \r\n        // decide what to do with affiliate share of fees\r\n        // affiliate must not be self, and must have a name registered\r\n        if (_affID != _pID && plyr_[_affID].name != '') {\r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit H3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\r\n        } else {\r\n\t\t\t_com = _com.add(_aff);\r\n        }\r\n\t\t\r\n\t\t// payout community rewards\r\n\t\tTeamDreamHub_.deposit.value(_com)();\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    function potSwap()\r\n        external\r\n        payable\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_ + 1;\r\n        \r\n        round_[_rID].pot = round_[_rID].pot.add(msg.value);\r\n        emit H3Devents.onPotSwapDeposit(_rID, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev distributes eth based on fees to gen and pot\r\n     */\r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(H3Ddatasets.EventReturns)\r\n    {\r\n        // calculate gen share\r\n        uint256 _gen = (_eth.mul(60)) / 100; \r\n        \r\n        // update eth balance (eth = eth - (com share + aff share + p3d share + airdrop pot share))\r\n        _eth = _eth.sub((_eth.mul(20)) / 100);\r\n        \r\n        // calculate pot \r\n        uint256 _pot = _eth.sub(_gen);\r\n        \r\n        // distribute gen share (thats what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        // add eth to pot\r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n        \r\n        // set up event data\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n        \r\n        return(_eventData_);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev distribute profits (_win) to the pot winners)\r\n     */\r\n    function winnersProfitDistributor(uint256 _rID, uint256 _win, uint256 _res, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n\t\treturns (uint256, H3Ddatasets.EventReturns)\r\n    {\t\t\r\n\t\tuint256 _pIDtmp; \r\n\t\tuint256 _paidPlayerCount; // note how many players have been paid already.\r\n\t\tuint256 _bonus_portion; // compute portions\r\n\r\n\t\t// pay the rand number generator caller\r\n\t\t_bonus_portion = (_win.mul(10)) / 1000;\t\t// 1%; to random number generator's caller\t\t\r\n        _eventData_ = determinePID(_eventData_);\r\n        _pIDtmp = pIDxAddr_[address_of_last_rand_gen_source_];\r\n\t\tplyr_[_pIDtmp].win = _bonus_portion.add(plyr_[_pIDtmp].win);\r\n\t\t_res = _res.sub(_bonus_portion);\r\n        \r\n\t\t// pay our latestPlayers\r\n\t\t_bonus_portion = (_win.mul(49)) / 1000; // 49x10 = 490; _win_latestPlayer_slot\r\n\t\t_paidPlayerCount = 0;\r\n        for (uint i = 0; i < round_[_rID].latestPlayers.length; i++) // remove _pID from the list first\r\n\t\t{\t\t\t\r\n\t\t\tif(round_[_rID].latestPlayers[i] == 0)  // early-stop\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(_paidPlayerCount == rule_limit_latestPlayersCnt) // already paid enough players\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t// only pay out for human player\r\n\t\t\t_pIDtmp = round_[_rID].latestPlayers[i];\r\n\t\t\tif(checkNotSmartContract(plyr_[_pIDtmp].addr))\r\n\t\t\t{\r\n\t\t\t\tplyr_[_pIDtmp].win = _bonus_portion.add(plyr_[_pIDtmp].win);\r\n\t\t\t\t_res = _res.sub(_bonus_portion);\r\n\t\t\t\tpPAIDxID_[round_[_rID].latestPlayers[i]] = _bonus_portion;\r\n\t\t\t\t_paidPlayerCount++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// pay our heavyPlayers\r\n\t\t_bonus_portion = (_win.mul(50)) / 1000; // 50x10 = 500; _win_heavyPlayer_slot\t\t\r\n\t\t_paidPlayerCount = 0;\r\n\t\tfor (i = 0; i < round_[_rID].heavyPlayers.length; i++) // remove _pID from the list first\r\n\t\t{\t\t\t\r\n\t\t\tif(round_[_rID].heavyPlayers[i] == 0)  // early-stop\r\n\t\t\t{\r\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(_paidPlayerCount == rule_limit_heavyPlayersCnt) // already paid enough players\r\n\t\t\t{\r\n\t\t\t\tbreak;\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// only pay out for human player\r\n\t\t\t_pIDtmp = round_[_rID].heavyPlayers[i];\r\n\t\t\tif(checkNotSmartContract(plyr_[_pIDtmp].addr))\r\n\t\t\t{\t\t\t\t\r\n\t\t\t\tif(pPAIDxID_[_pIDtmp] != 0) // don't paid the latestPlayer again.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t\r\n\t\t\t\tplyr_[_pIDtmp].win = _bonus_portion.add(plyr_[_pIDtmp].win);\r\n\t\t\t\t_res = _res.sub(_bonus_portion);\r\n\t\t\t\t_paidPlayerCount++;\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t\t// clear pPAIDxID_ for the use in next round's endround process.\r\n\t\tfor (i = 0; i < round_[_rID].latestPlayers.length; i++)\r\n\t\t\tpPAIDxID_[round_[_rID].latestPlayers[i]] = 0;\t\t\r\n\t\t\r\n\t\treturn (_res,_eventData_);\r\n\t}\r\n\t\r\n    /**\r\n     * @dev note neccessary info.\r\n     */\r\n    function internalNoter(uint256 _rID, uint256 _pID)\r\n        private\r\n    {\r\n\t\t\t//update latestPlayers\r\n\t\t\tuint idx_to_insert = round_[_rID].latestPlayers.length - 1; // default goes to the end of list\r\n\t\t\tfor (uint i = 0; i < round_[_rID].latestPlayers.length; i++) // remove _pID from the list first\r\n\t\t\t{\r\n\t\t\t\tif(round_[_rID].latestPlayers[i] == 0)  // early-stop\r\n\t\t\t\t{\r\n\t\t\t\t\tidx_to_insert = i;\r\n\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(round_[_rID].latestPlayers[i] == _pID) // case: if _pID already on the list\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (uint j = i; j < (round_[_rID].latestPlayers.length - 1); j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tround_[_rID].latestPlayers[j] = round_[_rID].latestPlayers[j+1]; // remove item i\r\n\t\t\t\t\t\tif(round_[_rID].latestPlayers[j+1] == 0) // early-stop\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\t\t\t\r\n\t\t\t}\t\t\t\r\n\t\t\tif (idx_to_insert == (round_[_rID].latestPlayers.length - 1)) // only do it when former loop hasn't found an idx to insert\r\n\t\t\t{\r\n\t\t\t\tfor (i = (round_[_rID].latestPlayers.length - 1); i >= 0; i--) // reversely checking for an empty position\r\n\t\t\t\t{\t\r\n\t\t\t\t\tif(round_[_rID].latestPlayers[i] == 0) // case: in the beginning\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tidx_to_insert = i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\t\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tround_[_rID].latestPlayers[idx_to_insert] = _pID; // note the player to the list\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t//update heavyPlayers\r\n\t\t\tidx_to_insert = round_[_rID].heavyPlayers.length - 1; // default goes to the end of list\r\n\t\t\tfor (i = 0; i < round_[_rID].heavyPlayers.length; i++) // remove _pID from the list first\r\n\t\t\t{\r\n\t\t\t\tif(round_[_rID].heavyPlayers[i] == 0)  // early-stop\r\n\t\t\t\t{\r\n\t\t\t\t\t// do NOT take this idx as the idx_to_insert because should also sort the list based on playerRound.eth\r\n\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(round_[_rID].heavyPlayers[i] == _pID) // case: if _pID already on the list\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (j = i; j < (round_[_rID].heavyPlayers.length - 1); j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tround_[_rID].heavyPlayers[j] = round_[_rID].heavyPlayers[j+1]; // remove item i\r\n\t\t\t\t\t\tif(round_[_rID].heavyPlayers[j+1] == 0) // early-stop\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// do NOT take this idx as the idx_to_insert because should also sort the list based on playerRound.eth\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\t\t\t\r\n\t\t\t}\t\t\t\t\t\t\t\r\n\t\t\tfor (i = 0; i < round_[_rID].heavyPlayers.length; i++)\r\n\t\t\t{\t\r\n\t\t\t\tif(round_[_rID].heavyPlayers[i] == 0) // case: in the beginning\r\n\t\t\t\t{\r\n\t\t\t\t\tidx_to_insert = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(plyrRnds_[_pID][_rID].eth > plyrRnds_[round_[_rID].heavyPlayers[i]][_rID].eth) // found spent eth more than another player on the list\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tidx_to_insert = i;\r\n\t\t\t\t\t\tfor (j = i; j < (round_[_rID].heavyPlayers.length - 1); j++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tround_[_rID].heavyPlayers[j+1] = round_[_rID].heavyPlayers[j]; // remove item in the end\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\t}\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\tround_[_rID].heavyPlayers[idx_to_insert] = _pID; // note the player to the list            \r\n    }\t\r\n\r\n    /**\r\n     * @dev updates masks for round and player when keys are bought\r\n     * @return dust left over \r\n     */\r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here.  is were going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n            \r\n            the player will have an additional mask that basically says \"based\r\n            on the rounds mask, my shares, and how much i've already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n        \r\n\t\tuint256 _ppt;\r\n\t\tif(round_[_rID].keys.sub(_keys) == 0) // only 1st key buyer can earn dividend based on the keys just purchased\r\n\t\t{\r\n\t\t\t// calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n\t\t\t_ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n\t\t\tround_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\t\t\t\t\r\n\t\t\t// calculate player earning from their own buy (only based on the keys\r\n\t\t\t// they just bought).  & update player earnings mask\r\n\t\t\tuint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n\t\t\tplyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n\t\t\treturn(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); // calculate & return dust\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n\t\t\t_ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys.sub(_keys));\r\n\t\t\tround_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\t\t\t\t\r\n\t\t\t// update player earnings mask so they cannot obtain profit generated based on their own input\r\n\t\t\tplyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000))).add(plyrRnds_[_pID][_rID].mask);\r\n\t\t\treturn(_gen.sub((_ppt.mul(round_[_rID].keys.sub(_keys))) / (1000000000000000000))); // calculate & return dust\r\n\t\t}\t\t\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @dev adds up unmasked earnings, & vault earnings, sets them all to 0\r\n     * @return earnings in wei format\r\n     */\r\n    function withdrawEarnings(uint256 _pID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        // from vaults \r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n    \r\n    /**\r\n     * @dev prepares compression data and fires event for buy or reload tx's\r\n     */\r\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, H3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n        \r\n        emit H3Devents.onEndTx\r\n        (\r\n            _eventData_.compressedData,\r\n            _eventData_.compressedIDs,\r\n            plyr_[_pID].name,\r\n            msg.sender,\r\n            _eth,\r\n            _keys,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.winnerName,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.P3DAmount,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount,\r\n            airDropPot_\r\n        );\r\n    }\r\n//==============================================================================\r\n//    (~ _  _    _._|_    .\r\n//    _)(/_(_|_|| | | \\/  .\r\n//====================/=========================================================\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs \r\n     * have time to set things up on the web end                            **/\r\n    bool public activated_ = false;\r\n    function activate()\r\n        public\r\n    {\r\n        // only Team Dream can activate \r\n        require(\r\n            msg.sender == owner,\r\n            \"only Team Dream can activate\"\r\n        );\r\n        \r\n        // can only be ran once\r\n        require(activated_ == false, \"Heaven3D already activated\");\r\n        \r\n        // activate the contract \r\n        activated_ = true;\r\n        \r\n        // lets start first round\r\n\t\trID_ = 1;\r\n        round_[1].strt = now + rndExtra_ - rndGap_;\r\n        round_[1].end = now + rndInit_ + rndExtra_;\r\n    }\r\n\t\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary H3Ddatasets {\r\n    //compressedData key\r\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\r\n        // 0 - new player (bool)\r\n        // 1 - joined round (bool)\r\n        // 2 - new  leader (bool)\r\n        // 3-5 - air drop tracker (uint 0-999)\r\n        // 6-16 - round end time\r\n        // 17 - winnerTeam\r\n        // 18 - 28 timestamp \r\n        // 29 - team\r\n        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\r\n        // 31 - airdrop happened bool\r\n        // 32 - airdrop tier \r\n        // 33 - airdrop amount won\r\n    //compressedIDs key\r\n    // [77-52][51-26][25-0]\r\n        // 0-25 - pID \r\n        // 26-51 - winPID\r\n        // 52-77 - rID\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 P3DAmount;          // amount distributed to p3d\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter and also for dividend upper bound limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask \r\n\t\tuint256 eth_went_to_gen;    // dividend earned and moved to gen bal. \r\n        uint256 ico;    // ICO phase investment\r\n    }\r\n    struct Round {\r\n\t\tuint256[20] latestPlayers; \t// latest players\r\n\t\tuint256[20] heavyPlayers; \t// players with top eth invested \r\n\t\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  |  _      _ _ | _  .\r\n//  |<(/_\\/  (_(_||(_  .\r\n//=======/======================================================================\r\nlibrary H3DKeysCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  . _ _|_ _  _ |` _  _ _  _  .\r\n//  || | | (/_| ~|~(_|(_(/__\\  .\r\n//==============================================================================\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n\r\ninterface TeamDreamHubInterface {\r\n    function deposit() external payable;\r\n}\r\n\r\n/**\r\n* @title -Name Filter- v0.1.9\r\n*       \r\n*                \r\n*               \r\n*                                  _____                      _____\r\n*                                 (, /     /)       /) /)    (, /      /)          /)\r\n*                                /   _ (/_      // //       /  _   // _   __  _(/\r\n*                            ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_\r\n*                           /   /          .-/ _____   (__ /                               \r\n*                            (__ /          (_/ (, /                                      /) \r\n*                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/\r\n*                            /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_\r\n*                             (__ /              .-/   Jekyll Island Inc. 2018\r\n*                                            (_/\r\n*              _       __    _      ____      ____  _   _    _____  ____  ___  \r\n*=============| |\\ |  / /\\  | |\\/| | |_ =====| |_  | | | |    | |  | |_  | |_)==============*\r\n*=============|_| \\| /_/--\\ |_|  | |_|__=====|_|   |_| |_|__  |_|  |_|__ |_| \\==============*\r\n*\r\n*    \r\n*                   Inventor \r\n*         \r\n*/\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXaddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receivePlayerNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_noMoreNextRound\",\"type\":\"bool\"}],\"name\":\"noMoreNextRoundSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"randomDecisionPhase_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"eth_went_to_gen\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noMoreNextRound_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TeamDreamHub_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PlayerBook\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_TeamDreamHubSCaddress\",\"type\":\"address\"},{\"name\":\"_PlayerBookSCaddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"randNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"decision\",\"type\":\"bool\"}],\"name\":\"onNewDecision\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airDropPot\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountAddedToPot\",\"type\":\"uint256\"}],\"name\":\"onPotSwapDeposit\",\"type\":\"event\"}]","ContractName":"Heaven3D","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000003e5793400dfb62f8eb469f4ffa84862cc1e6acc0000000000000000000000004ee1ba168551379fd8a59e2e918ff9ee109a6abf","Library":"","SwarmSource":"bzzr://9ce12b9f55ace14a48f5adcc4e6a8f66a81f5f06925231bd7ddc55238561846b"}]}