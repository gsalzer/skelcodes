{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Lottery {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint8;\r\n\r\n    uint private lotteryBalance;\r\n    uint private ticketsCount;\r\n\r\n    address[] internal ticketsAddresses;\r\n    mapping(address => uint) internal tickets;\r\n\r\n    uint constant private DEPOSIT_MULTIPLY = 100 finney; // 0.1 eth\r\n    uint8 constant internal ITERATION_LIMIT = 150;\r\n    uint8 private generatorOffset = 0;\r\n    uint private randomNumber = 0;\r\n\r\n    Utils.winner private lastWinner;\r\n\r\n    function addLotteryParticipant(address addr, uint depositAmount) internal {\r\n        if (depositAmount >= DEPOSIT_MULTIPLY) {\r\n            uint investorTicketCount = depositAmount.div(DEPOSIT_MULTIPLY);\r\n            ticketsCount = ticketsCount.add(investorTicketCount);\r\n            ticketsAddresses.push(addr);\r\n            tickets[addr] = tickets[addr].add(investorTicketCount);\r\n        }\r\n    }\r\n\r\n    function getLotteryBalance() public view returns(uint) {\r\n\r\n        return lotteryBalance;\r\n    }\r\n\r\n    function increaseLotteryBalance(uint value) internal {\r\n\r\n        lotteryBalance = lotteryBalance.add(value);\r\n    }\r\n\r\n    function resetLotteryBalance() internal {\r\n\r\n        ticketsCount = 0;\r\n        lotteryBalance = 0;\r\n    }\r\n\r\n    function setLastWinner(address addr, uint balance, uint prize, uint date) internal {\r\n        lastWinner.addr = addr;\r\n        lastWinner.balance = balance;\r\n        lastWinner.prize = prize;\r\n        lastWinner.date = date;\r\n    }\r\n\r\n    function getLastWinner() public view returns(address, uint, uint, uint) {\r\n        return (lastWinner.addr, lastWinner.balance, lastWinner.prize, lastWinner.date);\r\n    }\r\n\r\n    function getRandomLotteryTicket() internal returns(address) {\r\n        address addr;\r\n        if (randomNumber != 0)\r\n            randomNumber = random(ticketsCount);\r\n        uint edge = 0;\r\n        for (uint8 key = generatorOffset; key < ticketsAddresses.length && key < ITERATION_LIMIT; key++) {\r\n            addr = ticketsAddresses[key];\r\n            edge = edge.add(tickets[addr]);\r\n            if (randomNumber <= edge) {\r\n                randomNumber = 0;\r\n                generatorOffset = 0;\r\n                return addr;\r\n            }\r\n        }\r\n        generatorOffset = key;\r\n        return 0;\r\n    }\r\n\r\n    function random(uint max) private view returns (uint) {\r\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % max + 1;\r\n    }\r\n}\r\n\r\ncontract Stellar {\r\n    using SafeMath for uint;\r\n\r\n    uint private stellarInvestorBalance;\r\n\r\n    struct stellar {\r\n        address addr;\r\n        uint balance;\r\n    }\r\n\r\n    stellar private stellarInvestor;\r\n\r\n    Utils.winner private lastStellar;\r\n\r\n    event NewStellar(address addr, uint balance);\r\n\r\n    function checkForNewStellar(address addr, uint balance) internal {\r\n        if (balance > stellarInvestor.balance) {\r\n            stellarInvestor = stellar(addr, balance);\r\n            emit NewStellar(addr, balance);\r\n        }\r\n    }\r\n\r\n    function getStellarInvestor() public view returns(address, uint) {\r\n\r\n        return (stellarInvestor.addr, stellarInvestor.balance);\r\n    }\r\n\r\n    function getStellarBalance() public view returns(uint) {\r\n\r\n        return stellarInvestorBalance;\r\n    }\r\n\r\n    function increaseStellarBalance(uint value) internal {\r\n\r\n        stellarInvestorBalance = stellarInvestorBalance.add(value);\r\n    }\r\n\r\n    function resetStellarBalance() internal {\r\n        stellarInvestorBalance = 0;\r\n    }\r\n\r\n    function resetStellarInvestor() internal {\r\n        stellarInvestor.addr = 0;\r\n        stellarInvestor.balance = 0;\r\n    }\r\n\r\n    function setLastStellar(address addr, uint balance, uint prize, uint date) internal {\r\n        lastStellar.addr = addr;\r\n        lastStellar.balance = balance;\r\n        lastStellar.prize = prize;\r\n        lastStellar.date = date;\r\n    }\r\n\r\n    function getLastStellar() public view returns(address, uint, uint, uint) {\r\n        return (lastStellar.addr, lastStellar.balance, lastStellar.prize, lastStellar.date);\r\n    }\r\n}\r\n\r\ncontract Star is Lottery, Stellar {\r\n\r\n    using Math for Math.percent;\r\n    using SafeMath for uint;\r\n\r\n    uint constant private MIN_DEPOSIT = 10 finney; // 0.01 eth\r\n    uint constant private PAYOUT_INTERVAL = 23 hours;\r\n    uint constant private WITHDRAW_INTERVAL = 12 hours;\r\n    uint constant private PAYOUT_TRANSACTION_LIMIT = 100;\r\n\r\n    Math.percent private DAILY_PERCENT =  Math.percent(35, 10); // Math.percent(35, 10) = 35 / 10 = 3.5%\r\n    Math.percent private FEE_PERCENT = Math.percent(18, 1);\r\n    Math.percent private LOTTERY_PERCENT = Math.percent(1, 1);\r\n    Math.percent private STELLAR_INVESTOR_PERCENT = Math.percent(1, 1);\r\n\r\n    address internal owner;\r\n\r\n    uint8 cycle;\r\n\r\n    address[] internal addresses;\r\n\r\n    uint internal investorCount;\r\n    uint internal lastPayoutDate;\r\n    uint internal lastDepositDate;\r\n\r\n    bool public isCycleFinish = false;\r\n\r\n    struct investor {\r\n        uint id;\r\n        uint balance;\r\n        uint depositCount;\r\n        uint lastDepositDate;\r\n    }\r\n\r\n    mapping(address => investor) internal investors;\r\n\r\n    event Invest(address addr, uint amount);\r\n    event InvestorPayout(address addr, uint amount, uint date);\r\n    event Payout(uint amount, uint transactionCount, uint date);\r\n    event Withdraw(address addr, uint amount);\r\n    event NextCycle(uint8 cycle, uint now, uint);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        addresses.length = 1;\r\n    }\r\n\r\n    function() payable public {\r\n        require(isCycleFinish == false, \"Cycle completed. The new cycle will start within 24 hours.\");\r\n\r\n        if (msg.value == 0) {\r\n            withdraw(msg.sender);\r\n            return;\r\n        }\r\n\r\n        deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function restartCycle() public onlyOwner returns(bool) {\r\n        if (isCycleFinish == true) {\r\n            newCycle();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function payout(uint startPosition) public onlyOwner {\r\n\r\n        require(isCycleFinish == false, \"Cycle completed. The new cycle will start within 24 hours.\");\r\n\r\n        uint transactionCount;\r\n        uint investorsPayout;\r\n        uint dividendsAmount;\r\n\r\n        if (startPosition == 0)\r\n            startPosition = 1;\r\n\r\n        for (uint key = startPosition; key <= investorCount && transactionCount < PAYOUT_TRANSACTION_LIMIT; key++) {\r\n            address addr = addresses[key];\r\n            if (investors[addr].lastDepositDate + PAYOUT_INTERVAL > now) {\r\n                continue;\r\n            }\r\n\r\n            dividendsAmount = getInvestorDividends(addr);\r\n\r\n            if (address(this).balance < dividendsAmount) {\r\n                isCycleFinish = true;\r\n                return;\r\n            }\r\n\r\n            addr.transfer(dividendsAmount);\r\n            emit InvestorPayout(addr, dividendsAmount, now);\r\n            investors[addr].lastDepositDate = now;\r\n\r\n            investorsPayout = investorsPayout.add(dividendsAmount);\r\n\r\n            transactionCount++;\r\n        }\r\n\r\n        lastPayoutDate = now;\r\n        emit Payout(investorsPayout, transactionCount, lastPayoutDate);\r\n    }\r\n\r\n    function deposit(address addr, uint amount) internal {\r\n        require(amount >= MIN_DEPOSIT, \"Too small amount, minimum 0.01 eth\");\r\n\r\n        investor storage user = investors[addr];\r\n\r\n        if (user.id == 0) {\r\n            user.id = addresses.length;\r\n            addresses.push(addr);\r\n            investorCount ++;\r\n        }\r\n\r\n        uint depositFee = FEE_PERCENT.getPercentFrom(amount);\r\n\r\n        increaseLotteryBalance(LOTTERY_PERCENT.getPercentFrom(amount));\r\n        increaseStellarBalance(STELLAR_INVESTOR_PERCENT.getPercentFrom(amount));\r\n\r\n        addLotteryParticipant(addr, amount);\r\n\r\n        user.balance = user.balance.add(amount);\r\n        user.depositCount ++;\r\n        user.lastDepositDate = now;\r\n        lastDepositDate = now;\r\n\r\n        checkForNewStellar(addr, user.balance);\r\n\r\n        emit Invest(msg.sender, msg.value);\r\n\r\n        owner.transfer(depositFee);\r\n    }\r\n\r\n    function withdraw(address addr) internal {\r\n        require(isCycleFinish == false, \"Cycle completed. The new cycle will start within 24 hours.\");\r\n\r\n        investor storage user = investors[addr];\r\n        require(user.id > 0, \"Account not found\");\r\n\r\n        require(now.sub(user.lastDepositDate).div(WITHDRAW_INTERVAL) > 0, \"The latest payment was earlier than 12 hours\");\r\n\r\n        uint dividendsAmount = getInvestorDividends(addr);\r\n\r\n        if (address(this).balance < dividendsAmount) {\r\n            isCycleFinish = true;\r\n            return;\r\n        }\r\n\r\n        addr.transfer(dividendsAmount);\r\n        user.lastDepositDate = now;\r\n\r\n        emit Withdraw(addr, dividendsAmount);\r\n    }\r\n\r\n    function runLottery() public onlyOwner returns(bool) {\r\n        return processLotteryReward();\r\n    }\r\n\r\n    function processLotteryReward() private returns(bool) {\r\n        if (getLotteryBalance() > 0) {\r\n            address winnerAddress = getRandomLotteryTicket();\r\n            if (winnerAddress == 0)\r\n                return false;\r\n            winnerAddress.transfer(getLotteryBalance());\r\n            setLastWinner(winnerAddress, investors[winnerAddress].balance, getLotteryBalance(), now);\r\n            resetLotteryBalance();\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function giveStellarReward() public onlyOwner {\r\n        processStellarReward();\r\n    }\r\n\r\n    function processStellarReward() private {\r\n        uint balance = getStellarBalance();\r\n        if (balance > 0) {\r\n            (address addr, uint investorBalance) = getStellarInvestor();\r\n            addr.transfer(balance);\r\n            setLastStellar(addr, investors[addr].balance, getStellarBalance(), now);\r\n            resetStellarBalance();\r\n        }\r\n    }\r\n\r\n    function getInvestorCount() public view returns (uint) {\r\n\r\n        return investorCount;\r\n    }\r\n\r\n    function getBalance() public view returns (uint) {\r\n\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getLastPayoutDate() public view returns (uint) {\r\n\r\n        return lastPayoutDate;\r\n    }\r\n\r\n    function getLastDepositDate() public view returns (uint) {\r\n\r\n        return lastDepositDate;\r\n    }\r\n\r\n    function getInvestorDividends(address addr) public view returns(uint) {\r\n        uint amountPerDay = DAILY_PERCENT.getPercentFrom(investors[addr].balance);\r\n        uint timeLapse = now.sub(investors[addr].lastDepositDate);\r\n\r\n        return amountPerDay.mul(timeLapse).div(1 days);\r\n    }\r\n\r\n    function getInvestorBalance(address addr) public view returns(uint) {\r\n\r\n        return investors[addr].balance;\r\n    }\r\n\r\n    function getInvestorInfo(address addr) public onlyOwner view returns(uint, uint, uint, uint) {\r\n\r\n        return (\r\n            investors[addr].id,\r\n            investors[addr].balance,\r\n            investors[addr].depositCount,\r\n            investors[addr].lastDepositDate\r\n        );\r\n    }\r\n\r\n    function newCycle() private {\r\n        address addr;\r\n        uint8 iteration;\r\n        uint i;\r\n\r\n        for (i = addresses.length - 1; i > 0; i--) {\r\n            addr = addresses[i];\r\n            addresses.length -= 1;\r\n            delete investors[addr];\r\n            iteration++;\r\n            if (iteration >= ITERATION_LIMIT) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (i = ticketsAddresses.length - 1; i > 0; i--) {\r\n            addr = ticketsAddresses[i];\r\n            ticketsAddresses.length -= 1;\r\n            delete tickets[addr];\r\n            iteration++;\r\n            if (iteration >= ITERATION_LIMIT) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        emit NextCycle(cycle, now, getBalance());\r\n\r\n        cycle++;\r\n        investorCount = 0;\r\n        lastPayoutDate = now;\r\n        lastDepositDate = now;\r\n        isCycleFinish = false;\r\n\r\n        resetLotteryBalance();\r\n        resetStellarBalance();\r\n        resetStellarInvestor();\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n\r\n    struct percent {\r\n        uint percent;\r\n        uint base;\r\n    }\r\n\r\n    function getPercentFrom(percent storage p, uint value) internal view returns (uint) {\r\n        return value * p.percent / p.base / 100;\r\n    }\r\n\r\n}\r\n\r\nlibrary Utils {\r\n\r\n    struct winner {\r\n        address addr;\r\n        uint balance;\r\n        uint prize;\r\n        uint date;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getStellarInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvestorInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvestorDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStellarBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastStellar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastPayoutDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"runLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvestorBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLotteryBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastDepositDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCycleFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startPosition\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giveStellarReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"InvestorPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transactionCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cycle\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"now\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NextCycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"NewStellar\",\"type\":\"event\"}]","ContractName":"Star","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ff067735b6fcfc7910102c9f69d3b94b54f375a6a81ecd3773111efe8d1ed857"}]}