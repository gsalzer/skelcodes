{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC20Interface {\r\n    function name() public view returns(bytes32);\r\n    function symbol() public view returns(bytes32);\r\n    function balanceOf (address _owner) public view returns(uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n\r\ncontract AppCoins is ERC20Interface{\r\n    // Public variables of the token\r\n    address public owner;\r\n    bytes32 private token_name;\r\n    bytes32 private token_symbol;\r\n    uint8 public decimals = 18;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n\r\n    function AppCoins() public {\r\n        owner = msg.sender;\r\n        token_name = \"AppCoins\";\r\n        token_symbol = \"APPC\";\r\n        uint256 _totalSupply = 1000000;\r\n        totalSupply = _totalSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        balances[owner] = totalSupply;                // Give the creator all initial tokens\r\n    }\r\n\r\n    function name() public view returns(bytes32) {\r\n        return token_name;\r\n    }\r\n\r\n    function symbol() public view returns(bytes32) {\r\n        return token_symbol;\r\n    }\r\n\r\n    function balanceOf (address _owner) public view returns(uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[_from] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        // Subtract from the sender\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balances[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n\r\n    function transfer (address _to, uint256 _amount) public returns (bool success) {\r\n        if( balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            emit Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return allowance[_from][msg.sender];\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ninterface ErrorThrower {\r\n    event Error(string func, string message);\r\n}\r\n\r\n\r\ncontract Ownable is ErrorThrower {\r\n    address public owner;\r\n    \r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    modifier onlyOwner(string _funcName) {\r\n        if(msg.sender != owner){\r\n            emit Error(_funcName,\"Operation can only be performed by contract owner\");\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n    function renounceOwnership() public onlyOwner(\"renounceOwnership\") {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner(\"transferOwnership\") {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n\r\n    function _transferOwnership(address _newOwner) internal {\r\n        if(_newOwner == address(0)){\r\n            emit Error(\"transferOwnership\",\"New owner's address needs to be different than 0x0\");\r\n            return;\r\n        }\r\n\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  function checkRole(address _operator, string _role)\r\n    public\r\n    view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  function hasRole(address _operator, string _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n\r\n  function addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n\r\n  function removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Whitelist is Ownable, RBAC {\r\n    string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n\r\n    modifier onlyIfWhitelisted(string _funcname, address _operator) {\r\n        if(!hasRole(_operator, ROLE_WHITELISTED)){\r\n            emit Error(_funcname, \"Operation can only be performed by Whitelisted Addresses\");\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n    function addAddressToWhitelist(address _operator)\r\n        public\r\n        onlyOwner(\"addAddressToWhitelist\")\r\n    {\r\n        addRole(_operator, ROLE_WHITELISTED);\r\n    }\r\n\r\n\r\n    function whitelist(address _operator)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return hasRole(_operator, ROLE_WHITELISTED);\r\n    }\r\n\r\n\r\n    function addAddressesToWhitelist(address[] _operators)\r\n        public\r\n        onlyOwner(\"addAddressesToWhitelist\")\r\n    {\r\n        for (uint256 i = 0; i < _operators.length; i++) {\r\n            addAddressToWhitelist(_operators[i]);\r\n        }\r\n    }\r\n\r\n\r\n    function removeAddressFromWhitelist(address _operator)\r\n        public\r\n        onlyOwner(\"removeAddressFromWhitelist\")\r\n    {\r\n        removeRole(_operator, ROLE_WHITELISTED);\r\n    }\r\n\r\n    function removeAddressesFromWhitelist(address[] _operators)\r\n        public\r\n        onlyOwner(\"removeAddressesFromWhitelist\")\r\n    {\r\n        for (uint256 i = 0; i < _operators.length; i++) {\r\n            removeAddressFromWhitelist(_operators[i]);\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract AppCoinsCreditsBalance is Whitelist {\r\n\r\n    // AppCoins token\r\n    AppCoins private appc;\r\n\r\n    // balance proof\r\n    bytes private balanceProof;\r\n\r\n    // balance\r\n    uint private balance;\r\n\r\n    event BalanceProof(bytes _merkleTreeHash);\r\n    event Deposit(uint _amount);\r\n    event Withdraw(uint _amount);\r\n\r\n    constructor(\r\n        address _addrAppc\r\n    )\r\n    public\r\n    {\r\n        appc = AppCoins(_addrAppc);\r\n    }\r\n\r\n\r\n    function getBalance() public view returns(uint256) {\r\n        return balance;\r\n    }\r\n\r\n    function getBalanceProof() public view returns(bytes) {\r\n        return balanceProof;\r\n    }\r\n\r\n \r\n    function registerBalanceProof(bytes _merkleTreeHash)\r\n        internal{\r\n\r\n        balanceProof = _merkleTreeHash;\r\n\r\n        emit BalanceProof(_merkleTreeHash);\r\n    }\r\n\r\n    function depositFunds(uint _amount, bytes _merkleTreeHash)\r\n        public\r\n        onlyIfWhitelisted(\"depositFunds\", msg.sender){\r\n        require(appc.allowance(msg.sender, address(this)) >= _amount);\r\n        registerBalanceProof(_merkleTreeHash);\r\n        appc.transferFrom(msg.sender, address(this), _amount);\r\n        balance = balance + _amount;\r\n        emit Deposit(_amount);\r\n    }\r\n\r\n    function withdrawFunds(uint _amount, bytes _merkleTreeHash)\r\n        public\r\n        onlyIfWhitelisted(\"withdrawFunds\",msg.sender){\r\n        require(balance >= _amount);\r\n        registerBalanceProof(_merkleTreeHash);\r\n        appc.transfer(msg.sender, _amount);\r\n        balance = balance - _amount;\r\n        emit Withdraw(_amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_merkleTreeHash\",\"type\":\"bytes\"}],\"name\":\"depositFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_merkleTreeHash\",\"type\":\"bytes\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addrAppc\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_merkleTreeHash\",\"type\":\"bytes\"}],\"name\":\"BalanceProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"func\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"AppCoinsCreditsBalance","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001a7a8bd9106f2b8d977e08582dc7d24c723ab0db","Library":"","SwarmSource":"bzzr://ae943a54e56dfae602ba17ab11ef088ee62fa003a2209356bc3711d031393aa0"}]}