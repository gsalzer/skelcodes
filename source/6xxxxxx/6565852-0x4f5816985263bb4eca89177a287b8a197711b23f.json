{"status":"1","message":"OK","result":[{"SourceCode":"/**+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n                            abcLotto: a Block Chain Lottery\r\n\r\n                            Don't trust anyone but the CODE!\r\n ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n /*\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without \r\n * express written consent from the creators is prohibited.\r\n */\r\n \r\n/**+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n                           this inviter book can be used by your applications too.\r\n                           \r\n                           have you heard about The 2009 DARPA Network Challenge?\r\n ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\npragma solidity ^0.4.20;\r\n\r\n/**\r\n* @title abc address resolver. \r\n */ \r\ncontract abcResolverI{\r\n    function getWalletAddress() public view returns (address);\r\n    function getAddress() public view returns (address);\r\n}\r\n\r\n/**\r\n* @title inviters book. \r\n */ \r\ncontract inviterBook{\r\n    using SafeMath for *;\r\n    //storage varible\r\n    address public owner;\r\n    abcResolverI public resolver;\r\n    address public wallet;\r\n    address public lotto;\r\n    \r\n    mapping (address=>bytes32) _alias;\r\n    mapping (bytes32=>address) _addressbook;\r\n    mapping (address=>address) _inviter;\r\n    mapping (address=>uint) _earnings;\r\n    mapping (address=>bool) _isRoot;\r\n    uint public rootNumber = 0;\r\n\r\n    //constant\r\n    uint constant REGISTRATION_FEE = 10000000000000000;    // registration fee is 0.01 ether.\r\n    \r\n    //modifier\r\n\r\n    //check contract interface, are they upgrated?\r\n    modifier abcInterface {\r\n        if((address(resolver)==0)||(getCodeSize(address(resolver))==0)){\r\n            if(abc_initNetwork()){\r\n                wallet = resolver.getWalletAddress();\r\n                lotto = resolver.getAddress();\r\n            }\r\n        }\r\n        else{\r\n            if(wallet != resolver.getWalletAddress())\r\n                wallet = resolver.getWalletAddress();\r\n\r\n            if(lotto != resolver.getAddress())\r\n                lotto = resolver.getAddress();\r\n        }    \r\n        \r\n        _;        \r\n    }    \r\n\r\n    //modifier\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        \r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized{\r\n        require(\r\n            msg.sender == lotto\r\n        );\r\n        \r\n        _;\r\n    }\r\n    //events\r\n    event OnRegisterAlias(address user, bytes32 alias);\r\n    event OnAddRoot(address root);\r\n    event OnSetInviter(address user, address inviter);\r\n    event OnWithdraw(address user, uint earning);\r\n    event OnPay(address user, uint value);\r\n    \r\n    /**\r\n    * @dev constructor\r\n    */\r\n    constructor() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    //++++++++++++++++++++++++++++++++    root inviter functions   +++++++++++++++++++++++++++++++++++++++++++++++++\r\n    //      - root inviter can't be delete.\r\n    /**\r\n    * @dev add a root inviter.\r\n    */\r\n    function addRoot(address addr) onlyOwner public{\r\n        require(_inviter[addr] == address(0x0) && _isRoot[addr] == false); \r\n        _isRoot[addr] = true;\r\n        rootNumber++;\r\n        emit OnAddRoot(addr);\r\n    }\r\n\r\n    /**\r\n    * @dev if address is a root inviter? with address param.\r\n    */\r\n    function isRoot(address addr) \r\n        public\r\n        view \r\n        returns(bool)\r\n    {\r\n        return _isRoot[addr];\r\n    }\r\n\r\n    /**\r\n    * @dev if i am a root inviter? no param.\r\n    */\r\n    function isRoot() \r\n        public\r\n        view \r\n        returns(bool)\r\n    {\r\n        return _isRoot[msg.sender];\r\n    }\r\n\r\n    /**\r\n    * @dev change owner address.\r\n    */ \r\n     function setOwner(address newOwner) \r\n        onlyOwner \r\n        public\r\n    {\r\n        require(newOwner != address(0x0));\r\n        owner = newOwner;\r\n    }    \r\n\r\n    //++++++++++++++++++++++++++++++++    inviter functions   +++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    //   - inviter can be set just once.\r\n    //   - can't set yourself as inviter.\r\n    /**\r\n    * @dev does anyone has inviter? with address param.\r\n    */ \r\n    function hasInviter(address addr) \r\n        public \r\n        view\r\n        returns(bool)\r\n    {\r\n        if(_inviter[addr] != address(0x0))\r\n            return true;\r\n        else\r\n            return false;\r\n    } \r\n    /**\r\n    * @dev does i has inviter? no param.\r\n    */     \r\n    function hasInviter() \r\n        public \r\n        view\r\n        returns(bool)\r\n    {\r\n        if(_inviter[msg.sender] != address(0x0))\r\n            return true;\r\n        else\r\n            return false;\r\n    } \r\n\r\n    /**\r\n    * @dev set self's inviter by name.\r\n    */      \r\n    function setInviter(string inviter) public{\r\n         //root player can't set inviter;\r\n        require(_isRoot[msg.sender] == false);\r\n\r\n        //inviter can be set just once.\r\n        require(_inviter[msg.sender] == address(0x0)); \r\n\r\n        //inviter must existed.\r\n        bytes32 _name = stringToBytes32(inviter);        \r\n        require(_addressbook[_name] != address(0x0));\r\n        \r\n        //can't set yourself as inviter.\r\n        require(_addressbook[_name] != msg.sender);       \r\n\r\n        //inviter must be valid. \r\n        require(isValidInviter(_addressbook[_name]));\r\n\r\n        _inviter[msg.sender] = _addressbook[_name];\r\n        emit OnSetInviter(msg.sender, _addressbook[_name]);\r\n    }\r\n    /**\r\n    * @dev set another's inviter by name. only by authorized contract.\r\n    */   \r\n    function setInviter(address addr, string inviter) \r\n        abcInterface\r\n        public\r\n        onlyAuthorized\r\n    {\r\n        //root player can't set inviter;\r\n        require(_isRoot[addr] == false);\r\n\r\n        //inviter can be set just once.\r\n        require(_inviter[addr] == address(0x0)); \r\n\r\n        //inviter must existed.\r\n        bytes32 _name = stringToBytes32(inviter);        \r\n        require(_addressbook[_name] != address(0x0));\r\n\r\n        //can't set yourself as inviter.\r\n        require(_addressbook[_name] != addr);       \r\n\r\n        //inviter must be valid. \r\n        require(isValidInviter(_addressbook[_name]));\r\n\r\n        _inviter[addr] = _addressbook[_name];\r\n        emit OnSetInviter(addr, _addressbook[_name]);\r\n    }\r\n \r\n    /**\r\n    * @dev set self's inviter by address.   \r\n    */ \r\n    function setInviterXAddr(address inviter) public{\r\n        //root player can't set inviter;\r\n        require(_isRoot[msg.sender] == false);\r\n\r\n        //inviter can be set just once.\r\n        require(_inviter[msg.sender] == address(0x0)); \r\n\r\n        //inviter must existed.        \r\n        require(inviter != address(0x0));\r\n\r\n        //can't set yourself as inviter.\r\n        require(inviter != msg.sender);       \r\n\r\n        //inviter must register his alias;\r\n        require(_alias[inviter] != bytes32(0x0));\r\n\r\n        //inviter must be valid. \r\n        require(isValidInviter(inviter));\r\n\r\n        _inviter[msg.sender] = inviter;\r\n        emit OnSetInviter(msg.sender, inviter);\r\n    }\r\n \r\n    /**\r\n    * @dev  set another's inviter by address. only authorized address can do this.\r\n    */ \r\n    function setInviterXAddr(address addr, address inviter) \r\n        abcInterface\r\n        public\r\n        onlyAuthorized\r\n    {\r\n         //root player can't set inviter;\r\n        require(_isRoot[addr] == false);\r\n\r\n        //inviter can be set just once.\r\n        require(_inviter[addr] == address(0x0)); \r\n\r\n        //inviter must existed.        \r\n        require(inviter != address(0x0));\r\n\r\n        //can't set yourself as inviter.\r\n        require(inviter != addr);       \r\n\r\n        //inviter must register his alias;\r\n        require(_alias[inviter] != bytes32(0x0));\r\n\r\n        //inviter must be valid. \r\n        require(isValidInviter(inviter));\r\n\r\n         _inviter[addr] = inviter;\r\n         emit OnSetInviter(addr, inviter);\r\n    }\r\n    \r\n     /**\r\n     * @dev get inviter's alias.\r\n     */ \r\n     function getInviter() \r\n        public \r\n        view\r\n        returns(string)\r\n     {\r\n         if(!hasInviter(msg.sender)) return \"\";\r\n        \r\n         return bytes32ToString(_alias[_inviter[msg.sender]]);\r\n     }  \r\n \r\n      /**\r\n     * @dev get inviter's address.\r\n     */ \r\n     function getInviterAddr() \r\n        public \r\n        view\r\n        returns(address)\r\n     {\r\n         return _inviter[msg.sender];\r\n     } \r\n\r\n     /**\r\n    * @dev check inviter's addr is valid.\r\n     */\r\n     function isValidInviter(address inviter)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address addr = inviter;\r\n        while(_inviter[addr] != address(0x0)){\r\n            addr = _inviter[addr];\r\n        } \r\n        \r\n        if(_isRoot[addr] == true)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n    //++++++++++++++++++++++++++++++++    earning functions   +++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n      /**\r\n     * @dev get self's referral earning.\r\n     */ \r\n     function getEarning()\r\n        public \r\n        view \r\n        returns (uint)\r\n     {\r\n         return _earnings[msg.sender];\r\n     }\r\n\r\n     /**\r\n     * @dev withdraw self's referral earning.\r\n     */ \r\n     function withdraw() public {\r\n         uint earning = _earnings[msg.sender];\r\n         if(earning>0){\r\n             _earnings[msg.sender] = 0;\r\n             msg.sender.transfer(earning);\r\n             emit OnWithdraw(msg.sender, earning);             \r\n         }\r\n     }\r\n\r\n     /**\r\n     * @dev fallback funtion, calculate inviter's earning. no param.\r\n     *      - direct inviter get 1/2 of the total value.\r\n     *      - direct inviter's inviter get 1/2 of the direct inviter, and so on.\r\n     *      - remaining balance transfered to a wallet.\r\n     */\r\n    function() \r\n        abcInterface\r\n        public \r\n        payable \r\n    {\r\n        address addr = msg.sender;\r\n        uint balance = msg.value;\r\n        uint earning = 0;\r\n        \r\n        while(_inviter[addr] != address(0x0)){\r\n            addr = _inviter[addr];\r\n            earning = balance.div(2);\r\n            balance = balance.sub(earning);\r\n            _earnings[addr] = _earnings[addr].add(earning);\r\n        }\r\n        \r\n        wallet.transfer(balance);\r\n        emit OnPay(msg.sender, msg.value);\r\n    }\r\n     \r\n     /**\r\n     * @dev pay funtion, calculate inviter's earning. \r\n     *      - direct inviter get 1/2 of the total value.\r\n     *      - direct inviter's inviter get 1/2 of the direct inviter, and so on.\r\n     *      - remaining balance transfered to a wallet.\r\n     */\r\n    function pay(address addr) \r\n        abcInterface\r\n        public \r\n        payable \r\n        onlyAuthorized\r\n    {\r\n        address _addr = addr;\r\n        uint balance = msg.value;\r\n        uint earning = 0;\r\n        \r\n        while(_inviter[_addr] != address(0x0)){\r\n            _addr = _inviter[_addr];\r\n            earning = balance.div(2);\r\n            balance = balance.sub(earning);\r\n            _earnings[_addr] = _earnings[_addr].add(earning);\r\n        }\r\n        \r\n        wallet.transfer(balance);\r\n        emit OnPay(addr, msg.value);\r\n    }\r\n    //++++++++++++++++++++++++++++++++    alias functions  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n     /**\r\n     * @dev register a alias. you can register alias several times.\r\n     */    \r\n     function registerAlias(string alias) \r\n        abcInterface \r\n        public \r\n        payable\r\n     {\r\n         require(msg.value >= REGISTRATION_FEE);\r\n         \r\n         //alias must be unique.\r\n         bytes32 _name = nameFilter(alias);\r\n         require(_addressbook[_name] == address(0x0));\r\n\r\n         //player hasn't inviter or no root can't register alias.\r\n         require(hasInviter() || _isRoot[msg.sender] == true);\r\n\r\n         if(_alias[msg.sender] != bytes32(0x0)){\r\n             //remove old alias mapping key.\r\n            _addressbook[_alias[msg.sender]] = address(0x0);\r\n         }\r\n         _alias[msg.sender] = _name;\r\n         _addressbook[_name] = msg.sender;\r\n\r\n         wallet.transfer(REGISTRATION_FEE);\r\n         //refund extra value.\r\n         if(msg.value > REGISTRATION_FEE){\r\n             msg.sender.transfer( msg.value.sub( REGISTRATION_FEE ));\r\n         }\r\n         emit OnRegisterAlias(msg.sender,_name);\r\n     }    \r\n     \r\n     /**\r\n     * @dev does alias exist?\r\n     */  \r\n     function aliasExist(string alias) \r\n        public \r\n        view \r\n        returns(bool) \r\n    {\r\n        bytes32 _name = stringToBytes32(alias);\r\n        if(_addressbook[_name] == address(0x0))\r\n            return false;\r\n        else\r\n            return true;\r\n     }\r\n     \r\n     /**\r\n     * @dev get self's alias.\r\n     */ \r\n    function getAlias() \r\n        public \r\n        view \r\n        returns(string)\r\n    {\r\n         return bytes32ToString(_alias[msg.sender]);\r\n    }\r\n\r\n    //++++++++++++++++++++++++++++++++     auxiliary functions  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n     /**\r\n     * @dev name string filters\r\n     * -length limited to 32 characters.\r\n     * -restricts characters to A-Z, a-z, 0-9.\r\n     * -cannot be only numbers.\r\n     * -cannot start with 0x.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0);\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78);\r\n            require(_temp[1] != 0x58);\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            require\r\n            (\r\n                // require character is A-Z\r\n                (_temp[i] > 0x40 && _temp[i] < 0x5b) || \r\n                // OR lowercase a-z\r\n                (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                // or 0-9\r\n                (_temp[i] > 0x2f && _temp[i] < 0x3a)\r\n             );\r\n                \r\n            // see if we have a character other than a number\r\n            if (_hasNonNumber == false && _temp[i] > 0x3a)\r\n                _hasNonNumber = true;    \r\n        \r\n        }\r\n        \r\n        require(_hasNonNumber == true);\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }    \r\n \r\n    /*\r\n    * @dev transfer string to bytes32\r\n    */\r\n    function stringToBytes32(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //limited to 32 characters\r\n        if (_length > 32 || _length == 0) return \"\";\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }   \r\n\r\n    /*\r\n    * @dev transfer bytes32 to string\r\n    */    \r\n     function bytes32ToString(bytes32 x) \r\n        internal\r\n        pure \r\n        returns (string) \r\n    {\r\n         bytes memory bytesString = new bytes(32);\r\n         uint charCount = 0;\r\n         for (uint j = 0; j < 32; j++) {\r\n             byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n             if (char != 0) {\r\n                 bytesString[charCount] = char;\r\n                 charCount++;\r\n             }\r\n         }\r\n         bytes memory bytesStringTrimmed = new bytes(charCount);\r\n         for (j = 0; j < charCount; j++) {\r\n             bytesStringTrimmed[j] = bytesString[j];\r\n         }\r\n         return string(bytesStringTrimmed);\r\n     }\r\n     \r\n    /**\r\n    * @dev init address resolver.\r\n    */ \r\n    function abc_initNetwork() \r\n        internal \r\n        returns(bool) \r\n    { \r\n         //mainnet\r\n         if (getCodeSize(0xde4413799c73a356d83ace2dc9055957c0a5c335)>0){     \r\n            resolver = abcResolverI(0xde4413799c73a356d83ace2dc9055957c0a5c335);\r\n            return true;\r\n         }\r\n         \r\n         //rinkeby\r\n         if (getCodeSize(0xcaddb7e777f7a1d4d60914cdae52aca561d539e8)>0){     \r\n            resolver = abcResolverI(0xcaddb7e777f7a1d4d60914cdae52aca561d539e8);\r\n            return true;\r\n         }         \r\n         //others ...\r\n\r\n         return false;\r\n    }      \r\n    /**\r\n    * @dev get code size of appointed address.\r\n     */\r\n     function getCodeSize(address _addr) \r\n        internal \r\n        view \r\n        returns(uint _size) \r\n    {\r\n         assembly {\r\n             _size := extcodesize(_addr)\r\n         }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath : it's from openzeppelin.\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) public pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) public pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) public pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) public pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInviter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"setInviterXAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInviterAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"inviter\",\"type\":\"string\"}],\"name\":\"setInviter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"alias\",\"type\":\"string\"}],\"name\":\"aliasExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"setInviterXAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlias\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInviter\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviter\",\"type\":\"string\"}],\"name\":\"setInviter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"alias\",\"type\":\"string\"}],\"name\":\"registerAlias\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotto\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasInviter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"alias\",\"type\":\"bytes32\"}],\"name\":\"OnRegisterAlias\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"root\",\"type\":\"address\"}],\"name\":\"OnAddRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"OnSetInviter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"earning\",\"type\":\"uint256\"}],\"name\":\"OnWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OnPay\",\"type\":\"event\"}]","ContractName":"inviterBook","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"SafeMath:b958e26be5f1e5c74ee8c3ccc7732714cffd4668","SwarmSource":"bzzr://8a0afb2c0278958189121ebe77c92bfcef50f833ba660c05a5143eba1a03558e"}]}