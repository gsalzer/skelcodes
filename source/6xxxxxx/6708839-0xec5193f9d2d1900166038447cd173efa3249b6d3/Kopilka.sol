pragma solidity ^0.4.25;

/**
 * Контракт Копилка
 *
 * Возвращает проценты от ваших депозитов, каждый следующий больше предыдущего
 * до достижения итоговой суммарной прибыли от 53% до 70%.
 *
 * Первый депозит определяет ваш ежедневный взнос
 * Это определяет, сколько вы можете вносить в копилку в среднем в течение дня.
 *
 * Копилка на каждый депозит (после первого) возвращает постоянно
 * увеличивающийся процент от внесенного депозита
 *
 * Когда суммарно внесенная сумма становится кратна депозиту, вы переходите на
 * новый уровень. С каждым уровнем возвращаемые копилкой проценты увеличиваются.
 * Уровень - это во сколько раз сумма внесенных вами взносов больше первого депозита.
 *
 * Например, вы внесли 1 ETH. Теперь это ваш средний ежедневный взнос. И вы
 * на 1 уровне.
 *
 * Через день вы внесли 0.5 ETH. Общая сумма вкладов 1.5 ETH, вы всё ещё
 * на первом уровне. Копилка сразу же возвращает вам примерно 0.24% от вклада
 *
 * Еще через день вы внесли еще 1 ETH. 0.5 ETH из них идут на первый уровень
 * до достижения вами суммарно внесенной сумме 2 ETH, а ещё 0.5 уже на втором
 * вашем уровне. Копилка сразу возвращает вам 0.24% от 0.5 ETH и 0.96% от 0.5 на
 * втором уровне.
 *
 * И так далее. Примерно на 20м уровне копилка будет возвращать около 100%
 * взноса. Примерно на 35м уровне копилка будет возвращать около 300% взноса
 * и в сумме вы получите всё, что внесли, обратно. Далее до 45 уровня идет
 * чистая прибыль. Внося ежедневный взнос, вы сразу получаете обратно от 300%
 * до 500% от взноса. Перехода на 46й уровень не происходит, вы удаляетесь
 * из копилки и для продолжения получения прибыли вам нужно делать новый вклад.
 *
 * Замечания:
 *
 * Минимальный первый депозит 0.01 ETH, максимальный - 5 ETH
 *
 * Помните, что рассчитать первый депозит надо таким образом, чтобы вы смогли
 * примерно ежедневно в течение 20 дней вносить его в копилку. Далее копилка
 * будет возвращать вам больше, чем вы вносите, так что проблем не будет.
 *
 * При ежедневном взносе 0.01 ETH суммарная прибыль 70%, 1 ETH - 67%,
 * 5 ETH - 53%, при промежуточных суммах - где-то между ними (процент убывает
 * с ростом первого депозита).
 *
 * Вы можете вносить ежедневные взносы в любое время, любыми частями. Вы не
 * потеряете время, если в среднем будете вносить в неделю сумму, равную 7
 * первым депозитам. Это можно сделать и в последний день недели. А можно
 * частями в течение недели. Тогда вы будете набирать 7 уровней в неделю.
 *
 * За один платеж вы сможете продвинуться максимум на 7 уровней. Поэтому, если
 * даже последний платеж вы сделали больше недели назад, при совершении
 * максимального платежа, вам из них будет засчитана только неделя.
 *
 * Контракт отслеживает, сколько вы можете внести на текущий момент, чтобы
 * взносы в среднем в день не превышали размера первоначального депозита. Если вы
 * пытаетесь внести большую сумму, контракт примет только максимально разрешенную
 * для вас сумму и вернет сдачу. Поэтому вы можете не беспокоиться и посылать
 * любые суммы.
 *
 * Возврат депозитов.
 *
 * Если вы неправильно подобрали размер взноса или просто хотите перестать копить,
 * то вы можете забрать депозит, послав 0.00000112 на адрес контракта.
 * Будет возвращено 70% от внесенных вами средств + у вас останется всё то,
 * что вам уже выплатила копилка. Возврат депозита возможен до 10 уровня включительно.
 *
 *
 */

/** Таблица депозитов и возвратов для начального депозита 1 ETH

       Уровень/      Проценты        Суммарный
       Cумма (ETH)	  Возврата        доход (ETH)
           1			0,24%			0,00
           2			0,96%			0,01
           3			2,15%			0,03
           4			3,82%			0,07
           5			5,98%			0,13
           6			8,60%			0,22
           7			11,7%			0,33
           8			15,3%			0,49
           9			19,4%			0,68
           10			23,9%			0,92
           11			28,9%			1,21
           12			34,4%			1,55
           13			40,4%			1,96
           14			46,8%			2,43
           15			53,8%			2,96
           16			61,2%			3,58
           17			69,1%			4,27
           18			77,4%			5,04
           19			86,3%			5,90
           20			95,6%			6,86
           21			105%			7,91
           22			116%			9,07
           23			126%			10,33
           24			138%			11,71
           25			149%			13,20
           26			162%			14,82
           27			174%			16,56
           28			187%			18,44
           29			201%			20,45
           30			215%			22,60
           31			230%			24,89
           32			245%			27,34
           33			260%			29,94
           34			276%			32,71
           35			293%			35,63
           36			310%			38,73
           37			327%			42,00
           38			345%			45,46
           39			364%			49,09
           40			382%			52,91
           41			402%			56,93
           42			422%			61,15
           43			442%			65,57
           44			463%			70,19
           45			484%			75,03
*/

contract Kopilka {
    uint constant ADV_PERCENT = 2; //2%
    uint constant TEAM_PERCENT = 2; //2%
    uint constant MAX_LEVEL = 45; //Максимальный уровень, который можно достичь
    uint constant PERIOD = 1 days; //Регулярность внесения взносов
    uint constant MAX_ONE_TIME_PERIODS = 7; //Максимальный размер взноса (за сколько дней)
    uint constant MIN_DEPOSIT = 0.01 ether; //Минимальный депозит
    uint constant MAX_DEPOSIT = 5 ether;    //Максимальный депозит
    uint constant RETURN_DEPOSIT_PERCENT = 70; //70% - процент возврата депозита
    uint constant MAX_LEVEL_TO_RETURN_DEPOSIT = 10; //Уровень, до которого можно вернуть депозит

    //Структура данных пользователя
    struct User {
        uint dep;   //Размер ежедневного взноса
        uint value; //Сумма всех взносов
        uint atTime;//Когда был сделан последний взнос (если бы они делались максимально равномерно)
    }

    //Все пользователи
    mapping (address => User) public users;

    //Адреса кошельков администрации
    address constant TEAM_ADDRESS = 0xF996A4e45E2f32F6BC5827A2448f7c2e54F69845;
    address constant ADV_ADDRESS = 0x18d84B54b6b1AEC9cdb2ef9B60E669FAD12Bb778;

    function () public payable {
        User storage user = users[msg.sender]; // это вы

        if (msg.value != 0.00000112 ether) { //Если внесли взнос, то
            //Отчисления администрации на развитие проекта
            ADV_ADDRESS.transfer(msg.value * ADV_PERCENT / 100);
            TEAM_ADDRESS.transfer(msg.value * TEAM_PERCENT / 100);

            if (user.value == 0) { //Если пользователя ещё не было
                //То это первый взнос. Надо его проверить на величину
                require(MIN_DEPOSIT <= msg.value && msg.value <= MAX_DEPOSIT);

                //Создаём пользователя
                user.dep = msg.value;
                user.value = msg.value;
                user.atTime = now;
            } else { //Это повторый взнос

                //Узнаём, сколько можно ещё пользователю внести
                //исходя из скорости внесения первый взнос/в день.
                uint allowed = getAllowedInvestmentAmount(msg.sender);

                //Сколько он прислал
                uint investment = msg.value;
                uint sendback = 0; //Сколько мы должны ему отправить обратно

                //Если он прислал больше, чем ему разрешено
                if(investment > allowed){
                    //Сразу записываем ему сдачу
                    sendback = investment - allowed;
                    //Позволяем ему внести только сколько разрешено
                    investment = allowed;
                }

                //Корректируем время последнего взноса с учетом неполного взноса
                //Чтобы можно было довнести позже
                user.atTime = now - (allowed - investment)*PERIOD/user.dep;

                uint dep = user.dep;  //Размер первого взноса
                uint amount = user.value; //Сколько пользователь уже всего внес
                uint level = amount/dep; //На каком уровне пользователь
                uint endLevel = (amount+investment)/dep; //На каком уровне он окажется после этого взноса

                //По всем новым уровням надо сделать ему выплаты
                for(uint l=level; l<=endLevel; ++l){
                    //Определяем размер взноса на данном уровне
                    uint levelInvestment = dep*(l+1) - amount;
                    //Если макс размер взноса на этом уровне превышает фактический взнос
                    //то частично оплачиваем данный уровень
                    if(levelInvestment > investment) levelInvestment = investment;

                    //Добавляем выплату на текущем уровне
                    sendback += calcReturn(levelInvestment, l);
                    //Добавляем эту выплату к сумме всех взносов пользователя
                    amount += levelInvestment;
                    //Вычитаем уже засчитанный взнос из присланного пользователем взноса
                    investment -= levelInvestment;
                }

                //Обновляем сумму взносов пользователя
                user.value = amount;

                //Если пользователь перешел на слишком высокий уровень
                //Удаляем его из копилки
                if(endLevel > MAX_LEVEL)
                    delete users[msg.sender];

                //Отправляем сдачу и проценты за взнос пользователю
                msg.sender.transfer(sendback);
            }
        } else if(user.dep > 0){ //Если пользователь вообще что-то вносил
            //Проверяем, что у него не слишком большой уровень для возврата взносов
            require(user.value/user.dep <= MAX_LEVEL_TO_RETURN_DEPOSIT, "It's too late to request a refund at this point");

            //Возвращаем 70% от всего им внесенного. Проценты, уже выплаченные ему, у него остаются.
            msg.sender.transfer(user.value * RETURN_DEPOSIT_PERCENT / 100);

            //Удаляем пользователя из копилки.
            delete users[msg.sender];
        }

    }

    //Получает максимально возможный взнос от пользователя на текущий момент
    //Из расчета, чтобы пользователь вносил в среднем размер первого депозита в день.
    function getAllowedInvestmentAmount(address addr) public view returns (uint) {
        User storage user = users[addr]; // пользователь
        //Сколько надо было бы внести, если делать это аккуратно
        uint allowed = user.dep * (now - user.atTime) / PERIOD;
        //Если внести надо больше, чем за неделю, уменьшаем до взноса за неделю
        if(allowed > MAX_ONE_TIME_PERIODS*user.dep)
            allowed = MAX_ONE_TIME_PERIODS*user.dep;
        //Проверим, что этот взнос не превысит максимальную сумму взносов
        uint max_investment = user.dep*MAX_LEVEL;
        //Если взнос превысит максимальную сумму взносов пользователя
        //То уменьшаем взнос до безопасной величины
        if(user.value + allowed > max_investment)
            allowed = max_investment > user.value ? max_investment - user.value : 0;
        //Возвращаем размер текущего макс взноса
        return allowed;
    }

    //Получает возврат процента от заданного взноса на заданном уровне
    function calcReturn(uint investment, uint level) public pure returns (uint){
        //Если уроверь больше максимального, то ничего не возвращем
        if(level > MAX_LEVEL)
            level = 0;
        require(investment <= MAX_DEPOSIT);
        //Хитрая квадратичная формула, которая позволяет вначале проценты давать маленькие,
        //а потом большие, подобрана для оптимальной работы контракта и хорошей прибыли
        //пользователей. Таблица значений для примера в комментариях в шапке.
        return investment * level * level * (24400 - 500 * investment / 1 ether) / 10000000;
    }

    //Получает процент, который будет выплачиваться при заданном первом взносе на заданном уровне
    function calcReturnPercent(uint dep, uint level) public pure returns(uint) {
        return calcReturn(dep, level)*1000000/dep;
    }

    //Получает все проценты на всех уровнях для заданного первого взноса
    function calcReturnPercents(uint dep) public pure returns (uint[] percents){
        percents = new uint[](MAX_LEVEL);
        for(uint i=0; i<MAX_LEVEL; ++i){
            percents[i] = calcReturnPercent(dep, i);
        }
    }

}
