{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: contracts/IAccounting.sol\r\n\r\ninterface IAccounting {\r\n  function contribute(\r\n    address contributor,\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external returns(uint128 deposited, uint128 depositedFees);\r\n\r\n  function withdrawContribution(address contributor) external returns(\r\n    uint128 withdrawn,\r\n    uint128 withdrawnFees\r\n  );\r\n\r\n  function finalize(uint128 amountDisputed) external;\r\n\r\n  function getTotalContribution() external view returns(uint256);\r\n\r\n  function getTotalFeesOffered() external view returns(uint256);\r\n\r\n  function getProjectedFee(uint128 amountDisputed) external view returns(\r\n    uint128 feeNumerator,\r\n    uint128 fundsUsedFromBoundaryBucket\r\n  );\r\n\r\n  function getOwner() external view returns(address);\r\n\r\n  function isFinalized() external view returns(bool);\r\n\r\n  /**\r\n   * Return value is how much REP and dispute tokens the contributor is entitled to.\r\n   *\r\n   * Does not change the state, as accounting is finalized at that moment.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateProceeds(address contributor) external view returns(\r\n    uint128 rep,\r\n    uint128 disputeTokens\r\n  );\r\n\r\n  /**\r\n   * Calculate fee that will be split between contract admin and\r\n   * account that triggered dispute transaction.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateFees() external view returns(uint128);\r\n\r\n  function addFeesOnTop(\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external pure returns(uint128);\r\n}\r\n\r\n// File: contracts/IAccountingFactory.sol\r\n\r\ninterface IAccountingFactory {\r\n  function create(address owner) external returns(IAccounting);\r\n}\r\n\r\n// File: contracts/Accounting.sol\r\n\r\n/**\r\n * Keeps track of all contributions, and calculates how much each contributor\r\n * is entitled to.\r\n *\r\n * Doesn't actually hold any funds, just keeps records.\r\n */\r\ncontract Accounting is IAccounting {\r\n  uint128 public constant FEE_DENOMINATOR = 1000;\r\n  address public m_owner;\r\n\r\n  uint128 private m_totalContribution;\r\n  uint128 private m_totalFeesOffered;\r\n  uint128[FEE_DENOMINATOR] public m_contributionPerFeeNumerator;\r\n  mapping(address => uint128) public m_feeNumeratorPerContributor;\r\n  mapping(address => uint128) public m_contributionPerContributor;\r\n\r\n  // populated at finalization\r\n  bool public m_isFinalized = false;\r\n  uint128 public m_fundsUsed;\r\n  uint128 public m_boundaryFeeNumerator;\r\n  uint128 public m_fundsUsedFromBoundaryBucket;\r\n\r\n  constructor(address owner) public {\r\n    m_owner = owner;\r\n  }\r\n\r\n  modifier ownerOnly() {\r\n    require(msg.sender == m_owner, \"Not Authorized\");\r\n    _;\r\n  }\r\n\r\n  modifier beforeFinalizationOnly() {\r\n    require(!m_isFinalized, \"Method only allowed before finalization\");\r\n    _;\r\n  }\r\n\r\n  modifier afterFinalizationOnly() {\r\n    require(m_isFinalized, \"Method only allowed after finalization\");\r\n    _;\r\n  }\r\n\r\n  function contribute(\r\n    address contributor,\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external ownerOnly beforeFinalizationOnly returns(\r\n    uint128 depositedLessFees,\r\n    uint128 depositedFees\r\n  ) {\r\n    require(amount > 0, \"Gotta have something to contribute\");\r\n    require(\r\n      amount % FEE_DENOMINATOR == 0,\r\n      \"Amount must be divisible by fee denominator\"\r\n    );\r\n    require(\r\n      feeNumerator >= 0 && feeNumerator < FEE_DENOMINATOR,\r\n      \"Bad feeNumerator\"\r\n    );\r\n    require(\r\n      m_contributionPerContributor[contributor] == 0,\r\n      \"One has to withdraw previous contribution before making a new one\"\r\n    );\r\n\r\n    m_contributionPerContributor[contributor] = amount;\r\n    m_feeNumeratorPerContributor[contributor] = feeNumerator;\r\n    m_contributionPerFeeNumerator[feeNumerator] = safeAdd(\r\n      m_contributionPerFeeNumerator[feeNumerator],\r\n      amount\r\n    );\r\n\r\n    uint128 feeAmount = safeMulDivExact(amount, feeNumerator, FEE_DENOMINATOR);\r\n\r\n    m_totalContribution = safeAdd(m_totalContribution, amount);\r\n    m_totalFeesOffered = safeAdd(m_totalFeesOffered, feeAmount);\r\n\r\n    return (amount, feeAmount);\r\n  }\r\n\r\n  function withdrawContribution(\r\n    address contributor\r\n  ) external ownerOnly beforeFinalizationOnly returns(\r\n    uint128 withdrawnLessFees,\r\n    uint128 withdrawnFees\r\n  ) {\r\n    uint128 amount = m_contributionPerContributor[contributor];\r\n\r\n    m_contributionPerContributor[contributor] = 0;\r\n\r\n    uint128 feeNumerator = m_feeNumeratorPerContributor[contributor];\r\n    m_contributionPerFeeNumerator[feeNumerator] = safeSub(\r\n      m_contributionPerFeeNumerator[feeNumerator],\r\n      amount\r\n    );\r\n\r\n    uint128 feeAmount = safeMulDivExact(amount, feeNumerator, FEE_DENOMINATOR);\r\n\r\n    m_totalContribution = safeSub(m_totalContribution, amount);\r\n    m_totalFeesOffered = safeSub(m_totalFeesOffered, feeAmount);\r\n\r\n    return (amount, feeAmount);\r\n  }\r\n\r\n  /**\r\n   * Someone may have sent us (by mistake or maliciously) extra dispute tokens.\r\n   * This is not fatal, but we need to be aware that amountDisputed may actually\r\n   * be greater than the REP contributed and not crash.\r\n   */\r\n  function finalize(\r\n    uint128 amountDisputed\r\n  ) external ownerOnly beforeFinalizationOnly {\r\n    m_isFinalized = true;\r\n    m_fundsUsed = amountDisputed;\r\n    (m_boundaryFeeNumerator, m_fundsUsedFromBoundaryBucket) = findBoundaryBucketForAmountDisputed(\r\n      amountDisputed\r\n    );\r\n  }\r\n\r\n  function getTotalContribution() external view returns(uint256) {\r\n    return m_totalContribution;\r\n  }\r\n\r\n  function getTotalFeesOffered() external view returns(uint256) {\r\n    return m_totalFeesOffered;\r\n  }\r\n\r\n  function getProjectedFee(uint128 amountDisputed) external view returns(\r\n    uint128 feeNumerator,\r\n    uint128 fundsUsedFromBoundaryBucket\r\n  ) {\r\n    (feeNumerator, fundsUsedFromBoundaryBucket) = findBoundaryBucketForAmountDisputed(\r\n      amountDisputed\r\n    );\r\n  }\r\n\r\n  function getOwner() external view returns(address) {\r\n    return m_owner;\r\n  }\r\n\r\n  function isFinalized() external view returns(bool) {\r\n    return m_isFinalized;\r\n  }\r\n\r\n  /**\r\n   * Return value is how much REP and dispute tokens the contributor is entitled to.\r\n   *\r\n   * Does not change the state, as accounting is finalized at that moment.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateProceeds(\r\n    address contributor\r\n  ) external view afterFinalizationOnly returns(\r\n    uint128 rep,\r\n    uint128 disputeTokens\r\n  ) {\r\n    uint128 contributorFeeNumerator = m_feeNumeratorPerContributor[contributor];\r\n    uint128 originalContributionOfContributor = m_contributionPerContributor[contributor];\r\n\r\n    if (originalContributionOfContributor == 0) {\r\n      return (0, 0);\r\n    }\r\n\r\n    if (contributorFeeNumerator < m_boundaryFeeNumerator) {\r\n      // this contributor didn't make it into dispute round,\r\n      // just refund their contribution with prepaid fees\r\n      disputeTokens = 0;\r\n      rep = addFeesOnTop(\r\n        originalContributionOfContributor,\r\n        contributorFeeNumerator\r\n      );\r\n    } else if (contributorFeeNumerator > m_boundaryFeeNumerator) {\r\n      // this contributor fully got into dispute round,\r\n      // give them dispute tokens in full, and refund unused portion of fee\r\n      disputeTokens = originalContributionOfContributor;\r\n      rep = safeMulDivExact(\r\n        originalContributionOfContributor,\r\n        safeSub(contributorFeeNumerator, m_boundaryFeeNumerator),\r\n        FEE_DENOMINATOR\r\n      );\r\n    } else {\r\n      assert(contributorFeeNumerator == m_boundaryFeeNumerator);\r\n      // most complex case, contributor partially got into dispute rounds\r\n      uint128 usableFundsContributedInBucket = m_contributionPerFeeNumerator[contributorFeeNumerator];\r\n      // assertion gotta be true because contributor admittedly did some\r\n      // contribution\r\n      assert(usableFundsContributedInBucket > 0);\r\n      uint128 fundsUsedInBucket = m_fundsUsedFromBoundaryBucket;\r\n      assert(fundsUsedInBucket <= usableFundsContributedInBucket);\r\n\r\n      // award dispute tokens pro rata\r\n      disputeTokens = safeMulDiv(\r\n        originalContributionOfContributor,\r\n        fundsUsedInBucket,\r\n        usableFundsContributedInBucket\r\n      );\r\n      // refund rep for the unused portion of contribution + fees\r\n      rep = safeMulDiv(\r\n        addFeesOnTop(\r\n          originalContributionOfContributor,\r\n          contributorFeeNumerator\r\n        ),\r\n        safeSub(usableFundsContributedInBucket, fundsUsedInBucket),\r\n        usableFundsContributedInBucket\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate fee that will be split between contract admin and\r\n   * account that triggered dispute transaction.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateFees() external view afterFinalizationOnly returns(\r\n    uint128\r\n  ) {\r\n    return safeMulDiv(m_fundsUsed, m_boundaryFeeNumerator, FEE_DENOMINATOR);\r\n  }\r\n\r\n  function addFeesOnTop(\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) public pure returns(uint128) {\r\n    return safeMulDivExact(\r\n      amount,\r\n      safeAdd(FEE_DENOMINATOR, feeNumerator),\r\n      FEE_DENOMINATOR\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Finds such lowest fee bucket, that all buckets with fee higher than that\r\n   * were fully included in the dispute. From that will also follow that none\r\n   * of the funds from buckets with fee lower than that were included in the\r\n   * dispute.\r\n   *\r\n   * Also calculates how much funds from the boundary bucket were included in\r\n   * the dispute (normally current bucket participated partially).\r\n   *\r\n   * The returned index will always be a valid feeNumerator.\r\n   */\r\n  function findBoundaryBucketForAmountDisputed(\r\n    uint128 amountDisputed\r\n  ) internal view returns(\r\n    uint128 feeNumerator,\r\n    uint128 fundsUsedFromBoundaryBucket\r\n  ) {\r\n    // initialize with one-past-last bucket; loop will do at least one iteration\r\n    uint128 tentativeBoundaryBucket = FEE_DENOMINATOR;\r\n    uint128 usableFundsInCurrentBucket;\r\n    uint128 usableFundsWithCurrentBucket = 0;\r\n    uint128 usableFundsInBucketsWithHigherFee;\r\n\r\n    // length of the loop constrained by constant FEE_DENOMINATOR\r\n    assert(\r\n      tentativeBoundaryBucket > 0 && usableFundsWithCurrentBucket <= amountDisputed\r\n    );\r\n    while (tentativeBoundaryBucket > 0 && usableFundsWithCurrentBucket <= amountDisputed) {\r\n      tentativeBoundaryBucket -= 1;\r\n      usableFundsInBucketsWithHigherFee = usableFundsWithCurrentBucket;\r\n      // TODO: consider skipping executions if usableFundsInCurrentBucket = 0\r\n      // Not skipping now to make it more evident that 1000 iterations of full\r\n      // loop body (worst case) is OK gas-wise. I.e. we make sure that\r\n      // worst-case is triggered frequently enough to not become a surprise.\r\n      usableFundsInCurrentBucket = m_contributionPerFeeNumerator[tentativeBoundaryBucket];\r\n      usableFundsWithCurrentBucket = safeAdd(\r\n        usableFundsInBucketsWithHigherFee,\r\n        usableFundsInCurrentBucket\r\n      );\r\n    }\r\n\r\n    // this is needed to protect against corner cases if someone sent dispute\r\n    // tokens into this contract directly in excess from what contributors funded\r\n    uint128 cappedAmountDisputed = amountDisputed <= usableFundsWithCurrentBucket ? amountDisputed : usableFundsWithCurrentBucket;\r\n\r\n    assert(cappedAmountDisputed >= usableFundsInBucketsWithHigherFee);\r\n\r\n    feeNumerator = tentativeBoundaryBucket;\r\n    fundsUsedFromBoundaryBucket = safeSub(\r\n      cappedAmountDisputed,\r\n      usableFundsInBucketsWithHigherFee\r\n    );\r\n    assert(fundsUsedFromBoundaryBucket <= usableFundsInCurrentBucket);\r\n  }\r\n\r\n  function safeAdd(uint128 a, uint128 b) internal pure returns(uint128) {\r\n    uint128 r = a + b;\r\n    assert(r >= a);\r\n    return r;\r\n  }\r\n\r\n  function safeSub(uint128 a, uint128 b) internal pure returns(uint128) {\r\n    assert(a >= b);\r\n    return a - b;\r\n  }\r\n\r\n  function safeMulDiv(uint128 a, uint128 b, uint128 c) internal pure returns(\r\n    uint128\r\n  ) {\r\n    assert(c > 0);\r\n    uint256 wa = a;\r\n    uint256 wb = b;\r\n    uint256 wc = c;\r\n\r\n    uint256 result = wa * wb / wc;\r\n    uint128 result128 = uint128(result);\r\n\r\n    assert(result == result128);\r\n    return result128;\r\n  }\r\n\r\n  function safeMulDivExact(\r\n    uint128 a,\r\n    uint128 b,\r\n    uint128 c\r\n  ) internal pure returns(uint128) {\r\n    assert(c > 0);\r\n    uint256 wa = a;\r\n    uint256 wb = b;\r\n    uint256 wc = c;\r\n\r\n    assert((wa * wb) % wc == 0);\r\n    uint256 result = wa * wb / wc;\r\n    uint128 result128 = uint128(result);\r\n\r\n    assert(result == result128);\r\n    return result128;\r\n  }\r\n}\r\n\r\n// File: contracts/AccountingFactory.sol\r\n\r\ncontract AccountingFactory is IAccountingFactory {\r\n  event Created(address _owner, IAccounting _address);\r\n\r\n  function create(address owner) external returns(IAccounting) {\r\n    IAccounting _address = new Accounting(owner);\r\n    emit Created(owner, _address);\r\n    return _address;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"}]","ContractName":"AccountingFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7c38182f35029f78213314df7939c629dcfeba8d9760f21362e7e60378912e9f"}]}