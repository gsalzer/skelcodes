{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n *  X3ProfitInMonthV6 contract (300% per 33 day, 99% per 11 day, 9% per day, in first iteration)\r\n *  This percent will decrease every restart of system to lowest value of 0.9% per day\r\n *\r\n *  Improved, no bugs and backdoors! Your investments are safe!\r\n *\r\n *  LOW RISK! You can take your deposit back ANY TIME!\r\n *     - Send 0.00000112 ETH to contract address\r\n *\r\n *  NO DEPOSIT FEES! All the money go to contract!\r\n *\r\n *  LOW WITHDRAWAL FEES! Advertising 10% to OUR MAIN CONTRACT 0xf85D337017D9e6600a433c5036E0D18EdD0380f3\r\n *\r\n *  HAVE COMMAND PREPARATION TIME DURING IT WILL BE RETURN ONLY INVESTED AMOUNT AND NOT MORE!\r\n *  Only special command will run X3 MODE!\r\n * \r\n *  After restart system automaticaly make deposits for damage users in damaged part, \r\n *   but before it users must self make promotion deposit by any amount first.\r\n *\r\n *  INSTRUCTIONS:\r\n *\r\n *  TO INVEST: send ETH to contract address.\r\n *  TO WITHDRAW INTEREST: send 0 ETH to contract address.\r\n *  TO REINVEST AND WITHDRAW INTEREST: send ETH to contract address.\r\n *  TO GET BACK YOUR DEPOSIT: send 0.00000112 ETH to contract address.\r\n *  TO START X3 WORK, ANY USER CAN VOTE 0.00000111 ETH to contract address.\r\n *     While X3 not started investors can return only their deposits and no profit.\r\n *     Admin voice power is equal 10 simple participants.\r\n *  TO RESTART, ANY USER CAN VOTE 0.00000101 ETH to contract address.\r\n *     Admin voice power is equal 10 simple participants.\r\n *  TO VOICE FOR SEAL/UNSEAL CONTRACT, ADMIN CAN VOTE 0.00000102 ETH \r\n *     to contract address.\r\n * \r\n *  Minimal investment is more than 0.000000001 ether, else if equal or smaller \r\n *  then only withdrawn will performed\r\n *\r\n *  RECOMMENDED GAS LIMIT 350000\r\n */\r\n \r\ncontract X3ProfitInMonthV6 {\r\n\r\n\tstruct Investor {\r\n\t      // Restart iteration index\r\n\t\tint iteration;\r\n          // array containing information about beneficiaries\r\n\t\tuint deposit;\r\n\t\t  // sum locked to remove in predstart period, gived by contract for \r\n\t\t  // compensation of previous iteration restart\r\n\t\tuint lockedDeposit;\r\n           //array containing information about the time of payment\r\n\t\tuint time;\r\n          //array containing information on interest paid\r\n\t\tuint withdrawn;\r\n           //array containing information on interest paid (without tax)\r\n\t\tuint withdrawnPure;\r\n\t\t   // Vote system for start iteration\r\n\t\tbool isVoteProfit;\r\n\t\t   // Vote system for restart iteration\r\n\t\tbool isVoteRestart;\r\n           // Default at any deposit we debt to user\r\n        bool isWeHaveDebt;\r\n\t}\r\n\r\n    mapping(address => Investor) public investors;\r\n\t\r\n    //fund to transfer percent for MAIN OUR CONTRACT EasyInvestForeverProtected2\r\n    address payable public constant ADDRESS_MAIN_FUND = 0x3Bd33FF04e1F2BF01C8BF15C395D607100b7E116;\r\n    address payable public constant ADDRESS_ADMIN =     0x6249046Af9FB588bb4E70e62d9403DD69239bdF5;\r\n    //time through which you can take dividends\r\n    uint private constant TIME_QUANT = 1 days;\r\n\t\r\n    //start percent 10% per day\r\n    uint private constant PERCENT_DAY = 10;\r\n    uint private constant PERCENT_DECREASE_PER_ITERATION = 1;\r\n    uint private constant PERCENT_DECREASE_MINIMUM = 1;\r\n\r\n    //Adv tax for withdrawal 10%\r\n    uint private constant PERCENT_MAIN_FUND = 10;\r\n\r\n    //All percent should be divided by this\r\n    uint private constant PERCENT_DIVIDER = 100;\r\n\r\n    uint public countOfInvestors = 0;\r\n    uint public countOfAdvTax = 0;\r\n\tuint public countOfStartVoices = 0;\r\n\tuint public countOfReStartVoices = 0;\r\n\tint  public iterationIndex = 1;\r\n\tint  private undoDecreaseIteration = 0;\r\n\tuint public countOfReturnDebt = 0;\r\n\r\n\tuint public amountOfDebt = 0;\r\n\tuint public amountOfReturnDebt = 0;\r\n\tuint public amountOfCharity = 0;\r\n\r\n    // max contract balance in ether for overflow protection in calculations only\r\n    // 340 quintillion 282 quadrillion 366 trillion 920 billion 938 million 463 thousand 463\r\n\tuint public constant maxBalance = 340282366920938463463374607431768211456 wei; //(2^128) \r\n\tuint public constant maxDeposit = maxBalance / 1000; \r\n\t\r\n\t// X3 Mode status\r\n    bool public isProfitStarted = false; \r\n    bool public isContractSealed = false;\r\n\r\n    modifier isUserExists() {\r\n        require(investors[msg.sender].iteration == iterationIndex, \"Deposit not found\");\r\n        _;\r\n    }\r\n\r\n    modifier timePayment() {\r\n        require(isContractSealed || now >= investors[msg.sender].time + TIME_QUANT, \"Too fast payout request\");\r\n        _;\r\n    }\r\n\r\n    //return of interest on the deposit\r\n    function collectPercent() isUserExists timePayment internal {\r\n        uint payout = payoutPlanned(msg.sender);\r\n        _payout(msg.sender, payout, false);\r\n    }\r\n    function dailyPercent() public view returns(uint) {\r\n        uint percent = PERCENT_DAY;\r\n\t\tint delta = 1 + undoDecreaseIteration;\r\n\t\tif (delta > iterationIndex) delta = iterationIndex;\r\n        uint decrease = PERCENT_DECREASE_PER_ITERATION * (uint)(iterationIndex - delta);\r\n        if(decrease > percent - PERCENT_DECREASE_MINIMUM)\r\n            decrease = percent - PERCENT_DECREASE_MINIMUM;\r\n        percent -= decrease;\r\n        return percent;\r\n    }\r\n    function payoutAmount(address addr) public view returns(uint) {\r\n        uint payout = payoutPlanned(addr);\r\n        if(payout == 0) return 0;\r\n        if(payout > address(this).balance) payout = address(this).balance;\r\n        if(!isContractSealed && !isProfitStarted) \r\n        {\r\n            Investor memory inv = investors[addr];\r\n            uint activDep = inv.deposit - inv.lockedDeposit;\r\n            if(payout + inv.withdrawn > activDep / 2)\r\n            {\r\n                if(inv.withdrawn >= activDep / 2) return 0;\r\n                payout = activDep / 2 - inv.withdrawn;\r\n            }\r\n        }\r\n        return payout - payout * PERCENT_MAIN_FUND / PERCENT_DIVIDER;\r\n    }\r\n    //calculate the amount available for withdrawal on deposit\r\n    function payoutPlanned(address addr) public view returns(uint) {\r\n        Investor storage inv = investors[addr];\r\n        if(inv.iteration != iterationIndex)\r\n            return 0;\r\n        if (isContractSealed)\r\n        {\r\n            if(inv.withdrawnPure >= inv.deposit) {\r\n                uint delta = 0;\r\n                if(amountOfReturnDebt < amountOfDebt) delta = amountOfDebt - amountOfReturnDebt;\r\n                if (inv.isWeHaveDebt) {\r\n                    if(inv.deposit < delta) \r\n                        delta -= inv.deposit; \r\n                    else\r\n                        delta = 0;\r\n                }\r\n                if(delta > 0) delta = PERCENT_DIVIDER * delta / (PERCENT_DIVIDER - PERCENT_MAIN_FUND) + 1; \r\n                // Sealed contract must transfer funds despite of complete debt payed\r\n                if(address(this).balance > delta) \r\n                    return address(this).balance - delta;\r\n                return 0;\r\n            }\r\n            uint amount = inv.deposit - inv.withdrawnPure;\r\n            return PERCENT_DIVIDER * amount / (PERCENT_DIVIDER - PERCENT_MAIN_FUND) + 1;\r\n        }\r\n        uint varTime = inv.time;\r\n        uint varNow = now;\r\n        if(varTime > varNow) varTime = varNow;\r\n        uint percent = dailyPercent();\r\n        uint rate = inv.deposit * percent / PERCENT_DIVIDER;\r\n        uint fraction = 100;\r\n        uint interestRate = fraction * (varNow  - varTime) / 1 days;\r\n        uint withdrawalAmount = rate * interestRate / fraction;\r\n        if(interestRate < fraction) withdrawalAmount = 0;\r\n        return withdrawalAmount;\r\n    }\r\n    function makeDebt(address payable addr, uint amount) private\r\n    {\r\n        if (amount == 0) return;\r\n        Investor storage inv = investors[addr];\r\n        if (!inv.isWeHaveDebt)\r\n        {\r\n            inv.isWeHaveDebt = true;\r\n            countOfReturnDebt--;\r\n            amountOfReturnDebt -= inv.deposit;\r\n        }\r\n        inv.deposit += amount;\r\n        amountOfDebt += amount;\r\n    }\r\n\r\n    //make a deposit\r\n    function makeDeposit() private {\r\n        if (msg.value > 0.000000001 ether) {\r\n            Investor storage inv = investors[msg.sender];\r\n            if (inv.iteration != iterationIndex) {\r\n\t\t\t    inv.iteration = iterationIndex;\r\n                countOfInvestors ++;\r\n                if(inv.deposit > inv.withdrawnPure)\r\n\t\t\t        inv.deposit -= inv.withdrawnPure;\r\n\t\t        else\r\n\t\t            inv.deposit = 0;\r\n\t\t        if(inv.deposit + msg.value > maxDeposit) \r\n\t\t            inv.deposit = maxDeposit - msg.value;\r\n\t\t\t\tinv.withdrawn = 0;\r\n\t\t\t\tinv.withdrawnPure = 0;\r\n\t\t\t\tinv.time = now;\r\n\t\t\t\tinv.lockedDeposit = inv.deposit;\r\n\t\t\t    amountOfDebt += inv.lockedDeposit;\r\n\t\t\t\t\r\n\t\t\t\tinv.isVoteProfit = false;\r\n\t\t\t\tinv.isVoteRestart = false;\r\n                inv.isWeHaveDebt = true;\r\n            }\r\n            if (!isContractSealed && now >= inv.time + TIME_QUANT) {\r\n                collectPercent();\r\n            }\r\n            makeDebt(msg.sender, msg.value);\r\n        } else {\r\n            collectPercent();\r\n        }\r\n    }\r\n\r\n    //return of deposit balance\r\n    function returnDeposit() isUserExists private {\r\n        if(isContractSealed)return;\r\n        Investor storage inv = investors[msg.sender];\r\n        uint withdrawalAmount = 0;\r\n        uint activDep = inv.deposit - inv.lockedDeposit;\r\n        if(activDep > inv.withdrawn)\r\n            withdrawalAmount = activDep - inv.withdrawn;\r\n\r\n        if(withdrawalAmount > address(this).balance){\r\n            withdrawalAmount = address(this).balance;\r\n        }\r\n        //Pay the rest of deposit and take taxes\r\n        _payout(msg.sender, withdrawalAmount, true);\r\n\r\n        //delete user record\r\n        _delete(msg.sender);\r\n    }\r\n    function charityToContract() external payable {\r\n\t    amountOfCharity += msg.value;\r\n    }    \r\n    function() external payable {\r\n        if(msg.data.length > 0){\r\n    \t    amountOfCharity += msg.value;\r\n            return;        \r\n        }\r\n        require(msg.value <= maxDeposit, \"Deposit overflow\");\r\n        \r\n        //refund of remaining funds when transferring to a contract 0.00000112 ether\r\n        Investor storage inv = investors[msg.sender];\r\n        if (!isContractSealed &&\r\n            msg.value == 0.00000112 ether && inv.iteration == iterationIndex) {\r\n            makeDebt(msg.sender, msg.value);\r\n            returnDeposit();\r\n        } else {\r\n            //start/restart X3 Mode on 0.00000111 ether / 0.00000101 ether\r\n            if ((!isContractSealed &&\r\n                (msg.value == 0.00000111 ether || msg.value == 0.00000101 ether)) ||\r\n                (msg.value == 0.00000102 ether&&msg.sender == ADDRESS_ADMIN)) \r\n            {\r\n                if(inv.iteration != iterationIndex)\r\n                    makeDeposit();\r\n                else\r\n                    makeDebt(msg.sender, msg.value);\r\n                if(msg.value == 0.00000102 ether){\r\n                    isContractSealed = !isContractSealed;\r\n                    if (!isContractSealed)\r\n                    {\r\n                        undoDecreaseIteration++;\r\n                        restart();\r\n                    }\r\n                }\r\n                else\r\n                if(msg.value == 0.00000101 ether)\r\n                {\r\n                    if(!inv.isVoteRestart)\r\n                    {\r\n                        countOfReStartVoices++;\r\n                        inv.isVoteRestart = true;\r\n                    }\r\n                    else{\r\n                        countOfReStartVoices--;\r\n                        inv.isVoteRestart = false;\r\n                    }\r\n                    if((countOfReStartVoices > 10 &&\r\n                        countOfReStartVoices > countOfInvestors / 2) || \r\n                        msg.sender == ADDRESS_ADMIN)\r\n                    {\r\n        \t\t\t    undoDecreaseIteration++;\r\n        \t\t\t    restart();\r\n                    }\r\n                }\r\n                else\r\n                if(!isProfitStarted)\r\n                {\r\n                    if(!inv.isVoteProfit)\r\n                    {\r\n                        countOfStartVoices++;\r\n                        inv.isVoteProfit = true;\r\n                    }\r\n                    else{\r\n                        countOfStartVoices--;\r\n                        inv.isVoteProfit = false;\r\n                    }\r\n                    if((countOfStartVoices > 10 &&\r\n                        countOfStartVoices > countOfInvestors / 2) || \r\n                        msg.sender == ADDRESS_ADMIN)\r\n                        start(msg.sender);        \t\t\t    \r\n                }\r\n            } \r\n            else\r\n            {\r\n                require(        \r\n                    msg.value <= 0.000000001 ether ||\r\n                    address(this).balance <= maxBalance, \r\n                    \"Contract balance overflow\");\r\n                makeDeposit();\r\n                require(inv.deposit <= maxDeposit, \"Deposit overflow\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    function start(address payable addr) private {\r\n        if (isContractSealed) return;\r\n\t    isProfitStarted = true;\r\n        uint payout = payoutPlanned(ADDRESS_ADMIN);\r\n        _payout(ADDRESS_ADMIN, payout, false);\r\n        if(addr != ADDRESS_ADMIN){\r\n            payout = payoutPlanned(addr);\r\n            _payout(addr, payout, false);\r\n        }\r\n    }\r\n    \r\n    function restart() private {\r\n        if (isContractSealed) return;\r\n        if(dailyPercent() == PERCENT_DECREASE_MINIMUM)\r\n        {\r\n            isContractSealed = true;\r\n            return;\r\n        }\r\n\t\tcountOfInvestors = 0;\r\n\t\titerationIndex++;\r\n\t\tcountOfStartVoices = 0;\r\n\t\tcountOfReStartVoices = 0;\r\n\t\tisProfitStarted = false;\r\n\t\tamountOfDebt = 0;\r\n\t\tamountOfReturnDebt = 0;\r\n\t\tcountOfReturnDebt = 0;\r\n\t}\r\n\t\r\n    //Pays out, takes taxes according to holding time\r\n    function _payout(address payable addr, uint amount, bool retDep) private {\r\n        if(amount == 0)\r\n            return;\r\n\t\tif(amount > address(this).balance) amount = address(this).balance;\r\n\t\tif(amount == 0){\r\n\t\t\trestart();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tInvestor storage inv = investors[addr];\r\n        //Calculate pure payout that user receives\r\n        uint activDep = inv.deposit - inv.lockedDeposit;\r\n        bool isDeleteNeed = false;\r\n\t\tif(!isContractSealed && !retDep && !isProfitStarted && amount + inv.withdrawn > activDep / 2 )\r\n\t\t{\r\n\t\t\tif(inv.withdrawn < activDep / 2)\r\n    \t\t\tamount = (activDep/2) - inv.withdrawn;\r\n\t\t\telse{\r\n    \t\t\tif(inv.withdrawn >= activDep)\r\n    \t\t\t{\r\n    \t\t\t\t_delete(addr);\r\n    \t\t\t\treturn;\r\n    \t\t\t}\r\n    \t\t\tamount = activDep - inv.withdrawn;\r\n    \t\t\tisDeleteNeed = true;\r\n\t\t\t}\r\n\t\t}\r\n        uint interestPure = amount * (PERCENT_DIVIDER - PERCENT_MAIN_FUND) / PERCENT_DIVIDER;\r\n\r\n        //calculate money to charity\r\n        uint advTax = amount - interestPure;\r\n        // revert tax with payment if we payouted debt to user\r\n        if(isContractSealed && inv.deposit <= inv.withdrawnPure){\r\n            interestPure = advTax;\r\n            advTax = amount - interestPure;\r\n        }\r\n        \r\n\t\tinv.withdrawnPure += interestPure;\r\n\t\tinv.withdrawn += amount;\r\n\t\tinv.time = now;\r\n\r\n        //send money\r\n        if(advTax > 0)\r\n        {\r\n            (bool success, bytes memory data) = ADDRESS_MAIN_FUND.call.value(advTax)(\"\");\r\n            if(success) \r\n                countOfAdvTax += advTax;\r\n            else\r\n                inv.withdrawn -= advTax;\r\n        }\r\n        if(interestPure > 0) addr.transfer(interestPure);\r\n        \r\n        if(inv.isWeHaveDebt && inv.withdrawnPure >= inv.deposit)\r\n        {\r\n            amountOfReturnDebt += inv.deposit;\r\n            countOfReturnDebt++;\r\n            inv.isWeHaveDebt = false;\r\n        }\r\n        \r\n        if(isDeleteNeed)\r\n\t\t\t_delete(addr);\r\n\r\n\t\tif(address(this).balance == 0)\r\n\t\t\trestart();\r\n    }\r\n\r\n    //Clears user from registry\r\n    function _delete(address addr) private {\r\n        Investor storage inv = investors[addr];\r\n        if(inv.iteration != iterationIndex)\r\n            return;\r\n        amountOfDebt -= inv.deposit;\r\n        if(!inv.isWeHaveDebt){\r\n            countOfReturnDebt--;\r\n            amountOfReturnDebt-=inv.deposit;\r\n            inv.isWeHaveDebt = true;\r\n        }\r\n        inv.iteration = -1;\r\n        countOfInvestors--;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"countOfStartVoices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfReStartVoices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfReturnDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfCharity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractSealed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDRESS_MAIN_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"iterationIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"iteration\",\"type\":\"int256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"lockedDeposit\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"name\":\"withdrawnPure\",\"type\":\"uint256\"},{\"name\":\"isVoteProfit\",\"type\":\"bool\"},{\"name\":\"isVoteRestart\",\"type\":\"bool\"},{\"name\":\"isWeHaveDebt\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"payoutAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"charityToContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"payoutPlanned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isProfitStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfAdvTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfReturnDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDRESS_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"X3ProfitInMonthV6","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a249c39689f51440a852c39a4ea8a5aec0fa38a3e5911ea4530c9020efd1a63e"}]}