{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* REKTCOIN.CASH\r\n* GOT REKT? COME TO STEEMFEST 2018 IN KRAKOW! - GET AWAY FROM THOSE CANDLES - HAVE A DRINK AND A GOOD TIME - THEN MOON.\r\n*\r\n* ALL PROCEEDINGS GO TOWARDS FUNDING STEEMFEST - REKTCOIN.CASH LEAD SPONSOR OF STEEMFEST 2018\r\n**/\r\n\r\n// File: contracts\\configs\\RektCoinCashConfig.sol\r\n\r\n\r\n/**\r\n * @title RektCoinCashConfig\r\n *\r\n * @dev The static configuration for the RektCoin.cash.\r\n */\r\ncontract RektCoinCashConfig {\r\n    // The name of the token.\r\n    string constant NAME = \"RektCoin.Cash\";\r\n\r\n    // The symbol of the token.\r\n    string constant SYMBOL = \"RKTC\";\r\n\r\n    // The number of decimals for the token.\r\n    uint8 constant DECIMALS = 18;  // Same as ethers.\r\n\r\n    // Decimal factor for multiplication purposes.\r\n    uint constant DECIMALS_FACTOR = 10 ** uint(DECIMALS);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC20TokenInterface.sol\r\n\r\n/**\r\n * @dev The standard ERC20 Token interface.\r\n */\r\ncontract ERC20TokenInterface {\r\n    uint public totalSupply;  /* shorthand for public function and a property */\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\n/**\r\n * @dev Library that helps prevent integer overflows and underflows,\r\n * inspired by https://github.com/OpenZeppelin/zeppelin-solidity\r\n */\r\nlibrary SafeMath {\r\n    function plus(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\ERC20Token.sol\r\n\r\n/**\r\n * @title ERC20Token\r\n *\r\n * @dev Implements the operations declared in the `ERC20TokenInterface`.\r\n */\r\ncontract ERC20Token is ERC20TokenInterface {\r\n    using SafeMath for uint;\r\n\r\n    // Token account balances.\r\n    mapping (address => uint) balances;\r\n\r\n    // Delegated number of tokens to transfer.\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n\r\n\r\n    /**\r\n     * @dev Checks the balance of a certain address.\r\n     *\r\n     * @param _account The address which's balance will be checked.\r\n     *\r\n     * @return Returns the balance of the `_account` address.\r\n     */\r\n    function balanceOf(address _account) public constant returns (uint balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        if (balances[msg.sender] < _value || _value == 0) {\r\n\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] = balances[_to].plus(_value);\r\n\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        if (balances[_from] < _value || allowed[_from][msg.sender] < _value || _value == 0) {\r\n            return false;\r\n        }\r\n\r\n        balances[_to] = balances[_to].plus(_value);\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Shows the number of tokens approved by `_owner` that are allowed to be transferred by `_spender`.\r\n     *\r\n     * @param _owner The account which allowed the transfer.\r\n     * @param _spender The account which will spend the tokens.\r\n     *\r\n     * @return The number of tokens to be transferred.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\HasOwner.sol\r\n\r\n/**\r\n * @title HasOwner\r\n *\r\n * @dev Allows for exclusive access to certain functionality.\r\n */\r\ncontract HasOwner {\r\n    // Current owner.\r\n    address public owner;\r\n\r\n    // Conditionally the new owner.\r\n    address public newOwner;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _owner The address of the owner.\r\n     */\r\n    function HasOwner(address _owner) internal {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Access control modifier that allows only the current owner to call the function.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The event is fired when the current owner is changed.\r\n     *\r\n     * @param _oldOwner The address of the previous owner.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Transfering the ownership is a two-step process, as we prepare\r\n     * for the transfer by setting `newOwner` and requiring `newOwner` to accept\r\n     * the transfer. This prevents accidental lock-out if something goes wrong\r\n     * when passing the `newOwner` address.\r\n     *\r\n     * @param _newOwner The address of the proposed new owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev The `newOwner` finishes the ownership transfer process by accepting the\r\n     * ownership.\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n\r\n        OwnershipTransfer(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\Freezable.sol\r\n\r\n/**\r\n * @title Freezable\r\n * @dev This trait allows to freeze the transactions in a Token\r\n */\r\ncontract Freezable is HasOwner {\r\n  bool public frozen = false;\r\n\r\n  /**\r\n   * @dev Modifier makes methods callable only when the contract is not frozen.\r\n   */\r\n  modifier requireNotFrozen() {\r\n    require(!frozen);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to \"freeze\" the contract.\r\n   */\r\n  function freeze() onlyOwner public {\r\n    frozen = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to \"unfreeze\" the contract.\r\n   */\r\n  function unfreeze() onlyOwner public {\r\n    frozen = false;\r\n  }\r\n}\r\n\r\n// File: contracts\\traits\\FreezableERC20Token.sol\r\n\r\n/**\r\n * @title FreezableERC20Token\r\n *\r\n * @dev Extends ERC20Token and adds ability to freeze all transfers of tokens.\r\n */\r\ncontract FreezableERC20Token is ERC20Token, Freezable {\r\n    /**\r\n     * @dev Overrides the original ERC20Token implementation by adding whenNotFrozen modifier.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\RektCoinCash.sol\r\n\r\n/**\r\n * @title RektCoin.cash\r\n *\r\n * @dev A standard token implementation of the ERC20 token standard with added\r\n *      HasOwner trait and initialized using the configuration constants.\r\n */\r\ncontract RektCoinCash is RektCoinCashConfig, HasOwner, FreezableERC20Token {\r\n    // The name of the token.\r\n    string public name;\r\n\r\n    // The symbol for the token.\r\n    string public symbol;\r\n\r\n    // The decimals of the token.\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @dev The constructor. Initially sets `totalSupply` and the balance of the\r\n     *      `owner` address according to the initialization parameter.\r\n     */\r\n    function RektCoinCash(uint _totalSupply) public\r\n        HasOwner(msg.sender)\r\n    {\r\n        name = NAME;\r\n        symbol = SYMBOL;\r\n        decimals = DECIMALS;\r\n        totalSupply = _totalSupply;\r\n        balances[owner] = _totalSupply;\r\n    }\r\n}\r\n\r\n// File: contracts\\configs\\RektCoinCashSponsorfundraiserConfig.sol\r\n\r\n/**\r\n * @title RektCoinCashSponsorfundraiserConfig\r\n *\r\n * @dev The static configuration for the RektCoin.cash sponsorfundraiser.\r\n */\r\ncontract RektCoinCashSponsorfundraiserConfig is RektCoinCashConfig {\r\n    // The number of RKTC per 1 ETH.\r\n    uint constant CONVERSION_RATE = 1000000;\r\n\r\n    // The public sale hard cap of the sponsorfundraiser.\r\n    uint constant TOKENS_HARD_CAP = 294553323 * DECIMALS_FACTOR;\r\n\r\n    // The start date of the sponsorfundraiser: Sun, 09 Sep 2018 09:09:09 +0000\r\n    uint constant START_DATE = 1536484149;\r\n\r\n    // The end date of the sponsorfundraiser:  Wed, 07 Nov 2018 19:00:00 +0000 // start of SteemFest 2018 in KrakÃ³w\r\n    uint constant END_DATE =  1541617200;\r\n\r\n    // Maximum gas price limit\r\n    uint constant MAX_GAS_PRICE = 90000000000 wei; // 90 gwei/shanon\r\n\r\n    // Minimum individual contribution\r\n    uint constant MIN_CONTRIBUTION =  0.1337 ether;\r\n\r\n    // Individual limit in ether\r\n    uint constant INDIVIDUAL_ETHER_LIMIT =  1337 ether;\r\n}\r\n\r\n// File: contracts\\traits\\TokenSafe.sol\r\n\r\n/**\r\n * @title TokenSafe\r\n *\r\n * @dev A multi-bundle token safe contract that contains locked tokens released after a date for the specific bundle type.\r\n */\r\ncontract TokenSafe {\r\n    using SafeMath for uint;\r\n\r\n    struct AccountsBundle {\r\n        // The total number of tokens locked.\r\n        uint lockedTokens;\r\n        // The release date for the locked tokens\r\n        // Note: Unix timestamp fits uint32, however block.timestamp is uint\r\n        uint releaseDate;\r\n        // The balances for the RKTC locked token accounts.\r\n        mapping (address => uint) balances;\r\n    }\r\n\r\n    // The account bundles of locked tokens grouped by release date\r\n    mapping (uint8 => AccountsBundle) public bundles;\r\n\r\n    // The `ERC20TokenInterface` contract.\r\n    ERC20TokenInterface token;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _token The address of the RektCoin.cash contract.\r\n     */\r\n    function TokenSafe(address _token) public {\r\n        token = ERC20TokenInterface(_token);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\RektCoinCashSafe.sol\r\n\r\n/**\r\n * @title RektCoinCashSafe\r\n *\r\n * @dev The RektCoin.cash safe containing all details about locked tokens.\r\n */\r\ncontract RektCoinCashSafe is TokenSafe, RektCoinCashSponsorfundraiserConfig {\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _token The address of the RektCoin.cash contract.\r\n     */\r\n    function RektCoinCashSafe(address _token) public TokenSafe(_token)\r\n    {\r\n        token = ERC20TokenInterface(_token);\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts\\traits\\Whitelist.sol\r\n\r\ncontract Whitelist is HasOwner\r\n{\r\n    // Whitelist mapping\r\n    mapping(address => bool) public whitelist;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     */\r\n    function Whitelist(address _owner) public\r\n        HasOwner(_owner)\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Access control modifier that allows only whitelisted address to call the method.\r\n     */\r\n    modifier onlyWhitelisted {\r\n        require(whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that sets whitelist status in batch.\r\n     *\r\n     * @param _entries An array with the entries to be updated\r\n     * @param _status The new status to apply\r\n     */\r\n    function setWhitelistEntries(address[] _entries, bool _status) internal {\r\n        for (uint32 i = 0; i < _entries.length; ++i) {\r\n            whitelist[_entries[i]] = _status;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that allows the owner to whitelist multiple entries\r\n     *\r\n     * @param _entries An array with the entries to be whitelisted\r\n     */\r\n    function whitelistAddresses(address[] _entries) public onlyOwner {\r\n        setWhitelistEntries(_entries, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that allows the owner to blacklist multiple entries\r\n     *\r\n     * @param _entries An array with the entries to be blacklist\r\n     */\r\n    function blacklistAddresses(address[] _entries) public onlyOwner {\r\n        setWhitelistEntries(_entries, false);\r\n    }\r\n}\r\n\r\n// File: contracts\\RektCoinCashSponsorfundraiser.sol\r\n\r\n/**\r\n * @title RektCoinCashSponsorfundraiser\r\n *\r\n * @dev The RektCoin.cash sponsorfundraiser contract.\r\n */\r\ncontract RektCoinCashSponsorfundraiser is RektCoinCash, RektCoinCashSponsorfundraiserConfig, Whitelist {\r\n    // Indicates whether the sponsorfundraiser has ended or not.\r\n    bool public finalized = false;\r\n\r\n    // The address of the account which will receive the funds gathered by the sponsorfundraiser.\r\n    address public beneficiary;\r\n\r\n    // The number of RKTC participants will receive per 1 ETH.\r\n    uint public conversionRate;\r\n\r\n    // Sponsorfundraiser start date.\r\n    uint public startDate;\r\n\r\n    // Sponsorfundraiser end date.\r\n    uint public endDate;\r\n\r\n    // Sponsorfundraiser tokens hard cap.\r\n    uint public hardCap;\r\n\r\n    // The `RektCoinCashSafe` contract.\r\n    RektCoinCashSafe public rektCoinCashSafe;\r\n\r\n    // The minimum amount of ether allowed in the public sale\r\n    uint internal minimumContribution;\r\n\r\n    // The maximum amount of ether allowed per address\r\n    uint internal individualLimit;\r\n\r\n    // Number of tokens sold during the sponsorfundraiser.\r\n    uint private tokensSold;\r\n\r\n\r\n\r\n    /**\r\n     * @dev The event fires every time a new buyer enters the sponsorfundraiser.\r\n     *\r\n     * @param _address The address of the buyer.\r\n     * @param _ethers The number of ethers sent.\r\n     * @param _tokens The number of tokens received by the buyer.\r\n     * @param _newTotalSupply The updated total number of tokens currently in circulation.\r\n     * @param _conversionRate The conversion rate at which the tokens were bought.\r\n     */\r\n    event FundsReceived(address indexed _address, uint _ethers, uint _tokens, uint _newTotalSupply, uint _conversionRate);\r\n\r\n    /**\r\n     * @dev The event fires when the beneficiary of the sponsorfundraiser is changed.\r\n     *\r\n     * @param _beneficiary The address of the new beneficiary.\r\n     */\r\n    event BeneficiaryChange(address _beneficiary);\r\n\r\n    /**\r\n     * @dev The event fires when the number of RKTC per 1 ETH is changed.\r\n     *\r\n     * @param _conversionRate The new number of RKTC per 1 ETH.\r\n     */\r\n    event ConversionRateChange(uint _conversionRate);\r\n\r\n    /**\r\n     * @dev The event fires when the sponsorfundraiser is successfully finalized.\r\n     *\r\n     * @param _beneficiary The address of the beneficiary.\r\n     * @param _ethers The number of ethers transfered to the beneficiary.\r\n     * @param _totalSupply The total number of tokens in circulation.\r\n     */\r\n    event Finalized(address _beneficiary, uint _ethers, uint _totalSupply);\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _beneficiary The address which will receive the funds gathered by the sponsorfundraiser.\r\n     */\r\n    function RektCoinCashSponsorfundraiser(address _beneficiary) public\r\n        RektCoinCash(0)\r\n        Whitelist(msg.sender)\r\n    {\r\n        require(_beneficiary != 0);\r\n\r\n        beneficiary = _beneficiary;\r\n        conversionRate = CONVERSION_RATE;\r\n        startDate = START_DATE;\r\n        endDate = END_DATE;\r\n        hardCap = TOKENS_HARD_CAP;\r\n        tokensSold = 0;\r\n        minimumContribution = MIN_CONTRIBUTION;\r\n        individualLimit = INDIVIDUAL_ETHER_LIMIT * CONVERSION_RATE;\r\n\r\n        rektCoinCashSafe = new RektCoinCashSafe(this);\r\n\r\n        // Freeze the transfers for the duration of the sponsorfundraiser. Removed this, you can immediately transfer your RKTC to any ether address you like!\r\n        // freeze();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the beneficiary of the sponsorfundraiser.\r\n     *\r\n     * @param _beneficiary The address of the new beneficiary.\r\n     */\r\n    function setBeneficiary(address _beneficiary) public onlyOwner {\r\n        require(_beneficiary != 0);\r\n\r\n        beneficiary = _beneficiary;\r\n\r\n        BeneficiaryChange(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets converstion rate of 1 ETH to RKTC. Can only be changed before the sponsorfundraiser starts.\r\n     *\r\n     * @param _conversionRate The new number of RektCoin.cashs per 1 ETH.\r\n     */\r\n    function setConversionRate(uint _conversionRate) public onlyOwner {\r\n        require(now < startDate);\r\n        require(_conversionRate > 0);\r\n\r\n        conversionRate = _conversionRate;\r\n        individualLimit = INDIVIDUAL_ETHER_LIMIT * _conversionRate;\r\n\r\n        ConversionRateChange(_conversionRate);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev The default function which will fire every time someone sends ethers to this contract's address.\r\n     */\r\n    function() public payable {\r\n        buyTokens();\r\n    }\r\n\r\n    /**\r\n     * @dev Creates new tokens based on the number of ethers sent and the conversion rate.\r\n     */\r\n    //function buyTokens() public payable onlyWhitelisted {\r\n    function buyTokens() public payable {\r\n        require(!finalized);\r\n        require(now >= startDate);\r\n        require(now <= endDate);\r\n        require(tx.gasprice <= MAX_GAS_PRICE);  // gas price limit\r\n        require(msg.value >= minimumContribution);  // required minimum contribution\r\n        require(tokensSold <= hardCap);\r\n\r\n        // Calculate the number of tokens the buyer will receive.\r\n        uint tokens = msg.value.mul(conversionRate);\r\n        balances[msg.sender] = balances[msg.sender].plus(tokens);\r\n\r\n        // Ensure that the individual contribution limit has not been reached\r\n        require(balances[msg.sender] <= individualLimit);\r\n\r\n\r\n\r\n        tokensSold = tokensSold.plus(tokens);\r\n        totalSupply = totalSupply.plus(tokens);\r\n\r\n        Transfer(0x0, msg.sender, tokens);\r\n\r\n        FundsReceived(\r\n            msg.sender,\r\n            msg.value,\r\n            tokens,\r\n            totalSupply,\r\n            conversionRate\r\n        );\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Finalize the sponsorfundraiser if `endDate` has passed or if `hardCap` is reached.\r\n     */\r\n    function finalize() public onlyOwner {\r\n        require((totalSupply >= hardCap) || (now >= endDate));\r\n        require(!finalized);\r\n\r\n        address contractAddress = this;\r\n        Finalized(beneficiary, contractAddress.balance, totalSupply);\r\n\r\n        /// Send the total number of ETH gathered to the beneficiary.\r\n        beneficiary.transfer(contractAddress.balance);\r\n\r\n        /// Finalize the sponsorfundraiser. Keep in mind that this cannot be undone.\r\n        finalized = true;\r\n\r\n        // Unfreeze transfers\r\n        unfreeze();\r\n    }\r\n\r\n    /**\r\n     * @dev allow owner to collect balance of contract during donation period\r\n     */\r\n\r\n    function collect() public onlyOwner {\r\n\r\n        address contractAddress = this;\r\n        /// Send the total number of ETH gathered to the beneficiary.\r\n        beneficiary.transfer(contractAddress.balance);\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entries\",\"type\":\"address[]\"}],\"name\":\"whitelistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entries\",\"type\":\"address[]\"}],\"name\":\"blacklistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rektCoinCashSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"setConversionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newTotalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"ConversionRateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RektCoinCashSponsorfundraiser","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d6d86739e67de6e08f3d5d3f727f568db215b85c","Library":"","SwarmSource":"bzzr://53d8449f6d769550958d16ac3cf690a2d7962cc618c515cb12f2e04fab01866d"}]}