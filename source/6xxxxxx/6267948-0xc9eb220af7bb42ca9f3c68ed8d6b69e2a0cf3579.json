{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\nlibrary Datasets {\r\n    struct Player {\r\n        uint256 currentroundIn0;\r\n        uint256 currentroundIn1;\r\n        uint256 allRoundIn;\r\n        uint256 win;    // total winnings vault\r\n        uint256 lastwin;\r\n        uint256 withdrawed;\r\n    }\r\n    struct Round {\r\n        uint256 strt;   // height round started\r\n        uint256 end;    // height round ended\r\n        bool ended;\r\n        uint256 etc0;//etc for bull\r\n        uint256 etc1;//etc for bear\r\n        int win;//0 for bull,1 for bear\r\n    }\r\n    struct totalData{\r\n        uint256 bullTotalIn;\r\n        uint256 bearTotalIn;\r\n        uint256 bullTotalWin;\r\n        uint256 bearTotalWin;\r\n    }\r\n}\r\ncontract Lotteryevents {\r\n    event onBuys\r\n    (\r\n        address addr,\r\n        uint256 amount,\r\n        uint8 _team\r\n    );\r\n    event onWithdraw\r\n    (\r\n        address playerAddress,\r\n        uint256 out,\r\n        uint256 timeStamp\r\n    );\r\n    event onBuyAndDistribute\r\n    (\r\n        uint256 rid,\r\n        uint256 strt,   // height round started\r\n        uint256 end,    // height round ended\r\n        uint256 etc0,//etc for bull\r\n        uint256 etc1,//etc for bear\r\n        int win//0 for bull,1 for bear\r\n    );\r\n}\r\ncontract NXlottery is Lotteryevents{\r\n    using SafeMath for *;\r\n    uint8 constant private rndGap_ = 100;\r\n    uint8 constant private lotteryHei_ = 10;\r\n    uint8 constant private fee = 5;\r\n    uint8 constant private maxLimit=200;\r\n    uint256 constant private splitThreshold=3000000000000000000;\r\n    uint256 private feeLeft=0;\r\n    address private creator;\r\n    Datasets.Round private currRound;\r\n    Datasets.Round private lastRound;//lastRound=currRound when clearing\r\n    uint256 private rID_=1;    // round id number / total rounds that have happened\r\n    address[] private allAddress;//allAddress.push(addre)\r\n    mapping (address => Datasets.Player) private allPlayer;\r\n    Datasets.totalData private total;\r\n    constructor() public {\r\n        creator = msg.sender;\r\n        uint256 curr=block.number;\r\n        currRound.strt = curr;\r\n        currRound.end = curr+rndGap_;\r\n        currRound.ended = false;\r\n        currRound.win = 0;\r\n    }\r\n    function getFee()\r\n        isCreator()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (feeLeft);\r\n    }\r\n    function getBlock()\r\n        public\r\n    {\r\n       splitPot();//lotteryHei_\r\n    }\r\n    function withdrawFee(uint256 amount)\r\n        isCreator()\r\n        public\r\n    {\r\n        if(feeLeft>=amount)\r\n        {\r\n            feeLeft=feeLeft.sub(amount);\r\n            msg.sender.transfer(amount);\r\n        }\r\n    }\r\n    function playerWithdraw(uint256 amount)\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 left=allPlayer[_customerAddress].win.sub(allPlayer[_customerAddress].withdrawed);\r\n\r\n        if(left>=amount)\r\n        {\r\n            allPlayer[_customerAddress].withdrawed=allPlayer[_customerAddress].withdrawed.add(amount);\r\n            _customerAddress.transfer(amount);\r\n            emit Lotteryevents.onWithdraw(msg.sender, amount, now);\r\n        }\r\n    }\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        require (_addr == tx.origin);\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 amount) {\r\n        require(amount >= 10000000000000000, \"too little\");//0.01\r\n        require(amount <= 100000000000000000000, \"too much\");//100\r\n        _;\r\n    }\r\n    modifier canClearing() {\r\n        require(currRound.end-lotteryHei_<=block.number, \"cannot clearing\");\r\n        require(currRound.ended==false, \"already cleared\");\r\n        _;\r\n    }\r\n    modifier isCreator() {\r\n        require(creator == msg.sender, \"not creator\");\r\n        _;\r\n    }\r\n\r\n    function()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        allBuyAmount(msg.value,0);\r\n    }\r\n    function reinvest(uint256 amount, uint8 _team)\r\n        isHuman()\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 left=allPlayer[_customerAddress].win.sub(allPlayer[_customerAddress].withdrawed);\r\n\r\n        if(left>=amount)\r\n        {\r\n            allPlayer[_customerAddress].withdrawed=allPlayer[_customerAddress].withdrawed.add(amount);\r\n            allBuyAmount(amount,_team);\r\n        }\r\n    }\r\n    function buy(uint8 _team)\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        allBuyAmount(msg.value,_team);\r\n    }\r\n    function allBuyAmount(uint256 amount,uint8 _team)\r\n        internal\r\n    {\r\n        require((_team == 0)||(_team == 1),\"team 0 or 1\");\r\n        Core(msg.sender,amount,_team);\r\n        emit Lotteryevents.onBuys\r\n        (\r\n            msg.sender,\r\n            amount,\r\n            _team\r\n        );\r\n    }\r\n    function Core(address addr, uint256 amount, uint8 _team)\r\n        private\r\n    {\r\n        if((block.number>=currRound.end-lotteryHei_))\r\n        {\r\n            if(block.number < currRound.end){\r\n                uint256 currAllIn=currRound.etc0+currRound.etc1;\r\n                if(currAllIn<splitThreshold){\r\n                    currRound.end=block.number+rndGap_;\r\n                } else {\r\n                    allPlayer[addr].win+=amount;\r\n                    return;\r\n                }\r\n            } else {\r\n                allPlayer[addr].win+=amount;\r\n                return;\r\n            }\r\n        }\r\n        if(allAddress.length>=maxLimit)\r\n        {\r\n            allPlayer[addr].win+=amount;\r\n            return;\r\n        }\r\n        uint i=0;\r\n        for (;i < allAddress.length; i++) {\r\n            if(addr==allAddress[i])\r\n                break;\r\n        }\r\n        if(i>=allAddress.length){\r\n            allAddress.push(addr);\r\n        }\r\n        if(_team==0){\r\n            allPlayer[addr].currentroundIn0=allPlayer[addr].currentroundIn0.add(amount);\r\n            currRound.etc0=currRound.etc0.add(amount);\r\n            total.bullTotalIn=total.bullTotalIn.add(amount);\r\n        }else{\r\n            allPlayer[addr].currentroundIn1=allPlayer[addr].currentroundIn1.add(amount);\r\n            currRound.etc1=currRound.etc1.add(amount);\r\n            total.bearTotalIn=total.bearTotalIn.add(amount);\r\n        }\r\n        allPlayer[msg.sender].allRoundIn=allPlayer[msg.sender].allRoundIn.add(amount);\r\n    }\r\n    // Lottery\r\n    function splitPot()\r\n        canClearing()\r\n        private\r\n    {\r\n        uint256 currAllIn=currRound.etc0+currRound.etc1;\r\n        if(currAllIn<splitThreshold){\r\n            currRound.end=block.number+rndGap_;\r\n            return;\r\n        }\r\n        if(currRound.end > block.number){\r\n            return;\r\n        }\r\n\r\n        uint8 whichTeamWin=sha(currRound.end); //Determine the winning team\r\n        if(currRound.etc0 <= 0){\r\n        \tif(allAddress.length>=maxLimit){//Doomed to failure\r\n        \t\twhichTeamWin = 1;\r\n        \t}else{\r\n        \t\tcurrRound.end=block.number+rndGap_;\r\n        \t\treturn;\r\n        \t}\r\n        }\r\n        if(currRound.etc1 <= 0){\r\n        \tif(allAddress.length>=maxLimit){//Doomed to failure\r\n        \t\twhichTeamWin = 0;\r\n        \t}else{\r\n        \t\tcurrRound.end=block.number+rndGap_;\r\n        \t\treturn;\r\n        \t}\r\n        }\r\n\r\n        currRound.win=whichTeamWin;\r\n        uint256 fees=currAllIn.mul(fee).div(100);\r\n        uint256 pot=currAllIn.sub(fees);\r\n        feeLeft=feeLeft.add(fees);\r\n\r\n        uint256 currentIn;\r\n        if(whichTeamWin==0){\r\n            currentIn=currRound.etc0;\r\n        }else{\r\n            currentIn=currRound.etc1;\r\n        }\r\n        //Distribution prize pool\r\n        for (uint i=0;i < allAddress.length; i++) {\r\n            address curr=allAddress[i];\r\n\r\n            uint256 temp;\r\n            if(whichTeamWin==0){\r\n                temp=allPlayer[curr].currentroundIn0;\r\n            }else{\r\n                temp=allPlayer[curr].currentroundIn1;\r\n            }\r\n            uint256 amount=0;\r\n            if(temp > 0)\r\n            {\r\n                 amount=pot.mul(temp).div(currentIn);\r\n                 allPlayer[curr].win=allPlayer[curr].win.add(amount);\r\n            }\r\n            allPlayer[curr].lastwin=amount;\r\n            allPlayer[curr].currentroundIn0=0;\r\n            allPlayer[curr].currentroundIn1=0;\r\n        }\r\n        currRound.ended=true;\r\n        lastRound=currRound;\r\n        emit Lotteryevents.onBuyAndDistribute\r\n        (\r\n            rID_,\r\n            lastRound.strt,\r\n            lastRound.end,\r\n            lastRound.etc0,\r\n            lastRound.etc1,\r\n            lastRound.win\r\n        );\r\n\r\n        uint256 currBlock=block.number+1;\r\n        rID_++;\r\n        currRound.strt = currBlock;\r\n        currRound.end = currBlock+rndGap_;\r\n        currRound.ended = false;\r\n        currRound.win = 0;\r\n        currRound.etc0=0;\r\n        currRound.etc1=0;\r\n\r\n        if(whichTeamWin==0){\r\n            total.bullTotalWin=total.bullTotalWin.add(pot);\r\n        }else{\r\n            total.bearTotalWin=total.bearTotalWin.add(pot);\r\n        }\r\n\r\n        delete allAddress;\r\n        allAddress.length=0;\r\n    }\r\n    function getAddressLength()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (allAddress.length);\r\n    }\r\n    function getAddressArray()constant public returns(address,address)\r\n    {\r\n        return (allAddress[0],allAddress[1]);\r\n    }\r\n\r\n    function getCurrentRoundLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _now = block.number;\r\n\r\n        if (_now < currRound.end)\r\n            return( (currRound.end).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n    function getEndowmentBalance() constant public returns (uint)\r\n    {\r\n    \treturn address(this).balance;\r\n    }\r\n    function getCreator() constant public returns (address)\r\n    {\r\n    \treturn creator;\r\n    }\r\n    function sha(uint256 end) constant private returns(uint8)\r\n    {\r\n        bytes32 h=blockhash(end-lotteryHei_);\r\n        if(h[31]&(0x0f)>8)\r\n        return 1;\r\n        return 0;  //0 for bull,1 for bear;\r\n    }\r\n\r\n    function getLastRoundInfo()\r\n      public\r\n      view\r\n      returns (uint256,uint256,uint256,uint256,bool,int)\r\n    {\r\n        return\r\n        (\r\n            lastRound.strt,\r\n            lastRound.end,\r\n            lastRound.etc0,\r\n            lastRound.etc1,\r\n            lastRound.ended,\r\n            lastRound.win\r\n        );\r\n    }\r\n  \tfunction getCurrentInfo()\r\n      public\r\n      view\r\n      returns (uint256,uint256,uint256,uint256,uint256,bool,int)\r\n    {\r\n        return\r\n        (\r\n            rID_,\r\n            currRound.strt,\r\n            currRound.end,\r\n            currRound.etc0,\r\n            currRound.etc1,\r\n            currRound.ended,\r\n            currRound.win\r\n        );\r\n    }\r\n    function getTotalInfo()\r\n      public\r\n      view\r\n      returns (uint256,uint256,uint256,uint256)\r\n    {\r\n        return\r\n        (\r\n            total.bullTotalIn,\r\n            total.bearTotalIn,\r\n            total.bullTotalWin,\r\n            total.bearTotalWin\r\n        );\r\n    }\r\n    function getPlayerInfoByAddress(address addr)\r\n        public\r\n        view\r\n        returns (uint256, uint256,uint256, uint256, uint256, uint256)\r\n    {\r\n        address _addr=addr;\r\n        if (_addr == address(0))\r\n        {\r\n            _addr = msg.sender;\r\n        }\r\n\r\n        return\r\n        (\r\n            allPlayer[_addr].currentroundIn0,\r\n            allPlayer[_addr].currentroundIn1,\r\n            allPlayer[_addr].allRoundIn,\r\n            allPlayer[_addr].win,\r\n            allPlayer[_addr].lastwin,\r\n            allPlayer[_addr].withdrawed\r\n        );\r\n    }\r\n\r\n    function kill()public\r\n    {\r\n        if (msg.sender == creator)\r\n            selfdestruct(creator);  // kills this contract and sends remaining funds back to creator\r\n    }\r\n}\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"uint8\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"playerWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEndowmentBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint8\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_team\",\"type\":\"uint8\"}],\"name\":\"onBuys\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"out\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etc0\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etc1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"win\",\"type\":\"int256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"}]","ContractName":"NXlottery","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://32c5d984aa002875e070a58446f7561fab77f5be1142d33ad055718115b4ee44"}]}