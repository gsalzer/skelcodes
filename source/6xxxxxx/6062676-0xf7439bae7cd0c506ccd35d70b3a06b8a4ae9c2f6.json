{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Ownable {\r\n    address public owner=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor()public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\ncontract PricingStrategy {\r\n\r\n  /** Interface declaration. */\r\n  function isPricingStrategy() public pure  returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /** Self check if all references are correctly set.\r\n   *\r\n   * Checks that pricing strategy matches crowdsale parameters.\r\n   */\r\n  function isSane() public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Pricing tells if this is a presale purchase or not.\r\n     @param purchaser Address of the purchaser\r\n     @return False by default, true if a presale purchaser\r\n   */\r\n  function isPresalePurchase(address purchaser) public pure returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\n   *\r\n   *\r\n   * @param value - What is the value of the transaction send in as wei\r\n   * @param tokensSold - how much tokens have been sold this far\r\n   * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale\r\n   * @param msgSender - who is the investor of this transaction\r\n   * @param decimals - how many decimal units the token has\r\n   * @return Amount of tokens the investor receives\r\n   */\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public pure returns (uint tokenAmount){\r\n      \r\n  }\r\n  \r\n}\r\ncontract FinalizeAgent {\r\n\r\n  function isFinalizeAgent() public pure returns(bool) {\r\n    return true;\r\n  }\r\n\r\n  /** Return true if we can run finalizeCrowdsale() properly.\r\n   *\r\n   * This is a safety check function that doesn't allow crowdsale to begin\r\n   * unless the finalizer has been set up properly.\r\n   */\r\n  function isSane() public pure returns (bool){\r\n      return true;\r\n}\r\n  /** Called once by crowdsale finalize() if the sale was success. */\r\n  function finalizeCrowdsale() pure public{\r\n     \r\n  }\r\n  \r\n\r\n}\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract UbricoinPresale {\r\n\r\n    /*/\r\n     *  Token state\r\n    /*/\r\n\r\n    enum Phase {\r\n        Created,\r\n        Running,\r\n        Paused,\r\n        Migrating,\r\n        Migrated\r\n    }\r\n\r\n    Phase public currentPhase = Phase.Created;\r\n    uint public totalSupply = 0; // amount of tokens already sold\r\n    \r\n\r\n    // Token manager has exclusive priveleges to call administrative\r\n    // functions on this contract.\r\n    address public tokenManager;\r\n\r\n    // Gathered funds can be withdrawn only to escrow's address.\r\n    address public escrow;\r\n\r\n    // Crowdsale manager has exclusive priveleges to burn presale tokens.\r\n    address public crowdsaleManager;\r\n\r\n    mapping (address => uint256) private balance;\r\n\r\n\r\n    modifier onlyTokenManager()     { if(msg.sender != tokenManager) revert(); _; }\r\n    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) revert(); _; }\r\n\r\n\r\n    /*/\r\n     *  Events\r\n    /*/\r\n\r\n    event LogBuy(address indexed owner, uint256 value);\r\n    event LogBurn(address indexed owner, uint256 value);\r\n    event LogPhaseSwitch(Phase newPhase);\r\n\r\n\r\n    /*/\r\n     *  Public functions\r\n    /*/\r\n\r\n \r\n    /// @dev Returns number of tokens owned by given address.\r\n    /// @param _owner Address of token owner.\r\n    function burnTokens(address _owner) public\r\n        onlyCrowdsaleManager\r\n    {\r\n        // Available only during migration phase\r\n        if(currentPhase != Phase.Migrating) revert();\r\n\r\n        uint256 tokens = balance[_owner];\r\n        if(tokens == 0) revert();\r\n        balance[_owner] = 0;\r\n        \r\n        emit LogBurn(_owner, tokens);\r\n\r\n        // Automatically switch phase when migration is done.\r\n       \r\n    }\r\n\r\n    /*/\r\n     *  Administrative functions\r\n    /*/\r\n\r\n    function setPresalePhase(Phase _nextPhase) public\r\n        onlyTokenManager\r\n    {\r\n        bool canSwitchPhase\r\n            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\r\n            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\r\n                // switch to migration phase only if crowdsale manager is set\r\n            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\r\n                && _nextPhase == Phase.Migrating\r\n                && crowdsaleManager != 0x0)\r\n            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\r\n                // switch to migrated only if everyting is migrated\r\n            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\r\n                && totalSupply == 0);\r\n\r\n        if(!canSwitchPhase) revert();\r\n        currentPhase = _nextPhase;\r\n        emit LogPhaseSwitch(_nextPhase); \r\n           \r\n    }\r\n\r\n\r\n    function withdrawEther() public\r\n        onlyTokenManager\r\n    {\r\n        // Available at any phase.\r\n        if(address(this).balance > 0) {\r\n            if(!escrow.send(address(this).balance)) revert();\r\n        }\r\n    }\r\n\r\n\r\n    function setCrowdsaleManager(address _mgr) public\r\n        onlyTokenManager\r\n    {\r\n        // You can't change crowdsale contract when migration is in progress.\r\n        if(currentPhase == Phase.Migrating) revert();\r\n        crowdsaleManager = _mgr;\r\n    }\r\n}\r\ncontract Haltable is Ownable  {\r\n    \r\n  bool public halted;\r\n  \r\n   modifier stopInEmergency {\r\n    if (halted) revert();\r\n    _;\r\n  }\r\n\r\n  modifier stopNonOwnersInEmergency {\r\n    if (halted && msg.sender != owner) revert();\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) revert();\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\ncontract WhitelistedCrowdsale is Ownable {\r\n\r\n  mapping(address => bool) public whitelist;\r\n\r\n  /**\r\n   * @dev Reverts if beneficiary is not whitelisted. Can be used when extending this contract.\r\n   */\r\n  modifier isWhitelisted(address _beneficiary) {\r\n    require(whitelist[_beneficiary]);\r\n    _;\r\n  }\r\n  \r\n  /**\r\n   * @dev Adds single address to whitelist.\r\n   * @param _beneficiary Address to be added to the whitelist\r\n   */\r\n  function addToWhitelist(address _beneficiary) onlyOwner public  {\r\n    whitelist[_beneficiary] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds list of addresses to whitelist. \r\n   * @param _beneficiaries Addresses to be added to the whitelist\r\n   */\r\n  function addManyToWhitelist(address[] _beneficiaries) onlyOwner public {\r\n    for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n      whitelist[_beneficiaries[i]] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes single address from whitelist.\r\n   * @param _beneficiary Address to be removed to the whitelist\r\n   */\r\n  function removeFromWhitelist(address _beneficiary)onlyOwner public {\r\n    whitelist[_beneficiary] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring beneficiary to be in whitelist.\r\n   * @param _beneficiary Token beneficiary\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  \r\n}\r\n\r\n   contract UbricoinCrowdsale is FinalizeAgent,WhitelistedCrowdsale {\r\n    using SafeMath for uint256;\r\n    address public beneficiary;\r\n    uint256 public fundingGoal;\r\n    uint256 public amountRaised;\r\n    uint256 public deadline;\r\n       \r\n    mapping(address => uint256) public balanceOf;\r\n    bool fundingGoalReached = false;\r\n    bool crowdsaleClosed = false;\r\n    uint256 public investorCount = 0;\r\n    \r\n    bool public requiredSignedAddress;\r\n    bool public requireCustomerId;\r\n    \r\n\r\n    bool public paused = false;\r\n\r\n    \r\n    event GoalReached(address recipient, uint256 totalAmountRaised);\r\n    event FundTransfer(address backer, uint256 amount, bool isContribution);\r\n    \r\n    // A new investment was made\r\n    event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint256 customerId);\r\n\r\n  // The rules were changed what kind of investments we accept\r\n    event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\n    event Pause();\r\n    event Unpause();\r\n \r\n     \r\n \r\n    modifier afterDeadline() { if (now >= deadline) _; }\r\n    \r\n\r\n    /**\r\n     * Check if goal was reached\r\n     *\r\n     * Checks if the goal or time limit has been reached and ends the campaign\r\n     */\r\n     \r\n    function invest(address ) public payable {\r\n    if(requireCustomerId) revert(); // Crowdsale needs to track partipants for thank you email\r\n    if(requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants\r\n   \r\n  }\r\n     \r\n    function investWithCustomerId(address , uint256 customerId) public payable {\r\n    if(requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants\r\n    if(customerId == 0)revert();  // UUIDv4 sanity check\r\n\r\n  }\r\n  \r\n    function buyWithCustomerId(uint256 customerId) public payable {\r\n    investWithCustomerId(msg.sender, customerId);\r\n  }\r\n     \r\n     \r\n    function checkGoalReached() afterDeadline public {\r\n        if (amountRaised >= fundingGoal){\r\n            fundingGoalReached = true;\r\n            emit GoalReached(beneficiary, amountRaised);\r\n        }\r\n        crowdsaleClosed = true;\r\n    }\r\n\r\n   \r\n\r\n    /**\r\n     * Withdraw the funds\r\n     *\r\n     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\r\n     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw\r\n     * the amount they contributed.\r\n     */\r\n    function safeWithdrawal() afterDeadline public {\r\n        if (!fundingGoalReached) {\r\n            uint256 amount = balanceOf[msg.sender];\r\n            balanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (msg.sender.send(amount)) {\r\n                emit FundTransfer(beneficiary,amountRaised,false);\r\n                } else {\r\n                    balanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        if  (fundingGoalReached && beneficiary == msg.sender) {\r\n            if (beneficiary.send(amountRaised)) {\r\n               emit FundTransfer(beneficiary,amountRaised,false);\r\n            } else {\r\n                //If we fail to send the funds to beneficiary, unlock funders balance\r\n                fundingGoalReached = false;\r\n            }\r\n        }\r\n    }\r\n    \r\n     /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public returns (bool) {\r\n    paused = true;\r\n    emit Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public returns (bool) {\r\n    paused = false;\r\n    emit Unpause();\r\n    return true;\r\n  }\r\n\r\n}\r\ncontract Upgradeable {\r\n    mapping(bytes4=>uint32) _sizes;\r\n    address _dest;\r\n\r\n    /**\r\n     * This function is called using delegatecall from the dispatcher when the\r\n     * target contract is first initialized. It should use this opportunity to\r\n     * insert any return data sizes in _sizes, and perform any other upgrades\r\n     * necessary to change over from the old contract implementation (if any).\r\n     * \r\n     * Implementers of this function should either perform strictly harmless,\r\n     * idempotent operations like setting return sizes, or use some form of\r\n     * access control, to prevent outside callers.\r\n     */\r\n    function initialize() public{\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Performs a handover to a new implementing contract.\r\n     */\r\n    function replace(address target) internal {\r\n        _dest = target;\r\n        require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\r\n    }\r\n}\r\n/**\r\n * The dispatcher is a minimal 'shim' that dispatches calls to a targeted\r\n * contract. Calls are made using 'delegatecall', meaning all storage and value\r\n * is kept on the dispatcher. As a result, when the target is updated, the new\r\n * contract inherits all the stored data and value from the old contract.\r\n */\r\ncontract Dispatcher is Upgradeable {\r\n    \r\n    constructor (address target) public {\r\n        replace(target);\r\n    }\r\n    \r\n    function initialize() public {\r\n        // Should only be called by on target contracts, not on the dispatcher\r\n        revert();\r\n    }\r\n\r\n    function() public {\r\n        uint len;\r\n        address target;\r\n        bytes4 sig;\r\n        assembly { sig := calldataload(0) }\r\n        len = _sizes[sig];\r\n        target = _dest;\r\n        \r\n        bool ret;\r\n        assembly {\r\n            // return _dest.delegatecall(msg.data)\r\n            calldatacopy(0x0, 0x0, calldatasize)\r\n            ret:=delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)\r\n            return(0, len)\r\n        }\r\n        if (!ret) revert();\r\n    }\r\n}\r\ncontract Example is Upgradeable {\r\n    uint _value;\r\n    \r\n    function initialize() public {\r\n        _sizes[bytes4(keccak256(\"getUint()\"))] = 32;\r\n    }\r\n    \r\n    function getUint() public view returns (uint) {\r\n        return _value;\r\n    }\r\n    \r\n    function setUint(uint value) public {\r\n        _value = value;\r\n    }\r\n}\r\ninterface tokenRecipient { \r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)external;\r\n    \r\n}\r\n\r\n /**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\n\r\ncontract Ubricoin is UbricoinPresale,Ownable,Haltable, UbricoinCrowdsale,Upgradeable {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    // Public variables of the token\r\n    string public name ='Ubricoin';\r\n    string public symbol ='UBN';\r\n    string public version= \"1.0\";\r\n    uint public decimals=18;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint public totalSupply = 10000000000;\r\n    uint256 public constant RATE = 1000;\r\n    uint256 initialSupply;\r\n\r\n    \r\n    \r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    \r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n    \r\n    uint256 public AVAILABLE_AIRDROP_SUPPLY = 100000000* decimals; // 100% Released at Token distribution\r\n    uint256 public grandTotalClaimed = 1;\r\n    uint256 public startTime;\r\n    \r\n    struct Allocation {\r\n    uint8 AllocationSupply; // Type of allocation\r\n    uint256 totalAllocated; // Total tokens allocated\r\n    uint256 amountClaimed;  // Total tokens claimed\r\n}\r\n    \r\n    \r\n    mapping (address => Allocation) public allocations;\r\n\r\n    // List of admins\r\n    mapping (address => bool) public airdropAdmins;\r\n\r\n    // Keeps track of whether or not an Ubricoin airdrop has been made to a particular address\r\n    mapping (address => bool) public airdrops;\r\n\r\n  modifier onlyOwnerOrAdmin() {\r\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\r\n    _;\r\n}\r\n    \r\n    \r\n    \r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n        bytes32 public currentChallenge;                         // The coin starts with a challenge\r\n        uint256 public timeOfLastProof;                             // Variable to keep track of when rewards were given\r\n        uint256 public difficulty = 10**32;                         // Difficulty starts reasonably low\r\n\r\n     \r\n    function proofOfWork(uint256 nonce) public{\r\n        bytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));    // Generate a random hash based on input\r\n        require(n >= bytes8(difficulty));                   // Check if it's under the difficulty\r\n\r\n        uint256 timeSinceLastProof = (now - timeOfLastProof);  // Calculate time since last reward was given\r\n        require(timeSinceLastProof >=  5 seconds);         // Rewards cannot be given too quickly\r\n        balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;  // The reward to the winner grows by the minute\r\n\r\n        difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;  // Adjusts the difficulty\r\n\r\n        timeOfLastProof = now;                              // Reset the counter\r\n        currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));  // Save a hash that will be used as the next proof\r\n    }\r\n\r\n\r\n   function () payable public whenNotPaused {\r\n        require(msg.value > 0);\r\n        uint256 tokens = msg.value.mul(RATE);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\r\n        totalSupply = totalSupply.add(tokens);\r\n        owner.transfer(msg.value);\r\n}\r\n    \r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n     function transfer(address _to, uint256 _value) public {\r\n\t\tbalanceOf[msg.sender] -= _value;\r\n\t\tbalanceOf[_to] += _value;\r\n\t}\r\n     \r\n   function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\r\n        return balanceOf[tokenOwner];\r\n        \r\n}\r\n\r\n   function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\r\n        return allowance[tokenOwner][spender];\r\n}\r\n   \r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n  \r\n    function mintToken(address target, uint256 mintedAmount)private onlyOwner {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        emit Transfer(0, owner, mintedAmount);\r\n        emit Transfer(owner, target, mintedAmount);\r\n    }\r\n\r\n    function validPurchase() internal returns (bool) {\r\n    bool lessThanMaxInvestment = msg.value <= 1000 ether; // change the value to whatever you need\r\n    return validPurchase() && lessThanMaxInvestment;\r\n}\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n    \r\n   /**\r\n    * @dev Add an airdrop admin\r\n    */\r\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\r\n    airdropAdmins[_admin] = _isAdmin;\r\n  }\r\n\r\n  /**\r\n    * @dev perform a transfer of allocations\r\n    * @param _recipient is a list of recipients\r\n    */\r\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\r\n    \r\n    uint airdropped;\r\n    for(uint256 i = 0; i< _recipient.length; i++)\r\n    {\r\n        if (!airdrops[_recipient[i]]) {\r\n          airdrops[_recipient[i]] = true;\r\n          Ubricoin.transfer(_recipient[i], 1 * decimals);\r\n          airdropped = airdropped.add(1 * decimals);\r\n        }\r\n    }\r\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\r\n    totalSupply = totalSupply.sub(airdropped);\r\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\r\n}\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"checkGoalReached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireCustomerId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"customerId\",\"type\":\"uint256\"}],\"name\":\"buyWithCustomerId\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"customerId\",\"type\":\"uint256\"}],\"name\":\"investWithCustomerId\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"airdropAdmins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AVAILABLE_AIRDROP_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextPhase\",\"type\":\"uint8\"}],\"name\":\"setPresalePhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mgr\",\"type\":\"address\"}],\"name\":\"setCrowdsaleManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address[]\"}],\"name\":\"airdropTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentChallenge\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocations\",\"outputs\":[{\"name\":\"AllocationSupply\",\"type\":\"uint8\"},{\"name\":\"totalAllocated\",\"type\":\"uint256\"},{\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"proofOfWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalizeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_isAdmin\",\"type\":\"bool\"}],\"name\":\"setAirdropAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeOfLastProof\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSane\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"addManyToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"airdrops\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grandTotalClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalAmountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerId\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requireCustomerId\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"requiredSignedAddress\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"InvestmentPolicyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPhase\",\"type\":\"uint8\"}],\"name\":\"LogPhaseSwitch\",\"type\":\"event\"}]","ContractName":"Ubricoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ba9ae6426e869a5578138f4fea124d065969019860502b1f8234689382c5e928"}]}