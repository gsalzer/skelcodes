{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity  0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint);\r\n\r\n    function allowance(address owner, address spender) public view returns(uint);\r\n\r\n    function transfer(address to, uint value) public returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns(bool ok);\r\n\r\n    function approve(address spender, uint value) public returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\ncontract Bounties is Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public totalTokensToClaim;\r\n    uint public totalBountyUsers;\r\n    uint public claimCount;\r\n    uint public totalClaimed;\r\n\r\n\r\n    mapping(address => bool) public claimed; // Tokens claimed by bounty members\r\n    Token public token;\r\n\r\n    mapping(address => bool) public bountyUsers;\r\n    mapping(address => uint) public bountyUsersAmounts;\r\n\r\n    constructor(Token _token) public {\r\n        require(_token != address(0));\r\n        token = Token(_token);\r\n    }\r\n\r\n    event TokensClaimed(address backer, uint count);\r\n    event LogBountyUser(address user, uint num);\r\n    event LogBountyUserMultiple(uint num);\r\n\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of the token contract\r\n    // @return res {bool}\r\n    function updateTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\r\n        token = _tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    // @notice contract owner can add one user at a time to claim bounties\r\n    function addBountyUser(address _user, uint _amount) public onlyOwner() returns (bool) {\r\n\r\n        require(_amount > 0);\r\n\r\n        if (bountyUsers[_user] != true) {\r\n            bountyUsers[_user] = true;\r\n            bountyUsersAmounts[_user] = _amount;\r\n            totalBountyUsers++;\r\n            totalTokensToClaim += _amount;\r\n            emit LogBountyUser(_user, totalBountyUsers);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // @notice contract owner can add multipl bounty users\r\n    function addBountyUserMultiple(address[] _users, uint[] _amount) external onlyOwner()  returns (bool) {\r\n\r\n        for (uint i = 0; i < _users.length; ++i) {\r\n\r\n            addBountyUser(_users[i], _amount[i]);\r\n        }\r\n        emit LogBountyUserMultiple(totalBountyUsers);\r\n        return true;\r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handels allocation of tokens to bounty users.\r\n    // bounty members can send 0 ether transaction to this contract to claim their tokens.\r\n    function () external payable {\r\n        claimTokens();\r\n    }\r\n\r\n    // @notice\r\n    // This function will allow to transfer unclaimed tokens to another address.\r\n    function transferRemainingTokens(address _newAddress) external onlyOwner() returns (bool) {\r\n        require(_newAddress != address(0));\r\n        if (!token.transfer(_newAddress, token.balanceOf(this)))\r\n            revert(); // transfer tokens to admin account or multisig wallet\r\n        return true;\r\n    }\r\n\r\n\r\n    // @notice called to send tokens to bounty members by contract owner\r\n    // @param _backer {address} address of beneficiary\r\n    function claimTokensForUser(address _backer) external onlyOwner()  returns(bool) {\r\n        require(token != address(0));\r\n        require(bountyUsers[_backer]);\r\n        require(!claimed[_backer]);\r\n        claimCount++;\r\n        claimed[_backer] = true;\r\n        totalClaimed = totalClaimed.add(bountyUsersAmounts[_backer]);\r\n\r\n        if (!token.transfer(_backer, bountyUsersAmounts[_backer]))\r\n            revert(); // send claimed tokens to contributor account\r\n\r\n        emit TokensClaimed(_backer, bountyUsersAmounts[_backer]);\r\n        return true;\r\n    }\r\n\r\n    // @notice bounty users can claim tokens\r\n    // Tokens also can be claimed by sending 0 eth transaction to this contract.\r\n    function claimTokens() public {\r\n\r\n        require(token != address(0));\r\n        require(bountyUsers[msg.sender]);\r\n        require(!claimed[msg.sender]);\r\n        claimCount++;\r\n        claimed[msg.sender] = true;\r\n        totalClaimed = totalClaimed.add(bountyUsersAmounts[msg.sender]);\r\n\r\n        if (!token.transfer(msg.sender, bountyUsersAmounts[msg.sender]))\r\n            revert(); // send claimed tokens to contributor account\r\n\r\n        emit TokensClaimed(msg.sender, bountyUsersAmounts[msg.sender]);\r\n    }\r\n\r\n}\r\n\r\n// The token\r\ncontract Token is ERC20, Ownable {\r\n        function transfer(address _to, uint _value) public  returns(bool);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"transferRemainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"}],\"name\":\"claimTokensForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bountyUsersAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addBountyUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bountyUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"updateTokenAddress\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"addBountyUserMultiple\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensToClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBountyUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"LogBountyUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"LogBountyUserMultiple\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Bounties","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f444cd92e09cc8b2a23cd2eecb3c1e4cc8da6958","Library":"","SwarmSource":"bzzr://dbfb0b8bf5a35a49c74a2e12652289b5dbaea9feaa09499602cd7a22db05333c"}]}