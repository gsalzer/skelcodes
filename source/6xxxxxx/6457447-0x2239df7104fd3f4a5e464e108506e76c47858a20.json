{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity^0.4.24;\r\n\r\n/**\r\n*\r\n*\r\n* Contacts: support (at) bankofeth.app\r\n*           https://twitter.com/bankofeth\r\n*           https://discord.gg/d5c7pfn\r\n*           https://t.me/bankofeth\r\n*           https://reddit.com/r/bankofeth\r\n*\r\n* PLAY NOW: https://heist.bankofeth.app/heist.htm\r\n*  \r\n* --- BANK OF ETH - BANK HEIST! ------------------------------------------------\r\n*\r\n* Hold the final key to complete the bank heist and win the entire vault funds!\r\n* \r\n* = Passive income while the vault time lock runs down - as others buy into the \r\n* game you earn $ETH! \r\n* \r\n* = Buy enough keys for a chance to open the safety bank deposit boxes for a \r\n* instant win! \r\n* \r\n* = Game designed with 4 dimensions of income for you, the players!\r\n*   (See https://heist.bankofeth.app/heist.htm for details)\r\n* \r\n* = Can you hold the last key to win the game!\r\n* = Can you win the safety deposit box!\r\n*\r\n* = Play NOW: https://heist.bankofeth.app/heist.htm\r\n*\r\n* Keys priced as low as 0.001 $ETH!\r\n*\r\n* Also - invest min 0.1 ETH for a chance to open a safety deposit box and \r\n* instantly win a bonus prize!\r\n* \r\n* The more keys you own in each round, the more distributed ETH you'll earn!\r\n* \r\n* All profits from thi game feed back into the main BankOfEth contract where \r\n* you can also be an investor in and earn a return on!\r\n*\r\n*\r\n* --- COPYRIGHT ----------------------------------------------------------------\r\n* \r\n*   This source code is provided for verification and audit purposes only and \r\n*   no license of re-use is granted.\r\n*   \r\n*   (C) Copyright 2018 BankOfEth.app\r\n*   \r\n*   \r\n*   Sub-license, white-label, solidity or Ethereum development enquiries please \r\n*   contact support (at) bankofeth.app\r\n*   \r\n*   \r\n* PLAY NOW: https://heist.bankofeth.app/heist.htm\r\n* \r\n*/\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Zero {\r\n  function requireNotZero(uint a) internal pure {\r\n    require(a != 0, \"require not zero\");\r\n  }\r\n\r\n  function requireNotZero(address addr) internal pure {\r\n    require(addr != address(0), \"require not zero address\");\r\n  }\r\n\r\n  function notZero(address addr) internal pure returns(bool) {\r\n    return !(addr == address(0));\r\n  }\r\n\r\n  function isZero(address addr) internal pure returns(bool) {\r\n    return addr == address(0);\r\n  }\r\n}\r\n\r\nlibrary Percent {\r\n\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) return 0;\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n}\r\n\r\nlibrary ToAddress {\r\n  function toAddr(uint source) internal pure returns(address) {\r\n    return address(source);\r\n  }\r\n\r\n  function toAddr(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n}\r\n\r\ninterface BankOfEth {\r\n    function receiveExternalProfits() external payable;\r\n}\r\n\r\ncontract BankOfEthVaultBreaker {\r\n    \r\n    using SafeMath for uint256;\r\n    using Percent for Percent.percent;\r\n    using Zero for *;\r\n    using ToAddress for *;\r\n\r\n    // Events    \r\n    event KeysIssued(address indexed to, uint keys, uint timestamp);\r\n    event EthDistributed(uint amount, uint timestamp);\r\n    event ReturnsWithdrawn(address indexed by, uint amount, uint timestamp);\r\n    event JackpotWon(address by, uint amount, uint timestamp);\r\n    event AirdropWon(address by, uint amount, uint timestamp);\r\n    event RoundStarted(uint indexed ID, uint hardDeadline, uint timestamp);\r\n    \r\n    address owner;\r\n    address devAddress;\r\n    address bankOfEthAddress = 0xd70c3f752Feb69Ecf8Eb31E48B20A97D979e8e5e;\r\n\r\n    BankOfEth localBankOfEth;\r\n    \r\n\r\n    // settings\r\n    uint public constant STARTING_KEY_PRICE = 1 finney; // 0.01 eth\r\n    uint public constant HARD_DEADLINE_DURATION = 30 days; // hard deadline is this much after the round start\r\n    \r\n    uint public constant TIME_PER_KEY = 5 minutes; // how much time is added to the soft deadline per key purchased\r\n    uint public constant PRICE_INCREASE_PERIOD = 1 hours; // how often the price doubles after the hard deadline\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n    \r\n    Percent.percent private m_currentRoundJackpotPercent = Percent.percent(15, 100); // 15/100*100% = 15%\r\n    Percent.percent private m_investorsPercent = Percent.percent(65, 100); // 65/100*100% = 65%\r\n    Percent.percent private m_devPercent = Percent.percent(10, 100); // 15/100*100% = 15%\r\n    Percent.percent private m_nextRoundSeedPercent = Percent.percent(5, 100); // 15/100*100% = 15%\r\n    Percent.percent private m_airdropPercent = Percent.percent(2, 100); // 15/100*100% = 15%\r\n    Percent.percent private m_bankOfEthProfitPercent = Percent.percent(3, 100); // 15/100*100% = 15%\r\n    Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 15%\r\n    \r\n    struct SafeBreaker {\r\n        //uint lastCumulativeReturnsPoints;\r\n        uint lastCumulativeReturnsPoints;\r\n        uint keys;\r\n    }\r\n    \r\n    struct GameRound {\r\n        uint totalInvested;        \r\n        uint jackpot;\r\n        uint airdropPot;\r\n        uint totalKeys;\r\n        uint cumulativeReturnsPoints; // this is to help calculate returns when the total number of keys changes\r\n        uint hardDeadline;\r\n        uint softDeadline;\r\n        uint price;\r\n        uint lastPriceIncreaseTime;\r\n        address lastInvestor;\r\n        bool finalized;\r\n        mapping (address => SafeBreaker) safeBreakers;\r\n    }\r\n    \r\n    struct Vault {\r\n        uint totalReturns; // Total balance = returns + referral returns + jackpots/airdrops \r\n        uint refReturns; // how much of the total is from referrals\r\n    }\r\n\r\n    mapping (address => Vault) vaults;\r\n\r\n    uint public latestRoundID;// the first round has an ID of 0\r\n    GameRound[] rounds;\r\n    \r\n    \r\n    uint256 public minInvestment = 1 finney; // 0.01 eth\r\n    uint256 public maxInvestment = 2000 ether; \r\n    uint256 public roundDuration = (24 hours);\r\n    uint public soft_deadline_duration = 1 days; // max soft deadline\r\n    bool public gamePaused = false;\r\n    bool public limitedReferralsMode = true;\r\n    \r\n    mapping(address => bool) private m_referrals; // we only pay out on the first set of referrals\r\n    \r\n    \r\n    // Game vars\r\n    uint public jackpotSeed;// Jackpot from previous rounds\r\n    \r\n    uint public unclaimedReturns;\r\n    uint public constant MULTIPLIER = RAY;\r\n    \r\n    // Main stats:\r\n    uint public totalJackpotsWon;\r\n    uint public totalKeysSold;\r\n    uint public totalEarningsGenerated;\r\n\r\n    \r\n    // modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier notOnPause() {\r\n        require(gamePaused == false, \"Game Paused\");\r\n        _;\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    constructor() public {\r\n\r\n        owner = msg.sender;\r\n        devAddress = msg.sender;\r\n        localBankOfEth = BankOfEth(bankOfEthAddress);\r\n        \r\n        rounds.length++;\r\n        GameRound storage rnd = rounds[0];\r\n        latestRoundID = 0;\r\n\r\n        rnd.lastInvestor = msg.sender;\r\n        rnd.price = STARTING_KEY_PRICE;\r\n        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\r\n        rnd.softDeadline = now + soft_deadline_duration;\r\n        jackpotSeed = 0; \r\n        rnd.jackpot = jackpotSeed;\r\n        \r\n\r\n        \r\n    }\r\n    \r\n    function () public payable {\r\n        buyKeys(address(0x0));\r\n    }\r\n    \r\n    function investorInfo(address investor, uint roundID) external view\r\n    returns(uint keys, uint totalReturns, uint referralReturns) \r\n    {\r\n        GameRound storage rnd = rounds[roundID];\r\n        keys = rnd.safeBreakers[investor].keys;\r\n        (totalReturns, referralReturns) = estimateReturns(investor, roundID);\r\n    }\r\n    function estimateReturns(address investor, uint roundID) public view \r\n    returns (uint totalReturns, uint refReturns) \r\n    {\r\n        GameRound storage rnd = rounds[roundID];\r\n        uint outstanding;\r\n        if(rounds.length > 1) {\r\n            if(hasReturns(investor, roundID - 1)) {\r\n                GameRound storage prevRnd = rounds[roundID - 1];\r\n                outstanding = _outstandingReturns(investor, prevRnd);\r\n            }\r\n        }\r\n\r\n        outstanding += _outstandingReturns(investor, rnd);\r\n        \r\n        totalReturns = vaults[investor].totalReturns + outstanding;\r\n        refReturns = vaults[investor].refReturns;\r\n    }\r\n    \r\n    function roundInfo(uint roundID) external view \r\n    returns(\r\n        address leader, \r\n        uint price,\r\n        uint jackpot, \r\n        uint airdrop, \r\n        uint keys, \r\n        uint totalInvested,\r\n        uint distributedReturns,\r\n        uint _hardDeadline,\r\n        uint _softDeadline,\r\n        bool finalized\r\n        )\r\n    {\r\n        GameRound storage rnd = rounds[roundID];\r\n        leader = rnd.lastInvestor;\r\n        price = rnd.price;\r\n        jackpot = rnd.jackpot;\r\n        airdrop = rnd.airdropPot;\r\n        keys = rnd.totalKeys;\r\n        totalInvested = rnd.totalInvested;\r\n        distributedReturns = m_currentRoundJackpotPercent.mul(rnd.totalInvested);\r\n        //wmul(rnd.totalInvested, RETURNS_FRACTION);\r\n        _hardDeadline = rnd.hardDeadline;\r\n        _softDeadline = rnd.softDeadline;\r\n        finalized = rnd.finalized;\r\n    }\r\n    \r\n    function totalsInfo() external view \r\n    returns(\r\n        uint totalReturns,\r\n        uint totalKeys,\r\n        uint totalJackpots\r\n    ) {\r\n        GameRound storage rnd = rounds[latestRoundID];\r\n        if(rnd.softDeadline > now) {\r\n            totalKeys = totalKeysSold + rnd.totalKeys;\r\n            totalReturns = totalEarningsGenerated + m_currentRoundJackpotPercent.mul(rnd.totalInvested); \r\n            // wmul(rnd.totalInvested, RETURNS_FRACTION);\r\n        } else {\r\n            totalKeys = totalKeysSold;\r\n            totalReturns = totalEarningsGenerated;\r\n        }\r\n        totalJackpots = totalJackpotsWon;\r\n    }\r\n\r\n    \r\n    function reinvestReturns(uint value) public {        \r\n        reinvestReturns(value, address(0x0));\r\n    }\r\n\r\n    function reinvestReturns(uint value, address ref) public {        \r\n        GameRound storage rnd = rounds[latestRoundID];\r\n        _updateReturns(msg.sender, rnd);        \r\n        require(vaults[msg.sender].totalReturns >= value, \"Can't spend what you don't have\");        \r\n        vaults[msg.sender].totalReturns = vaults[msg.sender].totalReturns.sub(value);\r\n        vaults[msg.sender].refReturns = min(vaults[msg.sender].refReturns, vaults[msg.sender].totalReturns);\r\n        unclaimedReturns = unclaimedReturns.sub(value);\r\n        _purchase(rnd, value, ref);\r\n    }\r\n    function withdrawReturns() public {\r\n        GameRound storage rnd = rounds[latestRoundID];\r\n\r\n        if(rounds.length > 1) {// check if they also have returns from before\r\n            if(hasReturns(msg.sender, latestRoundID - 1)) {\r\n                GameRound storage prevRnd = rounds[latestRoundID - 1];\r\n                _updateReturns(msg.sender, prevRnd);\r\n            }\r\n        }\r\n        _updateReturns(msg.sender, rnd);\r\n        uint amount = vaults[msg.sender].totalReturns;\r\n        require(amount > 0, \"Nothing to withdraw!\");\r\n        unclaimedReturns = unclaimedReturns.sub(amount);\r\n        vaults[msg.sender].totalReturns = 0;\r\n        vaults[msg.sender].refReturns = 0;\r\n        \r\n        rnd.safeBreakers[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\r\n        msg.sender.transfer(amount);\r\n\r\n        emit ReturnsWithdrawn(msg.sender, amount, now);\r\n    }\r\n    function hasReturns(address investor, uint roundID) public view returns (bool) {\r\n        GameRound storage rnd = rounds[roundID];\r\n        return rnd.cumulativeReturnsPoints > rnd.safeBreakers[investor].lastCumulativeReturnsPoints;\r\n    }\r\n    function updateMyReturns(uint roundID) public {\r\n        GameRound storage rnd = rounds[roundID];\r\n        _updateReturns(msg.sender, rnd);\r\n    }\r\n    \r\n    function finalizeLastRound() public {\r\n        GameRound storage rnd = rounds[latestRoundID];\r\n        _finalizeRound(rnd);\r\n    }\r\n    function finalizeAndRestart() public payable {\r\n        finalizeLastRound();\r\n        startNewRound(address(0x0));\r\n    }\r\n    \r\n    function finalizeAndRestart(address _referer) public payable {\r\n        finalizeLastRound();\r\n        startNewRound(_referer);\r\n    }\r\n    \r\n    event debugLog(uint _num, string _string);\r\n    \r\n    function startNewRound(address _referer) public payable {\r\n        \r\n        require(rounds[latestRoundID].finalized, \"Previous round not finalized\");\r\n        require(rounds[latestRoundID].softDeadline < now, \"Previous round still running\");\r\n        \r\n        uint _rID = rounds.length++; // first round is 0\r\n        GameRound storage rnd = rounds[_rID];\r\n        latestRoundID = _rID;\r\n\r\n        rnd.lastInvestor = msg.sender;\r\n        rnd.price = STARTING_KEY_PRICE;\r\n        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\r\n        rnd.softDeadline = now + soft_deadline_duration;\r\n        rnd.jackpot = jackpotSeed;\r\n        jackpotSeed = 0; \r\n\r\n        _purchase(rnd, msg.value, _referer);\r\n        emit RoundStarted(_rID, rnd.hardDeadline, now);\r\n    }\r\n    \r\n    \r\n    function buyKeys(address _referer) public payable notOnPause {\r\n        require(msg.value >= minInvestment);\r\n        if(rounds.length > 0) {\r\n            GameRound storage rnd = rounds[latestRoundID];   \r\n               \r\n            _purchase(rnd, msg.value, _referer);            \r\n        } else {\r\n            revert(\"Not yet started\");\r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n    function _purchase(GameRound storage rnd, uint value, address referer) internal {\r\n        require(rnd.softDeadline >= now, \"After deadline!\");\r\n        require(value >= rnd.price/10, \"Not enough Ether!\");\r\n        rnd.totalInvested = rnd.totalInvested.add(value);\r\n\r\n        // Set the last investor (to win the jackpot after the deadline)\r\n        if(value >= rnd.price)\r\n            rnd.lastInvestor = msg.sender;\r\n        \r\n        \r\n        _airDrop(rnd, value);\r\n        \r\n\r\n        _splitRevenue(rnd, value, referer);\r\n        \r\n        _updateReturns(msg.sender, rnd);\r\n        \r\n        uint newKeys = _issueKeys(rnd, msg.sender, value);\r\n\r\n\r\n        uint timeIncreases = newKeys/WAD;// since 1 key is represented by 1 * 10^18, divide by 10^18\r\n        // adjust soft deadline to new soft deadline\r\n        uint newDeadline = rnd.softDeadline.add( timeIncreases.mul(TIME_PER_KEY));\r\n        \r\n        rnd.softDeadline = min(newDeadline, now + soft_deadline_duration);\r\n        // If after hard deadline, double the price every price increase periods\r\n        if(now > rnd.hardDeadline) {\r\n            if(now > rnd.lastPriceIncreaseTime + PRICE_INCREASE_PERIOD) {\r\n                rnd.price = rnd.price * 2;\r\n                rnd.lastPriceIncreaseTime = now;\r\n            }\r\n        }\r\n    }\r\n    function _issueKeys(GameRound storage rnd, address _safeBreaker, uint value) internal returns(uint) {    \r\n        if(rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints == 0) {\r\n            rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\r\n        }    \r\n        \r\n        uint newKeys = wdiv(value, rnd.price);\r\n        \r\n        //bonuses:\r\n        if(value >= 100 ether) {\r\n            newKeys = newKeys.mul(2);//get double keys if you paid more than 100 ether\r\n        } else if(value >= 10 ether) {\r\n            newKeys = newKeys.add(newKeys/2);//50% bonus\r\n        } else if(value >= 1 ether) {\r\n            newKeys = newKeys.add(newKeys/3);//33% bonus\r\n        } else if(value >= 100 finney) {\r\n            newKeys = newKeys.add(newKeys/10);//10% bonus\r\n        }\r\n\r\n        rnd.safeBreakers[_safeBreaker].keys = rnd.safeBreakers[_safeBreaker].keys.add(newKeys);\r\n        rnd.totalKeys = rnd.totalKeys.add(newKeys);\r\n        emit KeysIssued(_safeBreaker, newKeys, now);\r\n        return newKeys;\r\n    }    \r\n    function _updateReturns(address _safeBreaker, GameRound storage rnd) internal {\r\n        if(rnd.safeBreakers[_safeBreaker].keys == 0) {\r\n            return;\r\n        }\r\n        \r\n        uint outstanding = _outstandingReturns(_safeBreaker, rnd);\r\n\r\n        // if there are any returns, transfer them to the investor's vaults\r\n        if (outstanding > 0) {\r\n            vaults[_safeBreaker].totalReturns = vaults[_safeBreaker].totalReturns.add(outstanding);\r\n        }\r\n\r\n        rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\r\n    }\r\n    function _outstandingReturns(address _safeBreaker, GameRound storage rnd) internal view returns(uint) {\r\n        if(rnd.safeBreakers[_safeBreaker].keys == 0) {\r\n            return 0;\r\n        }\r\n        // check if there've been new returns\r\n        uint newReturns = rnd.cumulativeReturnsPoints.sub(\r\n            rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints\r\n            );\r\n\r\n        uint outstanding = 0;\r\n        if(newReturns != 0) { \r\n            // outstanding returns = (total new returns points * ivestor keys) / MULTIPLIER\r\n            // The MULTIPLIER is used also at the point of returns disbursment\r\n            outstanding = newReturns.mul(rnd.safeBreakers[_safeBreaker].keys) / MULTIPLIER;\r\n        }\r\n\r\n        return outstanding;\r\n    }\r\n    function _splitRevenue(GameRound storage rnd, uint value, address ref) internal {\r\n        uint roundReturns; // how much to pay in dividends to round players\r\n        \r\n\r\n        if(ref != address(0x0)) {\r\n\r\n            // only pay referrals for the first investment of each player\r\n            if(\r\n                (!m_referrals[msg.sender] && limitedReferralsMode == true)\r\n                ||\r\n                limitedReferralsMode == false\r\n                ) {\r\n            \r\n            \r\n                uint _referralEarning = m_refPercent.mul(value);\r\n                unclaimedReturns = unclaimedReturns.add(_referralEarning);\r\n                vaults[ref].totalReturns = vaults[ref].totalReturns.add(_referralEarning);\r\n                vaults[ref].refReturns = vaults[ref].refReturns.add(_referralEarning);\r\n                \r\n                value = value.sub(_referralEarning);\r\n                \r\n                m_referrals[msg.sender] = true;\r\n                \r\n            }\r\n        } else {\r\n        }\r\n        \r\n        roundReturns = m_investorsPercent.mul(value); // 65%\r\n        \r\n        uint airdrop_value = m_airdropPercent.mul(value);\r\n        \r\n        uint jackpot_value = m_currentRoundJackpotPercent.mul(value); //15%\r\n        \r\n        uint dev_value = m_devPercent.mul(value);\r\n        \r\n        uint bankOfEth_profit = m_bankOfEthProfitPercent.mul(value);\r\n        localBankOfEth.receiveExternalProfits.value(bankOfEth_profit)();\r\n        \r\n        // if this is the first purchase, roundReturns goes to jackpot (no one can claim these returns otherwise)\r\n        if(rnd.totalKeys == 0) {\r\n            rnd.jackpot = rnd.jackpot.add(roundReturns);\r\n        } else {\r\n            _disburseReturns(rnd, roundReturns);\r\n        }\r\n        \r\n        rnd.airdropPot = rnd.airdropPot.add(airdrop_value);\r\n        rnd.jackpot = rnd.jackpot.add(jackpot_value);\r\n        \r\n        devAddress.transfer(dev_value);\r\n        \r\n    }\r\n    function _disburseReturns(GameRound storage rnd, uint value) internal {\r\n        emit EthDistributed(value, now);\r\n        unclaimedReturns = unclaimedReturns.add(value);// keep track of unclaimed returns\r\n        // The returns points represent returns*MULTIPLIER/totalkeys (at the point of purchase)\r\n        // This allows us to keep outstanding balances of keyholders when the total supply changes in real time\r\n        if(rnd.totalKeys == 0) {\r\n            //rnd.cumulativeReturnsPoints = mul(value, MULTIPLIER) / wdiv(value, rnd.price);\r\n            rnd.cumulativeReturnsPoints = value.mul(MULTIPLIER) / wdiv(value, rnd.price);\r\n        } else {\r\n            rnd.cumulativeReturnsPoints = rnd.cumulativeReturnsPoints.add(\r\n                value.mul(MULTIPLIER) / rnd.totalKeys\r\n            );\r\n        }\r\n    }\r\n    function _airDrop(GameRound storage rnd, uint value) internal {\r\n        require(msg.sender == tx.origin, \"Only Humans Allowed! (or scripts that don't use smart contracts)!\");\r\n        if(value > 100 finney) {\r\n            /**\r\n                Creates a random number from the last block hash and current timestamp.\r\n                One could add more seemingly random data like the msg.sender, etc, but that doesn't \r\n                make it harder for a miner to manipulate the result in their favor (if they intended to).\r\n             */\r\n            uint chance = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), now)));\r\n            if(chance % 200 == 0) {// once in 200 times\r\n                uint prize = rnd.airdropPot / 2;// win half of the pot, regardless of how much you paid\r\n                rnd.airdropPot = rnd.airdropPot / 2;\r\n                vaults[msg.sender].totalReturns = vaults[msg.sender].totalReturns.add(prize);\r\n                unclaimedReturns = unclaimedReturns.add(prize);\r\n                totalJackpotsWon += prize;\r\n                emit AirdropWon(msg.sender, prize, now);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function _finalizeRound(GameRound storage rnd) internal {\r\n        require(!rnd.finalized, \"Already finalized!\");\r\n        require(rnd.softDeadline < now, \"Round still running!\");\r\n\r\n\r\n        // Transfer jackpot to winner's vault\r\n        vaults[rnd.lastInvestor].totalReturns = vaults[rnd.lastInvestor].totalReturns.add(rnd.jackpot);\r\n        unclaimedReturns = unclaimedReturns.add(rnd.jackpot);\r\n        \r\n        emit JackpotWon(rnd.lastInvestor, rnd.jackpot, now);\r\n        totalJackpotsWon += rnd.jackpot;\r\n        // transfer the leftover to the next round's jackpot\r\n        jackpotSeed = jackpotSeed.add( m_nextRoundSeedPercent.mul(rnd.totalInvested));\r\n            \r\n        //Empty the AD pot if it has a balance.\r\n        jackpotSeed = jackpotSeed.add(rnd.airdropPot);\r\n        \r\n        //Send out dividends to token holders\r\n        //uint _div;\r\n        \r\n        //_div = wmul(rnd.totalInvested, DIVIDENDS_FRACTION);            \r\n        \r\n        //token.disburseDividends.value(_div)();\r\n        //totalDividendsPaid += _div;\r\n        totalKeysSold += rnd.totalKeys;\r\n        totalEarningsGenerated += m_currentRoundJackpotPercent.mul(rnd.totalInvested);\r\n\r\n        rnd.finalized = true;\r\n    }\r\n    \r\n    // Owner only functions    \r\n    function p_setOwner(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n    function p_setDevAddress(address _devAddress) public onlyOwner {\r\n        devAddress = _devAddress;\r\n    }\r\n    function p_setCurrentRoundJackpotPercent(uint num, uint dem) public onlyOwner {\r\n        m_currentRoundJackpotPercent = Percent.percent(num, dem);\r\n    }\r\n    function p_setInvestorsPercent(uint num, uint dem) public onlyOwner {\r\n        m_investorsPercent = Percent.percent(num, dem);\r\n    }\r\n    function p_setDevPercent(uint num, uint dem) public onlyOwner {\r\n        m_devPercent = Percent.percent(num, dem);\r\n    }\r\n    function p_setNextRoundSeedPercent(uint num, uint dem) public onlyOwner {\r\n        m_nextRoundSeedPercent = Percent.percent(num, dem);\r\n    }\r\n    function p_setAirdropPercent(uint num, uint dem) public onlyOwner {\r\n        m_airdropPercent = Percent.percent(num, dem);\r\n    }\r\n    function p_setBankOfEthProfitPercent(uint num, uint dem) public onlyOwner {\r\n        m_bankOfEthProfitPercent = Percent.percent(num, dem);\r\n    }\r\n    function p_setMinInvestment(uint _minInvestment) public onlyOwner {\r\n        minInvestment = _minInvestment;\r\n    }\r\n    function p_setMaxInvestment(uint _maxInvestment) public onlyOwner {\r\n        maxInvestment = _maxInvestment;\r\n    }\r\n    function p_setGamePaused(bool _gamePaused) public onlyOwner {\r\n        gamePaused = _gamePaused;\r\n    }\r\n    function p_setRoundDuration(uint256 _roundDuration) public onlyOwner {\r\n        roundDuration = _roundDuration;\r\n    }\r\n    function p_setBankOfEthAddress(address _bankOfEthAddress) public onlyOwner {\r\n        bankOfEthAddress = _bankOfEthAddress;\r\n        localBankOfEth = BankOfEth(bankOfEthAddress);\r\n    }\r\n    function p_setLimitedReferralsMode(bool _limitedReferralsMode) public onlyOwner {\r\n        limitedReferralsMode = _limitedReferralsMode;\r\n    }\r\n    function p_setSoft_deadline_duration(uint _soft_deadline_duration) public onlyOwner {\r\n        soft_deadline_duration = _soft_deadline_duration;\r\n    }\r\n    // Util functions\r\n    function notZeroAndNotSender(address addr) internal view returns(bool) {\r\n        return addr.notZero() && addr != msg.sender;\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = x.mul(y).add(WAD/2) / WAD;\r\n        //z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = x.mul(y).add(RAY/2) / RAY;\r\n        //z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = x.mul(WAD).add(y/2)/y;\r\n        //z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = x.mul(RAY).add(y/2)/y;\r\n        //z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n    \r\n    uint op;\r\n    function gameOp() public {\r\n        op++;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundDuration\",\"type\":\"uint256\"}],\"name\":\"p_setRoundDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalKeysSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"startNewRound\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"buyKeys\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitedReferralsMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"dem\",\"type\":\"uint256\"}],\"name\":\"p_setInvestorsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEarningsGenerated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"totalReturns\",\"type\":\"uint256\"},{\"name\":\"referralReturns\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soft_deadline_duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minInvestment\",\"type\":\"uint256\"}],\"name\":\"p_setMinInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limitedReferralsMode\",\"type\":\"bool\"}],\"name\":\"p_setLimitedReferralsMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"updateMyReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"roundInfo\",\"outputs\":[{\"name\":\"leader\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"airdrop\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"name\":\"distributedReturns\",\"type\":\"uint256\"},{\"name\":\"_hardDeadline\",\"type\":\"uint256\"},{\"name\":\"_softDeadline\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"hasReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeAndRestart\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalsInfo\",\"outputs\":[{\"name\":\"totalReturns\",\"type\":\"uint256\"},{\"name\":\"totalKeys\",\"type\":\"uint256\"},{\"name\":\"totalJackpots\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_devAddress\",\"type\":\"address\"}],\"name\":\"p_setDevAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"p_setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"dem\",\"type\":\"uint256\"}],\"name\":\"p_setBankOfEthProfitPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"dem\",\"type\":\"uint256\"}],\"name\":\"p_setNextRoundSeedPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"dem\",\"type\":\"uint256\"}],\"name\":\"p_setAirdropPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxInvestment\",\"type\":\"uint256\"}],\"name\":\"p_setMaxInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_soft_deadline_duration\",\"type\":\"uint256\"}],\"name\":\"p_setSoft_deadline_duration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"gameOp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"dem\",\"type\":\"uint256\"}],\"name\":\"p_setCurrentRoundJackpotPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HARD_DEADLINE_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"reinvestReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"estimateReturns\",\"outputs\":[{\"name\":\"totalReturns\",\"type\":\"uint256\"},{\"name\":\"refReturns\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STARTING_KEY_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gamePaused\",\"type\":\"bool\"}],\"name\":\"p_setGamePaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bankOfEthAddress\",\"type\":\"address\"}],\"name\":\"p_setBankOfEthAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeLastRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"reinvestReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_PER_KEY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalJackpotsWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"finalizeAndRestart\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"dem\",\"type\":\"uint256\"}],\"name\":\"p_setDevPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestRoundID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_INCREASE_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"KeysIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"EthDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReturnsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"JackpotWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AirdropWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardDeadline\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_num\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_string\",\"type\":\"string\"}],\"name\":\"debugLog\",\"type\":\"event\"}]","ContractName":"BankOfEthVaultBreaker","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e557fa958935f5b12bde1fce4c2ed6f9115108977045a01d97841de6305aee18"}]}