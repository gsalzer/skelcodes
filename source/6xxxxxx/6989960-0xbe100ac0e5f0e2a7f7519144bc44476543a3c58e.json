{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: contracts/ERC20Relay.sol\r\n\r\ncontract ERC20Relay is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    string public constant VERSION = \"1.0.0\";\r\n\r\n    /* Managers */\r\n    address public verifierManager;\r\n    address public feeManager;\r\n\r\n    event NewVerifierManager(\r\n        address indexed previousManager,\r\n        address indexed newManager\r\n    );\r\n    event NewFeeManager(\r\n        address indexed previousManager,\r\n        address indexed newManager\r\n    );\r\n\r\n    /* Verifiers */\r\n    uint256 constant MINIMUM_VERIFIERS = 3;\r\n    uint256 public requiredVerifiers;\r\n    address[] private verifiers;\r\n    mapping (address => uint256) private verifierAddressToIndex;\r\n\r\n    /* Withdrawals */\r\n    uint256 constant GAS_PRICE = 20 * 10 ** 9;\r\n    uint256 constant ESTIMATED_GAS_PER_VERIFIER = 54301;\r\n    uint256 constant ESTIMATED_GAS_PER_WITHDRAWAL= 73458;\r\n    uint256 public nctEthExchangeRate;\r\n    uint256 public fees;\r\n    address public feeWallet;\r\n\r\n    struct Withdrawal {\r\n        address destination;\r\n        uint256 amount;\r\n        bool processed;\r\n    }\r\n\r\n    mapping (bytes32 => Withdrawal) public withdrawals;\r\n    mapping (bytes32 => address[]) public withdrawalApprovals;\r\n\r\n    event WithdrawalProcessed(\r\n        address indexed destination,\r\n        uint256 amount,\r\n        bytes32 txHash,\r\n        bytes32 blockHash,\r\n        uint256 blockNumber\r\n    );\r\n\r\n    event FeesChanged(\r\n        uint256 newFees\r\n    );\r\n\r\n    /* Sidechain anchoring */\r\n    struct Anchor {\r\n        bytes32 blockHash;\r\n        uint256 blockNumber;\r\n        bool processed;\r\n    }\r\n\r\n    Anchor[] public anchors;\r\n    mapping (bytes32 => address[]) public anchorApprovals;\r\n\r\n    event AnchoredBlock(\r\n        bytes32 indexed blockHash,\r\n        uint256 indexed blockNumber\r\n    );\r\n\r\n    event ContestedBlock(\r\n        bytes32 indexed blockHash,\r\n        uint256 indexed blockNumber\r\n    );\r\n\r\n    ERC20 private token;\r\n\r\n    constructor(address _token, uint256 _nctEthExchangeRate, address _feeWallet, address[] _verifiers) public {\r\n        require(_token != address(0), \"Invalid token address\");\r\n        require(_verifiers.length >= MINIMUM_VERIFIERS, \"Number of verifiers less than minimum\");\r\n\r\n        // If set to address(0), onlyVerifierManager and onlyFeeManager are equivalent to onlyOwner\r\n        verifierManager = address(0);\r\n        feeManager = address(0);\r\n\r\n        // Dummy verifier at index 0\r\n        verifiers.push(address(0));\r\n\r\n        for (uint256 i = 0; i < _verifiers.length; i++) {\r\n            verifiers.push(_verifiers[i]);\r\n            verifierAddressToIndex[_verifiers[i]] = i.add(1);\r\n        }\r\n\r\n        requiredVerifiers = calculateRequiredVerifiers();\r\n\r\n        nctEthExchangeRate = _nctEthExchangeRate;\r\n        fees = calculateFees();\r\n\r\n        token = ERC20(_token);\r\n        feeWallet = _feeWallet;\r\n    }\r\n\r\n    /** Disable usage of the fallback function */\r\n    function () external payable {\r\n        revert(\"Do not allow sending Eth to this contract\");\r\n    }\r\n\r\n    modifier onlyVerifierManager() {\r\n        if (verifierManager == address(0)) {\r\n            require(msg.sender == owner, \"Not a verifier manager\");\r\n        } else {\r\n            require(msg.sender == verifierManager, \"Not a verifier manager\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function setVerifierManager(address newVerifierManager) external onlyOwner {\r\n        emit NewVerifierManager(verifierManager, newVerifierManager);\r\n        verifierManager = newVerifierManager;\r\n    }\r\n\r\n    modifier onlyFeeManager() {\r\n        if (feeManager == address(0)) {\r\n            require(msg.sender == owner, \"Not a fee manager\");\r\n        } else {\r\n            require(msg.sender == feeManager, \"Not a fee manager\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function setFeeManager(address newFeeManager) external onlyOwner {\r\n        emit NewFeeManager(feeManager, newFeeManager);\r\n        feeManager = newFeeManager;\r\n    }\r\n\r\n    function addVerifier(address addr) external onlyVerifierManager {\r\n        require(addr != address(0), \"Invalid verifier address\");\r\n        require(verifierAddressToIndex[addr] == 0, \"Address is already a verifier\");\r\n\r\n        uint256 index = verifiers.push(addr);\r\n        verifierAddressToIndex[addr] = index.sub(1);\r\n\r\n        requiredVerifiers = calculateRequiredVerifiers();\r\n        fees = calculateFees();\r\n    }\r\n\r\n    function removeVerifier(address addr) external onlyVerifierManager {\r\n        require(addr != address(0), \"Invalid verifier address\");\r\n        require(verifierAddressToIndex[addr] != 0, \"Address is not a verifier\");\r\n        require(verifiers.length.sub(1) > MINIMUM_VERIFIERS, \"Removing verifier would put number of verifiers below minimum\");\r\n\r\n        uint256 index = verifierAddressToIndex[addr];\r\n        require(verifiers[index] == addr, \"Verifier address not present in verifiers array\");\r\n        verifiers[index] = verifiers[verifiers.length.sub(1)];\r\n        verifierAddressToIndex[verifiers[verifiers.length.sub(1)]] = index;\r\n        delete verifierAddressToIndex[addr];\r\n        verifiers.length = verifiers.length.sub(1);\r\n\r\n        requiredVerifiers = calculateRequiredVerifiers();\r\n        fees = calculateFees();\r\n    }\r\n\r\n    function activeVerifiers() public view returns (address[]) {\r\n        require(verifiers.length > 0, \"Invalid number of verifiers\");\r\n\r\n        address[] memory ret = new address[](verifiers.length.sub(1));\r\n\r\n        // Skip dummy verifier at index 0\r\n        for (uint256 i = 1; i < verifiers.length; i++) {\r\n            ret[i.sub(1)] = verifiers[i];\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    function numberOfVerifiers() public view returns (uint256) {\r\n        require(verifiers.length > 0, \"Invalid number of verifiers\");\r\n        return verifiers.length.sub(1);\r\n    }\r\n\r\n    function calculateRequiredVerifiers() internal view returns(uint256) {\r\n        return numberOfVerifiers().mul(2).div(3);\r\n    }\r\n\r\n    function isVerifier(address addr) public view returns (bool) {\r\n        return verifierAddressToIndex[addr] != 0 && verifiers[verifierAddressToIndex[addr]] == addr;\r\n    }\r\n\r\n    modifier onlyVerifier() {\r\n        require(isVerifier(msg.sender), \"msg.sender is not verifier\");\r\n        _;\r\n    }\r\n\r\n    function setNctEthExchangeRate(uint256 _nctEthExchangeRate) external onlyFeeManager {\r\n        nctEthExchangeRate = _nctEthExchangeRate;\r\n        fees = calculateFees();\r\n\r\n        emit FeesChanged(fees);\r\n    }\r\n\r\n    function calculateFees() internal view returns (uint256) {\r\n        uint256 estimatedGas = ESTIMATED_GAS_PER_VERIFIER.mul(numberOfVerifiers())\r\n            .add(ESTIMATED_GAS_PER_WITHDRAWAL);\r\n        return estimatedGas.mul(GAS_PRICE).mul(nctEthExchangeRate);\r\n    }\r\n\r\n    function approveWithdrawal(\r\n        address destination,\r\n        uint256 amount,\r\n        bytes32 txHash,\r\n        bytes32 blockHash,\r\n        uint256 blockNumber\r\n    )\r\n        external\r\n        onlyVerifier\r\n    {\r\n        require(amount > fees, \"Withdrawal amount is less than or equal to fees\");\r\n        require(destination != address(0), \"Invalid destination address\");\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(txHash, blockHash, blockNumber));\r\n        uint256 net = amount.sub(fees);\r\n\r\n        if (withdrawals[hash].destination == address(0)) {\r\n            withdrawals[hash] = Withdrawal(destination, net, false);\r\n        }\r\n\r\n        Withdrawal storage w = withdrawals[hash];\r\n        address[] storage approvals = withdrawalApprovals[hash];\r\n        require(w.destination == destination, \"Destination mismatch\");\r\n        require(w.amount == net, \"Amount mismatch\");\r\n\r\n\r\n        for (uint256 i = 0; i < approvals.length; i++) {\r\n            require(approvals[i] != msg.sender, \"Already approved withdrawal\");\r\n        }\r\n\r\n        approvals.push(msg.sender);\r\n\r\n        if (approvals.length >= requiredVerifiers && !w.processed) {\r\n            if (fees != 0 && feeWallet != address(0)) {\r\n                token.safeTransfer(feeWallet, fees);\r\n            }\r\n\r\n            // We require that amount > fees therefore net > 0\r\n            token.safeTransfer(destination, net);\r\n\r\n            w.processed = true;\r\n            emit WithdrawalProcessed(destination, net, txHash, blockHash, blockNumber);\r\n        }\r\n    }\r\n\r\n    // Allow verifiers to retract their withdrawals in the case of a chain\r\n    // reorganization. This shouldn't happen but is possible.\r\n    function unapproveWithdrawal(\r\n        bytes32 txHash,\r\n        bytes32 blockHash,\r\n        uint256 blockNumber\r\n    )\r\n        external\r\n        onlyVerifier\r\n    {\r\n        bytes32 hash = keccak256(abi.encodePacked(txHash, blockHash, blockNumber));\r\n        require(withdrawals[hash].destination != address(0), \"No such withdrawal\");\r\n\r\n        Withdrawal storage w = withdrawals[hash];\r\n        address[] storage approvals = withdrawalApprovals[hash];\r\n        require(!w.processed, \"Withdrawal already processed\");\r\n\r\n        uint256 length = approvals.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (approvals[i] == msg.sender) {\r\n                approvals[i] = approvals[length.sub(1)];\r\n                delete approvals[length.sub(1)];\r\n                approvals.length = approvals.length.sub(1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function anchor(bytes32 blockHash, uint256 blockNumber) external onlyVerifier {\r\n        // solium-disable-next-line operator-whitespace\r\n        if (anchors.length == 0 ||\r\n            anchors[anchors.length.sub(1)].blockHash != blockHash ||\r\n            anchors[anchors.length.sub(1)].blockNumber != blockNumber) {\r\n            // Emit event to alert the last anchor was never confirmed\r\n\r\n            if (anchors.length > 0 && !anchors[anchors.length.sub(1)].processed) {\r\n                Anchor storage last = anchors[anchors.length.sub(1)];\r\n                emit ContestedBlock(last.blockHash, last.blockNumber);\r\n            }\r\n            anchors.push(Anchor(blockHash, blockNumber, false));\r\n        }\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(blockHash, blockNumber));\r\n        Anchor storage a = anchors[anchors.length.sub(1)];\r\n        address[] storage approvals = anchorApprovals[hash];\r\n        require(a.blockHash == blockHash, \"Block hash mismatch\");\r\n        require(a.blockNumber == blockNumber, \"Block number mismatch\");\r\n\r\n        for (uint256 i = 0; i < approvals.length; i++) {\r\n            require(approvals[i] != msg.sender, \"Already approved anchor block\");\r\n        }\r\n\r\n        approvals.push(msg.sender);\r\n        if (approvals.length >= requiredVerifiers && !a.processed) {\r\n            a.processed = true;\r\n            emit AnchoredBlock(blockHash, blockNumber);\r\n        }\r\n    }\r\n\r\n    function unanchor() external onlyVerifier {\r\n        Anchor storage a = anchors[anchors.length.sub(1)];\r\n        require(!a.processed, \"Block anchor already processed\");\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(a.blockHash, a.blockNumber));\r\n        address[] storage approvals = anchorApprovals[hash];\r\n\r\n        uint256 length = approvals.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (approvals[i] == msg.sender) {\r\n                approvals[i] = approvals[length.sub(1)];\r\n                delete approvals[length.sub(1)];\r\n                approvals.length = approvals.length.sub(1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"unanchor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifierManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeVerifiers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"anchors\",\"outputs\":[{\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"processed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeeManager\",\"type\":\"address\"}],\"name\":\"setFeeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawalApprovals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfVerifiers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredVerifiers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nctEthExchangeRate\",\"type\":\"uint256\"}],\"name\":\"setNctEthExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"txHash\",\"type\":\"bytes32\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"approveWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"anchor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addVerifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txHash\",\"type\":\"bytes32\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"unapproveWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nctEthExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newVerifierManager\",\"type\":\"address\"}],\"name\":\"setVerifierManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeVerifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"anchorApprovals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawals\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"processed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_nctEthExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_feeWallet\",\"type\":\"address\"},{\"name\":\"_verifiers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"NewVerifierManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"NewFeeManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"WithdrawalProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFees\",\"type\":\"uint256\"}],\"name\":\"FeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"AnchoredBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"ContestedBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ERC20Relay","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009e46a38f5daabe8683e10793b06749eef7d733d100000000000000000000000000000000000000000000000000000000000103610000000000000000000000000f57baedcf2c84383492d1ea700835ce2492c48a000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000050000000000000000000000008ba785d521735b04d9da615e7acd469da578356d0000000000000000000000003f5d0751736d89fb519c88a153413fbbf4456f49000000000000000000000000b15fb44788e5eda896247ef4e3d552ccc05f5d6b000000000000000000000000315bf9dfc4f27b02c8e2df0b541ac601c352613d000000000000000000000000a6fe9a9ecd482934779aa896db8dd1488bdde3d2","Library":"","SwarmSource":"bzzr://4e6ba8db7449aea94b7804e55c47c749e5b34669e0233a38234c1df9b5bbfed7"}]}