{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ninterface HourglassInterface {\r\n    function() payable external;\r\n    function buy(address _investorAddress) payable external returns(uint256);\r\n    function reinvest() external;\r\n    function exit() payable external;\r\n    function withdraw() payable external;\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function totalEthereumBalance() external;\r\n    function totalSupply() external;\r\n    function myTokens() external returns(uint256);\r\n    function myDividends(bool _includeReferralBonus) external returns (uint256);\r\n    function balanceOf(address _investorAddress) external returns (uint256);\r\n    function dividendsOf(address _investorAddress) external returns (uint256);\r\n    function sellPrice() payable external returns (uint256);\r\n    function buyPrice() external;\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) external;\r\n    function calculateEthereumReceived(uint256 _tokensToSell) external returns(uint256);\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) external;\r\n}\r\n\r\ncontract CryptoMinerFund {\r\n    using ItsJustBasicMathBro\r\n    for uint;\r\n    \r\n    /* Marketing private wallet*/\r\n    address constant _parojectMarketing = 0x3d3B4a38caD44c2B77DAAC1D746124D2e2b8a27C;\r\n    address constant _cmtfContractAddress = 0x0a97094c19295E320D5121d72139A150021a2702;\r\n    /* Interface to main CMT contract */    \r\n    HourglassInterface constant CMTContract = HourglassInterface(_cmtfContractAddress);\r\n    /* Hashtables for functionality */\r\n    mapping(address => uint) public walletDeposits;\r\n    mapping(address => uint) public walletTimer;\r\n    mapping(address => uint) public withdrawedAmounts;\r\n    \r\n    /* % Fee that will be deducted from initial transfer and sent to CMT contract */\r\n    uint constant _masterTaxOnInvestment = 8;\r\n    /* Time modifier for return value incremental increase */\r\n    uint constant payOutInterval = 1 hours;\r\n    /* Percent rates */\r\n    uint constant basePercent = 250;\r\n    uint constant lowPercent = 300;\r\n    uint constant averagePercent = 350;\r\n    uint constant highPercent = 500;\r\n    /* Balance switches for % */\r\n    uint constant phasePreperation = 200 ether;\r\n    uint constant phaseEngineStart = 500 ether;\r\n    uint constant phaseLiftoff = 2000 ether;\r\n    uint constant taxFreeEpoc = 1540321200;\r\n\r\n    /* Fallback that allows to call early exit or with any other value to make a deposit after 1 hour */\r\n    function() external payable {\r\n        if (msg.value > 0) {\r\n            makeDeposit();\r\n        } else {\r\n            requestPayDay();\r\n        }\r\n    }\r\n\r\n    /* Internal function that makes record into walletDeposits for incomming deposit */\r\n    function makeDeposit() internal{\r\n        if (msg.value > 0) {\r\n                /* If user has already deposited we add value to balance & reset timer */\r\n                if(walletDeposits[msg.sender]>0){\r\n                     walletDeposits[msg.sender] += msg.value;\r\n                     walletTimer[msg.sender] = now;\r\n                }\r\n                else{\r\n                     walletDeposits[msg.sender] = walletDeposits[msg.sender].add(msg.value);\r\n                }\r\n              \r\n               walletTimer[msg.sender] = now;\r\n               /* Till 2018. 23. October, Thursday, 22:00:00 is divident free investments */\r\n              if(now > taxFreeEpoc){\r\n                startDivDistribution();\r\n              }\r\n        }\r\n    }\r\n\r\n    /* Calculates if balance > 92% of investment and returns user he's 92% on early exit or all balance if > */\r\n    function requestPayDay() internal{\r\n        uint payDay = 0;\r\n        if(walletDeposits[msg.sender] > getAvailablePayout()){\r\n            if(walletTimer[msg.sender] > taxFreeEpoc){\r\n                payDay = walletDeposits[msg.sender].mul(92).div(100);\r\n            } else{\r\n                payDay = walletDeposits[msg.sender];\r\n            }\r\n            withdrawedAmounts[msg.sender] = 0;\r\n        } else{\r\n            payDay = getAvailablePayout();\r\n            withdrawedAmounts[msg.sender] += payDay;\r\n        }\r\n        walletTimer[msg.sender] = 0;\r\n        walletDeposits[msg.sender] = 0;\r\n        msg.sender.transfer(payDay);\r\n    }\r\n    \r\n    /* Internal function to distribute masterx tax fee into dividends to all CMT holders */\r\n    function startDivDistribution() internal{\r\n            /*#######################################  !  IMPORTANT  !  ##############################################\r\n            ## Here we buy CMT tokens with 8% from deposit and we intentionally use marketing wallet as masternode  ##\r\n            ## that results into 33% from 10% deducted on 8% goes to marketing & server running  purposes by our    ##\r\n            ## team but the rest of 8% is distributet to all holder with selling CMT tokens & then reinvesting      ##\r\n            ## again  (LOGIC FROM CMT) This kindof functionality allows us to decrease the % tax on deposit since   ##\r\n            ## 1% from deposit is much  more than 33% from 8%.                                                      ##\r\n            ########################################################################################################*/\r\n            CMTContract.buy.value(msg.value.mul(_masterTaxOnInvestment).div(100))(_parojectMarketing);\r\n            uint _cmtBalance = getFundCMTBalance();\r\n            CMTContract.sell(_cmtBalance);\r\n            CMTContract.reinvest();\r\n    }\r\n      \r\n    /* Calculates actual value of % earned */\r\n    function getAvailablePayout() public view returns(uint) {\r\n        uint percent = resolvePercentRate();\r\n        uint interestRate = now.sub(walletTimer[msg.sender]).div(payOutInterval);\r\n        uint baseRate = walletDeposits[msg.sender].mul(percent).div(100000);\r\n        uint withdrawAmount = baseRate.mul(interestRate);\r\n        if(withdrawAmount > walletDeposits[msg.sender].mul(2)){\r\n            return walletDeposits[msg.sender].mul(2);\r\n        }\r\n        return (withdrawAmount);\r\n    }\r\n\r\n    /* Resolve percent rate for deposit */\r\n    function resolvePercentRate() public view returns(uint) {\r\n        uint balance = address(this).balance;\r\n        if (balance < phasePreperation) {\r\n            return (basePercent);\r\n        }\r\n        if (balance >= phasePreperation && balance < phaseEngineStart) {\r\n            return (lowPercent);\r\n        }\r\n        if (balance >= phaseEngineStart && balance < phaseLiftoff) {\r\n            return (averagePercent);\r\n        }\r\n        if (balance >= phaseLiftoff) {\r\n            return (highPercent);\r\n        }\r\n    }\r\n\r\n    /* Returns contracts balance on CMT contract */\r\n    function getFundCMTBalance() internal returns (uint256){\r\n        return CMTContract.myTokens();\r\n    }\r\n    \r\n    /* Returns total balance of contract wallet */\r\n    function totalEthereumBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n\r\n}\r\n\r\nlibrary ItsJustBasicMathBro {\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawedAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailablePayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolvePercentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CryptoMinerFund","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b8a3153f613098e562c22250f7ba7441eda132f45e19e8145f4cfa21ce2a659d"}]}