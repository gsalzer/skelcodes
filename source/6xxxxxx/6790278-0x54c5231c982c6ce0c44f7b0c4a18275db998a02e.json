{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeConvert {\r\n\r\n    function toUint8(uint256 _value) internal pure returns (uint8) {\r\n        assert(_value <= 255);\r\n        return uint8(_value);\r\n    }\r\n\r\n    function toUint16(uint256 _value) internal pure returns (uint16) {\r\n        assert(_value <= 2**16 - 1);\r\n        return uint16(_value);\r\n    }\r\n\r\n    function toUint32(uint256 _value) internal pure returns (uint32) {\r\n        assert(_value <= 2**32 - 1);\r\n        return uint32(_value);\r\n    }\r\n}\r\n\r\nlibrary SafeMath8 {\r\n\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint8 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint32 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint32 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract Getter {\r\n    function getDragonTypes(uint256) external view returns (uint8[11]) {}\r\n    function getDragonTactics(uint256) external view returns (uint8, uint8) {}\r\n    function getDragonSkills(uint256) external view returns (uint32, uint32, uint32, uint32, uint32) {}\r\n    function getDragonCurrentHealthAndMana(uint256) external view returns (uint32, uint32, uint8, uint8) {}\r\n    function getDragonMaxHealthAndMana(uint256) external view returns (uint32, uint32) {}\r\n    function getDragonSpecialAttack(uint256) external view returns (uint8, uint32, uint8, uint8) {}\r\n    function getDragonSpecialDefense(uint256) external view returns (uint8, uint32, uint8, uint8) {}\r\n    function getDragonBuffs(uint256) external view returns (uint32[5]) {}\r\n}\r\n\r\n\r\n\r\n\r\n//////////////CONTRACT//////////////\r\n\r\n\r\n\r\n\r\ncontract Battle is Upgradable {\r\n    using SafeMath8 for uint8;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath256 for uint256;\r\n    using SafeConvert for uint256;\r\n\r\n    Getter getter;\r\n\r\n    struct Dragon {\r\n        uint256 id;\r\n        uint8 attackChance;\r\n        uint8 meleeChance;\r\n        uint32 health;\r\n        uint32 mana;\r\n        uint32 speed;\r\n        uint32 attack;\r\n        uint32 defense;\r\n        uint32 specialAttackCost;\r\n        uint8 specialAttackFactor;\r\n        uint8 specialAttackChance;\r\n        uint32 specialDefenseCost;\r\n        uint8 specialDefenseFactor;\r\n        uint8 specialDefenseChance;\r\n        bool blocking;\r\n        bool specialBlocking;\r\n    }\r\n\r\n    uint8 constant __FLOAT_NUMBER_MULTIPLY = 10;\r\n\r\n    // We have to divide each calculations\r\n    // with \"__\" postfix by __FLOAT_NUMBER_MULTIPLY\r\n    uint8 constant DISTANCE_ATTACK_WEAK__ = 8; // 0.8\r\n    uint8 constant DEFENSE_SUCCESS_MULTIPLY__ = 10; // 1\r\n    uint8 constant DEFENSE_FAIL_MULTIPLY__ = 2; // 0.2\r\n    uint8 constant FALLBACK_SPEED_FACTOR__ = 7; // 0.7\r\n\r\n    uint32 constant MAX_MELEE_ATTACK_DISTANCE = 100; // 1, multiplied as skills\r\n    uint32 constant MIN_RANGE_ATTACK_DISTANCE = 300; // 3, multiplied as skills\r\n\r\n    uint8 constant MAX_TURNS = 70;\r\n\r\n    uint8 constant DRAGON_TYPE_FACTOR = 5; // 0.5\r\n\r\n    uint16 constant DRAGON_TYPE_MULTIPLY = 1600;\r\n\r\n    uint8 constant PERCENT_MULTIPLIER = 100;\r\n\r\n\r\n    uint256 battlesCounter;\r\n\r\n    // values in the range of 0..99\r\n    function _getRandomNumber(\r\n        uint256 _initialSeed,\r\n        uint256 _currentSeed_\r\n    ) internal pure returns(uint8, uint256) {\r\n        uint256 _currentSeed = _currentSeed_;\r\n        if (_currentSeed == 0) {\r\n            _currentSeed = _initialSeed;\r\n        }\r\n        uint8 _random = (_currentSeed % 100).toUint8();\r\n        _currentSeed = _currentSeed.div(100);\r\n        return (_random, _currentSeed);\r\n    }\r\n\r\n    function _safeSub(uint32 a, uint32 b) internal pure returns(uint32) {\r\n        return b > a ? 0 : a.sub(b);\r\n    }\r\n\r\n    function _multiplyByFloatNumber(uint32 _number, uint8 _multiplier) internal pure returns (uint32) {\r\n        return _number.mul(_multiplier).div(__FLOAT_NUMBER_MULTIPLY);\r\n    }\r\n\r\n    function _calculatePercentage(uint32 _part, uint32 _full) internal pure returns (uint32) {\r\n        return _part.mul(PERCENT_MULTIPLIER).div(_full);\r\n    }\r\n\r\n    function _calculateDragonTypeMultiply(uint8[11] _attackerTypesArray, uint8[11] _defenderTypesArray) internal pure returns (uint32) {\r\n        uint32 dragonTypeSumMultiply = 0;\r\n        uint8 _currentDefenderType;\r\n        uint32 _dragonTypeMultiply;\r\n\r\n        for (uint8 _attackerType = 0; _attackerType < _attackerTypesArray.length; _attackerType++) {\r\n            if (_attackerTypesArray[_attackerType] != 0) {\r\n                for (uint8 _defenderType = 0; _defenderType < _defenderTypesArray.length; _defenderType++) {\r\n                    if (_defenderTypesArray[_defenderType] != 0) {\r\n                        _currentDefenderType = _defenderType;\r\n\r\n                        if (_currentDefenderType < _attackerType) {\r\n                            _currentDefenderType = _currentDefenderType.add(_defenderTypesArray.length.toUint8());\r\n                        }\r\n\r\n                        if (_currentDefenderType.add(_attackerType).add(1) % 2 == 0) {\r\n                            _dragonTypeMultiply = _attackerTypesArray[_attackerType];\r\n                            _dragonTypeMultiply = _dragonTypeMultiply.mul(_defenderTypesArray[_defenderType]);\r\n                            dragonTypeSumMultiply = dragonTypeSumMultiply.add(_dragonTypeMultiply);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return _multiplyByFloatNumber(dragonTypeSumMultiply, DRAGON_TYPE_FACTOR).add(DRAGON_TYPE_MULTIPLY);\r\n    }\r\n\r\n    function _initBaseDragon(\r\n        uint256 _id,\r\n        uint256 _opponentId,\r\n        uint8 _meleeChance,\r\n        uint8 _attackChance,\r\n        bool _isGladiator\r\n    ) internal view returns (Dragon) {\r\n        uint32 _health;\r\n        uint32 _mana;\r\n        if (_isGladiator) {\r\n            (_health, _mana) = getter.getDragonMaxHealthAndMana(_id);\r\n        } else {\r\n            (_health, _mana, , ) = getter.getDragonCurrentHealthAndMana(_id);\r\n        }\r\n\r\n        if (_meleeChance == 0 || _attackChance == 0) {\r\n            (_meleeChance, _attackChance) = getter.getDragonTactics(_id);\r\n        }\r\n        uint8[11] memory _attackerTypes = getter.getDragonTypes(_id);\r\n        uint8[11] memory _opponentTypes = getter.getDragonTypes(_opponentId);\r\n        uint32 _attack;\r\n        uint32 _defense;\r\n        uint32 _speed;\r\n        (_attack, _defense, , _speed, ) = getter.getDragonSkills(_id);\r\n\r\n        return Dragon({\r\n            id: _id,\r\n            attackChance: _attackChance,\r\n            meleeChance: _meleeChance,\r\n            health: _health,\r\n            mana: _mana,\r\n            speed: _speed,\r\n            attack: _attack.mul(_calculateDragonTypeMultiply(_attackerTypes, _opponentTypes)).div(DRAGON_TYPE_MULTIPLY),\r\n            defense: _defense,\r\n            specialAttackCost: 0,\r\n            specialAttackFactor: 0,\r\n            specialAttackChance: 0,\r\n            specialDefenseCost: 0,\r\n            specialDefenseFactor: 0,\r\n            specialDefenseChance: 0,\r\n            blocking: false,\r\n            specialBlocking: false\r\n        });\r\n    }\r\n\r\n    function _initDragon(\r\n        uint256 _id,\r\n        uint256 _opponentId,\r\n        uint8[2] _tactics,\r\n        bool _isGladiator\r\n    ) internal view returns (Dragon dragon) {\r\n        dragon = _initBaseDragon(_id, _opponentId, _tactics[0], _tactics[1], _isGladiator);\r\n\r\n        uint32 _specialAttackCost;\r\n        uint8 _specialAttackFactor;\r\n        uint8 _specialAttackChance;\r\n        uint32 _specialDefenseCost;\r\n        uint8 _specialDefenseFactor;\r\n        uint8 _specialDefenseChance;\r\n\r\n        ( , _specialAttackCost, _specialAttackFactor, _specialAttackChance) = getter.getDragonSpecialAttack(_id);\r\n        ( , _specialDefenseCost, _specialDefenseFactor, _specialDefenseChance) = getter.getDragonSpecialDefense(_id);\r\n\r\n        dragon.specialAttackCost = _specialAttackCost;\r\n        dragon.specialAttackFactor = _specialAttackFactor;\r\n        dragon.specialAttackChance = _specialAttackChance;\r\n        dragon.specialDefenseCost = _specialDefenseCost;\r\n        dragon.specialDefenseFactor = _specialDefenseFactor;\r\n        dragon.specialDefenseChance = _specialDefenseChance;\r\n\r\n        uint32[5] memory _buffs = getter.getDragonBuffs(_id);\r\n\r\n        if (_buffs[0] > 0) {\r\n            dragon.attack = dragon.attack.mul(_buffs[0]).div(100);\r\n        }\r\n        if (_buffs[1] > 0) {\r\n            dragon.defense = dragon.defense.mul(_buffs[1]).div(100);\r\n        }\r\n        if (_buffs[3] > 0) {\r\n            dragon.speed = dragon.speed.mul(_buffs[3]).div(100);\r\n        }\r\n    }\r\n\r\n    function _resetBlocking(Dragon dragon) internal pure returns (Dragon) {\r\n        dragon.blocking = false;\r\n        dragon.specialBlocking = false;\r\n\r\n        return dragon;\r\n    }\r\n\r\n    function _attack(\r\n        uint8 turnId,\r\n        bool isMelee,\r\n        Dragon attacker,\r\n        Dragon opponent,\r\n        uint8 _random\r\n    ) internal pure returns (\r\n        Dragon,\r\n        Dragon\r\n    ) {\r\n\r\n        uint8 _turnModificator = 10; // multiplied by 10\r\n        if (turnId > 30) {\r\n            uint256 _modif = uint256(turnId).sub(30);\r\n            _modif = _modif.mul(50);\r\n            _modif = _modif.div(40);\r\n            _modif = _modif.add(10);\r\n            _turnModificator = _modif.toUint8();\r\n        }\r\n\r\n        bool isSpecial = _random < _multiplyByFloatNumber(attacker.specialAttackChance, _turnModificator);\r\n\r\n        uint32 damage = _multiplyByFloatNumber(attacker.attack, _turnModificator);\r\n\r\n        if (isSpecial && attacker.mana >= attacker.specialAttackCost) {\r\n            attacker.mana = attacker.mana.sub(attacker.specialAttackCost);\r\n            damage = _multiplyByFloatNumber(damage, attacker.specialAttackFactor);\r\n        }\r\n\r\n        if (!isMelee) {\r\n            damage = _multiplyByFloatNumber(damage, DISTANCE_ATTACK_WEAK__);\r\n        }\r\n\r\n        uint32 defense = opponent.defense;\r\n\r\n        if (opponent.blocking) {\r\n            defense = _multiplyByFloatNumber(defense, DEFENSE_SUCCESS_MULTIPLY__);\r\n\r\n            if (opponent.specialBlocking) {\r\n                defense = _multiplyByFloatNumber(defense, opponent.specialDefenseFactor);\r\n            }\r\n        } else {\r\n            defense = _multiplyByFloatNumber(defense, DEFENSE_FAIL_MULTIPLY__);\r\n        }\r\n\r\n        if (damage > defense) {\r\n            opponent.health = _safeSub(opponent.health, damage.sub(defense));\r\n        } else if (isMelee) {\r\n            attacker.health = _safeSub(attacker.health, defense.sub(damage));\r\n        }\r\n\r\n        return (attacker, opponent);\r\n    }\r\n\r\n    function _defense(\r\n        Dragon attacker,\r\n        uint256 initialSeed,\r\n        uint256 currentSeed\r\n    ) internal pure returns (\r\n        Dragon,\r\n        uint256\r\n    ) {\r\n        uint8 specialRandom;\r\n\r\n        (specialRandom, currentSeed) = _getRandomNumber(initialSeed, currentSeed);\r\n        bool isSpecial = specialRandom < attacker.specialDefenseChance;\r\n\r\n        if (isSpecial && attacker.mana >= attacker.specialDefenseCost) {\r\n            attacker.mana = attacker.mana.sub(attacker.specialDefenseCost);\r\n            attacker.specialBlocking = true;\r\n        }\r\n        attacker.blocking = true;\r\n\r\n        return (attacker, currentSeed);\r\n    }\r\n\r\n    function _turn(\r\n        uint8 turnId,\r\n        uint256 initialSeed,\r\n        uint256 currentSeed,\r\n        uint32 distance,\r\n        Dragon currentDragon,\r\n        Dragon currentEnemy\r\n    ) internal view returns (\r\n        Dragon winner,\r\n        Dragon looser\r\n    ) {\r\n        uint8 rand;\r\n\r\n        (rand, currentSeed) = _getRandomNumber(initialSeed, currentSeed);\r\n        bool isAttack = rand < currentDragon.attackChance;\r\n\r\n        if (isAttack) {\r\n            (rand, currentSeed) = _getRandomNumber(initialSeed, currentSeed);\r\n            bool isMelee = rand < currentDragon.meleeChance;\r\n\r\n            if (isMelee && distance > MAX_MELEE_ATTACK_DISTANCE) {\r\n                distance = _safeSub(distance, currentDragon.speed);\r\n            } else if (!isMelee && distance < MIN_RANGE_ATTACK_DISTANCE) {\r\n                distance = distance.add(_multiplyByFloatNumber(currentDragon.speed, FALLBACK_SPEED_FACTOR__));\r\n            } else {\r\n                (rand, currentSeed) = _getRandomNumber(initialSeed, currentSeed);\r\n                (currentDragon, currentEnemy) = _attack(turnId, isMelee, currentDragon, currentEnemy, rand);\r\n            }\r\n        } else {\r\n            (currentDragon, currentSeed) = _defense(currentDragon, initialSeed, currentSeed);\r\n        }\r\n\r\n        currentEnemy = _resetBlocking(currentEnemy);\r\n\r\n        if (currentDragon.health == 0) {\r\n            return (currentEnemy, currentDragon);\r\n        } else if (currentEnemy.health == 0) {\r\n            return (currentDragon, currentEnemy);\r\n        } else if (turnId < MAX_TURNS) {\r\n            return _turn(turnId.add(1), initialSeed, currentSeed, distance, currentEnemy, currentDragon);\r\n        } else {\r\n            uint32 _dragonMaxHealth;\r\n            uint32 _enemyMaxHealth;\r\n            (_dragonMaxHealth, ) = getter.getDragonMaxHealthAndMana(currentDragon.id);\r\n            (_enemyMaxHealth, ) = getter.getDragonMaxHealthAndMana(currentEnemy.id);\r\n            if (_calculatePercentage(currentDragon.health, _dragonMaxHealth) >= _calculatePercentage(currentEnemy.health, _enemyMaxHealth)) {\r\n                return (currentDragon, currentEnemy);\r\n            } else {\r\n                return (currentEnemy, currentDragon);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _start(\r\n        uint256 _firstDragonId,\r\n        uint256 _secondDragonId,\r\n        uint8[2] _firstTactics,\r\n        uint8[2] _secondTactics,\r\n        uint256 _seed,\r\n        bool _isGladiator\r\n    ) internal view returns (\r\n        uint256[2],\r\n        uint32,\r\n        uint32,\r\n        uint32,\r\n        uint32\r\n    ) {\r\n        Dragon memory _firstDragon = _initDragon(_firstDragonId, _secondDragonId, _firstTactics, _isGladiator);\r\n        Dragon memory _secondDragon = _initDragon(_secondDragonId, _firstDragonId, _secondTactics, _isGladiator);\r\n\r\n        if (_firstDragon.speed >= _secondDragon.speed) {\r\n            (_firstDragon, _secondDragon) = _turn(1, _seed, _seed, MAX_MELEE_ATTACK_DISTANCE, _firstDragon, _secondDragon);\r\n        } else {\r\n            (_firstDragon, _secondDragon) = _turn(1, _seed, _seed, MAX_MELEE_ATTACK_DISTANCE, _secondDragon, _firstDragon);\r\n        }\r\n\r\n        return (\r\n            [_firstDragon.id,  _secondDragon.id],\r\n            _firstDragon.health,\r\n            _firstDragon.mana,\r\n            _secondDragon.health,\r\n            _secondDragon.mana\r\n        );\r\n    }\r\n\r\n    function start(\r\n        uint256 _firstDragonId,\r\n        uint256 _secondDragonId,\r\n        uint8[2] _tactics,\r\n        uint8[2] _tactics2,\r\n        uint256 _seed,\r\n        bool _isGladiator\r\n    ) external onlyController returns (\r\n        uint256[2] winnerLooserIds,\r\n        uint32 winnerHealth,\r\n        uint32 winnerMana,\r\n        uint32 looserHealth,\r\n        uint32 looserMana,\r\n        uint256 battleId\r\n    ) {\r\n\r\n        (\r\n            winnerLooserIds,\r\n            winnerHealth,\r\n            winnerMana,\r\n            looserHealth,\r\n            looserMana\r\n        ) = _start(\r\n            _firstDragonId,\r\n            _secondDragonId,\r\n            _tactics,\r\n            _tactics2,\r\n            _seed,\r\n            _isGladiator\r\n        );\r\n\r\n        battleId = battlesCounter;\r\n        battlesCounter = battlesCounter.add(1);\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        super.setInternalDependencies(_newDependencies);\r\n\r\n        getter = Getter(_newDependencies[0]);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_firstDragonId\",\"type\":\"uint256\"},{\"name\":\"_secondDragonId\",\"type\":\"uint256\"},{\"name\":\"_tactics\",\"type\":\"uint8[2]\"},{\"name\":\"_tactics2\",\"type\":\"uint8[2]\"},{\"name\":\"_seed\",\"type\":\"uint256\"},{\"name\":\"_isGladiator\",\"type\":\"bool\"}],\"name\":\"start\",\"outputs\":[{\"name\":\"winnerLooserIds\",\"type\":\"uint256[2]\"},{\"name\":\"winnerHealth\",\"type\":\"uint32\"},{\"name\":\"winnerMana\",\"type\":\"uint32\"},{\"name\":\"looserHealth\",\"type\":\"uint32\"},{\"name\":\"looserMana\",\"type\":\"uint32\"},{\"name\":\"battleId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Battle","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7abeebd07bf816dfd4ce2ec667b69601f0927fb8711d08d88694ff31aef27ed2"}]}