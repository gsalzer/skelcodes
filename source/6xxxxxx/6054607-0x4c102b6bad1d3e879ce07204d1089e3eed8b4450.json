{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n//Slightly modified SafeMath library - includes a min function\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n//Swap factory functions - descriptions can be found in Factory.sol\r\ninterface Factory_Interface {\r\n  function createToken(uint _supply, address _party, uint _start_date) external returns (address,address, uint);\r\n  function payToken(address _party, address _token_add) external;\r\n  function deployContract(uint _start_date) external payable returns (address);\r\n   function getBase() external view returns(address);\r\n  function getVariables() external view returns (address, uint, uint, address,uint);\r\n  function isWhitelisted(address _member) external view returns (bool);\r\n}\r\n\r\n/**\r\n*The DRCTLibrary contains the reference code used in the DRCT_Token (an ERC20 compliant token\r\n*representing the payout of the swap contract specified in the Factory contract).\r\n*/\r\nlibrary DRCTLibrary{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /*Structs*/\r\n    /**\r\n    *@dev Keeps track of balance amounts in the balances array\r\n    */\r\n    struct Balance {\r\n        address owner;\r\n        uint amount;\r\n        }\r\n\r\n    struct TokenStorage{\r\n        //This is the factory contract that the token is standardized at\r\n        address factory_contract;\r\n        //Total supply of outstanding tokens in the contract\r\n        uint total_supply;\r\n        //Mapping from: swap address -> user balance struct (index for a particular user's balance can be found in swap_balances_index)\r\n        mapping(address => Balance[]) swap_balances;\r\n        //Mapping from: swap address -> user -> swap_balances index\r\n        mapping(address => mapping(address => uint)) swap_balances_index;\r\n        //Mapping from: user -> dynamic array of swap addresses (index for a particular swap can be found in user_swaps_index)\r\n        mapping(address => address[]) user_swaps;\r\n        //Mapping from: user -> swap address -> user_swaps index\r\n        mapping(address => mapping(address => uint)) user_swaps_index;\r\n        //Mapping from: user -> total balance accross all entered swaps\r\n        mapping(address => uint) user_total_balances;\r\n        //Mapping from: owner -> spender -> amount allowed\r\n        mapping(address => mapping(address => uint)) allowed;\r\n    }   \r\n\r\n    /*Events*/\r\n    /**\r\n    *@dev events for transfer and approvals\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event CreateToken(address _from, uint _value);\r\n    \r\n    /*Functions*/\r\n    /**\r\n    *@dev Constructor - sets values for token name and token supply, as well as the \r\n    *factory_contract, the swap.\r\n    *@param _factory \r\n    */\r\n    function startToken(TokenStorage storage self,address _factory) public {\r\n        self.factory_contract = _factory;\r\n    }\r\n\r\n    /**\r\n    *@dev ensures the member is whitelisted\r\n    *@param _member is the member address that is chekced agaist the whitelist\r\n    */\r\n    function isWhitelisted(TokenStorage storage self,address _member) internal view returns(bool){\r\n        Factory_Interface _factory = Factory_Interface(self.factory_contract);\r\n        return _factory.isWhitelisted(_member);\r\n    }\r\n\r\n    /**\r\n    *@dev gets the factory address\r\n    */\r\n    function getFactoryAddress(TokenStorage storage self) external view returns(address){\r\n        return self.factory_contract;\r\n    }\r\n\r\n    /**\r\n    *@dev Token Creator - This function is called by the factory contract and creates new tokens\r\n    *for the user\r\n    *@param _supply amount of DRCT tokens created by the factory contract for this swap\r\n    *@param _owner address\r\n    *@param _swap address\r\n    */\r\n    function createToken(TokenStorage storage self,uint _supply, address _owner, address _swap) public{\r\n        require(msg.sender == self.factory_contract);\r\n        //Update total supply of DRCT Tokens\r\n        self.total_supply = self.total_supply.add(_supply);\r\n        //Update the total balance of the owner\r\n        self.user_total_balances[_owner] = self.user_total_balances[_owner].add(_supply);\r\n        //If the user has not entered any swaps already, push a zeroed address to their user_swaps mapping to prevent default value conflicts in user_swaps_index\r\n        if (self.user_swaps[_owner].length == 0)\r\n            self.user_swaps[_owner].push(address(0x0));\r\n        //Add a new swap index for the owner\r\n        self.user_swaps_index[_owner][_swap] = self.user_swaps[_owner].length;\r\n        //Push a new swap address to the owner's swaps\r\n        self.user_swaps[_owner].push(_swap);\r\n        //Push a zeroed Balance struct to the swap balances mapping to prevent default value conflicts in swap_balances_index\r\n        self.swap_balances[_swap].push(Balance({\r\n            owner: 0,\r\n            amount: 0\r\n        }));\r\n        //Add a new owner balance index for the swap\r\n        self.swap_balances_index[_swap][_owner] = 1;\r\n        //Push the owner's balance to the swap\r\n        self.swap_balances[_swap].push(Balance({\r\n            owner: _owner,\r\n            amount: _supply\r\n        }));\r\n        emit CreateToken(_owner,_supply);\r\n    }\r\n\r\n    /**\r\n    *@dev Called by the factory contract, and pays out to a _party\r\n    *@param _party being paid\r\n    *@param _swap address\r\n    */\r\n    function pay(TokenStorage storage self,address _party, address _swap) public{\r\n        require(msg.sender == self.factory_contract);\r\n        uint party_balance_index = self.swap_balances_index[_swap][_party];\r\n        require(party_balance_index > 0);\r\n        uint party_swap_balance = self.swap_balances[_swap][party_balance_index].amount;\r\n        //reduces the users totals balance by the amount in that swap\r\n        self.user_total_balances[_party] = self.user_total_balances[_party].sub(party_swap_balance);\r\n        //reduces the total supply by the amount of that users in that swap\r\n        self.total_supply = self.total_supply.sub(party_swap_balance);\r\n        //sets the partys balance to zero for that specific swaps party balances\r\n        self.swap_balances[_swap][party_balance_index].amount = 0;\r\n    }\r\n\r\n    /**\r\n    *@dev Returns the users total balance (sum of tokens in all swaps the user has tokens in)\r\n    *@param _owner user address\r\n    *@return user total balance\r\n    */\r\n    function balanceOf(TokenStorage storage self,address _owner) public constant returns (uint balance) {\r\n       return self.user_total_balances[_owner]; \r\n     }\r\n\r\n    /**\r\n    *@dev Getter for the total_supply of tokens in the contract\r\n    *@return total supply\r\n    */\r\n    function totalSupply(TokenStorage storage self) public constant returns (uint _total_supply) {\r\n       return self.total_supply;\r\n    }\r\n\r\n    /**\r\n    *@dev Removes the address from the swap balances for a swap, and moves the last address in the\r\n    *swap into their place\r\n    *@param _remove address of prevous owner\r\n    *@param _swap address used to get last addrss of the swap to replace the removed address\r\n    */\r\n    function removeFromSwapBalances(TokenStorage storage self,address _remove, address _swap) internal {\r\n        uint last_address_index = self.swap_balances[_swap].length.sub(1);\r\n        address last_address = self.swap_balances[_swap][last_address_index].owner;\r\n        //If the address we want to remove is the final address in the swap\r\n        if (last_address != _remove) {\r\n            uint remove_index = self.swap_balances_index[_swap][_remove];\r\n            //Update the swap's balance index of the last address to that of the removed address index\r\n            self.swap_balances_index[_swap][last_address] = remove_index;\r\n            //Set the swap's Balance struct at the removed index to the Balance struct of the last address\r\n            self.swap_balances[_swap][remove_index] = self.swap_balances[_swap][last_address_index];\r\n        }\r\n        //Remove the swap_balances index for this address\r\n        delete self.swap_balances_index[_swap][_remove];\r\n        //Finally, decrement the swap balances length\r\n        self.swap_balances[_swap].length = self.swap_balances[_swap].length.sub(1);\r\n    }\r\n\r\n    /**\r\n    *@dev This is the main function to update the mappings when a transfer happens\r\n    *@param _from address to send funds from\r\n    *@param _to address to send funds to\r\n    *@param _amount amount of token to send\r\n    */\r\n    function transferHelper(TokenStorage storage self,address _from, address _to, uint _amount) internal {\r\n        //Get memory copies of the swap arrays for the sender and reciever\r\n        address[] memory from_swaps = self.user_swaps[_from];\r\n        //Iterate over sender's swaps in reverse order until enough tokens have been transferred\r\n        for (uint i = from_swaps.length.sub(1); i > 0; i--) {\r\n            //Get the index of the sender's balance for the current swap\r\n            uint from_swap_user_index = self.swap_balances_index[from_swaps[i]][_from];\r\n            Balance memory from_user_bal = self.swap_balances[from_swaps[i]][from_swap_user_index];\r\n            //If the current swap will be entirely depleted - we remove all references to it for the sender\r\n            if (_amount >= from_user_bal.amount) {\r\n                _amount -= from_user_bal.amount;\r\n                //If this swap is to be removed, we know it is the (current) last swap in the user's user_swaps list, so we can simply decrement the length to remove it\r\n                self.user_swaps[_from].length = self.user_swaps[_from].length.sub(1);\r\n                //Remove the user swap index for this swap\r\n                delete self.user_swaps_index[_from][from_swaps[i]];\r\n                //If the _to address already holds tokens from this swap\r\n                if (self.user_swaps_index[_to][from_swaps[i]] != 0) {\r\n                    //Get the index of the _to balance in this swap\r\n                    uint to_balance_index = self.swap_balances_index[from_swaps[i]][_to];\r\n                    assert(to_balance_index != 0);\r\n                    //Add the _from tokens to _to\r\n                    self.swap_balances[from_swaps[i]][to_balance_index].amount = self.swap_balances[from_swaps[i]][to_balance_index].amount.add(from_user_bal.amount);\r\n                    //Remove the _from address from this swap's balance array\r\n                    removeFromSwapBalances(self,_from, from_swaps[i]);\r\n                } else {\r\n                    //Prepare to add a new swap by assigning the swap an index for _to\r\n                    if (self.user_swaps[_to].length == 0){\r\n                        self.user_swaps[_to].push(address(0x0));\r\n                    }\r\n                self.user_swaps_index[_to][from_swaps[i]] = self.user_swaps[_to].length;\r\n                //Add the new swap to _to\r\n                self.user_swaps[_to].push(from_swaps[i]);\r\n                //Give the reciever the sender's balance for this swap\r\n                self.swap_balances[from_swaps[i]][from_swap_user_index].owner = _to;\r\n                //Give the reciever the sender's swap balance index for this swap\r\n                self.swap_balances_index[from_swaps[i]][_to] = self.swap_balances_index[from_swaps[i]][_from];\r\n                //Remove the swap balance index from the sending party\r\n                delete self.swap_balances_index[from_swaps[i]][_from];\r\n            }\r\n            //If there is no more remaining to be removed, we break out of the loop\r\n            if (_amount == 0)\r\n                break;\r\n            } else {\r\n                //The amount in this swap is more than the amount we still need to transfer\r\n                uint to_swap_balance_index = self.swap_balances_index[from_swaps[i]][_to];\r\n                //If the _to address already holds tokens from this swap\r\n                if (self.user_swaps_index[_to][from_swaps[i]] != 0) {\r\n                    //Because both addresses are in this swap, and neither will be removed, we simply update both swap balances\r\n                    self.swap_balances[from_swaps[i]][to_swap_balance_index].amount = self.swap_balances[from_swaps[i]][to_swap_balance_index].amount.add(_amount);\r\n                } else {\r\n                    //Prepare to add a new swap by assigning the swap an index for _to\r\n                    if (self.user_swaps[_to].length == 0){\r\n                        self.user_swaps[_to].push(address(0x0));\r\n                    }\r\n                    self.user_swaps_index[_to][from_swaps[i]] = self.user_swaps[_to].length;\r\n                    //And push the new swap\r\n                    self.user_swaps[_to].push(from_swaps[i]);\r\n                    //_to is not in this swap, so we give this swap a new balance index for _to\r\n                    self.swap_balances_index[from_swaps[i]][_to] = self.swap_balances[from_swaps[i]].length;\r\n                    //And push a new balance for _to\r\n                    self.swap_balances[from_swaps[i]].push(Balance({\r\n                        owner: _to,\r\n                        amount: _amount\r\n                    }));\r\n                }\r\n                //Finally, update the _from user's swap balance\r\n                self.swap_balances[from_swaps[i]][from_swap_user_index].amount = self.swap_balances[from_swaps[i]][from_swap_user_index].amount.sub(_amount);\r\n                //Because we have transferred the last of the amount to the reciever, we break;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *@dev ERC20 compliant transfer function\r\n    *@param _to Address to send funds to\r\n    *@param _amount Amount of token to send\r\n    *@return true for successful\r\n    */\r\n    function transfer(TokenStorage storage self, address _to, uint _amount) public returns (bool) {\r\n        require(isWhitelisted(self,_to));\r\n        uint balance_owner = self.user_total_balances[msg.sender];\r\n        if (\r\n            _to == msg.sender ||\r\n            _to == address(0) ||\r\n            _amount == 0 ||\r\n            balance_owner < _amount\r\n        ) return false;\r\n        transferHelper(self,msg.sender, _to, _amount);\r\n        self.user_total_balances[msg.sender] = self.user_total_balances[msg.sender].sub(_amount);\r\n        self.user_total_balances[_to] = self.user_total_balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n    /**\r\n    *@dev ERC20 compliant transferFrom function\r\n    *@param _from address to send funds from (must be allowed, see approve function)\r\n    *@param _to address to send funds to\r\n    *@param _amount amount of token to send\r\n    *@return true for successful\r\n    */\r\n    function transferFrom(TokenStorage storage self, address _from, address _to, uint _amount) public returns (bool) {\r\n        require(isWhitelisted(self,_to));\r\n        uint balance_owner = self.user_total_balances[_from];\r\n        uint sender_allowed = self.allowed[_from][msg.sender];\r\n        if (\r\n            _to == _from ||\r\n            _to == address(0) ||\r\n            _amount == 0 ||\r\n            balance_owner < _amount ||\r\n            sender_allowed < _amount\r\n        ) return false;\r\n        transferHelper(self,_from, _to, _amount);\r\n        self.user_total_balances[_from] = self.user_total_balances[_from].sub(_amount);\r\n        self.user_total_balances[_to] = self.user_total_balances[_to].add(_amount);\r\n        self.allowed[_from][msg.sender] = self.allowed[_from][msg.sender].sub(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *@dev ERC20 compliant approve function\r\n    *@param _spender party that msg.sender approves for transferring funds\r\n    *@param _amount amount of token to approve for sending\r\n    *@return true for successful\r\n    */\r\n    function approve(TokenStorage storage self, address _spender, uint _amount) public returns (bool) {\r\n        self.allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *@dev Counts addresses involved in the swap based on the length of balances array for _swap\r\n    *@param _swap address\r\n    *@return the length of the balances array for the swap\r\n    */\r\n    function addressCount(TokenStorage storage self, address _swap) public constant returns (uint) { \r\n        return self.swap_balances[_swap].length; \r\n    }\r\n\r\n    /**\r\n    *@dev Gets the owner address and amount by specifying the swap address and index\r\n    *@param _ind specified index in the swap\r\n    *@param _swap specified swap address\r\n    *@return the owner address associated with a particular index in a particular swap\r\n    *@return the amount to transfer associated with a particular index in a particular swap\r\n    */\r\n    function getBalanceAndHolderByIndex(TokenStorage storage self, uint _ind, address _swap) public constant returns (uint, address) {\r\n        return (self.swap_balances[_swap][_ind].amount, self.swap_balances[_swap][_ind].owner);\r\n    }\r\n\r\n    /**\r\n    *@dev Gets the index by specifying the swap and owner addresses\r\n    *@param _owner specifed address\r\n    *@param _swap  specified swap address\r\n    *@return the index associated with the _owner address in a particular swap\r\n    */\r\n    function getIndexByAddress(TokenStorage storage self, address _owner, address _swap) public constant returns (uint) {\r\n        return self.swap_balances_index[_swap][_owner]; \r\n    }\r\n\r\n    /**\r\n    *@dev Look up how much the spender or contract is allowed to spend?\r\n    *@param _owner \r\n    *@param _spender party approved for transfering funds \r\n    *@return the allowed amount _spender can spend of _owner's balance\r\n    */\r\n    function allowance(TokenStorage storage self, address _owner, address _spender) public constant returns (uint) {\r\n        return self.allowed[_owner][_spender]; \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_swap\",\"type\":\"address\"}],\"name\":\"createToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_swap\",\"type\":\"address\"}],\"name\":\"addressCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_ind\",\"type\":\"uint256\"},{\"name\":\"_swap\",\"type\":\"address\"}],\"name\":\"getBalanceAndHolderByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_party\",\"type\":\"address\"},{\"name\":\"_swap\",\"type\":\"address\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"}],\"name\":\"getFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"startToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_swap\",\"type\":\"address\"}],\"name\":\"getIndexByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"}],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_total_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"DRCTLibrary.TokenStorage storage\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateToken\",\"type\":\"event\"}]","ContractName":"DRCTLibrary","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cd85a2dabf4d7f6a0afa7adfbb26c81c329af59ae5e20d160b634594b9e1e527"}]}