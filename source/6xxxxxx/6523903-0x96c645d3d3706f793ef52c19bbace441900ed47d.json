{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * MPSToken.sol\r\n * MPS Token (Mt Pelerin Share)\r\n\r\n * More info about MPS : https://github.com/MtPelerin/MtPelerin-share-MPS\r\n\r\n * The unflattened code is available through this github tag:\r\n * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1\r\n\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n\r\n * @notice All matters regarding the intellectual property of this code \r\n * @notice or software are subject to Swiss Law without reference to its \r\n * @notice conflicts of law rules.\r\n\r\n * @notice License for each contract is available in the respective file\r\n * @notice or in the LICENSE.md file.\r\n * @notice https://github.com/MtPelerin/\r\n\r\n * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:\r\n * @notice https://github.com/OpenZeppelin/openzeppelin-solidity\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interface/ISeizable.sol\r\n\r\n/**\r\n * @title ISeizable\r\n * @dev ISeizable interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract ISeizable {\r\n  function seize(address _account, uint256 _value) public;\r\n  event Seize(address account, uint256 amount);\r\n}\r\n\r\n// File: contracts/zeppelin/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/Authority.sol\r\n\r\n/**\r\n * @title Authority\r\n * @dev The Authority contract has an authority address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * Authority means to represent a legal entity that is entitled to specific rights\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * AU01: Message sender must be an authority\r\n */\r\ncontract Authority is Ownable {\r\n\r\n  address authority;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the authority.\r\n   */\r\n  modifier onlyAuthority {\r\n    require(msg.sender == authority, \"AU01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev return the address associated to the authority\r\n   */\r\n  function authorityAddress() public view returns (address) {\r\n    return authority;\r\n  }\r\n\r\n  /**\r\n   * @dev rdefines an authority\r\n   * @param _name the authority name\r\n   * @param _address the authority address.\r\n   */\r\n  function defineAuthority(string _name, address _address) public onlyOwner {\r\n    emit AuthorityDefined(_name, _address);\r\n    authority = _address;\r\n  }\r\n\r\n  event AuthorityDefined(\r\n    string name,\r\n    address _address\r\n  );\r\n}\r\n\r\n// File: contracts/token/component/SeizableToken.sol\r\n\r\n/**\r\n * @title SeizableToken\r\n * @dev BasicToken contract which allows owner to seize accounts\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * ST01: Owner cannot seize itself\r\n*/\r\ncontract SeizableToken is BasicToken, Authority, ISeizable {\r\n  using SafeMath for uint256;\r\n\r\n  // Although very unlikely, the value below may overflow.\r\n  // This contract and its children should expect it to happened and consider\r\n  // this value as only the first 256 bits of the complete value.\r\n  uint256 public allTimeSeized = 0; // overflow may happend\r\n\r\n  /**\r\n   * @dev called by the owner to seize value from the account\r\n   */\r\n  function seize(address _account, uint256 _value)\r\n    public onlyAuthority\r\n  {\r\n    require(_account != owner, \"ST01\");\r\n\r\n    balances[_account] = balances[_account].sub(_value);\r\n    balances[authority] = balances[authority].add(_value);\r\n\r\n    allTimeSeized += _value;\r\n    emit Seize(_account, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interface/IProvableOwnership.sol\r\n\r\n/**\r\n * @title IProvableOwnership\r\n * @dev IProvableOwnership interface which describe proof of ownership.\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IProvableOwnership {\r\n  function proofLength(address _holder) public view returns (uint256);\r\n  function proofAmount(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function proofDateFrom(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function proofDateTo(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function createProof(address _holder) public;\r\n  function checkProof(address _holder, uint256 _proofId, uint256 _at)\r\n    public view returns (uint256);\r\n\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n    ) public returns (bool);\r\n\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n    ) public returns (bool);\r\n\r\n  event ProofOfOwnership(address indexed holder, uint256 proofId);\r\n}\r\n\r\n// File: contracts/interface/IAuditableToken.sol\r\n\r\n/**\r\n * @title IAuditableToken\r\n * @dev IAuditableToken interface describing the audited data\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IAuditableToken {\r\n  function lastTransactionAt(address _address) public view returns (uint256);\r\n  function lastReceivedAt(address _address) public view returns (uint256);\r\n  function lastSentAt(address _address) public view returns (uint256);\r\n  function transactionCount(address _address) public view returns (uint256);\r\n  function receivedCount(address _address) public view returns (uint256);\r\n  function sentCount(address _address) public view returns (uint256);\r\n  function totalReceivedAmount(address _address) public view returns (uint256);\r\n  function totalSentAmount(address _address) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/token/component/AuditableToken.sol\r\n\r\n/**\r\n * @title AuditableToken\r\n * @dev AuditableToken contract\r\n * AuditableToken provides transaction data which can be used\r\n * in other smart contracts\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract AuditableToken is IAuditableToken, StandardToken {\r\n\r\n   // Although very unlikely, the following values below may overflow:\r\n   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount\r\n   // This contract and its children should expect it to happen and consider\r\n   // these values as only the first 256 bits of the complete value.\r\n  struct Audit {\r\n    uint256 createdAt;\r\n    uint256 lastReceivedAt;\r\n    uint256 lastSentAt;\r\n    uint256 receivedCount; // potential overflow\r\n    uint256 sentCount; // poential overflow\r\n    uint256 totalReceivedAmount; // potential overflow\r\n    uint256 totalSentAmount; // potential overflow\r\n  }\r\n  mapping(address => Audit) internal audits;\r\n\r\n  /**\r\n   * @dev Time of the creation of the audit struct\r\n   */\r\n  function auditCreatedAt(address _address) public view returns (uint256) {\r\n    return audits[_address].createdAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last transaction\r\n   */\r\n  function lastTransactionAt(address _address) public view returns (uint256) {\r\n    return ( audits[_address].lastReceivedAt > audits[_address].lastSentAt ) ?\r\n      audits[_address].lastReceivedAt : audits[_address].lastSentAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last received transaction\r\n   */\r\n  function lastReceivedAt(address _address) public view returns (uint256) {\r\n    return audits[_address].lastReceivedAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last sent transaction\r\n   */\r\n  function lastSentAt(address _address) public view returns (uint256) {\r\n    return audits[_address].lastSentAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of transactions\r\n   */\r\n  function transactionCount(address _address) public view returns (uint256) {\r\n    return audits[_address].receivedCount + audits[_address].sentCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of received transactions\r\n   */\r\n  function receivedCount(address _address) public view returns (uint256) {\r\n    return audits[_address].receivedCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of sent transactions\r\n   */\r\n  function sentCount(address _address) public view returns (uint256) {\r\n    return audits[_address].sentCount;\r\n  }\r\n\r\n  /**\r\n   * @dev All time received\r\n   */\r\n  function totalReceivedAmount(address _address)\r\n    public view returns (uint256)\r\n  {\r\n    return audits[_address].totalReceivedAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev All time sent\r\n   */\r\n  function totalSentAmount(address _address) public view returns (uint256) {\r\n    return audits[_address].totalSentAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    if (!super.transfer(_to, _value)) {\r\n      return false;\r\n    }\r\n    updateAudit(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool)\r\n  {\r\n    if (!super.transferFrom(_from, _to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    updateAudit(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n /**\r\n   * @dev currentTime()\r\n   */\r\n  function currentTime() internal view returns (uint256) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return now;\r\n  }\r\n\r\n  /**\r\n   * @dev Update audit data\r\n   */\r\n  function updateAudit(address _sender, address _receiver, uint256 _value)\r\n    private returns (uint256)\r\n  {\r\n    Audit storage senderAudit = audits[_sender];\r\n    senderAudit.lastSentAt = currentTime();\r\n    senderAudit.sentCount++;\r\n    senderAudit.totalSentAmount += _value;\r\n    if (senderAudit.createdAt == 0) {\r\n      senderAudit.createdAt = currentTime();\r\n    }\r\n\r\n    Audit storage receiverAudit = audits[_receiver];\r\n    receiverAudit.lastReceivedAt = currentTime();\r\n    receiverAudit.receivedCount++;\r\n    receiverAudit.totalReceivedAmount += _value;\r\n    if (receiverAudit.createdAt == 0) {\r\n      receiverAudit.createdAt = currentTime();\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/ProvableOwnershipToken.sol\r\n\r\n/**\r\n * @title ProvableOwnershipToken\r\n * @dev ProvableOwnershipToken is a StandardToken\r\n * with ability to record a proof of ownership\r\n *\r\n * When desired a proof of ownership can be generated.\r\n * The proof is stored within the contract.\r\n * A proofId is then returned.\r\n * The proof can later be used to retrieve the amount needed.\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {\r\n  struct Proof {\r\n    uint256 amount;\r\n    uint256 dateFrom;\r\n    uint256 dateTo;\r\n  }\r\n  mapping(address => mapping(uint256 => Proof)) internal proofs;\r\n  mapping(address => uint256) internal proofLengths;\r\n\r\n  /**\r\n   * @dev number of proof stored in the contract\r\n   */\r\n  function proofLength(address _holder) public view returns (uint256) {\r\n    return proofLengths[_holder];\r\n  }\r\n\r\n  /**\r\n   * @dev amount contains for the proofId reccord\r\n   */\r\n  function proofAmount(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].amount;\r\n  }\r\n\r\n  /**\r\n   * @dev date from which the proof is valid\r\n   */\r\n  function proofDateFrom(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].dateFrom;\r\n  }\r\n\r\n  /**\r\n   * @dev date until the proof is valid\r\n   */\r\n  function proofDateTo(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].dateTo;\r\n  }\r\n\r\n  /**\r\n   * @dev called to challenge a proof at a point in the past\r\n   * Return the amount tokens owned by the proof owner at that time\r\n   */\r\n  function checkProof(address _holder, uint256 _proofId, uint256 _at)\r\n    public view returns (uint256)\r\n  {\r\n    if (_proofId < proofLengths[_holder]) {\r\n      Proof storage proof = proofs[_holder][_proofId];\r\n\r\n      if (proof.dateFrom <= _at && _at <= proof.dateTo) {\r\n        return proof.amount;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @dev called to create a proof of token ownership\r\n   */\r\n  function createProof(address _holder) public {\r\n    createProofInternal(\r\n      _holder,\r\n      balanceOf(_holder),\r\n      lastTransactionAt(_holder)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer function with also create a proof of ownership to any of the participants\r\n   * @param _proofSender if true a proof will be created for the sender\r\n   * @param _proofReceiver if true a proof will be created for the receiver\r\n   */\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofSender,\r\n    bool _proofReceiver\r\n  ) public returns (bool)\r\n  {\r\n    uint256 balanceBeforeFrom = balanceOf(msg.sender);\r\n    uint256 beforeFrom = lastTransactionAt(msg.sender);\r\n    uint256 balanceBeforeTo = balanceOf(_to);\r\n    uint256 beforeTo = lastTransactionAt(_to);\r\n\r\n    if (!super.transfer(_to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    transferPostProcessing(\r\n      msg.sender,\r\n      balanceBeforeFrom,\r\n      beforeFrom,\r\n      _proofSender\r\n    );\r\n    transferPostProcessing(\r\n      _to,\r\n      balanceBeforeTo,\r\n      beforeTo,\r\n      _proofReceiver\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev transfer function with also create a proof of ownership to any of the participants\r\n   * @param _proofSender if true a proof will be created for the sender\r\n   * @param _proofReceiver if true a proof will be created for the receiver\r\n   */\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to, \r\n    uint256 _value,\r\n    bool _proofSender, bool _proofReceiver)\r\n    public returns (bool)\r\n  {\r\n    uint256 balanceBeforeFrom = balanceOf(_from);\r\n    uint256 beforeFrom = lastTransactionAt(_from);\r\n    uint256 balanceBeforeTo = balanceOf(_to);\r\n    uint256 beforeTo = lastTransactionAt(_to);\r\n\r\n    if (!super.transferFrom(_from, _to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    transferPostProcessing(\r\n      _from,\r\n      balanceBeforeFrom,\r\n      beforeFrom,\r\n      _proofSender\r\n    );\r\n    transferPostProcessing(\r\n      _to,\r\n      balanceBeforeTo,\r\n      beforeTo,\r\n      _proofReceiver\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev can be used to force create a proof (with a fake amount potentially !)\r\n   * Only usable by child contract internaly\r\n   */\r\n  function createProofInternal(\r\n    address _holder, uint256 _amount, uint256 _from) internal\r\n  {\r\n    uint proofId = proofLengths[_holder];\r\n    // solium-disable-next-line security/no-block-members\r\n    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());\r\n    proofLengths[_holder] = proofId+1;\r\n    emit ProofOfOwnership(_holder, proofId);\r\n  }\r\n\r\n  /**\r\n   * @dev private function updating contract state after a transfer operation\r\n   */\r\n  function transferPostProcessing(\r\n    address _holder,\r\n    uint256 _balanceBefore,\r\n    uint256 _before,\r\n    bool _proof) private\r\n  {\r\n    if (_proof) {\r\n      createProofInternal(_holder, _balanceBefore, _before);\r\n    }\r\n  }\r\n\r\n  event ProofOfOwnership(address indexed holder, uint256 proofId);\r\n}\r\n\r\n// File: contracts/interface/IClaimable.sol\r\n\r\n/**\r\n * @title IClaimable\r\n * @dev IClaimable interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ninterface IClaimable {\r\n  function hasClaimsSince(address _address, uint256 at)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IWithClaims.sol\r\n\r\n/**\r\n * @title IWithClaims\r\n * @dev IWithClaims interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IWithClaims {\r\n  function claimableLength() public view returns (uint256);\r\n  function claimable(uint256 _claimableId) public view returns (IClaimable);\r\n  function hasClaims(address _holder) public view returns (bool);\r\n  function defineClaimables(IClaimable[] _claimables) public;\r\n\r\n  event ClaimablesDefined(uint256 count);\r\n}\r\n\r\n// File: contracts/token/component/TokenWithClaims.sol\r\n\r\n/**\r\n * @title TokenWithClaims\r\n * @dev TokenWithClaims contract\r\n * TokenWithClaims is a token that will create a\r\n * proofOfOwnership during transfers if a claim can be made.\r\n * Holder may ask for the claim later using the proofOfOwnership\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * E01: Claimable address must be defined\r\n * E02: Claimables parameter must not be empty\r\n * E03: Claimable does not exist\r\n**/\r\ncontract TokenWithClaims is IWithClaims, ProvableOwnershipToken {\r\n\r\n  IClaimable[] claimables;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IClaimable[] _claimables) public {\r\n    claimables = _claimables;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of claimables\r\n   */\r\n  function claimableLength() public view returns (uint256) {\r\n    return claimables.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the Claimable associated to the specified claimableId\r\n   */\r\n  function claimable(uint256 _claimableId) public view returns (IClaimable) {\r\n    return claimables[_claimableId];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if there are any claims associated to this token\r\n   * to be made at this time for the _holder\r\n   */\r\n  function hasClaims(address _holder) public view returns (bool) {\r\n    uint256 lastTransaction = lastTransactionAt(_holder);\r\n    for (uint256 i = 0; i < claimables.length; i++) {\r\n      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @dev Override the transfer function with transferWithProofs\r\n   * A proof of ownership will be made if any claims can be made by the participants\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    bool proofFrom = hasClaims(msg.sender);\r\n    bool proofTo = hasClaims(_to);\r\n\r\n    return super.transferWithProofs(\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Override the transfer function with transferWithProofs\r\n   * A proof of ownership will be made if any claims can be made by the participants\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool)\r\n  {\r\n    bool proofFrom = hasClaims(_from);\r\n    bool proofTo = hasClaims(_to);\r\n\r\n    return super.transferFromWithProofs(\r\n      _from,\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer with proofs\r\n   */\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n  ) public returns (bool)\r\n  {\r\n    bool proofFrom = _proofFrom || hasClaims(msg.sender);\r\n    bool proofTo = _proofTo || hasClaims(_to);\r\n\r\n    return super.transferWithProofs(\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer from with proofs\r\n   */\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n  ) public returns (bool)\r\n  {\r\n    bool proofFrom = _proofFrom || hasClaims(_from);\r\n    bool proofTo = _proofTo || hasClaims(_to);\r\n\r\n    return super.transferFromWithProofs(\r\n      _from,\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev define claimables contract to this token\r\n   */\r\n  function defineClaimables(IClaimable[] _claimables) public onlyOwner {\r\n    claimables = _claimables;\r\n    emit ClaimablesDefined(claimables.length);\r\n  }\r\n}\r\n\r\n// File: contracts/interface/IRule.sol\r\n\r\n/**\r\n * @title IRule\r\n * @dev IRule interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ninterface IRule {\r\n  function isAddressValid(address _address) external view returns (bool);\r\n  function isTransferValid(address _from, address _to, uint256 _amount)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IWithRules.sol\r\n\r\n/**\r\n * @title IWithRules\r\n * @dev IWithRules interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IWithRules {\r\n  function ruleLength() public view returns (uint256);\r\n  function rule(uint256 _ruleId) public view returns (IRule);\r\n  function validateAddress(address _address) public view returns (bool);\r\n  function validateTransfer(address _from, address _to, uint256 _amount)\r\n    public view returns (bool);\r\n\r\n  function defineRules(IRule[] _rules) public;\r\n\r\n  event RulesDefined(uint256 count);\r\n}\r\n\r\n// File: contracts/rule/WithRules.sol\r\n\r\n/**\r\n * @title WithRules\r\n * @dev WithRules contract allows inheriting contract to use a set of validation rules\r\n * @dev contract owner may add or remove rules\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * WR01: The rules rejected this address\r\n * WR02: The rules rejected the transfer\r\n **/\r\ncontract WithRules is IWithRules, Ownable {\r\n\r\n  IRule[] internal rules;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IRule[] _rules) public {\r\n    rules = _rules;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of rules\r\n   */\r\n  function ruleLength() public view returns (uint256) {\r\n    return rules.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the Rule associated to the specified ruleId\r\n   */\r\n  function rule(uint256 _ruleId) public view returns (IRule) {\r\n    return rules[_ruleId];\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid for an address\r\n   */\r\n  function validateAddress(address _address) public view returns (bool) {\r\n    for (uint256 i = 0; i < rules.length; i++) {\r\n      if (!rules[i].isAddressValid(_address)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid\r\n   */\r\n  function validateTransfer(address _from, address _to, uint256 _amount)\r\n    public view returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < rules.length; i++) {\r\n      if (!rules[i].isTransferValid(_from, _to, _amount)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make functions callable\r\n   * only when participants follow rules\r\n   */\r\n  modifier whenAddressRulesAreValid(address _address) {\r\n    require(validateAddress(_address), \"WR01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make transfer functions callable\r\n   * only when participants follow rules\r\n   */\r\n  modifier whenTransferRulesAreValid(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount)\r\n  {\r\n    require(validateTransfer(_from, _to, _amount), \"WR02\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Define rules to the token\r\n   */\r\n  function defineRules(IRule[] _rules) public onlyOwner {\r\n    rules = _rules;\r\n    emit RulesDefined(rules.length);\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/TokenWithRules.sol\r\n\r\n/**\r\n * @title TokenWithRules\r\n * @dev TokenWithRules contract\r\n * TokenWithRules is a token that will apply\r\n * rules restricting transferability\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n **/\r\ncontract TokenWithRules is StandardToken, WithRules {\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IRule[] _rules) public WithRules(_rules) { }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _to, uint256 _value)\r\n    public whenTransferRulesAreValid(msg.sender, _to, _value)\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public whenTransferRulesAreValid(_from, _to, _value)\r\n    whenAddressRulesAreValid(msg.sender)\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/token/BridgeToken.sol\r\n\r\n/**\r\n * @title BridgeToken\r\n * @dev BridgeToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {\r\n  string public name;\r\n  string public symbol;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string _name, string _symbol) \r\n    TokenWithRules(new IRule[](0))\r\n    TokenWithClaims(new IClaimable[](0)) public\r\n  {\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n}\r\n\r\n// File: contracts/interface/IMintable.sol\r\n\r\n/**\r\n * @title Mintable interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract IMintable {\r\n  function mintingFinished() public view returns (bool);\r\n\r\n  function mint(address _to, uint256 _amount) public returns (bool);\r\n  function finishMinting() public returns (bool);\r\n \r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n}\r\n\r\n// File: contracts/token/component/MintableToken.sol\r\n\r\n/**\r\n * @title MintableToken\r\n * @dev MintableToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * MT01: Minting is already finished.\r\n*/\r\ncontract MintableToken is StandardToken, Ownable, IMintable {\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  function mintingFinished() public view returns (bool) {\r\n    return mintingFinished;\r\n  }\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished, \"MT01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  ) public canMint onlyOwner returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public canMint onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n}\r\n\r\n// File: contracts/token/MintableBridgeToken.sol\r\n\r\n/**\r\n * @title MintableBridgeToken\r\n * @dev MintableBridgeToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract MintableBridgeToken is BridgeToken, MintableToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string _name, string _symbol)\r\n    BridgeToken(_name, _symbol) public\r\n  {\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n}\r\n\r\n// File: contracts/token/ShareBridgeToken.sol\r\n\r\n/**\r\n * @title ShareBridgeToken\r\n * @dev ShareBridgeToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract ShareBridgeToken is MintableBridgeToken {\r\n\r\n  // Shares are non divisible assets\r\n  uint256 public decimals = 0;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string _name, string _symbol) public\r\n    MintableBridgeToken(_name, _symbol)\r\n  {\r\n  }\r\n}\r\n\r\n// File: contracts/mps/MPSToken.sol\r\n\r\n/**\r\n * @title MPSToken\r\n * @dev MPSToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract MPSToken is ShareBridgeToken {\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor() public\r\n    ShareBridgeToken(\"MtPelerin Shares\", \"MPS\")\r\n  {\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"totalSentAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lastTransactionAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"hasClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allTimeSeized\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"totalReceivedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_proofFrom\",\"type\":\"bool\"},{\"name\":\"_proofTo\",\"type\":\"bool\"}],\"name\":\"transferWithProofs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_proofId\",\"type\":\"uint256\"}],\"name\":\"proofDateFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"createProof\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"validateAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"receivedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_proofId\",\"type\":\"uint256\"}],\"name\":\"proofDateTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lastSentAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"proofLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_proofId\",\"type\":\"uint256\"}],\"name\":\"proofAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_proofId\",\"type\":\"uint256\"},{\"name\":\"_at\",\"type\":\"uint256\"}],\"name\":\"checkProof\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"auditCreatedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ruleLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"validateTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rules\",\"type\":\"address[]\"}],\"name\":\"defineRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_proofFrom\",\"type\":\"bool\"},{\"name\":\"_proofTo\",\"type\":\"bool\"}],\"name\":\"transferFromWithProofs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_claimableId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lastReceivedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"sentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ruleId\",\"type\":\"uint256\"}],\"name\":\"rule\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimables\",\"type\":\"address[]\"}],\"name\":\"defineClaimables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"defineAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimableLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Seize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AuthorityDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proofId\",\"type\":\"uint256\"}],\"name\":\"ProofOfOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"RulesDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ClaimablesDefined\",\"type\":\"event\"}]","ContractName":"MPSToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7b772253022a34c13f160094b262bd38a37d7bfb0c40727f22dc2bd07b2de7ae"}]}