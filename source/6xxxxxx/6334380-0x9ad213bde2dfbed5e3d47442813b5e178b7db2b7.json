{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Fog {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed owner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  event Winner(address indexed to, uint indexed value);\r\n  event CupCake(address indexed to, uint indexed value);\r\n  event Looser(address indexed from, uint indexed value);\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function move(uint256 direction) public payable {\r\n    require(tx.origin == msg.sender);\r\n\r\n    uint doubleValue = mul(msg.value, 2);\r\n    uint minValue = 10000000000000000; // 0.01 Ether\r\n\r\n    // Check for minValue and make sure we have enough balance\r\n    require(msg.value >= minValue && doubleValue <= address(this).balance);\r\n\r\n    // Roll biased towards direction\r\n    uint dice = uint(keccak256(abi.encodePacked(now + uint(msg.sender) + direction))) % 3;\r\n\r\n    // Winner\r\n    if (dice == 2) {\r\n      msg.sender.transfer(doubleValue);\r\n      emit Winner(msg.sender, doubleValue);\r\n\r\n    // Looser\r\n    } else {\r\n      // Coin biased towards direction\r\n      uint coin = uint(keccak256(abi.encodePacked(now + uint(msg.sender) + direction))) % 2;\r\n\r\n      // CupCake\r\n      if (coin == 1) {\r\n        // Woa! Refund 80%\r\n        uint eightyPercent = div(mul(msg.value, 80), 100);\r\n\r\n        msg.sender.transfer(eightyPercent);\r\n        emit CupCake(msg.sender, eightyPercent);\r\n\r\n      // Looser\r\n      } else {\r\n        emit Looser(msg.sender, msg.value);\r\n      }\r\n    }\r\n  }\r\n\r\n  function drain(uint value) public onlyOwner {\r\n    require(value > 0 && value < address(this).balance);\r\n    owner.transfer(value);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function() public payable { }\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"direction\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CupCake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Looser\",\"type\":\"event\"}]","ContractName":"Fog","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8438d6bba0a8dd319e08582417f91bd3451cb6f75568516587a5362d839437cc"}]}