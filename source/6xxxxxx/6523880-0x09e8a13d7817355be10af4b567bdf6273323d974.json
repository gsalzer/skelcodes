{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * MPSBoardSig.sol\r\n * Governance smart contract including multi-signature capabilities.\r\n * It uniquely represents the Board of Directors of Mt Pelerin Group SA on-chain\r\n * until it is superseded by a resolution of the board referring to a new\r\n * governance on-chain reference.\r\n\r\n * The unflattened code is available through this github tag:\r\n * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1\r\n\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n\r\n * @notice All matters regarding the intellectual property of this code \r\n * @notice or software are subject to Swiss Law without reference to its \r\n * @notice conflicts of law rules.\r\n\r\n * @notice License for each contract is available in the respective file\r\n * @notice or in the LICENSE.md file.\r\n * @notice https://github.com/MtPelerin/\r\n\r\n * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:\r\n * @notice https://github.com/OpenZeppelin/openzeppelin-solidity\r\n */\r\n\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/multisig/private/MultiSig.sol\r\n\r\n/**\r\n * @title MultiSig\r\n * @dev MultiSig contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n\r\n * Error messages\r\n * MS01: Valid signatures below threshold\r\n * MS02: Transaction validity has expired\r\n * MS03: Sender does not belong to signers\r\n * MS04: Execution should be correct\r\n */\r\ncontract MultiSig {\r\n  address[]  signers_;\r\n  uint8 public threshold;\r\n\r\n  bytes32 public replayProtection;\r\n  uint256 public nonce;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(address[] _signers, uint8 _threshold) public {\r\n    signers_ = _signers;\r\n    threshold = _threshold;\r\n\r\n    // Prevent first transaction of different contracts\r\n    // to be replayed here\r\n    updateReplayProtection();\r\n  }\r\n\r\n  /**\r\n   * @dev fallback function\r\n   */\r\n  function () public payable { }\r\n\r\n  /**\r\n   * @dev read a function selector from a bytes field\r\n   * @param _data contains the selector\r\n   */\r\n  function readSelector(bytes _data) public pure returns (bytes4) {\r\n    bytes4 selector;\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      selector := mload(add(_data, 0x20))\r\n    }\r\n    return selector;\r\n  }\r\n\r\n  /**\r\n   * @dev read ERC20 destination\r\n   * @param _data ERC20 transfert\r\n   */\r\n  function readERC20Destination(bytes _data) public pure returns (address) {\r\n    address destination;\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      destination := mload(add(_data, 0x24))\r\n    }\r\n    return destination;\r\n  }\r\n\r\n  /**\r\n   * @dev read ERC20 value\r\n   * @param _data contains the selector\r\n   */\r\n  function readERC20Value(bytes _data) public pure returns (uint256) {\r\n    uint256 value;\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      value := mload(add(_data, 0x44))\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier verifying that valid signatures are above _threshold\r\n   */\r\n  modifier thresholdRequired(\r\n    address _destination, uint256 _value, bytes _data,\r\n    uint256 _validity, uint256 _threshold,\r\n    bytes32[] _sigR, bytes32[] _sigS, uint8[] _sigV)\r\n  {\r\n    require(\r\n      reviewSignatures(\r\n        _destination, _value, _data, _validity, _sigR, _sigS, _sigV\r\n      ) >= _threshold,\r\n      \"MS01\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier verifying that transaction is still valid\r\n   * @dev This modifier also protects against replay on forked chain.\r\n   *\r\n   * @notice If both the _validity and gasPrice are low, then there is a risk\r\n   * @notice that the transaction is executed after its _validity but before it does timeout\r\n   * @notice In that case, the transaction will fail.\r\n   * @notice In general, it is recommended to use a _validity greater than the potential timeout\r\n   */\r\n  modifier stillValid(uint256 _validity)\r\n  {\r\n    if (_validity != 0) {\r\n      require(_validity >= block.number, \"MS02\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier requiring that the message sender belongs to the signers\r\n   */\r\n  modifier onlySigners() {\r\n    bool found = false;\r\n    for (uint256 i = 0; i < signers_.length && !found; i++) {\r\n      found = (msg.sender == signers_[i]);\r\n    }\r\n    require(found, \"MS03\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev returns signers\r\n   */\r\n  function signers() public view returns (address[]) {\r\n    return signers_;\r\n  }\r\n\r\n  /**\r\n   * returns threshold\r\n   */\r\n  function threshold() public view returns (uint8) {\r\n    return threshold;\r\n  }\r\n\r\n  /**\r\n   * @dev returns replayProtection\r\n   */\r\n  function replayProtection() public view returns (bytes32) {\r\n    return replayProtection;\r\n  }\r\n\r\n  /**\r\n   * @dev returns nonce\r\n   */\r\n  function nonce() public view returns (uint256) {\r\n    return nonce;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the number of valid signatures\r\n   */\r\n  function reviewSignatures(\r\n    address _destination, uint256 _value, bytes _data,\r\n    uint256 _validity,\r\n    bytes32[] _sigR, bytes32[] _sigS, uint8[] _sigV)\r\n    public view returns (uint256)\r\n  {\r\n    return reviewSignaturesInternal(\r\n      _destination,\r\n      _value,\r\n      _data,\r\n      _validity,\r\n      signers_,\r\n      _sigR,\r\n      _sigS,\r\n      _sigV\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev buildHash\r\n   **/\r\n  function buildHash(\r\n    address _destination, uint256 _value,\r\n    bytes _data, uint256 _validity)\r\n    public view returns (bytes32)\r\n  {\r\n    // FIXME: web3/solidity behaves differently with empty bytes\r\n    if (_data.length == 0) {\r\n      return keccak256(\r\n        abi.encode(\r\n          _destination, _value, _validity, replayProtection\r\n        )\r\n      );\r\n    } else {\r\n      return keccak256(\r\n        abi.encode(\r\n          _destination, _value, _data, _validity, replayProtection\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev recover the public address from the signatures\r\n   **/\r\n  function recoverAddress(\r\n    address _destination, uint256 _value,\r\n    bytes _data, uint256 _validity,\r\n    bytes32 _r, bytes32 _s, uint8 _v)\r\n    public view returns (address)\r\n  {\r\n    // When used in web.eth.sign, geth will prepend the hash\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\",\r\n        buildHash(\r\n          _destination,\r\n          _value,\r\n          _data,\r\n          _validity\r\n        )\r\n      )\r\n    );\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    uint8 v = (_v < 27) ? _v += 27: _v;\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return address(0);\r\n    } else {\r\n      return ecrecover(\r\n        hash,\r\n        v,\r\n        _r,\r\n        _s\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev execute a transaction if enough signatures are valid\r\n   **/\r\n  function execute(\r\n    bytes32[] _sigR,\r\n    bytes32[] _sigS,\r\n    uint8[] _sigV,\r\n    address _destination, uint256 _value, bytes _data, uint256 _validity)\r\n    public\r\n    stillValid(_validity)\r\n    thresholdRequired(_destination, _value, _data, _validity, threshold, _sigR, _sigS, _sigV)\r\n    returns (bool)\r\n  {\r\n    executeInternal(_destination, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev review signatures against a list of signers\r\n   * Signatures must be provided in the same order as the list of signers\r\n   * All provided signatures must be valid and correspond to one of the signers\r\n   * returns the number of valid signatures\r\n   * returns 0 if the inputs are inconsistent\r\n   */\r\n  function reviewSignaturesInternal(\r\n    address _destination, uint256 _value, bytes _data, uint256 _validity,\r\n    address[] _signers,\r\n    bytes32[] _sigR, bytes32[] _sigS, uint8[] _sigV)\r\n    internal view returns (uint256)\r\n  {\r\n    uint256 length = _sigR.length;\r\n    if (length == 0 || length > _signers.length || (\r\n      _sigS.length != length || _sigV.length != length\r\n    ))\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    uint256 validSigs = 0;\r\n    address recovered = recoverAddress(\r\n      _destination, _value, _data, _validity, \r\n      _sigR[0], _sigS[0], _sigV[0]);\r\n    for (uint256 i = 0; i < _signers.length; i++) {\r\n      if (_signers[i] == recovered) {\r\n        validSigs++;\r\n        if (validSigs < length) {\r\n          recovered = recoverAddress(\r\n            _destination,\r\n            _value,\r\n            _data,\r\n            _validity,\r\n            _sigR[validSigs],\r\n            _sigS[validSigs],\r\n            _sigV[validSigs]\r\n          );\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (validSigs != length) {\r\n      return 0;\r\n    }\r\n\r\n    return validSigs;\r\n  }\r\n\r\n  /**\r\n   * @dev execute a transaction\r\n   **/\r\n  function executeInternal(address _destination, uint256 _value, bytes _data)\r\n    internal\r\n  {\r\n    updateReplayProtection();\r\n    if (_data.length == 0) {\r\n      _destination.transfer(_value);\r\n    } else {\r\n      // solium-disable-next-line security/no-call-value\r\n      require(_destination.call.value(_value)(_data), \"MS04\");\r\n    }\r\n    emit Execution(_destination, _value, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev update replay protection\r\n   * contract address is used to prevent replay between different contracts\r\n   * block hash is used to prevent replay between branches\r\n   * nonce is used to prevent replay within the contract\r\n   **/\r\n  function updateReplayProtection() internal {\r\n    replayProtection = keccak256(\r\n      abi.encodePacked(address(this), blockhash(block.number-1), nonce));\r\n    nonce++;\r\n  }\r\n\r\n  event Execution(address to, uint256 value, bytes data);\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interface/ISeizable.sol\r\n\r\n/**\r\n * @title ISeizable\r\n * @dev ISeizable interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract ISeizable {\r\n  function seize(address _account, uint256 _value) public;\r\n  event Seize(address account, uint256 amount);\r\n}\r\n\r\n// File: contracts/zeppelin/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/Authority.sol\r\n\r\n/**\r\n * @title Authority\r\n * @dev The Authority contract has an authority address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * Authority means to represent a legal entity that is entitled to specific rights\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * AU01: Message sender must be an authority\r\n */\r\ncontract Authority is Ownable {\r\n\r\n  address authority;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the authority.\r\n   */\r\n  modifier onlyAuthority {\r\n    require(msg.sender == authority, \"AU01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev return the address associated to the authority\r\n   */\r\n  function authorityAddress() public view returns (address) {\r\n    return authority;\r\n  }\r\n\r\n  /**\r\n   * @dev rdefines an authority\r\n   * @param _name the authority name\r\n   * @param _address the authority address.\r\n   */\r\n  function defineAuthority(string _name, address _address) public onlyOwner {\r\n    emit AuthorityDefined(_name, _address);\r\n    authority = _address;\r\n  }\r\n\r\n  event AuthorityDefined(\r\n    string name,\r\n    address _address\r\n  );\r\n}\r\n\r\n// File: contracts/token/component/SeizableToken.sol\r\n\r\n/**\r\n * @title SeizableToken\r\n * @dev BasicToken contract which allows owner to seize accounts\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * ST01: Owner cannot seize itself\r\n*/\r\ncontract SeizableToken is BasicToken, Authority, ISeizable {\r\n  using SafeMath for uint256;\r\n\r\n  // Although very unlikely, the value below may overflow.\r\n  // This contract and its children should expect it to happened and consider\r\n  // this value as only the first 256 bits of the complete value.\r\n  uint256 public allTimeSeized = 0; // overflow may happend\r\n\r\n  /**\r\n   * @dev called by the owner to seize value from the account\r\n   */\r\n  function seize(address _account, uint256 _value)\r\n    public onlyAuthority\r\n  {\r\n    require(_account != owner, \"ST01\");\r\n\r\n    balances[_account] = balances[_account].sub(_value);\r\n    balances[authority] = balances[authority].add(_value);\r\n\r\n    allTimeSeized += _value;\r\n    emit Seize(_account, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interface/IProvableOwnership.sol\r\n\r\n/**\r\n * @title IProvableOwnership\r\n * @dev IProvableOwnership interface which describe proof of ownership.\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IProvableOwnership {\r\n  function proofLength(address _holder) public view returns (uint256);\r\n  function proofAmount(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function proofDateFrom(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function proofDateTo(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function createProof(address _holder) public;\r\n  function checkProof(address _holder, uint256 _proofId, uint256 _at)\r\n    public view returns (uint256);\r\n\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n    ) public returns (bool);\r\n\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n    ) public returns (bool);\r\n\r\n  event ProofOfOwnership(address indexed holder, uint256 proofId);\r\n}\r\n\r\n// File: contracts/interface/IAuditableToken.sol\r\n\r\n/**\r\n * @title IAuditableToken\r\n * @dev IAuditableToken interface describing the audited data\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IAuditableToken {\r\n  function lastTransactionAt(address _address) public view returns (uint256);\r\n  function lastReceivedAt(address _address) public view returns (uint256);\r\n  function lastSentAt(address _address) public view returns (uint256);\r\n  function transactionCount(address _address) public view returns (uint256);\r\n  function receivedCount(address _address) public view returns (uint256);\r\n  function sentCount(address _address) public view returns (uint256);\r\n  function totalReceivedAmount(address _address) public view returns (uint256);\r\n  function totalSentAmount(address _address) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/token/component/AuditableToken.sol\r\n\r\n/**\r\n * @title AuditableToken\r\n * @dev AuditableToken contract\r\n * AuditableToken provides transaction data which can be used\r\n * in other smart contracts\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract AuditableToken is IAuditableToken, StandardToken {\r\n\r\n   // Although very unlikely, the following values below may overflow:\r\n   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount\r\n   // This contract and its children should expect it to happen and consider\r\n   // these values as only the first 256 bits of the complete value.\r\n  struct Audit {\r\n    uint256 createdAt;\r\n    uint256 lastReceivedAt;\r\n    uint256 lastSentAt;\r\n    uint256 receivedCount; // potential overflow\r\n    uint256 sentCount; // poential overflow\r\n    uint256 totalReceivedAmount; // potential overflow\r\n    uint256 totalSentAmount; // potential overflow\r\n  }\r\n  mapping(address => Audit) internal audits;\r\n\r\n  /**\r\n   * @dev Time of the creation of the audit struct\r\n   */\r\n  function auditCreatedAt(address _address) public view returns (uint256) {\r\n    return audits[_address].createdAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last transaction\r\n   */\r\n  function lastTransactionAt(address _address) public view returns (uint256) {\r\n    return ( audits[_address].lastReceivedAt > audits[_address].lastSentAt ) ?\r\n      audits[_address].lastReceivedAt : audits[_address].lastSentAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last received transaction\r\n   */\r\n  function lastReceivedAt(address _address) public view returns (uint256) {\r\n    return audits[_address].lastReceivedAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last sent transaction\r\n   */\r\n  function lastSentAt(address _address) public view returns (uint256) {\r\n    return audits[_address].lastSentAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of transactions\r\n   */\r\n  function transactionCount(address _address) public view returns (uint256) {\r\n    return audits[_address].receivedCount + audits[_address].sentCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of received transactions\r\n   */\r\n  function receivedCount(address _address) public view returns (uint256) {\r\n    return audits[_address].receivedCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of sent transactions\r\n   */\r\n  function sentCount(address _address) public view returns (uint256) {\r\n    return audits[_address].sentCount;\r\n  }\r\n\r\n  /**\r\n   * @dev All time received\r\n   */\r\n  function totalReceivedAmount(address _address)\r\n    public view returns (uint256)\r\n  {\r\n    return audits[_address].totalReceivedAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev All time sent\r\n   */\r\n  function totalSentAmount(address _address) public view returns (uint256) {\r\n    return audits[_address].totalSentAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    if (!super.transfer(_to, _value)) {\r\n      return false;\r\n    }\r\n    updateAudit(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool)\r\n  {\r\n    if (!super.transferFrom(_from, _to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    updateAudit(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n /**\r\n   * @dev currentTime()\r\n   */\r\n  function currentTime() internal view returns (uint256) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return now;\r\n  }\r\n\r\n  /**\r\n   * @dev Update audit data\r\n   */\r\n  function updateAudit(address _sender, address _receiver, uint256 _value)\r\n    private returns (uint256)\r\n  {\r\n    Audit storage senderAudit = audits[_sender];\r\n    senderAudit.lastSentAt = currentTime();\r\n    senderAudit.sentCount++;\r\n    senderAudit.totalSentAmount += _value;\r\n    if (senderAudit.createdAt == 0) {\r\n      senderAudit.createdAt = currentTime();\r\n    }\r\n\r\n    Audit storage receiverAudit = audits[_receiver];\r\n    receiverAudit.lastReceivedAt = currentTime();\r\n    receiverAudit.receivedCount++;\r\n    receiverAudit.totalReceivedAmount += _value;\r\n    if (receiverAudit.createdAt == 0) {\r\n      receiverAudit.createdAt = currentTime();\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/ProvableOwnershipToken.sol\r\n\r\n/**\r\n * @title ProvableOwnershipToken\r\n * @dev ProvableOwnershipToken is a StandardToken\r\n * with ability to record a proof of ownership\r\n *\r\n * When desired a proof of ownership can be generated.\r\n * The proof is stored within the contract.\r\n * A proofId is then returned.\r\n * The proof can later be used to retrieve the amount needed.\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {\r\n  struct Proof {\r\n    uint256 amount;\r\n    uint256 dateFrom;\r\n    uint256 dateTo;\r\n  }\r\n  mapping(address => mapping(uint256 => Proof)) internal proofs;\r\n  mapping(address => uint256) internal proofLengths;\r\n\r\n  /**\r\n   * @dev number of proof stored in the contract\r\n   */\r\n  function proofLength(address _holder) public view returns (uint256) {\r\n    return proofLengths[_holder];\r\n  }\r\n\r\n  /**\r\n   * @dev amount contains for the proofId reccord\r\n   */\r\n  function proofAmount(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].amount;\r\n  }\r\n\r\n  /**\r\n   * @dev date from which the proof is valid\r\n   */\r\n  function proofDateFrom(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].dateFrom;\r\n  }\r\n\r\n  /**\r\n   * @dev date until the proof is valid\r\n   */\r\n  function proofDateTo(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].dateTo;\r\n  }\r\n\r\n  /**\r\n   * @dev called to challenge a proof at a point in the past\r\n   * Return the amount tokens owned by the proof owner at that time\r\n   */\r\n  function checkProof(address _holder, uint256 _proofId, uint256 _at)\r\n    public view returns (uint256)\r\n  {\r\n    if (_proofId < proofLengths[_holder]) {\r\n      Proof storage proof = proofs[_holder][_proofId];\r\n\r\n      if (proof.dateFrom <= _at && _at <= proof.dateTo) {\r\n        return proof.amount;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @dev called to create a proof of token ownership\r\n   */\r\n  function createProof(address _holder) public {\r\n    createProofInternal(\r\n      _holder,\r\n      balanceOf(_holder),\r\n      lastTransactionAt(_holder)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer function with also create a proof of ownership to any of the participants\r\n   * @param _proofSender if true a proof will be created for the sender\r\n   * @param _proofReceiver if true a proof will be created for the receiver\r\n   */\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofSender,\r\n    bool _proofReceiver\r\n  ) public returns (bool)\r\n  {\r\n    uint256 balanceBeforeFrom = balanceOf(msg.sender);\r\n    uint256 beforeFrom = lastTransactionAt(msg.sender);\r\n    uint256 balanceBeforeTo = balanceOf(_to);\r\n    uint256 beforeTo = lastTransactionAt(_to);\r\n\r\n    if (!super.transfer(_to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    transferPostProcessing(\r\n      msg.sender,\r\n      balanceBeforeFrom,\r\n      beforeFrom,\r\n      _proofSender\r\n    );\r\n    transferPostProcessing(\r\n      _to,\r\n      balanceBeforeTo,\r\n      beforeTo,\r\n      _proofReceiver\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev transfer function with also create a proof of ownership to any of the participants\r\n   * @param _proofSender if true a proof will be created for the sender\r\n   * @param _proofReceiver if true a proof will be created for the receiver\r\n   */\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to, \r\n    uint256 _value,\r\n    bool _proofSender, bool _proofReceiver)\r\n    public returns (bool)\r\n  {\r\n    uint256 balanceBeforeFrom = balanceOf(_from);\r\n    uint256 beforeFrom = lastTransactionAt(_from);\r\n    uint256 balanceBeforeTo = balanceOf(_to);\r\n    uint256 beforeTo = lastTransactionAt(_to);\r\n\r\n    if (!super.transferFrom(_from, _to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    transferPostProcessing(\r\n      _from,\r\n      balanceBeforeFrom,\r\n      beforeFrom,\r\n      _proofSender\r\n    );\r\n    transferPostProcessing(\r\n      _to,\r\n      balanceBeforeTo,\r\n      beforeTo,\r\n      _proofReceiver\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev can be used to force create a proof (with a fake amount potentially !)\r\n   * Only usable by child contract internaly\r\n   */\r\n  function createProofInternal(\r\n    address _holder, uint256 _amount, uint256 _from) internal\r\n  {\r\n    uint proofId = proofLengths[_holder];\r\n    // solium-disable-next-line security/no-block-members\r\n    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());\r\n    proofLengths[_holder] = proofId+1;\r\n    emit ProofOfOwnership(_holder, proofId);\r\n  }\r\n\r\n  /**\r\n   * @dev private function updating contract state after a transfer operation\r\n   */\r\n  function transferPostProcessing(\r\n    address _holder,\r\n    uint256 _balanceBefore,\r\n    uint256 _before,\r\n    bool _proof) private\r\n  {\r\n    if (_proof) {\r\n      createProofInternal(_holder, _balanceBefore, _before);\r\n    }\r\n  }\r\n\r\n  event ProofOfOwnership(address indexed holder, uint256 proofId);\r\n}\r\n\r\n// File: contracts/interface/IClaimable.sol\r\n\r\n/**\r\n * @title IClaimable\r\n * @dev IClaimable interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ninterface IClaimable {\r\n  function hasClaimsSince(address _address, uint256 at)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IWithClaims.sol\r\n\r\n/**\r\n * @title IWithClaims\r\n * @dev IWithClaims interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IWithClaims {\r\n  function claimableLength() public view returns (uint256);\r\n  function claimable(uint256 _claimableId) public view returns (IClaimable);\r\n  function hasClaims(address _holder) public view returns (bool);\r\n  function defineClaimables(IClaimable[] _claimables) public;\r\n\r\n  event ClaimablesDefined(uint256 count);\r\n}\r\n\r\n// File: contracts/token/component/TokenWithClaims.sol\r\n\r\n/**\r\n * @title TokenWithClaims\r\n * @dev TokenWithClaims contract\r\n * TokenWithClaims is a token that will create a\r\n * proofOfOwnership during transfers if a claim can be made.\r\n * Holder may ask for the claim later using the proofOfOwnership\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * E01: Claimable address must be defined\r\n * E02: Claimables parameter must not be empty\r\n * E03: Claimable does not exist\r\n**/\r\ncontract TokenWithClaims is IWithClaims, ProvableOwnershipToken {\r\n\r\n  IClaimable[] claimables;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IClaimable[] _claimables) public {\r\n    claimables = _claimables;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of claimables\r\n   */\r\n  function claimableLength() public view returns (uint256) {\r\n    return claimables.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the Claimable associated to the specified claimableId\r\n   */\r\n  function claimable(uint256 _claimableId) public view returns (IClaimable) {\r\n    return claimables[_claimableId];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if there are any claims associated to this token\r\n   * to be made at this time for the _holder\r\n   */\r\n  function hasClaims(address _holder) public view returns (bool) {\r\n    uint256 lastTransaction = lastTransactionAt(_holder);\r\n    for (uint256 i = 0; i < claimables.length; i++) {\r\n      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @dev Override the transfer function with transferWithProofs\r\n   * A proof of ownership will be made if any claims can be made by the participants\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    bool proofFrom = hasClaims(msg.sender);\r\n    bool proofTo = hasClaims(_to);\r\n\r\n    return super.transferWithProofs(\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Override the transfer function with transferWithProofs\r\n   * A proof of ownership will be made if any claims can be made by the participants\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool)\r\n  {\r\n    bool proofFrom = hasClaims(_from);\r\n    bool proofTo = hasClaims(_to);\r\n\r\n    return super.transferFromWithProofs(\r\n      _from,\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer with proofs\r\n   */\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n  ) public returns (bool)\r\n  {\r\n    bool proofFrom = _proofFrom || hasClaims(msg.sender);\r\n    bool proofTo = _proofTo || hasClaims(_to);\r\n\r\n    return super.transferWithProofs(\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer from with proofs\r\n   */\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n  ) public returns (bool)\r\n  {\r\n    bool proofFrom = _proofFrom || hasClaims(_from);\r\n    bool proofTo = _proofTo || hasClaims(_to);\r\n\r\n    return super.transferFromWithProofs(\r\n      _from,\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev define claimables contract to this token\r\n   */\r\n  function defineClaimables(IClaimable[] _claimables) public onlyOwner {\r\n    claimables = _claimables;\r\n    emit ClaimablesDefined(claimables.length);\r\n  }\r\n}\r\n\r\n// File: contracts/interface/IRule.sol\r\n\r\n/**\r\n * @title IRule\r\n * @dev IRule interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ninterface IRule {\r\n  function isAddressValid(address _address) external view returns (bool);\r\n  function isTransferValid(address _from, address _to, uint256 _amount)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IWithRules.sol\r\n\r\n/**\r\n * @title IWithRules\r\n * @dev IWithRules interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IWithRules {\r\n  function ruleLength() public view returns (uint256);\r\n  function rule(uint256 _ruleId) public view returns (IRule);\r\n  function validateAddress(address _address) public view returns (bool);\r\n  function validateTransfer(address _from, address _to, uint256 _amount)\r\n    public view returns (bool);\r\n\r\n  function defineRules(IRule[] _rules) public;\r\n\r\n  event RulesDefined(uint256 count);\r\n}\r\n\r\n// File: contracts/rule/WithRules.sol\r\n\r\n/**\r\n * @title WithRules\r\n * @dev WithRules contract allows inheriting contract to use a set of validation rules\r\n * @dev contract owner may add or remove rules\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * WR01: The rules rejected this address\r\n * WR02: The rules rejected the transfer\r\n **/\r\ncontract WithRules is IWithRules, Ownable {\r\n\r\n  IRule[] internal rules;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IRule[] _rules) public {\r\n    rules = _rules;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of rules\r\n   */\r\n  function ruleLength() public view returns (uint256) {\r\n    return rules.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the Rule associated to the specified ruleId\r\n   */\r\n  function rule(uint256 _ruleId) public view returns (IRule) {\r\n    return rules[_ruleId];\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid for an address\r\n   */\r\n  function validateAddress(address _address) public view returns (bool) {\r\n    for (uint256 i = 0; i < rules.length; i++) {\r\n      if (!rules[i].isAddressValid(_address)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid\r\n   */\r\n  function validateTransfer(address _from, address _to, uint256 _amount)\r\n    public view returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < rules.length; i++) {\r\n      if (!rules[i].isTransferValid(_from, _to, _amount)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make functions callable\r\n   * only when participants follow rules\r\n   */\r\n  modifier whenAddressRulesAreValid(address _address) {\r\n    require(validateAddress(_address), \"WR01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make transfer functions callable\r\n   * only when participants follow rules\r\n   */\r\n  modifier whenTransferRulesAreValid(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount)\r\n  {\r\n    require(validateTransfer(_from, _to, _amount), \"WR02\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Define rules to the token\r\n   */\r\n  function defineRules(IRule[] _rules) public onlyOwner {\r\n    rules = _rules;\r\n    emit RulesDefined(rules.length);\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/TokenWithRules.sol\r\n\r\n/**\r\n * @title TokenWithRules\r\n * @dev TokenWithRules contract\r\n * TokenWithRules is a token that will apply\r\n * rules restricting transferability\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n **/\r\ncontract TokenWithRules is StandardToken, WithRules {\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IRule[] _rules) public WithRules(_rules) { }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _to, uint256 _value)\r\n    public whenTransferRulesAreValid(msg.sender, _to, _value)\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public whenTransferRulesAreValid(_from, _to, _value)\r\n    whenAddressRulesAreValid(msg.sender)\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/token/BridgeToken.sol\r\n\r\n/**\r\n * @title BridgeToken\r\n * @dev BridgeToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {\r\n  string public name;\r\n  string public symbol;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string _name, string _symbol) \r\n    TokenWithRules(new IRule[](0))\r\n    TokenWithClaims(new IClaimable[](0)) public\r\n  {\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n}\r\n\r\n// File: contracts/governance/BoardSig.sol\r\n\r\n/**\r\n * @title BoardSig\r\n * @dev BoardSig contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * @notice Swissquote Bank SA solely is entitled to the GNU LGPL.\r\n * @notice Any other party is subject to the copyright mentioned in the software.\r\n *\r\n * Error messages\r\n */\r\ncontract BoardSig is MultiSig {\r\n  bytes32 public constant TOKENIZE = keccak256(\"TOKENIZE\");\r\n\r\n  string public companyName;\r\n\r\n  string public country;\r\n  string public registeredNumber;\r\n\r\n  BridgeToken public token;\r\n\r\n  /**\r\n   * @dev constructor function\r\n   */\r\n  constructor(address[] _addresses, uint8 _threshold) public\r\n    MultiSig(_addresses, _threshold)\r\n  {\r\n  }\r\n\r\n  /**\r\n   * @dev returns hash of hashed \"TOKENIZE\"+ token address + document hash\r\n   */\r\n  function tokenizeHash(BridgeToken _token, bytes32 _hash)\r\n    public pure returns (bytes32)\r\n  {\r\n    return keccak256(\r\n      abi.encode(TOKENIZE, address(_token), _hash)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev tokenize shares\r\n   */\r\n  function tokenizeShares(\r\n    BridgeToken _token,\r\n    bytes32 _hash,\r\n    bytes32[] _sigR,\r\n    bytes32[] _sigS,\r\n    uint8[] _sigV) public\r\n    thresholdRequired(address(this), 0,\r\n      abi.encodePacked(tokenizeHash(_token, _hash)),\r\n      0, threshold, _sigR, _sigS, _sigV)\r\n  {\r\n    updateReplayProtection();\r\n    token = _token;\r\n\r\n    emit ShareTokenization(_token, _hash);\r\n  }\r\n\r\n  /**\r\n   * @dev add board meeting\r\n   */\r\n  function addBoardMeeting(\r\n    bytes32 _hash,\r\n    bytes32[] _sigR,\r\n    bytes32[] _sigS,\r\n    uint8[] _sigV) public\r\n    thresholdRequired(address(this), 0,\r\n      abi.encodePacked(_hash),\r\n      0, threshold, _sigR, _sigS, _sigV)\r\n  {\r\n    emit BoardMeetingHash(_hash);\r\n  }\r\n\r\n  event ShareTokenization(BridgeToken token, bytes32 hash);\r\n  event BoardMeetingHash(bytes32 hash);\r\n\r\n}\r\n\r\n// File: contracts/mps/MPSBoardSig.sol\r\n\r\n/**\r\n * @title MPSBoardSig\r\n * @dev MPSBoardSig contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n */\r\ncontract MPSBoardSig is BoardSig {\r\n\r\n  string public companyName = \"MtPelerin Group SA\";\r\n  string public country = \"Switzerland\";\r\n  string public registeredNumber = \"CHE-188.552.084\";\r\n\r\n  /**\r\n   * @dev constructor function\r\n   */\r\n  constructor(address[] _addresses, uint8 _threshold) public\r\n    BoardSig(_addresses, _threshold)\r\n  {\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"readERC20Destination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"buildHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sigR\",\"type\":\"bytes32[]\"},{\"name\":\"_sigS\",\"type\":\"bytes32[]\"},{\"name\":\"_sigV\",\"type\":\"uint8[]\"},{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registeredNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_sigR\",\"type\":\"bytes32[]\"},{\"name\":\"_sigS\",\"type\":\"bytes32[]\"},{\"name\":\"_sigV\",\"type\":\"uint8[]\"}],\"name\":\"tokenizeShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_validity\",\"type\":\"uint256\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"}],\"name\":\"recoverAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_validity\",\"type\":\"uint256\"},{\"name\":\"_sigR\",\"type\":\"bytes32[]\"},{\"name\":\"_sigS\",\"type\":\"bytes32[]\"},{\"name\":\"_sigV\",\"type\":\"uint8[]\"}],\"name\":\"reviewSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_sigR\",\"type\":\"bytes32[]\"},{\"name\":\"_sigS\",\"type\":\"bytes32[]\"},{\"name\":\"_sigV\",\"type\":\"uint8[]\"}],\"name\":\"addBoardMeeting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"replayProtection\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"readERC20Value\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"tokenizeHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"country\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"readSelector\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_threshold\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"ShareTokenization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"BoardMeetingHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Execution\",\"type\":\"event\"}]","ContractName":"MPSBoardSig","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000f38158446403cf3adcd9cadd852242f9b4190937000000000000000000000000773e07b618694b14b1ba740acdc3d1bae1ab05600000000000000000000000000e2f5d1736215c9c892b95b58a9f6bf4de6e82e2","Library":"","SwarmSource":"bzzr://d4c8bb4b9749e8b9d9cbc40ffaf8320058fedc8028678c04ecc56f7a20ba9be2"}]}