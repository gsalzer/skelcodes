{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n    ================================\r\n    Disclaimer: Данный контракт - всего лишь игра и не является профессиональным инструментом заработка.\r\n    Отнеситесь к этому с забавой, пользуйтесь с умом и не забывайте, что вклад денег в фаст-контракты - это всегда крайне рисково. \r\n    Мы не призываем людей относится к данному контракту, как к инвестиционному проекту.\r\n    ================================\r\n\r\n  Gradual.pro - Плавно растущий и долго живущий умножитель КАЖДЫЙ ДЕНЬ с розыгрыванием ДЖЕКПОТА!, который возвращает 121% от вашего депозита!\r\n\r\n  Маленький лимит на депозит избавляет от проблем с КИТАМИ, которые очень сильно тормозили предыдущую версию контракта и значительно продлевает срок его жизни!\r\n\r\n  Автоматические выплаты!\r\n  Полные отчеты о потраченых на рекламу средствах в группе!\r\n  Без ошибок, дыр, автоматический - для выплат НЕ НУЖНА администрация!\r\n  Создан и проверен профессионалами!\r\n  Код полностью документирован на русском языке, каждая строчка понятна!\r\n\r\n  Вебсайт: http://gradual.pro/\r\n  Канал в телеграмме: https://t.me/gradualpro\r\n\r\n  1. Пошлите любую ненулевую сумму на адрес контракта\r\n     - сумма от 0.01 до 1 ETH\r\n     - gas limit минимум 250000\r\n     - вы встанете в очередь\r\n  2. Немного подождите\r\n  3. ...\r\n  4. PROFIT! Вам пришло 121% от вашего депозита.\r\n  5. После 21:00 МСК контракт выплачивает 25% от накопленного джекпота последнему вкладчику.\r\n  6. Остальной джекпот распределяется всем остальным в обратной очереди по 121% от каждого вклада.\r\n  7. Затем очередь обнуляется и запускается заново!\r\n\r\n\r\n  Как это возможно?\r\n  1. Первый инвестор в очереди (вы станете первым очень скоро) получает выплаты от\r\n     новых инвесторов до тех пор, пока не получит 121% от своего депозита\r\n  2. Выплаты могут приходить несколькими частями или все сразу\r\n  3. Как только вы получаете 121% от вашего депозита, вы удаляетесь из очереди\r\n  4. Вы можете делать несколько депозитов сразу\r\n  5. Баланс этого контракта состовляет сумму джекпота на данный момент!\r\n\r\n     Таким образом, последние платят первым, и инвесторы, достигшие выплат 121% от депозита,\r\n     удаляются из очереди, уступая место остальным\r\n\r\n              новый инвестор --|            совсем новый инвестор --|\r\n                 инвестор5     |                новый инвестор      |\r\n                 инвестор4     |     =======>      инвестор5        |\r\n                 инвестор3     |                   инвестор4        |\r\n (част. выплата) инвестор2    <|                   инвестор3        |\r\n(полная выплата) инвестор1   <-|                   инвестор2   <----|  (доплата до 121%)\r\n\r\n*/\r\n\r\ncontract Restarter {\r\n    // Время отсроченного старта (timestamp)\r\n    uint constant public FIRST_START_TIMESTAMP = 1541008800;\r\n\r\n    // Интервал рестарта\r\n    uint constant public RESTART_INTERVAL = 24 hours; // 24 hours\r\n\r\n    // Адрес кошелька для оплаты рекламы\r\n    address constant private ADS_SUPPORT = 0x79C188C8d8c7dEc9110c340140F46bE10854E754;\r\n\r\n    // Адрес кошелька для оплаты технической поддержки информационных каналов\r\n    address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c;\r\n\r\n    // Процент депозита на рекламу 2%\r\n    uint constant public ADS_PERCENT = 2;\r\n\r\n    // Процент депозита на тех поддержку 1%\r\n    uint constant public TECH_PERCENT = 1;\r\n\r\n    // Процент депозита в Джекпот 3%\r\n    uint constant public JACKPOT_PERCENT = 3;\r\n\r\n    // Процент который перечислится победителю джекпота (последний вкладчик перед рестартом)\r\n    uint constant public JACKPOT_WINNER_PERCENT = 25;\r\n    \r\n    // Процент выплат всем участникам\r\n    uint constant public MULTIPLIER = 121;\r\n\r\n    // Максимальный размер депозита = 1 эфир, чтобы каждый смог учавстовать и киты не тормозили и не пугали вкладчиков\r\n    uint constant public MAX_LIMIT = 1 ether;\r\n\r\n    // Минимальный размер депозита = 0.01 эфира\r\n    uint constant public MIN_LIMIT = 0.01 ether;\r\n\r\n    // Минимальный лимит газа\r\n    uint constant public MINIMAL_GAS_LIMIT = 250000;\r\n\r\n    // Структура Deposit содержит информацию о депозите\r\n    struct Deposit {\r\n        address depositor; // Владелец депозита\r\n        uint128 deposit;   // Сумма депозита\r\n        uint128 expect;    // Сумма выплаты (моментально 121% от депозита)\r\n    }\r\n\r\n    // Событие, чтобы моментально показывать уведомления на сайте\r\n    event Restart(uint timestamp);\r\n\r\n    // Очередь\r\n    Deposit[] private _queue;\r\n\r\n    // Номер обрабатываемого депозита, можно следить в разделе Read contract\r\n    uint public currentReceiverIndex = 0;\r\n\r\n    // Сумма джекпота\r\n    uint public jackpotAmount = 0;\r\n\r\n    // Храним время последнего старта, чтобы знать когда делать рестарт\r\n    uint public lastStartTimestamp;\r\n\r\n    uint public queueCurrentLength = 0;\r\n\r\n    // При создании контракта\r\n    constructor() public {\r\n        // Записываем время первого старта\r\n        lastStartTimestamp = FIRST_START_TIMESTAMP;\r\n    }\r\n\r\n    // Данная функция получает все депозиты, сохраняет их и производит моментальные выплаты\r\n    function () public payable {\r\n        // Проверяем, если отсроченый старт начался\r\n        require(now >= FIRST_START_TIMESTAMP, \"Not started yet!\");\r\n\r\n        // Проверяем минимальный лимит газа, иначе отменяем депозит и возвращаем деньги вкладчику\r\n        require(gasleft() >= MINIMAL_GAS_LIMIT, \"We require more gas!\");\r\n\r\n        // Проверяем максимальную сумму вклада\r\n        require(msg.value <= MAX_LIMIT, \"Deposit is too big!\");\r\n\r\n        // Проверяем минимальную сумму вклада\r\n        require(msg.value >= MIN_LIMIT, \"Deposit is too small!\");\r\n\r\n        // Проверяем, если нужно сделать рестарт\r\n        if (now >= lastStartTimestamp + RESTART_INTERVAL) {\r\n            // Записываем время нового рестарта\r\n            lastStartTimestamp += (now - lastStartTimestamp) / RESTART_INTERVAL * RESTART_INTERVAL;\r\n            // Выплачиваем Джекпот\r\n            _payoutJackpot();\r\n            _clearQueue();\r\n            // Вызываем событие\r\n            emit Restart(now);\r\n        }\r\n\r\n        // Добавляем депозит в очередь, записываем что ему нужно выплатить % от суммы депозита\r\n        _insertQueue(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * MULTIPLIER / 100)));\r\n\r\n        // Увеличиваем Джекпот\r\n        jackpotAmount += msg.value * JACKPOT_PERCENT / 100;\r\n\r\n        // Отправляем процент на продвижение проекта\r\n        uint ads = msg.value * ADS_PERCENT / 100;\r\n        ADS_SUPPORT.transfer(ads);\r\n\r\n        // Отправляем процент на техническую поддержку проекта\r\n        uint tech = msg.value * TECH_PERCENT / 100;\r\n        TECH_SUPPORT.transfer(tech);\r\n\r\n        // Вызываем функцию оплаты первым в очереди депозитам\r\n        _pay();\r\n    }\r\n\r\n    // Функция используется для оплаты первым в очереди депозитам\r\n    // Каждая новая транзация обрабатывает от 1 до 4+ вкладчиков в начале очереди \r\n    // В зависимости от оставшегося газа\r\n    function _pay() private {\r\n        // Попытаемся послать все деньги имеющиеся на контракте первым в очереди вкладчикам за вычетом суммы Джекпота\r\n        uint128 money = uint128(address(this).balance) - uint128(jackpotAmount);\r\n\r\n        // Проходим по всей очереди\r\n        for (uint i = 0; i < queueCurrentLength; i++) {\r\n\r\n            // Достаем номер первого в очереди депозита\r\n            uint idx = currentReceiverIndex + i;\r\n\r\n            // Достаем информацию о первом депозите\r\n            Deposit storage dep = _queue[idx];\r\n\r\n            // Если у нас есть достаточно денег для полной выплаты, то выплачиваем ему все\r\n            if(money >= dep.expect) {\r\n                // Отправляем ему деньги\r\n                dep.depositor.transfer(dep.expect);\r\n                // Обновляем количество оставшихся денег\r\n                money -= dep.expect;\r\n            } else {\r\n                // Попадаем сюда, если у нас не достаточно денег выплатить все, а лишь часть\r\n                // Отправляем все оставшееся\r\n                dep.depositor.transfer(money);\r\n                // Обновляем количество оставшихся денег\r\n                dep.expect -= money;\r\n                // Выходим из цикла\r\n                break;\r\n            }\r\n\r\n            // Проверяем если еще остался газ, и если его нет, то выходим из цикла\r\n            if (gasleft() <= 50000) {\r\n                //  Следующий вкладчик осуществит выплату следующим в очереди\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Обновляем номер депозита ставшего первым в очереди\r\n        currentReceiverIndex += i;\r\n    }\r\n\r\n    function _payoutJackpot() private {\r\n        // Попытаемся послать все деньги имеющиеся на контракте первым в очереди вкладчикам за вычетом суммы Джекпота\r\n        uint128 money = uint128(jackpotAmount);\r\n\r\n        // Перечисляем 25% с джекпота победителю\r\n        Deposit storage dep = _queue[queueCurrentLength - 1];\r\n\r\n        dep.depositor.transfer(uint128(jackpotAmount * JACKPOT_WINNER_PERCENT / 100));\r\n        money -= uint128(jackpotAmount * JACKPOT_WINNER_PERCENT / 100);\r\n\r\n        // Проходим по всей очереди с конца\r\n        for (uint i = queueCurrentLength - 2; i < queueCurrentLength && i >= currentReceiverIndex; i--) {\r\n            // Достаем информацию о последнем депозите\r\n            dep = _queue[i];\r\n\r\n            // Если у нас есть достаточно денег для полной выплаты, то выплачиваем ему все\r\n            if(money >= dep.expect) {\r\n                // Отправляем ему деньги\r\n                dep.depositor.transfer(dep.expect);\r\n                // Обновляем количество оставшихся денег\r\n                money -= dep.expect;\r\n            } else if (money > 0) {\r\n                // Попадаем сюда, если у нас не достаточно денег выплатить все, а лишь часть\r\n                // Отправляем все оставшееся\r\n                dep.depositor.transfer(money);\r\n                // Обновляем количество оставшихся денег\r\n                dep.expect -= money;\r\n                money = 0;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Обнуляем джекпот на новый раунд\r\n        jackpotAmount = 0;\r\n        // Обнуляем очередь\r\n        currentReceiverIndex = 0;\r\n    }\r\n\r\n    function _insertQueue(Deposit deposit) private {\r\n        if (queueCurrentLength == _queue.length) {\r\n            _queue.length += 1;\r\n        }\r\n        _queue[queueCurrentLength++] = deposit;\r\n    }\r\n\r\n    function _clearQueue() private {\r\n        queueCurrentLength = 0;\r\n    }\r\n\r\n    // Показывает информацию о депозите по его номеру (idx), можно следить в разделе Read contract\r\n    // Вы можете получить номер депозита  (idx) вызвав функцию getDeposits()\r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\r\n        Deposit storage dep = _queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expect);\r\n    }\r\n\r\n    // Показывает количество вкладов определенного инвестора\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i < queueCurrentLength; ++i){\r\n            if(_queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    // Показывает все депозиты (index, deposit, expect) определенного инвестора, можно следить в разделе Read contract\r\n    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\r\n        uint c = getDepositsCount(depositor);\r\n\r\n        idxs = new uint[](c);\r\n        deposits = new uint128[](c);\r\n        expects = new uint128[](c);\r\n\r\n        if(c > 0) {\r\n            uint j = 0;\r\n            for(uint i = currentReceiverIndex; i < queueCurrentLength; ++i){\r\n                Deposit storage dep = _queue[i];\r\n                if(dep.depositor == depositor){\r\n                    idxs[j] = i;\r\n                    deposits[j] = dep.deposit;\r\n                    expects[j] = dep.expect;\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Показывает длинну очереди, можно следить в разделе Read contract\r\n    function getQueueLength() public view returns (uint) {\r\n        return queueCurrentLength - currentReceiverIndex;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_WINNER_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMAL_GAS_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"name\":\"idxs\",\"type\":\"uint256[]\"},{\"name\":\"deposits\",\"type\":\"uint128[]\"},{\"name\":\"expects\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_START_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADS_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TECH_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESTART_INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queueCurrentLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Restart\",\"type\":\"event\"}]","ContractName":"Restarter","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5da5912a51bae7cc4905a0ecac203744ea8ef3c30d82d6b44ac597192d02ac31"}]}