{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/lib/ownership/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n       require(newOwner != address(0));\r\n       emit OwnershipTransferred(owner, newOwner);\r\n       owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n\tfunction addImmutableContract(string contractName, address newAddress) external;\r\n\tfunction updateContract(string contractName, address newAddress) external;\r\n\tfunction getContractName(uint index) public view returns (string);\r\n\tfunction getContract(string contractName) public view returns (address);\r\n\tfunction updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/lib/ownership/Upgradable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Upgradable {\r\n\r\n\taddress coordinatorAddr;\r\n\tZapCoordinatorInterface coordinator;\r\n\r\n\tconstructor(address c) public{\r\n\t\tcoordinatorAddr = c;\r\n\t\tcoordinator = ZapCoordinatorInterface(c);\r\n\t}\r\n\r\n    function updateDependencies() external coordinatorOnly {\r\n       _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal;\r\n\r\n    modifier coordinatorOnly() {\r\n    \trequire(msg.sender == coordinatorAddr, \"Error: Coordinator Only Function\");\r\n    \t_;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/lifecycle/Destructible.sol\r\n\r\ncontract Destructible is Ownable {\r\n\tfunction selfDestruct() public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n}\r\n\r\n// File: contracts/platform/bondage/BondageInterface.sol\r\n\r\ncontract BondageInterface {\r\n    function bond(address, bytes32, uint256) external returns(uint256);\r\n    function unbond(address, bytes32, uint256) external returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256) external returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256) external returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256) external returns (bool);\r\n    function returnDots(address, address, bytes32, uint256) external returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256) external view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function getDotsIssued(address, bytes32) public view returns (uint256);\r\n    function getBoundDots(address, address, bytes32) public view returns (uint256);\r\n    function getZapBound(address, bytes32) public view returns (uint256);\r\n    function dotLimit( address, bytes32) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/arbiter/ArbiterInterface.sol\r\n\r\ncontract ArbiterInterface {\r\n    function initiateSubscription(address, bytes32, bytes32[], uint256, uint64) public;\r\n    function getSubscription(address, address, bytes32) public view returns (uint64, uint96, uint96);\r\n    function endSubscriptionProvider(address, bytes32) public;\r\n    function endSubscriptionSubscriber(address, bytes32) public;\r\n    function passParams(address receiver, bytes32 endpoint, bytes32[] params) public;\r\n}\r\n\r\n// File: contracts/platform/database/DatabaseInterface.sol\r\n\r\ncontract DatabaseInterface is Ownable {\r\n\tfunction setStorageContract(address _storageContract, bool _allowed) public;\r\n\t/*** Bytes32 ***/\r\n\tfunction getBytes32(bytes32 key) external view returns(bytes32);\r\n\tfunction setBytes32(bytes32 key, bytes32 value) external;\r\n\t/*** Number **/\r\n\tfunction getNumber(bytes32 key) external view returns(uint256);\r\n\tfunction setNumber(bytes32 key, uint256 value) external;\r\n\t/*** Bytes ***/\r\n\tfunction getBytes(bytes32 key) external view returns(bytes);\r\n\tfunction setBytes(bytes32 key, bytes value) external;\r\n\t/*** String ***/\r\n\tfunction getString(bytes32 key) external view returns(string);\r\n\tfunction setString(bytes32 key, string value) external;\r\n\t/*** Bytes Array ***/\r\n\tfunction getBytesArray(bytes32 key) external view returns (bytes32[]);\r\n\tfunction getBytesArrayIndex(bytes32 key, uint256 index) external view returns (bytes32);\r\n\tfunction getBytesArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushBytesArray(bytes32 key, bytes32 value) external;\r\n\tfunction setBytesArrayIndex(bytes32 key, uint256 index, bytes32 value) external;\r\n\tfunction setBytesArray(bytes32 key, bytes32[] value) external;\r\n\t/*** Int Array ***/\r\n\tfunction getIntArray(bytes32 key) external view returns (int[]);\r\n\tfunction getIntArrayIndex(bytes32 key, uint256 index) external view returns (int);\r\n\tfunction getIntArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushIntArray(bytes32 key, int value) external;\r\n\tfunction setIntArrayIndex(bytes32 key, uint256 index, int value) external;\r\n\tfunction setIntArray(bytes32 key, int[] value) external;\r\n\t/*** Address Array ***/\r\n\tfunction getAddressArray(bytes32 key) external view returns (address[]);\r\n\tfunction getAddressArrayIndex(bytes32 key, uint256 index) external view returns (address);\r\n\tfunction getAddressArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushAddressArray(bytes32 key, address value) external;\r\n\tfunction setAddressArrayIndex(bytes32 key, uint256 index, address value) external;\r\n\tfunction setAddressArray(bytes32 key, address[] value) external;\r\n}\r\n\r\n// File: contracts/platform/arbiter/Arbiter.sol\r\n\r\n// v1.0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Arbiter is Destructible, ArbiterInterface, Upgradable {\r\n    // Called when a data purchase is initiated\r\n    event DataPurchase(\r\n        address indexed provider,          // Etheruem address of the provider\r\n        address indexed subscriber,        // Ethereum address of the subscriber\r\n        uint256 publicKey,                 // Public key of the subscriber\r\n        uint256 indexed amount,            // Amount (in 1/100 ZAP) of ethereum sent\r\n        bytes32[] endpointParams,          // Endpoint specific(nonce,encrypted_uuid),\r\n        bytes32 endpoint                   // Endpoint specifier\r\n    );\r\n\r\n    // Called when a data subscription is ended by either provider or terminator\r\n    event DataSubscriptionEnd(\r\n        address indexed provider,                      // Provider from the subscription\r\n        address indexed subscriber,                    // Subscriber from the subscription\r\n        SubscriptionTerminator indexed terminator      // Which terminated the contract\r\n    ); \r\n\r\n    // Called when party passes arguments to another party\r\n    event ParamsPassed(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        bytes32 endpoint,\r\n        bytes32[] params\r\n    );\r\n\r\n    // Used to specify who is the terminator of a contract\r\n    enum SubscriptionTerminator { Provider, Subscriber }\r\n\r\n    BondageInterface bondage;\r\n    address public bondageAddress;\r\n\r\n    // database address and reference\r\n    DatabaseInterface public db;\r\n\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        bondageAddress = coordinator.getContract(\"BONDAGE\");\r\n        bondage = BondageInterface(bondageAddress);\r\n\r\n        address databaseAddress = coordinator.getContract(\"DATABASE\");\r\n        db = DatabaseInterface(databaseAddress);\r\n    }\r\n\r\n    //@dev broadcast parameters from sender to offchain receiver\r\n    /// @param receiver address\r\n    /// @param endpoint Endpoint specifier\r\n    /// @param params arbitrary params to be passed\r\n    function passParams(address receiver, bytes32 endpoint, bytes32[] params) public {\r\n\r\n        emit ParamsPassed(msg.sender, receiver, endpoint, params);    \r\n    }\r\n\r\n    /// @dev subscribe to specified number of blocks of provider\r\n    /// @param providerAddress Provider address\r\n    /// @param endpoint Endpoint specifier\r\n    /// @param endpointParams Endpoint specific params\r\n    /// @param publicKey Public key of the purchaser\r\n    /// @param blocks Number of blocks subscribed, 1block=1dot\r\n    function initiateSubscription(\r\n        address providerAddress,   //\r\n        bytes32 endpoint,          //\r\n        bytes32[] endpointParams,  //\r\n        uint256 publicKey,         // Public key of the purchaser\r\n        uint64 blocks              //\r\n    ) \r\n        public \r\n    {   \r\n        // Must be atleast one block\r\n        require(blocks > 0, \"Error: Must be at least one block\");\r\n\r\n        // Can't reinitiate a currently active contract\r\n        require(getDots(providerAddress, msg.sender, endpoint) == 0, \"Error: Cannot reinstantiate a currently active contract\");\r\n\r\n        // Escrow the necessary amount of dots\r\n        bondage.escrowDots(msg.sender, providerAddress, endpoint, blocks);\r\n        \r\n        // Initiate the subscription struct\r\n        setSubscription(\r\n            providerAddress,\r\n            msg.sender,\r\n            endpoint,\r\n            blocks,\r\n            uint96(block.number),\r\n            uint96(block.number) + uint96(blocks)\r\n        );\r\n\r\n        emit DataPurchase(\r\n            providerAddress,\r\n            msg.sender,\r\n            publicKey,\r\n            blocks,\r\n            endpointParams,\r\n            endpoint\r\n        );\r\n    }\r\n\r\n    /// @dev get subscription info\r\n    function getSubscription(address providerAddress, address subscriberAddress, bytes32 endpoint)\r\n        public\r\n        view\r\n        returns (uint64 dots, uint96 blockStart, uint96 preBlockEnd)\r\n    {\r\n        return (\r\n            getDots(providerAddress, subscriberAddress, endpoint),\r\n            getBlockStart(providerAddress, subscriberAddress, endpoint),\r\n            getPreBlockEnd(providerAddress, subscriberAddress, endpoint)\r\n        );\r\n    }\r\n\r\n    /// @dev Finish the data feed from the provider\r\n    function endSubscriptionProvider(        \r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public \r\n    {\r\n        // Emit an event on success about who ended the contract\r\n        if (endSubscription(msg.sender, subscriberAddress, endpoint))\r\n            emit DataSubscriptionEnd(\r\n                msg.sender, \r\n                subscriberAddress, \r\n                SubscriptionTerminator.Provider\r\n            );\r\n    }\r\n\r\n    /// @dev Finish the data feed from the subscriber\r\n    function endSubscriptionSubscriber(\r\n        address providerAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public \r\n    {\r\n        // Emit an event on success about who ended the contract\r\n        if (endSubscription(providerAddress, msg.sender, endpoint))\r\n            emit DataSubscriptionEnd(\r\n                providerAddress,\r\n                msg.sender,\r\n                SubscriptionTerminator.Subscriber\r\n            );\r\n    }\r\n\r\n    /// @dev Finish the data feed\r\n    function endSubscription(        \r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        private\r\n        returns (bool)\r\n    {   \r\n        // get the total value/block length of this subscription\r\n        uint256 dots = getDots(providerAddress, subscriberAddress, endpoint);\r\n        uint256 preblockend = getPreBlockEnd(providerAddress, subscriberAddress, endpoint);\r\n        // Make sure the subscriber has a subscription\r\n        require(dots > 0, \"Error: Subscriber must have a subscription\");\r\n\r\n        if (block.number < preblockend) {\r\n            // Subscription ended early\r\n            uint256 earnedDots = block.number - getBlockStart(providerAddress, subscriberAddress, endpoint);\r\n            uint256 returnedDots = dots - earnedDots;\r\n\r\n            // Transfer the earned dots to the provider\r\n            bondage.releaseDots(\r\n                subscriberAddress,\r\n                providerAddress,\r\n                endpoint,\r\n                earnedDots\r\n            );\r\n            //  Transfer the returned dots to the subscriber\r\n            bondage.returnDots(\r\n                subscriberAddress,\r\n                providerAddress,\r\n                endpoint,\r\n                returnedDots\r\n            );\r\n        } else {\r\n            // Transfer all the dots\r\n            bondage.releaseDots(\r\n                subscriberAddress,\r\n                providerAddress,\r\n                endpoint,\r\n                dots\r\n            );\r\n        }\r\n        // Kill the subscription\r\n        deleteSubscription(providerAddress, subscriberAddress, endpoint);\r\n        return true;\r\n    }    \r\n\r\n\r\n    /*** --- *** STORAGE METHODS *** --- ***/\r\n\r\n    /// @dev get subscriber dots remaining for specified provider endpoint\r\n    function getDots(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint64)\r\n    {\r\n        return uint64(db.getNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'dots'))));\r\n    }\r\n\r\n    /// @dev get first subscription block number\r\n    function getBlockStart(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint96)\r\n    {\r\n        return uint96(db.getNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'blockStart'))));\r\n    }\r\n\r\n    /// @dev get last subscription block number\r\n    function getPreBlockEnd(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint96)\r\n    {\r\n        return uint96(db.getNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'preBlockEnd'))));\r\n    }\r\n\r\n    /**** Set Methods ****/\r\n\r\n    /// @dev store new subscription\r\n    function setSubscription(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint,\r\n        uint64 dots,\r\n        uint96 blockStart,\r\n        uint96 preBlockEnd\r\n    )\r\n        private\r\n    {\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'dots')), dots);\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'blockStart')), uint256(blockStart));\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'preBlockEnd')), uint256(preBlockEnd));\r\n    }\r\n\r\n    /**** Delete Methods ****/\r\n\r\n    /// @dev remove subscription\r\n    function deleteSubscription(\r\n        address providerAddress,\r\n        address subscriberAddress,\r\n        bytes32 endpoint\r\n    )\r\n        private\r\n    {\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'dots')), 0);\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'blockStart')), uint256(0));\r\n        db.setNumber(keccak256(abi.encodePacked('subscriptions', providerAddress, subscriberAddress, endpoint, 'preBlockEnd')), uint256(0));\r\n    }\r\n}\r\n\r\n    /*************************************** STORAGE ****************************************\r\n    * 'holders', holderAddress, 'initialized', oracleAddress => {uint256} 1 -> provider-subscriber initialized, 0 -> not initialized \r\n    * 'holders', holderAddress, 'bonds', oracleAddress, endpoint => {uint256} number of dots this address has bound to this endpoint\r\n    * 'oracles', oracleAddress, endpoint, 'broker' => {address} address of endpoint broker, 0 if none\r\n    * 'escrow', holderAddress, oracleAddress, endpoint => {uint256} amount of Zap that have been escrowed\r\n    * 'totalBound', oracleAddress, endpoint => {uint256} amount of Zap bound to this endpoint\r\n    * 'totalIssued', oracleAddress, endpoint => {uint256} number of dots issued by this endpoint\r\n    * 'holders', holderAddress, 'oracleList' => {address[]} array of oracle addresses associated with this holder\r\n    ****************************************************************************************/","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"providerAddress\",\"type\":\"address\"},{\"name\":\"subscriberAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getBlockStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"db\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"providerAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"endSubscriptionSubscriber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"providerAddress\",\"type\":\"address\"},{\"name\":\"subscriberAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getSubscription\",\"outputs\":[{\"name\":\"dots\",\"type\":\"uint64\"},{\"name\":\"blockStart\",\"type\":\"uint96\"},{\"name\":\"preBlockEnd\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"params\",\"type\":\"bytes32[]\"}],\"name\":\"passParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"providerAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"endpointParams\",\"type\":\"bytes32[]\"},{\"name\":\"publicKey\",\"type\":\"uint256\"},{\"name\":\"blocks\",\"type\":\"uint64\"}],\"name\":\"initiateSubscription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"providerAddress\",\"type\":\"address\"},{\"name\":\"subscriberAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getDots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bondageAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"providerAddress\",\"type\":\"address\"},{\"name\":\"subscriberAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getPreBlockEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscriberAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"endSubscriptionProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"c\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"publicKey\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endpointParams\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"DataPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"terminator\",\"type\":\"uint8\"}],\"name\":\"DataSubscriptionEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"params\",\"type\":\"bytes32[]\"}],\"name\":\"ParamsPassed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Arbiter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a16","Library":"","SwarmSource":"bzzr://32713ae0afa70fb54839660e63715532f180369847ed8ef7970967857cbd06bc"}]}