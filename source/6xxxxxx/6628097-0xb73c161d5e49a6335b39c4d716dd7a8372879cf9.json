{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @notice Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @notice Multiplies two numbers, throws on overflow.\r\n  * @param a Multiplier\r\n  * @param b Multiplicand\r\n  * @return {\"result\" : \"Returns product\"}\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 result) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"Error: Unsafe multiplication operation!\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @notice Integer division of two numbers, truncating the quotient.\r\n  * @param a Dividend\r\n  * @param b Divisor\r\n  * @return {\"result\" : \"Returns quotient\"}\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 result) {\r\n    // @dev require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // @dev require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @notice Subtracts two numbers, throws on underflow.\r\n  * @param a Subtrahend\r\n  * @param b Minuend\r\n  * @return {\"result\" : \"Returns difference\"}\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 result) {\r\n    // @dev throws on overflow (i.e. if subtrahend is greater than minuend)\r\n    require(b <= a, \"Error: Unsafe subtraction operation!\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @notice Adds two numbers, throws on overflow.\r\n  * @param a First addend\r\n  * @param b Second addend\r\n  * @return {\"result\" : \"Returns summation\"}\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 result) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"Error: Unsafe addition operation!\");\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n\r\nCOPYRIGHT 2018 Token, Inc.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n@title Ownable\r\n@dev The Ownable contract has an owner address, and provides basic authorization control\r\nfunctions, this simplifies the implementation of \"user permissions\".\r\n\r\n\r\n */\r\ncontract Ownable {\r\n\r\n  mapping(address => bool) public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  event AllowOwnership(address indexed allowedAddress);\r\n  event RevokeOwnership(address indexed allowedAddress);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner[msg.sender] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner[msg.sender], \"Error: Transaction sender is not allowed by the contract.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   * @return {\"success\" : \"Returns true when successfully transferred ownership\"}\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner returns (bool success) {\r\n    require(newOwner != address(0), \"Error: newOwner cannot be null!\");\r\n    emit OwnershipTransferred(msg.sender, newOwner);\r\n    owner[newOwner] = true;\r\n    owner[msg.sender] = false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows interface contracts and accounts to access contract methods (e.g. Storage contract)\r\n   * @param allowedAddress The address of new owner\r\n   * @return {\"success\" : \"Returns true when successfully allowed ownership\"}\r\n   */\r\n  function allowOwnership(address allowedAddress) public onlyOwner returns (bool success) {\r\n    owner[allowedAddress] = true;\r\n    emit AllowOwnership(allowedAddress);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows interface contracts and accounts to access contract methods (e.g. Storage contract)\r\n   * @param allowedAddress The address to disallow ownership\r\n   * @return {\"success\" : \"Returns true when successfully allowed ownership\"}\r\n   */\r\n  function removeOwnership(address allowedAddress) public onlyOwner returns (bool success) {\r\n    owner[allowedAddress] = false;\r\n    emit RevokeOwnership(allowedAddress);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n\r\nCOPYRIGHT 2018 Token, Inc.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n@title TokenIOStorage - Serves as derived contract for TokenIO contract and\r\nis used to upgrade interfaces in the event of deprecating the main contract.\r\n\r\n@author Ryan Tate <ryan.tate@token.io>, Sean Pollock <sean.pollock@token.io>\r\n\r\n@notice Storage contract\r\n\r\n@dev In the event that the main contract becomes deprecated, the upgraded contract\r\nwill be set as the owner of this contract, and use this contract's storage to\r\nmaintain data consistency between contract.\r\n\r\n@notice NOTE: This contract is based on the RocketPool Storage Contract,\r\nfound here: https://github.com/rocket-pool/rocketpool/blob/master/contracts/RocketStorage.sol\r\nAnd this medium article: https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d\r\n\r\nChanges:\r\n - setting primitive mapping view to internal;\r\n - setting method views to public;\r\n\r\n @dev NOTE: When deprecating the main TokenIO contract, the upgraded contract\r\n must take ownership of the TokenIO contract, it will require using the public methods\r\n to update changes to the underlying data. The updated contract must use a\r\n standard call to original TokenIO contract such that the  request is made from\r\n the upgraded contract and not the transaction origin (tx.origin) of the signing\r\n account.\r\n\r\n\r\n @dev NOTE: The reasoning for using the storage contract is to abstract the interface\r\n from the data of the contract on chain, limiting the need to migrate data to\r\n new contracts.\r\n\r\n*/\r\ncontract TokenIOStorage is Ownable {\r\n\r\n\r\n    /// @dev mapping for Primitive Data Types;\r\n\t\t/// @notice primitive data mappings have `internal` view;\r\n\t\t/// @dev only the derived contract can use the internal methods;\r\n\t\t/// @dev key == `keccak256(param1, param2...)`\r\n\t\t/// @dev Nested mapping can be achieved using multiple params in keccak256 hash;\r\n    mapping(bytes32 => uint256)    internal uIntStorage;\r\n    mapping(bytes32 => string)     internal stringStorage;\r\n    mapping(bytes32 => address)    internal addressStorage;\r\n    mapping(bytes32 => bytes)      internal bytesStorage;\r\n    mapping(bytes32 => bool)       internal boolStorage;\r\n    mapping(bytes32 => int256)     internal intStorage;\r\n\r\n    constructor() public {\r\n\t\t\t\t/// @notice owner is set to msg.sender by default\r\n\t\t\t\t/// @dev consider removing in favor of setting ownership in inherited\r\n\t\t\t\t/// contract\r\n        owner[msg.sender] = true;\r\n    }\r\n\r\n    /// @dev Set Key Methods\r\n\r\n    /**\r\n     * @notice Set value for Address associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @param _value The Address value to be set\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function setAddress(bytes32 _key, address _value) public onlyOwner returns (bool success) {\r\n        addressStorage[_key] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Set value for Uint associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @param _value The Uint value to be set\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {\r\n        uIntStorage[_key] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Set value for String associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @param _value The String value to be set\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function setString(bytes32 _key, string _value) public onlyOwner returns (bool success) {\r\n        stringStorage[_key] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Set value for Bytes associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @param _value The Bytes value to be set\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function setBytes(bytes32 _key, bytes _value) public onlyOwner returns (bool success) {\r\n        bytesStorage[_key] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Set value for Bool associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @param _value The Bool value to be set\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function setBool(bytes32 _key, bool _value) public onlyOwner returns (bool success) {\r\n        boolStorage[_key] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Set value for Int associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @param _value The Int value to be set\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function setInt(bytes32 _key, int _value) public onlyOwner returns (bool success) {\r\n        intStorage[_key] = _value;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Delete Key Methods\r\n\t\t/// @dev delete methods may be unnecessary; Use set methods to set values\r\n\t\t/// to default?\r\n\r\n    /**\r\n     * @notice Delete value for Address associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function deleteAddress(bytes32 _key) public onlyOwner returns (bool success) {\r\n        delete addressStorage[_key];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delete value for Uint associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function deleteUint(bytes32 _key) public onlyOwner returns (bool success) {\r\n        delete uIntStorage[_key];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delete value for String associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function deleteString(bytes32 _key) public onlyOwner returns (bool success) {\r\n        delete stringStorage[_key];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delete value for Bytes associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function deleteBytes(bytes32 _key) public onlyOwner returns (bool success) {\r\n        delete bytesStorage[_key];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delete value for Bool associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function deleteBool(bytes32 _key) public onlyOwner returns (bool success) {\r\n        delete boolStorage[_key];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delete value for Int associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"success\" : \"Returns true when successfully called from another contract\" }\r\n     */\r\n    function deleteInt(bytes32 _key) public onlyOwner returns (bool success) {\r\n        delete intStorage[_key];\r\n        return true;\r\n    }\r\n\r\n    /// @dev Get Key Methods\r\n\r\n    /**\r\n     * @notice Get value for Address associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"_value\" : \"Returns the Address value associated with the id key\" }\r\n     */\r\n    function getAddress(bytes32 _key) public view returns (address _value) {\r\n        return addressStorage[_key];\r\n    }\r\n\r\n    /**\r\n     * @notice Get value for Uint associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"_value\" : \"Returns the Uint value associated with the id key\" }\r\n     */\r\n    function getUint(bytes32 _key) public view returns (uint _value) {\r\n        return uIntStorage[_key];\r\n    }\r\n\r\n    /**\r\n     * @notice Get value for String associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"_value\" : \"Returns the String value associated with the id key\" }\r\n     */\r\n    function getString(bytes32 _key) public view returns (string _value) {\r\n        return stringStorage[_key];\r\n    }\r\n\r\n    /**\r\n     * @notice Get value for Bytes associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"_value\" : \"Returns the Bytes value associated with the id key\" }\r\n     */\r\n    function getBytes(bytes32 _key) public view returns (bytes _value) {\r\n        return bytesStorage[_key];\r\n    }\r\n\r\n    /**\r\n     * @notice Get value for Bool associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"_value\" : \"Returns the Bool value associated with the id key\" }\r\n     */\r\n    function getBool(bytes32 _key) public view returns (bool _value) {\r\n        return boolStorage[_key];\r\n    }\r\n\r\n    /**\r\n     * @notice Get value for Int associated with bytes32 id key\r\n     * @param _key Pointer identifier for value in storage\r\n     * @return { \"_value\" : \"Returns the Int value associated with the id key\" }\r\n     */\r\n    function getInt(bytes32 _key) public view returns (int _value) {\r\n        return intStorage[_key];\r\n    }\r\n\r\n}\r\n\r\n/**\r\nCOPYRIGHT 2018 Token, Inc.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n@title TokenIOLib\r\n\r\n@author Ryan Tate <ryan.tate@token.io>, Sean Pollock <sean.pollock@token.io>\r\n\r\n@notice This library proxies the TokenIOStorage contract for the interface contract,\r\nallowing the library and the interfaces to remain stateless, and share a universally\r\navailable storage contract between interfaces.\r\n\r\n\r\n*/\r\n\r\n\r\nlibrary TokenIOLib {\r\n\r\n  /// @dev all math operating are using SafeMath methods to check for overflow/underflows\r\n  using SafeMath for uint;\r\n\r\n  /// @dev the Data struct uses the Storage contract for stateful setters\r\n  struct Data {\r\n    TokenIOStorage Storage;\r\n  }\r\n\r\n  /// @notice Not using `Log` prefix for events to be consistent with ERC20 named events;\r\n  event Approval(address indexed owner, address indexed spender, uint amount);\r\n  event Deposit(string currency, address indexed account, uint amount, string issuerFirm);\r\n  event Withdraw(string currency, address indexed account, uint amount, string issuerFirm);\r\n  event Transfer(string currency, address indexed from, address indexed to, uint amount, bytes data);\r\n  event KYCApproval(address indexed account, bool status, string issuerFirm);\r\n  event AccountStatus(address indexed account, bool status, string issuerFirm);\r\n  event FxSwap(string tokenASymbol,string tokenBSymbol,uint tokenAValue,uint tokenBValue, uint expiration, bytes32 transactionHash);\r\n  event AccountForward(address indexed originalAccount, address indexed forwardedAccount);\r\n  event NewAuthority(address indexed authority, string issuerFirm);\r\n\r\n  /**\r\n   * @notice Set the token name for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param tokenName Name of the token contract\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setTokenName(Data storage self, string tokenName) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.name', address(this)));\r\n    require(\r\n      self.Storage.setString(id, tokenName),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the token symbol for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param tokenSymbol Symbol of the token contract\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setTokenSymbol(Data storage self, string tokenSymbol) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.symbol', address(this)));\r\n    require(\r\n      self.Storage.setString(id, tokenSymbol),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the token three letter abreviation (TLA) for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param tokenTLA TLA of the token contract\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setTokenTLA(Data storage self, string tokenTLA) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.tla', address(this)));\r\n    require(\r\n      self.Storage.setString(id, tokenTLA),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the token version for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param tokenVersion Semantic (vMAJOR.MINOR.PATCH | e.g. v0.1.0) version of the token contract\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setTokenVersion(Data storage self, string tokenVersion) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.version', address(this)));\r\n    require(\r\n      self.Storage.setString(id, tokenVersion),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the token decimals for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @dev This method is not set to the address of the contract, rather is maped to currency\r\n   * @dev To derive decimal value, divide amount by 10^decimal representation (e.g. 10132 / 10**2 == 101.32)\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param tokenDecimals Decimal representation of the token contract unit amount\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setTokenDecimals(Data storage self, string currency, uint tokenDecimals) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.decimals', currency));\r\n    require(\r\n      self.Storage.setUint(id, tokenDecimals),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set basis point fee for contract interface\r\n   * @dev Transaction fees can be set by the TokenIOFeeContract\r\n   * @dev Fees vary by contract interface specified `feeContract`\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param feeBPS Basis points fee for interface contract transactions\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setFeeBPS(Data storage self, uint feeBPS) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.bps', address(this)));\r\n    require(\r\n      self.Storage.setUint(id, feeBPS),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set minimum fee for contract interface\r\n   * @dev Transaction fees can be set by the TokenIOFeeContract\r\n   * @dev Fees vary by contract interface specified `feeContract`\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param feeMin Minimum fee for interface contract transactions\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setFeeMin(Data storage self, uint feeMin) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.min', address(this)));\r\n    require(\r\n      self.Storage.setUint(id, feeMin),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set maximum fee for contract interface\r\n   * @dev Transaction fees can be set by the TokenIOFeeContract\r\n   * @dev Fees vary by contract interface specified `feeContract`\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param feeMax Maximum fee for interface contract transactions\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setFeeMax(Data storage self, uint feeMax) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.max', address(this)));\r\n    require(\r\n      self.Storage.setUint(id, feeMax),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set flat fee for contract interface\r\n   * @dev Transaction fees can be set by the TokenIOFeeContract\r\n   * @dev Fees vary by contract interface specified `feeContract`\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param feeFlat Flat fee for interface contract transactions\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setFeeFlat(Data storage self, uint feeFlat) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.flat', address(this)));\r\n    require(\r\n      self.Storage.setUint(id, feeFlat),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set fee message for contract interface\r\n   * @dev Default fee messages can be set by the TokenIOFeeContract (e.g. \"tx_fees\")\r\n   * @dev Fee messages vary by contract interface specified `feeContract`\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param feeMsg Fee message included in a transaction with fees\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setFeeMsg(Data storage self, bytes feeMsg) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.msg', address(this)));\r\n    require(\r\n      self.Storage.setBytes(id, feeMsg),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set fee contract for a contract interface\r\n   * @dev feeContract must be a TokenIOFeeContract storage approved contract\r\n   * @dev Fees vary by contract interface specified `feeContract`\r\n   * @dev | This method has an `internal` view\r\n   * @dev | This must be called directly from the interface contract\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param feeContract Set the fee contract for `this` contract address interface\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setFeeContract(Data storage self, address feeContract) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.account', address(this)));\r\n    require(\r\n      self.Storage.setAddress(id, feeContract),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set contract interface associated with a given TokenIO currency symbol (e.g. USDx)\r\n   * @dev | This should only be called once from a token interface contract;\r\n   * @dev | This method has an `internal` view\r\n   * @dev | This method is experimental and may be deprecated/refactored\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setTokenNameSpace(Data storage self, string currency) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.namespace', currency));\r\n    require(\r\n      self.Storage.setAddress(id, address(this)),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the KYC approval status (true/false) for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @dev | Every account must be KYC'd to be able to use transfer() & transferFrom() methods\r\n   * @dev | To gain approval for an account, register at https://tsm.token.io/sign-up\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder\r\n   * @param isApproved Boolean (true/false) KYC approval status for a given account\r\n   * @param issuerFirm Firm name for issuing KYC approval\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setKYCApproval(Data storage self, address account, bool isApproved, string issuerFirm) internal returns (bool success) {\r\n      bytes32 id = keccak256(abi.encodePacked('account.kyc', getForwardedAccount(self, account)));\r\n      require(\r\n        self.Storage.setBool(id, isApproved),\r\n        \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n      );\r\n\r\n      /// @dev NOTE: Issuer is logged for setting account KYC status\r\n      emit KYCApproval(account, isApproved, issuerFirm);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the global approval status (true/false) for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @dev | Every account must be permitted to be able to use transfer() & transferFrom() methods\r\n   * @dev | To gain approval for an account, register at https://tsm.token.io/sign-up\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder\r\n   * @param isAllowed Boolean (true/false) global status for a given account\r\n   * @param issuerFirm Firm name for issuing approval\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setAccountStatus(Data storage self, address account, bool isAllowed, string issuerFirm) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('account.allowed', getForwardedAccount(self, account)));\r\n    require(\r\n      self.Storage.setBool(id, isAllowed),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n\r\n    /// @dev NOTE: Issuer is logged for setting account status\r\n    emit AccountStatus(account, isAllowed, issuerFirm);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Set a forwarded address for an account.\r\n   * @dev | This method has an `internal` view\r\n   * @dev | Forwarded accounts must be set by an authority in case of account recovery;\r\n   * @dev | Additionally, the original owner can set a forwarded account (e.g. add a new device, spouse, dependent, etc)\r\n   * @dev | All transactions will be logged under the same KYC information as the original account holder;\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param originalAccount Original registered Ethereum address of the account holder\r\n   * @param forwardedAccount Forwarded Ethereum address of the account holder\r\n   * @return {\"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setForwardedAccount(Data storage self, address originalAccount, address forwardedAccount) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('master.account', forwardedAccount));\r\n    require(\r\n      self.Storage.setAddress(id, originalAccount),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the original address for a forwarded account\r\n   * @dev | This method has an `internal` view\r\n   * @dev | Will return the registered account for the given forwarded account\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder\r\n   * @return { \"registeredAccount\" : \"Will return the original account of a forwarded account or the account itself if no account found\"}\r\n   */\r\n  function getForwardedAccount(Data storage self, address account) internal view returns (address registeredAccount) {\r\n    bytes32 id = keccak256(abi.encodePacked('master.account', account));\r\n    address originalAccount = self.Storage.getAddress(id);\r\n    if (originalAccount != 0x0) {\r\n      return originalAccount;\r\n    } else {\r\n      return account;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get KYC approval status for the account holder\r\n   * @dev | This method has an `internal` view\r\n   * @dev | All forwarded accounts will use the original account's status\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder\r\n   * @return { \"status\" : \"Returns the KYC approval status for an account holder\" }\r\n   */\r\n  function getKYCApproval(Data storage self, address account) internal view returns (bool status) {\r\n      bytes32 id = keccak256(abi.encodePacked('account.kyc', getForwardedAccount(self, account)));\r\n      return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get global approval status for the account holder\r\n   * @dev | This method has an `internal` view\r\n   * @dev | All forwarded accounts will use the original account's status\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder\r\n   * @return { \"status\" : \"Returns the global approval status for an account holder\" }\r\n   */\r\n  function getAccountStatus(Data storage self, address account) internal view returns (bool status) {\r\n    bytes32 id = keccak256(abi.encodePacked('account.allowed', getForwardedAccount(self, account)));\r\n    return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the contract interface address associated with token symbol\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @return { \"contractAddress\" : \"Returns the contract interface address for a symbol\" }\r\n   */\r\n  function getTokenNameSpace(Data storage self, string currency) internal view returns (address contractAddress) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.namespace', currency));\r\n    return self.Storage.getAddress(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token name for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return {\"tokenName\" : \"Name of the token contract\"}\r\n   */\r\n  function getTokenName(Data storage self, address contractAddress) internal view returns (string tokenName) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.name', contractAddress));\r\n    return self.Storage.getString(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token symbol for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return {\"tokenSymbol\" : \"Symbol of the token contract\"}\r\n   */\r\n  function getTokenSymbol(Data storage self, address contractAddress) internal view returns (string tokenSymbol) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.symbol', contractAddress));\r\n    return self.Storage.getString(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token Three letter abbreviation (TLA) for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return {\"tokenTLA\" : \"TLA of the token contract\"}\r\n   */\r\n  function getTokenTLA(Data storage self, address contractAddress) internal view returns (string tokenTLA) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.tla', contractAddress));\r\n    return self.Storage.getString(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token version for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return {\"tokenVersion\" : \"Semantic version of the token contract\"}\r\n   */\r\n  function getTokenVersion(Data storage self, address contractAddress) internal view returns (string) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.version', contractAddress));\r\n    return self.Storage.getString(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token decimals for Token interfaces\r\n   * @dev This method must be set by the token interface's setParams() method\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @return {\"tokenDecimals\" : \"Decimals of the token contract\"}\r\n   */\r\n  function getTokenDecimals(Data storage self, string currency) internal view returns (uint tokenDecimals) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.decimals', currency));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the basis points fee of the contract address; typically TokenIOFeeContract\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"feeBps\" : \"Returns the basis points fees associated with the contract address\"}\r\n   */\r\n  function getFeeBPS(Data storage self, address contractAddress) internal view returns (uint feeBps) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.bps', contractAddress));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the minimum fee of the contract address; typically TokenIOFeeContract\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"feeMin\" : \"Returns the minimum fees associated with the contract address\"}\r\n   */\r\n  function getFeeMin(Data storage self, address contractAddress) internal view returns (uint feeMin) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.min', contractAddress));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the maximum fee of the contract address; typically TokenIOFeeContract\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"feeMax\" : \"Returns the maximum fees associated with the contract address\"}\r\n   */\r\n  function getFeeMax(Data storage self, address contractAddress) internal view returns (uint feeMax) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.max', contractAddress));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the flat fee of the contract address; typically TokenIOFeeContract\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"feeFlat\" : \"Returns the flat fees associated with the contract address\"}\r\n   */\r\n  function getFeeFlat(Data storage self, address contractAddress) internal view returns (uint feeFlat) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.flat', contractAddress));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the flat message of the contract address; typically TokenIOFeeContract\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"feeMsg\" : \"Returns the fee message (bytes) associated with the contract address\"}\r\n   */\r\n  function getFeeMsg(Data storage self, address contractAddress) internal view returns (bytes feeMsg) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.msg', contractAddress));\r\n    return self.Storage.getBytes(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Set the master fee contract used as the default fee contract when none is provided\r\n   * @dev | This method has an `internal` view\r\n   * @dev | This value is set in the TokenIOAuthority contract\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"success\" : \"Returns true when successfully called from another contract\"}\r\n   */\r\n  function setMasterFeeContract(Data storage self, address contractAddress) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.contract.master'));\r\n    require(\r\n      self.Storage.setAddress(id, contractAddress),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the master fee contract set via the TokenIOAuthority contract\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @return { \"masterFeeContract\" : \"Returns the master fee contract set for TSM.\"}\r\n   */\r\n  function getMasterFeeContract(Data storage self) internal view returns (address masterFeeContract) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.contract.master'));\r\n    return self.Storage.getAddress(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the fee contract set for a contract interface\r\n   * @dev | This method has an `internal` view\r\n   * @dev | Custom fee pricing can be set by assigning a fee contract to transactional contract interfaces\r\n   * @dev | If a fee contract has not been set by an interface contract, then the master fee contract will be returned\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the queryable interface\r\n   * @return { \"feeContract\" : \"Returns the fee contract associated with a contract interface\"}\r\n   */\r\n  function getFeeContract(Data storage self, address contractAddress) internal view returns (address feeContract) {\r\n    bytes32 id = keccak256(abi.encodePacked('fee.account', contractAddress));\r\n\r\n    address feeAccount = self.Storage.getAddress(id);\r\n    if (feeAccount == 0x0) {\r\n      return getMasterFeeContract(self);\r\n    } else {\r\n      return feeAccount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token supply for a given TokenIO TSM currency symbol (e.g. USDx)\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @return { \"supply\" : \"Returns the token supply of the given currency\"}\r\n   */\r\n  function getTokenSupply(Data storage self, string currency) internal view returns (uint supply) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.supply', currency));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token spender allowance for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder\r\n   * @param spender Ethereum address of spender\r\n   * @return { \"allowance\" : \"Returns the allowance of a given spender for a given account\"}\r\n   */\r\n  function getTokenAllowance(Data storage self, string currency, address account, address spender) internal view returns (uint allowance) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, getForwardedAccount(self, account), getForwardedAccount(self, spender)));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token balance for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param account Ethereum address of account holder\r\n   * @return { \"balance\" : \"Return the balance of a given account for a specified currency\"}\r\n   */\r\n  function getTokenBalance(Data storage self, string currency, address account) internal view returns (uint balance) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the frozen token balance for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param account Ethereum address of account holder\r\n   * @return { \"frozenBalance\" : \"Return the frozen balance of a given account for a specified currency\"}\r\n   */\r\n  function getTokenFrozenBalance(Data storage self, string currency, address account) internal view returns (uint frozenBalance) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.frozen', currency, getForwardedAccount(self, account)));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Set the frozen token balance for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param account Ethereum address of account holder\r\n   * @param amount Amount of tokens to freeze for account\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\"}\r\n   */\r\n  function setTokenFrozenBalance(Data storage self, string currency, address account, uint amount) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.frozen', currency, getForwardedAccount(self, account)));\r\n    require(\r\n      self.Storage.setUint(id, amount),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the frozen token balance for a given account\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Contract address of the fee contract\r\n   * @param amount Transaction value\r\n   * @return { \"calculatedFees\" : \"Return the calculated transaction fees for a given amount and fee contract\" }\r\n   */\r\n  function calculateFees(Data storage self, address contractAddress, uint amount) internal view returns (uint calculatedFees) {\r\n\r\n    uint maxFee = self.Storage.getUint(keccak256(abi.encodePacked('fee.max', contractAddress)));\r\n    uint minFee = self.Storage.getUint(keccak256(abi.encodePacked('fee.min', contractAddress)));\r\n    uint bpsFee = self.Storage.getUint(keccak256(abi.encodePacked('fee.bps', contractAddress)));\r\n    uint flatFee = self.Storage.getUint(keccak256(abi.encodePacked('fee.flat', contractAddress)));\r\n    uint fees = ((amount.mul(bpsFee)).div(10000)).add(flatFee);\r\n\r\n    if (fees > maxFee) {\r\n      return maxFee;\r\n    } else if (fees < minFee) {\r\n      return minFee;\r\n    } else {\r\n      return fees;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Verified KYC and global status for two accounts and return true or throw if either account is not verified\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param accountA Ethereum address of first account holder to verify\r\n   * @param accountB Ethereum address of second account holder to verify\r\n   * @return { \"verified\" : \"Returns true if both accounts are successfully verified\" }\r\n   */\r\n  function verifyAccounts(Data storage self, address accountA, address accountB) internal view returns (bool verified) {\r\n    require(\r\n      verifyAccount(self, accountA),\r\n      \"Error: Account is not verified for operation. Please ensure account has been KYC approved.\"\r\n    );\r\n    require(\r\n      verifyAccount(self, accountB),\r\n      \"Error: Account is not verified for operation. Please ensure account has been KYC approved.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Verified KYC and global status for a single account and return true or throw if account is not verified\r\n   * @dev | This method has an `internal` view\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of account holder to verify\r\n   * @return { \"verified\" : \"Returns true if account is successfully verified\" }\r\n   */\r\n  function verifyAccount(Data storage self, address account) internal view returns (bool verified) {\r\n    require(\r\n      getKYCApproval(self, account),\r\n      \"Error: Account does not have KYC approval.\"\r\n    );\r\n    require(\r\n      getAccountStatus(self, account),\r\n      \"Error: Account status is `false`. Account status must be `true`.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Transfer an amount of currency token from msg.sender account to another specified account\r\n   * @dev This function is called by an interface that is accessible directly to the account holder\r\n   * @dev | This method has an `internal` view\r\n   * @dev | This method uses `forceTransfer()` low-level api\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param to Ethereum address of account to send currency amount to\r\n   * @param amount Value of currency to transfer\r\n   * @param data Arbitrary bytes data to include with the transaction\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function transfer(Data storage self, string currency, address to, uint amount, bytes data) internal returns (bool success) {\r\n    require(address(to) != 0x0, \"Error: `to` address cannot be null.\" );\r\n    require(amount > 0, \"Error: `amount` must be greater than zero\");\r\n\r\n    address feeContract = getFeeContract(self, address(this));\r\n    uint fees = calculateFees(self, feeContract, amount);\r\n\r\n    require(\r\n      setAccountSpendingAmount(self, msg.sender, getFxUSDAmount(self, currency, amount)),\r\n      \"Error: Unable to set spending amount for account.\");\r\n\r\n    require(\r\n      forceTransfer(self, currency, msg.sender, to, amount, data),\r\n      \"Error: Unable to transfer funds to account.\");\r\n\r\n    // @dev transfer fees to fee contract\r\n    require(\r\n      forceTransfer(self, currency, msg.sender, feeContract, fees, getFeeMsg(self, feeContract)),\r\n      \"Error: Unable to transfer fees to fee contract.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer an amount of currency token from account to another specified account via an approved spender account\r\n   * @dev This function is called by an interface that is accessible directly to the account spender\r\n   * @dev | This method has an `internal` view\r\n   * @dev | Transactions will fail if the spending amount exceeds the daily limit\r\n   * @dev | This method uses `forceTransfer()` low-level api\r\n   * @dev | This method implements ERC20 transferFrom() method with approved spender behavior\r\n   * @dev | msg.sender == spender; `updateAllowance()` reduces approved limit for account spender\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param from Ethereum address of account to send currency amount from\r\n   * @param to Ethereum address of account to send currency amount to\r\n   * @param amount Value of currency to transfer\r\n   * @param data Arbitrary bytes data to include with the transaction\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function transferFrom(Data storage self, string currency, address from, address to, uint amount, bytes data) internal returns (bool success) {\r\n    require(\r\n      address(to) != 0x0,\r\n      \"Error: `to` address must not be null.\"\r\n    );\r\n\r\n    address feeContract = getFeeContract(self, address(this));\r\n    uint fees = calculateFees(self, feeContract, amount);\r\n\r\n    /// @dev NOTE: This transaction will fail if the spending amount exceeds the daily limit\r\n    require(\r\n      setAccountSpendingAmount(self, from, getFxUSDAmount(self, currency, amount)),\r\n      \"Error: Unable to set account spending amount.\"\r\n    );\r\n\r\n    /// @dev Attempt to transfer the amount\r\n    require(\r\n      forceTransfer(self, currency, from, to, amount, data),\r\n      \"Error: Unable to transfer funds to account.\"\r\n    );\r\n\r\n    // @dev transfer fees to fee contract\r\n    require(\r\n      forceTransfer(self, currency, from, feeContract, fees, getFeeMsg(self, feeContract)),\r\n      \"Error: Unable to transfer fees to fee contract.\"\r\n    );\r\n\r\n    /// @dev Attempt to update the spender allowance\r\n    /// @notice this will throw if the allowance has not been set.\r\n    require(\r\n      updateAllowance(self, currency, from, amount),\r\n      \"Error: Unable to update allowance for spender.\"\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Low-level transfer method\r\n   * @dev | This method has an `internal` view\r\n   * @dev | This method does not include fees or approved allowances.\r\n   * @dev | This method is only for authorized interfaces to use (e.g. TokenIOFX)\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param from Ethereum address of account to send currency amount from\r\n   * @param to Ethereum address of account to send currency amount to\r\n   * @param amount Value of currency to transfer\r\n   * @param data Arbitrary bytes data to include with the transaction\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function forceTransfer(Data storage self, string currency, address from, address to, uint amount, bytes data) internal returns (bool success) {\r\n    require(\r\n      address(to) != 0x0,\r\n      \"Error: `to` address must not be null.\"\r\n    );\r\n\r\n    bytes32 id_a = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, from)));\r\n    bytes32 id_b = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, to)));\r\n\r\n    require(\r\n      self.Storage.setUint(id_a, self.Storage.getUint(id_a).sub(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\"\r\n    );\r\n    require(\r\n      self.Storage.setUint(id_b, self.Storage.getUint(id_b).add(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\"\r\n    );\r\n\r\n    emit Transfer(currency, from, to, amount, data);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Low-level method to update spender allowance for account\r\n   * @dev | This method is called inside the `transferFrom()` method\r\n   * @dev | msg.sender == spender address\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param account Ethereum address of account holder\r\n   * @param amount Value to reduce allowance by (i.e. the amount spent)\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function updateAllowance(Data storage self, string currency, address account, uint amount) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, getForwardedAccount(self, account), getForwardedAccount(self, msg.sender)));\r\n    require(\r\n      self.Storage.setUint(id, self.Storage.getUint(id).sub(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Low-level method to set the allowance for a spender\r\n   * @dev | This method is called inside the `approve()` ERC20 method\r\n   * @dev | msg.sender == account holder\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param spender Ethereum address of account spender\r\n   * @param amount Value to set for spender allowance\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function approveAllowance(Data storage self, address spender, uint amount) internal returns (bool success) {\r\n    require(spender != 0x0,\r\n        \"Error: `spender` address cannot be null.\");\r\n\r\n    string memory currency = getTokenSymbol(self, address(this));\r\n\r\n    require(\r\n      getTokenFrozenBalance(self, currency, getForwardedAccount(self, spender)) == 0,\r\n      \"Error: Spender must not have a frozen balance directly\");\r\n\r\n    bytes32 id_a = keccak256(abi.encodePacked('token.allowance', currency, getForwardedAccount(self, msg.sender), getForwardedAccount(self, spender)));\r\n    bytes32 id_b = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, msg.sender)));\r\n\r\n    require(\r\n      self.Storage.getUint(id_a) == 0 || amount == 0,\r\n      \"Error: Allowance must be zero (0) before setting an updated allowance for spender.\");\r\n\r\n    require(\r\n      self.Storage.getUint(id_b) >= amount,\r\n      \"Error: Allowance cannot exceed msg.sender token balance.\");\r\n\r\n    require(\r\n      self.Storage.setUint(id_a, amount),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n\r\n    emit Approval(msg.sender, spender, amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Deposit an amount of currency into the Ethereum account holder\r\n   * @dev | The total supply of the token increases only when new funds are deposited 1:1\r\n   * @dev | This method should only be called by authorized issuer firms\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param account Ethereum address of account holder to deposit funds for\r\n   * @param amount Value of currency to deposit for account\r\n   * @param issuerFirm Name of the issuing firm authorizing the deposit\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function deposit(Data storage self, string currency, address account, uint amount, string issuerFirm) internal returns (bool success) {\r\n    bytes32 id_a = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));\r\n    bytes32 id_b = keccak256(abi.encodePacked('token.issued', currency, issuerFirm));\r\n    bytes32 id_c = keccak256(abi.encodePacked('token.supply', currency));\r\n\r\n\r\n    require(self.Storage.setUint(id_a, self.Storage.getUint(id_a).add(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n    require(self.Storage.setUint(id_b, self.Storage.getUint(id_b).add(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n    require(self.Storage.setUint(id_c, self.Storage.getUint(id_c).add(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n\r\n    emit Deposit(currency, account, amount, issuerFirm);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw an amount of currency from the Ethereum account holder\r\n   * @dev | The total supply of the token decreases only when new funds are withdrawn 1:1\r\n   * @dev | This method should only be called by authorized issuer firms\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  currency Currency symbol of the token (e.g. USDx, JYPx, GBPx)\r\n   * @param account Ethereum address of account holder to deposit funds for\r\n   * @param amount Value of currency to withdraw for account\r\n   * @param issuerFirm Name of the issuing firm authorizing the withdraw\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function withdraw(Data storage self, string currency, address account, uint amount, string issuerFirm) internal returns (bool success) {\r\n    bytes32 id_a = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));\r\n    bytes32 id_b = keccak256(abi.encodePacked('token.issued', currency, issuerFirm)); // possible for issuer to go negative\r\n    bytes32 id_c = keccak256(abi.encodePacked('token.supply', currency));\r\n\r\n    require(\r\n      self.Storage.setUint(id_a, self.Storage.getUint(id_a).sub(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n    require(\r\n      self.Storage.setUint(id_b, self.Storage.getUint(id_b).sub(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n    require(\r\n      self.Storage.setUint(id_c, self.Storage.getUint(id_c).sub(amount)),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n\r\n    emit Withdraw(currency, account, amount, issuerFirm);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n  /**\r\n   * @notice Method for setting a registered issuer firm\r\n   * @dev | Only Token, Inc. and other authorized institutions may set a registered firm\r\n   * @dev | The TokenIOAuthority.sol interface wraps this method\r\n   * @dev | If the registered firm is unapproved; all authorized addresses of that firm will also be unapproved\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param issuerFirm Name of the firm to be registered\r\n   * @param approved Approval status to set for the firm (true/false)\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function setRegisteredFirm(Data storage self, string issuerFirm, bool approved) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));\r\n    require(\r\n      self.Storage.setBool(id, approved),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Method for setting a registered issuer firm authority\r\n   * @dev | Only Token, Inc. and other approved institutions may set a registered firm\r\n   * @dev | The TokenIOAuthority.sol interface wraps this method\r\n   * @dev | Authority can only be set for a registered issuer firm\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param issuerFirm Name of the firm to be registered to authority\r\n   * @param authorityAddress Ethereum address of the firm authority to be approved\r\n   * @param approved Approval status to set for the firm authority (true/false)\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function setRegisteredAuthority(Data storage self, string issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {\r\n    require(\r\n      isRegisteredFirm(self, issuerFirm),\r\n      \"Error: `issuerFirm` must be registered.\");\r\n\r\n    bytes32 id_a = keccak256(abi.encodePacked('registered.authority', issuerFirm, authorityAddress));\r\n    bytes32 id_b = keccak256(abi.encodePacked('registered.authority.firm', authorityAddress));\r\n\r\n    require(\r\n      self.Storage.setBool(id_a, approved),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n\r\n    require(\r\n      self.Storage.setString(id_b, issuerFirm),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the issuer firm registered to the authority Ethereum address\r\n   * @dev | Only one firm can be registered per authority\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param authorityAddress Ethereum address of the firm authority to query\r\n   * @return { \"issuerFirm\" : \"Name of the firm registered to authority\" }\r\n   */\r\n  function getFirmFromAuthority(Data storage self, address authorityAddress) internal view returns (string issuerFirm) {\r\n    bytes32 id = keccak256(abi.encodePacked('registered.authority.firm', getForwardedAccount(self, authorityAddress)));\r\n    return self.Storage.getString(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Return the boolean (true/false) registration status for an issuer firm\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param issuerFirm Name of the issuer firm\r\n   * @return { \"registered\" : \"Return if the issuer firm has been registered\" }\r\n   */\r\n  function isRegisteredFirm(Data storage self, string issuerFirm) internal view returns (bool registered) {\r\n    bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));\r\n    return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Return the boolean (true/false) status if an authority is registered to an issuer firm\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param issuerFirm Name of the issuer firm\r\n   * @param authorityAddress Ethereum address of the firm authority to query\r\n   * @return { \"registered\" : \"Return if the authority is registered with the issuer firm\" }\r\n   */\r\n  function isRegisteredToFirm(Data storage self, string issuerFirm, address authorityAddress) internal view returns (bool registered) {\r\n    bytes32 id = keccak256(abi.encodePacked('registered.authority', issuerFirm, getForwardedAccount(self, authorityAddress)));\r\n    return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Return if an authority address is registered\r\n   * @dev | This also checks the status of the registered issuer firm\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param authorityAddress Ethereum address of the firm authority to query\r\n   * @return { \"registered\" : \"Return if the authority is registered\" }\r\n   */\r\n  function isRegisteredAuthority(Data storage self, address authorityAddress) internal view returns (bool registered) {\r\n    bytes32 id = keccak256(abi.encodePacked('registered.authority', getFirmFromAuthority(self, getForwardedAccount(self, authorityAddress)), getForwardedAccount(self, authorityAddress)));\r\n    return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Return boolean transaction status if the transaction has been used\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param txHash keccak256 ABI tightly packed encoded hash digest of tx params\r\n   * @return {\"txStatus\": \"Returns true if the tx hash has already been set using `setTxStatus()` method\"}\r\n   */\r\n  function getTxStatus(Data storage self, bytes32 txHash) internal view returns (bool txStatus) {\r\n    bytes32 id = keccak256(abi.encodePacked('tx.status', txHash));\r\n    return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Set transaction status if the transaction has been used\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param txHash keccak256 ABI tightly packed encoded hash digest of tx params\r\n   * @return { \"success\" : \"Return true if successfully called from another contract\" }\r\n   */\r\n  function setTxStatus(Data storage self, bytes32 txHash) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('tx.status', txHash));\r\n    /// @dev Ensure transaction has not yet been used;\r\n    require(!getTxStatus(self, txHash),\r\n      \"Error: Transaction status must be false before setting the transaction status.\");\r\n\r\n    /// @dev Update the status of the transaction;\r\n    require(self.Storage.setBool(id, true),\r\n      \"Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Accepts a signed fx request to swap currency pairs at a given amount;\r\n   * @dev | This method can be called directly between peers\r\n   * @dev | This method does not take transaction fees from the swap\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param  requester address Requester is the orginator of the offer and must\r\n   * match the signature of the payload submitted by the fulfiller\r\n   * @param  symbolA    Symbol of the currency desired\r\n   * @param  symbolB    Symbol of the currency offered\r\n   * @param  valueA     Amount of the currency desired\r\n   * @param  valueB     Amount of the currency offered\r\n   * @param  sigV       Ethereum secp256k1 signature V value; used by ecrecover()\r\n   * @param  sigR       Ethereum secp256k1 signature R value; used by ecrecover()\r\n   * @param  sigS       Ethereum secp256k1 signature S value; used by ecrecover()\r\n   * @param  expiration Expiration of the offer; Offer is good until expired\r\n   * @return {\"success\" : \"Returns true if successfully called from another contract\"}\r\n   */\r\n  function execSwap(\r\n    Data storage self,\r\n    address requester,\r\n    string symbolA,\r\n    string symbolB,\r\n    uint valueA,\r\n    uint valueB,\r\n    uint8 sigV,\r\n    bytes32 sigR,\r\n    bytes32 sigS,\r\n    uint expiration\r\n  ) internal returns (bool success) {\r\n\r\n    bytes32 fxTxHash = keccak256(abi.encodePacked(requester, symbolA, symbolB, valueA, valueB, expiration));\r\n\r\n    /// @notice check that sender and requester accounts are verified\r\n    /// @notice Only verified accounts can perform currency swaps\r\n    require(\r\n      verifyAccounts(self, msg.sender, requester),\r\n      \"Error: Only verified accounts can perform currency swaps.\");\r\n\r\n    /// @dev Immediately set this transaction to be confirmed before updating any params;\r\n    require(\r\n      setTxStatus(self, fxTxHash),\r\n      \"Error: Failed to set transaction status to fulfilled.\");\r\n\r\n    /// @dev Ensure contract has not yet expired;\r\n    require(expiration >= now, \"Error: Transaction has expired!\");\r\n\r\n    /// @dev Recover the address of the signature from the hashed digest;\r\n    /// @dev Ensure it equals the requester's address\r\n    require(\r\n      ecrecover(fxTxHash, sigV, sigR, sigS) == requester,\r\n      \"Error: Address derived from transaction signature does not match the requester address\");\r\n\r\n    /// @dev Transfer funds from each account to another.\r\n    require(\r\n      forceTransfer(self, symbolA, msg.sender, requester, valueA, \"0x0\"),\r\n      \"Error: Unable to transfer funds to account.\");\r\n\r\n    require(\r\n      forceTransfer(self, symbolB, requester, msg.sender, valueB, \"0x0\"),\r\n      \"Error: Unable to transfer funds to account.\");\r\n\r\n    emit FxSwap(symbolA, symbolB, valueA, valueB, expiration, fxTxHash);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Deprecate a contract interface\r\n   * @dev | This is a low-level method to deprecate a contract interface.\r\n   * @dev | This is useful if the interface needs to be updated or becomes out of date\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Ethereum address of the contract interface\r\n   * @return {\"success\" : \"Returns true if successfully called from another contract\"}\r\n   */\r\n  function setDeprecatedContract(Data storage self, address contractAddress) internal returns (bool success) {\r\n    require(contractAddress != 0x0,\r\n        \"Error: cannot deprecate a null address.\");\r\n\r\n    bytes32 id = keccak256(abi.encodePacked('depcrecated', contractAddress));\r\n\r\n    require(self.Storage.setBool(id, true),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Return the deprecation status of a contract\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param contractAddress Ethereum address of the contract interface\r\n   * @return {\"status\" : \"Return deprecation status (true/false) of the contract interface\"}\r\n   */\r\n  function isContractDeprecated(Data storage self, address contractAddress) internal view returns (bool status) {\r\n    bytes32 id = keccak256(abi.encodePacked('depcrecated', contractAddress));\r\n    return self.Storage.getBool(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Set the Account Spending Period Limit as UNIX timestamp\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @param period Unix timestamp of the spending period\r\n   * @return {\"success\" : \"Returns true is successfully called from a contract\"}\r\n   */\r\n  function setAccountSpendingPeriod(Data storage self, address account, uint period) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('limit.spending.period', account));\r\n    require(self.Storage.setUint(id, period),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the Account Spending Period Limit as UNIX timestamp\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @dev | If the current spending period has expired, it will be set upon next `transfer()`\r\n   * or `transferFrom()` request\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @return {\"period\" : \"Returns Unix timestamp of the current spending period\"}\r\n   */\r\n  function getAccountSpendingPeriod(Data storage self, address account) internal view returns (uint period) {\r\n    bytes32 id = keccak256(abi.encodePacked('limit.spending.period', account));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Set the account spending limit amount\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @param limit Spending limit amount\r\n   * @return {\"success\" : \"Returns true is successfully called from a contract\"}\r\n   */\r\n  function setAccountSpendingLimit(Data storage self, address account, uint limit) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('account.spending.limit', account));\r\n    require(self.Storage.setUint(id, limit),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the account spending limit amount\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @return {\"limit\" : \"Returns the account spending limit amount\"}\r\n   */\r\n  function getAccountSpendingLimit(Data storage self, address account) internal view returns (uint limit) {\r\n    bytes32 id = keccak256(abi.encodePacked('account.spending.limit', account));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Set the account spending amount for the daily period\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @dev | This transaction will throw if the new spending amount is greater than the limit\r\n   * @dev | This method is called in the `transfer()` and `transferFrom()` methods\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @param amount Set the amount spent for the daily period\r\n   * @return {\"success\" : \"Returns true is successfully called from a contract\"}\r\n   */\r\n  function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {\r\n\r\n    /// @dev NOTE: Always ensure the period is current when checking the daily spend limit\r\n    require(updateAccountSpendingPeriod(self, account),\r\n      \"Error: Unable to update account spending period.\");\r\n\r\n    uint updatedAmount = getAccountSpendingAmount(self, account).add(amount);\r\n\r\n    /// @dev Ensure the spend limit is greater than the amount spend for the period\r\n    require(\r\n      getAccountSpendingLimit(self, account) >= updatedAmount,\r\n      \"Error: Account cannot exceed its daily spend limit.\");\r\n\r\n    /// @dev Update the spending period amount if within limit\r\n    bytes32 id = keccak256(abi.encodePacked('account.spending.amount', account, getAccountSpendingPeriod(self, account)));\r\n    require(self.Storage.setUint(id, updatedAmount),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Low-level API to ensure the account spending period is always current\r\n   * @dev | This method is internally called by `setAccountSpendingAmount()` to ensure\r\n   * spending period is always the most current daily period.\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @return {\"success\" : \"Returns true is successfully called from a contract\"}\r\n   */\r\n  function updateAccountSpendingPeriod(Data storage self, address account) internal returns (bool success) {\r\n    uint begDate = getAccountSpendingPeriod(self, account);\r\n    if (begDate > now) {\r\n      return true;\r\n    } else {\r\n      uint duration = 86400; // 86400 seconds in a day\r\n      require(\r\n        setAccountSpendingPeriod(self, account, begDate.add(((now.sub(begDate)).div(duration).add(1)).mul(duration))),\r\n        \"Error: Unable to update account spending period.\");\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Return the amount spent during the current period\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @return {\"amount\" : \"Returns the amount spent by the account during the current period\"}\r\n   */\r\n  function getAccountSpendingAmount(Data storage self, address account) internal view returns (uint amount) {\r\n    bytes32 id = keccak256(abi.encodePacked('account.spending.amount', account, getAccountSpendingPeriod(self, account)));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Return the amount remaining during the current period\r\n   * @dev | Each account has it's own daily spending limit\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param account Ethereum address of the account holder\r\n   * @return {\"amount\" : \"Returns the amount remaining by the account during the current period\"}\r\n   */\r\n  function getAccountSpendingRemaining(Data storage self, address account) internal view returns (uint remainingLimit) {\r\n    return getAccountSpendingLimit(self, account).sub(getAccountSpendingAmount(self, account));\r\n  }\r\n\r\n  /**\r\n   * @notice Set the foreign currency exchange rate to USD in basis points\r\n   * @dev | This value should always be relative to USD pair; e.g. JPY/USD, GBP/USD, etc.\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param currency The TokenIO currency symbol (e.g. USDx, JPYx, GBPx)\r\n   * @param bpsRate Basis point rate of foreign currency exchange rate to USD\r\n   * @return { \"success\": \"Returns true if successfully called from another contract\"}\r\n   */\r\n  function setFxUSDBPSRate(Data storage self, string currency, uint bpsRate) internal returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('fx.usd.rate', currency));\r\n    require(\r\n      self.Storage.setUint(id, bpsRate),\r\n      \"Error: Unable to update account spending period.\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Return the foreign currency USD exchanged amount in basis points\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param currency The TokenIO currency symbol (e.g. USDx, JPYx, GBPx)\r\n   * @return {\"usdAmount\" : \"Returns the foreign currency amount in USD\"}\r\n   */\r\n  function getFxUSDBPSRate(Data storage self, string currency) internal view returns (uint bpsRate) {\r\n    bytes32 id = keccak256(abi.encodePacked('fx.usd.rate', currency));\r\n    return self.Storage.getUint(id);\r\n  }\r\n\r\n  /**\r\n   * @notice Return the foreign currency USD exchanged amount\r\n   * @param self Internal storage proxying TokenIOStorage contract\r\n   * @param currency The TokenIO currency symbol (e.g. USDx, JPYx, GBPx)\r\n   * @param fxAmount Amount of foreign currency to exchange into USD\r\n   * @return {\"amount\" : \"Returns the foreign currency amount in USD\"}\r\n   */\r\n  function getFxUSDAmount(Data storage self, string currency, uint fxAmount) internal view returns (uint amount) {\r\n    uint usdDecimals = getTokenDecimals(self, 'USDx');\r\n    uint fxDecimals = getTokenDecimals(self, currency);\r\n    /// @dev ensure decimal precision is normalized to USD decimals\r\n    uint usdAmount = ((fxAmount.mul(getFxUSDBPSRate(self, currency)).div(10000)).mul(10**usdDecimals)).div(10**fxDecimals);\r\n    return usdAmount;\r\n  }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @notice interface contract from Zeppelin token erc20;\r\n */\r\ninterface ERC20Interface {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/*\r\nCOPYRIGHT 2018 Token, Inc.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n@title ERC20 Compliant StableCoin Swap Smart Contract for Token, Inc.\r\n\r\n@author Ryan Tate <ryan.tate@token.io>, Sean Pollock <sean.pollock@token.io>\r\n\r\n@notice Contract uses generalized storage contract, `TokenIOStorage`, for\r\nupgradeability of interface contract.\r\n\r\n@dev In the event that the main contract becomes deprecated, the upgraded contract\r\nwill be set as the owner of this contract, and use this contract's storage to\r\nmaintain data consistency between contract.\r\n*/\r\n\r\n\r\n\r\ncontract TokenIOStableSwap is Ownable {\r\n  /// @dev use safe math operations\r\n  using SafeMath for uint;\r\n\r\n  //// @dev Set reference to TokenIOLib interface which proxies to TokenIOStorage\r\n  using TokenIOLib for TokenIOLib.Data;\r\n  TokenIOLib.Data lib;\r\n\r\n  event StableSwap(address fromAsset, address toAsset, address requestedBy, uint amount, string currency);\r\n  event TransferredHoldings(address asset, address to, uint amount);\r\n  event AllowedERC20Asset(address asset, string currency);\r\n  event RemovedERC20Asset(address asset, string currency);\r\n\r\n  /**\r\n  * @notice Constructor method for TokenIOStableSwap contract\r\n  * @param _storageContract     address of TokenIOStorage contract\r\n  */\r\n  constructor(address _storageContract) public {\r\n    //// @dev Set the storage contract for the interface\r\n    //// @dev This contract will be unable to use the storage constract until\r\n    //// @dev contract address is authorized with the storage contract\r\n    //// @dev Once authorized, Use the `setParams` method to set storage values\r\n    lib.Storage = TokenIOStorage(_storageContract);\r\n\r\n    //// @dev set owner to contract initiator\r\n    owner[msg.sender] = true;\r\n  }\r\n\r\n\t/**\r\n\t * @notice Allows the address of the asset to be accepted by this contract by the currency type. This method is only called by admins.\r\n\t * @notice This method may be deprecated or refactored to allow for multiple interfaces\r\n\t * @param  asset Ethereum address of the ERC20 compliant smart contract to allow the swap\r\n\t * @param  currency string Currency symbol of the token (e.g. `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK`)\r\n   * @param feeBps Basis points Swap Fee\r\n\t * @param feeMin Minimum Swap Fees\r\n\t * @param feeMax Maximum Swap Fee\r\n\t * @param feeFlat Flat Swap Fee\r\n\t * @return { \"success\" : \"Returns true if successfully called from another contract\"}\r\n\t */\r\n\tfunction allowAsset(address asset, string currency, uint feeBps, uint feeMin, uint feeMax, uint feeFlat) public onlyOwner notDeprecated returns (bool success) {\r\n\t\tbytes32 id = keccak256(abi.encodePacked('allowed.stable.asset', asset, currency));\r\n    require(\r\n      lib.Storage.setBool(id, true),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n\r\n    /// @notice set Currency for the asset;\r\n    require(setAssetCurrency(asset, currency), 'Error: Unable to set Currency for asset');\r\n\r\n    /// @notice set the Fee Params for the asset\r\n    require(setAssetFeeParams(asset, feeBps, feeMin, feeMax, feeFlat), 'Error: Unable to set fee params for asset');\r\n\r\n    /// @dev Log Allow ERC20 Asset\r\n    emit AllowedERC20Asset(asset, currency);\r\n\t\treturn true;\r\n\t}\r\n\r\n  function removeAsset(address asset) public onlyOwner notDeprecated returns (bool success) {\r\n    string memory currency = getAssetCurrency(asset);\r\n    bytes32 id = keccak256(abi.encodePacked('allowed.stable.asset', asset, currency));\r\n    require(\r\n      lib.Storage.setBool(id, false),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    emit RemovedERC20Asset(asset, currency);\r\n    return true;\r\n  }\r\n\r\n\t/**\r\n\t * @notice Return boolean if the asset is an allowed stable asset for the corresponding currency\r\n\t * @param  asset Ethereum address of the ERC20 compliant smart contract to check allowed status of\r\n\t * @param  currency string Currency symbol of the token (e.g. `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK`)\r\n\t * @return {\"allowed\": \"Returns true if the asset is allowed\"}\r\n\t */\r\n\tfunction isAllowedAsset(address asset, string currency) public view returns (bool allowed) {\r\n\t\tif (isTokenXContract(asset, currency)) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tbytes32 id = keccak256(abi.encodePacked('allowed.stable.asset', asset, currency));\r\n\t\t\treturn lib.Storage.getBool(id);\r\n\t\t}\r\n\t}\r\n\r\n  /**\r\n   * Set the Three Letter Abbrevation for the currency associated to the asset\r\n   * @param asset Ethereum address of the asset to set the currency for\r\n   * @param currency string Currency of the asset (NOTE: This is the currency for the asset)\r\n   * @return { \"success\" : \"Returns true if successfully called from another contract\"}\r\n   */\r\n  function setAssetCurrency(address asset, string currency) public onlyOwner returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('asset.currency', asset));\r\n    require(\r\n      lib.Storage.setString(id, currency),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get the Currency for an associated asset;\r\n   * @param asset Ethereum address of the asset to get the currency for\r\n   * @return {\"currency\": \"Returns the Currency of the asset if the asset has been allowed.\"}\r\n   */\r\n  function getAssetCurrency(address asset) public view returns (string currency) {\r\n    bytes32 id = keccak256(abi.encodePacked('asset.currency', asset));\r\n    return lib.Storage.getString(id);\r\n  }\r\n\r\n  /**\r\n\t * @notice Register the address of the asset as a Token X asset for a specific currency\r\n\t * @notice This method may be deprecated or refactored to allow for multiple interfaces\r\n\t * @param  asset Ethereum address of the ERC20 compliant Token X asset\r\n\t * @param  currency string Currency symbol of the token (e.g. `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK`)\r\n\t * @return { \"success\" : \"Returns true if successfully called from another contract\"}\r\n\t */\r\n\tfunction setTokenXCurrency(address asset, string currency) public onlyOwner notDeprecated returns (bool success) {\r\n    bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));\r\n    require(\r\n      lib.Storage.setBool(id, true),\r\n      \"Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract.\"\r\n    );\r\n\r\n    /// @notice set Currency for the asset;\r\n    require(setAssetCurrency(asset, currency));\r\n\r\n    return true;\r\n\t}\r\n\r\n  /**\r\n    * @notice Return boolean if the asset is a registered Token X asset for the corresponding currency\r\n    * @param  asset Ethereum address of the asset to check if is a registered Token X stable coin asset\r\n    * @param  currency string Currency symbol of the token (e.g. `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK`)\r\n    * @return {\"allowed\": \"Returns true if the asset is allowed\"}\r\n   */\r\n\tfunction isTokenXContract(address asset, string currency) public view returns (bool isX) {\r\n\t\tbytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));\r\n\t\treturn lib.Storage.getBool(id);\r\n\t}\r\n\r\n  /**\r\n   * @notice Set BPS, Min, Max, and Flat fee params for asset\r\n   * @param asset Ethereum address of the asset to set fees for.\r\n   * @param feeBps Basis points Swap Fee\r\n\t * @param feeMin Minimum Swap Fees\r\n\t * @param feeMax Maximum Swap Fee\r\n\t * @param feeFlat Flat Swap Fee\r\n\t * @return { \"success\" : \"Returns true if successfully called from another contract\"}\r\n   */\r\n  function setAssetFeeParams(address asset, uint feeBps, uint feeMin, uint feeMax, uint feeFlat) public onlyOwner notDeprecated returns (bool success) {\r\n    /// @dev This method bypasses the setFee library methods and directly sets the fee params for a requested asset.\r\n    /// @notice Fees can be different per asset. Some assets may have different liquidity requirements.\r\n    require(lib.Storage.setUint(keccak256(abi.encodePacked('fee.max', asset)), feeMax),\r\n      'Error: Failed to set fee parameters with storage contract. Please check permissions.');\r\n\r\n    require(lib.Storage.setUint(keccak256(abi.encodePacked('fee.min', asset)), feeMin),\r\n      'Error: Failed to set fee parameters with storage contract. Please check permissions.');\r\n\r\n    require(lib.Storage.setUint(keccak256(abi.encodePacked('fee.bps', asset)), feeBps),\r\n      'Error: Failed to set fee parameters with storage contract. Please check permissions.');\r\n\r\n    require(lib.Storage.setUint(keccak256(abi.encodePacked('fee.flat', asset)), feeFlat),\r\n      'Error: Failed to set fee parameters with storage contract. Please check permissions.');\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [calcAssetFees description]\r\n   * @param  asset Ethereum address of the asset to calculate fees based on\r\n   * @param  amount Amount to calculate fees on\r\n   * @return { \"fees\" : \"Returns the fees for the amount associated with the asset contract\"}\r\n   */\r\n  function calcAssetFees(address asset, uint amount) public view returns (uint fees) {\r\n    return lib.calculateFees(asset, amount);\r\n  }\r\n\r\n  /**\r\n    * @notice Return boolean if the asset is a registered Token X asset for the corresponding currency\r\n    * @notice Amounts will always be passed in according to the decimal representation of the `fromAsset` token;\r\n    * @param  fromAsset Ethereum address of the asset with allowance for this contract to transfer and\r\n    * @param  toAsset Ethereum address of the asset to check if is a registered Token X stable coin asset\r\n    * @param  amount Amount of fromAsset to be transferred.\r\n    * @return { \"success\" : \"Returns true if successfully called from another contract\"}\r\n   */\r\n\tfunction convert(address fromAsset, address toAsset, uint amount) public notDeprecated returns (bool success) {\r\n    /// @notice lookup currency from one of the assets, check if allowed by both assets.\r\n    string memory currency = getAssetCurrency(fromAsset);\r\n    uint fromDecimals = ERC20Interface(fromAsset).decimals();\r\n    uint toDecimals = ERC20Interface(toAsset).decimals();\r\n\r\n    /// @dev Ensure assets are allowed to be swapped;\r\n\t\trequire(isAllowedAsset(fromAsset, currency), 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .');\r\n\t\trequire(isAllowedAsset(toAsset, currency), 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .');\r\n\r\n\r\n\t\t/// @dev require one of the assets be equal to Token X asset;\r\n\t\tif (isTokenXContract(toAsset, currency)) {\r\n      /// @notice This requires the erc20 transfer function to return a boolean result of true;\r\n      /// @dev the amount being transferred must be in the same decimal representation of the asset\r\n      /// e.g. If decimals = 6 and want to transfer $100.00 the amount passed to this contract should be 100e6 (100 * 10 ** 6)\r\n      require(\r\n        ERC20Interface(fromAsset).transferFrom(msg.sender, address(this), amount),\r\n        'Error: Unable to transferFrom your asset holdings. Please ensure this contract has an approved allowance equal to or greater than the amount called in transferFrom method.'\r\n      );\r\n\r\n      /// @dev Deposit TokenX asset to the user;\r\n      /// @notice Amount received from deposit is net of fees.\r\n      uint netAmountFrom = amount.sub(calcAssetFees(fromAsset, amount));\r\n      /// @dev Ensure amount is converted for the correct decimal representation;\r\n      uint convertedAmountFrom = (netAmountFrom.mul(10**toDecimals)).div(10**fromDecimals);\r\n      require(\r\n        lib.deposit(lib.getTokenSymbol(toAsset), msg.sender, convertedAmountFrom, 'Token, Inc.'),\r\n        \"Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered\"\r\n      );\r\n\t\t} else if(isTokenXContract(fromAsset, currency)) {\r\n      ///@dev Transfer the asset to the user;\r\n      /// @notice Amount received from withdraw is net of fees.\r\n      uint convertedAmount = (amount.mul(10**toDecimals)).div(10**fromDecimals);\r\n      uint fees = calcAssetFees(toAsset, convertedAmount);\r\n      uint netAmountTo = convertedAmount.sub(fees);\r\n      /// @dev Ensure amount is converted for the correct decimal representation;\r\n      require(\r\n      \tERC20Interface(toAsset).transfer(msg.sender, netAmountTo),\r\n      \t'Unable to call the requested erc20 contract.'\r\n      );\r\n\r\n      /// @dev Withdraw TokenX asset from the user\r\n      require(\r\n      \tlib.withdraw(lib.getTokenSymbol(fromAsset), msg.sender, amount, 'Token, Inc.'),\r\n      \t\"Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn\"\r\n      );\r\n\t\t} else {\r\n        revert('Error: At least one asset must be issued by Token, Inc. (Token X).');\r\n\t\t}\r\n\r\n    /// @dev Log the swap event for event listeners\r\n    emit StableSwap(fromAsset, toAsset, msg.sender, amount, currency);\r\n    return true;\r\n\t}\r\n\r\n  /**\r\n   * Allow this contract to transfer collected fees to another contract;\r\n   * @param  asset Ethereum address of asset to transfer\r\n   * @param  to Transfer collected fees to the following account;\r\n   * @param  amount Amount of fromAsset to be transferred.\r\n   * @return { \"success\" : \"Returns true if successfully called from another contract\"}\r\n   */\r\n  function transferCollectedFees(address asset, address to, uint amount) public onlyOwner notDeprecated returns (bool success) {\r\n\t\trequire(\r\n\t\t\tERC20Interface(asset).transfer(to, amount),\r\n\t\t\t\"Error: Unable to transfer fees to account.\"\r\n\t\t);\r\n    emit TransferredHoldings(asset, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @notice gets currency status of contract\r\n\t* @return {\"deprecated\" : \"Returns true if deprecated, false otherwise\"}\r\n\t*/\r\n\tfunction deprecateInterface() public onlyOwner returns (bool deprecated) {\r\n\t\trequire(lib.setDeprecatedContract(address(this)),\r\n      \"Error: Unable to deprecate contract!\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\tmodifier notDeprecated() {\r\n\t\t/// @notice throws if contract is deprecated\r\n\t\trequire(!lib.isContractDeprecated(address(this)),\r\n\t\t\t\"Error: Contract has been deprecated, cannot perform operation!\");\r\n\t\t_;\r\n\t}\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"setAssetCurrency\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAsset\",\"type\":\"address\"},{\"name\":\"toAsset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcAssetFees\",\"outputs\":[{\"name\":\"fees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"removeAsset\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allowedAddress\",\"type\":\"address\"}],\"name\":\"allowOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"feeBps\",\"type\":\"uint256\"},{\"name\":\"feeMin\",\"type\":\"uint256\"},{\"name\":\"feeMax\",\"type\":\"uint256\"},{\"name\":\"feeFlat\",\"type\":\"uint256\"}],\"name\":\"setAssetFeeParams\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allowedAddress\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"setTokenXCurrency\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"currency\",\"type\":\"string\"},{\"name\":\"feeBps\",\"type\":\"uint256\"},{\"name\":\"feeMin\",\"type\":\"uint256\"},{\"name\":\"feeMax\",\"type\":\"uint256\"},{\"name\":\"feeFlat\",\"type\":\"uint256\"}],\"name\":\"allowAsset\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferCollectedFees\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"isAllowedAsset\",\"outputs\":[{\"name\":\"allowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAssetCurrency\",\"outputs\":[{\"name\":\"currency\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"isTokenXContract\",\"outputs\":[{\"name\":\"isX\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deprecateInterface\",\"outputs\":[{\"name\":\"deprecated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_storageContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"requestedBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"StableSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferredHoldings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"AllowedERC20Asset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"string\"}],\"name\":\"RemovedERC20Asset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"allowedAddress\",\"type\":\"address\"}],\"name\":\"AllowOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"allowedAddress\",\"type\":\"address\"}],\"name\":\"RevokeOwnership\",\"type\":\"event\"}]","ContractName":"TokenIOStableSwap","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007395662c0379ea49c8af2275dbba6bf0e2033af4","Library":"","SwarmSource":"bzzr://f114044a12f5aac375f88b95776e044ccd435c9ffff18efe3ef7aae30bd25501"}]}