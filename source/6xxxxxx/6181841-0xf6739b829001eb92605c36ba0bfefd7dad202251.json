{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\nlibrary CampaignLibrary {\r\n\r\n    struct Campaign {\r\n        bytes32 bidId;\r\n        uint price;\r\n        uint budget;\r\n        uint startDate;\r\n        uint endDate;\r\n        bool valid;\r\n        address  owner;\r\n    }\r\n\r\n    function convertCountryIndexToBytes(uint[] countries) internal returns (uint,uint,uint){\r\n        uint countries1 = 0;\r\n        uint countries2 = 0;\r\n        uint countries3 = 0;\r\n        for(uint i = 0; i < countries.length; i++){\r\n            uint index = countries[i];\r\n\r\n            if(index<256){\r\n                countries1 = countries1 | uint(1) << index;\r\n            } else if (index<512) {\r\n                countries2 = countries2 | uint(1) << (index - 256);\r\n            } else {\r\n                countries3 = countries3 | uint(1) << (index - 512);\r\n            }\r\n        }\r\n\r\n        return (countries1,countries2,countries3);\r\n    }\r\n\r\n    \r\n}\r\n\r\n\r\ncontract AdvertisementStorage {\r\n\r\n    mapping (bytes32 => CampaignLibrary.Campaign) campaigns;\r\n    mapping (address => bool) allowedAddresses;\r\n    address public owner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedAddress() {\r\n        require(allowedAddresses[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    event CampaignCreated\r\n        (\r\n            bytes32 bidId,\r\n            uint price,\r\n            uint budget,\r\n            uint startDate,\r\n            uint endDate,\r\n            bool valid,\r\n            address owner\r\n    );\r\n\r\n    event CampaignUpdated\r\n        (\r\n            bytes32 bidId,\r\n            uint price,\r\n            uint budget,\r\n            uint startDate,\r\n            uint endDate,\r\n            bool valid,\r\n            address  owner\r\n    );\r\n\r\n    function AdvertisementStorage() public {\r\n        owner = msg.sender;\r\n        allowedAddresses[msg.sender] = true;\r\n    }\r\n\r\n    function setAllowedAddresses(address newAddress, bool isAllowed) public onlyOwner {\r\n        allowedAddresses[newAddress] = isAllowed;\r\n    }\r\n\r\n\r\n    function getCampaign(bytes32 campaignId)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32,\r\n            uint,\r\n            uint,\r\n            uint,\r\n            uint,\r\n            bool,\r\n            address\r\n        ) {\r\n\r\n        CampaignLibrary.Campaign storage campaign = campaigns[campaignId];\r\n\r\n        return (\r\n            campaign.bidId,\r\n            campaign.price,\r\n            campaign.budget,\r\n            campaign.startDate,\r\n            campaign.endDate,\r\n            campaign.valid,\r\n            campaign.owner\r\n        );\r\n    }\r\n\r\n\r\n    function setCampaign (\r\n        bytes32 bidId,\r\n        uint price,\r\n        uint budget,\r\n        uint startDate,\r\n        uint endDate,\r\n        bool valid,\r\n        address owner\r\n    )\r\n    public\r\n    onlyAllowedAddress {\r\n\r\n        CampaignLibrary.Campaign memory campaign = campaigns[campaign.bidId];\r\n\r\n        campaign = CampaignLibrary.Campaign({\r\n            bidId: bidId,\r\n            price: price,\r\n            budget: budget,\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            valid: valid,\r\n            owner: owner\r\n        });\r\n\r\n        emitEvent(campaign);\r\n\r\n        campaigns[campaign.bidId] = campaign;\r\n        \r\n    }\r\n\r\n    function getCampaignPriceById(bytes32 bidId)\r\n        public\r\n        view\r\n        returns (uint) {\r\n        return campaigns[bidId].price;\r\n    }\r\n\r\n    function setCampaignPriceById(bytes32 bidId, uint price)\r\n        public\r\n        onlyAllowedAddress\r\n        {\r\n        campaigns[bidId].price = price;\r\n        emitEvent(campaigns[bidId]);\r\n    }\r\n\r\n    function getCampaignBudgetById(bytes32 bidId)\r\n        public\r\n        view\r\n        returns (uint) {\r\n        return campaigns[bidId].budget;\r\n    }\r\n\r\n    function setCampaignBudgetById(bytes32 bidId, uint newBudget)\r\n        public\r\n        onlyAllowedAddress\r\n        {\r\n        campaigns[bidId].budget = newBudget;\r\n        emitEvent(campaigns[bidId]);\r\n    }\r\n\r\n    function getCampaignStartDateById(bytes32 bidId)\r\n        public\r\n        view\r\n        returns (uint) {\r\n        return campaigns[bidId].startDate;\r\n    }\r\n\r\n    function setCampaignStartDateById(bytes32 bidId, uint newStartDate)\r\n        public\r\n        onlyAllowedAddress\r\n        {\r\n        campaigns[bidId].startDate = newStartDate;\r\n        emitEvent(campaigns[bidId]);\r\n    }\r\n\r\n    function getCampaignEndDateById(bytes32 bidId)\r\n        public\r\n        view\r\n        returns (uint) {\r\n        return campaigns[bidId].endDate;\r\n    }\r\n\r\n    function setCampaignEndDateById(bytes32 bidId, uint newEndDate)\r\n        public\r\n        onlyAllowedAddress\r\n        {\r\n        campaigns[bidId].endDate = newEndDate;\r\n        emitEvent(campaigns[bidId]);\r\n    }\r\n\r\n    function getCampaignValidById(bytes32 bidId)\r\n        public\r\n        view\r\n        returns (bool) {\r\n        return campaigns[bidId].valid;\r\n    }\r\n\r\n    function setCampaignValidById(bytes32 bidId, bool isValid)\r\n        public\r\n        onlyAllowedAddress\r\n        {\r\n        campaigns[bidId].valid = isValid;\r\n        emitEvent(campaigns[bidId]);\r\n    }\r\n\r\n    function getCampaignOwnerById(bytes32 bidId)\r\n        public\r\n        view\r\n        returns (address) {\r\n        return campaigns[bidId].owner;\r\n    }\r\n\r\n    function setCampaignOwnerById(bytes32 bidId, address newOwner)\r\n        public\r\n        onlyAllowedAddress\r\n        {\r\n        campaigns[bidId].owner = newOwner;\r\n        emitEvent(campaigns[bidId]);\r\n    }\r\n\r\n    function emitEvent(CampaignLibrary.Campaign campaign) private {\r\n\r\n        if (campaigns[campaign.bidId].bidId == 0x0) {\r\n            emit CampaignCreated(\r\n                campaign.bidId,\r\n                campaign.price,\r\n                campaign.budget,\r\n                campaign.startDate,\r\n                campaign.endDate,\r\n                campaign.valid,\r\n                campaign.owner\r\n            );\r\n        } else {\r\n            emit CampaignUpdated(\r\n                campaign.bidId,\r\n                campaign.price,\r\n                campaign.budget,\r\n                campaign.startDate,\r\n                campaign.endDate,\r\n                campaign.valid,\r\n                campaign.owner\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ncontract AdvertisementFinance {\r\n\r\n    mapping (address => uint256) balanceDevelopers;\r\n    mapping (address => bool) developerExists;\r\n    \r\n    address[] developers;\r\n    address owner;\r\n    address advertisementContract;\r\n    address advStorageContract;\r\n    AppCoins appc;\r\n\r\n    modifier onlyOwner() { \r\n        require(owner == msg.sender); \r\n        _; \r\n    }\r\n\r\n    modifier onlyAds() { \r\n        require(advertisementContract == msg.sender); \r\n        _; \r\n    }\r\n\r\n    modifier onlyOwnerOrAds() { \r\n        require(msg.sender == owner || msg.sender == advertisementContract); \r\n        _; \r\n    }\t\r\n\r\n    function AdvertisementFinance (address _addrAppc) \r\n        public {\r\n        owner = msg.sender;\r\n        appc = AppCoins(_addrAppc);\r\n        advStorageContract = 0x0;\r\n    }\r\n\r\n    function setAdsStorageAddress (address _addrStorage) external onlyOwnerOrAds {\r\n        reset();\r\n        advStorageContract = _addrStorage;\r\n    }\r\n\r\n    function setAdsContractAddress (address _addrAdvert) external onlyOwner {\r\n        // Verify if the new Ads contract is using the same storage as before \r\n        if (advertisementContract != 0x0){\r\n            Advertisement adsContract = Advertisement(advertisementContract);\r\n            address adsStorage = adsContract.getAdvertisementStorageAddress();\r\n            require (adsStorage == advStorageContract);\r\n        }\r\n        \r\n        //Update contract\r\n        advertisementContract = _addrAdvert;\r\n    }\r\n    \r\n\r\n    function increaseBalance(address _developer, uint256 _value) \r\n        public onlyAds{\r\n\r\n        if(developerExists[_developer] == false){\r\n            developers.push(_developer);\r\n            developerExists[_developer] = true;\r\n        }\r\n\r\n        balanceDevelopers[_developer] += _value;\r\n    }\r\n\r\n    function pay(address _developer, address _destination, uint256 _value) \r\n        public onlyAds{\r\n\r\n        appc.transfer( _destination, _value);\r\n        balanceDevelopers[_developer] -= _value;\r\n    }\r\n\r\n    function withdraw(address _developer, uint256 _value) public onlyOwnerOrAds {\r\n\r\n        require(balanceDevelopers[_developer] >= _value);\r\n        \r\n        appc.transfer(_developer, _value);\r\n        balanceDevelopers[_developer] -= _value;    \r\n    }\r\n\r\n    function reset() public onlyOwnerOrAds {\r\n        for(uint i = 0; i < developers.length; i++){\r\n            withdraw(developers[i],balanceDevelopers[developers[i]]);\r\n        }\r\n    }\r\n    \r\n\r\n}\t\r\n\r\ncontract ERC20Interface {\r\n    function name() public view returns(bytes32);\r\n    function symbol() public view returns(bytes32);\r\n    function balanceOf (address _owner) public view returns(uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n\r\ncontract AppCoins is ERC20Interface{\r\n    // Public variables of the token\r\n    address public owner;\r\n    bytes32 private token_name;\r\n    bytes32 private token_symbol;\r\n    uint8 public decimals = 18;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function AppCoins() public {\r\n        owner = msg.sender;\r\n        token_name = \"AppCoins\";\r\n        token_symbol = \"APPC\";\r\n        uint256 _totalSupply = 1000000;\r\n        totalSupply = _totalSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        balances[owner] = totalSupply;                // Give the creator all initial tokens\r\n    }\r\n\r\n    function name() public view returns(bytes32) {\r\n        return token_name;\r\n    }\r\n\r\n    function symbol() public view returns(bytes32) {\r\n        return token_symbol;\r\n    }\r\n\r\n    function balanceOf (address _owner) public view returns(uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[_from] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        // Subtract from the sender\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balances[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n    // /**\r\n    //  * Transfer tokens\r\n    //  *\r\n    //  * Send `_value` tokens to `_to` from your account\r\n    //  *\r\n    //  * @param _to The address of the recipient\r\n    //  * @param _value the amount to send\r\n    //  */\r\n    // function transfer(address _to, uint256 _value) public {\r\n    //     _transfer(msg.sender, _to, _value);\r\n    // }\r\n    function transfer (address _to, uint256 _amount) public returns (bool success) {\r\n        if( balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            emit Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return allowance[_from][msg.sender];\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The Advertisement contract collects campaigns registered by developers\r\n * and executes payments to users using campaign registered applications\r\n * after proof of Attention.\r\n */\r\ncontract Advertisement {\r\n\r\n    struct ValidationRules {\r\n        bool vercode;\r\n        bool ipValidation;\r\n        bool country;\r\n        uint constipDailyConversions;\r\n        uint walletDailyConversions;\r\n    }\r\n\r\n    uint constant expectedPoALength = 12;\r\n\r\n    ValidationRules public rules;\r\n    bytes32[] bidIdList;\r\n    AppCoins appc;\r\n    AdvertisementStorage advertisementStorage;\r\n    AdvertisementFinance advertisementFinance;\r\n    address public owner;\r\n    mapping (address => mapping (bytes32 => bool)) userAttributions;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    event PoARegistered(bytes32 bidId, string packageName,uint64[] timestampList,uint64[] nonceList,string walletName, bytes2 countryCode);\r\n    event Error(string func, string message);\r\n    event CampaignInformation\r\n        (\r\n            bytes32 bidId,\r\n            address  owner,\r\n            string ipValidator,\r\n            string packageName,\r\n            uint[3] countries,\r\n            uint[] vercodes\r\n    );\r\n\r\n    /**\r\n    * Constructor function\r\n    *\r\n    * Initializes contract with default validation rules\r\n    */\r\n    function Advertisement (address _addrAppc, address _addrAdverStorage, address _addrAdverFinance) public {\r\n        rules = ValidationRules(false, true, true, 2, 1);\r\n        owner = msg.sender;\r\n        appc = AppCoins(_addrAppc);\r\n        advertisementStorage = AdvertisementStorage(_addrAdverStorage);\r\n        advertisementFinance = AdvertisementFinance(_addrAdverFinance);\r\n    }\r\n\r\n    struct Map {\r\n        mapping (address => uint256) balance;\r\n        address[] devs;\r\n    }\r\n\r\n    function upgradeFinance (address addrAdverFinance) public onlyOwner {\r\n        AdvertisementFinance newAdvFinance = AdvertisementFinance(addrAdverFinance);\r\n        Map storage devBalance;    \r\n\r\n        for(uint i = 0; i < bidIdList.length; i++) {\r\n            address dev = advertisementStorage.getCampaignOwnerById(bidIdList[i]);\r\n            \r\n            if(devBalance.balance[dev] == 0){\r\n                devBalance.devs.push(dev);\r\n            }\r\n            \r\n            devBalance.balance[dev] += advertisementStorage.getCampaignBudgetById(bidIdList[i]);\r\n        }        \r\n\r\n        for(i = 0; i < devBalance.devs.length; i++) {\r\n            advertisementFinance.pay(devBalance.devs[i],address(newAdvFinance),devBalance.balance[devBalance.devs[i]]);\r\n            newAdvFinance.increaseBalance(devBalance.devs[i],devBalance.balance[devBalance.devs[i]]);\r\n        }\r\n\r\n        uint256 oldBalance = appc.balances(address(advertisementFinance));\r\n\r\n        require(oldBalance == 0);\r\n\r\n        advertisementFinance = newAdvFinance;\r\n    }\r\n\r\n    /**\r\n    * Upgrade storage function\r\n    *\r\n    * Upgrades AdvertisementStorage contract addres with no need to redeploy\r\n    * Advertisement contract however every campaign in the old contract will\r\n    * be canceled\r\n    */\r\n\r\n    function upgradeStorage (address addrAdverStorage) public onlyOwner {\r\n        for(uint i = 0; i < bidIdList.length; i++) {\r\n            cancelCampaign(bidIdList[i]);\r\n        }\r\n        delete bidIdList;\r\n        advertisementFinance.reset();\r\n        advertisementFinance.setAdsStorageAddress(addrAdverStorage);\r\n        advertisementStorage = AdvertisementStorage(addrAdverStorage);\r\n    }\r\n\r\n    /**\r\n    * Get AdvertisementStorageAddress\r\n    *\r\n    * Is required to upgrade Advertisement contract address on\r\n    * Advertisement Finance contract\r\n    */\r\n\r\n    function getAdvertisementStorageAddress() public view returns(address _contract) {\r\n        require (msg.sender == address(advertisementFinance));\r\n\r\n        return address(advertisementStorage);\r\n    }\r\n\r\n\r\n    /**\r\n    * Creates a campaign for a certain package name with\r\n    * a defined price and budget\r\n    */\r\n\r\n    function createCampaign (\r\n        string packageName,\r\n        uint[3] countries,\r\n        uint[] vercodes,\r\n        uint price,\r\n        uint budget,\r\n        uint startDate,\r\n        uint endDate)\r\n        external {\r\n\r\n        require(budget >= price);\r\n        require(endDate >= startDate);\r\n\r\n        CampaignLibrary.Campaign memory newCampaign;\r\n\r\n        newCampaign.price = price;\r\n        newCampaign.startDate = startDate;\r\n        newCampaign.endDate = endDate;\r\n\r\n        //Transfers the budget to contract address\r\n        if(appc.allowance(msg.sender, address(this)) < budget){\r\n            emit Error(\"createCampaign\",\"Not enough allowance\");\r\n            return;\r\n        }\r\n\r\n        appc.transferFrom(msg.sender, address(advertisementFinance), budget);\r\n\r\n        advertisementFinance.increaseBalance(msg.sender,budget);\r\n\r\n        newCampaign.budget = budget;\r\n        newCampaign.owner = msg.sender;\r\n        newCampaign.valid = true;\r\n        newCampaign.bidId = uintToBytes(bidIdList.length);\r\n        addCampaign(newCampaign);\r\n\r\n        emit CampaignInformation(\r\n            newCampaign.bidId,\r\n            newCampaign.owner,\r\n            \"\", // ipValidator field\r\n            packageName,\r\n            countries,\r\n            vercodes);\r\n    }\r\n\r\n    function addCampaign(CampaignLibrary.Campaign campaign) internal {\r\n\r\n\t\t//Add to bidIdList\r\n        bidIdList.push(campaign.bidId);\r\n\r\n\t\t//Add to campaign map\r\n        advertisementStorage.setCampaign(\r\n            campaign.bidId,\r\n            campaign.price,\r\n            campaign.budget,\r\n            campaign.startDate,\r\n            campaign.endDate,\r\n            campaign.valid,\r\n            campaign.owner\r\n        );\r\n\r\n    }\r\n\r\n    function registerPoA (\r\n        string packageName, bytes32 bidId,\r\n        uint64[] timestampList, uint64[] nonces,\r\n        address appstore, address oem,\r\n        string walletName, bytes2 countryCode) external {\r\n\r\n        if(!isCampaignValid(bidId)){\r\n            emit Error(\r\n                \"registerPoA\",\"Registering a Proof of attention to a invalid campaign\");\r\n            return;\r\n        }\r\n\r\n        if(timestampList.length != expectedPoALength){\r\n            emit Error(\"registerPoA\",\"Proof-of-attention should have exactly 12 proofs\");\r\n            return;\r\n        }\r\n\r\n        if(timestampList.length != nonces.length){\r\n            emit Error(\r\n                \"registerPoA\",\"Nounce list and timestamp list must have same length\");\r\n            return;\r\n        }\r\n        //Expect ordered array arranged in ascending order\r\n        for (uint i = 0; i < timestampList.length - 1; i++) {\r\n            uint timestampDiff = (timestampList[i+1]-timestampList[i]);\r\n            if((timestampDiff / 1000) != 10){\r\n                emit Error(\r\n                    \"registerPoA\",\"Timestamps should be spaced exactly 10 secounds\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        /* if(!areNoncesValid(bytes(packageName), timestampList, nonces)){\r\n            emit Error(\r\n                \"registerPoA\",\"Incorrect nounces for submited proof of attention\");\r\n            return;\r\n        } */\r\n\r\n        if(userAttributions[msg.sender][bidId]){\r\n            emit Error(\r\n                \"registerPoA\",\"User already registered a proof of attention for this campaign\");\r\n            return;\r\n        }\r\n        //atribute\r\n        userAttributions[msg.sender][bidId] = true;\r\n\r\n        payFromCampaign(bidId, appstore, oem);\r\n\r\n        emit PoARegistered(bidId, packageName, timestampList, nonces, walletName, countryCode);\r\n    }\r\n\r\n    function cancelCampaign (bytes32 bidId) public {\r\n        address campaignOwner = getOwnerOfCampaign(bidId);\r\n\r\n\t\t// Only contract owner or campaign owner can cancel a campaign\r\n        require(owner == msg.sender || campaignOwner == msg.sender);\r\n        uint budget = getBudgetOfCampaign(bidId);\r\n\r\n        advertisementFinance.withdraw(campaignOwner, budget);\r\n\r\n        advertisementStorage.setCampaignBudgetById(bidId, 0);\r\n        advertisementStorage.setCampaignValidById(bidId, false);\r\n    }\r\n\r\n    function getCampaignValidity(bytes32 bidId) public view returns(bool){\r\n        return advertisementStorage.getCampaignValidById(bidId);\r\n    }\r\n\r\n    function getPriceOfCampaign (bytes32 bidId) public view returns(uint) {\r\n        return advertisementStorage.getCampaignPriceById(bidId);\r\n    }\r\n\r\n    function getStartDateOfCampaign (bytes32 bidId) public view returns(uint) {\r\n        return advertisementStorage.getCampaignStartDateById(bidId);\r\n    }\r\n\r\n    function getEndDateOfCampaign (bytes32 bidId) public view returns(uint) {\r\n        return advertisementStorage.getCampaignEndDateById(bidId);\r\n    }\r\n\r\n    function getBudgetOfCampaign (bytes32 bidId) public view returns(uint) {\r\n        return advertisementStorage.getCampaignBudgetById(bidId);\r\n    }\r\n\r\n    function getOwnerOfCampaign (bytes32 bidId) public view returns(address) {\r\n        return advertisementStorage.getCampaignOwnerById(bidId);\r\n    }\r\n\r\n    function getBidIdList() public view returns(bytes32[]) {\r\n        return bidIdList;\r\n    }\r\n\r\n    function isCampaignValid(bytes32 bidId) public view returns(bool) {\r\n        uint startDate = advertisementStorage.getCampaignStartDateById(bidId);\r\n        uint endDate = advertisementStorage.getCampaignEndDateById(bidId);\r\n        bool valid = advertisementStorage.getCampaignValidById(bidId);\r\n\r\n        uint nowInMilliseconds = now * 1000;\r\n        return valid && startDate < nowInMilliseconds && endDate > nowInMilliseconds;\r\n    }\r\n\r\n    function payFromCampaign (bytes32 bidId, address appstore, address oem) internal {\r\n        uint devShare = 85;\r\n        uint appstoreShare = 10;\r\n        uint oemShare = 5;\r\n\r\n        //Search bid price\r\n        uint price = advertisementStorage.getCampaignPriceById(bidId);\r\n        uint budget = advertisementStorage.getCampaignBudgetById(bidId);\r\n        address campaignOwner = advertisementStorage.getCampaignOwnerById(bidId);\r\n\r\n        require(budget > 0);\r\n        require(budget >= price);\r\n\r\n        //transfer to user, appstore and oem\r\n        advertisementFinance.pay(campaignOwner,msg.sender,division(price * devShare, 100));\r\n        advertisementFinance.pay(campaignOwner,appstore,division(price * appstoreShare, 100));\r\n        advertisementFinance.pay(campaignOwner,oem,division(price * oemShare, 100));\r\n\r\n        //subtract from campaign\r\n        uint newBudget = budget - price;\r\n\r\n        advertisementStorage.setCampaignBudgetById(bidId, newBudget);\r\n\r\n\r\n        if (newBudget < price) {\r\n            advertisementStorage.setCampaignValidById(bidId, false);\r\n        }\r\n    }\r\n\r\n    function areNoncesValid (bytes packageName,uint64[] timestampList, uint64[] nonces) internal returns(bool) {\r\n\r\n        for(uint i = 0; i < nonces.length; i++){\r\n            bytes8 timestamp = bytes8(timestampList[i]);\r\n            bytes8 nonce = bytes8(nonces[i]);\r\n            bytes memory byteList = new bytes(packageName.length + timestamp.length);\r\n\r\n            for(uint j = 0; j < packageName.length;j++){\r\n                byteList[j] = packageName[j];\r\n            }\r\n\r\n            for(j = 0; j < timestamp.length; j++ ){\r\n                byteList[j + packageName.length] = timestamp[j];\r\n            }\r\n\r\n            bytes32 result = sha256(byteList);\r\n\r\n            bytes memory noncePlusHash = new bytes(result.length + nonce.length);\r\n\r\n            for(j = 0; j < nonce.length; j++){\r\n                noncePlusHash[j] = nonce[j];\r\n            }\r\n\r\n            for(j = 0; j < result.length; j++){\r\n                noncePlusHash[j + nonce.length] = result[j];\r\n            }\r\n\r\n            result = sha256(noncePlusHash);\r\n\r\n            bytes2[1] memory leadingBytes = [bytes2(0)];\r\n            bytes2 comp = 0x0000;\r\n\r\n            assembly{\r\n            \tmstore(leadingBytes,result)\r\n            }\r\n\r\n            if(comp != leadingBytes[0]){\r\n                return false;\r\n            }\r\n\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function division(uint numerator, uint denominator) public view returns (uint) {\r\n        uint _quotient = numerator / denominator;\r\n        return _quotient;\r\n    }\r\n\r\n    function uintToBytes (uint256 i) public view returns(bytes32 b) {\r\n        b = bytes32(i);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"getEndDateOfCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBidIdList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rules\",\"outputs\":[{\"name\":\"vercode\",\"type\":\"bool\"},{\"name\":\"ipValidation\",\"type\":\"bool\"},{\"name\":\"country\",\"type\":\"bool\"},{\"name\":\"constipDailyConversions\",\"type\":\"uint256\"},{\"name\":\"walletDailyConversions\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"getPriceOfCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"getCampaignValidity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrAdverFinance\",\"type\":\"address\"}],\"name\":\"upgradeFinance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdvertisementStorageAddress\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrAdverStorage\",\"type\":\"address\"}],\"name\":\"upgradeStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"countries\",\"type\":\"uint256[3]\"},{\"name\":\"vercodes\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"budget\",\"type\":\"uint256\"},{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"createCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"uintToBytes\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"getOwnerOfCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"bidId\",\"type\":\"bytes32\"},{\"name\":\"timestampList\",\"type\":\"uint64[]\"},{\"name\":\"nonces\",\"type\":\"uint64[]\"},{\"name\":\"appstore\",\"type\":\"address\"},{\"name\":\"oem\",\"type\":\"address\"},{\"name\":\"walletName\",\"type\":\"string\"},{\"name\":\"countryCode\",\"type\":\"bytes2\"}],\"name\":\"registerPoA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"isCampaignValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"cancelCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"division\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"getStartDateOfCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bidId\",\"type\":\"bytes32\"}],\"name\":\"getBudgetOfCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addrAppc\",\"type\":\"address\"},{\"name\":\"_addrAdverStorage\",\"type\":\"address\"},{\"name\":\"_addrAdverFinance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"packageName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"timestampList\",\"type\":\"uint64[]\"},{\"indexed\":false,\"name\":\"nonceList\",\"type\":\"uint64[]\"},{\"indexed\":false,\"name\":\"walletName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"countryCode\",\"type\":\"bytes2\"}],\"name\":\"PoARegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"func\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipValidator\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"packageName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"countries\",\"type\":\"uint256[3]\"},{\"indexed\":false,\"name\":\"vercodes\",\"type\":\"uint256[]\"}],\"name\":\"CampaignInformation\",\"type\":\"event\"}]","ContractName":"Advertisement","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001a7a8bd9106f2b8d977e08582dc7d24c723ab0db000000000000000000000000bd6ceb311557f3b2f1a138f8d8fbfca05a6b61e20000000000000000000000009291be1e406c8e36f1db5cfc4776f9b38148d9be","Library":"","SwarmSource":"bzzr://510dfc0ee7e3aa50c2478334e2e03a604ea57a346a0114e539fb8b7df3515197"}]}