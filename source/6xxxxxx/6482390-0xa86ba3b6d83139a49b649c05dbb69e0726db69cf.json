{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: @ensdomains/ens/contracts/ENS.sol\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\r\n    function setResolver(bytes32 node, address resolver) public;\r\n    function setOwner(bytes32 node, address owner) public;\r\n    function setTTL(bytes32 node, uint64 ttl) public;\r\n    function owner(bytes32 node) public view returns (address);\r\n    function resolver(bytes32 node) public view returns (address);\r\n    function ttl(bytes32 node) public view returns (uint64);\r\n\r\n}\r\n\r\n// File: contracts/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage _role, address _account)\r\n    internal\r\n  {\r\n    _role.bearer[_account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage _role, address _account)\r\n    internal\r\n  {\r\n    _role.bearer[_account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _account)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _account));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_account];\r\n  }\r\n}\r\n\r\n// File: contracts/RBAC.sol\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * Supports unlimited numbers of roles and addresses.\r\n * See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n * for you to write your own implementation of this interface using Enums or similar.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n    public\r\n    view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function _addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function _removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param _roles the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] _roles) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < _roles.length; i++) {\r\n  //         if (hasRole(msg.sender, _roles[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n// File: contracts/OwnerResolver.sol\r\n\r\ncontract OwnerResolver {\r\n    ENS public ens;\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n    }\r\n\r\n    function addr(bytes32 node) public view returns(address) {\r\n        return ens.owner(node);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x3b3b57de;\r\n    }\r\n}\r\n\r\n// File: contracts/OwnedRegistrar.sol\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n/**\r\n * OwnedRegistrar implements an ENS registrar that accepts registrations by a\r\n * list of approved parties (IANA registrars). Registrations must be submitted\r\n * by a \"transactor\", and signed by a \"registrar\". Registrars can be added or\r\n * removed by an account with the \"authoriser\" role.\r\n *\r\n * An audit of this code is available here: https://hackmd.io/s/SJcPchO57\r\n */\r\ncontract OwnedRegistrar is RBAC {\r\n    ENS public ens;\r\n    OwnerResolver public resolver;\r\n    mapping(uint=>mapping(address=>bool)) public registrars; // Maps IANA IDs to authorised accounts\r\n    mapping(bytes32=>uint) public nonces; // Maps namehashes to domain nonces\r\n\r\n    event RegistrarAdded(uint id, address registrar);\r\n    event RegistrarRemoved(uint id, address registrar);\r\n    event Associate(bytes32 indexed node, bytes32 indexed subnode, address indexed owner);\r\n    event Disassociate(bytes32 indexed node, bytes32 indexed subnode);\r\n\r\n    constructor(ENS _ens) public {\r\n        ens = _ens;\r\n        resolver = new OwnerResolver(_ens);\r\n        _addRole(msg.sender, \"owner\");\r\n    }\r\n\r\n    function addRole(address addr, string role) external onlyRole(\"owner\") {\r\n        _addRole(addr, role);\r\n    }\r\n\r\n    function removeRole(address addr, string role) external onlyRole(\"owner\") {\r\n        // Don't allow owners to remove themselves\r\n        require(keccak256(abi.encode(role)) != keccak256(abi.encode(\"owner\")) || msg.sender != addr);\r\n        _removeRole(addr, role);\r\n    }\r\n\r\n    function setRegistrar(uint id, address registrar) public onlyRole(\"authoriser\") {\r\n        registrars[id][registrar] = true;\r\n        emit RegistrarAdded(id, registrar);\r\n    }\r\n\r\n    function unsetRegistrar(uint id, address registrar) public onlyRole(\"authoriser\") {\r\n        registrars[id][registrar] = false;\r\n        emit RegistrarRemoved(id, registrar);\r\n    }\r\n\r\n    function associateWithSig(bytes32 node, bytes32 label, address owner, uint nonce, uint registrarId, bytes32 r, bytes32 s, uint8 v) public onlyRole(\"transactor\") {\r\n        bytes32 subnode = keccak256(abi.encode(node, label));\r\n        require(nonce == nonces[subnode]);\r\n        nonces[subnode]++;\r\n\r\n        bytes32 sighash = keccak256(abi.encode(subnode, owner, nonce));\r\n        address registrar = ecrecover(sighash, v, r, s);\r\n        require(registrars[registrarId][registrar]);\r\n\r\n        ens.setSubnodeOwner(node, label, address(this));\r\n        if(owner == 0) {\r\n            ens.setResolver(subnode, 0);\r\n        } else {\r\n            ens.setResolver(subnode, resolver);\r\n        }\r\n        ens.setOwner(subnode, owner);\r\n\r\n        emit Associate(node, label, owner);\r\n    }\r\n\r\n    function multicall(bytes[] calls) public {\r\n        for(uint i = 0; i < calls.length; i++) {\r\n            require(address(this).delegatecall(calls[i]));\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"string\"}],\"name\":\"removeRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registrars\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"node\",\"type\":\"bytes32\"},{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"registrarId\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"associateWithSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"setRegistrar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"string\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"unsetRegistrar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"calls\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"RegistrarAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"RegistrarRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"subnode\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Associate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"subnode\",\"type\":\"bytes32\"}],\"name\":\"Disassociate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"}]","ContractName":"OwnedRegistrar","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b","Library":"","SwarmSource":"bzzr://811d1b709287da3943d1756725d19fad06fb73d3716815108eb11a69f9852dd6"}]}