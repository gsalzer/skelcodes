{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\nlibrary SafeMath {\r\n\r\n  // We use `pure` bbecause it promises that the value for the function depends ONLY\r\n  // on the function arguments\r\n    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface RTCoinInterface {\r\n    \r\n\r\n    /** Functions - ERC20 */\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(address _owner, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool approved);\r\n\r\n    /** Getters - ERC20 */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    /** Getters - Custom */\r\n    function mint(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function stakeContractAddress() external view returns (address);\r\n\r\n    function mergedMinerValidatorAddress() external view returns (address);\r\n    \r\n    /** Functions - Custom */\r\n    function freezeTransfers() external returns (bool);\r\n\r\n    function thawTransfers() external returns (bool);\r\n}\r\n\r\n/// @title Merged Miner Validator allows people who mine mainnet Ethereum blocks to also mint RTC\r\n/// @author Postables, RTrade Technologies Ltd\r\n/// @notice Version 1, future versions will require a non-interactive block submissinon method\r\n/// @dev We able V5 for safety features, see https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html#take-warnings-seriously\r\ncontract MergedMinerValidator {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    // 0.5\r\n    uint256 constant public SUBMISSIONREWARD = 500000000000000000;\r\n    // 0.3\r\n    uint256 constant public BLOCKREWARD = 300000000000000000;\r\n    string  constant public VERSION = \"production\";\r\n    address constant public TOKENADDRESS = 0xecc043b92834c1ebDE65F2181B59597a6588D616;\r\n    RTCoinInterface constant public RTI = RTCoinInterface(TOKENADDRESS);\r\n    \r\n    address public tokenAddress;\r\n    address public admin;\r\n    uint256 public lastBlockSet;\r\n\r\n    enum BlockStateEnum { nil, submitted, claimed }\r\n\r\n    struct Blocks {\r\n        uint256 number;\r\n        address coinbase;\r\n        BlockStateEnum state;\r\n    }\r\n\r\n    mapping (uint256 => Blocks) public blocks;\r\n    mapping (uint256 => bytes) public hashedBlocks;\r\n    event BlockInformationSubmitted(address indexed _coinbase, uint256 indexed _blockNumber, address _submitter);\r\n    event MergedMinedRewardClaimed(address indexed _claimer, uint256[] indexed _blockNumbers, uint256 _totalReward);\r\n\r\n    modifier submittedBlock(uint256 _blockNum) {\r\n        require(blocks[_blockNum].state == BlockStateEnum.submitted, \"block state must be submitted\");\r\n        _;\r\n\r\n    }\r\n\r\n    modifier nonSubmittedBlock(uint256 _blockNum) {\r\n        require(blocks[_blockNum].state == BlockStateEnum.nil, \"block state must be empty\");\r\n        _;\r\n    }\r\n\r\n    modifier isCoinbase(uint256 _blockNumber) {\r\n        require(msg.sender == blocks[_blockNumber].coinbase, \"sender must be coinbase\");\r\n        _;\r\n    }\r\n\r\n    modifier canMint() {\r\n        require(RTI.mergedMinerValidatorAddress() == address(this), \"merged miner contract on rtc token must be set to this contract\");\r\n        _;\r\n    }\r\n\r\n    modifier notCurrentSetBlock(uint256 _blockNumber) {\r\n        require(_blockNumber > lastBlockSet, \"unable to submit information for already submitted block\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only an admin can invoke this function\");\r\n        _;\r\n    }\r\n\r\n    modifier tokenAddressNotSet() {\r\n        require(tokenAddress == address(0), \"token address must not be set\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _admin) public {\r\n        admin = _admin;\r\n        Blocks memory b = Blocks({\r\n            number: block.number,\r\n            coinbase: block.coinbase,\r\n            state: BlockStateEnum.submitted\r\n        });\r\n        lastBlockSet = block.number;\r\n        blocks[block.number] = b;\r\n        // we use address(0) and don't mint any tokens, since \"we are submitting the information\" \r\n        emit BlockInformationSubmitted(block.coinbase, block.number, address(0));\r\n    }\r\n\r\n    /** @notice Used to submit block hash, and block miner information for the current block\r\n        * @dev Future iterations will avoid this process entirely, and use RLP encoded block headers to parse the data.\r\n     */\r\n    function submitBlock() public nonSubmittedBlock(block.number) notCurrentSetBlock(block.number) returns (bool) {\r\n        Blocks memory b = Blocks({\r\n            number: block.number,\r\n            coinbase: block.coinbase,\r\n            state: BlockStateEnum.submitted\r\n        });\r\n        lastBlockSet = block.number;\r\n        blocks[block.number] = b;\r\n        // lets not do a storage lookup so we can avoid SSLOAD gas usage\r\n        emit BlockInformationSubmitted(block.coinbase, block.number, msg.sender);\r\n        require(RTI.mint(msg.sender, SUBMISSIONREWARD), \"failed to transfer reward to block submitter\");\r\n        return true;\r\n    }\r\n    \r\n\r\n    /** @notice Used by a miner to claim their merged mined RTC\r\n        * @param _blockNumber The block number of the block that the person mined\r\n     */\r\n    function claimReward(uint256 _blockNumber) \r\n        internal\r\n        isCoinbase(_blockNumber) \r\n        submittedBlock(_blockNumber)\r\n        returns (uint256) \r\n    {\r\n        // mark the reward as claimed\r\n        blocks[_blockNumber].state = BlockStateEnum.claimed;\r\n        return BLOCKREWARD;\r\n    }\r\n\r\n    /** @notice Used by a miner to bulk claim their merged mined RTC\r\n        * @dev To prevent expensive looping, we throttle to 20 withdrawals at once\r\n        * @param _blockNumbers Contains the block numbers for which they want to claim\r\n     */\r\n    function bulkClaimReward(uint256[] _blockNumbers) external canMint returns (bool) {\r\n        require(_blockNumbers.length <= 20, \"can only claim up to 20 rewards at once\");\r\n        uint256 totalMint;\r\n        for (uint256 i = 0; i < _blockNumbers.length; i++) {\r\n            // update their total amount minted\r\n            totalMint = totalMint.add(claimReward(_blockNumbers[i]));\r\n        }\r\n        emit MergedMinedRewardClaimed(msg.sender, _blockNumbers, totalMint);\r\n        // make sure more than 0 is being claimed\r\n        require(totalMint > 0, \"total coins to mint must be greater than 0\");\r\n        require(RTI.mint(msg.sender, totalMint), \"unable to mint tokens\");\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used to destroy the contract\r\n     */\r\n    function goodNightSweetPrince() public onlyAdmin returns (bool) {\r\n        selfdestruct(msg.sender);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"submitBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBlockSet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUBMISSIONREWARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RTI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashedBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumbers\",\"type\":\"uint256[]\"}],\"name\":\"bulkClaimReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"goodNightSweetPrince\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLOCKREWARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blocks\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"coinbase\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_coinbase\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_submitter\",\"type\":\"address\"}],\"name\":\"BlockInformationSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_blockNumbers\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"name\":\"MergedMinedRewardClaimed\",\"type\":\"event\"}]","ContractName":"MergedMinerValidator","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000041fb0e5bd1dfe3b61e9a09ebd4105c2e35b0bcbd","Library":"","SwarmSource":"bzzr://d3799efcf1c08661b3d40156234c7d92346beecb6e82964fd98659351cde165c"}]}