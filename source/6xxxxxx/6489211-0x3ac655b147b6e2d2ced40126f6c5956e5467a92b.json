{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC223.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n// ----------------------------------------------------------------------------\\n// Owned contract\\n// ----------------------------------------------------------------------------\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n    function acceptOwnership() public {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\\ncontract ERC223 {\\n  uint public totalSupply;\\n  function balanceOf(address who) constant returns (uint);\\n\\n  function name() constant returns (string _name);\\n  function symbol() constant returns (string _symbol);\\n  function decimals() constant returns (uint8 _decimals);\\n  function totalSupply() constant returns (uint256 _supply);\\n\\n  function transfer(address to, uint value) returns (bool ok);\\n  function transfer(address to, uint value, bytes data) returns (bool ok);\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n  event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\\n}\\n\\ncontract ContractReceiver {\\n  function tokenFallback(address _from, uint _value, bytes _data);\\n}\\n\\ncontract ERC223Token is ERC223 {\\n  using SafeMath for uint;\\n\\n  mapping(address =\\u003e uint) balances;\\n\\n  string public name;\\n  string public symbol;\\n  uint8 public decimals;\\n  uint256 public totalSupply;\\n\\n\\n  // Function to access name of token .\\n  function name() constant returns (string _name) {\\n      return name;\\n  }\\n  // Function to access symbol of token .\\n  function symbol() constant returns (string _symbol) {\\n      return symbol;\\n  }\\n  // Function to access decimals of token .\\n  function decimals() constant returns (uint8 _decimals) {\\n      return decimals;\\n  }\\n  // Function to access total supply of tokens .\\n  function totalSupply() constant returns (uint256 _totalSupply) {\\n      return totalSupply;\\n  }\\n\\n  // Function that is called when a user or another contract wants to transfer funds .\\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\\n    if(isContract(_to)) {\\n        return transferToContract(_to, _value, _data);\\n    }\\n    else {\\n        return transferToAddress(_to, _value, _data);\\n    }\\n}\\n\\n  // Standard function transfer similar to ERC20 transfer with no _data .\\n  // Added due to backwards compatibility reasons .\\n  function transfer(address _to, uint _value) returns (bool success) {\\n\\n    //standard function transfer similar to ERC20 transfer with no _data\\n    //added due to backwards compatibility reasons\\n    bytes memory empty;\\n    if(isContract(_to)) {\\n        return transferToContract(_to, _value, empty);\\n    }\\n    else {\\n        return transferToAddress(_to, _value, empty);\\n    }\\n}\\n\\n//assemble the given address bytecode. If bytecode exists then the _addr is a contract.\\n  function isContract(address _addr) private returns (bool is_contract) {\\n      uint length;\\n      assembly {\\n            //retrieve the size of the code on target address, this needs assembly\\n            length := extcodesize(_addr)\\n        }\\n        if(length\\u003e0) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n  //function that is called when transaction target is an address\\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\\n    if (balanceOf(msg.sender) \\u003c _value) revert();\\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\\n    balances[_to] = balanceOf(_to).add(_value);\\n    Transfer(msg.sender, _to, _value);\\n    ERC223Transfer(msg.sender, _to, _value, _data);\\n    return true;\\n  }\\n\\n  //function that is called when transaction target is a contract\\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\\n    if (balanceOf(msg.sender) \\u003c _value) revert();\\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\\n    balances[_to] = balanceOf(_to).add(_value);\\n    ContractReceiver reciever = ContractReceiver(_to);\\n    reciever.tokenFallback(msg.sender, _value, _data);\\n    Transfer(msg.sender, _to, _value);\\n    ERC223Transfer(msg.sender, _to, _value, _data);\\n    return true;\\n  }\\n\\n\\n  function balanceOf(address _owner) constant returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\"},\"GoodGamePlatform.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC223.sol\\\";\\n\\ncontract GoodGamePlatform is ERC223Token, Owned {\\n  string public name = \\\"GoodGamePlatform\\\";\\n  string public symbol = \\\"GGP\\\";\\n  uint public decimals = 18;\\n  uint public totalSupply = 1000000000 * 10**uint(decimals);\\n\\n  function GoodGamePlatform() {\\n    balances[owner] = totalSupply;\\n    emit Transfer(address(0), owner, totalSupply);\\n  }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"ERC223Transfer\",\"type\":\"event\"}]","ContractName":"GoodGamePlatform","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ab9f0fe42d9e16b9e57ac46a758e7fa8f126024174b2d499ea997543c325ce05"}]}