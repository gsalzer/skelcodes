{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\nlibrary BytesLib {\r\n  function toAddress(bytes _bytes, uint _start) internal pure returns (address) {\r\n    require(_bytes.length >= (_start + 20));\r\n    address tempAddress;\r\n\r\n    assembly {\r\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n    }\r\n\r\n    return tempAddress;\r\n  }\r\n\r\n  function toUint(bytes _bytes, uint _start) internal pure returns (uint256) {\r\n    require(_bytes.length >= (_start + 32));\r\n    uint256 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\r\n    require(_bytes.length >= (_start + _length));\r\n    bytes memory tempBytes;\r\n\r\n    assembly {\r\n      switch iszero(_length)\r\n        case 0 {\r\n          // Get a location of some free memory and store it in tempBytes as\r\n          // Solidity does for memory variables.\r\n          tempBytes := mload(0x40)\r\n\r\n          // The first word of the slice result is potentially a partial\r\n          // word read from the original array. To read it, we calculate\r\n          // the length of that partial word and start copying that many\r\n          // bytes into the array. The first word we copy will start with\r\n          // data we don't care about, but the last `lengthmod` bytes will\r\n          // land at the beginning of the contents of the new array. When\r\n          // we're done copying, we overwrite the full first word with\r\n          // the actual length of the slice.\r\n          let lengthmod := and(_length, 31)\r\n\r\n          // The multiplication in the next line is necessary\r\n          // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n          // the following copy loop was copying the origin's length\r\n          // and then ending prematurely not copying everything it should.\r\n          let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n          let end := add(mc, _length)\r\n\r\n          for {\r\n            // The multiplication in the next line has the same exact purpose\r\n            // as the one above.\r\n            let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n          } lt(mc, end) {\r\n            mc := add(mc, 0x20)\r\n            cc := add(cc, 0x20)\r\n          } {\r\n            mstore(mc, mload(cc))\r\n          }\r\n\r\n          mstore(tempBytes, _length)\r\n\r\n          //update free-memory pointer\r\n          //allocating the array padded to 32 bytes like the compiler does now\r\n          mstore(0x40, and(add(mc, 31), not(31)))\r\n        }\r\n        //if we want a zero-length slice let's just return a zero-length array\r\n        default {\r\n          tempBytes := mload(0x40)\r\n          mstore(0x40, add(tempBytes, 0x20))\r\n        }\r\n    }\r\n    return tempBytes;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC223 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n\r\n  function name() constant returns (string _name);\r\n  function symbol() constant returns (string _symbol);\r\n  function decimals() constant returns (uint8 _decimals);\r\n  function totalSupply() constant returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) returns (bool ok);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\r\n}\r\n\r\ncontract ContractReceiver {\r\n  function tokenFallback(address _from, uint _value, bytes _data);\r\n}\r\n\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract TokenAirdrop is ContractReceiver {\r\n  using SafeMath for uint256;\r\n  using BytesLib for bytes;\r\n\r\n  // let users withdraw their tokens\r\n  // person => token => balance\r\n  mapping(address => mapping(address => uint256)) private balances;\r\n  address private etherAddress = 0x0;\r\n\r\n  event Airdrop(\r\n    address from,\r\n    address to,\r\n    bytes message,\r\n    address token,\r\n    uint amount,\r\n    uint time\r\n  );\r\n  event Claim(\r\n    address claimer,\r\n    address token,\r\n    uint amount,\r\n    uint time\r\n  );\r\n\r\n\r\n  // handle incoming ERC223 tokens\r\n  function tokenFallback(address from, uint value, bytes data) public {\r\n    // payload structure\r\n    // [address 20 bytes][utf-8 encoded message]\r\n    require(data.length > 20);\r\n    address beneficiary = data.toAddress(0);\r\n    bytes memory message = data.slice(20, data.length - 20);\r\n    balances[beneficiary][msg.sender] = balances[beneficiary][msg.sender].add(value);\r\n    emit Airdrop(from, beneficiary, message, msg.sender, value, now);\r\n  }\r\n\r\n  // handle ether\r\n  function giftEther(address to, bytes message) public payable {\r\n    require(msg.value > 0);\r\n    balances[to][etherAddress] = balances[to][etherAddress].add(msg.value);\r\n    emit Airdrop(msg.sender, to, message, etherAddress, msg.value, now);\r\n  }\r\n\r\n  // handle ERC20\r\n  function giftERC20(address to, uint amount, address token, bytes message) public {\r\n    ERC20(token).transferFrom(msg.sender, address(this), amount);\r\n    balances[to][token] = balances[to][token].add(amount);\r\n    emit Airdrop(msg.sender, to, message, token, amount, now);\r\n  }\r\n\r\n  function claim(address token) public {\r\n    uint amount = balanceOf(msg.sender, token);\r\n    require(amount > 0);\r\n    balances[msg.sender][token] = 0;\r\n    require(sendTokensTo(msg.sender, amount, token));\r\n    emit Claim(msg.sender, token, amount, now);\r\n  }\r\n\r\n  function balanceOf(address person, address token) public view returns(uint) {\r\n    return balances[person][token];\r\n  }\r\n\r\n  function sendTokensTo(address destination, uint256 amount, address tkn) private returns(bool) {\r\n    if (tkn == etherAddress) {\r\n      destination.transfer(amount);\r\n    } else {\r\n      require(ERC20(tkn).transfer(destination, amount));\r\n    }\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"giftERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"giftEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"person\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"}]","ContractName":"TokenAirdrop","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1a55a1851526297eafe4621b658e6908971598c223362f87a15f24ae1e64e6dd"}]}