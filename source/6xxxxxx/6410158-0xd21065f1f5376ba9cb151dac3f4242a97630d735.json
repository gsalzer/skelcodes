{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: contracts/IMarketplace.sol\r\n\r\ncontract IMarketplace {\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint128 startPrice,\r\n        uint128 endPrice,\r\n        uint128 duration\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/AnimalMarketplace.sol\r\n\r\ncontract AnimalMarketplace is Ownable, IMarketplace {\r\n    using AddressUtils for address;\r\n    using SafeMath for uint256;\r\n    uint8 internal percentFee = 5;\r\n\r\n    ERC721Basic private erc721Contract;\r\n\r\n    struct Auction {\r\n        address tokenOwner;\r\n        uint256 startTime;\r\n        uint128 startPrice;\r\n        uint128 endPrice;\r\n        uint128 duration;\r\n    }\r\n\r\n    struct AuctionEntry {\r\n        uint256 keyIndex;\r\n        Auction value;\r\n    }\r\n\r\n    struct TokenIdAuctionMap {\r\n        mapping(uint256 => AuctionEntry) data;\r\n        uint256[] keys;\r\n    }\r\n\r\n    TokenIdAuctionMap private auctions;\r\n\r\n    event AuctionBoughtEvent(\r\n        uint256 tokenId,\r\n        address previousOwner,\r\n        address newOwner,\r\n        uint256 pricePaid\r\n    );\r\n\r\n    event AuctionCreatedEvent(\r\n        uint256 tokenId,\r\n        uint128 startPrice,\r\n        uint128 endPrice,\r\n        uint128 duration\r\n    );\r\n\r\n    event AuctionCanceledEvent(uint256 tokenId);\r\n\r\n    modifier isNotFromContract() {\r\n        require(!msg.sender.isContract());\r\n        _;\r\n    }\r\n\r\n    constructor(ERC721Basic _erc721Contract) public {\r\n        erc721Contract = _erc721Contract;\r\n    }\r\n\r\n    // \"approve\" in game contract will revert if sender is not token owner\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint128 _startPrice,\r\n        uint128 _endPrice,\r\n        uint128 _duration\r\n    )\r\n        external\r\n    {\r\n        // this can be only called from game contract\r\n        require(msg.sender == address(erc721Contract));\r\n\r\n        AuctionEntry storage entry = auctions.data[_tokenId];\r\n        require(entry.keyIndex == 0);\r\n\r\n        address tokenOwner = erc721Contract.ownerOf(_tokenId);\r\n        erc721Contract.transferFrom(tokenOwner, address(this), _tokenId);\r\n\r\n        entry.value = Auction({\r\n            tokenOwner: tokenOwner,\r\n            startTime: block.timestamp,\r\n            startPrice: _startPrice,\r\n            endPrice: _endPrice,\r\n            duration: _duration\r\n        });\r\n\r\n        entry.keyIndex = ++auctions.keys.length;\r\n        auctions.keys[entry.keyIndex - 1] = _tokenId;\r\n\r\n        emit AuctionCreatedEvent(_tokenId, _startPrice, _endPrice, _duration);\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId) external {\r\n        AuctionEntry storage entry = auctions.data[_tokenId];\r\n        Auction storage auction = entry.value;\r\n        address sender = msg.sender;\r\n        require(sender == auction.tokenOwner);\r\n        erc721Contract.transferFrom(address(this), sender, _tokenId);\r\n        deleteAuction(_tokenId, entry);\r\n        emit AuctionCanceledEvent(_tokenId);\r\n    }\r\n\r\n    function buyAuction(uint256 _tokenId)\r\n        external\r\n        payable\r\n        isNotFromContract\r\n    {\r\n        AuctionEntry storage entry = auctions.data[_tokenId];\r\n        require(entry.keyIndex > 0);\r\n        Auction storage auction = entry.value;\r\n        address sender = msg.sender;\r\n        address tokenOwner = auction.tokenOwner;\r\n        uint256 auctionPrice = calculateCurrentPrice(auction);\r\n        uint256 pricePaid = msg.value;\r\n\r\n        require(pricePaid >= auctionPrice);\r\n        deleteAuction(_tokenId, entry);\r\n\r\n        refundSender(sender, pricePaid, auctionPrice);\r\n        payTokenOwner(tokenOwner, auctionPrice);\r\n        erc721Contract.transferFrom(address(this), sender, _tokenId);\r\n        emit AuctionBoughtEvent(_tokenId, tokenOwner, sender, auctionPrice);\r\n    }\r\n\r\n    function getAuctionByTokenId(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 tokenId,\r\n            address tokenOwner,\r\n            uint128 startPrice,\r\n            uint128 endPrice,\r\n            uint256 startTime,\r\n            uint128 duration,\r\n            uint256 currentPrice,\r\n            bool exists\r\n        )\r\n    {\r\n        AuctionEntry storage entry = auctions.data[_tokenId];\r\n        Auction storage auction = entry.value;\r\n        uint256 calculatedCurrentPrice = calculateCurrentPrice(auction);\r\n        return (\r\n            entry.keyIndex > 0 ? _tokenId : 0,\r\n            auction.tokenOwner,\r\n            auction.startPrice,\r\n            auction.endPrice,\r\n            auction.startTime,\r\n            auction.duration,\r\n            calculatedCurrentPrice,\r\n            entry.keyIndex > 0\r\n        );\r\n    }\r\n\r\n    function getAuctionByIndex(uint256 _auctionIndex)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 tokenId,\r\n            address tokenOwner,\r\n            uint128 startPrice,\r\n            uint128 endPrice,\r\n            uint256 startTime,\r\n            uint128 duration,\r\n            uint256 currentPrice,\r\n            bool exists\r\n        )\r\n    {\r\n        // for consistency with getAuctionByTokenId when returning invalid auction - otherwise it would throw error\r\n        if (_auctionIndex >= auctions.keys.length) {\r\n            return (0, address(0), 0, 0, 0, 0, 0, false);\r\n        }\r\n\r\n        uint256 currentTokenId = auctions.keys[_auctionIndex];\r\n        Auction storage auction = auctions.data[currentTokenId].value;\r\n        uint256 calculatedCurrentPrice = calculateCurrentPrice(auction);\r\n        return (\r\n            currentTokenId,\r\n            auction.tokenOwner,\r\n            auction.startPrice,\r\n            auction.endPrice,\r\n            auction.startTime,\r\n            auction.duration,\r\n            calculatedCurrentPrice,\r\n            true\r\n        );\r\n    }\r\n\r\n    function getAuctionsCount() external view returns (uint256 auctionsCount) {\r\n        return auctions.keys.length;\r\n    }\r\n\r\n    function isOnAuction(uint256 _tokenId) public view returns (bool onAuction) {\r\n        return auctions.data[_tokenId].keyIndex > 0;\r\n    }\r\n\r\n    function withdrawContract() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function refundSender(address _sender, uint256 _pricePaid, uint256 _auctionPrice) private {\r\n        uint256 etherToRefund = _pricePaid.sub(_auctionPrice);\r\n        if (etherToRefund > 0) {\r\n            _sender.transfer(etherToRefund);\r\n        }\r\n    }\r\n\r\n    function payTokenOwner(address _tokenOwner, uint256 _auctionPrice) private {\r\n        uint256 etherToPay = _auctionPrice.sub(_auctionPrice * percentFee / 100);\r\n        if (etherToPay > 0) {\r\n            _tokenOwner.transfer(etherToPay);\r\n        }\r\n    }\r\n\r\n    function deleteAuction(uint256 _tokenId, AuctionEntry storage _entry) private {\r\n        uint256 keysLength = auctions.keys.length;\r\n        if (_entry.keyIndex <= keysLength) {\r\n            // Move an existing element into the vacated key slot.\r\n            auctions.data[auctions.keys[keysLength - 1]].keyIndex = _entry.keyIndex;\r\n            auctions.keys[_entry.keyIndex - 1] = auctions.keys[keysLength - 1];\r\n            auctions.keys.length = keysLength - 1;\r\n            delete auctions.data[_tokenId];\r\n        }\r\n    }\r\n\r\n    function calculateCurrentPrice(Auction storage _auction) private view returns (uint256) {\r\n        uint256 secondsInProgress = block.timestamp - _auction.startTime;\r\n\r\n        if (secondsInProgress >= _auction.duration) {\r\n            return _auction.endPrice;\r\n        }\r\n\r\n        int256 totalPriceChange = int256(_auction.endPrice) - int256(_auction.startPrice);\r\n        int256 currentPriceChange =\r\n            totalPriceChange * int256(secondsInProgress) / int256(_auction.duration);\r\n\r\n        int256 calculatedPrice = int256(_auction.startPrice) + int256(currentPriceChange);\r\n\r\n        return uint256(calculatedPrice);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startPrice\",\"type\":\"uint128\"},{\"name\":\"_endPrice\",\"type\":\"uint128\"},{\"name\":\"_duration\",\"type\":\"uint128\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isOnAuction\",\"outputs\":[{\"name\":\"onAuction\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuctionByTokenId\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"startPrice\",\"type\":\"uint128\"},{\"name\":\"endPrice\",\"type\":\"uint128\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint128\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getAuctionByIndex\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"startPrice\",\"type\":\"uint128\"},{\"name\":\"endPrice\",\"type\":\"uint128\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint128\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionsCount\",\"outputs\":[{\"name\":\"auctionsCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_erc721Contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pricePaid\",\"type\":\"uint256\"}],\"name\":\"AuctionBoughtEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"endPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint128\"}],\"name\":\"AuctionCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCanceledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AnimalMarketplace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003a1957a0b9755d78c77e301410b254b6147a400c","Library":"","SwarmSource":"bzzr://27c0bfd333c7e768ae4ffec8257dc39991d8ffd9fabd7a63b9fbcdfa96a0f86b"}]}