{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary AZTECInterface {\r\n    function validateJoinSplit(bytes32[6][], uint, uint, bytes32[4]) external pure returns (bool) {}\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n **/\r\ncontract ERC20Interface {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n}\r\n\r\n/**\r\n * @title  AZTEC token, providing a confidential representation of an ERC20 token \r\n * @author Zachary Williamson, AZTEC\r\n * Copyright Spilsbury Holdings Ltd 2018. All rights reserved.\r\n * We will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\r\n * This will include our bespoke AZTEC decentralized exchange, allowing for cross-asset transfers with full transaction privacy\r\n * and interopability with public decentralized exchanges.\r\n * Stay tuned for updates!\r\n **/\r\ncontract AZTECERC20Bridge {\r\n    uint private constant groupModulusBoundary = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\r\n    uint private constant groupModulus = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint public scalingFactor;\r\n    mapping(bytes32 => address) public noteRegistry;\r\n    bytes32[4] setupPubKey;\r\n    bytes32 domainHash;\r\n    ERC20Interface token;\r\n\r\n    event Created(bytes32 domainHash, address contractAddress);\r\n    event ConfidentialTransfer();\r\n\r\n    /**\r\n    * @dev contract constructor.\r\n    * @param _setupPubKey the trusted setup public key (group element of group G2)\r\n    * @param _token the address of the ERC20 token being attached to\r\n    * @param _scalingFactor the mapping from note value -> ERC20 token value.\r\n    * AZTEC notes have a range between 0 and 2^{25}-1 and ERC20 tokens range between 0 and 2^{255} - 1\r\n    * so we don't want to directly map note value : token value\r\n    **/\r\n    constructor(bytes32[4] _setupPubKey, address _token, uint256 _scalingFactor) public {\r\n        setupPubKey = _setupPubKey;\r\n        token = ERC20Interface(_token);\r\n        scalingFactor = _scalingFactor;\r\n\r\n        // calculate the EIP712 domain hash, for hashing structured data\r\n        bytes32 _domainHash;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(m, 0x8d4b25bfecb769291b71726cd5ec8a497664cc7292c02b1868a0534306741fd9)\r\n            mstore(add(m, 0x20), 0x87a23625953c9fb02b3570c86f75403039bbe5de82b48ca671c10157d91a991a) // name = \"AZTEC_MAINNET_DOMAIN\"\r\n            mstore(add(m, 0x40), 0x25130290f410620ec94e7cf11f1cdab5dea284e1039a83fa7b87f727031ff5f4) // version = \"0.1.0\"\r\n            mstore(add(m, 0x60), 1) // chain id\r\n            mstore(add(m, 0x80), 0x210db872dec2e06c375dd40a5a354307bb4ba52ba65bd84594554580ae6f0639)\r\n            mstore(add(m, 0xa0), address) // verifying contract\r\n            _domainHash := keccak256(m, 0xc0)\r\n        }\r\n        domainHash = _domainHash;\r\n        emit Created(_domainHash, this);\r\n    }\r\n\r\n    /**\r\n    * @dev Determine validity of an input note and remove from note registry\r\n    * 1. validate that the note is signed by the note owner\r\n    * 2. validate that the note exists in the note registry\r\n    *\r\n    * Note signature is EIP712 signature (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md) over the following struct\r\n    * struct AZTEC_NOTE_SIGNATURE {\r\n    *     bytes32[4] note;\r\n    *     uint256 challenge;\r\n    *     address sender;    \r\n    * };\r\n    * @param note AZTEC confidential note being destroyed\r\n    * @param signature ECDSA signature from note owner\r\n    * @param challenge AZTEC zero-knowledge proof challenge\r\n    * @param domainHashT Temporary holding ```domainHash``` (to minimize # of sload ops)\r\n    **/\r\n    function validateInputNote(bytes32[6] note, bytes32[3] signature, uint challenge, bytes32 domainHashT) internal {\r\n        bytes32 noteHash;\r\n        bytes32 signatureMessage;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(m, mload(add(note, 0x40)))\r\n            mstore(add(m, 0x20), mload(add(note, 0x60)))\r\n            mstore(add(m, 0x40), mload(add(note, 0x80)))\r\n            mstore(add(m, 0x60), mload(add(note, 0xa0)))\r\n            noteHash := keccak256(m, 0x80)\r\n            mstore(m, 0x1aba5d08f7cd777136d3fa7eb7baa742ab84001b34c9de5b17d922fc2ca75cce) // keccak256 hash of \"AZTEC_NOTE_SIGNATURE(bytes32[4] note,uint256 challenge,address sender)\"\r\n            mstore(add(m, 0x20), noteHash)\r\n            mstore(add(m, 0x40), challenge)\r\n            mstore(add(m, 0x60), caller)\r\n            mstore(add(m, 0x40), keccak256(m, 0x80))\r\n            mstore(add(m, 0x20), domainHashT)\r\n            mstore(m, 0x1901)\r\n            signatureMessage := keccak256(add(m, 0x1e), 0x42)\r\n        }\r\n        address owner = ecrecover(signatureMessage, uint8(signature[0]), signature[1], signature[2]);\r\n        require(owner != address(0), \"signature invalid\");\r\n        require(noteRegistry[noteHash] == owner, \"expected input note to exist in registry\");\r\n        noteRegistry[noteHash] = 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Validate an output note from an AZTEC confidential transaction\r\n    * If the note does not already exist in ```noteRegistry```, create it\r\n    * @param note AZTEC confidential note to be created\r\n    * @param owner The address of the note owner\r\n    **/\r\n    function validateOutputNote(bytes32[6] note, address owner) internal {\r\n        bytes32 noteHash; // Construct a keccak256 hash of the note coordinates.\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(m, mload(add(note, 0x40)))\r\n            mstore(add(m, 0x20), mload(add(note, 0x60)))\r\n            mstore(add(m, 0x40), mload(add(note, 0x80)))\r\n            mstore(add(m, 0x60), mload(add(note, 0xa0)))\r\n            noteHash := keccak256(m, 0x80)\r\n        }\r\n        require(owner != address(0), \"owner must be valid Ethereum address\");\r\n        require(noteRegistry[noteHash] == 0, \"expected output note to not exist in registry\");\r\n        noteRegistry[noteHash] = owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Perform a confidential transaction. Takes ```m``` input notes and ```notes.length - m``` output notes.\r\n    * ```notes, m, challenge``` constitute an AZTEC zero-knowledge proof that states the following:\r\n    * The sum of the values of the input notes is equal to a the sum of the values of the output notes + a public commitment value ```kPublic```\r\n    * \\sum_{i=0}^{m-1}k_i = \\sum_{i=m}^{n-1}k_i + k_{public} (mod p)\r\n    * notes[6][] contains value ```kPublic```  at notes[notes.length - 1][0].\r\n    * If ```kPublic``` is negative, this represents ```(GROUP_MODULUS - kPublic) * SCALING_FACTOR``` ERC20 tokens being converted into confidential note form.\r\n    * If ```kPublic``` is positive, this represents ```kPublic * SCALING_FACTOR``` worth of AZTEC notes being converted into ERC20 form\r\n    * @param notes defines AZTEC input notes and output notes. notes[0,...,m-1] = input notes. notes[m,...,notes.length-1] = output notes\r\n    * @param m where notes[0,..., m - 1] = input notes. notes[m,...,notes.length - 1] = output notes\r\n    * @param challenge AZTEC zero-knowledge proof challenge variable\r\n    * @param inputSignatures array of ECDSA signatures, one for each input note\r\n    * @param outputOwners addresses of owners, one for each output note\r\n    * Unnamed param is metadata: if AZTEC notes are assigned to stealth addresses, metadata should contain the ephemeral keys required for note owner to identify their note\r\n    */\r\n    function confidentialTransfer(bytes32[6][] notes, uint256 m, uint256 challenge, bytes32[3][] inputSignatures, address[] outputOwners, bytes) external {\r\n        require(inputSignatures.length == m, \"input signature length invalid\");\r\n        require(inputSignatures.length + outputOwners.length == notes.length, \"array length mismatch\");\r\n\r\n        // validate AZTEC zero-knowledge proof\r\n        require(AZTECInterface.validateJoinSplit(notes, m, challenge, setupPubKey), \"proof not valid!\");\r\n\r\n        // extract variable kPublic from proof\r\n        uint256 kPublic = uint(notes[notes.length - 1][0]);\r\n        require(kPublic < groupModulus, \"invalid value of kPublic\");\r\n\r\n        // iterate over the notes array and validate each input/output note\r\n        for (uint256 i = 0; i < notes.length; i++) {\r\n\r\n            // if i < m this is an input note\r\n            if (i < m) {\r\n\r\n                // call validateInputNote to check that the note exists and that we have a matching signature over the note.\r\n                // pass domainHash in as a function parameter to prevent multiple sloads\r\n                // this will remove the input notes from noteRegistry\r\n                validateInputNote(notes[i], inputSignatures[i], challenge, domainHash);\r\n            } else {\r\n                \r\n                // if i >= m this is an output note\r\n                // validate that output notes, attached to the specified owners do not exist in noteRegistry.\r\n                // if all checks pass, add notes into note registry\r\n                validateOutputNote(notes[i], outputOwners[i - m]);\r\n            }\r\n        }\r\n\r\n        if (kPublic > 0) {\r\n            if (kPublic < groupModulusBoundary) {\r\n\r\n                // if value < the group modulus boundary then this public value represents a conversion from confidential note form to public form\r\n                // call token.transfer to send relevent tokens\r\n                require(token.transfer(msg.sender, kPublic * scalingFactor), \"token transfer to user failed!\");\r\n            } else {\r\n\r\n                // if value > group modulus boundary, this represents a commitment of a public value into confidential note form.\r\n                // only proceed if the required transferFrom call from msg.sender to this contract succeeds\r\n                require(token.transferFrom(msg.sender, this, (groupModulus - kPublic) * scalingFactor), \"token transfer from user failed!\");\r\n            }\r\n        }\r\n\r\n        // emit an event to mark this transaction. Can recover notes + metadata from input data\r\n        emit ConfidentialTransfer();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"noteRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"notes\",\"type\":\"bytes32[6][]\"},{\"name\":\"m\",\"type\":\"uint256\"},{\"name\":\"challenge\",\"type\":\"uint256\"},{\"name\":\"inputSignatures\",\"type\":\"bytes32[3][]\"},{\"name\":\"outputOwners\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"confidentialTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scalingFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_setupPubKey\",\"type\":\"bytes32[4]\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_scalingFactor\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"domainHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ConfidentialTransfer\",\"type\":\"event\"}]","ContractName":"AZTECERC20Bridge","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"01cf7cc93bfbf7b2c5f04a3bc9cb8b72bbcf2defcabdceb09860c493bdf1588d08d554bf59102bbb961ba81107ec71785ef9ce6638e5332b6c1a58b87447d181204e5d81d86c561f9344ad5f122a625f259996b065b80cbbe74a9ad97b6d7cc202cb2a424885c9e412b94c40905b359e3043275cd29f5b557f008cd0a3e0c0dc00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359000000000000000000000000000000000000000000000000016345785d8a0000","Library":"AZTECInterface:A43F8675850ac3f60A4D4cec954F1A1B0e1dbB07","SwarmSource":"bzzr://8d4a1cba83ad5ccdae4d72ecf542a685997707f51cad4ba6691b13e356bc07c8"}]}