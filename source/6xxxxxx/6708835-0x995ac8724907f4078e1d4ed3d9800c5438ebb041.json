{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Formula1Game {\r\n\r\n    address public support;\r\n\r\n\tuint constant public PRIZE_PERCENT = 5;\r\n    uint constant public SUPPORT_PERCENT = 2;\r\n    \r\n    uint constant public MAX_INVESTMENT =  5 ether;\r\n    uint constant public MIN_INVESTMENT = 0.1 ether;\r\n    uint constant public MIN_INVESTMENT_FOR_PRIZE = 0.1 ether;\r\n    uint constant public GAS_PRICE_MAX = 50; \r\n    uint constant public MAX_IDLE_TIME = 10 minutes; \r\n\r\n    uint constant public SIZE_TO_SAVE_INVEST = 15; \r\n    uint constant public TIME_TO_SAVE_INVEST = 5 minutes; \r\n    \r\n    uint8[] MULTIPLIERS = [\r\n        107, \r\n        112, \r\n        117 \r\n    ];\r\n\r\n    struct Deposit {\r\n        address depositor; \r\n        uint128 deposit;  \r\n        uint128 expect;    \r\n    }\r\n\r\n    struct DepositCount {\r\n        int128 stage;\r\n        uint128 count;\r\n    }\r\n\r\n    struct LastDepositInfo {\r\n        uint128 index;\r\n        uint128 time;\r\n    }\r\n\r\n    Deposit[] private queue;  \r\n\r\n    uint public currentReceiverIndex = 0; \r\n    uint public currentQueueSize = 0; \r\n    LastDepositInfo public lastDepositInfoForPrize; \r\n    LastDepositInfo public previosDepositInfoForPrize; \r\n\r\n    uint public prizeAmount = 0; \r\n    uint public prizeStageAmount = 0; \r\n    int public stage = 0; \r\n    uint128 public lastDepositTime = 0; \r\n    \r\n    mapping(address => DepositCount) public depositsMade; \r\n\r\n    constructor() public {\r\n        support = msg.sender; \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n    \r\n    function () public payable {\r\n        require(tx.gasprice <= GAS_PRICE_MAX * 1000000000);\r\n        require(gasleft() >= 250000, \"We require more gas!\"); \r\n        \r\n        checkAndUpdateStage();\r\n        \r\n        if(msg.value > 0){\r\n            require(msg.value >= MIN_INVESTMENT && msg.value <= MAX_INVESTMENT); \r\n            require(lastDepositInfoForPrize.time <= now + MAX_IDLE_TIME); \r\n            \r\n            require(getNextStageStartTime() >= now + MAX_IDLE_TIME + 10 minutes);\r\n            \r\n            if(currentQueueSize < SIZE_TO_SAVE_INVEST){ \r\n                \r\n                addDeposit(msg.sender, msg.value);\r\n                \r\n            } else {\r\n                \r\n                addDeposit(msg.sender, msg.value);\r\n                pay(); \r\n                \r\n            }\r\n            \r\n        } else if(msg.value == 0 && currentQueueSize > SIZE_TO_SAVE_INVEST){\r\n            \r\n            withdrawPrize(); \r\n            \r\n        } else if(msg.value == 0){\r\n            \r\n            require(currentQueueSize <= SIZE_TO_SAVE_INVEST); \r\n            require(lastDepositTime > 0 && (now - lastDepositTime) >= TIME_TO_SAVE_INVEST); \r\n            \r\n            returnPays(); \r\n            \r\n        } \r\n    }\r\n\r\n    function pay() private {\r\n        \r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        \r\n        if(balance > prizeStageAmount) \r\n            money = uint128(balance - prizeStageAmount);\r\n        \r\n        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);\r\n        support.send(moneyS);\r\n        money -= moneyS;\r\n        \r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; \r\n\r\n            if(money >= dep.expect){  \r\n                    \r\n                dep.depositor.send(dep.expect); \r\n                money -= dep.expect;          \r\n                \r\n                delete queue[i];\r\n                \r\n            }else{\r\n                \r\n                dep.depositor.send(money);      \r\n                money -= dep.expect;            \r\n                break;                     \r\n            }\r\n\r\n            if(gasleft() <= 50000)         \r\n                break;                     \r\n        }\r\n\r\n        currentReceiverIndex = i; \r\n    }\r\n    \r\n    function returnPays() private {\r\n        \r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        \r\n        if(balance > prizeAmount) \r\n            money = uint128(balance - prizeAmount);\r\n        \r\n        \r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; \r\n\r\n                dep.depositor.send(dep.deposit); \r\n                money -= dep.deposit;            \r\n                \r\n                \r\n                delete queue[i];\r\n\r\n        }\r\n\r\n        prizeStageAmount = 0; \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n\r\n    function addDeposit(address depositor, uint value) private {\r\n        \r\n        DepositCount storage c = depositsMade[depositor];\r\n        if(c.stage != stage){\r\n            c.stage = int128(stage);\r\n            c.count = 0;\r\n        }\r\n\r\n        \r\n        if(value >= MIN_INVESTMENT_FOR_PRIZE){\r\n            previosDepositInfoForPrize = lastDepositInfoForPrize;\r\n            lastDepositInfoForPrize = LastDepositInfo(uint128(currentQueueSize), uint128(now));\r\n        }\r\n\r\n        \r\n        uint multiplier = getDepositorMultiplier(depositor);\r\n        \r\n        push(depositor, value, value*multiplier/100);\r\n\r\n        \r\n        c.count++;\r\n\r\n        lastDepositTime = uint128(now);\r\n        \r\n        \r\n        prizeStageAmount += value*PRIZE_PERCENT/100;\r\n    }\r\n\r\n    function checkAndUpdateStage() private {\r\n        int _stage = getCurrentStageByTime();\r\n\r\n        require(_stage >= stage); \r\n\r\n        if(_stage != stage){\r\n            proceedToNewStage(_stage);\r\n        }\r\n    }\r\n\r\n    function proceedToNewStage(int _stage) private {\r\n        \r\n        stage = _stage;\r\n        currentQueueSize = 0; \r\n        currentReceiverIndex = 0;\r\n        lastDepositTime = 0;\r\n        prizeAmount += prizeStageAmount; \r\n        prizeStageAmount = 0;\r\n        delete queue;\r\n        delete previosDepositInfoForPrize;\r\n        delete lastDepositInfoForPrize;\r\n    }\r\n\r\n    function withdrawPrize() private {\r\n        \r\n        require(lastDepositInfoForPrize.time > 0 && lastDepositInfoForPrize.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\r\n        \r\n        require(currentReceiverIndex <= lastDepositInfoForPrize.index, \"The last depositor should still be in queue\");\r\n\r\n        uint balance = address(this).balance;\r\n        \r\n        uint prize = balance;\r\n        if(previosDepositInfoForPrize.index > 0){\r\n            uint prizePrevios = prize*10/100;\r\n            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);\r\n            prize -= prizePrevios;\r\n        }\r\n\r\n        queue[lastDepositInfoForPrize.index].depositor.send(prize);\r\n        \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n\r\n    function push(address depositor, uint deposit, uint expect) private {\r\n        \r\n        Deposit memory dep = Deposit(depositor, uint128(deposit), uint128(expect));\r\n        assert(currentQueueSize <= queue.length); \r\n        if(queue.length == currentQueueSize)\r\n            queue.push(dep);\r\n        else\r\n            queue[currentQueueSize] = dep;\r\n\r\n        currentQueueSize++;\r\n    }\r\n\r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\r\n        Deposit storage dep = queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expect);\r\n    }\r\n\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; ++i){\r\n            if(queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function getQueueLength() public view returns (uint) {\r\n        return currentQueueSize - currentReceiverIndex;\r\n    }\r\n\r\n    function getDepositorMultiplier(address depositor) public view returns (uint) {\r\n        DepositCount storage c = depositsMade[depositor];\r\n        uint count = 0;\r\n        if(c.stage == getCurrentStageByTime())\r\n            count = c.count;\r\n        if(count < MULTIPLIERS.length)\r\n            return MULTIPLIERS[count];\r\n\r\n        return MULTIPLIERS[MULTIPLIERS.length - 1];\r\n    }\r\n\r\n    function getCurrentStageByTime() public view returns (int) {\r\n        return int(now - 17847 * 86400 - 17 * 3600) / (24 * 60 * 60);\r\n    }\r\n\r\n    function getNextStageStartTime() public view returns (uint) {\r\n        return 17847 * 86400 + 17 * 3600 + uint((getCurrentStageByTime() + 1) * 24 * 60 * 60); \r\n    }\r\n\r\n    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\r\n        if(currentReceiverIndex <= lastDepositInfoForPrize.index && lastDepositInfoForPrize.index < currentQueueSize){\r\n            Deposit storage d = queue[lastDepositInfoForPrize.index];\r\n            addr = d.depositor;\r\n            timeLeft = int(lastDepositInfoForPrize.time + MAX_IDLE_TIME) - int(now);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getNextStageStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentQueueSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositInfoForPrize\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"support\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPORT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStageByTime\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositorMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_PRICE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRIZE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT_FOR_PRIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeStageAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositsMade\",\"outputs\":[{\"name\":\"stage\",\"type\":\"int128\"},{\"name\":\"count\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIZE_TO_SAVE_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IDLE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_TO_SAVE_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentCandidateForPrize\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"timeLeft\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previosDepositInfoForPrize\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Formula1Game","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://77a236bd0e7e770d40530c13c82198c84eb9bb8767fa4ae10a4e69ff51f5c165"}]}