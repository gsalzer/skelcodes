{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\n// input  /home/henry/learning/git/smartContract/truffle/022-sht/contracts-bak/SibbayHealthToken.sol\r\n// flattened :  Saturday, 17-Nov-18 06:24:45 UTC\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Management is Ownable {\r\n\r\n  /**\r\n   * 暂停和取消暂停事件\r\n   * */\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  /**\r\n   * 打开锁定期自动释放事件\r\n   * 关闭锁定期自动释放事件\r\n   * 打开强制锁定期自动释放事件\r\n   * */\r\n  event OpenAutoFree(address indexed admin, address indexed who);\r\n  event CloseAutoFree(address indexed admin, address indexed who);\r\n  event OpenForceAutoFree(address indexed admin, address indexed who);\r\n\r\n  /**\r\n   * 增加和删除管理员事件\r\n   * */\r\n  event AddAdministrator(address indexed admin);\r\n  event DelAdministrator(address indexed admin);\r\n\r\n  /**\r\n   * 合约暂停标志, True 暂停，false 未暂停\r\n   * 锁定余额自动释放开关\r\n   * 强制锁定余额自动释放开关\r\n   * 合约管理员\r\n   * */\r\n  bool public paused = false;\r\n  mapping(address => bool) public autoFreeLockBalance;          // false(default) for auto frce, true for not free\r\n  mapping(address => bool) public forceAutoFreeLockBalance;     // false(default) for not force free, true for froce free\r\n  mapping(address => bool) public adminList;\r\n\r\n  /**\r\n   * 构造函数\r\n   * */\r\n  constructor() public {\r\n  }\r\n\r\n  /**\r\n   * modifier 要求合约正在运行状态\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * modifier 要求合约暂停状态\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * 要求是管理员\r\n   * */\r\n  modifier whenAdministrator(address who) {\r\n    require(adminList[who]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * 要求不是管理员\r\n   * */\r\n  modifier whenNotAdministrator(address who) {\r\n    require(!adminList[who]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * * 暂停合约\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * 取消暂停合约\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n\r\n  /**\r\n   * 打开锁定期自动释放开关\r\n   * */\r\n  function openAutoFree(address who) whenAdministrator(msg.sender) public {\r\n    delete autoFreeLockBalance[who];\r\n    emit OpenAutoFree(msg.sender, who);\r\n  }\r\n\r\n  /**\r\n   * 关闭锁定期自动释放开关\r\n   * */\r\n  function closeAutoFree(address who) whenAdministrator(msg.sender) public {\r\n    autoFreeLockBalance[who] = true;\r\n    emit CloseAutoFree(msg.sender, who);\r\n  }\r\n\r\n  /**\r\n   * 打开强制锁定期自动释放开关\r\n   * 该开关只能打开，不能关闭\r\n   * */\r\n  function openForceAutoFree(address who) onlyOwner public {\r\n    forceAutoFreeLockBalance[who] = true;\r\n    emit OpenForceAutoFree(msg.sender, who);\r\n  }\r\n\r\n  /**\r\n   * 添加管理员\r\n   * */\r\n  function addAdministrator(address who) onlyOwner public {\r\n    adminList[who] = true;\r\n    emit AddAdministrator(who);\r\n  }\r\n\r\n  /**\r\n   * 删除管理员\r\n   * */\r\n  function delAdministrator(address who) onlyOwner public {\r\n    delete adminList[who];\r\n    emit DelAdministrator(who);\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * 账户总余额\r\n   * */\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n   * 总供应量\r\n   * */\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n   * 获取总供应量\r\n   * */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  // 记录代理账户\r\n  // 第一个address是token的所有者，即被代理账户\r\n  // 第二个address是token的使用者，即代理账户\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  // 代理转账事件\r\n  // spender: 代理\r\n  // from: token所有者\r\n  // to: token接收账户\r\n  // value: token的转账数量\r\n  event TransferFrom(address indexed spender,\r\n                     address indexed from,\r\n                     address indexed to,\r\n                     uint256 value);\r\n\r\n\r\n  /**\r\n   * 设置代理\r\n   * _spender 代理账户\r\n   * _value 代理额度\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 查询代理额度\r\n   * _owner token拥有者账户\r\n   * _spender 代理账户\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * 提高代理额度\r\n   * _spender 代理账户\r\n   * _addValue 需要提高的代理额度\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 降低代理额度\r\n   * _spender 代理账户\r\n   * _subtractedValue 降低的代理额度\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract SibbayHealthToken is StandardToken, Management {\r\n\r\n  string public constant name = \"Sibbay Health Token\"; // solium-disable-line uppercase\r\n  string public constant symbol = \"SHT\"; // solium-disable-line uppercase\r\n  uint8 public constant decimals = 18; // solium-disable-line uppercase\r\n\r\n  /**\r\n   * 常量\r\n   * 单位量, 即1个token有多少wei(假定token的最小单位为wei)\r\n   * */\r\n  uint256 constant internal MAGNITUDE = 10 ** uint256(decimals);\r\n\r\n  uint256 public constant INITIAL_SUPPLY = 1000000000 * MAGNITUDE;\r\n\r\n  // 设置赎回价格事件\r\n  event SetSellPrice(address indexed admin, uint256 price);\r\n  // 锁定期转账事件\r\n  event TransferByDate(address indexed from, address indexed to, uint256[] values, uint256[] dates);\r\n  event TransferFromByDate(address indexed spender, address indexed from, address indexed to, uint256[] values, uint256[] dates);\r\n  // 关闭赎回事件\r\n  event CloseSell(address indexed who);\r\n  // 赎回事件\r\n  event Sell(address indexed from, address indexed to, uint256 tokenValue, uint256 etherValue);\r\n  // withdraw 事件\r\n  event Withdraw(address indexed who, uint256 etherValue);\r\n  // 添加token到fundAccount账户\r\n  event AddTokenToFund(address indexed who, address indexed from, uint256 value);\r\n  // refresh 事件\r\n  event Refresh(address indexed from, address indexed who);\r\n\r\n  /**\r\n   * 将锁定期的map做成一个list\r\n   * value 锁定的余额\r\n   * _next 下个锁定期的到期时间\r\n   * */\r\n  struct Element {\r\n    uint256 value;\r\n    uint256 next;\r\n  }\r\n\r\n  /**\r\n   * 账户\r\n   * lockedBalances 锁定余额\r\n   * lockedElement 锁定期余额\r\n   * start_date 锁定期最早到期时间\r\n   * end_date 锁定期最晚到期时间\r\n   * */\r\n  struct Account {\r\n    uint256 lockedBalances;\r\n    mapping(uint256 => Element) lockedElement;\r\n    uint256 start_date;\r\n    uint256 end_date;\r\n  }\r\n\r\n  /**\r\n   * 所有账户\r\n   * */\r\n  mapping(address => Account) public accounts;\r\n\r\n  /**\r\n   * sellPrice: token 赎回价格, 即1 token的赎回价格是多少wei(wei为以太币最小单位)\r\n   * fundAccount: 特殊资金账户，赎回token，接收购买token资金\r\n   * sellFlag: 赎回标记\r\n   * */\r\n  uint256 public sellPrice;\r\n  address public fundAccount;\r\n  bool public sellFlag;\r\n\r\n  /**\r\n   * 需求：owner 每年释放的金额不得超过年初余额的10%\r\n   * curYear:  当前年初时间\r\n   * YEAR:  一年365天的时间\r\n   * vault: owner限制额度\r\n   * VAULT_FLOOR_VALUE: vault 最低限值\r\n   * */\r\n  uint256 public curYear;\r\n  uint256 constant internal YEAR = 365 * 24 * 3600;\r\n  uint256 public vault;\r\n  uint256 constant internal VAULT_FLOOR_VALUE = 10000000 * MAGNITUDE;\r\n\r\n  /**\r\n   * 合约构造函数\r\n   * 初始化合约的总供应量\r\n   */\r\n  constructor(address _owner, address _fund) public {\r\n    // 要求_owner, _fund不为0\r\n    require(_owner != address(0));\r\n    require(_fund != address(0));\r\n\r\n    // 设置owner, fund\r\n    owner = _owner;\r\n    fundAccount = _fund;\r\n\r\n    // 初始化owner是管理员\r\n    adminList[owner] = true;\r\n\r\n    // 初始化发行量\r\n    totalSupply_ = INITIAL_SUPPLY;\r\n    balances[owner] = INITIAL_SUPPLY;\r\n    emit Transfer(0x0, owner, INITIAL_SUPPLY);\r\n\r\n    /**\r\n     * 初始化合约属性\r\n     * 赎回价格\r\n     * 赎回标记为false\r\n     * */\r\n    sellPrice = 0;\r\n    sellFlag = true;\r\n\r\n    /**\r\n     * 初始化owner限制额度\r\n     * 2018/01/01 00:00:00\r\n     * */\r\n    vault = totalSupply_.mul(10).div(100);\r\n    curYear = 1514736000;\r\n  }\r\n\r\n  /**\r\n   * fallback函数\r\n   * */\r\n  function () external payable {\r\n  }\r\n\r\n  /**\r\n   * modifier 要求开启赎回token\r\n   * */\r\n  modifier whenOpenSell()\r\n  {\r\n    require(sellFlag);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * modifier 要求关闭赎回token\r\n   * */\r\n  modifier whenCloseSell()\r\n  {\r\n    require(!sellFlag);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * 刷新owner限制余额vault\r\n   * */\r\n  function refreshVault(address _who, uint256 _value) internal\r\n  {\r\n    uint256 balance;\r\n\r\n    // 只对owner操作\r\n    if (_who != owner)\r\n      return ;\r\n    // 记录balance of owner\r\n    balance = balances[owner];\r\n    // 如果是新的一年, 则计算vault为当前余额的10%\r\n    if (now >= (curYear + YEAR))\r\n    {\r\n      if (balance <= VAULT_FLOOR_VALUE)\r\n        vault = balance;\r\n      else\r\n        vault = balance.mul(10).div(100);\r\n      curYear = curYear.add(YEAR);\r\n    }\r\n\r\n    // vault 必须大于等于 _value\r\n    require(vault >= _value);\r\n    vault = vault.sub(_value);\r\n    return ;\r\n  }\r\n\r\n  /**\r\n   * 重新计算到期的锁定期余额, 内部接口\r\n   * _who: 账户地址\r\n   * */\r\n  function refreshlockedBalances(address _who, bool _update) internal returns (uint256)\r\n  {\r\n    uint256 tmp_date = accounts[_who].start_date;\r\n    uint256 tmp_value = accounts[_who].lockedElement[tmp_date].value;\r\n    uint256 tmp_balances = 0;\r\n    uint256 tmp_var;\r\n\r\n    // 强制自动释放打开则跳过判断，直接释放锁定期余额\r\n    if (!forceAutoFreeLockBalance[_who])\r\n    {\r\n      // 强制自动释放未打开，则判断自动释放开关\r\n      if(autoFreeLockBalance[_who])\r\n      {\r\n        // 自动释放开关未打开(true), 直接返回0\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // 锁定期到期\r\n    while(tmp_date != 0 &&\r\n          tmp_date <= now)\r\n    {\r\n      // 记录到期余额\r\n      tmp_balances = tmp_balances.add(tmp_value);\r\n\r\n      // 记录 tmp_date\r\n      tmp_var = tmp_date;\r\n\r\n      // 跳到下一个锁定期\r\n      tmp_date = accounts[_who].lockedElement[tmp_date].next;\r\n      tmp_value = accounts[_who].lockedElement[tmp_date].value;\r\n\r\n      // delete 锁定期余额\r\n      if (_update)\r\n        delete accounts[_who].lockedElement[tmp_var];\r\n    }\r\n\r\n    // return expired balance\r\n    if(!_update)\r\n      return tmp_balances;\r\n\r\n    // 修改锁定期数据\r\n    accounts[_who].start_date = tmp_date;\r\n    accounts[_who].lockedBalances = accounts[_who].lockedBalances.sub(tmp_balances);\r\n    balances[_who] = balances[_who].add(tmp_balances);\r\n\r\n    // 将最早和最晚时间的标志，都置0，即最初状态\r\n    if (accounts[_who].start_date == 0)\r\n        accounts[_who].end_date = 0;\r\n\r\n    return tmp_balances;\r\n  }\r\n\r\n  /**\r\n   * 可用余额转账，内部接口\r\n   * _from token的拥有者\r\n   * _to token的接收者\r\n   * _value token的数量\r\n   * */\r\n  function transferAvailableBalances(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    // 检查可用余额\r\n    require(_value <= balances[_from]);\r\n\r\n    // 修改可用余额\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n\r\n    // 触发转账事件\r\n    if(_from == msg.sender)\r\n      emit Transfer(_from, _to, _value);\r\n    else\r\n      emit TransferFrom(msg.sender, _from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * 锁定余额转账，内部接口\r\n   * _from token的拥有者\r\n   * _to token的接收者\r\n   * _value token的数量\r\n   * */\r\n  function transferLockedBalances(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    // 检查可用余额\r\n    require(_value <= balances[_from]);\r\n\r\n    // 修改可用余额和锁定余额\r\n    balances[_from] = balances[_from].sub(_value);\r\n    accounts[_to].lockedBalances = accounts[_to].lockedBalances.add(_value);\r\n  }\r\n\r\n  /**\r\n   * 回传以太币, 内部接口\r\n   * _from token来源账户\r\n   * _to token目标账户\r\n   * _value 为token数目\r\n   * */\r\n  function transferEther(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    /**\r\n     * 要求 _to 账户接收地址为特殊账户地址\r\n     * 这里只能为return，不能为revert\r\n     * 普通转账在这里返回, 不赎回ether\r\n     * */\r\n    if (_to != fundAccount)\r\n        return ;\r\n\r\n    /**\r\n     * 没有打开赎回功能，不能向fundAccount转账\r\n     * */\r\n    require(sellFlag);\r\n\r\n    /**\r\n     * 赎回价格必须大于0\r\n     * 赎回的token必须大于0\r\n     * */\r\n    require(_value > 0);\r\n\r\n    // 赎回的以太币必须小于账户余额, evalue 单位是wei，即以太币的最小单位\r\n    uint256 evalue = _value.mul(sellPrice).div(MAGNITUDE);\r\n    require(evalue <= address(this).balance);\r\n\r\n    // 回传以太币\r\n    if (evalue > 0)\r\n    {\r\n      _from.transfer(evalue);\r\n      emit Sell(_from, _to, _value, evalue);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 取回合约上所有的以太币\r\n   * 只有owner才能取回\r\n   * */\r\n  function withdraw() public onlyOwner {\r\n    uint256 value = address(this).balance;\r\n    owner.transfer(value);\r\n    emit Withdraw(msg.sender, value);\r\n  }\r\n\r\n  /**\r\n   * 从from账户向fundAccount添加token\r\n   * */\r\n  function addTokenToFund(address _from, uint256 _value) \r\n    whenNotPaused\r\n    public\r\n  {\r\n    if (_from != msg.sender)\r\n    {\r\n      // 检查代理额度\r\n      require(_value <= allowed[_from][msg.sender]);\r\n\r\n      // 修改代理额度\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    }\r\n\r\n    // 刷新vault余额\r\n    refreshVault(_from, _value);\r\n\r\n    // 修改可用账户余额\r\n    transferAvailableBalances(_from, fundAccount, _value);\r\n    emit AddTokenToFund(msg.sender, _from, _value);\r\n  }\r\n\r\n  /**\r\n   * 转账\r\n   * */\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    // 不能给地址0转账\r\n    require(_to != address(0));\r\n\r\n    /**\r\n     * 获取到期的锁定期余额\r\n     * */\r\n    refreshlockedBalances(msg.sender, true);\r\n    refreshlockedBalances(_to, true);\r\n\r\n    // 刷新vault余额\r\n    refreshVault(msg.sender, _value);\r\n\r\n    // 修改可用账户余额\r\n    transferAvailableBalances(msg.sender, _to, _value);\r\n\r\n    // 回传以太币\r\n    transferEther(msg.sender, _to, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 代理转账\r\n   * 代理从 _from 转账 _value 到 _to\r\n   * */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    // 不能向赎回地址发送token\r\n    require(_to != fundAccount);\r\n\r\n    // 不能向0地址转账\r\n    require(_to != address(0));\r\n\r\n    /**\r\n     * 获取到期的锁定期余额\r\n     * */\r\n    refreshlockedBalances(_from, true);\r\n    refreshlockedBalances(_to, true);\r\n\r\n    // 检查代理额度\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    // 修改代理额度\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n    // 刷新vault余额\r\n    refreshVault(_from, _value);\r\n\r\n    // 修改可用账户余额\r\n    transferAvailableBalances(_from, _to, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 设定代理和代理额度\r\n   * 设定代理为 _spender 额度为 _value\r\n   * */\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  /**\r\n   * 提高代理的代理额度\r\n   * 提高代理 _spender 的代理额度 _addedValue\r\n   * */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  /**\r\n   * 降低代理的代理额度\r\n   * 降低代理 _spender 的代理额度 _subtractedValue\r\n   * */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n\r\n  /**\r\n   * 批量转账 token\r\n   * 批量用户 _receivers\r\n   * 对应的转账数量 _values\r\n   * */\r\n  function batchTransfer(\r\n    address[] _receivers,\r\n    uint256[] _values\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    // 判断接收账号和token数量为一一对应\r\n    require(_receivers.length > 0 && _receivers.length == _values.length);\r\n\r\n    /**\r\n     * 获取到期的锁定期余额\r\n     * */\r\n    refreshlockedBalances(msg.sender, true);\r\n\r\n    // 判断可用余额足够\r\n    uint32 i = 0;\r\n    uint256 total = 0;\r\n    for (i = 0; i < _values.length; i ++)\r\n    {\r\n      total = total.add(_values[i]);\r\n    }\r\n    require(total <= balances[msg.sender]);\r\n\r\n    // 刷新vault余额\r\n    refreshVault(msg.sender, total);\r\n\r\n    // 一一 转账\r\n    for (i = 0; i < _receivers.length; i ++)\r\n    {\r\n      // 不能向赎回地址发送token\r\n      require(_receivers[i] != fundAccount);\r\n\r\n      // 不能向0地址转账\r\n      require(_receivers[i] != address(0));\r\n\r\n      refreshlockedBalances(_receivers[i], true);\r\n      // 修改可用账户余额\r\n      transferAvailableBalances(msg.sender, _receivers[i], _values[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 代理批量转账 token\r\n   * 被代理人 _from\r\n   * 批量用户 _receivers\r\n   * 对应的转账数量 _values\r\n   * */\r\n  function batchTransferFrom(\r\n    address _from,\r\n    address[] _receivers,\r\n    uint256[] _values\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    // 判断接收账号和token数量为一一对应\r\n    require(_receivers.length > 0 && _receivers.length == _values.length);\r\n\r\n    /**\r\n     * 获取到期的锁定期余额\r\n     * */\r\n    refreshlockedBalances(_from, true);\r\n\r\n    // 判断可用余额足够\r\n    uint32 i = 0;\r\n    uint256 total = 0;\r\n    for (i = 0; i < _values.length; i ++)\r\n    {\r\n      total = total.add(_values[i]);\r\n    }\r\n    require(total <= balances[_from]);\r\n\r\n    // 判断代理额度足够\r\n    require(total <= allowed[_from][msg.sender]);\r\n\r\n    // 修改代理额度\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(total);\r\n\r\n    // 刷新vault余额\r\n    refreshVault(_from, total);\r\n\r\n    // 一一 转账\r\n    for (i = 0; i < _receivers.length; i ++)\r\n    {\r\n      // 不能向赎回地址发送token\r\n      require(_receivers[i] != fundAccount);\r\n\r\n      // 不能向0地址转账\r\n      require(_receivers[i] != address(0));\r\n\r\n      refreshlockedBalances(_receivers[i], true);\r\n      // 修改可用账户余额\r\n      transferAvailableBalances(_from, _receivers[i], _values[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 带有锁定期的转账, 当锁定期到期之后，锁定token数量将转入可用余额\r\n   * _receiver 转账接收账户\r\n   * _values 转账数量\r\n   * _dates 锁定期，即到期时间\r\n   *        格式：UTC时间，单位秒，即从1970年1月1日开始到指定时间所经历的秒\r\n   * */\r\n  function transferByDate(\r\n    address _receiver,\r\n    uint256[] _values,\r\n    uint256[] _dates\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    // 判断接收账号和token数量为一一对应\r\n    require(_values.length > 0 &&\r\n        _values.length == _dates.length);\r\n\r\n    // 不能向赎回地址发送token\r\n    require(_receiver != fundAccount);\r\n\r\n    // 不能向0地址转账\r\n    require(_receiver != address(0));\r\n\r\n    /**\r\n     * 获取到期的锁定期余额\r\n     * */\r\n    refreshlockedBalances(msg.sender, true);\r\n    refreshlockedBalances(_receiver, true);\r\n\r\n    // 判断可用余额足够\r\n    uint32 i = 0;\r\n    uint256 total = 0;\r\n    for (i = 0; i < _values.length; i ++)\r\n    {\r\n      total = total.add(_values[i]);\r\n    }\r\n    require(total <= balances[msg.sender]);\r\n\r\n    // 刷新vault余额\r\n    refreshVault(msg.sender, total);\r\n\r\n    // 转账\r\n    for(i = 0; i < _values.length; i ++)\r\n    {\r\n      transferByDateSingle(msg.sender, _receiver, _values[i], _dates[i]);\r\n    }\r\n\r\n    emit TransferByDate(msg.sender, _receiver, _values, _dates);\r\n  }\r\n\r\n  /**\r\n   * 代理带有锁定期的转账, 当锁定期到期之后，锁定token数量将转入可用余额\r\n   * _from 被代理账户\r\n   * _receiver 转账接收账户\r\n   * _values 转账数量\r\n   * _dates 锁定期，即到期时间\r\n   *        格式：UTC时间，单位秒，即从1970年1月1日开始到指定时间所经历的秒\r\n   * */\r\n  function transferFromByDate(\r\n    address _from,\r\n    address _receiver,\r\n    uint256[] _values,\r\n    uint256[] _dates\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    // 判断接收账号和token数量为一一对应\r\n    require(_values.length > 0 &&\r\n        _values.length == _dates.length);\r\n\r\n    // 不能向赎回地址发送token\r\n    require(_receiver != fundAccount);\r\n\r\n    // 不能向0地址转账\r\n    require(_receiver != address(0));\r\n\r\n    /**\r\n     * 获取到期的锁定期余额\r\n     * */\r\n    refreshlockedBalances(_from, true);\r\n    refreshlockedBalances(_receiver, true);\r\n\r\n    // 判断可用余额足够\r\n    uint32 i = 0;\r\n    uint256 total = 0;\r\n    for (i = 0; i < _values.length; i ++)\r\n    {\r\n      total = total.add(_values[i]);\r\n    }\r\n    require(total <= balances[_from]);\r\n\r\n    // 判断代理额度足够\r\n    require(total <= allowed[_from][msg.sender]);\r\n\r\n    // 修改代理额度\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(total);\r\n\r\n    // 刷新vault余额\r\n    refreshVault(_from, total);\r\n\r\n    // 转账\r\n    for(i = 0; i < _values.length; i ++)\r\n    {\r\n      transferByDateSingle(_from, _receiver, _values[i], _dates[i]);\r\n    }\r\n\r\n    emit TransferFromByDate(msg.sender, _from, _receiver, _values, _dates);\r\n  }\r\n\r\n  /**\r\n   * _from token拥有者\r\n   * _to 转账接收账户\r\n   * _value 转账数量\r\n   * _date 锁定期，即到期时间\r\n   *       格式：UTC时间，单位秒，即从1970年1月1日开始到指定时间所经历的秒\r\n   * */\r\n  function transferByDateSingle(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    uint256 _date\r\n  )\r\n    internal\r\n  {\r\n    uint256 start_date = accounts[_to].start_date;\r\n    uint256 end_date = accounts[_to].end_date;\r\n    uint256 tmp_var = accounts[_to].lockedElement[_date].value;\r\n    uint256 tmp_date;\r\n\r\n    if (_value == 0)\r\n    {\r\n        // 不做任何处理\r\n        return ;\r\n    }\r\n\r\n    if (_date <= now)\r\n    {\r\n      // 到期时间比当前早，直接转入可用余额\r\n      // 修改可用账户余额\r\n      transferAvailableBalances(_from, _to, _value);\r\n\r\n      return ;\r\n    }\r\n\r\n    if (start_date == 0)\r\n    {\r\n      // 还没有收到过锁定期转账\r\n      // 最早时间和最晚时间一样\r\n      accounts[_to].start_date = _date;\r\n      accounts[_to].end_date = _date;\r\n      accounts[_to].lockedElement[_date].value = _value;\r\n    }\r\n    else if (tmp_var > 0)\r\n    {\r\n      // 收到过相同的锁定期\r\n      accounts[_to].lockedElement[_date].value = tmp_var.add(_value);\r\n    }\r\n    else if (_date < start_date)\r\n    {\r\n      // 锁定期比最早到期的还早\r\n      // 添加锁定期，并加入到锁定期列表\r\n      accounts[_to].lockedElement[_date].value = _value;\r\n      accounts[_to].lockedElement[_date].next = start_date;\r\n      accounts[_to].start_date = _date;\r\n    }\r\n    else if (_date > end_date)\r\n    {\r\n      // 锁定期比最晚到期还晚\r\n      // 添加锁定期，并加入到锁定期列表\r\n      accounts[_to].lockedElement[_date].value = _value;\r\n      accounts[_to].lockedElement[end_date].next = _date;\r\n      accounts[_to].end_date = _date;\r\n    }\r\n    else\r\n    {\r\n      /**\r\n       * 锁定期在 最早和最晚之间\r\n       * 首先找到插入的位置\r\n       * 然后在插入的位置插入数据\r\n       * tmp_var 即 tmp_next\r\n       * */\r\n      tmp_date = start_date;\r\n      tmp_var = accounts[_to].lockedElement[tmp_date].next;\r\n      while(tmp_var < _date)\r\n      {\r\n        tmp_date = tmp_var;\r\n        tmp_var = accounts[_to].lockedElement[tmp_date].next;\r\n      }\r\n\r\n      // 记录锁定期并加入列表\r\n      accounts[_to].lockedElement[_date].value = _value;\r\n      accounts[_to].lockedElement[_date].next = tmp_var;\r\n      accounts[_to].lockedElement[tmp_date].next = _date;\r\n    }\r\n\r\n    // 锁定期转账\r\n    transferLockedBalances(_from, _to, _value);\r\n\r\n    return ;\r\n  }\r\n\r\n  /**\r\n   * sell tokens\r\n   * */\r\n  function sell(uint256 _value) public whenOpenSell whenNotPaused {\r\n    transfer(fundAccount, _value);\r\n  }\r\n\r\n  /**\r\n   * 设置token赎回价格\r\n   * */\r\n  function setSellPrice(uint256 price) public whenAdministrator(msg.sender) {\r\n    require(price > 0);\r\n    sellPrice = price;\r\n\r\n    emit SetSellPrice(msg.sender, price);\r\n  }\r\n\r\n  /**\r\n   * 关闭购买赎回token\r\n   * */\r\n  function closeSell() public whenOpenSell onlyOwner {\r\n    sellFlag = false;\r\n    emit CloseSell(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * 重新计算账号的lockbalance\r\n   * */\r\n  function refresh(address _who) public whenNotPaused {\r\n    refreshlockedBalances(_who, true);\r\n    emit Refresh(msg.sender, _who);\r\n  }\r\n\r\n  /**\r\n   * 查询账户可用余额\r\n   * */\r\n  function availableBalanceOf(address _owner) public view returns (uint256) {\r\n    return (balances[_owner] + refreshlockedBalances(_owner, false));\r\n  }\r\n\r\n  /**\r\n   * 查询账户总余额\r\n   * */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner] + accounts[_owner].lockedBalances;\r\n  }\r\n\r\n  /**\r\n   * 获取锁定余额\r\n   * */\r\n  function lockedBalanceOf(address _who) public view returns (uint256) {\r\n    return (accounts[_who].lockedBalances - refreshlockedBalances(_who, false));\r\n  }\r\n\r\n  /**\r\n   * 根据日期获取锁定余额\r\n   * 返回：锁定余额，下一个锁定期\r\n   * */\r\n  function lockedBalanceOfByDate(address _who, uint256 date) public view returns (uint256, uint256) {\r\n    return (accounts[_who].lockedElement[date].value, accounts[_who].lockedElement[date].next);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"openForceAutoFree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"refresh\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"}],\"name\":\"transferFromByDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"delAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"availableBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"lockedBalances\",\"type\":\"uint256\"},{\"name\":\"start_date\",\"type\":\"uint256\"},{\"name\":\"end_date\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"}],\"name\":\"transferByDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"closeAutoFree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addTokenToFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"autoFreeLockBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"openAutoFree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"addAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"lockedBalanceOfByDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"forceAutoFreeLockBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_fund\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SetSellPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"dates\",\"type\":\"uint256[]\"}],\"name\":\"TransferByDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"dates\",\"type\":\"uint256[]\"}],\"name\":\"TransferFromByDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"CloseSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherValue\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherValue\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddTokenToFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Refresh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"OpenAutoFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"CloseAutoFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"OpenForceAutoFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddAdministrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DelAdministrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SibbayHealthToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006bd5f0f1846f913cff230014c32ac6f4e4fad4b00000000000000000000000008a0e4b86cd76684057bc0e62b5753f513fc332bb","Library":"","SwarmSource":"bzzr://ef36ac7fee16238d4316c20b1affb75aab55c0d2b49f237fefc3042caed72217"}]}