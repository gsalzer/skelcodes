{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.17;\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address internal owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n/*\r\n * @title AutoCoinICO\r\n * @dev AutoCoinCrowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them ATC tokens based\r\n * on a ATC token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n  mapping(address => uint256) balances;\r\n  mapping(address => bool) blockListed;\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    \r\n    require(\r\n        balances[msg.sender] >= _value\r\n        && _value > 0\r\n        && !blockListed[_to]\r\n        && !blockListed[msg.sender]\r\n    );\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(\r\n            balances[msg.sender] >= _value\r\n            && balances[_from] >= _value\r\n            && _value > 0\r\n            && !blockListed[_to]\r\n            && !blockListed[msg.sender]\r\n    );\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n  bool public mintingFinished = false;\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n    function addBlockeddUser(address user) public onlyOwner {\r\n        blockListed[user] = true;\r\n    }\r\n    function removeBlockeddUser(address user) public onlyOwner  {\r\n        blockListed[user] = false;\r\n    }\r\n}\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n  bool public paused = false;\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n/*\r\n * @title AutoCoin Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale is Ownable, Pausable {\r\n  using SafeMath for uint256;\r\n  /*\r\n   *  @MintableToken token - Token Object\r\n   *  @address wallet - Wallet Address\r\n   *  @uint8 rate - Tokens per Ether\r\n   *  @uint256 weiRaised - Total funds raised in Ethers\r\n  */\r\n  MintableToken internal token;\r\n  address internal wallet;\r\n  uint256 public rate;\r\n  uint256 internal weiRaised;\r\n  /*\r\n   *  @uint256 privateSaleStartTime - Private-Sale Start Time\r\n   *  @uint256 privateSaleEndTime - Private-Sale End Time\r\n   *  @uint256 preSaleStartTime - Pre-Sale Start Time\r\n   *  @uint256 preSaleEndTime - Pre-Sale End Time\r\n   *  @uint256 preICOStartTime - Pre-ICO Start Time\r\n   *  @uint256 preICOEndTime - Pre-ICO End Time\r\n   *  @uint256 ICOstartTime - ICO Start Time\r\n   *  @uint256 ICOEndTime - ICO End Time\r\n  */\r\n  \r\n  uint256 public privateSaleStartTime;\r\n  uint256 public privateSaleEndTime;\r\n  uint256 public preSaleStartTime;\r\n  uint256 public preSaleEndTime;\r\n  uint256 public preICOStartTime;\r\n  uint256 public preICOEndTime;\r\n  uint256 public ICOstartTime;\r\n  uint256 public ICOEndTime;\r\n  \r\n  /*\r\n   *  @uint privateBonus - Private Bonus\r\n   *  @uint preSaleBonus - Pre-Sale Bonus\r\n   *  @uint preICOBonus - Pre-Sale Bonus\r\n   *  @uint firstWeekBonus - ICO 1st Week Bonus\r\n   *  @uint secondWeekBonus - ICO 2nd Week Bonus\r\n   *  @uint thirdWeekBonus - ICO 3rd Week Bonus\r\n   *  @uint forthWeekBonus - ICO 4th Week Bonus\r\n   *  @uint fifthWeekBonus - ICO 5th Week Bonus\r\n  */\r\n  uint256 internal privateSaleBonus;\r\n  uint256 internal preSaleBonus;\r\n  uint256 internal preICOBonus;\r\n  uint256 internal firstWeekBonus;\r\n  uint256 internal secondWeekBonus;\r\n  uint256 internal thirdWeekBonus;\r\n  uint256 internal forthWeekBonus;\r\n  uint256 internal fifthWeekBonus;\r\n  uint256 internal weekOne;\r\n  uint256 internal weekTwo;\r\n  uint256 internal weekThree;\r\n  uint256 internal weekFour;\r\n  uint256 internal weekFive;\r\n  uint256 internal privateSaleTarget;\r\n  uint256 public preSaleTarget;\r\n  uint256 internal preICOTarget;\r\n  /*\r\n   *  @uint256 totalSupply - Total supply of tokens \r\n   *  @uint256 publicSupply - Total public Supply \r\n   *  @uint256 bountySupply - Total Bounty Supply\r\n   *  @uint256 reservedSupply - Total Reserved Supply \r\n   *  @uint256 privateSaleSupply - Total Private Supply from Public Supply  \r\n   *  @uint256 preSaleSupply - Total PreSale Supply from Public Supply \r\n   *  @uint256 preICOSupply - Total PreICO Supply from Public Supply\r\n   *  @uint256 icoSupply - Total ICO Supply from Public Supply\r\n  */\r\n  uint256 public totalSupply = SafeMath.mul(400000000, 1 ether);\r\n  uint256 internal publicSupply = SafeMath.mul(SafeMath.div(totalSupply,100),55);\r\n  uint256 internal bountySupply = SafeMath.mul(SafeMath.div(totalSupply,100),6);\r\n  uint256 internal reservedSupply = SafeMath.mul(SafeMath.div(totalSupply,100),39);\r\n  uint256 internal privateSaleSupply = SafeMath.mul(24750000, 1 ether);\r\n  uint256 public preSaleSupply = SafeMath.mul(39187500, 1 ether);\r\n  uint256 internal preICOSupply = SafeMath.mul(39187500, 1 ether);\r\n  uint256 internal icoSupply = SafeMath.mul(116875000, 1 ether);\r\n  /*\r\n   *  @bool checkUnsoldTokens - Tokens will be added to bounty supply\r\n   *  @bool upgradePreSaleSupply - Boolean variable updates when the PrivateSale tokens added to PreSale supply\r\n   *  @bool upgradePreICOSupply - Boolean variable updates when the PreSale tokens added to PreICO supply\r\n   *  @bool upgradeICOSupply - Boolean variable updates when the PreICO tokens added to ICO supply\r\n   *  @bool grantFounderTeamSupply - Boolean variable updates when Team and Founder tokens minted\r\n  */\r\n  bool public checkUnsoldTokens;\r\n  bool internal upgradePreSaleSupply;\r\n  bool internal upgradePreICOSupply;\r\n  bool internal upgradeICOSupply;\r\n  /*\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value Wei's paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n  /*\r\n   * function Crowdsale - Parameterized Constructor\r\n   * @param _startTime - StartTime of Crowdsale\r\n   * @param _endTime - EndTime of Crowdsale\r\n   * @param _rate - Tokens against Ether\r\n   * @param _wallet - MultiSignature Wallet Address\r\n   */\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) internal {\r\n    \r\n    require(_wallet != 0x0);\r\n    token = createTokenContract();\r\n    //privateSaleStartTime = _startTime;\r\n    //privateSaleEndTime = 1537952399;\r\n    preSaleStartTime = _startTime;\r\n    preSaleEndTime = 1541581199;\r\n    preICOStartTime = 1541581200;\r\n    preICOEndTime = 1544000399; \r\n    ICOstartTime = 1544000400;\r\n    ICOEndTime = _endTime;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    //privateSaleBonus = SafeMath.div(SafeMath.mul(rate,50),100);\r\n    preSaleBonus = SafeMath.div(SafeMath.mul(rate,30),100);\r\n    preICOBonus = SafeMath.div(SafeMath.mul(rate,30),100);\r\n    firstWeekBonus = SafeMath.div(SafeMath.mul(rate,20),100);\r\n    secondWeekBonus = SafeMath.div(SafeMath.mul(rate,15),100);\r\n    thirdWeekBonus = SafeMath.div(SafeMath.mul(rate,10),100);\r\n    forthWeekBonus = SafeMath.div(SafeMath.mul(rate,5),100);\r\n    \r\n    weekOne = SafeMath.add(ICOstartTime, 14 days);\r\n    weekTwo = SafeMath.add(weekOne, 14 days);\r\n    weekThree = SafeMath.add(weekTwo, 14 days);\r\n    weekFour = SafeMath.add(weekThree, 14 days);\r\n    weekFive = SafeMath.add(weekFour, 14 days);\r\n    privateSaleTarget = SafeMath.mul(4500, 1 ether);\r\n    preSaleTarget = SafeMath.mul(7125, 1 ether);\r\n    preICOTarget = SafeMath.mul(7125, 1 ether);\r\n    checkUnsoldTokens = false;\r\n    upgradeICOSupply = false;\r\n    upgradePreICOSupply = false;\r\n    upgradePreSaleSupply = false;\r\n  \r\n  }\r\n  /*\r\n   * function createTokenContract - Mintable Token Created\r\n   */\r\n  function createTokenContract() internal returns (MintableToken) {\r\n    return new MintableToken();\r\n  }\r\n  \r\n  /*\r\n   * function Fallback - Receives Ethers\r\n   */\r\n  function () payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n    /*\r\n   * function preSaleTokens - Calculate Tokens in PreSale\r\n   */\r\n  // function privateSaleTokens(uint256 weiAmount, uint256 tokens) internal returns (uint256) {\r\n        \r\n  //   require(privateSaleSupply > 0);\r\n  //   require(weiAmount <= privateSaleTarget);\r\n  //   tokens = SafeMath.add(tokens, weiAmount.mul(privateSaleBonus));\r\n  //   tokens = SafeMath.add(tokens, weiAmount.mul(rate));\r\n  //   require(privateSaleSupply >= tokens);\r\n  //   privateSaleSupply = privateSaleSupply.sub(tokens);        \r\n  //   privateSaleTarget = privateSaleTarget.sub(weiAmount);\r\n  //   return tokens;\r\n  // }\r\n  /*\r\n   * function preSaleTokens - Calculate Tokens in PreSale\r\n   */\r\n  function preSaleTokens(uint256 weiAmount, uint256 tokens) internal returns (uint256) {\r\n        \r\n    require(preSaleSupply > 0);\r\n    require(weiAmount <= preSaleTarget);\r\n    if (!upgradePreSaleSupply) {\r\n      preSaleSupply = SafeMath.add(preSaleSupply, privateSaleSupply);\r\n      preSaleTarget = SafeMath.add(preSaleTarget, privateSaleTarget);\r\n      upgradePreSaleSupply = true;\r\n    }\r\n    tokens = SafeMath.add(tokens, weiAmount.mul(preSaleBonus));\r\n    tokens = SafeMath.add(tokens, weiAmount.mul(rate));\r\n    require(preSaleSupply >= tokens);\r\n    preSaleSupply = preSaleSupply.sub(tokens);        \r\n    preSaleTarget = preSaleTarget.sub(weiAmount);\r\n    return tokens;\r\n  }\r\n  /*\r\n    * function preICOTokens - Calculate Tokens in PreICO\r\n    */\r\n  function preICOTokens(uint256 weiAmount, uint256 tokens) internal returns (uint256) {\r\n        \r\n    require(preICOSupply > 0);\r\n    require(weiAmount <= preICOTarget);\r\n    if (!upgradePreICOSupply) {\r\n      preICOSupply = SafeMath.add(preICOSupply, preSaleSupply);\r\n      preICOTarget = SafeMath.add(preICOTarget, preSaleTarget);\r\n      upgradePreICOSupply = true;\r\n    }\r\n    tokens = SafeMath.add(tokens, weiAmount.mul(preICOBonus));\r\n    tokens = SafeMath.add(tokens, weiAmount.mul(rate));\r\n    \r\n    require(preICOSupply >= tokens);\r\n    \r\n    preICOSupply = preICOSupply.sub(tokens);        \r\n    preICOTarget = preICOTarget.sub(weiAmount);\r\n    return tokens;\r\n  }\r\n  /*\r\n   * function icoTokens - Calculate Tokens in ICO\r\n   */\r\n  \r\n  function icoTokens(uint256 weiAmount, uint256 tokens, uint256 accessTime) internal returns (uint256) {\r\n        \r\n    require(icoSupply > 0);\r\n    if (!upgradeICOSupply) {\r\n      icoSupply = SafeMath.add(icoSupply,preICOSupply);\r\n      upgradeICOSupply = true;\r\n    }\r\n    \r\n    if (accessTime <= weekOne) {\r\n      tokens = SafeMath.add(tokens, weiAmount.mul(firstWeekBonus));\r\n    } else if (accessTime <= weekTwo) {\r\n      tokens = SafeMath.add(tokens, weiAmount.mul(secondWeekBonus));\r\n    } else if ( accessTime < weekThree ) {\r\n      tokens = SafeMath.add(tokens, weiAmount.mul(thirdWeekBonus));\r\n    } else if ( accessTime < weekFour ) {\r\n      tokens = SafeMath.add(tokens, weiAmount.mul(forthWeekBonus));\r\n    } else if ( accessTime < weekFive ) {\r\n      tokens = SafeMath.add(tokens, weiAmount.mul(fifthWeekBonus));\r\n    }\r\n    \r\n    tokens = SafeMath.add(tokens, weiAmount.mul(rate));\r\n    icoSupply = icoSupply.sub(tokens);        \r\n    return tokens;\r\n  }\r\n  /*\r\n  * function buyTokens - Collect Ethers and transfer tokens\r\n  */\r\n  function buyTokens(address beneficiary) whenNotPaused internal {\r\n    require(beneficiary != 0x0);\r\n    require(validPurchase());\r\n    uint256 accessTime = now;\r\n    uint256 tokens = 0;\r\n    uint256 weiAmount = msg.value;\r\n    require((weiAmount >= (100000000000000000)) && (weiAmount <= (20000000000000000000)));\r\n    if ((accessTime >= preSaleStartTime) && (accessTime < preSaleEndTime)) {\r\n      tokens = preSaleTokens(weiAmount, tokens);\r\n    } else if ((accessTime >= preICOStartTime) && (accessTime < preICOEndTime)) {\r\n      tokens = preICOTokens(weiAmount, tokens);\r\n    } else if ((accessTime >= ICOstartTime) && (accessTime <= ICOEndTime)) { \r\n      tokens = icoTokens(weiAmount, tokens, accessTime);\r\n    } else {\r\n      revert();\r\n    }\r\n    \r\n    publicSupply = publicSupply.sub(tokens);\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    token.mint(beneficiary, tokens);\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n    forwardFunds();\r\n  }\r\n  /*\r\n   * function forwardFunds - Transfer funds to wallet\r\n   */\r\n  function forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n  /*\r\n   * function validPurchase - Checks the purchase is valid or not\r\n   * @return true - Purchase is withPeriod and nonZero\r\n   */\r\n  function validPurchase() internal constant returns (bool) {\r\n    bool withinPeriod = now >= privateSaleStartTime && now <= ICOEndTime;\r\n    bool nonZeroPurchase = msg.value != 0;\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n  /*\r\n   * function hasEnded - Checks the ICO ends or not\r\n   * @return true - ICO Ends\r\n   */\r\n  \r\n  function hasEnded() public constant returns (bool) {\r\n    return now > ICOEndTime;\r\n  }\r\n  /*\r\n   * function unsoldToken - Function used to transfer all \r\n   *               unsold public tokens to reserve supply\r\n   */\r\n  function unsoldToken() onlyOwner public {\r\n    require(hasEnded());\r\n    require(!checkUnsoldTokens);\r\n    \r\n    checkUnsoldTokens = true;\r\n    bountySupply = SafeMath.add(bountySupply, publicSupply);\r\n    publicSupply = 0;\r\n  }\r\n  /* \r\n   * function getTokenAddress - Get Token Address \r\n   */\r\n  function getTokenAddress() onlyOwner public returns (address) {\r\n    return token;\r\n  }\r\n}\r\n/*\r\n * @title AutoCoinToken \r\n */\r\n \r\ncontract AutoCoinToken is MintableToken {\r\n  /*\r\n   *  @string name - Token Name\r\n   *  @string symbol - Token Symbol\r\n   *  @uint8 decimals - Token Decimals\r\n   *  @uint256 _totalSupply - Token Total Supply\r\n  */\r\n    string public constant name = \"AUTO COIN\";\r\n    string public constant symbol = \"AUTO COIN\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant _totalSupply = 400000000000000000000000000;\r\n  \r\n/* Constructor AutoCoinToken */\r\n    function AutoCoinToken() public {\r\n        totalSupply = _totalSupply;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract CrowdsaleFunctions is Crowdsale {\r\n /* \r\n  * function bountyFunds - Transfer bounty tokens via AirDrop\r\n  * @param beneficiary address where owner wants to transfer tokens\r\n  * @param tokens value of token\r\n  */\r\n    function bountyFunds(address[] beneficiary, uint256[] tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < beneficiary.length; i++) {\r\n            tokens[i] = SafeMath.mul(tokens[i],1 ether); \r\n            require(beneficiary[i] != 0x0);\r\n            require(bountySupply >= tokens[i]);\r\n            \r\n            bountySupply = SafeMath.sub(bountySupply,tokens[i]);\r\n            token.mint(beneficiary[i], tokens[i]);\r\n        }\r\n    }\r\n  /* \r\n   * function grantReservedToken - Transfer advisor,team and founder tokens  \r\n   */\r\n    function grantReservedToken(address beneficiary, uint256 tokens) public onlyOwner {\r\n        require(beneficiary != 0x0);\r\n        require(reservedSupply > 0);\r\n        tokens = SafeMath.mul(tokens,1 ether);\r\n        require(reservedSupply >= tokens);\r\n        reservedSupply = SafeMath.sub(reservedSupply,tokens);\r\n        token.mint(beneficiary, tokens);\r\n      \r\n    }\r\n/* \r\n *.function transferToken - Used to transfer tokens to investors who pays us other than Ethers\r\n * @param beneficiary - Address where owner wants to transfer tokens\r\n * @param tokens -  Number of tokens\r\n */\r\n    function singleTransferToken(address beneficiary, uint256 tokens) onlyOwner public {\r\n        \r\n        require(beneficiary != 0x0);\r\n        require(publicSupply > 0);\r\n        tokens = SafeMath.mul(tokens,1 ether);\r\n        require(publicSupply >= tokens);\r\n        publicSupply = SafeMath.sub(publicSupply,tokens);\r\n        token.mint(beneficiary, tokens);\r\n    }\r\n  /* \r\n   * function multiTransferToken - Transfer tokens on multiple addresses \r\n   */\r\n    function multiTransferToken(address[] beneficiary, uint256[] tokens) public onlyOwner {\r\n        for (uint256 i = 0; i < beneficiary.length; i++) {\r\n            tokens[i] = SafeMath.mul(tokens[i],1 ether); \r\n            require(beneficiary[i] != 0x0);\r\n            require(publicSupply >= tokens[i]);\r\n            \r\n            publicSupply = SafeMath.sub(publicSupply,tokens[i]);\r\n            token.mint(beneficiary[i], tokens[i]);\r\n        }\r\n    }\r\n    function addBlockListed(address user) public onlyOwner {\r\n        token.addBlockeddUser(user);\r\n    }\r\n    \r\n    function removeBlockListed(address user) public onlyOwner {\r\n        token.removeBlockeddUser(user);\r\n    }\r\n}\r\ncontract AutoCoinICO is Crowdsale, CrowdsaleFunctions {\r\n  \r\n    /* Constructor AutoCoinICO */\r\n    function AutoCoinICO(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet)   \r\n    Crowdsale(_startTime,_endTime,_rate,_wallet) \r\n    {\r\n    }\r\n    \r\n    /* AutoCoinToken Contract */\r\n    function createTokenContract() internal returns (MintableToken) {\r\n        return new AutoCoinToken();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"preSaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"grantReservedToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeBlockListed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unsoldToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkUnsoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addBlockListed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"singleTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateSaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address[]\"},{\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"bountyFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preICOEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preICOStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOstartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateSaleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address[]\"},{\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"multiTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AutoCoinICO","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005bb0d938000000000000000000000000000000000000000000000000000000005c628ad4000000000000000000000000000000000000000000000000000000000000051400000000000000000000000066b357f29c5c487c5e3627a1ef9c349e7eee22c6","Library":"","SwarmSource":"bzzr://402685cabc72a0ef51b9215d6c6e96ac07813de7eb0cf98df2f2cfade87890b8"}]}