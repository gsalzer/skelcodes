{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\npragma experimental \"v0.5.0\";\r\n/*\r\n  This file is part of The Colony Network.\r\n\r\n  The Colony Network is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  The Colony Network is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with The Colony Network. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n/*\r\n  This file is part of The Colony Network.\r\n\r\n  The Colony Network is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  The Colony Network is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with The Colony Network. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n/// base.sol -- basic ERC20 implementation\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/// erc20.sol -- API for the ERC20 token standard\r\n\r\n// See <https://github.com/ethereum/EIPs/issues/20>.\r\n\r\n// This file likely does not meet the threshold of originality\r\n// required for copyright to apply.  As a result, this is free and\r\n// unencumbered software belonging to the public domain.\r\n\r\n\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    constructor(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n/*\r\n  This file is part of The Colony Network.\r\n\r\n  The Colony Network is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  The Colony Network is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with The Colony Network. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20Extended is ERC20 {\r\n  event Mint(address indexed guy, uint wad);\r\n  event Burn(address indexed guy, uint wad);\r\n\r\n  function mint(uint wad) public;\r\n  \r\n  function burn(uint wad) public;\r\n}\r\n\r\n\r\ncontract Token is DSTokenBase(0), DSAuth, ERC20Extended {\r\n  uint8 public decimals;\r\n  string public symbol;\r\n  string public name;\r\n\r\n  bool public locked;\r\n\r\n  modifier unlocked {\r\n    if (locked) {\r\n      require(isAuthorized(msg.sender, msg.sig));\r\n    }\r\n    _;\r\n  }\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    locked = true;\r\n  }\r\n\r\n  function transferFrom(address src, address dst, uint wad) public \r\n  unlocked\r\n  returns (bool)\r\n  {\r\n    return super.transferFrom(src, dst, wad);\r\n  }\r\n\r\n  function mint(uint wad) public\r\n  auth\r\n  {\r\n    _balances[msg.sender] = add(_balances[msg.sender], wad);\r\n    _supply = add(_supply, wad);\r\n\r\n    emit Mint(msg.sender, wad);\r\n  }\r\n\r\n  function burn(uint wad) public {\r\n    _balances[msg.sender] = sub(_balances[msg.sender], wad);\r\n    _supply = sub(_supply, wad);\r\n\r\n    emit Burn(msg.sender, wad);\r\n  }\r\n\r\n  function unlock() public\r\n  auth\r\n  {\r\n    locked = false;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Vesting is DSMath {\r\n  Token public token;\r\n  address public colonyMultiSig;\r\n\r\n  uint constant internal SECONDS_PER_MONTH = 2628000;\r\n\r\n  event GrantAdded(address recipient, uint256 startTime, uint128 amount, uint16 vestingDuration, uint16 vestingCliff);\r\n  event GrantRemoved(address recipient, uint128 amountVested, uint128 amountNotVested);\r\n  event GrantTokensClaimed(address recipient, uint128 amountClaimed);\r\n\r\n  struct Grant {\r\n    uint startTime;\r\n    uint128 amount;\r\n    uint16 vestingDuration;\r\n    uint16 vestingCliff;\r\n    uint16 monthsClaimed;\r\n    uint128 totalClaimed;\r\n  }\r\n  mapping (address => Grant) public tokenGrants;\r\n\r\n  modifier onlyColonyMultiSig {\r\n    require(msg.sender == colonyMultiSig);\r\n    _;\r\n  }\r\n\r\n  modifier nonZeroAddress(address x) {\r\n    require(x != 0);\r\n    _;\r\n  }\r\n\r\n  modifier noGrantExistsForUser(address _user) {\r\n    require(tokenGrants[_user].startTime == 0);\r\n    _;\r\n  }\r\n\r\n  constructor(address _token, address _colonyMultiSig) public\r\n  nonZeroAddress(_token)\r\n  nonZeroAddress(_colonyMultiSig)\r\n  {\r\n    token = Token(_token);\r\n    colonyMultiSig = _colonyMultiSig;\r\n  }\r\n\r\n  /// @notice Add a new token grant for user `_recipient`. Only one grant per user is allowed\r\n  /// The amount of CLNY tokens here need to be preapproved for transfer by this `Vesting` contract before this call\r\n  /// Secured to the Colony MultiSig only\r\n  /// @param _recipient Address of the token grant recipient entitled to claim the grant funds\r\n  /// @param _startTime Grant start time as seconds since unix epoch\r\n  /// Allows backdating grants by passing time in the past. If `0` is passed here current blocktime is used. \r\n  /// @param _amount Total number of tokens in grant\r\n  /// @param _vestingDuration Number of months of the grant's duration\r\n  /// @param _vestingCliff Number of months of the grant's vesting cliff\r\n  function addTokenGrant(address _recipient, uint256 _startTime, uint128 _amount, uint16 _vestingDuration, uint16 _vestingCliff) public \r\n  onlyColonyMultiSig\r\n  noGrantExistsForUser(_recipient)\r\n  {\r\n    require(_vestingCliff > 0);\r\n    require(_vestingDuration > _vestingCliff);\r\n    uint amountVestedPerMonth = _amount / _vestingDuration;\r\n    require(amountVestedPerMonth > 0);\r\n\r\n    // Transfer the grant tokens under the control of the vesting contract\r\n    token.transferFrom(colonyMultiSig, address(this), _amount);\r\n\r\n    Grant memory grant = Grant({\r\n      startTime: _startTime == 0 ? now : _startTime,\r\n      amount: _amount,\r\n      vestingDuration: _vestingDuration,\r\n      vestingCliff: _vestingCliff,\r\n      monthsClaimed: 0,\r\n      totalClaimed: 0\r\n    });\r\n\r\n    tokenGrants[_recipient] = grant;\r\n    emit GrantAdded(_recipient, grant.startTime, _amount, _vestingDuration, _vestingCliff);\r\n  }\r\n\r\n  /// @notice Terminate token grant transferring all vested tokens to the `_recipient`\r\n  /// and returning all non-vested tokens to the Colony MultiSig\r\n  /// Secured to the Colony MultiSig only\r\n  /// @param _recipient Address of the token grant recipient\r\n  function removeTokenGrant(address _recipient) public \r\n  onlyColonyMultiSig\r\n  {\r\n    Grant storage tokenGrant = tokenGrants[_recipient];\r\n    uint16 monthsVested;\r\n    uint128 amountVested;\r\n    (monthsVested, amountVested) = calculateGrantClaim(_recipient);\r\n    uint128 amountNotVested = uint128(sub(sub(tokenGrant.amount, tokenGrant.totalClaimed), amountVested));\r\n\r\n    require(token.transfer(_recipient, amountVested));\r\n    require(token.transfer(colonyMultiSig, amountNotVested));\r\n\r\n    tokenGrant.startTime = 0;\r\n    tokenGrant.amount = 0;\r\n    tokenGrant.vestingDuration = 0;\r\n    tokenGrant.vestingCliff = 0;\r\n    tokenGrant.monthsClaimed = 0;\r\n    tokenGrant.totalClaimed = 0;\r\n\r\n    emit GrantRemoved(_recipient, amountVested, amountNotVested);\r\n  }\r\n\r\n  /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\r\n  /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\r\n  function claimVestedTokens() public {\r\n    uint16 monthsVested;\r\n    uint128 amountVested;\r\n    (monthsVested, amountVested) = calculateGrantClaim(msg.sender);\r\n    require(amountVested > 0);\r\n\r\n    Grant storage tokenGrant = tokenGrants[msg.sender];\r\n    tokenGrant.monthsClaimed = uint16(add(tokenGrant.monthsClaimed, monthsVested));\r\n    tokenGrant.totalClaimed = uint128(add(tokenGrant.totalClaimed, amountVested));\r\n    \r\n    require(token.transfer(msg.sender, amountVested));\r\n    emit GrantTokensClaimed(msg.sender, amountVested);\r\n  }\r\n\r\n  /// @notice Calculate the vested and unclaimed months and tokens available for `_recepient` to claim\r\n  /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\r\n  /// Returns (0, 0) if cliff has not been reached\r\n  function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {\r\n    Grant storage tokenGrant = tokenGrants[_recipient];\r\n\r\n    // For grants created with a future start date, that hasn't been reached, return 0, 0\r\n    if (now < tokenGrant.startTime) {\r\n      return (0, 0);\r\n    }\r\n\r\n    // Check cliff was reached\r\n    uint elapsedTime = sub(now, tokenGrant.startTime);\r\n    uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH;\r\n    \r\n    if (elapsedMonths < tokenGrant.vestingCliff) {\r\n      return (0, 0);\r\n    }\r\n\r\n    // If over vesting duration, all tokens vested\r\n    if (elapsedMonths >= tokenGrant.vestingDuration) {\r\n      uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;\r\n      return (tokenGrant.vestingDuration, remainingGrant);\r\n    } else {\r\n      uint16 monthsVested = uint16(sub(elapsedMonths, tokenGrant.monthsClaimed));\r\n      uint amountVestedPerMonth = tokenGrant.amount / tokenGrant.vestingDuration;\r\n      uint128 amountVested = uint128(mul(monthsVested, amountVestedPerMonth));\r\n      return (monthsVested, amountVested);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"colonyMultiSig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"removeTokenGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenGrants\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"vestingDuration\",\"type\":\"uint16\"},{\"name\":\"vestingCliff\",\"type\":\"uint16\"},{\"name\":\"monthsClaimed\",\"type\":\"uint16\"},{\"name\":\"totalClaimed\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint128\"},{\"name\":\"_vestingDuration\",\"type\":\"uint16\"},{\"name\":\"_vestingCliff\",\"type\":\"uint16\"}],\"name\":\"addTokenGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimVestedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"calculateGrantClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_colonyMultiSig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"vestingDuration\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"vestingCliff\",\"type\":\"uint16\"}],\"name\":\"GrantAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountVested\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"amountNotVested\",\"type\":\"uint128\"}],\"name\":\"GrantRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountClaimed\",\"type\":\"uint128\"}],\"name\":\"GrantTokensClaimed\",\"type\":\"event\"}]","ContractName":"Vesting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000006441deaf11d60d77e5e42d4f644c64ca05c2fce000000000000000000000000710e4c6ede91ef8de2f65d221316cf7448d3cf1c","Library":"","SwarmSource":"bzzr://a2a1ce7cd169546879e02cc8ddc9c7d53c49d526923f8d0b8dba0307e36ee3b8"}]}