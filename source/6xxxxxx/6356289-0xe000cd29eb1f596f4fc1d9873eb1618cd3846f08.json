{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\ncontract Vote {\r\n  using SafeMath for uint256;\r\n  struct Proposal {\r\n    uint deadline;\r\n    mapping(address => uint) votes;\r\n    uint yeas;\r\n    uint nays;\r\n    string reason;\r\n    bytes data;\r\n    address target;\r\n  }\r\n  struct Deposit {\r\n    uint balance;\r\n    uint lockedUntil;\r\n  }\r\n\r\n  event Proposed(\r\n    uint proposalId,\r\n    uint deadline,\r\n    address target\r\n  );\r\n\r\n  event Executed(\r\n    uint indexed proposalId\r\n  );\r\n\r\n  event Vote(\r\n    uint indexed proposalId,\r\n    address indexed voter,\r\n    uint yeas,\r\n    uint nays,\r\n    uint totalYeas,\r\n    uint totalNays\r\n  );\r\n\r\n  ERC20 public token;\r\n  uint public proposalDuration;\r\n  Proposal[] public proposals;\r\n  mapping(address => Deposit) public deposits;\r\n  mapping(address => bool) public proposers;\r\n\r\n  constructor(address _token) {\r\n    proposers[msg.sender] = true;\r\n    token = ERC20(_token);\r\n    proposalDuration = 5;\r\n    // Start with a passed proposal to increase the duration to 24 hours.\r\n    // Having a short initial proposalDuration makes testing easier, but 24\r\n    // hours is a more reasonable time frame for voting. Having a pre-approved\r\n    // proposal to increase the time means it only has to be executed, and not\r\n    // voted on, as proposing a vote and voting on it within a 5 second\r\n    // duration could be very difficult to accomplish on a main network.\r\n    proposals.push(Proposal({\r\n      deadline: block.timestamp,\r\n      yeas: 1,\r\n      nays: 0,\r\n      reason: \"\",\r\n      // ABI Encoded setProposalDuration(60*60*24)\r\n      data: hex\"7d007ac10000000000000000000000000000000000000000000000000000000000015180\",\r\n      target: this\r\n    }));\r\n  }\r\n\r\n  // In order to vote on a proposal, voters must deposit tokens in the contract\r\n  function deposit(uint units) public {\r\n    require(token.transferFrom(msg.sender, address(this), units), \"Transfer failed\");\r\n    deposits[msg.sender].balance = deposits[msg.sender].balance.add(units);\r\n  }\r\n\r\n  // Once all proposals a user has voted on have completed, they may withdraw\r\n  // their tokens from the contract.\r\n  function withdraw(uint units) external {\r\n    require(deposits[msg.sender].balance >= units, \"Insufficient balance\");\r\n    require(deposits[msg.sender].lockedUntil < block.timestamp, \"Deposit locked\");\r\n    deposits[msg.sender].balance = deposits[msg.sender].balance.sub(units);\r\n    token.transfer(msg.sender, units);\r\n  }\r\n\r\n  // A user may cast a number of yea or nay votes equal to the number of tokens\r\n  // they have deposited in the contract. This will lock the user's deposit\r\n  // until the voting ends for this proposal. Locking deposits ensures the user\r\n  // cannot vote, then transfer tokens away and use them to vote again.\r\n  function vote(uint proposalId, uint yeas, uint nays) public {\r\n\r\n    require(\r\n      proposals[proposalId].deadline > block.timestamp,\r\n      \"Voting closed\"\r\n    );\r\n    if(proposals[proposalId].deadline > deposits[msg.sender].lockedUntil) {\r\n      // The voter's deposit is locked until the proposal deadline\r\n      deposits[msg.sender].lockedUntil = proposals[proposalId].deadline;\r\n    }\r\n    // Track vote counts to ensure voters can only vote their deposited tokens\r\n    proposals[proposalId].votes[msg.sender] = proposals[proposalId].votes[msg.sender].add(yeas).add(nays);\r\n    require(proposals[proposalId].votes[msg.sender] <= deposits[msg.sender].balance, \"Insufficient balance\");\r\n\r\n    // Presumably only one of these will change.\r\n    proposals[proposalId].yeas = proposals[proposalId].yeas.add(yeas);\r\n    proposals[proposalId].nays = proposals[proposalId].nays.add(nays);\r\n\r\n    emit Vote(proposalId, msg.sender, yeas, nays, proposals[proposalId].yeas, proposals[proposalId].nays);\r\n  }\r\n\r\n  // depositAndVote allows users to call deposit() and vote() in a single\r\n  // transaction.\r\n  function depositAndVote(uint proposalId, uint yeas, uint nays) external {\r\n    deposit(yeas.add(nays));\r\n    vote(proposalId, yeas, nays);\r\n  }\r\n\r\n  // Authorized proposers may issue proposals. They must provide the contract\r\n  // data, the target contract, and a reason for the proposal. The reason will\r\n  // probably be a swarm / ipfs URL with a longer explanation.\r\n  function propose(bytes data, address target, string reason) external {\r\n    require(proposers[msg.sender], \"Invalid proposer\");\r\n    require(data.length > 0, \"Invalid proposal\");\r\n    uint proposalId = proposals.push(Proposal({\r\n      deadline: block.timestamp + proposalDuration,\r\n      yeas: 0,\r\n      nays: 0,\r\n      reason: reason,\r\n      data: data,\r\n      target: target\r\n    }));\r\n    emit Proposed(\r\n      proposalId - 1,\r\n      block.timestamp + proposalDuration,\r\n      target\r\n    );\r\n  }\r\n\r\n  // If a proposal has passed, it may be executed exactly once. Executed\r\n  // proposals will have the data zeroed out, discounting gas for the submitter\r\n  // and effectively marking the proposal as executed.\r\n  function execute(uint proposalId) external {\r\n    Proposal memory proposal = proposals[proposalId];\r\n    require(\r\n      // Voting is complete when the deadline passes, or a majority of all\r\n      // token holders have voted yea.\r\n      proposal.deadline < block.timestamp || proposal.yeas > (token.totalSupply() / 2),\r\n      \"Voting is not complete\"\r\n    );\r\n    require(proposal.data.length > 0, \"Already executed\");\r\n    if(proposal.yeas > proposal.nays) {\r\n      proposal.target.call(proposal.data);\r\n      emit Executed(proposalId);\r\n    }\r\n    // Even if the vote failed, we can still clean out the data\r\n    proposals[proposalId].data = \"\";\r\n  }\r\n\r\n  // As the result of a vote, proposers may be authorized or deauthorized\r\n  function setProposer(address proposer, bool value) public {\r\n    require(msg.sender == address(this), \"Setting a proposer requires a vote\");\r\n    proposers[proposer] = value;\r\n  }\r\n\r\n  // As the result of a vote, the duration of voting on a proposal can be\r\n  // changed\r\n  function setProposalDuration(uint value) public {\r\n    require(msg.sender == address(this), \"Setting a duration requires a vote\");\r\n    proposalDuration = value;\r\n  }\r\n\r\n  function proposalDeadline(uint proposalId) public view returns (uint) {\r\n    return proposals[proposalId].deadline;\r\n  }\r\n\r\n  function proposalData(uint proposalId) public view returns (bytes) {\r\n    return proposals[proposalId].data;\r\n  }\r\n\r\n  function proposalReason(uint proposalId) public view returns (string) {\r\n    return proposals[proposalId].reason;\r\n  }\r\n\r\n  function proposalTarget(uint proposalId) public view returns (address) {\r\n    return proposals[proposalId].target;\r\n  }\r\n\r\n  function proposalVotes(uint proposalId) public view returns (uint[]) {\r\n    uint[] memory votes = new uint[](2);\r\n    votes[0] = proposals[proposalId].yeas;\r\n    votes[1] = proposals[proposalId].nays;\r\n    return votes;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"yeas\",\"type\":\"uint256\"},{\"name\":\"nays\",\"type\":\"uint256\"},{\"name\":\"reason\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"target\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalReason\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"units\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setProposalDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"yeas\",\"type\":\"uint256\"},{\"name\":\"nays\",\"type\":\"uint256\"}],\"name\":\"depositAndVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"yeas\",\"type\":\"uint256\"},{\"name\":\"nays\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"units\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposer\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setProposer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deadline\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Proposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"yeas\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalYeas\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalNays\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"}]","ContractName":"Vote","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005f2a3496f1adebf7966d003090731c50b0d76969","Library":"","SwarmSource":"bzzr://c81946e7f03548e991eb9e0b3eb74e67b65891a53f03a40a06b2831bbc053372"}]}