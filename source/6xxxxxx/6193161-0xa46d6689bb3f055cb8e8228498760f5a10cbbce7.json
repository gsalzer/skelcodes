{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface IRescue {\r\n    function canRescue(address _addr) external returns (bool);\r\n}\r\n\r\ncontract TeambrellaWallet {\r\n    \r\n    uint public m_opNum;\r\n    uint public m_teamId;\r\n    address public m_owner;\r\n    address[] public m_cosigners;\r\n    address[] public m_cosignersApprovedDisband;    \r\n\r\n    address m_rescuer;\r\n    \r\n    modifier orderedOps(uint opNum) {\r\n        require(opNum >= m_opNum);\r\n        _; \r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == m_owner);\r\n        _; \r\n    }\r\n    \r\n    function() public payable { }\r\n\r\n\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    function ecrecovery(bytes32 hash, bytes sig) private returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function ecverify(bytes32 hash, bytes sig, address signer) private returns (bool) {\r\n        bool ret;\r\n        address addr;\r\n\r\n        (ret, addr) = ecrecovery(hash, sig);\r\n\r\n        return ret == true && addr == signer;\r\n    }\r\n\r\n    function checkSignatures(\r\n        bytes32 hash,\r\n        uint[3] cosignersPos,\r\n        bytes sigCosigner0,\r\n        bytes sigCosigner1,\r\n        bytes sigCosigner2\r\n        ) private returns(bool) {\r\n\r\n        uint cosignersNum = m_cosigners.length;\r\n        bool signed = ecverify(hash, sigCosigner0, m_cosigners[cosignersPos[0]]);\r\n        if (cosignersNum > 3) {\r\n            signed = signed && ecverify(hash, sigCosigner1, m_cosigners[cosignersPos[1]]);\r\n        }\r\n        if (cosignersNum > 6) {\r\n            signed = signed && ecverify(hash, sigCosigner2, m_cosigners[cosignersPos[2]]);\r\n        }\r\n\r\n        return signed;\r\n    }\r\n    \r\n    function checkSignatures2(\r\n        bytes32 hash,\r\n        bytes sigCosigner0,\r\n        bytes sigCosigner1,\r\n        bytes sigCosigner2\r\n        ) private returns(bool) {\r\n\r\n        uint cosignersNum = m_cosigners.length;\r\n        uint pos = uint(sigCosigner0[65]);\r\n        bool signed = ecverify(hash, sigCosigner0, m_cosigners[pos]);\r\n        if (cosignersNum > 3) {\r\n            pos = uint(sigCosigner1[65]);\r\n            signed = signed && ecverify(hash, sigCosigner1, m_cosigners[pos]);\r\n        }\r\n        if (cosignersNum > 6) {\r\n            pos = uint(sigCosigner2[65]);\r\n            signed = signed && ecverify(hash, sigCosigner2, m_cosigners[pos]);\r\n        }\r\n        return signed;\r\n    }\r\n\r\n    function toBytes(uint256[] x) private pure returns (bytes b) {\r\n        b = new bytes(32 * x.length);\r\n        for (uint j = 0; j < x.length; j++) {\r\n            for (uint i = 0; i < 32; i++) {\r\n                b[j*32 + i] = byte(uint8(x[j] / (2**(8*(31 - i))))); \r\n            }\r\n        }\r\n    }\r\n\r\n    function toBytes(address[] x) private pure returns (bytes b) {\r\n\r\n        b = new bytes(20 * x.length);\r\n        for (uint j = 0; j < x.length; j++) {\r\n            for (uint i = 0; i < 20; i++) {\r\n                b[j*20 + i] = byte(uint8(uint160(x[j]) / (2**(8*(19 - i))))); \r\n            }\r\n        }\r\n    }\r\n\r\n    constructor() public payable {\r\n        m_opNum = 1;\r\n\t\tm_owner = msg.sender;\r\n\t\tm_rescuer = 0x127c4605cFe96C4649A58ff6db7B216440C9EFa2; // mainnet\r\n    }\r\n    \r\n     function assignOwner(address[] cosigners, uint teamId, address newOwner) onlyOwner external {\r\n\t\tif (m_cosigners.length == 0)\r\n\t\t{\r\n\t\t\tm_cosigners = cosigners;\r\n\t\t\tm_teamId = teamId;\r\n\t\t\tm_owner = newOwner;\r\n\t\t}\r\n    }\r\n       \r\n    function changeAllCosigners(\r\n        uint opNum,\r\n        address[] newCosigners,\r\n        uint[3] cosignersPos,\r\n        bytes sigCosigner0, \r\n        bytes sigCosigner1,\r\n        bytes sigCosigner2 \r\n        ) onlyOwner orderedOps(opNum) external {\r\n\r\n        bytes32 hash = keccak256(\"NS\", m_teamId, opNum, toBytes(newCosigners));\r\n        require(checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2));\r\n        m_opNum = opNum + 1;\r\n        m_cosignersApprovedDisband.length = 0;\r\n        m_cosigners = newCosigners;\r\n    }\r\n\r\n    function changeAllCosigners2(\r\n        uint opNum,\r\n        address[] newCosigners,\r\n        bytes sigCosigner0, \r\n        bytes sigCosigner1,\r\n        bytes sigCosigner2,\r\n        bytes sigOwner \r\n        ) orderedOps(opNum) external {\r\n\r\n        bytes32 hash = keccak256(\"NS\", m_teamId, opNum, toBytes(newCosigners));\r\n        require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2));\r\n        require(ecverify(hash, sigOwner, m_owner));\r\n        m_opNum = opNum + 1;\r\n        m_cosignersApprovedDisband.length = 0;\r\n        m_cosigners = newCosigners;\r\n    }\r\n        \r\n    function getsum(uint[] values) private pure returns (uint s) {\r\n        s = 0;\r\n\r\n        for (uint j = 0; j < values.length; j++) {\r\n            s += values[j];\r\n        }\r\n\r\n        return s;    \r\n    }\r\n        \r\n    function transfer(\r\n        uint opNum,\r\n        address[] tos, \r\n        uint[] values,\r\n        uint[3] cosignersPos,\r\n        bytes sigCosigner0, \r\n        bytes sigCosigner1, \r\n        bytes sigCosigner2\r\n        ) onlyOwner orderedOps(opNum) external {\r\n\r\n        require (getsum(values) <= address(this).balance);\r\n        bytes32 hash = keccak256(\"TR\", m_teamId, opNum, toBytes(tos), toBytes(values));\r\n        require (checkSignatures(hash, cosignersPos, sigCosigner0, sigCosigner1, sigCosigner2));\r\n        m_opNum = opNum + 1;\r\n        realtransfer(tos, values);\r\n    }\r\n\r\n    function transfer2(\r\n        uint opNum,\r\n        address[] tos, \r\n        uint[] values,\r\n        bytes sigCosigner0,\r\n        bytes sigCosigner1,\r\n        bytes sigCosigner2,\r\n        bytes sigOwner\r\n        ) external {\r\n        require(opNum >= m_opNum);\r\n        require (getsum(values) <= address(this).balance);\r\n        bytes32 hash = keccak256(\"TR\", m_teamId, opNum, toBytes(tos), toBytes(values));\r\n        require(checkSignatures2(hash, sigCosigner0, sigCosigner1, sigCosigner2));\r\n        require(ecverify(hash, sigOwner, m_owner));\r\n        m_opNum = opNum + 1;\r\n        realtransfer(tos, values);\r\n    }    \r\n\r\n    function realtransfer(address[] tos, uint[] values) private {\r\n\r\n        for (uint i = 0; i < values.length; i++) {\r\n            tos[i].transfer(values[i]);\r\n        }\r\n    }\r\n\r\n    function approveDisband() external {\r\n\r\n        for (uint pos=0; pos<m_cosignersApprovedDisband.length; pos++) {\r\n            if (m_cosignersApprovedDisband[pos] == msg.sender) {\r\n                return;\r\n            }\r\n        }\r\n        for (pos=0; pos<m_cosigners.length; pos++) {\r\n            if (m_cosigners[pos] == msg.sender) {\r\n                m_cosignersApprovedDisband.push(msg.sender);\r\n            }\r\n        }\r\n    }\r\n\r\n    function disbandTo(address to) onlyOwner external {\r\n\r\n        uint cosignersNum = m_cosigners.length;\r\n        uint approved = m_cosignersApprovedDisband.length;\r\n        if (cosignersNum > 6) {\r\n            require(approved > 2);\r\n        }\r\n        if (cosignersNum > 3) {\r\n            require(approved > 1);\r\n        }\r\n        require(approved > 0);\r\n\r\n        to.transfer(address(this).balance);\r\n    }\r\n    \r\n    function rescue(\r\n        address _to \r\n        ) onlyOwner external {\r\n\r\n        IRescue rescuer = IRescue(m_rescuer);\r\n        require(rescuer.canRescue(msg.sender));\r\n        \r\n        _to.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"m_cosignersApprovedDisband\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"opNum\",\"type\":\"uint256\"},{\"name\":\"newCosigners\",\"type\":\"address[]\"},{\"name\":\"sigCosigner0\",\"type\":\"bytes\"},{\"name\":\"sigCosigner1\",\"type\":\"bytes\"},{\"name\":\"sigCosigner2\",\"type\":\"bytes\"},{\"name\":\"sigOwner\",\"type\":\"bytes\"}],\"name\":\"changeAllCosigners2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"m_cosigners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveDisband\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_teamId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"opNum\",\"type\":\"uint256\"},{\"name\":\"tos\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"sigCosigner0\",\"type\":\"bytes\"},{\"name\":\"sigCosigner1\",\"type\":\"bytes\"},{\"name\":\"sigCosigner2\",\"type\":\"bytes\"},{\"name\":\"sigOwner\",\"type\":\"bytes\"}],\"name\":\"transfer2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"opNum\",\"type\":\"uint256\"},{\"name\":\"tos\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"cosignersPos\",\"type\":\"uint256[3]\"},{\"name\":\"sigCosigner0\",\"type\":\"bytes\"},{\"name\":\"sigCosigner1\",\"type\":\"bytes\"},{\"name\":\"sigCosigner2\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"opNum\",\"type\":\"uint256\"},{\"name\":\"newCosigners\",\"type\":\"address[]\"},{\"name\":\"cosignersPos\",\"type\":\"uint256[3]\"},{\"name\":\"sigCosigner0\",\"type\":\"bytes\"},{\"name\":\"sigCosigner1\",\"type\":\"bytes\"},{\"name\":\"sigCosigner2\",\"type\":\"bytes\"}],\"name\":\"changeAllCosigners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"disbandTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cosigners\",\"type\":\"address[]\"},{\"name\":\"teamId\",\"type\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"assignOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_opNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TeambrellaWallet","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6e4e4e3318778c8638fd37f03a5de2b524b8873f0bcaaf9585dfa57ff4cabbe3"}]}