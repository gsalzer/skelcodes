{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary Math {\r\n    function min(uint a, uint b) internal pure returns(uint) {\r\n        if (a > b) {\r\n            return b;\r\n    }\r\n        return a;\r\n    }\r\n}\r\n\r\n\r\nlibrary Zero {\r\n    function requireNotZero(address addr) internal pure {\r\n        require(addr != address(0), \"require not zero address\");\r\n    }\r\n\r\n    function requireNotZero(uint val) internal pure {\r\n        require(val != 0, \"require not zero value\");\r\n    }\r\n\r\n    function notZero(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n\r\n    function isZero(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n\r\n    function isZero(uint a) internal pure returns(bool) {\r\n        return a == 0;\r\n    }\r\n\r\n    function notZero(uint a) internal pure returns(bool) {\r\n        return a != 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n    struct percent {\r\n      uint num;\r\n      uint den;\r\n    }\r\n\r\n    // storage\r\n    function mul(percent storage p, uint a) internal view returns (uint) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      return a*p.num/p.den;\r\n    }\r\n\r\n    function div(percent storage p, uint a) internal view returns (uint) {\r\n      return a/p.num*p.den;\r\n    }\r\n\r\n    function sub(percent storage p, uint a) internal view returns (uint) {\r\n      uint b = mul(p, a);\r\n      if (b >= a) {\r\n        return 0;\r\n      }\r\n      return a - b;\r\n    }\r\n\r\n    function add(percent storage p, uint a) internal view returns (uint) {\r\n      return a + mul(p, a);\r\n    }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n      return Percent.percent(p.num, p.den);\r\n    }\r\n\r\n    // memory\r\n    function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      return a*p.num/p.den;\r\n    }\r\n\r\n    function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n      return a/p.num*p.den;\r\n    }\r\n\r\n    function msub(percent memory p, uint a) internal pure returns (uint) {\r\n      uint b = mmul(p, a);\r\n      if (b >= a) {\r\n        return 0;\r\n      }\r\n      return a - b;\r\n    }\r\n\r\n    function madd(percent memory p, uint a) internal pure returns (uint) {\r\n      return a + mmul(p, a);\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function toAddress(bytes source) internal pure returns(address addr) {\r\n      assembly { addr := mload(add(source,0x14)) }\r\n      return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n      uint length;\r\n      assembly { length := extcodesize(addr) }\r\n      return length == 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n      // benefit is lost if 'b' is also tested.\r\n      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n          return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n      uint256 c = _a + _b;\r\n      require(c >= _a);\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n    address private owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n      owner = msg.sender;\r\n    }\r\n\r\n    function disown() internal {\r\n      delete owner;\r\n    }\r\n}\r\n\r\ncontract InvestorsStorage is Accessibility {\r\n    using SafeMath for uint;\r\n    struct Investor {\r\n        uint investment;\r\n        uint paymentTime;\r\n        uint maxPayout; \r\n        bool exit;\r\n    }\r\n\r\n    uint public size;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    function isInvestor(address addr) public view returns (bool) {\r\n      return investors[addr]. investment > 0;\r\n    }\r\n\r\n    function investorInfo(address addr) public view returns(uint investment, uint paymentTime,uint maxPayout,bool exit) {\r\n        investment = investors[addr].investment;\r\n        paymentTime = investors[addr].paymentTime;\r\n        maxPayout = investors[addr].maxPayout;\r\n        exit = investors[addr].exit;\r\n    }\r\n\r\n    function newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {\r\n        // initialize new investor to investment and maxPayout = 2x investment\r\n        Investor storage inv = investors[addr];\r\n        if (inv.investment != 0 || investment == 0) {\r\n            return false;\r\n        }\r\n        inv.exit = false;\r\n        inv.investment = investment; \r\n        inv.maxPayout = investment.mul(2); \r\n        inv.paymentTime = paymentTime;\r\n        size++;\r\n        return true;\r\n    }\r\n\r\n    function addInvestment(address addr, uint investment,uint dividends) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].investment += investment;\r\n\r\n        // Update maximum payout exlude dividends\r\n        investors[addr].maxPayout += (investment-dividends).mul(2);\r\n        return true;\r\n    }\r\n\r\n    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n        if(investors[addr].exit){\r\n            return true;\r\n        }\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].paymentTime = paymentTime;\r\n        return true;\r\n    }\r\n    function investorExit(address addr)  public onlyOwner returns (bool){\r\n        investors[addr].exit = true;\r\n        investors[addr].maxPayout = 0;\r\n        investors[addr].investment = 0;\r\n    }\r\n    function payout(address addr, uint dividend) public onlyOwner returns (uint) {\r\n        uint dividendToPay = 0;\r\n        if(investors[addr].maxPayout <= dividend){\r\n            dividendToPay = investors[addr].maxPayout;\r\n            investorExit(addr);\r\n        } else{\r\n            dividendToPay = dividend;\r\n            investors[addr].maxPayout -= dividend;\r\n      }\r\n        return dividendToPay;\r\n    }\r\n}\r\n\r\n\r\nlibrary RapidGrowthProtection {\r\n  using RapidGrowthProtection for rapidGrowthProtection;\r\n\r\n  struct rapidGrowthProtection {\r\n    uint startTimestamp;\r\n    uint maxDailyTotalInvestment;\r\n    uint8 activityDays;\r\n    mapping(uint8 => uint) dailyTotalInvestment;\r\n  }\r\n\r\n  function maxInvestmentAtNow(rapidGrowthProtection storage rgp) internal view returns(uint) {\r\n    uint day = rgp.currDay();\r\n    if (day == 0 || day > rgp.activityDays) {\r\n      return 0;\r\n    }\r\n    if (rgp.dailyTotalInvestment[uint8(day)] >= rgp.maxDailyTotalInvestment) {\r\n      return 0;\r\n    }\r\n    return rgp.maxDailyTotalInvestment - rgp.dailyTotalInvestment[uint8(day)];\r\n  }\r\n\r\n    function isActive(rapidGrowthProtection storage rgp) internal view returns(bool) {\r\n        uint day = rgp.currDay();\r\n        return day != 0 && day <= rgp.activityDays;\r\n    }\r\n\r\n  function saveInvestment(rapidGrowthProtection storage rgp, uint investment) internal returns(bool) {\r\n    uint day = rgp.currDay();\r\n    if (day == 0 || day > rgp.activityDays) {\r\n      return false;\r\n    }\r\n    if (rgp.dailyTotalInvestment[uint8(day)] + investment > rgp.maxDailyTotalInvestment) {\r\n      return false;\r\n    }\r\n    rgp.dailyTotalInvestment[uint8(day)] += investment;\r\n    return true;\r\n  }\r\n\r\n  function startAt(rapidGrowthProtection storage rgp, uint timestamp) internal {\r\n    rgp.startTimestamp = timestamp;\r\n\r\n    // restart\r\n    for (uint8 i = 1; i <= rgp.activityDays; i++) {\r\n      if (rgp.dailyTotalInvestment[i] != 0) {\r\n        delete rgp.dailyTotalInvestment[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  function currDay(rapidGrowthProtection storage rgp) internal view returns(uint day) {\r\n    if (rgp.startTimestamp > now) {\r\n      return 0;\r\n    }\r\n    day = (now - rgp.startTimestamp) / 24 hours + 1; // +1 for skipping zero day\r\n  }\r\n}\r\n\r\n\r\nlibrary BonusPool {\r\n    using BonusPool for bonusPool;\r\n    struct bonusLevel {\r\n        uint bonusAmount;\r\n        bool triggered;\r\n        uint triggeredTimestamp; \r\n        bool bonusSet;\r\n    }\r\n\r\n    struct bonusPool {\r\n        uint8 nextLevelToTrigger;\r\n        mapping(uint8 => bonusLevel) bonusLevels;\r\n    }\r\n\r\n    function setBonus(bonusPool storage self,uint8 level,uint amount) internal {\r\n        require(!self.bonusLevels[level].bonusSet,\"Bonus already set\");\r\n        self.bonusLevels[level].bonusAmount = amount;\r\n        self.bonusLevels[level].bonusSet = true;\r\n        self.bonusLevels[level].triggered = false;\r\n    }\r\n    \r\n    function hasMetBonusTriggerLevel(bonusPool storage self) internal returns(bool){\r\n        bonusLevel storage nextBonusLevel = self.bonusLevels[self.nextLevelToTrigger];\r\n        if(address(this).balance >= nextBonusLevel.bonusAmount){\r\n            if(nextBonusLevel.triggered){\r\n                self.goToNextLevel();\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function prizeToPool(bonusPool storage self) internal returns(uint){\r\n        return self.bonusLevels[self.nextLevelToTrigger].bonusAmount;\r\n    }\r\n\r\n    function goToNextLevel(bonusPool storage self) internal {\r\n        self.bonusLevels[self.nextLevelToTrigger].triggered = true;\r\n        self.nextLevelToTrigger += 1;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Myethsss is Accessibility {\r\n    using RapidGrowthProtection for RapidGrowthProtection.rapidGrowthProtection;\r\n    using BonusPool for BonusPool.bonusPool;\r\n    using Percent for Percent.percent;\r\n    using SafeMath for uint;\r\n    using Math for uint;\r\n\r\n    // easy read for investors\r\n    using Address for *;\r\n    using Zero for *;\r\n\r\n    RapidGrowthProtection.rapidGrowthProtection private m_rgp;\r\n    BonusPool.bonusPool private m_bonusPool;\r\n    mapping(address => bool) private m_referrals;\r\n    InvestorsStorage private m_investors;\r\n    uint totalRealBalance;\r\n    // automatically generates getters\r\n    uint public constant minInvesment = 0.1 ether; //       0.1 eth\r\n    uint public constant maxBalance = 366e5 ether; // 36 600 000 eth\r\n    address public advertisingAddress;\r\n    address public adminsAddress;\r\n    address public riskAddress;\r\n    address public bonusAddress;\r\n    uint public investmentsNumber;\r\n    uint public waveStartup;\r\n\r\n  // percents\r\n    Percent.percent private m_1_percent = Percent.percent(1, 100);           //   1/100  *100% = 1%\r\n    Percent.percent private m_1_66_percent = Percent.percent(166, 10000);           //   166/10000*100% = 1.66%\r\n    Percent.percent private m_2_66_percent = Percent.percent(266, 10000);    // 266/10000*100% = 2.66%\r\n    Percent.percent private m_6_66_percent = Percent.percent(666, 10000);    // 666/10000*100% = 6.66% refer bonus\r\n    Percent.percent private m_adminsPercent = Percent.percent(5, 100);       //   5/100  *100% = 5%\r\n    Percent.percent private m_advertisingPercent = Percent.percent(5, 100); // 5/1000  *100% = 5%\r\n    Percent.percent private m_riskPercent = Percent.percent(5, 100); // 5/1000  *100% = 5%\r\n    Percent.percent private m_bonusPercent = Percent.percent(666, 10000);           //   666/10000  *100% = 6.66%\r\n\r\n    modifier balanceChanged {\r\n        _;\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(msg.sender.isNotContract(), \"only externally accounts\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        adminsAddress = msg.sender;\r\n        advertisingAddress = msg.sender;\r\n        riskAddress=msg.sender;\r\n        bonusAddress = msg.sender;\r\n        nextWave();\r\n    }\r\n\r\n    function() public payable {\r\n        if (msg.value.isZero()) {\r\n            getMyDividends();\r\n            return;\r\n        }\r\n        doInvest(msg.data.toAddress());\r\n    }\r\n\r\n    function doDisown() public onlyOwner {\r\n        disown();\r\n    }\r\n// uint timestamp\r\n    function init() public onlyOwner {\r\n        m_rgp.startTimestamp = now + 1;\r\n        m_rgp.maxDailyTotalInvestment = 5000 ether;\r\n        m_rgp.activityDays = 21;\r\n        // Set bonus pool tier\r\n        m_bonusPool.setBonus(0,3000 ether);\r\n        m_bonusPool.setBonus(1,6000 ether);\r\n        m_bonusPool.setBonus(2,10000 ether);\r\n        m_bonusPool.setBonus(3,15000 ether);\r\n        m_bonusPool.setBonus(4,20000 ether);\r\n        m_bonusPool.setBonus(5,25000 ether);\r\n        m_bonusPool.setBonus(6,30000 ether);\r\n        m_bonusPool.setBonus(7,35000 ether);\r\n        m_bonusPool.setBonus(8,40000 ether);\r\n        m_bonusPool.setBonus(9,45000 ether);\r\n        m_bonusPool.setBonus(10,50000 ether);\r\n        m_bonusPool.setBonus(11,60000 ether);\r\n        m_bonusPool.setBonus(12,70000 ether);\r\n        m_bonusPool.setBonus(13,80000 ether);\r\n        m_bonusPool.setBonus(14,90000 ether);\r\n        m_bonusPool.setBonus(15,100000 ether);\r\n        m_bonusPool.setBonus(16,150000 ether);\r\n        m_bonusPool.setBonus(17,200000 ether);\r\n        m_bonusPool.setBonus(18,500000 ether);\r\n        m_bonusPool.setBonus(19,1000000 ether);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    function getBonusAmount(uint8 level) public view returns(uint){\r\n        return m_bonusPool.bonusLevels[level].bonusAmount;\r\n        \r\n    }\r\n    function doBonusPooling() public onlyOwner {\r\n        require(m_bonusPool.hasMetBonusTriggerLevel(),\"Has not met next bonus requirement\");\r\n        bonusAddress.transfer(m_bonusPercent.mul(m_bonusPool.prizeToPool()));\r\n        m_bonusPool.goToNextLevel();\r\n    }\r\n\r\n    function setAdvertisingAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        advertisingAddress = addr;\r\n    }\r\n\r\n    function setAdminsAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        adminsAddress = addr;\r\n    }\r\n\r\n    function setRiskAddress(address addr) public onlyOwner{\r\n        addr.requireNotZero();\r\n        riskAddress=addr;\r\n    }\r\n\r\n    function setBonusAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        bonusAddress = addr;\r\n    }\r\n\r\n\r\n    function rapidGrowthProtectionmMaxInvestmentAtNow() public view returns(uint investment) {\r\n        investment = m_rgp.maxInvestmentAtNow();\r\n    }\r\n\r\n    function investorsNumber() public view returns(uint) {\r\n        return m_investors.size();\r\n    }\r\n\r\n    function balanceETH() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function percent1() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_1_percent.num, m_1_percent.den);\r\n    }\r\n\r\n    function percent2() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_1_66_percent.num, m_1_66_percent.den);\r\n    }\r\n\r\n    function percent3_33() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_2_66_percent.num, m_2_66_percent.den);\r\n    }\r\n\r\n    function advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n    }\r\n\r\n    function adminsPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n    }\r\n    function riskPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_riskPercent.num, m_riskPercent.den);\r\n    }\r\n\r\n    function investorInfo(address investorAddr) public view returns(uint investment, uint paymentTime,uint maxPayout,bool exit, bool isReferral) {\r\n        (investment, paymentTime,maxPayout,exit) = m_investors.investorInfo(investorAddr);\r\n        isReferral = m_referrals[investorAddr];\r\n    }\r\n\r\n    function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\n        dividends = calcDividends(investorAddr);\r\n    }\r\n\r\n    function dailyPercentAtNow() public view returns(uint numerator, uint denominator) {\r\n        Percent.percent memory p = dailyPercent();\r\n        (numerator, denominator) = (p.num, p.den);\r\n    }\r\n\r\n    function refBonusPercentAtNow() public view returns(uint numerator, uint denominator) {\r\n        Percent.percent memory p = refBonusPercent();\r\n        (numerator, denominator) = (p.num, p.den);\r\n    }\r\n\r\n    function getMyDividends() public notFromContract balanceChanged {\r\n      // calculate dividends\r\n        uint dividends = calcDividends(msg.sender);\r\n        require (dividends.notZero(), \"cannot pay zero dividends\");\r\n        // deduct payout from max\r\n        dividends = m_investors.payout(msg.sender,dividends);\r\n            // update investor payment timestamp\r\n        assert(m_investors.setPaymentTime(msg.sender, now));\r\n      // check enough eth - goto next wave if needed\r\n        if (address(this).balance <= dividends) {\r\n                // nextWave();\r\n            dividends = address(this).balance;\r\n        }\r\n\r\n      // transfer dividends to investor\r\n        msg.sender.transfer(dividends);\r\n    }\r\n\r\n    function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\n        uint investment = msg.value;\r\n        uint receivedEther = msg.value;\r\n        require(investment >= minInvesment, \"investment must be >= minInvesment\");\r\n        require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\n        if (m_rgp.isActive()) {\r\n        // use Rapid Growth Protection if needed\r\n            uint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\r\n            rpgMaxInvest.requireNotZero();\r\n            investment = Math.min(investment, rpgMaxInvest);\r\n            assert(m_rgp.saveInvestment(investment));\r\n\r\n      } \r\n\r\n      // send excess of ether if needed\r\n        if (receivedEther > investment) {\r\n            uint excess = receivedEther - investment;\r\n            msg.sender.transfer(excess);\r\n            receivedEther = investment;\r\n      }\r\n\r\n      // commission\r\n        advertisingAddress.transfer(m_advertisingPercent.mul(receivedEther));\r\n        adminsAddress.transfer(m_adminsPercent.mul(receivedEther));\r\n        riskAddress.transfer(m_riskPercent.mul(receivedEther));\r\n\r\n        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n      // ref system works only once and only on first invest\r\n        if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\r\n            referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\r\n\r\n            m_referrals[msg.sender] = true;\r\n            // add referral bonus to referee's investments and pay investor's refer bonus\r\n            uint refBonus = refBonusPercent().mmul(investment);\r\n            // Investment increase 2.66%\r\n            uint refBonuss = refBonusPercentt().mmul(investment);\r\n            // ADD referee bonus to referee investment and maxinvestment\r\n            investment += refBonuss;\r\n            // PAY referer refer bonus directly\r\n            referrerAddr.transfer(refBonus);                                    \r\n            // emit LogNewReferral(msg.sender, referrerAddr, now, refBonus);\r\n        }\r\n\r\n      // automatic reinvest - prevent burning dividends\r\n        uint dividends = calcDividends(msg.sender);\r\n        if (senderIsInvestor && dividends.notZero()) {\r\n            investment += dividends;\r\n        }\r\n\r\n        if (senderIsInvestor) {\r\n                // update existing investor\r\n            assert(m_investors.addInvestment(msg.sender, investment, dividends));\r\n            assert(m_investors.setPaymentTime(msg.sender, now));\r\n        } else {\r\n            // create new investor\r\n            assert(m_investors.newInvestor(msg.sender, investment, now));\r\n        }\r\n\r\n        investmentsNumber++;\r\n    }\r\n\r\n    function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n        (uint investment, uint paymentTime,uint maxPayout,bool exit) = m_investors.investorInfo(investorAddr);\r\n        return InvestorsStorage.Investor(investment, paymentTime,maxPayout,exit);\r\n    }\r\n\r\n    function calcDividends(address investorAddr) internal view returns(uint dividends) {\r\n        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n\r\n      // safe gas if dividends will be 0,  \r\n        if (investor.investment.isZero()\r\n        // || now.sub(investor.paymentTime) < 1 minutes\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        // for prevent burning daily dividends if 24h did not pass - calculate it per 10 min interval\r\n        // if daily percent is X, then 10min percent = X / (24h / 10 min) = X / 144\r\n\r\n        // and we must to get numbers of 10 min interval after investor got payment:\r\n        // (now - investor.paymentTime) / 10min\r\n\r\n        // finaly calculate dividends = ((now - investor.paymentTime) / 10min) * (X * investor.investment)  / 144)\r\n        Percent.percent memory p = dailyPercent();\r\n        // dividends = ((now - investor.paymentTime) / 10 minutes) * (p.mmul(investor.investment) / 144);\r\n        dividends = ((now - investor.paymentTime) / 10 minutes) * (p.mmul(investor.investment) / 144);\r\n      //  dividends =  p.mmul(investor.investment);\r\n    }\r\n\r\n    function dailyPercent() internal view returns(Percent.percent memory p) {\r\n        uint balance = address(this).balance;\r\n\r\n      // (2) 1.66% if balance < 50 000 ETH\r\n    \r\n      // (1) 1% if >50 000 ETH\r\n\r\n        if (balance < 50000 ether) {\r\n            p = m_1_66_percent.toMemory();    // (2)\r\n        } else {\r\n            p = m_1_percent.toMemory();    // (1)\r\n        }\r\n    }\r\n\r\n    function refBonusPercent() internal view returns(Percent.percent memory p) {\r\n      //fix refer bonus payment to 6.66%\r\n      p = m_6_66_percent.toMemory();\r\n    }\r\n\r\nfunction refBonusPercentt() internal view returns(Percent.percent memory p) {\r\n      //fix refer bonus to 2.66%\r\n      p = m_2_66_percent.toMemory();\r\n    }\r\n\r\n    function nextWave() private {\r\n        m_investors = new InvestorsStorage();\r\n        investmentsNumber = 0;\r\n        waveStartup = now;\r\n        m_rgp.startAt(now);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"percent2\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refBonusPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent1\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doBonusPooling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRiskAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rapidGrowthProtectionmMaxInvestmentAtNow\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"riskPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"riskAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent3_33\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setBonusAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"name\":\"exit\",\"type\":\"bool\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"getBonusAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDisown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Myethsss","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ec43ab1bc4455f6972829baf3608b1e7958fb09c50cbe89724dbc402ea8216ac"}]}