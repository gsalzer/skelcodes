{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Governable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    address public governor;\r\n    bool public paused = false;\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    function setGovernor(address _gov) public onlyGovernor {\r\n        governor = _gov;\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyGovernor whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyGovernor whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract CardBase is Governable {\r\n\r\n\r\n    struct Card {\r\n        uint16 proto;\r\n        uint16 purity;\r\n    }\r\n\r\n    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\r\n        Card memory card = cards[id];\r\n        return (card.proto, card.purity);\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n    Card[] public cards;\r\n    \r\n}\r\n\r\n\r\n\r\ncontract CardProto is CardBase {\r\n\r\n    event NewProtoCard(\r\n        uint16 id, uint8 season, uint8 god, \r\n        Rarity rarity, uint8 mana, uint8 attack, \r\n        uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    );\r\n\r\n    struct Limit {\r\n        uint64 limit;\r\n        bool exists;\r\n    }\r\n\r\n    // limits for mythic cards\r\n    mapping(uint16 => Limit) public limits;\r\n\r\n    // can only set limits once\r\n    function setLimit(uint16 id, uint64 limit) public onlyGovernor {\r\n        Limit memory l = limits[id];\r\n        require(!l.exists);\r\n        limits[id] = Limit({\r\n            limit: limit,\r\n            exists: true\r\n        });\r\n    }\r\n\r\n    function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\r\n        Limit memory l = limits[id];\r\n        return (l.limit, l.exists);\r\n    }\r\n\r\n    // could make these arrays to save gas\r\n    // not really necessary - will be update a very limited no of times\r\n    mapping(uint8 => bool) public seasonTradable;\r\n    mapping(uint8 => bool) public seasonTradabilityLocked;\r\n    uint8 public currentSeason;\r\n\r\n    function makeTradeable(uint8 season) public onlyGovernor {\r\n        seasonTradable[season] = true;\r\n    }\r\n\r\n    function makeUntradable(uint8 season) public onlyGovernor {\r\n        require(!seasonTradabilityLocked[season]);\r\n        seasonTradable[season] = false;\r\n    }\r\n\r\n    function makePermanantlyTradable(uint8 season) public onlyGovernor {\r\n        require(seasonTradable[season]);\r\n        seasonTradabilityLocked[season] = true;\r\n    }\r\n\r\n    function isTradable(uint16 proto) public view returns (bool) {\r\n        return seasonTradable[protos[proto].season];\r\n    }\r\n\r\n    function nextSeason() public onlyGovernor {\r\n        //Seasons shouldn't go to 0 if there is more than the uint8 should hold, the governor should know this ¯\\_(ツ)_/¯ -M\r\n        require(currentSeason <= 255); \r\n\r\n        currentSeason++;\r\n        mythic.length = 0;\r\n        legendary.length = 0;\r\n        epic.length = 0;\r\n        rare.length = 0;\r\n        common.length = 0;\r\n    }\r\n\r\n    enum Rarity {\r\n        Common,\r\n        Rare,\r\n        Epic,\r\n        Legendary, \r\n        Mythic\r\n    }\r\n\r\n    uint8 constant SPELL = 1;\r\n    uint8 constant MINION = 2;\r\n    uint8 constant WEAPON = 3;\r\n    uint8 constant HERO = 4;\r\n\r\n    struct ProtoCard {\r\n        bool exists;\r\n        uint8 god;\r\n        uint8 season;\r\n        uint8 cardType;\r\n        Rarity rarity;\r\n        uint8 mana;\r\n        uint8 attack;\r\n        uint8 health;\r\n        uint8 tribe;\r\n    }\r\n\r\n    // there is a particular design decision driving this:\r\n    // need to be able to iterate over mythics only for card generation\r\n    // don't store 5 different arrays: have to use 2 ids\r\n    // better to bear this cost (2 bytes per proto card)\r\n    // rather than 1 byte per instance\r\n\r\n    uint16 public protoCount;\r\n    \r\n    mapping(uint16 => ProtoCard) protos;\r\n\r\n    uint16[] public mythic;\r\n    uint16[] public legendary;\r\n    uint16[] public epic;\r\n    uint16[] public rare;\r\n    uint16[] public common;\r\n\r\n    function addProtos(\r\n        uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks, uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        for (uint i = 0; i < externalIDs.length; i++) {\r\n\r\n            ProtoCard memory card = ProtoCard({\r\n                exists: true,\r\n                god: gods[i],\r\n                season: currentSeason,\r\n                cardType: cardTypes[i],\r\n                rarity: rarities[i],\r\n                mana: manas[i],\r\n                attack: attacks[i],\r\n                health: healths[i],\r\n                tribe: tribes[i]\r\n            });\r\n\r\n            _addProto(externalIDs[i], card, packable[i]);\r\n        }\r\n        \r\n    }\r\n\r\n    function addProto(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: cardType,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addWeapon(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: WEAPON,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: durability,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: SPELL,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: 0,\r\n            health: 0,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addMinion(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: MINION,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\r\n\r\n        require(!protos[externalID].exists);\r\n\r\n        card.exists = true;\r\n\r\n        protos[externalID] = card;\r\n\r\n        protoCount++;\r\n\r\n        emit NewProtoCard(\r\n            externalID, currentSeason, card.god, \r\n            card.rarity, card.mana, card.attack, \r\n            card.health, card.cardType, card.tribe, packable\r\n        );\r\n\r\n        if (packable) {\r\n            Rarity rarity = card.rarity;\r\n            if (rarity == Rarity.Common) {\r\n                common.push(externalID);\r\n            } else if (rarity == Rarity.Rare) {\r\n                rare.push(externalID);\r\n            } else if (rarity == Rarity.Epic) {\r\n                epic.push(externalID);\r\n            } else if (rarity == Rarity.Legendary) {\r\n                legendary.push(externalID);\r\n            } else if (rarity == Rarity.Mythic) {\r\n                mythic.push(externalID);\r\n            } else {\r\n                require(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getProto(uint16 id) public view returns(\r\n        bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) {\r\n        ProtoCard memory proto = protos[id];\r\n        return (\r\n            proto.exists,\r\n            proto.god,\r\n            proto.season,\r\n            proto.cardType,\r\n            proto.rarity,\r\n            proto.mana,\r\n            proto.attack,\r\n            proto.health,\r\n            proto.tribe\r\n        );\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\r\n        // modulo bias is fine - creates rarity tiers etc\r\n        // will obviously revert is there are no cards of that type: this is expected - should never happen\r\n        if (rarity == Rarity.Common) {\r\n            return common[random % common.length];\r\n        } else if (rarity == Rarity.Rare) {\r\n            return rare[random % rare.length];\r\n        } else if (rarity == Rarity.Epic) {\r\n            return epic[random % epic.length];\r\n        } else if (rarity == Rarity.Legendary) {\r\n            return legendary[random % legendary.length];\r\n        } else if (rarity == Rarity.Mythic) {\r\n            // make sure a mythic is available\r\n            uint16 id;\r\n            uint64 limit;\r\n            bool set;\r\n            for (uint i = 0; i < mythic.length; i++) {\r\n                id = mythic[(random + i) % mythic.length];\r\n                (limit, set) = getLimit(id);\r\n                if (set && limit > 0){\r\n                    return id;\r\n                }\r\n            }\r\n            // if not, they get a legendary :(\r\n            return legendary[random % legendary.length];\r\n        }\r\n        require(false);\r\n        return 0;\r\n    }\r\n\r\n    // can never adjust tradable cards\r\n    // each season gets a 'balancing beta'\r\n    // totally immutable: season, rarity\r\n    function replaceProto(\r\n        uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) public onlyGovernor {\r\n        ProtoCard memory pc = protos[index];\r\n        require(!seasonTradable[pc.season]);\r\n        protos[index] = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: pc.season,\r\n            cardType: cardType,\r\n            rarity: pc.rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MigrationInterface {\r\n\r\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\r\n\r\n    function getRandomCard(CardProto.Rarity rarity, uint16 random) public view returns (uint16);\r\n\r\n    function migrate(uint id) public;\r\n\r\n}\r\n\r\n\r\n\r\ncontract CardPackFour {\r\n\r\n    MigrationInterface public migration;\r\n    uint public creationBlock;\r\n\r\n    constructor(MigrationInterface _core) public payable {\r\n        migration = _core;\r\n        creationBlock = 5939061 + 2000; // set to creation block of first contracts + 8 hours for down time\r\n    }\r\n\r\n    event Referral(address indexed referrer, uint value, address purchaser);\r\n\r\n    /**\r\n    * purchase 'count' of this type of pack\r\n    */\r\n    function purchase(uint16 packCount, address referrer) public payable;\r\n\r\n    // store purity and shine as one number to save users gas\r\n    function _getPurity(uint16 randOne, uint16 randTwo) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000 + randTwo;\r\n        } else if (randOne >= 988) {\r\n            return 2000 + randTwo;\r\n        } else if (randOne >= 938) {\r\n            return 1000 + randTwo;\r\n        } else {\r\n            return randTwo;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    \r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Vault is Ownable { \r\n\r\n    function () public payable {\r\n\r\n    }\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function withdraw(uint amount) public onlyOwner {\r\n        require(address(this).balance >= amount);\r\n        owner.transfer(amount);\r\n    }\r\n\r\n    function withdrawAll() public onlyOwner {\r\n        withdraw(address(this).balance);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract CappedVault is Vault { \r\n\r\n    uint public limit;\r\n    uint withdrawn = 0;\r\n\r\n    constructor() public {\r\n        limit = 33333 ether;\r\n    }\r\n\r\n    function () public payable {\r\n        require(total() + msg.value <= limit);\r\n    }\r\n\r\n    function total() public view returns(uint) {\r\n        return getBalance() + withdrawn;\r\n    }\r\n\r\n    function withdraw(uint amount) public onlyOwner {\r\n        require(address(this).balance >= amount);\r\n        owner.transfer(amount);\r\n        withdrawn += amount;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract PresalePackFour is CardPackFour, Pausable {\r\n\r\n    CappedVault public vault;\r\n\r\n    Purchase[] public purchases;\r\n\r\n    function getPurchaseCount() public view returns (uint) {\r\n        return purchases.length;\r\n    }\r\n\r\n    struct Purchase {\r\n        uint16 current;\r\n        uint16 count;\r\n        address user;\r\n        uint randomness;\r\n        uint64 commit;\r\n    }\r\n\r\n    event PacksPurchased(uint indexed id, address indexed user, uint16 count);\r\n    event PackOpened(uint indexed id, uint16 startIndex, address indexed user, uint[] cardIDs);\r\n    event RandomnessReceived(uint indexed id, address indexed user, uint16 count, uint randomness);\r\n    event Recommit(uint indexed id);\r\n\r\n    constructor(MigrationInterface _core, CappedVault _vault) public payable CardPackFour(_core) {\r\n        vault = _vault;\r\n    }\r\n\r\n    function basePrice() public returns (uint);\r\n    function getCardDetails(uint16 packIndex, uint8 cardIndex, uint result) public view returns (uint16 proto, uint16 purity);\r\n    \r\n    function packSize() public view returns (uint8) {\r\n        return 5;\r\n    }\r\n\r\n    uint16 public perClaim = 15;\r\n\r\n    function setPacksPerClaim(uint16 _perClaim) public onlyOwner {\r\n        perClaim = _perClaim;\r\n    }\r\n\r\n    function packsPerClaim() public view returns (uint16) {\r\n        return perClaim;\r\n    }\r\n\r\n    // start in bytes, length in bytes\r\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\r\n        return (((1 << (length * 8)) - 1) & (num >> ((start * 8) - 1)));\r\n    }\r\n\r\n    function purchaseFor(address user, uint16 packCount, address referrer) whenNotPaused public payable {\r\n        _purchase(user, packCount, referrer);\r\n    }\r\n\r\n    function purchase(uint16 packCount, address referrer) whenNotPaused public payable {\r\n        _purchase(msg.sender, packCount, referrer);\r\n    }\r\n\r\n    function _purchase(address user, uint16 packCount, address referrer) internal {\r\n        require(packCount > 0);\r\n        require(referrer != user);\r\n\r\n        uint price = calculatePrice(basePrice(), packCount);\r\n        uint value = msg.value;\r\n\r\n        require(value >= price);\r\n\r\n        Purchase memory p = Purchase({\r\n            user: user,\r\n            count: packCount,\r\n            commit: uint64(block.number),\r\n            randomness: 0,\r\n            current: 0\r\n        });\r\n\r\n        uint id = purchases.push(p) - 1;\r\n\r\n        emit PacksPurchased(id, user, packCount);\r\n\r\n        if (referrer != address(0)) {\r\n            uint commission = price / 10;\r\n            referrer.transfer(commission);\r\n            price -= commission;\r\n            emit Referral(referrer, commission, user);\r\n        }\r\n        \r\n        address(vault).transfer(price);\r\n    }\r\n\r\n    // can recommit\r\n    // this gives you more chances\r\n    // if no-one else sends the callback (should never happen)\r\n    // still only get a random extra chance\r\n    function recommit(uint id) public {\r\n\r\n        Purchase storage p = purchases[id];\r\n\r\n        require(p.randomness == 0);\r\n\r\n        require(block.number >= p.commit + 256);\r\n\r\n        p.commit = uint64(block.number);\r\n\r\n        emit Recommit(id);\r\n    }\r\n\r\n    // can be called by anybody\r\n    // can miners withhold blocks --> not really\r\n    // giving up block reward for extra chance --> still really low\r\n    function callback(uint id) public {\r\n\r\n        Purchase storage p = purchases[id];\r\n\r\n        require(p.randomness == 0);\r\n\r\n        // must be within last 256 blocks, otherwise recommit\r\n        require(block.number - 256 < p.commit);\r\n\r\n        // can't callback on the original block\r\n        require(uint64(block.number) != p.commit);\r\n\r\n        bytes32 bhash = blockhash(p.commit);\r\n        // will get the same on every block\r\n        // only use properties which can't be altered by the user\r\n        uint random = uint(keccak256(abi.encodePacked(bhash, p.user, address(this), p.count)));\r\n\r\n        require(uint(bhash) != 0);\r\n\r\n        p.randomness = random;\r\n\r\n        emit RandomnessReceived(id, p.user, p.count, p.randomness);\r\n    }\r\n\r\n    function claim(uint id) public {\r\n        \r\n        Purchase storage p = purchases[id];\r\n\r\n        require(canClaim);\r\n\r\n        uint16 proto;\r\n        uint16 purity;\r\n        uint16 count = p.count;\r\n        uint result = p.randomness;\r\n        uint8 size = packSize();\r\n\r\n        address user = p.user;\r\n        uint16 current = p.current;\r\n\r\n        require(result != 0); // have to wait for the callback\r\n        // require(user == msg.sender); // not needed\r\n        require(count > 0);\r\n\r\n        uint[] memory ids = new uint[](size);\r\n\r\n        uint16 end = current + packsPerClaim() > count ? count : current + packsPerClaim();\r\n\r\n        require(end > current);\r\n\r\n        for (uint16 i = current; i < end; i++) {\r\n            for (uint8 j = 0; j < size; j++) {\r\n                (proto, purity) = getCardDetails(i, j, result);\r\n                ids[j] = migration.createCard(user, proto, purity);\r\n            }\r\n            emit PackOpened(id, (i * size), user, ids);\r\n        }\r\n        p.current += (end - current);\r\n    }\r\n\r\n    function predictPacks(uint id) external view returns (uint16[] protos, uint16[] purities) {\r\n\r\n        Purchase memory p = purchases[id];\r\n\r\n        uint16 proto;\r\n        uint16 purity;\r\n        uint16 count = p.count;\r\n        uint result = p.randomness;\r\n        uint8 size = packSize();\r\n\r\n        purities = new uint16[](size * count);\r\n        protos = new uint16[](size * count);\r\n\r\n        for (uint16 i = 0; i < count; i++) {\r\n            for (uint8 j = 0; j < size; j++) {\r\n                (proto, purity) = getCardDetails(i, j, result);\r\n                purities[(i * size) + j] = purity;\r\n                protos[(i * size) + j] = proto;\r\n            }\r\n        }\r\n        return (protos, purities);\r\n    }\r\n\r\n    function calculatePrice(uint base, uint16 packCount) public view returns (uint) {\r\n        // roughly 6k blocks per day\r\n        uint difference = block.number - creationBlock;\r\n        uint numDays = difference / 6000;\r\n        if (20 > numDays) {\r\n            return (base - (((20 - numDays) * base) / 100)) * packCount;\r\n        }\r\n        return base * packCount;\r\n    }\r\n\r\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else if (rand >= 998345) {\r\n            return CardProto.Rarity.Legendary;\r\n        } else if (rand >= 986765) {\r\n            return CardProto.Rarity.Epic;\r\n        } else if (rand >= 924890) {\r\n            return CardProto.Rarity.Rare;\r\n        } else {\r\n            return CardProto.Rarity.Common;\r\n        }\r\n    }\r\n\r\n    function _getRarePlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return CardProto.Rarity.Legendary;\r\n        } else if (rand >= 852940) {\r\n            return CardProto.Rarity.Epic;\r\n        } else {\r\n            return CardProto.Rarity.Rare;\r\n        } \r\n    }\r\n\r\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return CardProto.Rarity.Legendary;\r\n        } else {\r\n            return CardProto.Rarity.Epic;\r\n        }\r\n    }\r\n\r\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else {\r\n            return CardProto.Rarity.Legendary;\r\n        } \r\n    }\r\n\r\n    bool public canClaim = true;\r\n\r\n    function setCanClaim(bool claim) public onlyOwner {\r\n        canClaim = claim;\r\n    }\r\n\r\n    function getComponents(\r\n        uint16 i, uint8 j, uint rand\r\n    ) internal returns (\r\n        uint random, uint32 rarityRandom, uint16 purityOne, uint16 purityTwo, uint16 protoRandom\r\n    ) {\r\n        random = uint(keccak256(abi.encodePacked(i, rand, j)));\r\n        rarityRandom = uint32(extract(random, 4, 10) % 1000000);\r\n        purityOne = uint16(extract(random, 2, 4) % 1000);\r\n        purityTwo = uint16(extract(random, 2, 6) % 1000);\r\n        protoRandom = uint16(extract(random, 2, 8) % (2**16-1));\r\n        return (random, rarityRandom, purityOne, purityTwo, protoRandom);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract DiscountPack is Vault {\r\n\r\n    PresalePackFour private pack;\r\n    uint public basePrice;\r\n    uint public baseDiscount;\r\n\r\n    constructor(PresalePackFour packToDiscount) public {\r\n        pack = packToDiscount;\r\n\r\n        baseDiscount = uint(7) * pack.basePrice() / uint(100);\r\n        basePrice = pack.basePrice() - baseDiscount;\r\n    }\r\n\r\n    event PackDiscount(address purchaser, uint16 packs, uint discount);\r\n \r\n    function() public payable {}\r\n\r\n    function purchase(uint16 packs) public payable {\r\n        uint discountedPrice = packs * basePrice;\r\n        uint discount = packs * baseDiscount;\r\n        uint fullPrice = discountedPrice + discount;\r\n\r\n        require(msg.value >= discountedPrice, \"Not enough value for the desired pack count.\");\r\n        require(address(this).balance >= discount, \"This contract is out of front money.\");\r\n\r\n        // This should route the referral back to this contract\r\n        pack.purchaseFor.value(fullPrice)(msg.sender, packs, this);\r\n        emit PackDiscount(msg.sender, packs, discount);\r\n    }\r\n\r\n    function fraction(uint value, uint8 num, uint8 denom) internal pure returns (uint) {\r\n        return (uint(num) * value) / uint(denom);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packs\",\"type\":\"uint16\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"packToDiscount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"packs\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"discount\",\"type\":\"uint256\"}],\"name\":\"PackDiscount\",\"type\":\"event\"}]","ContractName":"DiscountPack","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000777f76d195795268388789343068e4fcd286919","Library":"","SwarmSource":"bzzr://8368529188e2b259245a9ba28c117c58f8be26698947ac123b50fce516f785e3"}]}