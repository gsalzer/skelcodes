{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n}\r\n\r\ncontract AccessControl {\r\n\r\n    event ContractUpgrade(address newContract);\r\n\r\n    address public addressDev;\r\n    address public addressFin;\r\n    address public addressOps;\r\n\r\n    modifier onlyDeveloper() {\r\n        require(msg.sender == addressDev);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFinance() {\r\n        require(msg.sender == addressFin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperation() {\r\n        require(msg.sender == addressOps);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTeamMembers() {\r\n        require(\r\n            msg.sender == addressDev ||\r\n            msg.sender == addressFin ||\r\n            msg.sender == addressOps\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setDeveloper(address _newDeveloper) external onlyDeveloper {\r\n        require(_newDeveloper != address(0));\r\n\r\n        addressDev = _newDeveloper;\r\n    }\r\n\r\n    function setFinance(address _newFinance) external onlyDeveloper {\r\n        require(_newFinance != address(0));\r\n\r\n        addressFin = _newFinance;\r\n    }\r\n\r\n    function setOperation(address _newOperation) external onlyDeveloper {\r\n        require(_newOperation != address(0));\r\n\r\n        addressOps = _newOperation;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// Basic mineral operations and counters, defines the constructor\r\ncontract MineralBase is AccessControl, Pausable {\r\n\r\n    bool public isPresale = true;\r\n\r\n    uint16 public discounts = 10000;\r\n    uint32 constant TOTAL_SUPPLY = 8888888;\r\n    uint32 public oresLeft;\r\n    uint32 gemsLeft;\r\n\r\n    // Price of ORE (50 pieces in presale, only 1 afterwards)\r\n    uint64 public orePrice = 1e16;\r\n\r\n    mapping(address => uint) internal ownerOreCount;\r\n\r\n    // Constructor\r\n    function MineralBase() public {\r\n\r\n        // Assign ownership to the creator\r\n        owner = msg.sender;\r\n        addressDev = owner;\r\n        addressFin = owner;\r\n        addressOps = owner;\r\n\r\n        // Initializing counters\r\n        oresLeft = TOTAL_SUPPLY;\r\n        gemsLeft = TOTAL_SUPPLY;\r\n\r\n        // Transfering ORES to the team\r\n        ownerOreCount[msg.sender] += oresLeft / 2;\r\n        oresLeft = oresLeft / 2;\r\n    }\r\n\r\n    function balanceOfOre(address _owner) public view returns (uint256 _balance) {\r\n        return ownerOreCount[_owner];\r\n    }\r\n\r\n    function sendOre(address _recipient, uint _amount) external payable {\r\n        require(balanceOfOre(msg.sender) >= _amount);\r\n        ownerOreCount[msg.sender] -= _amount;\r\n        ownerOreCount[_recipient] += _amount;\r\n    }\r\n\r\n    function endPresale() onlyTeamMembers external {\r\n        isPresale = false;\r\n        discounts = 0;\r\n    }\r\n}\r\n\r\n// The Factory holds the defined counts and provides an exclusive operations\r\ncontract MineralFactory is MineralBase {\r\n\r\n    uint8 constant MODULUS = 100;\r\n    uint8 constant CATEGORY_COUNT = 50;\r\n    uint64 constant EXTRACT_PRICE = 1e16;\r\n\r\n    uint32[] mineralCounts = [\r\n        8880, 9768, 10744, 11819, 13001,\r\n        19304, 21234, 23358, 25694, 28263,\r\n        28956, 31852, 35037, 38541, 42395,\r\n        43434, 47778, 52556, 57811, 63592,\r\n        65152, 71667, 78834, 86717, 95389,\r\n        97728, 107501, 118251, 130076, 143084,\r\n        146592, 161251, 177377, 195114, 214626,\r\n        219888, 241877, 266065, 292672, 321939,\r\n        329833, 362816, 399098, 439008, 482909,\r\n        494750, 544225, 598647, 658512, 724385];\r\n\r\n    uint64[] polishingPrice = [\r\n        200e16, 180e16, 160e16, 130e16, 100e16,\r\n        80e16, 60e16, 40e16, 20e16, 5e16];\r\n\r\n    mapping(address => uint) internal ownerGemCount;\r\n    mapping (uint256 => address) public gemIndexToOwner;\r\n    mapping (uint256 => address) public gemIndexToApproved;\r\n\r\n    Gemstone[] public gemstones;\r\n\r\n    struct Gemstone {\r\n        uint category;\r\n        string name;\r\n        uint256 colour;\r\n        uint64 extractionTime;\r\n        uint64 polishedTime;\r\n        uint256 price;\r\n    }\r\n\r\n    function _getRandomMineralId() private view returns (uint32) {\r\n        return uint32(uint256(keccak256(block.timestamp, block.difficulty))%oresLeft);\r\n    }\r\n\r\n     function _getPolishingPrice(uint _category) private view returns (uint) {\r\n        return polishingPrice[_category / 5];\r\n    }\r\n\r\n    function _generateRandomHash(string _str) private view returns (uint) {\r\n        uint rand = uint(keccak256(_str));\r\n        return rand % MODULUS;\r\n    }\r\n\r\n    function _getCategoryIdx(uint position) private view returns (uint8) {\r\n        uint32 tempSum = 0;\r\n        //Chosen category index, 255 for no category selected - when we are out of minerals\r\n        uint8 chosenIdx = 255;\r\n\r\n        for (uint8 i = 0; i < mineralCounts.length; i++) {\r\n            uint32 value = mineralCounts[i];\r\n            tempSum += value;\r\n            if (tempSum > position) {\r\n                //Mineral counts is 50, so this is safe to do\r\n                chosenIdx = i;\r\n                break;\r\n            }\r\n        }\r\n        return chosenIdx;\r\n    }\r\n\r\n    function extractOre(string _name) external payable returns (uint8, uint256) {\r\n        require(gemsLeft > 0);\r\n        require(msg.value >= EXTRACT_PRICE);\r\n        require(ownerOreCount[msg.sender] > 0);\r\n\r\n        uint32 randomNumber = _getRandomMineralId();\r\n        uint8 categoryIdx = _getCategoryIdx(randomNumber);\r\n\r\n        require(categoryIdx < CATEGORY_COUNT);\r\n\r\n        //Decrease the mineral count for the category\r\n        mineralCounts[categoryIdx] = mineralCounts[categoryIdx] - 1;\r\n        //Decrease total mineral count\r\n        gemsLeft = gemsLeft - 1;\r\n\r\n        Gemstone memory _stone = Gemstone({\r\n            category : categoryIdx,\r\n            name : _name,\r\n            colour : _generateRandomHash(_name),\r\n            extractionTime : uint64(block.timestamp),\r\n            polishedTime : 0,\r\n            price : 0\r\n        });\r\n\r\n        uint256 newStoneId = gemstones.push(_stone) - 1;\r\n\r\n        ownerOreCount[msg.sender]--;\r\n        ownerGemCount[msg.sender]++;\r\n        gemIndexToOwner[newStoneId] = msg.sender;\r\n\r\n        return (categoryIdx, _stone.colour);\r\n    }\r\n\r\n    function polishRoughStone(uint256 _gemId) external payable {\r\n        uint gainedWei = msg.value;\r\n        require(gemIndexToOwner[_gemId] == msg.sender);\r\n\r\n        Gemstone storage gem = gemstones[_gemId];\r\n        require(gem.polishedTime == 0);\r\n        require(gainedWei >= _getPolishingPrice(gem.category));\r\n\r\n        gem.polishedTime = uint64(block.timestamp);\r\n    }\r\n}\r\n\r\n// The Ownership contract makes sure the requirements of the NFT are met\r\ncontract MineralOwnership is MineralFactory, ERC721 {\r\n\r\n    string public constant name = \"CryptoMinerals\";\r\n    string public constant symbol = \"GEM\";\r\n\r\n    function _owns(address _claimant, uint256 _gemId) internal view returns (bool) {\r\n        return gemIndexToOwner[_gemId] == _claimant;\r\n    }\r\n\r\n    // Assigns ownership of a specific gem to an address.\r\n    function _transfer(address _from, address _to, uint256 _gemId) internal {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        ownerGemCount[_from]--;\r\n        ownerGemCount[_to]++;\r\n        gemIndexToOwner[_gemId] = _to;\r\n        Transfer(_from, _to, _gemId);\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _gemId) internal view returns (bool) {\r\n        return gemIndexToApproved[_gemId] == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _gemId, address _approved) internal {\r\n        gemIndexToApproved[_gemId] = _approved;\r\n    }\r\n\r\n    // Required for ERC-721 compliance\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownerGemCount[_owner];\r\n    }\r\n\r\n    // Required for ERC-721 compliance.\r\n    function transfer(address _to, uint256 _gemId) external whenNotPaused {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n\r\n        require(_owns(msg.sender, _gemId));\r\n        _transfer(msg.sender, _to, _gemId);\r\n    }\r\n\r\n    // Required for ERC-721 compliance.\r\n    function approve(address _to, uint256 _gemId) external whenNotPaused {\r\n        require(_owns(msg.sender, _gemId));\r\n        _approve(_gemId, _to);\r\n        Approval(msg.sender, _to, _gemId);\r\n    }\r\n\r\n    // Required for ERC-721 compliance.\r\n    function transferFrom(address _from, address _to, uint256 _gemId) external whenNotPaused {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n\r\n        require(_approvedFor(msg.sender, _gemId));\r\n        require(_owns(_from, _gemId));\r\n\r\n        _transfer(_from, _to, _gemId);\r\n    }\r\n\r\n    // Required for ERC-721 compliance.\r\n    function totalSupply() public view returns (uint) {\r\n        return TOTAL_SUPPLY - gemsLeft;\r\n    }\r\n\r\n    // Required for ERC-721 compliance.\r\n    function ownerOf(uint256 _gemId) external view returns (address owner) {\r\n        owner = gemIndexToOwner[_gemId];\r\n        require(owner != address(0));\r\n    }\r\n\r\n    // Required for ERC-721 compliance.\r\n    function implementsERC721() public view returns (bool implementsERC721) {\r\n        return true;\r\n    }\r\n\r\n    function gemsOfOwner(address _owner) external view returns(uint256[] ownerGems) {\r\n        uint256 gemCount = balanceOf(_owner);\r\n\r\n        if (gemCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](gemCount);\r\n            uint256 totalGems = totalSupply();\r\n            uint256 resultIndex = 0;\r\n            uint256 gemId;\r\n\r\n            for (gemId = 0; gemId <= totalGems; gemId++) {\r\n                if (gemIndexToOwner[gemId] == _owner) {\r\n                    result[resultIndex] = gemId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\n// This contract introduces functionalities for the basic trading\r\ncontract MineralMarket is MineralOwnership {\r\n\r\n    function buyOre() external payable {\r\n        require(msg.sender != address(0));\r\n        require(msg.value >= orePrice);\r\n        require(oresLeft > 0);\r\n\r\n        uint8 amount;\r\n        if (isPresale) {\r\n            require(discounts > 0);\r\n            amount = 50;\r\n            discounts--;\r\n        } else {\r\n            amount = 1;\r\n        }\r\n        oresLeft -= amount;\r\n        ownerOreCount[msg.sender] += amount;\r\n    }\r\n\r\n    function buyGem(uint _gemId) external payable {\r\n        uint gainedWei = msg.value;\r\n        require(msg.sender != address(0));\r\n        require(_gemId < gemstones.length);\r\n        require(gemIndexToOwner[_gemId] == address(this));\r\n\r\n        Gemstone storage gem = gemstones[_gemId];\r\n        require(gainedWei >= gem.price);\r\n\r\n        _transfer(address(this), msg.sender, _gemId);\r\n    }\r\n\r\n   function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyTeamMembers external {\r\n\r\n        require(gemsLeft > 0);\r\n        require(_categoryIdx < CATEGORY_COUNT);\r\n\r\n        //Decrease the mineral count for the category if not PROMO gem\r\n        if (_categoryIdx < CATEGORY_COUNT){\r\n             mineralCounts[_categoryIdx] = mineralCounts[_categoryIdx] - 1;\r\n        }\r\n\r\n        uint64 stamp = 0;\r\n        if (_polished) {\r\n            stamp = uint64(block.timestamp);\r\n        }\r\n\r\n        //Decrease counters\r\n        gemsLeft = gemsLeft - 1;\r\n        oresLeft--;\r\n\r\n        Gemstone memory _stone = Gemstone({\r\n            category : _categoryIdx,\r\n            name : _name,\r\n            colour : _colour,\r\n            extractionTime : uint64(block.timestamp),\r\n            polishedTime : stamp,\r\n            price : _price\r\n        });\r\n\r\n        uint256 newStoneId = gemstones.push(_stone) - 1;\r\n        ownerGemCount[address(this)]++;\r\n        gemIndexToOwner[newStoneId] = address(this);\r\n    }\r\n\r\n    function setPrice(uint256 _gemId, uint256 _price) onlyTeamMembers external {\r\n        require(_gemId < gemstones.length);\r\n        Gemstone storage gem = gemstones[_gemId];\r\n        gem.price = uint64(_price);\r\n    }\r\n\r\n    function setMyPrice(uint256 _gemId, uint256 _price) external {\r\n        require(_gemId < gemstones.length);\r\n        require(gemIndexToOwner[_gemId] == msg.sender);\r\n        Gemstone storage gem = gemstones[_gemId];\r\n        gem.price = uint64(_price);\r\n    }\r\n\r\n    function withdrawBalance() onlyTeamMembers external {\r\n        bool res = owner.send(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"buyOre\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressFin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gemIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressDev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_gemId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gemstones\",\"outputs\":[{\"name\":\"category\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"colour\",\"type\":\"uint256\"},{\"name\":\"extractionTime\",\"type\":\"uint64\"},{\"name\":\"polishedTime\",\"type\":\"uint64\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"implementsERC721\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_gemId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gemId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setMyPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gemId\",\"type\":\"uint256\"}],\"name\":\"polishRoughStone\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gemId\",\"type\":\"uint256\"}],\"name\":\"buyGem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfOre\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gemId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"extractOre\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oresLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendOre\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFinance\",\"type\":\"address\"}],\"name\":\"setFinance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_gemId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressOps\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"gemsOfOwner\",\"outputs\":[{\"name\":\"ownerGems\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gemIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_categoryIdx\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_colour\",\"type\":\"uint256\"},{\"name\":\"_polished\",\"type\":\"bool\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"mintGem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gemId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperation\",\"type\":\"address\"}],\"name\":\"setOperation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDeveloper\",\"type\":\"address\"}],\"name\":\"setDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"MineralMarket","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fe135e9a1c1b156eca169341f6d82fe4c87677920917000a5da0235922ce4fd4"}]}