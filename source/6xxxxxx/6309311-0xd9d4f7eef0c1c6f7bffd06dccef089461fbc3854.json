{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/Lava.sol\r\n\r\ncontract Lava {\r\n\r\n  using SafeMath for uint;\r\n\r\n  struct Rand {\r\n      address submitter;\r\n      uint value;\r\n  }\r\n\r\n  struct PredUnit {\r\n      address submitter;\r\n      uint value;\r\n  }\r\n\r\n  event receivedRand(address indexed _from, uint _value);\r\n  event receivedPred(address indexed _from, uint[] _window);\r\n  event requestedRand(address indexed _from, uint _value); // who requested a value and the value they received\r\n\r\n  uint MAXRAND = 100; // all rands, cyclical array\r\n  uint RANDPRICE = 857 wei;\r\n  uint RANDDEPOSIT = 1 wei;\r\n  uint PREDWAGER = 1 wei;\r\n  uint CURRIDX = 1; // current index in rands\r\n  uint nWinners = 0;\r\n  bool predPeat = false; // true if preders paid out >= once but can still win again if submitRand() has not been called since, else false\r\n\r\n  mapping(uint => Rand) private rands; // cyclical array\r\n  mapping(uint => bool) public randExists; // true if random number exists at index in cyclical array, else false\r\n  mapping(uint => PredUnit) public winners; // winning PredUnits\r\n  mapping(uint => PredUnit[]) public arrIdx2predUnitArr; // all predictions per each index in cyclical array\r\n  mapping(uint => bool) public arrIdx2lost; // true if rander at index lost to a preder, else false (default false)\r\n\r\n  constructor () public payable {\r\n    for (uint i=0; i<MAXRAND; i++) {\r\n      randExists[i] = false;\r\n      arrIdx2lost[i] = false;\r\n    }\r\n    rands[0] = Rand({submitter: address(this), value: 0});\r\n    arrIdx2lost[0] = true;\r\n  }\r\n\r\n  function submitRand(uint _value) public payable {\r\n    // √ create Rand struct\r\n    // √ add new Rand struct to rands\r\n    // √ register/ledger deposit\r\n    require(msg.value >= RANDDEPOSIT);\r\n    require(_value >= 1); // min support\r\n    require(_value <= 65536); // max support\r\n    Rand memory newRand = Rand({\r\n      submitter: msg.sender,\r\n      value: _value\r\n    });\r\n    if (!arrIdx2lost[CURRIDX]) { rands[CURRIDX].submitter.transfer(RANDDEPOSIT); } // return deposit rander being booted from cyclical array\r\n    rands[CURRIDX] = newRand;\r\n    arrIdx2lost[CURRIDX] = false;\r\n    randExists[CURRIDX] = true;\r\n    if (predPeat) { delete arrIdx2predUnitArr[CURRIDX]; } // reset array\r\n    predPeat = false;\r\n    CURRIDX = (CURRIDX.add(1)).mod(MAXRAND);\r\n    emit receivedRand(msg.sender, _value);\r\n  }\r\n\r\n  function submitPredWindow(uint[] _guess) public payable {\r\n    // √ create accessible PredUnits\r\n    // √ create accessible PredWindow\r\n    // √ add to preds\r\n    // √ register/ledger deposit\r\n    require(msg.value >= PREDWAGER.mul(_guess.length)); // 1 wager per prediction\r\n    require(_guess.length <= MAXRAND);\r\n    uint outputIdx = wrapSub(CURRIDX, 1, MAXRAND);\r\n    for (uint i=0; i<_guess.length; i++) {\r\n      PredUnit memory newUnit = PredUnit({\r\n        submitter: msg.sender,\r\n        value: _guess[i]\r\n      });\r\n      arrIdx2predUnitArr[(i+outputIdx) % MAXRAND].push(newUnit);\r\n    }\r\n    emit receivedPred(msg.sender, _guess);\r\n  }\r\n\r\n  function requestRand() public payable returns (uint) {\r\n    // √ register/ledger payment\r\n    // √ initiates auditing process (was there a correct prediction)\r\n    // √ sends payments to appropriate players (rander recency or preder relative wager)\r\n    // √ returns rand from timeline of most current timestamp\r\n    require(msg.value >= RANDPRICE);\r\n    uint outputIdx = wrapSub(CURRIDX, 1, MAXRAND);\r\n    uint idx;\r\n    uint val;\r\n    uint i;\r\n    uint reward;\r\n    if (predPeat) {\r\n        reward = RANDPRICE.div(nWinners);\r\n        for (i=0; i<nWinners; i++) { winners[i].submitter.transfer(reward); } // pay winning preders\r\n    } else {\r\n        nWinners = 0;\r\n        for (i=0; i<arrIdx2predUnitArr[outputIdx].length; i++) {\r\n          if (arrIdx2predUnitArr[outputIdx][i].value == rands[outputIdx].value) {\r\n            winners[i] = arrIdx2predUnitArr[outputIdx][i]; // enumerate winning PredUnits\r\n            nWinners++;\r\n          }\r\n        }\r\n        if (nWinners > 0) { // at least one preder wins\r\n          if (arrIdx2lost[outputIdx]) { reward = RANDPRICE.div(nWinners); } // if random number was predicted already or if constructor is rander\r\n          else { reward = PREDWAGER.add(RANDPRICE.div(nWinners)); } // if random number was not predicted already\r\n          for (i=0; i<nWinners; i++) { winners[i].submitter.transfer(reward); } // pay winning preders\r\n          winners[0].submitter.transfer(address(this).balance); // send pot to first correct preder\r\n          for (i=0; i<MAXRAND; i++) { arrIdx2lost[i] = true; } // all randers suffer\r\n          predPeat = true;\r\n        } else { // a single rander won, all recent randers get paid from earliest to last\r\n          idx = wrapSub(outputIdx, 0, MAXRAND);\r\n          rands[idx].submitter.transfer(RANDPRICE.div(4)); // extra winnings for the rander to submit the actual requested random number\r\n          for (i=0; i<MAXRAND; i++) {\r\n            idx = wrapSub(outputIdx, i, MAXRAND);\r\n            val = i.add(2);\r\n            if (randExists[idx]) { rands[idx].submitter.transfer(RANDPRICE.div(val.mul(val))); }\r\n          }\r\n        }\r\n    }\r\n    emit requestedRand(msg.sender, rands[outputIdx].value);\r\n    return rands[outputIdx].value;\r\n  }\r\n\r\n  function wrapSub(uint a, uint b, uint c) public pure returns(uint) { return uint(int(a) - int(b)).mod(c); } // computes (a-b)%c\r\n\r\n  function () public payable {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrIdx2lost\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"name\":\"submitter\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"submitRand\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_guess\",\"type\":\"uint256[]\"}],\"name\":\"submitPredWindow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrIdx2predUnitArr\",\"outputs\":[{\"name\":\"submitter\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"},{\"name\":\"c\",\"type\":\"uint256\"}],\"name\":\"wrapSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"receivedRand\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_window\",\"type\":\"uint256[]\"}],\"name\":\"receivedPred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"requestedRand\",\"type\":\"event\"}]","ContractName":"Lava","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f6267d5b9966b9e6712ffbbd87dc343617c5d74755e3bfeca0d4d2be169a5a97"}]}