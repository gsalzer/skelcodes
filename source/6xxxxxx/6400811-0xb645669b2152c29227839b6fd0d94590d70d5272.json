{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\n/*\r\n\r\n    Copyright 2018 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n    return _a >= _b ? _a : _b;\r\n  }\r\n\r\n  function min64(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n    return _a < _b ? _a : _b;\r\n  }\r\n\r\n  function max256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    return _a >= _b ? _a : _b;\r\n  }\r\n\r\n  function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    return _a < _b ? _a : _b;\r\n  }\r\n}\r\n\r\n// File: contracts/lib/Fraction.sol\r\n\r\n/**\r\n * @title Fraction\r\n * @author dYdX\r\n *\r\n * This library contains implementations for fraction structs.\r\n */\r\nlibrary Fraction {\r\n    struct Fraction128 {\r\n        uint128 num;\r\n        uint128 den;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/FractionMath.sol\r\n\r\n/**\r\n * @title FractionMath\r\n * @author dYdX\r\n *\r\n * This library contains safe math functions for manipulating fractions.\r\n */\r\nlibrary FractionMath {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint128;\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a + b\r\n     *\r\n     * @param  a  The first Fraction128\r\n     * @param  b  The second Fraction128\r\n     * @return    The result (sum)\r\n     */\r\n    function add(\r\n        Fraction.Fraction128 memory a,\r\n        Fraction.Fraction128 memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        uint256 left = a.num.mul(b.den);\r\n        uint256 right = b.num.mul(a.den);\r\n        uint256 denominator = a.den.mul(b.den);\r\n\r\n        // if left + right overflows, prevent overflow\r\n        if (left + right < left) {\r\n            left = left.div(2);\r\n            right = right.div(2);\r\n            denominator = denominator.div(2);\r\n        }\r\n\r\n        return bound(left.add(right), denominator);\r\n    }\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a - (1/2)^d\r\n     *\r\n     * @param  a  The Fraction128\r\n     * @param  d  The power of (1/2)\r\n     * @return    The result\r\n     */\r\n    function sub1Over(\r\n        Fraction.Fraction128 memory a,\r\n        uint128 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        if (a.den % d == 0) {\r\n            return bound(\r\n                a.num.sub(a.den.div(d)),\r\n                a.den\r\n            );\r\n        }\r\n        return bound(\r\n            a.num.mul(d).sub(a.den),\r\n            a.den.mul(d)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a / d\r\n     *\r\n     * @param  a  The first Fraction128\r\n     * @param  d  The divisor\r\n     * @return    The result (quotient)\r\n     */\r\n    function div(\r\n        Fraction.Fraction128 memory a,\r\n        uint128 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        if (a.num % d == 0) {\r\n            return bound(\r\n                a.num.div(d),\r\n                a.den\r\n            );\r\n        }\r\n        return bound(\r\n            a.num,\r\n            a.den.mul(d)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns a Fraction128 that is equal to a * b.\r\n     *\r\n     * @param  a  The first Fraction128\r\n     * @param  b  The second Fraction128\r\n     * @return    The result (product)\r\n     */\r\n    function mul(\r\n        Fraction.Fraction128 memory a,\r\n        Fraction.Fraction128 memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        return bound(\r\n            a.num.mul(b.num),\r\n            a.den.mul(b.den)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns a fraction from two uint256's. Fits them into uint128 if necessary.\r\n     *\r\n     * @param  num  The numerator\r\n     * @param  den  The denominator\r\n     * @return      The Fraction128 that matches num/den most closely\r\n     */\r\n    /* solium-disable-next-line security/no-assign-params */\r\n    function bound(\r\n        uint256 num,\r\n        uint256 den\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        uint256 max = num > den ? num : den;\r\n        uint256 first128Bits = (max >> 128);\r\n        if (first128Bits != 0) {\r\n            first128Bits += 1;\r\n            num /= first128Bits;\r\n            den /= first128Bits;\r\n        }\r\n\r\n        assert(den != 0); // coverage-enable-line\r\n        assert(den < 2**128);\r\n        assert(num < 2**128);\r\n\r\n        return Fraction.Fraction128({\r\n            num: uint128(num),\r\n            den: uint128(den)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns an in-memory copy of a Fraction128\r\n     *\r\n     * @param  a  The Fraction128 to copy\r\n     * @return    A copy of the Fraction128\r\n     */\r\n    function copy(\r\n        Fraction.Fraction128 memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        validate(a);\r\n        return Fraction.Fraction128({ num: a.num, den: a.den });\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Asserts that a Fraction128 is valid (i.e. the denominator is non-zero)\r\n     *\r\n     * @param  a  The Fraction128 to validate\r\n     */\r\n    function validate(\r\n        Fraction.Fraction128 memory a\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        assert(a.den != 0); // coverage-enable-line\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Exponent.sol\r\n\r\n/**\r\n * @title Exponent\r\n * @author dYdX\r\n *\r\n * This library contains an implementation for calculating e^X for arbitrary fraction X\r\n */\r\nlibrary Exponent {\r\n    using SafeMath for uint256;\r\n    using FractionMath for Fraction.Fraction128;\r\n\r\n    // ============ Constants ============\r\n\r\n    // 2**128 - 1\r\n    uint128 constant public MAX_NUMERATOR = 340282366920938463463374607431768211455;\r\n\r\n    // Number of precomputed integers, X, for E^((1/2)^X)\r\n    uint256 constant public MAX_PRECOMPUTE_PRECISION = 32;\r\n\r\n    // Number of precomputed integers, X, for E^X\r\n    uint256 constant public NUM_PRECOMPUTED_INTEGERS = 32;\r\n\r\n    // ============ Public Implementation Functions ============\r\n\r\n    /**\r\n     * Returns e^X for any fraction X\r\n     *\r\n     * @param  X                    The exponent\r\n     * @param  precomputePrecision  Accuracy of precomputed terms\r\n     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\r\n     * @return                      e^X\r\n     */\r\n    function exp(\r\n        Fraction.Fraction128 memory X,\r\n        uint256 precomputePrecision,\r\n        uint256 maclaurinPrecision\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        require(\r\n            precomputePrecision <= MAX_PRECOMPUTE_PRECISION,\r\n            \"Exponent#exp: Precompute precision over maximum\"\r\n        );\r\n\r\n        Fraction.Fraction128 memory Xcopy = X.copy();\r\n        if (Xcopy.num == 0) { // e^0 = 1\r\n            return ONE();\r\n        }\r\n\r\n        // get the integer value of the fraction (example: 9/4 is 2.25 so has integerValue of 2)\r\n        uint256 integerX = uint256(Xcopy.num).div(Xcopy.den);\r\n\r\n        // if X is less than 1, then just calculate X\r\n        if (integerX == 0) {\r\n            return expHybrid(Xcopy, precomputePrecision, maclaurinPrecision);\r\n        }\r\n\r\n        // get e^integerX\r\n        Fraction.Fraction128 memory expOfInt =\r\n            getPrecomputedEToThe(integerX % NUM_PRECOMPUTED_INTEGERS);\r\n        while (integerX >= NUM_PRECOMPUTED_INTEGERS) {\r\n            expOfInt = expOfInt.mul(getPrecomputedEToThe(NUM_PRECOMPUTED_INTEGERS));\r\n            integerX -= NUM_PRECOMPUTED_INTEGERS;\r\n        }\r\n\r\n        // multiply e^integerX by e^decimalX\r\n        Fraction.Fraction128 memory decimalX = Fraction.Fraction128({\r\n            num: Xcopy.num % Xcopy.den,\r\n            den: Xcopy.den\r\n        });\r\n        return expHybrid(decimalX, precomputePrecision, maclaurinPrecision).mul(expOfInt);\r\n    }\r\n\r\n    /**\r\n     * Returns e^X for any X < 1. Multiplies precomputed values to get close to the real value, then\r\n     * Maclaurin Series approximation to reduce error.\r\n     *\r\n     * @param  X                    Exponent\r\n     * @param  precomputePrecision  Accuracy of precomputed terms\r\n     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\r\n     * @return                      e^X\r\n     */\r\n    function expHybrid(\r\n        Fraction.Fraction128 memory X,\r\n        uint256 precomputePrecision,\r\n        uint256 maclaurinPrecision\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        assert(precomputePrecision <= MAX_PRECOMPUTE_PRECISION);\r\n        assert(X.num < X.den);\r\n        // will also throw if precomputePrecision is larger than the array length in getDenominator\r\n\r\n        Fraction.Fraction128 memory Xtemp = X.copy();\r\n        if (Xtemp.num == 0) { // e^0 = 1\r\n            return ONE();\r\n        }\r\n\r\n        Fraction.Fraction128 memory result = ONE();\r\n\r\n        uint256 d = 1; // 2^i\r\n        for (uint256 i = 1; i <= precomputePrecision; i++) {\r\n            d *= 2;\r\n\r\n            // if Fraction > 1/d, subtract 1/d and multiply result by precomputed e^(1/d)\r\n            if (d.mul(Xtemp.num) >= Xtemp.den) {\r\n                Xtemp = Xtemp.sub1Over(uint128(d));\r\n                result = result.mul(getPrecomputedEToTheHalfToThe(i));\r\n            }\r\n        }\r\n        return result.mul(expMaclaurin(Xtemp, maclaurinPrecision));\r\n    }\r\n\r\n    /**\r\n     * Returns e^X for any X, using Maclaurin Series approximation\r\n     *\r\n     * e^X = SUM(X^n / n!) for n >= 0\r\n     * e^X = 1 + X/1! + X^2/2! + X^3/3! ...\r\n     *\r\n     * @param  X           Exponent\r\n     * @param  precision   Accuracy of Maclaurin terms\r\n     * @return             e^X\r\n     */\r\n    function expMaclaurin(\r\n        Fraction.Fraction128 memory X,\r\n        uint256 precision\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        Fraction.Fraction128 memory Xcopy = X.copy();\r\n        if (Xcopy.num == 0) { // e^0 = 1\r\n            return ONE();\r\n        }\r\n\r\n        Fraction.Fraction128 memory result = ONE();\r\n        Fraction.Fraction128 memory Xtemp = ONE();\r\n        for (uint256 i = 1; i <= precision; i++) {\r\n            Xtemp = Xtemp.mul(Xcopy.div(uint128(i)));\r\n            result = result.add(Xtemp);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a fraction roughly equaling E^((1/2)^x) for integer x\r\n     */\r\n    function getPrecomputedEToTheHalfToThe(\r\n        uint256 x\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        assert(x <= MAX_PRECOMPUTE_PRECISION);\r\n\r\n        uint128 denominator = [\r\n            125182886983370532117250726298150828301,\r\n            206391688497133195273760705512282642279,\r\n            265012173823417992016237332255925138361,\r\n            300298134811882980317033350418940119802,\r\n            319665700530617779809390163992561606014,\r\n            329812979126047300897653247035862915816,\r\n            335006777809430963166468914297166288162,\r\n            337634268532609249517744113622081347950,\r\n            338955731696479810470146282672867036734,\r\n            339618401537809365075354109784799900812,\r\n            339950222128463181389559457827561204959,\r\n            340116253979683015278260491021941090650,\r\n            340199300311581465057079429423749235412,\r\n            340240831081268226777032180141478221816,\r\n            340261598367316729254995498374473399540,\r\n            340271982485676106947851156443492415142,\r\n            340277174663693808406010255284800906112,\r\n            340279770782412691177936847400746725466,\r\n            340281068849199706686796915841848278311,\r\n            340281717884450116236033378667952410919,\r\n            340282042402539547492367191008339680733,\r\n            340282204661700319870089970029119685699,\r\n            340282285791309720262481214385569134454,\r\n            340282326356121674011576912006427792656,\r\n            340282346638529464274601981200276914173,\r\n            340282356779733812753265346086924801364,\r\n            340282361850336100329388676752133324799,\r\n            340282364385637272451648746721404212564,\r\n            340282365653287865596328444437856608255,\r\n            340282366287113163939555716675618384724,\r\n            340282366604025813553891209601455838559,\r\n            340282366762482138471739420386372790954,\r\n            340282366841710300958333641874363209044\r\n        ][x];\r\n        return Fraction.Fraction128({\r\n            num: MAX_NUMERATOR,\r\n            den: denominator\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns a fraction roughly equaling E^(x) for integer x\r\n     */\r\n    function getPrecomputedEToThe(\r\n        uint256 x\r\n    )\r\n        internal\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        assert(x <= NUM_PRECOMPUTED_INTEGERS);\r\n\r\n        uint128 denominator = [\r\n            340282366920938463463374607431768211455,\r\n            125182886983370532117250726298150828301,\r\n            46052210507670172419625860892627118820,\r\n            16941661466271327126146327822211253888,\r\n            6232488952727653950957829210887653621,\r\n            2292804553036637136093891217529878878,\r\n            843475657686456657683449904934172134,\r\n            310297353591408453462393329342695980,\r\n            114152017036184782947077973323212575,\r\n            41994180235864621538772677139808695,\r\n            15448795557622704876497742989562086,\r\n            5683294276510101335127414470015662,\r\n            2090767122455392675095471286328463,\r\n            769150240628514374138961856925097,\r\n            282954560699298259527814398449860,\r\n            104093165666968799599694528310221,\r\n            38293735615330848145349245349513,\r\n            14087478058534870382224480725096,\r\n            5182493555688763339001418388912,\r\n            1906532833141383353974257736699,\r\n            701374233231058797338605168652,\r\n            258021160973090761055471434334,\r\n            94920680509187392077350434438,\r\n            34919366901332874995585576427,\r\n            12846117181722897538509298435,\r\n            4725822410035083116489797150,\r\n            1738532907279185132707372378,\r\n            639570514388029575350057932,\r\n            235284843422800231081973821,\r\n            86556456714490055457751527,\r\n            31842340925906738090071268,\r\n            11714142585413118080082437,\r\n            4309392228124372433711936\r\n        ][x];\r\n        return Fraction.Fraction128({\r\n            num: MAX_NUMERATOR,\r\n            den: denominator\r\n        });\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    function ONE()\r\n        private\r\n        pure\r\n        returns (Fraction.Fraction128 memory)\r\n    {\r\n        return Fraction.Fraction128({ num: 1, den: 1 });\r\n    }\r\n}\r\n\r\n// File: contracts/lib/MathHelpers.sol\r\n\r\n/**\r\n * @title MathHelpers\r\n * @author dYdX\r\n *\r\n * This library helps with common math functions in Solidity\r\n */\r\nlibrary MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              target * numerator / denominator\r\n     */\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return numerator.mul(target).div(denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              Rounded-up result of target * numerator / denominator\r\n     */\r\n    function getPartialAmountRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return divisionRoundedUp(numerator.mul(target), denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates division given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator.\r\n     * @param  denominator  Denominator.\r\n     * @return              Rounded-up result of numerator / denominator\r\n     */\r\n    function divisionRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(denominator != 0); // coverage-enable-line\r\n        if (numerator == 0) {\r\n            return 0;\r\n        }\r\n        return numerator.sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint256(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint32(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        return 2 ** 32 - 1;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\r\n     *\r\n     * @param  n  The uint256 to get the number of bits in\r\n     * @return    The number of bits in n\r\n     */\r\n    function getNumBits(\r\n        uint256 n\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 first = 0;\r\n        uint256 last = 256;\r\n        while (first < last) {\r\n            uint256 check = (first + last) / 2;\r\n            if ((n >> check) == 0) {\r\n                last = check;\r\n            } else {\r\n                first = check + 1;\r\n            }\r\n        }\r\n        assert(first <= 256);\r\n        return first;\r\n    }\r\n}\r\n\r\n// File: contracts/margin/impl/InterestImpl.sol\r\n\r\n/**\r\n * @title InterestImpl\r\n * @author dYdX\r\n *\r\n * A library that calculates continuously compounded interest for principal, time period, and\r\n * interest rate.\r\n */\r\nlibrary InterestImpl {\r\n    using SafeMath for uint256;\r\n    using FractionMath for Fraction.Fraction128;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant DEFAULT_PRECOMPUTE_PRECISION = 11;\r\n\r\n    uint256 constant DEFAULT_MACLAURIN_PRECISION = 5;\r\n\r\n    uint256 constant MAXIMUM_EXPONENT = 80;\r\n\r\n    uint128 constant E_TO_MAXIUMUM_EXPONENT = 55406223843935100525711733958316613;\r\n\r\n    // ============ Public Implementation Functions ============\r\n\r\n    /**\r\n     * Returns total tokens owed after accruing interest. Continuously compounding and accurate to\r\n     * roughly 10^18 decimal places. Continuously compounding interest follows the formula:\r\n     * I = P * e^(R*T)\r\n     *\r\n     * @param  principal           Principal of the interest calculation\r\n     * @param  interestRate        Annual nominal interest percentage times 10**6.\r\n     *                             (example: 5% = 5e6)\r\n     * @param  secondsOfInterest   Number of seconds that interest has been accruing\r\n     * @return                     Total amount of tokens owed. Greater than tokenAmount.\r\n     */\r\n    function getCompoundedInterest(\r\n        uint256 principal,\r\n        uint256 interestRate,\r\n        uint256 secondsOfInterest\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numerator = interestRate.mul(secondsOfInterest);\r\n        uint128 denominator = (10**8) * (365 * 1 days);\r\n\r\n        // interestRate and secondsOfInterest should both be uint32\r\n        assert(numerator < 2**128);\r\n\r\n        // fraction representing (Rate * Time)\r\n        Fraction.Fraction128 memory rt = Fraction.Fraction128({\r\n            num: uint128(numerator),\r\n            den: denominator\r\n        });\r\n\r\n        // calculate e^(RT)\r\n        Fraction.Fraction128 memory eToRT;\r\n        if (numerator.div(denominator) >= MAXIMUM_EXPONENT) {\r\n            // degenerate case: cap calculation\r\n            eToRT = Fraction.Fraction128({\r\n                num: E_TO_MAXIUMUM_EXPONENT,\r\n                den: 1\r\n            });\r\n        } else {\r\n            // normal case: calculate e^(RT)\r\n            eToRT = Exponent.exp(\r\n                rt,\r\n                DEFAULT_PRECOMPUTE_PRECISION,\r\n                DEFAULT_MACLAURIN_PRECISION\r\n            );\r\n        }\r\n\r\n        // e^X for positive X should be greater-than or equal to 1\r\n        assert(eToRT.num >= eToRT.den);\r\n\r\n        return safeMultiplyUint256ByFraction(principal, eToRT);\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Returns n * f, trying to prevent overflow as much as possible. Assumes that the numerator\r\n     * and denominator of f are less than 2**128.\r\n     */\r\n    function safeMultiplyUint256ByFraction(\r\n        uint256 n,\r\n        Fraction.Fraction128 memory f\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 term1 = n.div(2 ** 128); // first 128 bits\r\n        uint256 term2 = n % (2 ** 128); // second 128 bits\r\n\r\n        // uncommon scenario, requires n >= 2**128. calculates term1 = term1 * f\r\n        if (term1 > 0) {\r\n            term1 = term1.mul(f.num);\r\n            uint256 numBits = MathHelpers.getNumBits(term1);\r\n\r\n            // reduce rounding error by shifting all the way to the left before dividing\r\n            term1 = MathHelpers.divisionRoundedUp(\r\n                term1 << (uint256(256).sub(numBits)),\r\n                f.den);\r\n\r\n            // continue shifting or reduce shifting to get the right number\r\n            if (numBits > 128) {\r\n                term1 = term1 << (numBits.sub(128));\r\n            } else if (numBits < 128) {\r\n                term1 = term1 >> (uint256(128).sub(numBits));\r\n            }\r\n        }\r\n\r\n        // calculates term2 = term2 * f\r\n        term2 = MathHelpers.getPartialAmountRoundedUp(\r\n            f.num,\r\n            f.den,\r\n            term2\r\n        );\r\n\r\n        return term1.add(term2);\r\n    }\r\n}\r\n\r\n// File: contracts/margin/impl/MarginState.sol\r\n\r\n/**\r\n * @title MarginState\r\n * @author dYdX\r\n *\r\n * Contains state for the Margin contract. Also used by libraries that implement Margin functions.\r\n */\r\nlibrary MarginState {\r\n    struct State {\r\n        // Address of the Vault contract\r\n        address VAULT;\r\n\r\n        // Address of the TokenProxy contract\r\n        address TOKEN_PROXY;\r\n\r\n        // Mapping from loanHash -> amount, which stores the amount of a loan which has\r\n        // already been filled.\r\n        mapping (bytes32 => uint256) loanFills;\r\n\r\n        // Mapping from loanHash -> amount, which stores the amount of a loan which has\r\n        // already been canceled.\r\n        mapping (bytes32 => uint256) loanCancels;\r\n\r\n        // Mapping from positionId -> Position, which stores all the open margin positions.\r\n        mapping (bytes32 => MarginCommon.Position) positions;\r\n\r\n        // Mapping from positionId -> bool, which stores whether the position has previously been\r\n        // open, but is now closed.\r\n        mapping (bytes32 => bool) closedPositions;\r\n\r\n        // Mapping from positionId -> uint256, which stores the total amount of owedToken that has\r\n        // ever been repaid to the lender for each position. Does not reset.\r\n        mapping (bytes32 => uint256) totalOwedTokenRepaidToLender;\r\n    }\r\n}\r\n\r\n// File: contracts/margin/interfaces/lender/LoanOwner.sol\r\n\r\n/**\r\n * @title LoanOwner\r\n * @author dYdX\r\n *\r\n * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\r\n *\r\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\r\n *       to these functions\r\n */\r\ninterface LoanOwner {\r\n\r\n    // ============ Public Interface functions ============\r\n\r\n    /**\r\n     * Function a contract must implement in order to receive ownership of a loan sell via the\r\n     * transferLoan function or the atomic-assign to the \"owner\" field in a loan offering.\r\n     *\r\n     * @param  from        Address of the previous owner\r\n     * @param  positionId  Unique ID of the position\r\n     * @return             This address to keep ownership, a different address to pass-on ownership\r\n     */\r\n    function receiveLoanOwnership(\r\n        address from,\r\n        bytes32 positionId\r\n    )\r\n        external\r\n        /* onlyMargin */\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/margin/interfaces/owner/PositionOwner.sol\r\n\r\n/**\r\n * @title PositionOwner\r\n * @author dYdX\r\n *\r\n * Interface that smart contracts must implement in order to own position on behalf of other\r\n * accounts\r\n *\r\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\r\n *       to these functions\r\n */\r\ninterface PositionOwner {\r\n\r\n    // ============ Public Interface functions ============\r\n\r\n    /**\r\n     * Function a contract must implement in order to receive ownership of a position via the\r\n     * transferPosition function or the atomic-assign to the \"owner\" field when opening a position.\r\n     *\r\n     * @param  from        Address of the previous owner\r\n     * @param  positionId  Unique ID of the position\r\n     * @return             This address to keep ownership, a different address to pass-on ownership\r\n     */\r\n    function receivePositionOwnership(\r\n        address from,\r\n        bytes32 positionId\r\n    )\r\n        external\r\n        /* onlyMargin */\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/margin/impl/TransferInternal.sol\r\n\r\n/**\r\n * @title TransferInternal\r\n * @author dYdX\r\n *\r\n * This library contains the implementation for transferring ownership of loans and positions.\r\n */\r\nlibrary TransferInternal {\r\n\r\n    // ============ Events ============\r\n\r\n    /**\r\n     * Ownership of a loan was transferred to a new address\r\n     */\r\n    event LoanTransferred(\r\n        bytes32 indexed positionId,\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n\r\n    /**\r\n     * Ownership of a postion was transferred to a new address\r\n     */\r\n    event PositionTransferred(\r\n        bytes32 indexed positionId,\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n\r\n    // ============ Internal Implementation Functions ============\r\n\r\n    /**\r\n     * Returns either the address of the new loan owner, or the address to which they wish to\r\n     * pass ownership of the loan. This function does not actually set the state of the position\r\n     *\r\n     * @param  positionId  The Unique ID of the position\r\n     * @param  oldOwner    The previous owner of the loan\r\n     * @param  newOwner    The intended owner of the loan\r\n     * @return             The address that the intended owner wishes to assign the loan to (may be\r\n     *                     the same as the intended owner).\r\n     */\r\n    function grantLoanOwnership(\r\n        bytes32 positionId,\r\n        address oldOwner,\r\n        address newOwner\r\n    )\r\n        internal\r\n        returns (address)\r\n    {\r\n        // log event except upon position creation\r\n        if (oldOwner != address(0)) {\r\n            emit LoanTransferred(positionId, oldOwner, newOwner);\r\n        }\r\n\r\n        if (AddressUtils.isContract(newOwner)) {\r\n            address nextOwner =\r\n                LoanOwner(newOwner).receiveLoanOwnership(oldOwner, positionId);\r\n            if (nextOwner != newOwner) {\r\n                return grantLoanOwnership(positionId, newOwner, nextOwner);\r\n            }\r\n        }\r\n\r\n        require(\r\n            newOwner != address(0),\r\n            \"TransferInternal#grantLoanOwnership: New owner did not consent to owning loan\"\r\n        );\r\n\r\n        return newOwner;\r\n    }\r\n\r\n    /**\r\n     * Returns either the address of the new position owner, or the address to which they wish to\r\n     * pass ownership of the position. This function does not actually set the state of the position\r\n     *\r\n     * @param  positionId  The Unique ID of the position\r\n     * @param  oldOwner    The previous owner of the position\r\n     * @param  newOwner    The intended owner of the position\r\n     * @return             The address that the intended owner wishes to assign the position to (may\r\n     *                     be the same as the intended owner).\r\n     */\r\n    function grantPositionOwnership(\r\n        bytes32 positionId,\r\n        address oldOwner,\r\n        address newOwner\r\n    )\r\n        internal\r\n        returns (address)\r\n    {\r\n        // log event except upon position creation\r\n        if (oldOwner != address(0)) {\r\n            emit PositionTransferred(positionId, oldOwner, newOwner);\r\n        }\r\n\r\n        if (AddressUtils.isContract(newOwner)) {\r\n            address nextOwner =\r\n                PositionOwner(newOwner).receivePositionOwnership(oldOwner, positionId);\r\n            if (nextOwner != newOwner) {\r\n                return grantPositionOwnership(positionId, newOwner, nextOwner);\r\n            }\r\n        }\r\n\r\n        require(\r\n            newOwner != address(0),\r\n            \"TransferInternal#grantPositionOwnership: New owner did not consent to owning position\"\r\n        );\r\n\r\n        return newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/lib/AccessControlledBase.sol\r\n\r\n/**\r\n * @title AccessControlledBase\r\n * @author dYdX\r\n *\r\n * Base functionality for access control. Requires an implementation to\r\n * provide a way to grant and optionally revoke access\r\n */\r\ncontract AccessControlledBase {\r\n    // ============ State Variables ============\r\n\r\n    mapping (address => bool) public authorized;\r\n\r\n    // ============ Events ============\r\n\r\n    event AccessGranted(\r\n        address who\r\n    );\r\n\r\n    event AccessRevoked(\r\n        address who\r\n    );\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier requiresAuthorization() {\r\n        require(\r\n            authorized[msg.sender],\r\n            \"AccessControlledBase#requiresAuthorization: Sender not authorized\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/StaticAccessControlled.sol\r\n\r\n/**\r\n * @title StaticAccessControlled\r\n * @author dYdX\r\n *\r\n * Allows for functions to be access controled\r\n * Permissions cannot be changed after a grace period\r\n */\r\ncontract StaticAccessControlled is AccessControlledBase, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ State Variables ============\r\n\r\n    // Timestamp after which no additional access can be granted\r\n    uint256 public GRACE_PERIOD_EXPIRATION;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        uint256 gracePeriod\r\n    )\r\n        public\r\n        Ownable()\r\n    {\r\n        GRACE_PERIOD_EXPIRATION = block.timestamp.add(gracePeriod);\r\n    }\r\n\r\n    // ============ Owner-Only State-Changing Functions ============\r\n\r\n    function grantAccess(\r\n        address who\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            block.timestamp < GRACE_PERIOD_EXPIRATION,\r\n            \"StaticAccessControlled#grantAccess: Cannot grant access after grace period\"\r\n        );\r\n\r\n        emit AccessGranted(who);\r\n        authorized[who] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/GeneralERC20.sol\r\n\r\n/**\r\n * @title GeneralERC20\r\n * @author dYdX\r\n *\r\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\r\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\r\n * transfer(), transferFrom(), or approve().\r\n */\r\ninterface GeneralERC20 {\r\n    function totalSupply(\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/lib/TokenInteract.sol\r\n\r\n/**\r\n * @title TokenInteract\r\n * @author dYdX\r\n *\r\n * This library contains functions for interacting with ERC20 tokens\r\n */\r\nlibrary TokenInteract {\r\n    function balanceOf(\r\n        address token,\r\n        address owner\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).balanceOf(owner);\r\n    }\r\n\r\n    function allowance(\r\n        address token,\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).allowance(owner, spender);\r\n    }\r\n\r\n    function approve(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        GeneralERC20(token).approve(spender, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#approve: Approval failed\"\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        address from = address(this);\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transfer(to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transfer: Transfer failed\"\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transferFrom(from, to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transferFrom: TransferFrom failed\"\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\r\n     * function returned 0 bytes or 32 bytes that are not all-zero.\r\n     */\r\n    function checkSuccess(\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 returnValue = 0;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            // check number of bytes returned from last function call\r\n            switch returndatasize\r\n\r\n            // no bytes returned: assume success\r\n            case 0x0 {\r\n                returnValue := 1\r\n            }\r\n\r\n            // 32 bytes returned: check if non-zero\r\n            case 0x20 {\r\n                // copy 32 bytes into scratch space\r\n                returndatacopy(0x0, 0x0, 0x20)\r\n\r\n                // load those bytes into returnValue\r\n                returnValue := mload(0x0)\r\n            }\r\n\r\n            // not sure what was returned: dont mark as success\r\n            default { }\r\n        }\r\n\r\n        return returnValue != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/margin/TokenProxy.sol\r\n\r\n/**\r\n * @title TokenProxy\r\n * @author dYdX\r\n *\r\n * Used to transfer tokens between addresses which have set allowance on this contract.\r\n */\r\ncontract TokenProxy is StaticAccessControlled {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        uint256 gracePeriod\r\n    )\r\n        public\r\n        StaticAccessControlled(gracePeriod)\r\n    {}\r\n\r\n    // ============ Authorized-Only State Changing Functions ============\r\n\r\n    /**\r\n     * Transfers tokens from an address (that has set allowance on the proxy) to another address.\r\n     *\r\n     * @param  token  The address of the ERC20 token\r\n     * @param  from   The address to transfer token from\r\n     * @param  to     The address to transfer tokens to\r\n     * @param  value  The number of tokens to transfer\r\n     */\r\n    function transferTokens(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external\r\n        requiresAuthorization\r\n    {\r\n        TokenInteract.transferFrom(\r\n            token,\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n    }\r\n\r\n    // ============ Public Constant Functions ============\r\n\r\n    /**\r\n     * Getter function to get the amount of token that the proxy is able to move for a particular\r\n     * address. The minimum of 1) the balance of that address and 2) the allowance given to proxy.\r\n     *\r\n     * @param  who    The owner of the tokens\r\n     * @param  token  The address of the ERC20 token\r\n     * @return        The number of tokens able to be moved by the proxy from the address specified\r\n     */\r\n    function available(\r\n        address who,\r\n        address token\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return Math.min256(\r\n            TokenInteract.allowance(token, who, address(this)),\r\n            TokenInteract.balanceOf(token, who)\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/margin/Vault.sol\r\n\r\n/**\r\n * @title Vault\r\n * @author dYdX\r\n *\r\n * Holds and transfers tokens in vaults denominated by id\r\n *\r\n * Vault only supports ERC20 tokens, and will not accept any tokens that require\r\n * a tokenFallback or equivalent function (See ERC223, ERC777, etc.)\r\n */\r\ncontract Vault is StaticAccessControlled\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Events ============\r\n\r\n    event ExcessTokensWithdrawn(\r\n        address indexed token,\r\n        address indexed to,\r\n        address caller\r\n    );\r\n\r\n    // ============ State Variables ============\r\n\r\n    // Address of the TokenProxy contract. Used for moving tokens.\r\n    address public TOKEN_PROXY;\r\n\r\n    // Map from vault ID to map from token address to amount of that token attributed to the\r\n    // particular vault ID.\r\n    mapping (bytes32 => mapping (address => uint256)) public balances;\r\n\r\n    // Map from token address to total amount of that token attributed to some account.\r\n    mapping (address => uint256) public totalBalances;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address proxy,\r\n        uint256 gracePeriod\r\n    )\r\n        public\r\n        StaticAccessControlled(gracePeriod)\r\n    {\r\n        TOKEN_PROXY = proxy;\r\n    }\r\n\r\n    // ============ Owner-Only State-Changing Functions ============\r\n\r\n    /**\r\n     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\r\n     * including (but not limited-to) token airdrops. Any tokens moved to the vault by TOKEN_PROXY\r\n     * will be accounted for and will not be withdrawable by this function.\r\n     *\r\n     * @param  token  ERC20 token address\r\n     * @param  to     Address to transfer tokens to\r\n     * @return        Amount of tokens withdrawn\r\n     */\r\n    function withdrawExcessToken(\r\n        address token,\r\n        address to\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        uint256 actualBalance = TokenInteract.balanceOf(token, address(this));\r\n        uint256 accountedBalance = totalBalances[token];\r\n        uint256 withdrawableBalance = actualBalance.sub(accountedBalance);\r\n\r\n        require(\r\n            withdrawableBalance != 0,\r\n            \"Vault#withdrawExcessToken: Withdrawable token amount must be non-zero\"\r\n        );\r\n\r\n        TokenInteract.transfer(token, to, withdrawableBalance);\r\n\r\n        emit ExcessTokensWithdrawn(token, to, msg.sender);\r\n\r\n        return withdrawableBalance;\r\n    }\r\n\r\n    // ============ Authorized-Only State-Changing Functions ============\r\n\r\n    /**\r\n     * Transfers tokens from an address (that has approved the proxy) to the vault.\r\n     *\r\n     * @param  id      The vault which will receive the tokens\r\n     * @param  token   ERC20 token address\r\n     * @param  from    Address from which the tokens will be taken\r\n     * @param  amount  Number of the token to be sent\r\n     */\r\n    function transferToVault(\r\n        bytes32 id,\r\n        address token,\r\n        address from,\r\n        uint256 amount\r\n    )\r\n        external\r\n        requiresAuthorization\r\n    {\r\n        // First send tokens to this contract\r\n        TokenProxy(TOKEN_PROXY).transferTokens(\r\n            token,\r\n            from,\r\n            address(this),\r\n            amount\r\n        );\r\n\r\n        // Then increment balances\r\n        balances[id][token] = balances[id][token].add(amount);\r\n        totalBalances[token] = totalBalances[token].add(amount);\r\n\r\n        // This should always be true. If not, something is very wrong\r\n        assert(totalBalances[token] >= balances[id][token]);\r\n\r\n        validateBalance(token);\r\n    }\r\n\r\n    /**\r\n     * Transfers a certain amount of funds to an address.\r\n     *\r\n     * @param  id      The vault from which to send the tokens\r\n     * @param  token   ERC20 token address\r\n     * @param  to      Address to transfer tokens to\r\n     * @param  amount  Number of the token to be sent\r\n     */\r\n    function transferFromVault(\r\n        bytes32 id,\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        external\r\n        requiresAuthorization\r\n    {\r\n        // Next line also asserts that (balances[id][token] >= amount);\r\n        balances[id][token] = balances[id][token].sub(amount);\r\n\r\n        // Next line also asserts that (totalBalances[token] >= amount);\r\n        totalBalances[token] = totalBalances[token].sub(amount);\r\n\r\n        // This should always be true. If not, something is very wrong\r\n        assert(totalBalances[token] >= balances[id][token]);\r\n\r\n        // Do the sending\r\n        TokenInteract.transfer(token, to, amount); // asserts transfer succeeded\r\n\r\n        // Final validation\r\n        validateBalance(token);\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Verifies that this contract is in control of at least as many tokens as accounted for\r\n     *\r\n     * @param  token  Address of ERC20 token\r\n     */\r\n    function validateBalance(\r\n        address token\r\n    )\r\n        private\r\n        view\r\n    {\r\n        // The actual balance could be greater than totalBalances[token] because anyone\r\n        // can send tokens to the contract's address which cannot be accounted for\r\n        assert(TokenInteract.balanceOf(token, address(this)) >= totalBalances[token]);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/TimestampHelper.sol\r\n\r\n/**\r\n * @title TimestampHelper\r\n * @author dYdX\r\n *\r\n * Helper to get block timestamps in other formats\r\n */\r\nlibrary TimestampHelper {\r\n    function getBlockTimestamp32()\r\n        internal\r\n        view\r\n        returns (uint32)\r\n    {\r\n        // Should not still be in-use in the year 2106\r\n        assert(uint256(uint32(block.timestamp)) == block.timestamp);\r\n\r\n        assert(block.timestamp > 0);\r\n\r\n        return uint32(block.timestamp);\r\n    }\r\n}\r\n\r\n// File: contracts/margin/impl/MarginCommon.sol\r\n\r\n/**\r\n * @title MarginCommon\r\n * @author dYdX\r\n *\r\n * This library contains common functions for implementations of public facing Margin functions\r\n */\r\nlibrary MarginCommon {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Position {\r\n        address owedToken;       // Immutable\r\n        address heldToken;       // Immutable\r\n        address lender;\r\n        address owner;\r\n        uint256 principal;\r\n        uint256 requiredDeposit;\r\n        uint32  callTimeLimit;   // Immutable\r\n        uint32  startTimestamp;  // Immutable, cannot be 0\r\n        uint32  callTimestamp;\r\n        uint32  maxDuration;     // Immutable\r\n        uint32  interestRate;    // Immutable\r\n        uint32  interestPeriod;  // Immutable\r\n    }\r\n\r\n    struct LoanOffering {\r\n        address   owedToken;\r\n        address   heldToken;\r\n        address   payer;\r\n        address   owner;\r\n        address   taker;\r\n        address   positionOwner;\r\n        address   feeRecipient;\r\n        address   lenderFeeToken;\r\n        address   takerFeeToken;\r\n        LoanRates rates;\r\n        uint256   expirationTimestamp;\r\n        uint32    callTimeLimit;\r\n        uint32    maxDuration;\r\n        uint256   salt;\r\n        bytes32   loanHash;\r\n        bytes     signature;\r\n    }\r\n\r\n    struct LoanRates {\r\n        uint256 maxAmount;\r\n        uint256 minAmount;\r\n        uint256 minHeldToken;\r\n        uint256 lenderFee;\r\n        uint256 takerFee;\r\n        uint32  interestRate;\r\n        uint32  interestPeriod;\r\n    }\r\n\r\n    // ============ Internal Implementation Functions ============\r\n\r\n    function storeNewPosition(\r\n        MarginState.State storage state,\r\n        bytes32 positionId,\r\n        Position memory position,\r\n        address loanPayer\r\n    )\r\n        internal\r\n    {\r\n        assert(!positionHasExisted(state, positionId));\r\n        assert(position.owedToken != address(0));\r\n        assert(position.heldToken != address(0));\r\n        assert(position.owedToken != position.heldToken);\r\n        assert(position.owner != address(0));\r\n        assert(position.lender != address(0));\r\n        assert(position.maxDuration != 0);\r\n        assert(position.interestPeriod <= position.maxDuration);\r\n        assert(position.callTimestamp == 0);\r\n        assert(position.requiredDeposit == 0);\r\n\r\n        state.positions[positionId].owedToken = position.owedToken;\r\n        state.positions[positionId].heldToken = position.heldToken;\r\n        state.positions[positionId].principal = position.principal;\r\n        state.positions[positionId].callTimeLimit = position.callTimeLimit;\r\n        state.positions[positionId].startTimestamp = TimestampHelper.getBlockTimestamp32();\r\n        state.positions[positionId].maxDuration = position.maxDuration;\r\n        state.positions[positionId].interestRate = position.interestRate;\r\n        state.positions[positionId].interestPeriod = position.interestPeriod;\r\n\r\n        state.positions[positionId].owner = TransferInternal.grantPositionOwnership(\r\n            positionId,\r\n            (position.owner != msg.sender) ? msg.sender : address(0),\r\n            position.owner\r\n        );\r\n\r\n        state.positions[positionId].lender = TransferInternal.grantLoanOwnership(\r\n            positionId,\r\n            (position.lender != loanPayer) ? loanPayer : address(0),\r\n            position.lender\r\n        );\r\n    }\r\n\r\n    function getPositionIdFromNonce(\r\n        uint256 nonce\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(msg.sender, nonce));\r\n    }\r\n\r\n    function getUnavailableLoanOfferingAmountImpl(\r\n        MarginState.State storage state,\r\n        bytes32 loanHash\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return state.loanFills[loanHash].add(state.loanCancels[loanHash]);\r\n    }\r\n\r\n    function cleanupPosition(\r\n        MarginState.State storage state,\r\n        bytes32 positionId\r\n    )\r\n        internal\r\n    {\r\n        delete state.positions[positionId];\r\n        state.closedPositions[positionId] = true;\r\n    }\r\n\r\n    function calculateOwedAmount(\r\n        Position storage position,\r\n        uint256 closeAmount,\r\n        uint256 endTimestamp\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 timeElapsed = calculateEffectiveTimeElapsed(position, endTimestamp);\r\n\r\n        return InterestImpl.getCompoundedInterest(\r\n            closeAmount,\r\n            position.interestRate,\r\n            timeElapsed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Calculates time elapsed rounded up to the nearest interestPeriod\r\n     */\r\n    function calculateEffectiveTimeElapsed(\r\n        Position storage position,\r\n        uint256 timestamp\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 elapsed = timestamp.sub(position.startTimestamp);\r\n\r\n        // round up to interestPeriod\r\n        uint256 period = position.interestPeriod;\r\n        if (period > 1) {\r\n            elapsed = MathHelpers.divisionRoundedUp(elapsed, period).mul(period);\r\n        }\r\n\r\n        // bound by maxDuration\r\n        return Math.min256(\r\n            elapsed,\r\n            position.maxDuration\r\n        );\r\n    }\r\n\r\n    function calculateLenderAmountForIncreasePosition(\r\n        Position storage position,\r\n        uint256 principalToAdd,\r\n        uint256 endTimestamp\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 timeElapsed = calculateEffectiveTimeElapsedForNewLender(position, endTimestamp);\r\n\r\n        return InterestImpl.getCompoundedInterest(\r\n            principalToAdd,\r\n            position.interestRate,\r\n            timeElapsed\r\n        );\r\n    }\r\n\r\n    function getLoanOfferingHash(\r\n        LoanOffering loanOffering\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                loanOffering.owedToken,\r\n                loanOffering.heldToken,\r\n                loanOffering.payer,\r\n                loanOffering.owner,\r\n                loanOffering.taker,\r\n                loanOffering.positionOwner,\r\n                loanOffering.feeRecipient,\r\n                loanOffering.lenderFeeToken,\r\n                loanOffering.takerFeeToken,\r\n                getValuesHash(loanOffering)\r\n            )\r\n        );\r\n    }\r\n\r\n    function getPositionBalanceImpl(\r\n        MarginState.State storage state,\r\n        bytes32 positionId\r\n    )\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Vault(state.VAULT).balances(positionId, state.positions[positionId].heldToken);\r\n    }\r\n\r\n    function containsPositionImpl(\r\n        MarginState.State storage state,\r\n        bytes32 positionId\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.positions[positionId].startTimestamp != 0;\r\n    }\r\n\r\n    function positionHasExisted(\r\n        MarginState.State storage state,\r\n        bytes32 positionId\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return containsPositionImpl(state, positionId) || state.closedPositions[positionId];\r\n    }\r\n\r\n    function getPositionFromStorage(\r\n        MarginState.State storage state,\r\n        bytes32 positionId\r\n    )\r\n        internal\r\n        view\r\n        returns (Position storage)\r\n    {\r\n        Position storage position = state.positions[positionId];\r\n\r\n        require(\r\n            position.startTimestamp != 0,\r\n            \"MarginCommon#getPositionFromStorage: The position does not exist\"\r\n        );\r\n\r\n        return position;\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Calculates time elapsed rounded down to the nearest interestPeriod\r\n     */\r\n    function calculateEffectiveTimeElapsedForNewLender(\r\n        Position storage position,\r\n        uint256 timestamp\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 elapsed = timestamp.sub(position.startTimestamp);\r\n\r\n        // round down to interestPeriod\r\n        uint256 period = position.interestPeriod;\r\n        if (period > 1) {\r\n            elapsed = elapsed.div(period).mul(period);\r\n        }\r\n\r\n        // bound by maxDuration\r\n        return Math.min256(\r\n            elapsed,\r\n            position.maxDuration\r\n        );\r\n    }\r\n\r\n    function getValuesHash(\r\n        LoanOffering loanOffering\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                loanOffering.rates.maxAmount,\r\n                loanOffering.rates.minAmount,\r\n                loanOffering.rates.minHeldToken,\r\n                loanOffering.rates.lenderFee,\r\n                loanOffering.rates.takerFee,\r\n                loanOffering.expirationTimestamp,\r\n                loanOffering.salt,\r\n                loanOffering.callTimeLimit,\r\n                loanOffering.maxDuration,\r\n                loanOffering.rates.interestRate,\r\n                loanOffering.rates.interestPeriod\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/margin/interfaces/PayoutRecipient.sol\r\n\r\n/**\r\n * @title PayoutRecipient\r\n * @author dYdX\r\n *\r\n * Interface that smart contracts must implement in order to be the payoutRecipient in a\r\n * closePosition transaction.\r\n *\r\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\r\n *       to these functions\r\n */\r\ninterface PayoutRecipient {\r\n\r\n    // ============ Public Interface functions ============\r\n\r\n    /**\r\n     * Function a contract must implement in order to receive payout from being the payoutRecipient\r\n     * in a closePosition transaction. May redistribute any payout as necessary. Throws on error.\r\n     *\r\n     * @param  positionId         Unique ID of the position\r\n     * @param  closeAmount        Amount of the position that was closed\r\n     * @param  closer             Address of the account or contract that closed the position\r\n     * @param  positionOwner      Address of the owner of the position\r\n     * @param  heldToken          Address of the ERC20 heldToken\r\n     * @param  payout             Number of tokens received from the payout\r\n     * @param  totalHeldToken     Total amount of heldToken removed from vault during close\r\n     * @param  payoutInHeldToken  True if payout is in heldToken, false if in owedToken\r\n     * @return                    True if approved by the receiver\r\n     */\r\n    function receiveClosePositionPayout(\r\n        bytes32 positionId,\r\n        uint256 closeAmount,\r\n        address closer,\r\n        address positionOwner,\r\n        address heldToken,\r\n        uint256 payout,\r\n        uint256 totalHeldToken,\r\n        bool    payoutInHeldToken\r\n    )\r\n        external\r\n        /* onlyMargin */\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/margin/interfaces/lender/CloseLoanDelegator.sol\r\n\r\n/**\r\n * @title CloseLoanDelegator\r\n * @author dYdX\r\n *\r\n * Interface that smart contracts must implement in order to let other addresses close a loan\r\n * owned by the smart contract.\r\n *\r\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\r\n *       to these functions\r\n */\r\ninterface CloseLoanDelegator {\r\n\r\n    // ============ Public Interface functions ============\r\n\r\n    /**\r\n     * Function a contract must implement in order to let other addresses call\r\n     * closeWithoutCounterparty().\r\n     *\r\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\r\n     * either revert the entire transaction or that (at most) the specified amount of the loan was\r\n     * successfully closed.\r\n     *\r\n     * @param  closer           Address of the caller of closeWithoutCounterparty()\r\n     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\r\n     * @param  positionId       Unique ID of the position\r\n     * @param  requestedAmount  Requested principal amount of the loan to close\r\n     * @return                  1) This address to accept, a different address to ask that contract\r\n     *                          2) The maximum amount that this contract is allowing\r\n     */\r\n    function closeLoanOnBehalfOf(\r\n        address closer,\r\n        address payoutRecipient,\r\n        bytes32 positionId,\r\n        uint256 requestedAmount\r\n    )\r\n        external\r\n        /* onlyMargin */\r\n        returns (address, uint256);\r\n}\r\n\r\n// File: contracts/margin/interfaces/owner/ClosePositionDelegator.sol\r\n\r\n/**\r\n * @title ClosePositionDelegator\r\n * @author dYdX\r\n *\r\n * Interface that smart contracts must implement in order to let other addresses close a position\r\n * owned by the smart contract, allowing more complex logic to control positions.\r\n *\r\n * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\r\n *       to these functions\r\n */\r\ninterface ClosePositionDelegator {\r\n\r\n    // ============ Public Interface functions ============\r\n\r\n    /**\r\n     * Function a contract must implement in order to let other addresses call closePosition().\r\n     *\r\n     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\r\n     * either revert the entire transaction or that (at-most) the specified amount of the position\r\n     * was successfully closed.\r\n     *\r\n     * @param  closer           Address of the caller of the closePosition() function\r\n     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\r\n     * @param  positionId       Unique ID of the position\r\n     * @param  requestedAmount  Requested principal amount of the position to close\r\n     * @return                  1) This address to accept, a different address to ask that contract\r\n     *                          2) The maximum amount that this contract is allowing\r\n     */\r\n    function closeOnBehalfOf(\r\n        address closer,\r\n        address payoutRecipient,\r\n        bytes32 positionId,\r\n        uint256 requestedAmount\r\n    )\r\n        external\r\n        /* onlyMargin */\r\n        returns (address, uint256);\r\n}\r\n\r\n// File: contracts/margin/impl/ClosePositionShared.sol\r\n\r\n/**\r\n * @title ClosePositionShared\r\n * @author dYdX\r\n *\r\n * This library contains shared functionality between ClosePositionImpl and\r\n * CloseWithoutCounterpartyImpl\r\n */\r\nlibrary ClosePositionShared {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct CloseTx {\r\n        bytes32 positionId;\r\n        uint256 originalPrincipal;\r\n        uint256 closeAmount;\r\n        uint256 owedTokenOwed;\r\n        uint256 startingHeldTokenBalance;\r\n        uint256 availableHeldToken;\r\n        address payoutRecipient;\r\n        address owedToken;\r\n        address heldToken;\r\n        address positionOwner;\r\n        address positionLender;\r\n        address exchangeWrapper;\r\n        bool    payoutInHeldToken;\r\n    }\r\n\r\n    // ============ Internal Implementation Functions ============\r\n\r\n    function closePositionStateUpdate(\r\n        MarginState.State storage state,\r\n        CloseTx memory transaction\r\n    )\r\n        internal\r\n    {\r\n        // Delete the position, or just decrease the principal\r\n        if (transaction.closeAmount == transaction.originalPrincipal) {\r\n            MarginCommon.cleanupPosition(state, transaction.positionId);\r\n        } else {\r\n            assert(\r\n                transaction.originalPrincipal == state.positions[transaction.positionId].principal\r\n            );\r\n            state.positions[transaction.positionId].principal =\r\n                transaction.originalPrincipal.sub(transaction.closeAmount);\r\n        }\r\n    }\r\n\r\n    function sendTokensToPayoutRecipient(\r\n        MarginState.State storage state,\r\n        ClosePositionShared.CloseTx memory transaction,\r\n        uint256 buybackCostInHeldToken,\r\n        uint256 receivedOwedToken\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 payout;\r\n\r\n        if (transaction.payoutInHeldToken) {\r\n            // Send remaining heldToken to payoutRecipient\r\n            payout = transaction.availableHeldToken.sub(buybackCostInHeldToken);\r\n\r\n            Vault(state.VAULT).transferFromVault(\r\n                transaction.positionId,\r\n                transaction.heldToken,\r\n                transaction.payoutRecipient,\r\n                payout\r\n            );\r\n        } else {\r\n            assert(transaction.exchangeWrapper != address(0));\r\n\r\n            payout = receivedOwedToken.sub(transaction.owedTokenOwed);\r\n\r\n            TokenProxy(state.TOKEN_PROXY).transferTokens(\r\n                transaction.owedToken,\r\n                transaction.exchangeWrapper,\r\n                transaction.payoutRecipient,\r\n                payout\r\n            );\r\n        }\r\n\r\n        if (AddressUtils.isContract(transaction.payoutRecipient)) {\r\n            require(\r\n                PayoutRecipient(transaction.payoutRecipient).receiveClosePositionPayout(\r\n                    transaction.positionId,\r\n                    transaction.closeAmount,\r\n                    msg.sender,\r\n                    transaction.positionOwner,\r\n                    transaction.heldToken,\r\n                    payout,\r\n                    transaction.availableHeldToken,\r\n                    transaction.payoutInHeldToken\r\n                ),\r\n                \"ClosePositionShared#sendTokensToPayoutRecipient: Payout recipient does not consent\"\r\n            );\r\n        }\r\n\r\n        // The ending heldToken balance of the vault should be the starting heldToken balance\r\n        // minus the available heldToken amount\r\n        assert(\r\n            MarginCommon.getPositionBalanceImpl(state, transaction.positionId)\r\n            == transaction.startingHeldTokenBalance.sub(transaction.availableHeldToken)\r\n        );\r\n\r\n        return payout;\r\n    }\r\n\r\n    function createCloseTx(\r\n        MarginState.State storage state,\r\n        bytes32 positionId,\r\n        uint256 requestedAmount,\r\n        address payoutRecipient,\r\n        address exchangeWrapper,\r\n        bool payoutInHeldToken,\r\n        bool isWithoutCounterparty\r\n    )\r\n        internal\r\n        returns (CloseTx memory)\r\n    {\r\n        // Validate\r\n        require(\r\n            payoutRecipient != address(0),\r\n            \"ClosePositionShared#createCloseTx: Payout recipient cannot be 0\"\r\n        );\r\n        require(\r\n            requestedAmount > 0,\r\n            \"ClosePositionShared#createCloseTx: Requested close amount cannot be 0\"\r\n        );\r\n\r\n        MarginCommon.Position storage position =\r\n            MarginCommon.getPositionFromStorage(state, positionId);\r\n\r\n        uint256 closeAmount = getApprovedAmount(\r\n            position,\r\n            positionId,\r\n            requestedAmount,\r\n            payoutRecipient,\r\n            isWithoutCounterparty\r\n        );\r\n\r\n        return parseCloseTx(\r\n            state,\r\n            position,\r\n            positionId,\r\n            closeAmount,\r\n            payoutRecipient,\r\n            exchangeWrapper,\r\n            payoutInHeldToken,\r\n            isWithoutCounterparty\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    function getApprovedAmount(\r\n        MarginCommon.Position storage position,\r\n        bytes32 positionId,\r\n        uint256 requestedAmount,\r\n        address payoutRecipient,\r\n        bool requireLenderApproval\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        // Ensure enough principal\r\n        uint256 allowedAmount = Math.min256(requestedAmount, position.principal);\r\n\r\n        // Ensure owner consent\r\n        allowedAmount = closePositionOnBehalfOfRecurse(\r\n            position.owner,\r\n            msg.sender,\r\n            payoutRecipient,\r\n            positionId,\r\n            allowedAmount\r\n        );\r\n\r\n        // Ensure lender consent\r\n        if (requireLenderApproval) {\r\n            allowedAmount = closeLoanOnBehalfOfRecurse(\r\n                position.lender,\r\n                msg.sender,\r\n                payoutRecipient,\r\n                positionId,\r\n                allowedAmount\r\n            );\r\n        }\r\n\r\n        assert(allowedAmount > 0);\r\n        assert(allowedAmount <= position.principal);\r\n        assert(allowedAmount <= requestedAmount);\r\n\r\n        return allowedAmount;\r\n    }\r\n\r\n    function closePositionOnBehalfOfRecurse(\r\n        address contractAddr,\r\n        address closer,\r\n        address payoutRecipient,\r\n        bytes32 positionId,\r\n        uint256 closeAmount\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        // no need to ask for permission\r\n        if (closer == contractAddr) {\r\n            return closeAmount;\r\n        }\r\n\r\n        (\r\n            address newContractAddr,\r\n            uint256 newCloseAmount\r\n        ) = ClosePositionDelegator(contractAddr).closeOnBehalfOf(\r\n            closer,\r\n            payoutRecipient,\r\n            positionId,\r\n            closeAmount\r\n        );\r\n\r\n        require(\r\n            newCloseAmount <= closeAmount,\r\n            \"ClosePositionShared#closePositionRecurse: newCloseAmount is greater than closeAmount\"\r\n        );\r\n        require(\r\n            newCloseAmount > 0,\r\n            \"ClosePositionShared#closePositionRecurse: newCloseAmount is zero\"\r\n        );\r\n\r\n        if (newContractAddr != contractAddr) {\r\n            closePositionOnBehalfOfRecurse(\r\n                newContractAddr,\r\n                closer,\r\n                payoutRecipient,\r\n                positionId,\r\n                newCloseAmount\r\n            );\r\n        }\r\n\r\n        return newCloseAmount;\r\n    }\r\n\r\n    function closeLoanOnBehalfOfRecurse(\r\n        address contractAddr,\r\n        address closer,\r\n        address payoutRecipient,\r\n        bytes32 positionId,\r\n        uint256 closeAmount\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        // no need to ask for permission\r\n        if (closer == contractAddr) {\r\n            return closeAmount;\r\n        }\r\n\r\n        (\r\n            address newContractAddr,\r\n            uint256 newCloseAmount\r\n        ) = CloseLoanDelegator(contractAddr).closeLoanOnBehalfOf(\r\n                closer,\r\n                payoutRecipient,\r\n                positionId,\r\n                closeAmount\r\n            );\r\n\r\n        require(\r\n            newCloseAmount <= closeAmount,\r\n            \"ClosePositionShared#closeLoanRecurse: newCloseAmount is greater than closeAmount\"\r\n        );\r\n        require(\r\n            newCloseAmount > 0,\r\n            \"ClosePositionShared#closeLoanRecurse: newCloseAmount is zero\"\r\n        );\r\n\r\n        if (newContractAddr != contractAddr) {\r\n            closeLoanOnBehalfOfRecurse(\r\n                newContractAddr,\r\n                closer,\r\n                payoutRecipient,\r\n                positionId,\r\n                newCloseAmount\r\n            );\r\n        }\r\n\r\n        return newCloseAmount;\r\n    }\r\n\r\n    // ============ Parsing Functions ============\r\n\r\n    function parseCloseTx(\r\n        MarginState.State storage state,\r\n        MarginCommon.Position storage position,\r\n        bytes32 positionId,\r\n        uint256 closeAmount,\r\n        address payoutRecipient,\r\n        address exchangeWrapper,\r\n        bool payoutInHeldToken,\r\n        bool isWithoutCounterparty\r\n    )\r\n        private\r\n        view\r\n        returns (CloseTx memory)\r\n    {\r\n        uint256 startingHeldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\r\n\r\n        uint256 availableHeldToken = MathHelpers.getPartialAmount(\r\n            closeAmount,\r\n            position.principal,\r\n            startingHeldTokenBalance\r\n        );\r\n        uint256 owedTokenOwed = 0;\r\n\r\n        if (!isWithoutCounterparty) {\r\n            owedTokenOwed = MarginCommon.calculateOwedAmount(\r\n                position,\r\n                closeAmount,\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        return CloseTx({\r\n            positionId: positionId,\r\n            originalPrincipal: position.principal,\r\n            closeAmount: closeAmount,\r\n            owedTokenOwed: owedTokenOwed,\r\n            startingHeldTokenBalance: startingHeldTokenBalance,\r\n            availableHeldToken: availableHeldToken,\r\n            payoutRecipient: payoutRecipient,\r\n            owedToken: position.owedToken,\r\n            heldToken: position.heldToken,\r\n            positionOwner: position.owner,\r\n            positionLender: position.lender,\r\n            exchangeWrapper: exchangeWrapper,\r\n            payoutInHeldToken: payoutInHeldToken\r\n        });\r\n    }\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeWrapper.sol\r\n\r\n/**\r\n * @title ExchangeWrapper\r\n * @author dYdX\r\n *\r\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\r\n * with other smart contracts through a common interface.\r\n */\r\ninterface ExchangeWrapper {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Exchange some amount of takerToken for makerToken.\r\n     *\r\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\r\n     *                              cannot always be trusted as it is set at the discretion of the\r\n     *                              msg.sender)\r\n     * @param  receiver             Address to set allowance on once the trade has completed\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  requestedFillAmount  Amount of takerToken being paid\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      The amount of makerToken received\r\n     */\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\r\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\r\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\r\n     * than desiredMakerToken\r\n     *\r\n     * @param  makerToken         Address of makerToken, the token to receive\r\n     * @param  takerToken         Address of takerToken, the token to pay\r\n     * @param  desiredMakerToken  Amount of makerToken requested\r\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                    Amount of takerToken the needed to complete the transaction\r\n     */\r\n    function getExchangeCost(\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/impl/ClosePositionImpl.sol\r\n\r\n/**\r\n * @title ClosePositionImpl\r\n * @author dYdX\r\n *\r\n * This library contains the implementation for the closePosition function of Margin\r\n */\r\nlibrary ClosePositionImpl {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Events ============\r\n\r\n    /**\r\n     * A position was closed or partially closed\r\n     */\r\n    event PositionClosed(\r\n        bytes32 indexed positionId,\r\n        address indexed closer,\r\n        address indexed payoutRecipient,\r\n        uint256 closeAmount,\r\n        uint256 remainingAmount,\r\n        uint256 owedTokenPaidToLender,\r\n        uint256 payoutAmount,\r\n        uint256 buybackCostInHeldToken,\r\n        bool    payoutInHeldToken\r\n    );\r\n\r\n    // ============ Public Implementation Functions ============\r\n\r\n    function closePositionImpl(\r\n        MarginState.State storage state,\r\n        bytes32 positionId,\r\n        uint256 requestedCloseAmount,\r\n        address payoutRecipient,\r\n        address exchangeWrapper,\r\n        bool payoutInHeldToken,\r\n        bytes memory orderData\r\n    )\r\n        public\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\r\n            state,\r\n            positionId,\r\n            requestedCloseAmount,\r\n            payoutRecipient,\r\n            exchangeWrapper,\r\n            payoutInHeldToken,\r\n            false\r\n        );\r\n\r\n        (\r\n            uint256 buybackCostInHeldToken,\r\n            uint256 receivedOwedToken\r\n        ) = returnOwedTokensToLender(\r\n            state,\r\n            transaction,\r\n            orderData\r\n        );\r\n\r\n        uint256 payout = ClosePositionShared.sendTokensToPayoutRecipient(\r\n            state,\r\n            transaction,\r\n            buybackCostInHeldToken,\r\n            receivedOwedToken\r\n        );\r\n\r\n        ClosePositionShared.closePositionStateUpdate(state, transaction);\r\n\r\n        logEventOnClose(\r\n            transaction,\r\n            buybackCostInHeldToken,\r\n            payout\r\n        );\r\n\r\n        return (\r\n            transaction.closeAmount,\r\n            payout,\r\n            transaction.owedTokenOwed\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    function returnOwedTokensToLender(\r\n        MarginState.State storage state,\r\n        ClosePositionShared.CloseTx memory transaction,\r\n        bytes memory orderData\r\n    )\r\n        private\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 buybackCostInHeldToken = 0;\r\n        uint256 receivedOwedToken = 0;\r\n        uint256 lenderOwedToken = transaction.owedTokenOwed;\r\n\r\n        // Setting exchangeWrapper to 0x000... indicates owedToken should be taken directly\r\n        // from msg.sender\r\n        if (transaction.exchangeWrapper == address(0)) {\r\n            require(\r\n                transaction.payoutInHeldToken,\r\n                \"ClosePositionImpl#returnOwedTokensToLender: Cannot payout in owedToken\"\r\n            );\r\n\r\n            // No DEX Order; send owedTokens directly from the closer to the lender\r\n            TokenProxy(state.TOKEN_PROXY).transferTokens(\r\n                transaction.owedToken,\r\n                msg.sender,\r\n                transaction.positionLender,\r\n                lenderOwedToken\r\n            );\r\n        } else {\r\n            // Buy back owedTokens using DEX Order and send to lender\r\n            (buybackCostInHeldToken, receivedOwedToken) = buyBackOwedToken(\r\n                state,\r\n                transaction,\r\n                orderData\r\n            );\r\n\r\n            // If no owedToken needed for payout: give lender all owedToken, even if more than owed\r\n            if (transaction.payoutInHeldToken) {\r\n                assert(receivedOwedToken >= lenderOwedToken);\r\n                lenderOwedToken = receivedOwedToken;\r\n            }\r\n\r\n            // Transfer owedToken from the exchange wrapper to the lender\r\n            TokenProxy(state.TOKEN_PROXY).transferTokens(\r\n                transaction.owedToken,\r\n                transaction.exchangeWrapper,\r\n                transaction.positionLender,\r\n                lenderOwedToken\r\n            );\r\n        }\r\n\r\n        state.totalOwedTokenRepaidToLender[transaction.positionId] =\r\n            state.totalOwedTokenRepaidToLender[transaction.positionId].add(lenderOwedToken);\r\n\r\n        return (buybackCostInHeldToken, receivedOwedToken);\r\n    }\r\n\r\n    function buyBackOwedToken(\r\n        MarginState.State storage state,\r\n        ClosePositionShared.CloseTx transaction,\r\n        bytes memory orderData\r\n    )\r\n        private\r\n        returns (uint256, uint256)\r\n    {\r\n        // Ask the exchange wrapper the cost in heldToken to buy back the close\r\n        // amount of owedToken\r\n        uint256 buybackCostInHeldToken;\r\n\r\n        if (transaction.payoutInHeldToken) {\r\n            buybackCostInHeldToken = ExchangeWrapper(transaction.exchangeWrapper)\r\n                .getExchangeCost(\r\n                    transaction.owedToken,\r\n                    transaction.heldToken,\r\n                    transaction.owedTokenOwed,\r\n                    orderData\r\n                );\r\n\r\n            // Require enough available heldToken to pay for the buyback\r\n            require(\r\n                buybackCostInHeldToken <= transaction.availableHeldToken,\r\n                \"ClosePositionImpl#buyBackOwedToken: Not enough available heldToken\"\r\n            );\r\n        } else {\r\n            buybackCostInHeldToken = transaction.availableHeldToken;\r\n        }\r\n\r\n        // Send the requisite heldToken to do the buyback from vault to exchange wrapper\r\n        Vault(state.VAULT).transferFromVault(\r\n            transaction.positionId,\r\n            transaction.heldToken,\r\n            transaction.exchangeWrapper,\r\n            buybackCostInHeldToken\r\n        );\r\n\r\n        // Trade the heldToken for the owedToken\r\n        uint256 receivedOwedToken = ExchangeWrapper(transaction.exchangeWrapper).exchange(\r\n            msg.sender,\r\n            state.TOKEN_PROXY,\r\n            transaction.owedToken,\r\n            transaction.heldToken,\r\n            buybackCostInHeldToken,\r\n            orderData\r\n        );\r\n\r\n        require(\r\n            receivedOwedToken >= transaction.owedTokenOwed,\r\n            \"ClosePositionImpl#buyBackOwedToken: Did not receive enough owedToken\"\r\n        );\r\n\r\n        return (buybackCostInHeldToken, receivedOwedToken);\r\n    }\r\n\r\n    function logEventOnClose(\r\n        ClosePositionShared.CloseTx transaction,\r\n        uint256 buybackCostInHeldToken,\r\n        uint256 payout\r\n    )\r\n        private\r\n    {\r\n        emit PositionClosed(\r\n            transaction.positionId,\r\n            msg.sender,\r\n            transaction.payoutRecipient,\r\n            transaction.closeAmount,\r\n            transaction.originalPrincipal.sub(transaction.closeAmount),\r\n            transaction.owedTokenOwed,\r\n            payout,\r\n            buybackCostInHeldToken,\r\n            transaction.payoutInHeldToken\r\n        );\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"MarginState.State storage\"},{\"name\":\"positionId\",\"type\":\"bytes32\"},{\"name\":\"requestedCloseAmount\",\"type\":\"uint256\"},{\"name\":\"payoutRecipient\",\"type\":\"address\"},{\"name\":\"exchangeWrapper\",\"type\":\"address\"},{\"name\":\"payoutInHeldToken\",\"type\":\"bool\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"closePositionImpl\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"positionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"closer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"payoutRecipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"closeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owedTokenPaidToLender\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buybackCostInHeldToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payoutInHeldToken\",\"type\":\"bool\"}],\"name\":\"PositionClosed\",\"type\":\"event\"}]","ContractName":"ClosePositionImpl","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"InterestImpl:cd3af710f570fbe7da9319cada82e647d0bc6456","SwarmSource":"bzzr://d3408f1d16e4175f4fa1fe9c5a389f68fe861a1b775625feecdcfd3112174212"}]}