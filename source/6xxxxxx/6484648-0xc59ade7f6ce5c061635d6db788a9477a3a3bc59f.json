{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/pricing/CvcPricingInterface.sol\r\n\r\n/**\r\n * @title CvcPricingInterface\r\n * @dev This contract defines the pricing service interface.\r\n */\r\ncontract CvcPricingInterface {\r\n\r\n    struct CredentialItemPrice {\r\n        bytes32 id;\r\n        uint256 price;\r\n        address idv;\r\n        string credentialItemType;\r\n        string credentialItemName;\r\n        string credentialItemVersion;\r\n        bool deprecated;\r\n    }\r\n\r\n    /**\r\n     * @dev The CredentialItemPriceSet event is emitted when Identity Validator sets new price for specific credential item.\r\n     *\r\n     * @param id Price record identifier.\r\n     * @param price Credential Item price in CVC.\r\n     * @param idv The address of Identity Validator who offers Credential Item for sale.\r\n     * @param credentialItemType Credential Item Type.\r\n     * @param credentialItemName Credential Item Name.\r\n     * @param credentialItemVersion Credential Item Version.\r\n     * @param credentialItemId Credential Item ID.\r\n     */\r\n    event CredentialItemPriceSet(\r\n        bytes32 indexed id,\r\n        uint256 price,\r\n        address indexed idv,\r\n        string credentialItemType,\r\n        string credentialItemName,\r\n        string credentialItemVersion,\r\n        bytes32 indexed credentialItemId\r\n    );\r\n\r\n    /**\r\n     * @dev The CredentialItemPriceDeleted event is emitted when Identity Validator deletes the price for specific credential item.\r\n     *\r\n     * @param id Price record identifier.\r\n     * @param idv The address of Identity Validator who offers Credential Item for sale\r\n     * @param credentialItemType Credential Item Type.\r\n     * @param credentialItemName Credential Item Name.\r\n     * @param credentialItemVersion Credential Item Version.\r\n     * @param credentialItemId Credential Item ID.\r\n     */\r\n    event CredentialItemPriceDeleted(\r\n        bytes32 indexed id,\r\n        address indexed idv,\r\n        string credentialItemType,\r\n        string credentialItemName,\r\n        string credentialItemVersion,\r\n        bytes32 indexed credentialItemId\r\n    );\r\n\r\n    /**\r\n    * @dev Sets the price for Credential Item of specific type, name and version.\r\n    * The price is associated with IDV address (sender).\r\n    * @param _credentialItemType Credential Item type.\r\n    * @param _credentialItemName Credential Item name.\r\n    * @param _credentialItemVersion Credential Item version.\r\n    * @param _price Credential Item price.\r\n    */\r\n    function setPrice(\r\n        string _credentialItemType,\r\n        string _credentialItemName,\r\n        string _credentialItemVersion,\r\n        uint256 _price\r\n        ) external;\r\n\r\n    /**\r\n    * @dev Deletes the price for Credential Item of specific type, name and version.\r\n    * @param _credentialItemType Credential Item type.\r\n    * @param _credentialItemName Credential Item name.\r\n    * @param _credentialItemVersion Credential Item version.\r\n    */\r\n    function deletePrice(\r\n        string _credentialItemType,\r\n        string _credentialItemName,\r\n        string _credentialItemVersion\r\n        ) external;\r\n\r\n    /**\r\n    * @dev Returns the price set by IDV for Credential Item of specific type, name and version.\r\n    * @param _idv IDV address.\r\n    * @param _credentialItemType Credential Item type.\r\n    * @param _credentialItemName Credential Item name.\r\n    * @param _credentialItemVersion Credential Item version.\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPrice(\r\n        address _idv,\r\n        string _credentialItemType,\r\n        string _credentialItemName,\r\n        string _credentialItemVersion\r\n        ) external view returns (\r\n            bytes32 id,\r\n            uint256 price,\r\n            address idv,\r\n            string credentialItemType,\r\n            string credentialItemName,\r\n            string credentialItemVersion,\r\n            bool deprecated\r\n        );\r\n\r\n    /**\r\n    * @dev Returns the price by Credential Item ID.\r\n    * @param _idv IDV address.\r\n    * @param _credentialItemId Credential Item ID.\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPriceByCredentialItemId(\r\n        address _idv,\r\n        bytes32 _credentialItemId\r\n        ) external view returns (\r\n            bytes32 id,\r\n            uint256 price,\r\n            address idv,\r\n            string credentialItemType,\r\n            string credentialItemName,\r\n            string credentialItemVersion,\r\n            bool deprecated\r\n        );\r\n\r\n    /**\r\n    * @dev Returns all Credential Item prices.\r\n    * @return CredentialItemPrice[]\r\n    */\r\n    function getAllPrices() external view returns (CredentialItemPrice[]);\r\n\r\n    /**\r\n     * @dev Returns all IDs of registered Credential Item prices.\r\n     * @return bytes32[]\r\n     */\r\n    function getAllIds() external view returns (bytes32[]);\r\n\r\n    /**\r\n    * @dev Returns the price by ID.\r\n    * @param _id Price ID\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPriceById(\r\n        bytes32 _id\r\n        ) public view returns (\r\n            bytes32 id,\r\n            uint256 price,\r\n            address idv,\r\n            string credentialItemType,\r\n            string credentialItemName,\r\n            string credentialItemVersion,\r\n            bool deprecated\r\n        );\r\n}\r\n\r\n// File: contracts/idv/CvcValidatorRegistryInterface.sol\r\n\r\n/**\r\n * @title CvcValidatorRegistryInterface\r\n * @dev This contract defines Validator Registry interface.\r\n */\r\ncontract CvcValidatorRegistryInterface {\r\n\r\n    /**\r\n    * @dev Adds a new Validator record or updates the existing one.\r\n    * @param _name Validator name.\r\n    * @param _description Validator description.\r\n    */\r\n    function set(address _idv, string _name, string _description) external;\r\n\r\n    /**\r\n    * @dev Returns Validator entry.\r\n    * @param _idv Validator address.\r\n    * @return name Validator name.\r\n    * @return description Validator description.\r\n    */\r\n    function get(address _idv) external view returns (string name, string description);\r\n\r\n    /**\r\n    * @dev Verifies whether Validator is registered.\r\n    * @param _idv Validator address.\r\n    * @return bool\r\n    */\r\n    function exists(address _idv) external view returns (bool);\r\n}\r\n\r\n// File: contracts/ontology/CvcOntologyInterface.sol\r\n\r\n/**\r\n * @title CvcOntologyInterface\r\n * @dev This contract defines marketplace ontology registry interface.\r\n */\r\ncontract CvcOntologyInterface {\r\n\r\n    struct CredentialItem {\r\n        bytes32 id;\r\n        string recordType;\r\n        string recordName;\r\n        string recordVersion;\r\n        string reference;\r\n        string referenceType;\r\n        bytes32 referenceHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds new Credential Item to the registry.\r\n     * @param _recordType Credential Item type\r\n     * @param _recordName Credential Item name\r\n     * @param _recordVersion Credential Item version\r\n     * @param _reference Credential Item reference URL\r\n     * @param _referenceType Credential Item reference type\r\n     * @param _referenceHash Credential Item reference hash\r\n     */\r\n    function add(\r\n        string _recordType,\r\n        string _recordName,\r\n        string _recordVersion,\r\n        string _reference,\r\n        string _referenceType,\r\n        bytes32 _referenceHash\r\n        ) external;\r\n\r\n    /**\r\n    * @dev Deprecates single Credential Item by external ID (type, name and version).\r\n    * @param _type Record type to deprecate\r\n    * @param _name Record name to deprecate\r\n    * @param _version Record version to deprecate\r\n    */\r\n    function deprecate(string _type, string _name, string _version) public;\r\n\r\n    /**\r\n    * @dev Deprecates single Credential Item by ID.\r\n    * @param _id Record ID to deprecate\r\n    */\r\n    function deprecateById(bytes32 _id) public;\r\n\r\n    /**\r\n     * @dev Returns single Credential Item data up by ontology record ID.\r\n     * @param _id Ontology record ID to search by\r\n     * @return id Ontology record ID\r\n     * @return recordType Credential Item type\r\n     * @return recordName Credential Item name\r\n     * @return recordVersion Credential Item version\r\n     * @return reference Credential Item reference URL\r\n     * @return referenceType Credential Item reference type\r\n     * @return referenceHash Credential Item reference hash\r\n     * @return deprecated Credential Item type deprecation flag\r\n     */\r\n    function getById(bytes32 _id) public view returns (\r\n        bytes32 id,\r\n        string recordType,\r\n        string recordName,\r\n        string recordVersion,\r\n        string reference,\r\n        string referenceType,\r\n        bytes32 referenceHash,\r\n        bool deprecated\r\n        );\r\n\r\n    /**\r\n     * @dev Returns single Credential Item of specific type, name and version.\r\n     * @param _type Credential Item type\r\n     * @param _name Credential Item name\r\n     * @param _version Credential Item version\r\n     * @return id Ontology record ID\r\n     * @return recordType Credential Item type\r\n     * @return recordName Credential Item name\r\n     * @return recordVersion Credential Item version\r\n     * @return reference Credential Item reference URL\r\n     * @return referenceType Credential Item reference type\r\n     * @return referenceHash Credential Item reference hash\r\n     * @return deprecated Credential Item type deprecation flag\r\n     */\r\n    function getByTypeNameVersion(\r\n        string _type,\r\n        string _name,\r\n        string _version\r\n        ) public view returns (\r\n            bytes32 id,\r\n            string recordType,\r\n            string recordName,\r\n            string recordVersion,\r\n            string reference,\r\n            string referenceType,\r\n            bytes32 referenceHash,\r\n            bool deprecated\r\n        );\r\n\r\n    /**\r\n     * @dev Returns all IDs of registered Credential Items.\r\n     * @return bytes32[]\r\n     */\r\n    function getAllIds() public view returns (bytes32[]);\r\n\r\n    /**\r\n     * @dev Returns all registered Credential Items.\r\n     * @return bytes32[]\r\n     */\r\n    function getAll() public view returns (CredentialItem[]);\r\n}\r\n\r\n// File: contracts/upgradeability/EternalStorage.sol\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract defines the generic storage structure\r\n * so that it could be re-used to implement any domain specific storage functionality\r\n */\r\ncontract EternalStorage {\r\n\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n    mapping(bytes32 => bytes32) internal bytes32Storage;\r\n\r\n}\r\n\r\n// File: contracts/upgradeability/ImplementationStorage.sol\r\n\r\n/**\r\n * @title ImplementationStorage\r\n * @dev This contract stores proxy implementation address.\r\n */\r\ncontract ImplementationStorage {\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"cvc.proxy.implementation\", and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\r\n\r\n    /**\r\n    * @dev Constructor\r\n    */\r\n    constructor() public {\r\n        assert(IMPLEMENTATION_SLOT == keccak256(\"cvc.proxy.implementation\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     * @return Address of the current implementation\r\n     */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Initializable.sol\r\n\r\n/**\r\n * @title Initializable\r\n * @dev This contract provides basic initialization control\r\n */\r\ncontract Initializable is EternalStorage, ImplementationStorage {\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    mapping(bytes32 => bool) initialized;\r\n    **/\r\n\r\n    /**\r\n     * @dev Throws if called before contract was initialized.\r\n     */\r\n    modifier onlyInitialized() {\r\n        // require(initialized[implementation()]);\r\n        require(boolStorage[keccak256(abi.encodePacked(implementation(), \"initialized\"))], \"Contract is not initialized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Controls the initialization state, allowing to call an initialization function only once.\r\n     */\r\n    modifier initializes() {\r\n        address impl = implementation();\r\n        // require(!initialized[implementation()]);\r\n        require(!boolStorage[keccak256(abi.encodePacked(impl, \"initialized\"))], \"Contract is already initialized\");\r\n        _;\r\n        // initialized[implementation()] = true;\r\n        boolStorage[keccak256(abi.encodePacked(impl, \"initialized\"))] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev This contract has an owner address providing basic authorization control\r\n */\r\ncontract Ownable is EternalStorage {\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    address owner;\r\n    **/\r\n\r\n    /**\r\n     * @dev Event to show ownership has been transferred\r\n     * @param previousOwner representing the address of the previous owner\r\n     * @param newOwner representing the address of the new owner\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(), \"Message sender must be contract admin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return the address of the owner\r\n     */\r\n    function owner() public view returns (address) {\r\n        // return owner;\r\n        return addressStorage[keccak256(\"owner\")];\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner the address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Contract owner cannot be zero address\");\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new owner address\r\n     */\r\n    function setOwner(address newOwner) internal {\r\n        emit OwnershipTransferred(owner(), newOwner);\r\n        // owner = newOwner;\r\n        addressStorage[keccak256(\"owner\")] = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable, ImplementationStorage {\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    mapping(bytes32 => bool) paused;\r\n    **/\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Contract must be paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        // paused[implementation()] = true;\r\n        boolStorage[keccak256(abi.encodePacked(implementation(), \"paused\"))] = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        // paused[implementation()] = false;\r\n        boolStorage[keccak256(abi.encodePacked(implementation(), \"paused\"))] = false;\r\n        emit Unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true when the contract is paused.\r\n     * @return bool\r\n     */\r\n    function paused() public view returns (bool) {\r\n        // return paused[implementation()];\r\n        return boolStorage[keccak256(abi.encodePacked(implementation(), \"paused\"))];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/pricing/CvcPricing.sol\r\n\r\n/**\r\n * @title CvcPricing\r\n * @dev This contract stores actual prices for Credential Items available for sale.\r\n * It allows registered Identity Validators to set or delete prices for specific Credential Items.\r\n *\r\n * The pricing contract depends on other marketplace contracts, such as:\r\n * CvcOntology - to verify that Credential Item is available on the market and can be offered for sale.\r\n * CvcValidatorRegistry - to ensure that only registered Identity Validators can use pricing services.\r\n *                          Transactions from unknown accounts will be rejected.\r\n */\r\ncontract CvcPricing is EternalStorage, Initializable, Pausable, CvcPricingInterface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    struct Price {\r\n        uint256 value;\r\n        bytes32 credentialItemId;\r\n        address idv;\r\n    }\r\n\r\n    address cvcOntology;\r\n    address idvRegistry;\r\n    uint256 pricesCount;\r\n    bytes32[] pricesIds;\r\n    mapping(bytes32 => uint256) pricesIndices;\r\n    mapping(bytes32 => Price) prices;\r\n    **/\r\n\r\n\r\n    /// Total supply of CVC tokens.\r\n    uint256 constant private CVC_TOTAL_SUPPLY = 1e17;\r\n\r\n    /// The fallback price introduced to be returned when credential price is undefined.\r\n    /// The number is greater than CVC total supply, so it makes it impossible to transact with (e.g. place to escrow).\r\n    uint256 constant private FALLBACK_PRICE = CVC_TOTAL_SUPPLY + 1; // solium-disable-line zeppelin/no-arithmetic-operations\r\n\r\n    /// As zero price and undefined price are virtually indistinguishable,\r\n    /// a special value is introduced to represent zero price.\r\n    /// It equals to max unsigned integer which makes it impossible to transact with, hence should never be returned.\r\n    uint256 constant private ZERO_PRICE = ~uint256(0);\r\n\r\n    /**\r\n    * @dev Constructor\r\n    * @param _ontology CvcOntology contract address.\r\n    * @param _idvRegistry CvcValidatorRegistry contract address.\r\n    */\r\n    constructor(address _ontology, address _idvRegistry) public {\r\n        initialize(_ontology, _idvRegistry, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by unregistered IDV.\r\n     */\r\n    modifier onlyRegisteredValidator() {\r\n        require(idvRegistry().exists(msg.sender), \"Identity Validator is not registered\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the price for Credential Item of specific type, name and version.\r\n    * The price is associated with IDV address (sender).\r\n    * @param _credentialItemType Credential Item type.\r\n    * @param _credentialItemName Credential Item name.\r\n    * @param _credentialItemVersion Credential Item version.\r\n    * @param _price Credential Item price.\r\n    */\r\n    function setPrice(\r\n        string _credentialItemType,\r\n        string _credentialItemName,\r\n        string _credentialItemVersion,\r\n        uint256 _price\r\n    )\r\n        external\r\n        onlyRegisteredValidator\r\n        whenNotPaused\r\n    {\r\n        // Check price value upper bound.\r\n        require(_price <= CVC_TOTAL_SUPPLY, \"Price value cannot be more than token total supply\");\r\n\r\n        // Check Credential Item ID to verify existence.\r\n        bytes32 credentialItemId;\r\n        bool deprecated;\r\n        (credentialItemId, , , , , , , deprecated) = ontology().getByTypeNameVersion(\r\n            _credentialItemType,\r\n            _credentialItemName,\r\n            _credentialItemVersion\r\n        );\r\n        // Prevent setting price for unknown credential items.\r\n        require(credentialItemId != 0x0, \"Cannot set price for unknown credential item\");\r\n        require(deprecated == false, \"Cannot set price for deprecated credential item\");\r\n\r\n        // Calculate price ID.\r\n        bytes32 id = calculateId(msg.sender, credentialItemId);\r\n\r\n        // Register new record (when price record has no associated Credential Item ID).\r\n        if (getPriceCredentialItemId(id) == 0x0) {\r\n            registerNewRecord(id);\r\n        }\r\n\r\n        // Save the price.\r\n        setPriceIdv(id, msg.sender);\r\n        setPriceCredentialItemId(id, credentialItemId);\r\n        setPriceValue(id, _price);\r\n\r\n        emit CredentialItemPriceSet(\r\n            id,\r\n            _price,\r\n            msg.sender,\r\n            _credentialItemType,\r\n            _credentialItemName,\r\n            _credentialItemVersion,\r\n            credentialItemId\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Deletes the price for Credential Item of specific type, name and version.\r\n    * @param _credentialItemType Credential Item type.\r\n    * @param _credentialItemName Credential Item name.\r\n    * @param _credentialItemVersion Credential Item version.\r\n    */\r\n    function deletePrice(\r\n        string _credentialItemType,\r\n        string _credentialItemName,\r\n        string _credentialItemVersion\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Lookup Credential Item.\r\n        bytes32 credentialItemId;\r\n        (credentialItemId, , , , , , ,) = ontology().getByTypeNameVersion(\r\n            _credentialItemType,\r\n            _credentialItemName,\r\n            _credentialItemVersion\r\n        );\r\n\r\n        // Calculate Price ID to address individual data items.\r\n        bytes32 id = calculateId(msg.sender, credentialItemId);\r\n\r\n        // Ensure the price existence. Check whether Credential Item is associated.\r\n        credentialItemId = getPriceCredentialItemId(id);\r\n        require(credentialItemId != 0x0, \"Cannot delete unknown price record\");\r\n\r\n        // Delete the price data.\r\n        deletePriceIdv(id);\r\n        deletePriceCredentialItemId(id);\r\n        deletePriceValue(id);\r\n\r\n        unregisterRecord(id);\r\n\r\n        emit CredentialItemPriceDeleted(\r\n            id,\r\n            msg.sender,\r\n            _credentialItemType,\r\n            _credentialItemName,\r\n            _credentialItemVersion,\r\n            credentialItemId\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the price set by IDV for Credential Item of specific type, name and version.\r\n    * @param _idv IDV address.\r\n    * @param _credentialItemType Credential Item type.\r\n    * @param _credentialItemName Credential Item name.\r\n    * @param _credentialItemVersion Credential Item version.\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPrice(\r\n        address _idv,\r\n        string _credentialItemType,\r\n        string _credentialItemName,\r\n        string _credentialItemVersion\r\n    )\r\n        external\r\n        view\r\n        onlyInitialized\r\n        returns (\r\n            bytes32 id,\r\n            uint256 price,\r\n            address idv,\r\n            string credentialItemType,\r\n            string credentialItemName,\r\n            string credentialItemVersion,\r\n            bool deprecated\r\n        )\r\n    {\r\n        // Lookup Credential Item.\r\n        bytes32 credentialItemId;\r\n        (credentialItemId, credentialItemType, credentialItemName, credentialItemVersion, , , , deprecated) = ontology().getByTypeNameVersion(\r\n            _credentialItemType,\r\n            _credentialItemName,\r\n            _credentialItemVersion\r\n        );\r\n        idv = _idv;\r\n        id = calculateId(idv, credentialItemId);\r\n        price = getPriceValue(id);\r\n        if (price == FALLBACK_PRICE) {\r\n            return (0x0, price, 0x0, \"\", \"\", \"\", false);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the price by Credential Item ID.\r\n    * @param _idv IDV address.\r\n    * @param _credentialItemId Credential Item ID.\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPriceByCredentialItemId(address _idv, bytes32 _credentialItemId) external view returns (\r\n        bytes32 id,\r\n        uint256 price,\r\n        address idv,\r\n        string credentialItemType,\r\n        string credentialItemName,\r\n        string credentialItemVersion,\r\n        bool deprecated\r\n    ) {\r\n        return getPriceById(calculateId(_idv, _credentialItemId));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns all Credential Item prices.\r\n    * @return CredentialItemPrice[]\r\n    */\r\n    function getAllPrices() external view onlyInitialized returns (CredentialItemPrice[]) {\r\n        uint256 count = getCount();\r\n        CredentialItemPrice[] memory prices = new CredentialItemPrice[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            bytes32 id = getRecordId(i);\r\n            bytes32 credentialItemId = getPriceCredentialItemId(id);\r\n            string memory credentialItemType;\r\n            string memory credentialItemName;\r\n            string memory credentialItemVersion;\r\n            bool deprecated;\r\n\r\n            (, credentialItemType, credentialItemName, credentialItemVersion, , , , deprecated) = ontology().getById(credentialItemId);\r\n\r\n            prices[i] = CredentialItemPrice(\r\n                id,\r\n                getPriceValue(id),\r\n                getPriceIdv(id),\r\n                credentialItemType,\r\n                credentialItemName,\r\n                credentialItemVersion,\r\n                deprecated\r\n            );\r\n        }\r\n\r\n        return prices;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all IDs of registered Credential Item prices.\r\n     * @return bytes32[]\r\n     */\r\n    function getAllIds() external view onlyInitialized returns(bytes32[]) {\r\n        uint256 count = getCount();\r\n        bytes32[] memory ids = new bytes32[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            ids[i] = getRecordId(i);\r\n        }\r\n\r\n        return ids;\r\n    }\r\n\r\n    /**\r\n    * @dev Contract initialization method.\r\n    * @param _ontology CvcOntology contract address.\r\n    * @param _idvRegistry CvcValidatorRegistry contract address.\r\n    * @param _owner Owner address\r\n    */\r\n    function initialize(address _ontology, address _idvRegistry, address _owner) public initializes {\r\n        require(AddressUtils.isContract(_ontology), \"Initialization error: no contract code at ontology contract address\");\r\n        require(AddressUtils.isContract(_idvRegistry), \"Initialization error: no contract code at IDV registry contract address\");\r\n        // cvcOntology = _ontology;\r\n        addressStorage[keccak256(\"cvc.ontology\")] = _ontology;\r\n        // idvRegistry = _idvRegistry;\r\n        addressStorage[keccak256(\"cvc.idv.registry\")] = _idvRegistry;\r\n        // Initialize current implementation owner address.\r\n        setOwner(_owner);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the price by ID.\r\n    * @param _id Price ID\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPriceById(bytes32 _id) public view onlyInitialized returns (\r\n        bytes32 id,\r\n        uint256 price,\r\n        address idv,\r\n        string credentialItemType,\r\n        string credentialItemName,\r\n        string credentialItemVersion,\r\n        bool deprecated\r\n    ) {\r\n        // Always return price (could be a fallback price when not set).\r\n        price = getPriceValue(_id);\r\n        // Check whether Credential Item is associated. This is mandatory requirement for all existing prices.\r\n        bytes32 credentialItemId = getPriceCredentialItemId(_id);\r\n        if (credentialItemId != 0x0) {\r\n            // Return ID and IDV address for existing entry only.\r\n            id = _id;\r\n            idv = getPriceIdv(_id);\r\n\r\n            (, credentialItemType, credentialItemName, credentialItemVersion, , , , deprecated) = ontology().getById(credentialItemId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns instance of CvcOntologyInterface.\r\n    * @return CvcOntologyInterface\r\n    */\r\n    function ontology() public view returns (CvcOntologyInterface) {\r\n        // return CvcOntologyInterface(cvcOntology);\r\n        return CvcOntologyInterface(addressStorage[keccak256(\"cvc.ontology\")]);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns instance of CvcValidatorRegistryInterface.\r\n    * @return CvcValidatorRegistryInterface\r\n    */\r\n    function idvRegistry() public view returns (CvcValidatorRegistryInterface) {\r\n        // return CvcValidatorRegistryInterface(idvRegistry);\r\n        return CvcValidatorRegistryInterface(addressStorage[keccak256(\"cvc.idv.registry\")]);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns price record count.\r\n    * @return uint256\r\n    */\r\n    function getCount() internal view returns (uint256) {\r\n        // return pricesCount;\r\n        return uintStorage[keccak256(\"prices.count\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Increments price record counter.\r\n    */\r\n    function incrementCount() internal {\r\n        // pricesCount = getCount().add(1);\r\n        uintStorage[keccak256(\"prices.count\")] = getCount().add(1);\r\n    }\r\n\r\n    /**\r\n    * @dev Decrements price record counter.\r\n    */\r\n    function decrementCount() internal {\r\n        // pricesCount = getCount().sub(1);\r\n        uintStorage[keccak256(\"prices.count\")] = getCount().sub(1);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns price ID by index.\r\n    * @param _index Price record index.\r\n    * @return bytes32\r\n    */\r\n    function getRecordId(uint256 _index) internal view returns (bytes32) {\r\n        // return pricesIds[_index];\r\n        return bytes32Storage[keccak256(abi.encodePacked(\"prices.ids.\", _index))];\r\n    }\r\n\r\n    /**\r\n    * @dev Index new price record.\r\n    * @param _id The price ID.\r\n    */\r\n    function registerNewRecord(bytes32 _id) internal {\r\n        bytes32 indexSlot = keccak256(abi.encodePacked(\"prices.indices.\", _id));\r\n        // Prevent from registering same ID twice.\r\n        // require(pricesIndices[_id] == 0);\r\n        require(uintStorage[indexSlot] == 0, \"Integrity error: price with the same ID is already registered\");\r\n\r\n        uint256 index = getCount();\r\n        // Store record ID against index.\r\n        // pricesIds[index] = _id;\r\n        bytes32Storage[keccak256(abi.encodePacked(\"prices.ids.\", index))] = _id;\r\n        // Maintain reversed index to ID mapping to ensure O(1) deletion.\r\n        // Store n+1 value and reserve zero value for not indexed records.\r\n        uintStorage[indexSlot] = index.add(1);\r\n        incrementCount();\r\n    }\r\n\r\n    /**\r\n    * @dev Deletes price record from index.\r\n    * @param _id The price ID.\r\n    */\r\n    function unregisterRecord(bytes32 _id) internal {\r\n        // Since the order of price records is not guaranteed, we can make deletion more efficient\r\n        // by replacing record we want to delete with the last record, hence avoid reindex.\r\n\r\n        // Calculate deletion record ID slot.\r\n        bytes32 deletionIndexSlot = keccak256(abi.encodePacked(\"prices.indices.\", _id));\r\n        // uint256 deletionIndex = pricesIndices[_id].sub(1);\r\n        uint256 deletionIndex = uintStorage[deletionIndexSlot].sub(1);\r\n        bytes32 deletionIdSlot = keccak256(abi.encodePacked(\"prices.ids.\", deletionIndex));\r\n\r\n        // Calculate last record ID slot.\r\n        uint256 lastIndex = getCount().sub(1);\r\n        bytes32 lastIdSlot = keccak256(abi.encodePacked(\"prices.ids.\", lastIndex));\r\n\r\n        // Calculate last record index slot.\r\n        bytes32 lastIndexSlot = keccak256(abi.encodePacked(\"prices.indices.\", bytes32Storage[lastIdSlot]));\r\n\r\n        // Copy last record ID into the empty slot.\r\n        // pricesIds[deletionIdSlot] = pricesIds[lastIdSlot];\r\n        bytes32Storage[deletionIdSlot] = bytes32Storage[lastIdSlot];\r\n        // Make moved ID index point to the the correct record.\r\n        // pricesIndices[lastIndexSlot] = pricesIndices[deletionIndexSlot];\r\n        uintStorage[lastIndexSlot] = uintStorage[deletionIndexSlot];\r\n        // Delete last record ID.\r\n        // delete pricesIds[lastIndex];\r\n        delete bytes32Storage[lastIdSlot];\r\n        // Delete reversed index.\r\n        // delete pricesIndices[_id];\r\n        delete uintStorage[deletionIndexSlot];\r\n        decrementCount();\r\n    }\r\n    /**\r\n    * @dev Returns price value.\r\n    * @param _id The price ID.\r\n    * @return uint256\r\n    */\r\n    function getPriceValue(bytes32 _id) internal view returns (uint256) {\r\n        // uint256 value = prices[_id].value;\r\n        uint256 value = uintStorage[keccak256(abi.encodePacked(\"prices.\", _id, \".value\"))];\r\n        // Return fallback price if price is not set for existing Credential Item.\r\n        // Since we use special (non-zero) value for zero price, actual '0' means the price was never set.\r\n        if (value == 0) {\r\n            return FALLBACK_PRICE;\r\n        }\r\n        // Convert from special zero representation value.\r\n        if (value == ZERO_PRICE) {\r\n            return 0;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n    * @dev Saves price value.\r\n    * @param _id The price ID.\r\n    * @param _value The price value.\r\n    */\r\n    function setPriceValue(bytes32 _id, uint256 _value) internal {\r\n        // Save the price (convert to special zero representation value if necessary).\r\n        // prices[_id].value = (_value == 0) ? ZERO_PRICE : _value;\r\n        uintStorage[keccak256(abi.encodePacked(\"prices.\", _id, \".value\"))] = (_value == 0) ? ZERO_PRICE : _value;\r\n    }\r\n\r\n    /**\r\n    * @dev Deletes price value.\r\n    * @param _id The price ID.\r\n    */\r\n    function deletePriceValue(bytes32 _id) internal {\r\n        // delete prices[_id].value;\r\n        delete uintStorage[keccak256(abi.encodePacked(\"prices.\", _id, \".value\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Returns Credential Item ID the price is set for.\r\n    * @param _id The price ID.\r\n    * @return bytes32\r\n    */\r\n    function getPriceCredentialItemId(bytes32 _id) internal view returns (bytes32) {\r\n        // return prices[_id].credentialItemId;\r\n        return bytes32Storage[keccak256(abi.encodePacked(\"prices.\", _id, \".credentialItemId\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Saves price Credential Item ID\r\n    * @param _id The price ID.\r\n    * @param _credentialItemId Associated Credential Item ID.\r\n    */\r\n    function setPriceCredentialItemId(bytes32 _id, bytes32 _credentialItemId) internal {\r\n        // prices[_id].credentialItemId = _credentialItemId;\r\n        bytes32Storage[keccak256(abi.encodePacked(\"prices.\", _id, \".credentialItemId\"))] = _credentialItemId;\r\n    }\r\n\r\n    /**\r\n    * @dev Deletes price Credential Item ID.\r\n    * @param _id The price ID.\r\n    */\r\n    function deletePriceCredentialItemId(bytes32 _id) internal {\r\n        // delete prices[_id].credentialItemId;\r\n        delete bytes32Storage[keccak256(abi.encodePacked(\"prices.\", _id, \".credentialItemId\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Returns price IDV address.\r\n    * @param _id The price ID.\r\n    * @return address\r\n    */\r\n    function getPriceIdv(bytes32 _id) internal view returns (address) {\r\n        // return prices[_id].idv;\r\n        return addressStorage[keccak256(abi.encodePacked(\"prices.\", _id, \".idv\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Saves price IDV address.\r\n    * @param _id The price ID.\r\n    * @param _idv IDV address.\r\n    */\r\n    function setPriceIdv(bytes32 _id, address _idv) internal {\r\n        // prices[_id].idv = _idv;\r\n        addressStorage[keccak256(abi.encodePacked(\"prices.\", _id, \".idv\"))] = _idv;\r\n    }\r\n\r\n    /**\r\n    * @dev Deletes price IDV address.\r\n    * @param _id The price ID.\r\n    */\r\n    function deletePriceIdv(bytes32 _id) internal {\r\n        // delete prices[_id].idv;\r\n        delete addressStorage[keccak256(abi.encodePacked(\"prices.\", _id, \".idv\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates price ID.\r\n    * @param _idv IDV address.\r\n    * @param _credentialItemId Credential Item ID.\r\n    * @return bytes32\r\n    */\r\n    function calculateId(address _idv, bytes32 _credentialItemId) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_idv, \".\", _credentialItemId));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ontology\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPrices\",\"outputs\":[{\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"idv\",\"type\":\"address\"},{\"name\":\"credentialItemType\",\"type\":\"string\"},{\"name\":\"credentialItemName\",\"type\":\"string\"},{\"name\":\"credentialItemVersion\",\"type\":\"string\"},{\"name\":\"deprecated\",\"type\":\"bool\"}],\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_credentialItemType\",\"type\":\"string\"},{\"name\":\"_credentialItemName\",\"type\":\"string\"},{\"name\":\"_credentialItemVersion\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_credentialItemType\",\"type\":\"string\"},{\"name\":\"_credentialItemName\",\"type\":\"string\"},{\"name\":\"_credentialItemVersion\",\"type\":\"string\"}],\"name\":\"deletePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_credentialItemType\",\"type\":\"string\"},{\"name\":\"_credentialItemName\",\"type\":\"string\"},{\"name\":\"_credentialItemVersion\",\"type\":\"string\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"idv\",\"type\":\"address\"},{\"name\":\"credentialItemType\",\"type\":\"string\"},{\"name\":\"credentialItemName\",\"type\":\"string\"},{\"name\":\"credentialItemVersion\",\"type\":\"string\"},{\"name\":\"deprecated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idvRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_credentialItemId\",\"type\":\"bytes32\"}],\"name\":\"getPriceByCredentialItemId\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"idv\",\"type\":\"address\"},{\"name\":\"credentialItemType\",\"type\":\"string\"},{\"name\":\"credentialItemName\",\"type\":\"string\"},{\"name\":\"credentialItemVersion\",\"type\":\"string\"},{\"name\":\"deprecated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ontology\",\"type\":\"address\"},{\"name\":\"_idvRegistry\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getPriceById\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"idv\",\"type\":\"address\"},{\"name\":\"credentialItemType\",\"type\":\"string\"},{\"name\":\"credentialItemName\",\"type\":\"string\"},{\"name\":\"credentialItemVersion\",\"type\":\"string\"},{\"name\":\"deprecated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ontology\",\"type\":\"address\"},{\"name\":\"_idvRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"idv\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"credentialItemType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"credentialItemName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"credentialItemVersion\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"credentialItemId\",\"type\":\"bytes32\"}],\"name\":\"CredentialItemPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"idv\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"credentialItemType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"credentialItemName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"credentialItemVersion\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"credentialItemId\",\"type\":\"bytes32\"}],\"name\":\"CredentialItemPriceDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CvcPricing","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002dd784673c8a60571863407f94b5a873d3aa11a100000000000000000000000045a0410c3f486f578319a9be04ac6f2b91770e04","Library":"","SwarmSource":"bzzr://e070f4ed6e990fa6f278511c288c8a5ac676a27335b4b0712ff901461149ffdd"}]}