{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\nlibrary ArrayUtils {\r\n    \r\n    function removeByIdx(uint256[] array,uint256 idx) public pure returns(uint256[] memory){\r\n         uint256[] memory ans = copy(array,array.length-1);\r\n        while((idx+1) < array.length){\r\n            ans[idx] = array[idx+1];\r\n            idx++;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function copy(uint256[] array,uint256 len) public pure returns(uint256[] memory){\r\n        uint256[] memory ans = new uint256[](len);\r\n        len = len > array.length? array.length : len;\r\n        for(uint256 i =0;i<len;i++){\r\n            ans[i] = array[i];\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function getHash(uint256[] array) public pure returns(uint256) {\r\n        uint256 baseStep =100;\r\n        uint256 pow = 1;\r\n        uint256 ans = 0;\r\n        for(uint256 i=0;i<array.length;i++){\r\n            ans= ans+ uint256(array[i] *pow ) ;\r\n            pow= pow* baseStep;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function contains(address[] adrs,address adr)public pure returns(bool){\r\n        for(uint256 i=0;i<adrs.length;i++){\r\n            if(adrs[i] ==  adr) return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n}\r\n\r\nlibrary PlayerReply{\r\n    \r\n    using ArrayUtils for address[];\r\n    using ArrayUtils for uint256[];\r\n    \r\n    uint256 constant VISABLE_NONE = 0;\r\n    uint256 constant VISABLE_FINAL = 1;\r\n    uint256 constant VISABLE_ALL = 2;\r\n    uint256 constant VISABLE_OWNER = 3;\r\n    uint256 constant VISABLE_BUYED = 4;\r\n    \r\n    uint256 constant HIDE_TIME = 5*60;\r\n    \r\n    uint256 constant GRAND_TOTAL_TIME = 10*60;\r\n    \r\n    \r\n    struct Data{\r\n        address[] ownerIds;\r\n        uint256 aCount;\r\n        uint256 bCount;\r\n        uint256[] answer;\r\n        uint replyAt;\r\n    }\r\n    \r\n    struct List{\r\n        uint256 size;\r\n        mapping (uint256 => uint256) hashIds;\r\n        mapping (uint256 => Data) map;\r\n        mapping (uint256=>uint256) sellPriceMap;\r\n        mapping (uint256=>address) seller;\r\n        mapping (uint256=>address[]) buyer;\r\n    }\r\n    \r\n    \r\n    function init(Data storage d,uint256 ac,uint256 bc,address own) internal{\r\n          d.ownerIds.push(own)  ;\r\n          d.aCount = ac;\r\n          d.bCount = bc;\r\n          d.replyAt = now;\r\n    }\r\n    \r\n    function clear(List storage ds) internal{\r\n        for(uint256 i =0;i<ds.size;i++){\r\n            uint256 key = ds.hashIds[i];\r\n            delete ds.map[key];\r\n            delete ds.sellPriceMap[key];\r\n            delete ds.seller[key];\r\n            delete ds.buyer[key];\r\n            delete ds.hashIds[i];\r\n        }\r\n        ds.size = 0;\r\n    }\r\n    \r\n    function setSellPrice(List storage ds,uint256 ansHash,uint256 price) internal {\r\n        require(ds.map[ansHash].ownerIds.contains(msg.sender));\r\n        require(ds.seller[ansHash] == address(0));\r\n        ds.seller[ansHash] = msg.sender;\r\n        ds.sellPriceMap[ansHash] = price;\r\n    }\r\n    \r\n    function getSellPrice(List storage ds,uint256 idx) public view returns(uint256) {\r\n        return ds.sellPriceMap[ds.hashIds[idx]] ;\r\n    }\r\n    \r\n    function isOwner(Data storage d) internal view returns(bool){\r\n        return d.replyAt>0 && d.answer.length>0 && d.ownerIds.contains(msg.sender);\r\n    }\r\n    \r\n    function isWined(Data storage d) internal view returns(bool){\r\n        return d.replyAt>0 && d.answer.length>0 && d.aCount == d.answer.length ;\r\n    }\r\n    \r\n    function getWin(List storage ds) internal view returns(Data storage lastAns){\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            Data storage d = get(ds,i);\r\n           if(isWined(d)){\r\n             return d;  \r\n           } \r\n        }\r\n        \r\n        return lastAns;\r\n    }\r\n    \r\n    function getVisibleType(List storage ds,uint256 ansHash) internal view returns(uint256) {\r\n        Data storage d = ds.map[ansHash];\r\n        if(d.ownerIds.contains(msg.sender)){\r\n            return VISABLE_OWNER;\r\n        }else if(d.answer.length == d.aCount){\r\n            return VISABLE_FINAL;\r\n        }else if(ds.buyer[ansHash].contains(msg.sender)){\r\n            return VISABLE_BUYED;\r\n        }else if((now - d.replyAt)> HIDE_TIME && ds.sellPriceMap[ansHash] == 0){\r\n            return VISABLE_ALL;\r\n        }\r\n        return VISABLE_NONE;\r\n    }\r\n    \r\n    function getReplay(List storage ds,uint256 idx) internal view returns(\r\n        uint256 ,//aCount;\r\n        uint256,// bCount;\r\n        uint256[],// answer;\r\n        uint,// Timeline;\r\n        uint256, // VisibleType\r\n        uint256, //sellPrice\r\n        uint256 //ansHash\r\n        ) {\r\n            uint256 ansHash = ds.hashIds[idx];\r\n            uint256 sellPrice = ds.sellPriceMap[ansHash];\r\n            Data storage d= ds.map[ansHash];\r\n            uint256 vt = getVisibleType(ds,ansHash);\r\n        return (\r\n            d.aCount,\r\n            d.bCount,\r\n            vt!=VISABLE_NONE ?  d.answer : new uint256[](0),\r\n            now-d.replyAt,\r\n            vt,\r\n            sellPrice,\r\n            vt!=VISABLE_NONE ? ansHash : 0\r\n        );\r\n    } \r\n    \r\n    function listBestScore(List storage ds) internal view returns(\r\n        uint256 aCount , //aCount    \r\n        uint256 bCount , //bCount\r\n        uint256 bestCount // Count\r\n        ){\r\n        uint256 sorce = 0;\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            Data storage d = get(ds,i);\r\n            uint256 curSore = (d.aCount *100) + d.bCount;\r\n            if(curSore > sorce){\r\n                aCount = d.aCount;\r\n                bCount = d.bCount;\r\n                sorce = curSore;\r\n                bestCount = 1;\r\n            }else if(curSore == sorce){\r\n                bestCount++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function getOrGenByAnwser(List storage ds,uint256[] ans) internal  returns(Data storage ){\r\n        uint256 ansHash = ans.getHash();\r\n        Data storage d = ds.map[ansHash];\r\n        if(d.answer.length>0) return d;\r\n        d.answer = ans;\r\n        ds.hashIds[ds.size] = ansHash;\r\n        ds.size ++;\r\n        return d;\r\n    }\r\n    \r\n    \r\n    function get(List storage ds,uint256 idx) public view returns(Data storage){\r\n        return ds.map[ ds.hashIds[idx]];\r\n    }\r\n    \r\n    function getByHash(List storage ds ,uint256 ansHash)public view returns(Data storage){\r\n        return ds.map[ansHash];\r\n    }\r\n    \r\n    \r\n    function getLastReplyAt(List storage list) internal view returns(uint256){\r\n        return list.size>0 ? (now- get(list,list.size-1).replyAt) : 0;\r\n    }\r\n    \r\n    function getLastReply(List storage ds) internal view returns(Data storage d){\r\n        if( ds.size>0){\r\n            return get(ds,ds.size-1);\r\n        }\r\n        return d;\r\n    }    \r\n    \r\n    function countByGrand(List storage ds) internal view returns(uint256) {\r\n        if(ds.size == 0 ) return 0;\r\n        uint256 count = 0;\r\n        uint256 _lastAt = now;\r\n        uint256 lastIdx = ds.size-1;\r\n        Data memory d = get(ds,lastIdx-count);\r\n        while((_lastAt - d.replyAt)<= GRAND_TOTAL_TIME ){\r\n            count++;\r\n            _lastAt = d.replyAt;\r\n            if(count>lastIdx) return count;\r\n            d = get(ds,lastIdx-count);\r\n        }\r\n        return count;       \r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"ds\",\"type\":\"PlayerReply.List storage\"},{\"name\":\"ansHash\",\"type\":\"uint256\"}],\"name\":\"getByHash\",\"outputs\":[{\"name\":\"\",\"type\":\"PlayerReply.Data storage\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ds\",\"type\":\"PlayerReply.List storage\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"\",\"type\":\"PlayerReply.Data storage\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ds\",\"type\":\"PlayerReply.List storage\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PlayerReply","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://db5cbe6d31867d1216ce1251b0bbdcc57e59e4ead0369c1958207ce6af7d7431"}]}