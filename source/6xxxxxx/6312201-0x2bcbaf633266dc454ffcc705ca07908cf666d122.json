{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract I4D_Contract{\r\n    using SafeMath for uint256;\r\n    \r\n    ///////////////////////////////////////////////////////////////////////////////\r\n    // Attributes set.\r\n    string public name = \"I4D\";\r\n    uint256 public tokenPrice = 0.01 ether;\r\n    uint256 public mintax = 0.003 ether; // about 1 USD\r\n    uint16[3] public Gate = [10, 100, 1000];\r\n    uint8[4] public commissionRate = [1, 2, 3, 4];\r\n    uint256 public newPlayerFee=0.1 ether;\r\n    bytes32 internal SuperAdmin_id = 0x0eac2ad3c8c41367ba898b18b9f85aab3adac98f5dfc76fafe967280f62987b4;\r\n    \r\n    ///////////////////////////////////////////////////////////////////////////////\r\n    // Data stored.\r\n    uint256 internal administratorETH;\r\n    uint256 public totalTokenSupply;\r\n    uint256 internal DivsSeriesSum;\r\n    mapping(bytes32 => bool) public administrators;  // type of byte32, keccak256 of address\r\n    mapping(address=>uint256) public tokenBalance;\r\n    mapping(address=>address) public highlevel;\r\n    mapping(address=>address) public rightbrother;\r\n    mapping(address=>address) public leftchild;\r\n    mapping(address=>uint256) public deltaDivsSum;\r\n    mapping(address=>uint256) public commission;\r\n    mapping(address=>uint256) public withdrawETH;\r\n    \r\n\r\n    constructor() public{\r\n        administrators[SuperAdmin_id] = true;\r\n        \r\n    }\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////\r\n    // modifier and Events\r\n    modifier onlyAdmin(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(_customerAddress)]);\r\n        _;\r\n    }\r\n    modifier onlyTokenholders() {\r\n        require(tokenBalance[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    event onEthSell(\r\n        address indexed customerAddress,\r\n        uint256 ethereumEarned\r\n    );\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    event testOutput(\r\n        uint256 ret\r\n    );\r\n    event taxOutput(\r\n        uint256 tax,\r\n        uint256 sumoftax\r\n    );\r\n    \r\n    \r\n    ///////////////////////////////////////////////////////////////////////////////\r\n    //Administrator api\r\n    function withdrawAdministratorETH(uint256 amount)\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        address administrator = msg.sender;\r\n        require(amount<=administratorETH,\"Too much\");\r\n        administratorETH = administratorETH.sub(amount);\r\n        administrator.transfer(amount);\r\n    }\r\n    \r\n    function getAdministratorETH()\r\n        public\r\n        onlyAdmin()\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return administratorETH;\r\n    }\r\n    \r\n    /** add Adimin here\r\n     * you can not change status of  super administrator.\r\n     */\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n        onlyAdmin()\r\n        public\r\n    {\r\n        require(_identifier!=SuperAdmin_id);\r\n        administrators[_identifier] = _status;\r\n    }\r\n    \r\n    \r\n    function setName(string _name)\r\n        onlyAdmin()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n    \r\n    /////////////////////////////////////////////////////////////////////////////\r\n    function setTokenValue(uint256 _value)\r\n        onlyAdmin()\r\n        public\r\n    {\r\n        // we may increase our token price.\r\n        require(_value > tokenPrice);\r\n        tokenPrice = _value;\r\n    }\r\n    \r\n    ///////////////////////////////////////////////////////////////////////////////\r\n    // Player api.\r\n    \r\n    /** \r\n     * api of buy tokens.\r\n     */\r\n    function buy(address _referredBy)\r\n        public\r\n        payable\r\n        returns(uint256)\r\n    {\r\n        PurchaseTokens(msg.value, _referredBy);\r\n    }\r\n    \r\n    /**\r\n     * reinvest your profits to puchase more tokens.\r\n     */\r\n    function reinvest(uint256 reinvestAmount)\r\n    onlyTokenholders()\r\n    public\r\n    {\r\n        require(reinvestAmount>=1,\"At least 1 Token!\");\r\n        address _customerAddress = msg.sender;\r\n        require(getReinvestableTokenAmount(_customerAddress)>=reinvestAmount,\"You DO NOT have enough ETH!\");\r\n        withdrawETH[_customerAddress] = withdrawETH[_customerAddress].add(reinvestAmount*tokenPrice);\r\n        uint256 tokens = PurchaseTokens(reinvestAmount.mul(tokenPrice), highlevel[_customerAddress]);\r\n        \r\n        ///////////////////\r\n        emit onReinvestment(_customerAddress,tokens*tokenPrice,tokens);\r\n    }\r\n    \r\n    /**\r\n     * withdraw the profits(include commissions and divs).\r\n     */\r\n    function withdraw(uint256 _amountOfEths)\r\n    public\r\n    onlyTokenholders()\r\n    {\r\n        address _customerAddress=msg.sender;\r\n        uint256 eth_all = getWithdrawableETH(_customerAddress);\r\n        require(eth_all >= _amountOfEths);\r\n        withdrawETH[_customerAddress] = withdrawETH[_customerAddress].add(_amountOfEths);\r\n        _customerAddress.transfer(_amountOfEths);\r\n        emit onEthSell(_customerAddress,_amountOfEths);\r\n        \r\n        //sell logic here\r\n    }\r\n    \r\n    // some view functions to get your information.\r\n    function getMaxLevel(address _customerAddress, uint16 cur_level)\r\n    public\r\n    view\r\n    returns(uint32)\r\n    {\r\n        address children = leftchild[_customerAddress];\r\n        uint32 maxlvl = cur_level;\r\n        while(children!=0x0000000000000000000000000000000000000000){\r\n            uint32 child_lvl = getMaxLevel(children, cur_level+1);\r\n            if(maxlvl < child_lvl){\r\n                maxlvl = child_lvl;\r\n            }\r\n            children = rightbrother[children];\r\n        }\r\n        return maxlvl;\r\n    }\r\n    \r\n    function getTotalNodeCount(address _customerAddress)\r\n    public\r\n    view\r\n    returns(uint32)\r\n    {\r\n        uint32 ctr=1;\r\n        address children = leftchild[_customerAddress];\r\n        while(children!=0x0000000000000000000000000000000000000000){\r\n            ctr += getTotalNodeCount(children);\r\n            children = rightbrother[children];\r\n        }\r\n        return ctr;\r\n    }\r\n    \r\n    function getMaxProfitAndtoken(address[] playerList)\r\n    public\r\n    view\r\n    returns(uint256[],uint256[],address[])\r\n    {\r\n        uint256 len=playerList.length;\r\n        uint256 i;\r\n        uint256 Profit;\r\n        uint256 token;\r\n        address hl;\r\n        uint[] memory ProfitList=new uint[](len);\r\n        uint[] memory tokenList=new uint[](len);\r\n        address[] memory highlevelList=new address[](len);\r\n        for(i=0;i<len;i++)\r\n        {\r\n            Profit=getTotalProfit(playerList[i]);\r\n            token=tokenBalance[playerList[i]];\r\n            hl=highlevel[playerList[i]];\r\n            ProfitList[i]=Profit;\r\n            tokenList[i]=token;\r\n            highlevelList[i]=hl;\r\n        }\r\n        return (ProfitList,tokenList,highlevelList);\r\n    }\r\n    function getReinvestableTokenAmount(address _customerAddress)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return getWithdrawableETH(_customerAddress).div(tokenPrice);\r\n    }\r\n    \r\n    /**\r\n     * Total profit = your withdrawable ETH + ETHs you have withdrew.\r\n     */\r\n    function getTotalProfit(address _customerAddress)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return commission[_customerAddress].add(DivsSeriesSum.sub(deltaDivsSum[_customerAddress]).mul(tokenBalance[_customerAddress])/10*3);\r\n    }\r\n    \r\n    function getWithdrawableETH(address _customerAddress)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 divs = DivsSeriesSum.sub(deltaDivsSum[_customerAddress]).mul(tokenBalance[_customerAddress])/10*3;\r\n        return commission[_customerAddress].add(divs).sub(withdrawETH[_customerAddress]);\r\n    }\r\n    \r\n    function getTokenBalance()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n    address _address = msg.sender;\r\n    return tokenBalance[_address];\r\n    }\r\n    \r\n    function getContractBalance()public view returns (uint) {\r\n        return address(this).balance;\r\n    }  \r\n    \r\n    /**\r\n     * get your commission rate by your token held.\r\n     */\r\n    function getCommissionRate(address _customerAddress)\r\n    public\r\n    view\r\n    returns(uint8)\r\n    {\r\n        if(tokenBalance[_customerAddress]<1){\r\n            return 0;\r\n        }\r\n        uint8 i;\r\n        for(i=0; i<Gate.length; i++){\r\n            if(tokenBalance[_customerAddress]<Gate[i]){\r\n                break;\r\n            }\r\n        }\r\n        return commissionRate[i];\r\n    }\r\n    \r\n    \r\n    ///////////////////////////////////////////////////////////////////////////////\r\n    // functions to calculate commissions and divs when someone purchase some tokens.\r\n    \r\n    /**\r\n     * api for buying tokens.\r\n     */\r\n    function PurchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n        internal\r\n        returns(uint256)\r\n    {   \r\n        /////////////////////////////////\r\n        address _customerAddress=msg.sender;\r\n        uint256 numOfToken;\r\n        require(_referredBy==0x0000000000000000000000000000000000000000 || tokenBalance[_referredBy] > 0);\r\n        if(tokenBalance[_customerAddress] > 0)\r\n        {\r\n            require(_incomingEthereum >= tokenPrice,\"ETH is NOT enough\");\r\n            require(_incomingEthereum % tokenPrice ==0);\r\n            require(highlevel[_customerAddress] == _referredBy);\r\n            numOfToken = ETH2Tokens(_incomingEthereum);\r\n        }\r\n        else\r\n        {\r\n            //New player without a inviter will be taxed for newPlayerFee, and this value can be changed by administrator\r\n            if(_referredBy==0x0000000000000000000000000000000000000000 || _referredBy==_customerAddress)\r\n            {\r\n                require(_incomingEthereum >= newPlayerFee+tokenPrice,\"ETH is NOT enough\");\r\n                require((_incomingEthereum-newPlayerFee) % tokenPrice ==0);\r\n                _incomingEthereum -= newPlayerFee;\r\n                numOfToken = ETH2Tokens(_incomingEthereum);\r\n                highlevel[_customerAddress] = 0x0000000000000000000000000000000000000000;\r\n                administratorETH = administratorETH.add(newPlayerFee);\r\n            }\r\n            else\r\n            {\r\n                // new player with invite address.\r\n                require(_incomingEthereum >= tokenPrice,\"ETH is NOT enough\");\r\n                require(_incomingEthereum % tokenPrice ==0);\r\n                numOfToken = ETH2Tokens(_incomingEthereum);\r\n                highlevel[_customerAddress] = _referredBy;\r\n                addMember(_referredBy,_customerAddress);\r\n            }\r\n            commission[_customerAddress] = 0;\r\n        }\r\n        calDivs(_customerAddress,numOfToken);\r\n        calCommission(_incomingEthereum,_customerAddress);\r\n        emit onTokenPurchase(_customerAddress,_incomingEthereum,numOfToken,_referredBy); \r\n        return numOfToken;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Calculate the dividends of the members hold tokens.\r\n     * There are two methods to calculate the dividends.\r\n     * We chose the second method for you that you can get more divs.\r\n     */\r\n    function calDivs(address customer,uint256 num)\r\n    internal\r\n    {\r\n        // Approach 1.\r\n        // Use harmonic series to cal player divs. This is a precise algorithm.\r\n        // Approach 2.\r\n        // Simplify the \"for loop\" of approach 1.\r\n        // You can get more divs than approach 1 when you buy more than 1 token at one time.\r\n        // cal average to avoid overflow.\r\n        uint256 average_before = deltaDivsSum[customer].mul(tokenBalance[customer]) / tokenBalance[customer].add(num);\r\n        uint256 average_delta = DivsSeriesSum.mul(num) / (num + tokenBalance[customer]);\r\n        deltaDivsSum[customer] = average_before.add(average_delta);\r\n        DivsSeriesSum = DivsSeriesSum.add(tokenPrice.mul(num) / totalTokenSupply.add(num));\r\n        totalTokenSupply += num;\r\n        tokenBalance[customer] = num.add(tokenBalance[customer]);\r\n    }\r\n    \r\n    /**\r\n     * Calculate the commissions of your inviters.\r\n     */\r\n    function calCommission(uint256 _incomingEthereum,address _customerAddress)\r\n        internal \r\n        returns(uint256)\r\n    {\r\n        address _highlevel=highlevel[_customerAddress];\r\n        uint256 tax;\r\n        uint256 sumOftax=0;\r\n        uint8 i=0;\r\n        uint256 tax_chain=_incomingEthereum;\r\n        uint256 globalfee = _incomingEthereum.mul(3).div(10);\r\n        // The maximum deepth of tree you can get commission is 14. You can never get any eth from your children of more than 15 lvl.\r\n        for(i=1; i<=14; i++)\r\n        {\r\n            if(_highlevel==0x0000000000000000000000000000000000000000 || tokenBalance[_highlevel]==0){\r\n                break;\r\n            }\r\n            uint8 com_rate = getCommissionRate(_highlevel);\r\n            tax_chain = tax_chain.mul(com_rate).div(10);\r\n            if(tokenBalance[_highlevel]>=Gate[2]){\r\n                tax=mul_float_power(_incomingEthereum, i, com_rate, 10);\r\n            }\r\n            else{\r\n                tax=tax_chain;\r\n            }\r\n\r\n            // The minimum deepth of tree you can get commission is 2.\r\n            // If the deepth is higher than 2 and the tax is lower than mintax, you can never get any commission.\r\n            if(i>2 && tax <= mintax){\r\n                break;\r\n            }\r\n            commission[_highlevel] = commission[_highlevel].add(tax);\r\n            sumOftax = sumOftax.add(tax);\r\n            _highlevel = highlevel[_highlevel];\r\n            emit taxOutput(tax,sumOftax);\r\n        }\r\n        \r\n        if(sumOftax.add(globalfee) < _incomingEthereum)\r\n        {\r\n            administratorETH = _incomingEthereum.sub(sumOftax).sub(globalfee).add(administratorETH);\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * New player with inviter should add member to the group tree.\r\n     */\r\n    function addMember(address _referredBy,address _customer)\r\n    internal\r\n    {\r\n        require(tokenBalance[_referredBy] > 0);\r\n        if(leftchild[_referredBy]!=0x0000000000000000000000000000000000000000)\r\n        {\r\n            rightbrother[_customer] = leftchild[_referredBy];\r\n        }\r\n        leftchild[_referredBy] = _customer;\r\n    }\r\n    \r\n    function ETH2Tokens(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return _ethereum.div(tokenPrice);\r\n    }\r\n    \r\n    function Tokens2ETH(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return _tokens.mul(tokenPrice);\r\n    }\r\n    \r\n    /**\r\n     * Calculate x  *  (numerator / denominator) ** n\r\n     * Use \"For Loop\" to avoid overflow.\r\n     */\r\n    function mul_float_power(uint256 x, uint8 n, uint8 numerator, uint8 denominator)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 ret = x;\r\n        if(x==0 || numerator==0){\r\n            return 0;\r\n        }\r\n        for(uint8 i=0; i<n; i++){\r\n            ret = ret.mul(numerator).div(denominator);\r\n        }\r\n        return ret;\r\n\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getWithdrawableETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newPlayerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfEths\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAdministratorETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deltaDivsSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"leftchild\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerList\",\"type\":\"address[]\"}],\"name\":\"getMaxProfitAndtoken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"cur_level\",\"type\":\"uint16\"}],\"name\":\"getMaxLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getTotalNodeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getReinvestableTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rightbrother\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getTotalProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reinvestAmount\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"commission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setTokenValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Gate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commissionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdministratorETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getCommissionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"highlevel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onEthSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ret\",\"type\":\"uint256\"}],\"name\":\"testOutput\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tax\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sumoftax\",\"type\":\"uint256\"}],\"name\":\"taxOutput\",\"type\":\"event\"}]","ContractName":"I4D_Contract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1fdc8c52d549db3a04ca03fc618793e00692c5e421487a7975663820a270e52e"}]}