{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n\r\nThis is a King Of The Hill contract which requires Proof of Work (hashpower) to set the king\r\n\r\nThis global non-owned contract proxy-mints 0xBTC through a personally-owned mintHelper contract (MintHelper.sol)\r\n\r\n*/\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\ncontract ERC918Interface {\r\n\r\n  function epochCount() public constant returns (uint);\r\n\r\n  function totalSupply() public constant returns (uint);\r\n  function getMiningDifficulty() public constant returns (uint);\r\n  function getMiningTarget() public constant returns (uint);\r\n  function getMiningReward() public constant returns (uint);\r\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n\r\n  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\r\n\r\n  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n}\r\n\r\ncontract mintForwarderInterface\r\n{\r\n  function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool success);\r\n}\r\n\r\ncontract proxyMinterInterface\r\n{\r\n  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\r\n}\r\n\r\n\r\ncontract MiningKing   {\r\n\r\n\r\n  using SafeMath for uint;\r\n\r\n\r\n   address public miningKing;\r\n\r\n   address public minedToken;\r\n\r\n\r\n   event TransferKing(address from, address to);\r\n\r\n   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\r\n  constructor(address mintableToken) public  {\r\n    minedToken = mintableToken;\r\n  }\r\n\r\n\r\n  //do not allow ether to enter\r\n  function() public payable {\r\n      revert();\r\n  }\r\n\r\n  function getKing() view public returns (address king)\r\n  {\r\n    return miningKing;\r\n  }\r\n\r\n   function transferKing(address newKing) public   {\r\n\r\n       require(msg.sender == miningKing);\r\n\r\n       miningKing = newKing;\r\n\r\n       emit TransferKing(msg.sender, newKing);\r\n\r\n   }\r\n\r\n\r\n/**\r\nSet the king to the Ethereum Address which is encoded as 160 bits of the 256 bit mining nonce\r\n\r\n\r\n**/\r\n\r\n//proxyMintWithKing\r\n   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address[] proxyMintArray) public returns (bool)\r\n   {\r\n\r\n      require(proxyMintArray.length > 0);\r\n\r\n\r\n      uint previousEpochCount = ERC918Interface(minedToken).epochCount();\r\n\r\n      address proxyMinter = proxyMintArray[0];\r\n\r\n      if(proxyMintArray.length == 1)\r\n      {\r\n        //Forward to the last proxyMint contract, typically a pool's owned  mint contract\r\n        require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\r\n      }else{\r\n        //if array length is greater than 1, pop the proxyMinter from the front of the array and keep cascading down the chain...\r\n        address[] memory remainingProxyMintArray = popFirstFromArray(proxyMintArray);\r\n\r\n        require(mintForwarderInterface(proxyMinter).mintForwarder(nonce, challenge_digest,remainingProxyMintArray));\r\n      }\r\n\r\n     //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\r\n      require( ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\r\n\r\n\r\n\r\n\r\n      // UNIQUE CONTRACT ACTION SPACE \r\n      bytes memory nonceBytes = uintToBytesForAddress(nonce);\r\n\r\n      address newKing = bytesToAddress(nonceBytes);\r\n      \r\n      miningKing = newKing;\r\n      // --------\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n  function popFirstFromArray(address[] array) pure public returns (address[] memory)\r\n  {\r\n    address[] memory newArray = new address[](array.length-1);\r\n\r\n    for (uint i=0; i < array.length-1; i++) {\r\n      newArray[i] =  array[i+1]  ;\r\n    }\r\n\r\n    return newArray;\r\n  }\r\n\r\n function uintToBytesForAddress(uint256 x) pure public returns (bytes b) {\r\n\r\n      b = new bytes(20);\r\n      for (uint i = 0; i < 20; i++) {\r\n          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\r\n      }\r\n\r\n      return b;\r\n    }\r\n\r\n\r\n function bytesToAddress (bytes b) pure public returns (address) {\r\n     uint result = 0;\r\n     for (uint i = b.length-1; i+1 > 0; i--) {\r\n       uint c = uint(b[i]);\r\n       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n       result += to_inc;\r\n     }\r\n     return address(result);\r\n }\r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newKing\",\"type\":\"address\"}],\"name\":\"transferKing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"array\",\"type\":\"address[]\"}],\"name\":\"popFirstFromArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningKing\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"bytesToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKing\",\"outputs\":[{\"name\":\"king\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"uintToBytesForAddress\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"name\":\"proxyMintArray\",\"type\":\"address[]\"}],\"name\":\"mintForwarder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"mintableToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TransferKing\",\"type\":\"event\"}]","ContractName":"MiningKing","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b6ed7644c69416d67b522e20bc294a9a9b405b31","Library":"","SwarmSource":"bzzr://c5d36b0dd56ed8d70b2e13c1b1b14fc1c0102d9b5d03e0d3868398f19eb60c4a"}]}