{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ncontract CloneFactory {\r\n\r\n  event CloneCreated(address indexed target, address clone);\r\n\r\n  function createClone(address target) internal returns (address result) {\r\n    bytes memory clone = hex\"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\";\r\n    bytes20 targetBytes = bytes20(target);\r\n    for (uint i = 0; i < 20; i++) {\r\n      clone[20 + i] = targetBytes[i];\r\n    }\r\n    assembly {\r\n      let len := mload(clone)\r\n      let data := add(clone, 0x20)\r\n      result := create(0, data, len)\r\n    }\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract DeconetPaymentsSplitting {\r\n    using SafeMath for uint;\r\n\r\n    // Logged on this distribution set up completion.\r\n    event DistributionCreated (\r\n        address[] destinations,\r\n        uint[] sharesMantissa,\r\n        uint sharesExponent\r\n    );\r\n\r\n    // Logged when funds landed to or been sent out from this contract balance.\r\n    event FundsOperation (\r\n        address indexed senderOrAddressee,\r\n        uint amount,\r\n        FundsOperationType indexed operationType\r\n    );\r\n\r\n    // Enumeration of possible funds operations.\r\n    enum FundsOperationType { Incoming, Outgoing }\r\n\r\n    // Describes Distribution destination and its share of all incoming funds.\r\n    struct Distribution {\r\n        // Destination address of the distribution.\r\n        address destination;\r\n\r\n        // Floating-point number mantissa of a share allotted for a destination address.\r\n        uint mantissa;\r\n    }\r\n\r\n    // Stores exponent of a power term of a floating-point number.\r\n    uint public sharesExponent;\r\n\r\n    // Stores list of distributions.\r\n    Distribution[] public distributions;\r\n\r\n    /**\r\n     * @dev Payable fallback that tries to send over incoming funds to the distribution destinations splitted\r\n     * by pre-configured shares. In case when there is not enough gas sent for the transaction to complete\r\n     * distribution, all funds will be kept in contract untill somebody calls `withdrawFullContractBalance` to\r\n     * run postponed distribution and withdraw contract's balance funds.\r\n     */\r\n    function () public payable {\r\n        emit FundsOperation(msg.sender, msg.value, FundsOperationType.Incoming);\r\n        distributeFunds();\r\n    }\r\n\r\n    /**\r\n     * @dev Set up distribution for the current clone, can be called only once.\r\n     * @param _destinations Destination addresses of the current payments splitting contract clone.\r\n     * @param _sharesMantissa Mantissa values for destinations shares ordered respectively with `_destinations`.\r\n     * @param _sharesExponent Exponent of a power term that forms shares floating-point numbers, expected to\r\n     * be the same for all values in `_sharesMantissa`.\r\n     */\r\n    function setUpDistribution(\r\n        address[] _destinations,\r\n        uint[] _sharesMantissa,\r\n        uint _sharesExponent\r\n    )\r\n        external\r\n    {\r\n        require(distributions.length == 0, \"Contract can only be initialized once\"); // Make sure the clone isn't initialized yet.\r\n        require(_destinations.length <= 8 && _destinations.length > 0, \"There is a maximum of 8 destinations allowed\");  // max of 8 destinations\r\n        // prevent integer overflow when math with _sharesExponent happens\r\n        // also ensures that low balances can be distributed because balance must always be >= 10**(sharesExponent + 2)\r\n        require(_sharesExponent <= 4, \"The maximum allowed sharesExponent is 4\");\r\n        // ensure that lengths of arrays match so array out of bounds can't happen\r\n        require(_destinations.length == _sharesMantissa.length, \"Length of destinations does not match length of sharesMantissa\");\r\n\r\n        uint sum = 0;\r\n        for (uint i = 0; i < _destinations.length; i++) {\r\n            // Forbid contract as destination so that transfer can never fail\r\n            require(!isContract(_destinations[i]), \"A contract may not be a destination address\");\r\n            sum = sum.add(_sharesMantissa[i]);\r\n            distributions.push(Distribution(_destinations[i], _sharesMantissa[i]));\r\n        }\r\n         // taking into account 100% by adding 2 to the exponent.\r\n        require(sum == 10**(_sharesExponent.add(2)), \"The sum of all sharesMantissa should equal 10 ** ( _sharesExponent + 2 ) but it does not.\");\r\n        sharesExponent = _sharesExponent;\r\n        emit DistributionCreated(_destinations, _sharesMantissa, _sharesExponent);\r\n    }\r\n\r\n    /**\r\n     * @dev Process the available balance through the distribution and send money over to destination addresses.\r\n     */\r\n    function distributeFunds() public {\r\n        uint balance = address(this).balance;\r\n        require(balance >= 10**(sharesExponent.add(2)), \"You can not split up less wei than sum of all shares\");\r\n        for (uint i = 0; i < distributions.length; i++) {\r\n            Distribution memory distribution = distributions[i];\r\n            uint amount = calculatePayout(balance, distribution.mantissa, sharesExponent);\r\n            distribution.destination.transfer(amount);\r\n            emit FundsOperation(distribution.destination, amount, FundsOperationType.Outgoing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns length of distributions array\r\n     * @return Length of distributions array\r\n    */\r\n    function distributionsLength() public view returns (uint256) {\r\n        return distributions.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Calculates a share of the full amount.\r\n     * @param _fullAmount Full amount.\r\n     * @param _shareMantissa Mantissa of the percentage floating-point number.\r\n     * @param _shareExponent Exponent of the percentage floating-point number.\r\n     * @return An uint of the payout.\r\n     */\r\n    function calculatePayout(uint _fullAmount, uint _shareMantissa, uint _shareExponent) private pure returns(uint) {\r\n        return (_fullAmount.div(10 ** (_shareExponent.add(2)))).mul(_shareMantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether or not a given address contains a contract\r\n     * @param _addr The address to check\r\n     * @return A boolean indicating whether or not the address is a contract\r\n     */\r\n    function isContract(address _addr) private view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n}\r\n\r\ncontract DeconetPaymentsSplittingFactory is CloneFactory {\r\n\r\n    // PaymentsSplitting master-contract address.\r\n    address public libraryAddress;\r\n\r\n    // Logged when a new PaymentsSplitting clone is deployed to the chain.\r\n    event PaymentsSplittingCreated(address newCloneAddress);\r\n\r\n    /**\r\n     * @dev Constructor for the contract.\r\n     * @param _libraryAddress PaymentsSplitting master-contract address.\r\n     */\r\n    constructor(address _libraryAddress) public {\r\n        libraryAddress = _libraryAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Create PaymentsSplitting clone.\r\n     * @param _destinations Destination addresses of the new PaymentsSplitting contract clone.\r\n     * @param _sharesMantissa Mantissa values for destinations shares ordered respectively with `_destinations`.\r\n     * @param _sharesExponent Exponent of a power term that forms shares floating-point numbers, expected to\r\n     * be the same for all values in `_sharesMantissa`.\r\n     */\r\n    function createPaymentsSplitting(\r\n        address[] _destinations,\r\n        uint[] _sharesMantissa,\r\n        uint _sharesExponent\r\n    )\r\n        external\r\n        returns(address)\r\n    {\r\n        address clone = createClone(libraryAddress);\r\n        DeconetPaymentsSplitting(clone).setUpDistribution(_destinations, _sharesMantissa, _sharesExponent);\r\n        emit PaymentsSplittingCreated(clone);\r\n        return clone;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_destinations\",\"type\":\"address[]\"},{\"name\":\"_sharesMantissa\",\"type\":\"uint256[]\"},{\"name\":\"_sharesExponent\",\"type\":\"uint256\"}],\"name\":\"createPaymentsSplitting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"libraryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_libraryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newCloneAddress\",\"type\":\"address\"}],\"name\":\"PaymentsSplittingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"CloneCreated\",\"type\":\"event\"}]","ContractName":"DeconetPaymentsSplittingFactory","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a485a4bbbd026cf0c49844ef617bd4a913b2bc89","Library":"","SwarmSource":"bzzr://ee01b5edf5da977257ce2939ae666ca9a17c02c49d5b338af8c57d587df04357"}]}