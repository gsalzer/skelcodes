{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n  Gradual.pro - Плавно растущий и долго живущий умножитель БЕЗ КИТОВ!, который возвращает 121% от вашего депозита!\r\n\r\n  Маленький лимит на депозит избавляет от проблем с КИТАМИ, которые очень сильно тормозили предыдущую версию контракта и значительно продлевает срок его жизни!\r\n\r\n  Автоматические выплаты!\r\n  Полные отчеты о потраченых на рекламу средствах в группе!\r\n  Без ошибок, дыр, автоматический - для выплат НЕ НУЖНА администрация!\r\n  Создан и проверен профессионалами!\r\n  Код полностью документирован на русском языке, каждая строчка понятна!\r\n\r\n  Вебсайт: http://gradual.pro/\r\n  Группа в телеграмме: https://t.me/gradualpro\r\n\r\n  1. Пошлите любую ненулевую сумму на адрес контракта\r\n     - сумма от 0.01 до 2 ETH\r\n     - gas limit минимум 250000\r\n     - вы встанете в очередь\r\n  2. Немного подождите\r\n  3. ...\r\n  4. PROFIT! Вам пришло 121% от вашего депозита.\r\n\r\n  Как это возможно?\r\n  1. Первый инвестор в очереди (вы станете первым очень скоро) получает выплаты от\r\n     новых инвесторов до тех пор, пока не получит 121% от своего депозита\r\n  2. Выплаты могут приходить несколькими частями или все сразу\r\n  3. Как только вы получаете 121% от вашего депозита, вы удаляетесь из очереди\r\n  4. Вы можете делать несколько депозитов сразу\r\n  5. Баланс этого контракта должен обычно быть в районе 0, потому что все поступления\r\n     сразу же направляются на выплаты\r\n\r\n     Таким образом, последние платят первым, и инвесторы, достигшие выплат 121% от депозита,\r\n     удаляются из очереди, уступая место остальным\r\n\r\n              новый инвестор --|            совсем новый инвестор --|\r\n                 инвестор5     |                новый инвестор      |\r\n                 инвестор4     |     =======>      инвестор5        |\r\n                 инвестор3     |                   инвестор4        |\r\n (част. выплата) инвестор2    <|                   инвестор3        |\r\n(полная выплата) инвестор1   <-|                   инвестор2   <----|  (доплата до 121%)\r\n\r\n*/\r\n\r\ncontract GradualPro {\r\n    // Адрес кошелька первого проекта для продвижения очереди\r\n    address constant private FIRST_SUPPORT = 0xf8F04b23dACE12841343ecf0E06124354515cc42;\r\n\r\n    // Адрес кошелька для оплаты технической поддержки информационных каналов\r\n    address constant private TECH_SUPPORT = 0x988f1a2fb17414c95f45E2DAaaA40509F5C9088c;\r\n\r\n    // Процент депозита на первый проект 4%\r\n    uint constant public FIRST_PERCENT = 4;\r\n\r\n    // Процент депозита на тех поддержку 1%\r\n    uint constant public TECH_PERCENT = 1;\r\n    \r\n    // Процент выплат всем участникам\r\n    uint constant public MULTIPLIER = 121;\r\n\r\n    // Максимальная сумма депозита = 2 эфира, чтобы каждый смог учавстовать и киты не тормозили и не пугали вкладчиков\r\n    uint constant public MAX_LIMIT = 2 ether;\r\n\r\n    // Структура Deposit содержит информацию о депозите\r\n    struct Deposit {\r\n        address depositor; // Владелец депозита\r\n        uint128 deposit;   // Сумма депозита\r\n        uint128 expect;    // Сумма выплаты (моментально 121% от депозита)\r\n    }\r\n\r\n    // Очередь\r\n    Deposit[] private queue;\r\n\r\n    // Номер обрабатываемого депозита, можно следить в разделе Read contract\r\n    uint public currentReceiverIndex = 0;\r\n\r\n    // Данная функция получает все депозиты, сохраняет их и производит моментальные выплаты\r\n    function () public payable {\r\n        // Если сумма депозита больше нуля\r\n        if(msg.value > 0){\r\n            // Проверяем минимальный лимит газа 220 000, иначе отменяем депозит и возвращаем деньги вкладчику\r\n            require(gasleft() >= 220000, \"We require more gas!\");\r\n\r\n            // Проверяем максимальную сумму вклада\r\n            require(msg.value <= MAX_LIMIT, \"Deposit is too big\");\r\n\r\n            // Добавляем депозит в очередь, записываем что ему нужно выплатить 121% от суммы депозита\r\n            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * MULTIPLIER / 100)));\r\n\r\n            // Отправляем процент на продвижение проекта\r\n            uint ads = msg.value * FIRST_PERCENT / 100;\r\n            require(FIRST_SUPPORT.call.value(ads).gas(gasleft())());\r\n\r\n            // Отправляем процент на техническую поддержку проекта\r\n            uint tech = msg.value * TECH_PERCENT / 100;\r\n            TECH_SUPPORT.transfer(tech);\r\n\r\n            // Вызываем функцию оплаты первому в очереди депозиту\r\n            pay();\r\n        }\r\n    }\r\n\r\n    // Фукнция используется для оплаты первым в очереди депозитам\r\n    // Каждая новая транзация обрабатывает от 1 до 4+ вкладчиков в начале очереди \r\n    // В зависимости от оставшегося газа\r\n    function pay() private {\r\n        // Попытаемся послать все деньги имеющиеся на контракте первым в очереди вкладчикам\r\n        uint128 money = uint128(address(this).balance);\r\n\r\n        // Проходим по всей очереди\r\n        for(uint i = 0; i < queue.length; i++) {\r\n\r\n            uint idx = currentReceiverIndex + i;  // Достаем номер первого в очереди депозита\r\n\r\n            Deposit storage dep = queue[idx]; // Достаем информацию о первом депозите\r\n\r\n            if(money >= dep.expect) {  // Если у нас есть достаточно денег для полной выплаты, то выплачиваем ему все\r\n                dep.depositor.transfer(dep.expect); // Отправляем ему деньги\r\n                money -= dep.expect; // Обновляем количество оставшихся денег\r\n\r\n                // депозит был полностью выплачен, удаляем его\r\n                delete queue[idx];\r\n            } else {\r\n                // Попадаем сюда, если у нас не достаточно денег выплатить все, а лишь часть\r\n                dep.depositor.transfer(money); // Отправляем все оставшееся\r\n                dep.expect -= money;       // Обновляем количество оставшихся денег\r\n                break;                     // Выходим из цикла\r\n            }\r\n\r\n            if (gasleft() <= 50000)         // Проверяем если еще остался газ, и если его нет, то выходим из цикла\r\n                break;                     //  Следующий вкладчик осуществит выплату следующим в очереди\r\n        }\r\n\r\n        currentReceiverIndex += i; // Обновляем номер депозита ставшего первым в очереди\r\n    }\r\n\r\n    // Показывает информацию о депозите по его номеру (idx), можно следить в разделе Read contract\r\n    // Вы можете получить номер депозита  (idx) вызвав функцию getDeposits()\r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\r\n        Deposit storage dep = queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expect);\r\n    }\r\n\r\n    // Показывает количество вкладов определенного инвестора\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\r\n            if(queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    // Показывает все депозиты (index, deposit, expect) определенного инвестора, можно следить в разделе Read contract\r\n    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\r\n        uint c = getDepositsCount(depositor);\r\n\r\n        idxs = new uint[](c);\r\n        deposits = new uint128[](c);\r\n        expects = new uint128[](c);\r\n\r\n        if(c > 0) {\r\n            uint j = 0;\r\n            for(uint i=currentReceiverIndex; i<queue.length; ++i){\r\n                Deposit storage dep = queue[i];\r\n                if(dep.depositor == depositor){\r\n                    idxs[j] = i;\r\n                    deposits[j] = dep.deposit;\r\n                    expects[j] = dep.expect;\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Показывает длинну очереди, можно следить в разделе Read contract\r\n    function getQueueLength() public view returns (uint) {\r\n        return queue.length - currentReceiverIndex;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"name\":\"idxs\",\"type\":\"uint256[]\"},{\"name\":\"deposits\",\"type\":\"uint128[]\"},{\"name\":\"expects\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TECH_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"GradualPro","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://78c72b9a29ce8afd72ea443f81518f11af270b8d31b62c3ad27201c231b41571"}]}