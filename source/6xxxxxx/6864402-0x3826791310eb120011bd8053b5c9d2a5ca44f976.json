{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n    );\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract Margin {\r\n    using SafeMath for uint256;\r\n\r\n    address public tokenAddress;\r\n    mapping(address => uint256) marginBalances;\r\n    event DepositWithToken(address indexed from, uint256 amount);\r\n    event WithdrawMargin(address indexed from, uint256 amount);\r\n\r\n    /**\r\n    * @dev Gets the margin balance of the specified address.\r\n    * @param _investor The address to query the the margin balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function marginBalanceOf(address _investor) public view returns (uint256) {\r\n        return marginBalances[_investor];\r\n    }\r\n\r\n    /**\r\n    * @notice Submit a presigned transfer which transfer tokens to this contract\r\n    * @param _signature bytes The signature, issued by the owner.\r\n    * @param _value uint256 The amount of tokens to be transferred.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function depositWithToken(\r\n        bytes _signature,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(block.number <= _validUntil);\r\n        BCNTToken tokenContract = BCNTToken(tokenAddress);\r\n\r\n        bytes32 hashedTx = ECRecovery.toEthSignedMessageHash(\r\n          tokenContract.transferPreSignedHashing(tokenAddress, address(this), _value, _fee, _nonce, _validUntil)\r\n        );\r\n        address from = ECRecovery.recover(hashedTx, _signature);\r\n\r\n        uint256 prevBalance = tokenContract.balanceOf(address(this));\r\n        require(tokenContract.transferPreSigned(_signature, address(this), _value, _fee, _nonce, _validUntil));\r\n        require(tokenContract.transfer(msg.sender, _fee));\r\n        uint256 curBalance = tokenContract.balanceOf(address(this));\r\n        require(curBalance == prevBalance + _value);\r\n\r\n        marginBalances[from] = marginBalances[from].add(_value);\r\n\r\n        emit DepositWithToken(from, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Withdraw specified amount of margin\r\n    * @param _value uint256 The amount of margin to be withdrawn.\r\n    */\r\n    function withdrawMargin(\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        BCNTToken tokenContract = BCNTToken(tokenAddress);\r\n\r\n        marginBalances[msg.sender] = marginBalances[msg.sender].sub(_value);\r\n        require(tokenContract.transfer(msg.sender, _value));\r\n\r\n        emit WithdrawMargin(msg.sender, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract MarginWithPresignedWithdraw is Margin{\r\n    using SafeMath for uint256;\r\n\r\n    event WithdrawMarginPreSigned(address indexed from, address indexed delegate, uint256 amount, uint256 fee);\r\n\r\n    /**\r\n    * @notice Submit a presigned withdraw to withdraw specified amount of margin\r\n    * @param _signature bytes The signature, issued by the owner.\r\n    * @param _from address The address which request to withdraw.\r\n    * @param _value uint256 The amount of margin to be withdraw.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the requester.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function withdrawMarginPreSigned(\r\n        bytes _signature,\r\n        address _from,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(block.number <= _validUntil);\r\n\r\n        bytes32 hashedTx = ECRecovery.toEthSignedMessageHash(withdrawMarginPreSignedHashing(\r\n            address(this),\r\n            _from,\r\n            _value,\r\n            _fee,\r\n            _nonce,\r\n            _validUntil\r\n        ));\r\n        address from = ECRecovery.recover(hashedTx, _signature);\r\n        require(_from == from);\r\n\r\n        BCNTToken tokenContract = BCNTToken(tokenAddress);\r\n\r\n        marginBalances[_from] = marginBalances[_from].sub(_value).sub(_fee);\r\n        require(tokenContract.transfer(_from, _value));\r\n        require(tokenContract.transfer(msg.sender, _fee));\r\n\r\n        emit WithdrawMargin(_from, _value);\r\n        emit WithdrawMarginPreSigned(_from, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Hash (keccak256) of the payload used by withdrawMarginPreSigned\r\n    * @param _investContract address The address of the InvestContract.\r\n    * @param _from address The address which request to withdraw.\r\n    * @param _value uint256 The amount of margin to be withdraw.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the requester.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function withdrawMarginPreSignedHashing(\r\n        address _investContract,\r\n        address _from,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"7701c52d\": withdrawMarginPreSignedHashing(address,address,address,uint256,uint256,uint256,uint256) */\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                bytes4(0x7701c52d),\r\n                _investContract,\r\n                _from,\r\n                _value,\r\n                _fee,\r\n                _nonce,\r\n                _validUntil\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\ncontract Invest is MarginWithPresignedWithdraw{\r\n    using SafeMath for uint256;\r\n\r\n    address public tradeProfileImplementation;\r\n    address public bincentive;\r\n    address public bincentiveErrand;\r\n    mapping(address => mapping(bytes32 => address)) traderProfile;\r\n    mapping(bytes => bool) internal registerSignatures;\r\n    mapping(bytes => bool) internal transferSignatures;\r\n    mapping(bytes => bool) internal followTraderSignatures;\r\n    event UpdateBincentiveErrand(address indexed newBincentiveErrand);\r\n    event TradeProfileUpgraded(address indexed implementation);\r\n    event RegisterTradeProfile(address indexed trader, address indexed profileAddr);\r\n    event CloseTradeProfile(address indexed trader, address indexed profileAddr);\r\n    event FollowTrader(address indexed follower, address indexed trader, uint256 marginAmount);\r\n    event ClearTrade(address indexed follower, address indexed trader, uint256 investedAmount, int256 profitAmount, string causeToClear);\r\n\r\n    // Group the local variables together to prevent\r\n    // Compiler error: Stack too deep, try removing local variables.\r\n    struct LocalVariableGrouping {\r\n        bytes32 hashedTx;\r\n        address from;\r\n        BCNTToken tokenContract;\r\n        address profileAddr;\r\n        TradeProfile profile;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the trade profile address of the specified trader address.\r\n    * @param _trader The address to query the profile of.\r\n    * @param _strategyID The strategy ID of the profile\r\n    * @return The trader's profile address.\r\n    */\r\n    function profileOf(address _trader, bytes32 _strategyID) public view returns (address) {\r\n        return traderProfile[_trader][_strategyID];\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrade the trade profile implementation address.\r\n    * @param _newImplementation The new implementation address.\r\n    */\r\n    function upgradeTradeProfileImplementation(address _newImplementation) public returns (bool) {\r\n        require(msg.sender == bincentive);\r\n        require(Address.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n        tradeProfileImplementation = _newImplementation;\r\n        emit TradeProfileUpgraded(_newImplementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Update the BincentiveErrand address.\r\n    * @param _newBincentiveErrand The address of the new BincentiveErrand address.\r\n    */\r\n    function updateBincentiveErrand(address _newBincentiveErrand) public returns (bool) {\r\n        require(msg.sender == bincentive);\r\n\r\n        bincentiveErrand = _newBincentiveErrand;\r\n        emit UpdateBincentiveErrand(_newBincentiveErrand);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Register a trade profile\r\n    * @param _registerSignature bytes The signature for register trade profile, issued by the trader.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    * @param _registerFee uint256 Fee paid for the registration by trader\r\n    * @param _periodLength uint256 Period length of a follow trade.\r\n    * @param _maxMarginDeposit uint256 The maximum amount to join the follow trade.\r\n    * @param _minMarginDeposit uint256 The minimum amount to join the follow trade.\r\n    * @param _rewardPercentage uint256 The ratio of the profit paid to the trader.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _transferSignature bytes The signature for transfer register fee, issued by the trader.\r\n    *        _transferSignature is the signature on (_registerFee, 0, _nonce, _validUntil)\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function registerTradeProfile(\r\n        bytes _registerSignature,\r\n        bytes32 _strategyID,\r\n        uint256 _registerFee,\r\n        uint256 _periodLength,\r\n        uint256 _maxMarginDeposit,\r\n        uint256 _minMarginDeposit,\r\n        uint256 _rewardPercentage,\r\n        uint256 _nonce,\r\n        bytes _transferSignature,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == bincentive);\r\n        require(registerSignatures[_registerSignature] == false);\r\n        require(transferSignatures[_transferSignature] == false || _transferSignature.length == 0);\r\n\r\n        LocalVariableGrouping memory localVariables;\r\n\r\n        localVariables.hashedTx = ECRecovery.toEthSignedMessageHash(registerPreSignedHashing(\r\n            address(this),\r\n            _strategyID,\r\n            _registerFee,\r\n            _periodLength,\r\n            _maxMarginDeposit,\r\n            _minMarginDeposit,\r\n            _rewardPercentage,\r\n            _nonce\r\n        ));\r\n        localVariables.from = ECRecovery.recover(localVariables.hashedTx, _registerSignature);\r\n        require(traderProfile[localVariables.from][_strategyID] == address(0));\r\n\r\n        if(_registerFee > 0) {\r\n            localVariables.tokenContract = BCNTToken(tokenAddress);\r\n\r\n            localVariables.hashedTx = ECRecovery.toEthSignedMessageHash(\r\n                localVariables.tokenContract.transferPreSignedHashing(tokenAddress, address(this), _registerFee, 0, _nonce, _validUntil)\r\n            );\r\n            require(ECRecovery.recover(localVariables.hashedTx, _transferSignature) == localVariables.from);\r\n\r\n            require(localVariables.tokenContract.transferPreSigned(_transferSignature, address(this), _registerFee, 0, _nonce, _validUntil));\r\n        }\r\n\r\n        localVariables.profileAddr = new TradeProfileProxy(\r\n            tradeProfileImplementation,\r\n            abi.encodeWithSignature(\r\n                \"init(address,uint256,uint256,uint256,uint256)\",\r\n                localVariables.from,\r\n                _periodLength,\r\n                _maxMarginDeposit,\r\n                _minMarginDeposit,\r\n                _rewardPercentage\r\n            )\r\n        );\r\n        localVariables.profile = TradeProfile(localVariables.profileAddr);\r\n        traderProfile[localVariables.from][_strategyID] = localVariables.profile;\r\n        registerSignatures[_registerSignature] = true;\r\n        transferSignatures[_transferSignature] = true;\r\n\r\n        emit RegisterTradeProfile(localVariables.from, localVariables.profile);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Hash (keccak256) of the payload used by registerTradeProfile\r\n    * @param _investContract address The address of the Invest Contract.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    * @param _registerFee uint256 Fee paid for the registration by trader\r\n    * @param _periodLength uint256 Period length of a follow trade.\r\n    * @param _maxMarginDeposit uint256 The maximum amount to join the follow trade.\r\n    * @param _minMarginDeposit uint256 The minimum amount to join the follow trade.\r\n    * @param _rewardPercentage uint256 The ratio of the profit paid to the trader.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    */\r\n    function registerPreSignedHashing(\r\n        address _investContract,\r\n        bytes32 _strategyID,\r\n        uint256 _registerFee,\r\n        uint256 _periodLength,\r\n        uint256 _maxMarginDeposit,\r\n        uint256 _minMarginDeposit,\r\n        uint256 _rewardPercentage,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"7fa5aa9d\": registerPreSignedHashing(address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256) */\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                bytes4(0x7fa5aa9d),\r\n                _investContract,\r\n                _strategyID,\r\n                _registerFee,\r\n                _periodLength,\r\n                _maxMarginDeposit,\r\n                _minMarginDeposit,\r\n                _rewardPercentage,\r\n                _nonce\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Follow a trader\r\n    * @param _signature bytes The signature, issued by the follower.\r\n    * @param _trader address Address of the trader to follow.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    * @param _marginAmount uint256 The amount of this follow trade.\r\n    * @param _oracle address The oracle of this follow trade that will report result when clearing.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function followTrader(\r\n        bytes _signature,\r\n        address _trader,\r\n        bytes32 _strategyID,\r\n        uint256 _marginAmount,\r\n        address _oracle,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(block.number <= _validUntil);\r\n        require(followTraderSignatures[_signature] == false);\r\n\r\n        require(traderProfile[_trader][_strategyID] != address(0));\r\n        TradeProfile profile = TradeProfile(traderProfile[_trader][_strategyID]);\r\n\r\n        bytes32 hashedTx = ECRecovery.toEthSignedMessageHash(followTraderPreSignedHashing(\r\n            address(this),\r\n            _trader,\r\n            _strategyID,\r\n            _marginAmount,\r\n            _oracle,\r\n            _validUntil\r\n        ));\r\n        address from = ECRecovery.recover(hashedTx, _signature);\r\n\r\n        marginBalances[from] = marginBalances[from].sub(_marginAmount);\r\n        require(profile.follow(from, _marginAmount, _oracle));\r\n\r\n        followTraderSignatures[_signature] = true;\r\n\r\n        emit FollowTrader(from, _trader, _marginAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Hash (keccak256) of the payload used by followTrader\r\n    * @param _investContract address The address of the Invest Contract.\r\n    * @param _trader address Address of the trader to follow.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    * @param _marginAmount uint256 The amount of this follow trade.\r\n    * @param _oracle address The oracle of this follow trade that will report result when clearing.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function followTraderPreSignedHashing(\r\n        address _investContract,\r\n        address _trader,\r\n        bytes32 _strategyID,\r\n        uint256 _marginAmount,\r\n        address _oracle,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"7aefec13\": followTraderPreSignedHashing(address,address,bytes32,uint256,address,uint256) */\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                bytes4(0x7aefec13),\r\n                _investContract,\r\n                _trader,\r\n                _strategyID,\r\n                _marginAmount,\r\n                _oracle,\r\n                _validUntil\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Clear a following trade\r\n    * @param _signature bytes The signature, issued by the oracle.\r\n    * @param _trader address Address of the trader to follow.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    * @param _follower address The follower of this trader.\r\n    * @param _investedAmount uint256 The total amount the follower invest in this follow trade.\r\n    * @param _profitAmount int256 The profit made in this follow trade, could be negative.\r\n    * @param _causeToClear string The cause to clear this follow trade.\r\n    */\r\n    function clearTrade(\r\n        bytes _signature,\r\n        address _trader,\r\n        bytes32 _strategyID,\r\n        address _follower,\r\n        uint256 _investedAmount,\r\n        int256 _profitAmount,\r\n        string _causeToClear\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(traderProfile[_trader][_strategyID] != address(0));\r\n        TradeProfile profile = TradeProfile(traderProfile[_trader][_strategyID]);\r\n\r\n        if(msg.sender != bincentive) {\r\n            require(profile.startTimeOf(_follower) + profile.periodLength() <= now);\r\n        }\r\n\r\n        bytes32 hashedTx = ECRecovery.toEthSignedMessageHash(clearTradePreSignedHashing(\r\n            address(this),\r\n            _trader,\r\n            _strategyID,\r\n            _follower,\r\n            _investedAmount,\r\n            _profitAmount,\r\n            _causeToClear\r\n        ));\r\n        address from = ECRecovery.recover(hashedTx, _signature);\r\n\r\n        uint256 amountToTrader;\r\n        uint256 amountToFollower;\r\n        (amountToTrader, amountToFollower) = profile.clear(_follower, from, _profitAmount);\r\n        marginBalances[_trader] = marginBalances[_trader].add(amountToTrader);\r\n        marginBalances[_follower] = marginBalances[_follower].add(amountToFollower);\r\n\r\n        emit ClearTrade(_follower, _trader, _investedAmount, _profitAmount, _causeToClear);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Hash (keccak256) of the payload used by clearTrade\r\n    * @param _investContract address The address of the Invest Contract.\r\n    * @param _trader address Address of the trader to follow.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    * @param _follower address The follower of this trader.\r\n    * @param _investedAmount uint256 The total amount the follower invest in this follow trade.\r\n    * @param _profitAmount int256 The profit made in this follow trade, could be negative.\r\n    * @param _causeToClear string The cause to clear this follow trade.\r\n    */\r\n    function clearTradePreSignedHashing(\r\n        address _investContract,\r\n        address _trader,\r\n        bytes32 _strategyID,\r\n        address _follower,\r\n        uint256 _investedAmount,\r\n        int256 _profitAmount,\r\n        string _causeToClear\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"29b26bc1\": clearTradePreSignedHashing(address,address,bytes32,address,uint256,int256,string) */\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                bytes4(0x29b26bc1),\r\n                _investContract,\r\n                _trader,\r\n                _strategyID,\r\n                _follower,\r\n                _investedAmount,\r\n                _profitAmount,\r\n                _causeToClear\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Close a trade profile\r\n    * @param _signature bytes The signature for closing trade profile, issued by the trader.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    */\r\n    function closeTradeProfile(bytes _signature, bytes32 _strategyID) public returns (bool) {\r\n        require(msg.sender == bincentive);\r\n\r\n        bytes32 hashedTx = ECRecovery.toEthSignedMessageHash(closePreSignedHashing(\r\n            address(this),\r\n            _strategyID\r\n        ));\r\n        address from = ECRecovery.recover(hashedTx, _signature);\r\n        require(traderProfile[from][_strategyID] != address(0));\r\n\r\n        TradeProfile profile = TradeProfile(traderProfile[from][_strategyID]);\r\n        require(profile.close());\r\n\r\n        emit CloseTradeProfile(from, profile);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Hash (keccak256) of the payload used by closeTradeProfile\r\n    * @param _investContract address The address of the Invest contract.\r\n    * @param _strategyID bytes32 The strategy ID of the trade profile.\r\n    */\r\n    function closePreSignedHashing(\r\n        address _investContract,\r\n        bytes32 _strategyID\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"c95bd3aa\": closePreSignedHashing(address,bytes32) */\r\n        return keccak256(\r\n            abi.encodePacked(bytes4(0xc95bd3aa), _investContract, _strategyID)\r\n        );\r\n    }\r\n\r\n    function init(address _bincentive, address _tokenAddress, address _bincentiveErrand, address _tradeProfileImplementation) public {\r\n        require(bincentive == address(0) && bincentiveErrand == address(0) && tokenAddress == address(0) && tradeProfileImplementation == address(0), \"It's already been initialized\");\r\n        bincentive = _bincentive;\r\n        bincentiveErrand = _bincentiveErrand;\r\n        tokenAddress = _tokenAddress;\r\n        tradeProfileImplementation = _tradeProfileImplementation;\r\n    }\r\n    function getInitInputDataBytes(address _bincentive, address _tokenAddress, address _bincentiveErrand, address _tradeProfileImplementation) public returns (bytes){\r\n        return abi.encodeWithSignature(\r\n            \"init(address,address,address,address)\",\r\n            _bincentive,\r\n            _tokenAddress,\r\n            _bincentiveErrand,\r\n            _tradeProfileImplementation\r\n        );\r\n    }\r\n}\r\n\r\ncontract Proxy {\r\n  /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n  function () payable external {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @return The Address of the implementation.\r\n   */\r\n  function _implementation() internal view returns (address);\r\n\r\n  /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) internal {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize)\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize)\r\n\r\n      switch result\r\n      // delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n  function _willFallback() internal {\r\n  }\r\n\r\n  /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (\r\n        allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n        allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract DepositFromPrivateToken is StandardToken {\r\n   using SafeMath for uint256;\r\n\r\n   PrivateToken public privateToken;\r\n\r\n   modifier onlyPrivateToken() {\r\n     require(msg.sender == address(privateToken));\r\n     _;\r\n   }\r\n\r\n   /**\r\n   * @dev Deposit is the function should only be called from PrivateToken\r\n   * When the user wants to deposit their private Token to Origin Token. They should\r\n   * let the Private Token invoke this function.\r\n   * @param _depositor address. The person who wants to deposit.\r\n   */\r\n\r\n   function deposit(address _depositor, uint256 _value) public onlyPrivateToken returns(bool){\r\n     require(_value != 0);\r\n     balances[_depositor] = balances[_depositor].add(_value);\r\n     emit Transfer(privateToken, _depositor, _value);\r\n     return true;\r\n   }\r\n }\r\n\r\ncontract BCNTToken is DepositFromPrivateToken{\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Bincentive Token\"; // solium-disable-line uppercase\r\n    string public constant symbol = \"BCNT\"; // solium-disable-line uppercase\r\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\r\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\r\n    mapping(bytes => bool) internal signatures;\r\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\r\n\r\n    /**\r\n    * @notice Submit a presigned transfer\r\n    * @param _signature bytes The signature, issued by the owner.\r\n    * @param _to address The address which you want to transfer to.\r\n    * @param _value uint256 The amount of tokens to be transferred.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(signatures[_signature] == false);\r\n        require(block.number <= _validUntil);\r\n\r\n        bytes32 hashedTx = ECRecovery.toEthSignedMessageHash(\r\n          transferPreSignedHashing(address(this), _to, _value, _fee, _nonce, _validUntil)\r\n        );\r\n\r\n        address from = ECRecovery.recover(hashedTx, _signature);\r\n\r\n        balances[from] = balances[from].sub(_value).sub(_fee);\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[msg.sender] = balances[msg.sender].add(_fee);\r\n        signatures[_signature] = true;\r\n\r\n        emit Transfer(from, _to, _value);\r\n        emit Transfer(from, msg.sender, _fee);\r\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Hash (keccak256) of the payload used by transferPreSigned\r\n    * @param _token address The address of the token.\r\n    * @param _to address The address which you want to transfer to.\r\n    * @param _value uint256 The amount of tokens to be transferred.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _validUntil uint256 Block number until which the presigned transaction is still valid.\r\n    */\r\n    function transferPreSignedHashing(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce,\r\n        uint256 _validUntil\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"0d2d1bf5\": transferPreSigned(address,address,uint256,uint256,uint256,uint256) */\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                bytes4(0x0a0fb66b),\r\n                _token,\r\n                _to,\r\n                _value,\r\n                _fee,\r\n                _nonce,\r\n                _validUntil\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor that gives _owner all of existing tokens.\r\n    */\r\n    constructor(address _admin) public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        privateToken = new PrivateToken(\r\n          _admin, \"Bincentive Private Token\", \"BCNP\", decimals, INITIAL_SUPPLY\r\n       );\r\n    }\r\n}\r\n\r\ncontract PrivateToken is StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    string public name; // solium-disable-line uppercase\r\n    string public symbol; // solium-disable-line uppercase\r\n    uint8 public decimals; // solium-disable-line uppercase\r\n\r\n    address public admin;\r\n    bool public isPublic;\r\n    uint256 public unLockTime;\r\n    DepositFromPrivateToken originToken;\r\n\r\n    event StartPublicSale(uint256 unlockTime);\r\n    event Deposit(address indexed from, uint256 value);\r\n    /**\r\n    *  @dev check if msg.sender is allowed to deposit Origin token.\r\n    */\r\n    function isDepositAllowed() internal view{\r\n      // If the tokens isn't public yet all transfering are limited to origin tokens\r\n      require(isPublic);\r\n      require(msg.sender == admin || block.timestamp > unLockTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit msg.sender's origin token to real token\r\n    */\r\n    function deposit(address _depositor) public returns (bool){\r\n      isDepositAllowed();\r\n      uint256 _value;\r\n      _value = balances[_depositor];\r\n      require(_value > 0);\r\n      balances[_depositor] = 0;\r\n      require(originToken.deposit(_depositor, _value));\r\n      emit Deposit(_depositor, _value);\r\n\r\n      // This event is for those apps calculate balance from events rather than balanceOf\r\n      emit Transfer(_depositor, address(0), _value);\r\n    }\r\n\r\n    /**\r\n    *  @dev Start Public sale and allow admin to deposit the token.\r\n    *  normal users could deposit their tokens after the tokens unlocked\r\n    */\r\n    function startPublicSale(uint256 _unLockTime) public onlyAdmin {\r\n      require(!isPublic);\r\n      isPublic = true;\r\n      unLockTime = _unLockTime;\r\n      emit StartPublicSale(_unLockTime);\r\n    }\r\n\r\n    /**\r\n    *  @dev unLock the origin token and start the public sale.\r\n    */\r\n    function unLock() public onlyAdmin{\r\n      require(isPublic);\r\n      unLockTime = block.timestamp;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n      require(msg.sender == admin);\r\n      _;\r\n    }\r\n\r\n    constructor(address _admin, string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public{\r\n      originToken = DepositFromPrivateToken(msg.sender);\r\n      admin = _admin;\r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      totalSupply_ = _totalSupply;\r\n      balances[admin] = _totalSupply;\r\n      emit Transfer(address(0), admin, _totalSupply);\r\n    }\r\n}\r\n\r\ninterface InterfaceInvest {\r\n    function bincentiveErrand() public returns (address);\r\n}\r\n\r\ncontract TradeProfile{\r\n    using SafeMath for uint256;\r\n\r\n    // Meta data\r\n    string public strategyName;\r\n    string public symbol;\r\n\r\n    address public InvestContractAddress;\r\n    address public owner;\r\n    bool public isActive;\r\n    uint256 public periodLength;\r\n    uint256 public maxMarginDeposit;\r\n    uint256 public minMarginDeposit;\r\n    uint256 public rewardPercentage;\r\n    mapping(address => uint256) investBalances;\r\n    mapping(address => uint256) startTime;\r\n    mapping(address => address) oracle;\r\n\r\n    event LogTraderTradingTransaction(string tradingTx);\r\n    event LogAggregatedFollowersTradingTransaction(bytes32 aggregatedTxsHash);\r\n\r\n    /**\r\n    * @dev Gets the invest balance of the specified follower.\r\n    * @param _follower address The follower to query the the invest balance of.\r\n    * @return uint256 representing the amount invested by the passed follower.\r\n    */\r\n    function investBalanceOf(address _follower) public view returns (uint256) {\r\n        return investBalances[_follower];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the start time of the specified follower.\r\n    * @param _follower address The follower to query the the start time of.\r\n    * @return uint256 representing the start time of the follow trade.\r\n    */\r\n    function startTimeOf(address _follower) public view returns (uint256) {\r\n        return startTime[_follower];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the oracle of the specified follower.\r\n    * @param _follower address The follower to query the the oracle of.\r\n    * @return address representing the oracle of the follow trade.\r\n    */\r\n    function oracleOf(address _follower) public view returns (address) {\r\n        return oracle[_follower];\r\n    }\r\n\r\n    /**\r\n    * @dev Update the metadata of the trade profile.\r\n    * @param _strategyName string The name of this strategy, e.g., JOHN'S STRATEGY\r\n    * @param _symbol string The symbol, e.g., ETH/BTC\r\n    */\r\n    function updateMetadata(string _strategyName, string _symbol) public returns (bool) {\r\n        require(isActive);\r\n        require(msg.sender == InterfaceInvest(InvestContractAddress).bincentiveErrand() || msg.sender == owner);\r\n\r\n        strategyName = _strategyName;\r\n        symbol = _symbol;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Increase the invest balance of the specified follower.\r\n    * @param _follower address The follower.\r\n    * @param _amount uint256 The amount of margin to put into this follow trade.\r\n    * @param _oracle address The oracle which has the authority to report the outcome of the follow trade.\r\n    */\r\n    function follow(address _follower, uint256 _amount, address _oracle) public returns (bool) {\r\n        require(isActive);\r\n        require(msg.sender == InvestContractAddress);\r\n\r\n        investBalances[_follower] = investBalances[_follower].add(_amount);\r\n        require(minMarginDeposit <= investBalances[_follower] && investBalances[_follower] <= maxMarginDeposit);\r\n\r\n        if(startTime[_follower] == 0) {\r\n            startTime[_follower] = now;\r\n            oracle[_follower] = _oracle;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Log the trader's trading transactions.\r\n    * @param _tradingTxs string Trading transactions in JSON format.\r\n    */\r\n    function logTraderTradingTx(string[] _tradingTxs) public {\r\n        require(msg.sender == InterfaceInvest(InvestContractAddress).bincentiveErrand());\r\n        for(uint i=0; i<_tradingTxs.length; i++) {\r\n            emit LogTraderTradingTransaction(_tradingTxs[i]);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Log the followers' trading transactions.\r\n    * @param _aggregatedTxsHash bytes32 Hash of aggregation of followers' trading transactions.\r\n    */\r\n    function logFollowerTradingTx(bytes32 _aggregatedTxsHash) public {\r\n        require(msg.sender == InterfaceInvest(InvestContractAddress).bincentiveErrand());\r\n        emit LogAggregatedFollowersTradingTransaction(_aggregatedTxsHash);\r\n    }\r\n\r\n    /**\r\n    * @notice Clear a following trade\r\n    * @param _follower address The follower of this trader.\r\n    * @param _oracle address The oracle which has the authority to report the outcome of the follow trade.\r\n    * @param _profitAmount int256 The profit made in this follow trade.\r\n    */\r\n    function clear(\r\n        address _follower,\r\n        address _oracle,\r\n        int256 _profitAmount\r\n    )\r\n        public\r\n        returns (uint256 amountToTrader, uint256 amountToFollower)\r\n    {\r\n        require(msg.sender == InvestContractAddress);\r\n        require(_oracle == oracle[_follower]);\r\n\r\n        uint256 balance = investBalances[_follower];\r\n\r\n        delete investBalances[_follower];\r\n        delete startTime[_follower];\r\n        delete oracle[_follower];\r\n\r\n        if(_profitAmount <= 0) {\r\n            amountToTrader = 0;\r\n        }\r\n        else {\r\n            amountToTrader = uint256(_profitAmount) * rewardPercentage / 100;\r\n            if(amountToTrader > balance) {\r\n                amountToTrader = balance;\r\n            }\r\n        }\r\n        amountToFollower = balance - amountToTrader;\r\n    }\r\n\r\n    function close() public returns (bool) {\r\n        require(isActive);\r\n        require(msg.sender == InvestContractAddress);\r\n        isActive = false;\r\n        return true;\r\n    }\r\n\r\n    function init(address _owner, uint256 _periodLength, uint256 _maxMarginDeposit, uint256 _minMarginDeposit, uint256 _rewardPercentage) public {\r\n        require(isActive == false && InvestContractAddress == address(0) && owner == address(0), \"It's already been initialized\");\r\n        InvestContractAddress = msg.sender;\r\n        owner = _owner;\r\n        periodLength = _periodLength;\r\n        maxMarginDeposit = _maxMarginDeposit;\r\n        minMarginDeposit = _minMarginDeposit;\r\n        rewardPercentage = _rewardPercentage;\r\n        isActive = true;\r\n    }\r\n}\r\n\r\ninterface InterfaceInvest2 {\r\n    function tradeProfileImplementation() public returns (address);\r\n}\r\n\r\ncontract TradeProfileProxy is Proxy {\r\n    bytes32 private constant INVEST_CONTRACT_ADDRESS_SLOT = 0x5a42b641b005233e81cd19caaa5315e4c1605dfef71bbbc7d71dce1aa5a81bf2;\r\n\r\n    /**\r\n    * @dev Contract constructor.\r\n    * @param _implementation Address of the initial implementation.\r\n    * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n    * It should include the signature and the parameters of the function to be called, as described in\r\n    * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n    * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n    */\r\n    constructor(address _implementation, bytes _data) public payable {\r\n        assert(INVEST_CONTRACT_ADDRESS_SLOT == keccak256(\"invest_contract_address\"));\r\n        bytes32 slot = INVEST_CONTRACT_ADDRESS_SLOT;\r\n        address invest_contract_addr = msg.sender;\r\n        assembly {\r\n            sstore(slot, invest_contract_addr)\r\n        }\r\n        if(_data.length > 0) {\r\n            require(_implementation.delegatecall(_data));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current implementation.\r\n    * @return Address of the current implementation\r\n    */\r\n    function _implementation() internal view returns (address) {\r\n        bytes32 slot = INVEST_CONTRACT_ADDRESS_SLOT;\r\n        address invest_contract_addr;\r\n        assembly {\r\n            invest_contract_addr := sload(slot)\r\n        }\r\n        return InterfaceInvest2(invest_contract_addr).tradeProfileImplementation();\r\n    }\r\n\r\n    /**\r\n    * @return The address of the implementation.\r\n    */\r\n    function implementation() external view returns (address) {\r\n        return _implementation();\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"InvestContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_strategyName\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"updateMetadata\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_follower\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_profitAmount\",\"type\":\"int256\"}],\"name\":\"clear\",\"outputs\":[{\"name\":\"amountToTrader\",\"type\":\"uint256\"},{\"name\":\"amountToFollower\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_follower\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"follow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradingTxs\",\"type\":\"string[]\"}],\"name\":\"logTraderTradingTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_periodLength\",\"type\":\"uint256\"},{\"name\":\"_maxMarginDeposit\",\"type\":\"uint256\"},{\"name\":\"_minMarginDeposit\",\"type\":\"uint256\"},{\"name\":\"_rewardPercentage\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_follower\",\"type\":\"address\"}],\"name\":\"investBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aggregatedTxsHash\",\"type\":\"bytes32\"}],\"name\":\"logFollowerTradingTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_follower\",\"type\":\"address\"}],\"name\":\"startTimeOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMarginDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strategyName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minMarginDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_follower\",\"type\":\"address\"}],\"name\":\"oracleOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tradingTx\",\"type\":\"string\"}],\"name\":\"LogTraderTradingTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"aggregatedTxsHash\",\"type\":\"bytes32\"}],\"name\":\"LogAggregatedFollowersTradingTransaction\",\"type\":\"event\"}]","ContractName":"TradeProfile","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b1baad11da6d3f1faa1898922976bd8d8e1b4abb468cb35fe95a6994c92edb9c"}]}