{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// _____________________________________________________________\r\n//                  .''\r\n//        ._.-.___.' (`\\\r\n//       //(        ( `'\r\n//      '/ )\\ ).__. )\r\n//      ' <' `\\ ._/'\\\r\n// ________`___\\_____\\__________________________________________\r\n//                                            .''\r\n//     ___ _____ _ __ ___  ___      ._.-.___.' (`\\\r\n//    / _//_  _//// // _/ / o |    //(        ( `'\r\n//   / _/  / / / ` // _/ /  ,'    '/ )\\ ).__. )\r\n//  /___/ /_/ /_n_//___//_/`_\\    ' <' `\\ ._/'\\\r\n// __________________________________`___\\_____\\________________\r\n//                                                    .''\r\n//     __   ___  ___   ___  _  __           ._.-.___.' (`\\\r\n//    /  \\ / _/ / o | / o.)| |/,'          //(        ( `'\r\n//   / o |/ _/ /  ,' / o \\ | ,'           '/ )\\ ).__. )\r\n//  /__,'/___//_/`_\\/___,'/_/             ' <' `\\ ._/'\\\r\n// __________________________________________`___\\_____\\________\r\n//                            .''\r\n//                  ._.-.___.' (`\\\r\n//                 //(        ( `'\r\n//                '/ )\\ ).__. )\r\n//                ' <' `\\ ._/'\\\r\n// __________________`___\\_____\\________________________________\r\n//\r\n// This product is protected under license.  Any unauthorized copy, modification, or use without \r\n// express written consent from the creators is prohibited.\r\n//\r\ncontract EtherDerby {\r\n    using SafeMath for *;\r\n    using CalcCarrots for uint256;\r\n\r\n    // settings\r\n    string constant public name = \"EtherDerby\";\r\n    uint256 constant private ROUNDMAX = 4 hours;\r\n    uint256 constant private MULTIPLIER = 2**64;\r\n    uint256 constant private DECIMALS = 18;\r\n    uint256 constant public REGISTERFEE = 20 finney;\r\n\r\n    address constant private DEVADDR = 0xC17A40cB38598520bd7C0D5BFF97D441A810a008;\r\n\r\n    // horse Identifiers\r\n    uint8 constant private H1 = 1;\r\n    uint8 constant private H2 = 2;\r\n    uint8 constant private H3 = 3;\r\n    uint8 constant private H4 = 4;\r\n\r\n    //  ___  _ _  ___   __   _  ___  _\r\n    // |_ _|| U || __| |  \\ / \\|_ _|/ \\\r\n    //  | | |   || _|  | o ) o || || o |\r\n    //  |_| |_n_||___| |__/|_n_||_||_n_|\r\n    //\r\n\r\n    struct Round {\r\n        uint8 winner; // horse in the lead\r\n        mapping (uint8 => uint256) eth; // total eth per horse\r\n        mapping (uint8 => uint256) carrots; // total eth per horse\r\n    }\r\n\r\n    struct Player {\r\n        address addr; // player address\r\n        bytes32 name; // player name\r\n        uint256 totalWinnings; // player winnings\r\n        uint256 totalReferrals; // player referral bonuses\r\n        int256  dividendPayouts; // running count of payouts player has received (important that it can be negative)\r\n\r\n        mapping (uint256 => mapping (uint8 => uint256)) eth; // round -> horse -> eTH invested\r\n        mapping (uint256 => mapping (uint8 => uint256)) carrots; // round -> horse -> carrots purchased\r\n        mapping (uint256 => mapping (uint8 => uint256)) referrals; // round -> horse -> referrals (eth)\r\n\r\n        mapping (uint8 => uint256) totalEth; // total carrots invested in each horse by the player\r\n        mapping (uint8 => uint256) totalCarrots; // total carrots invested in each horse by the player\r\n\r\n        uint256 totalWithdrawn; // running total of ETH withdrawn by the player\r\n        uint256 totalReinvested; // running total of ETH reinvested by the player\r\n\r\n        uint256 roundLastManaged; // round players winnings were last recorded\r\n        uint256 roundLastReferred; // round player was last referred and therefore had its referrals managed\r\n        address lastRef; // address of player who last referred this player\r\n    }\r\n\r\n    struct Horse {\r\n        bytes32 name;\r\n        uint256 totalEth;\r\n        uint256 totalCarrots;\r\n        uint256 mostCarrotsOwned;\r\n        address owner;\r\n    }\r\n\r\n    uint256 rID_ = 0; // current round number\r\n    mapping (uint256 => Round) public rounds_; // data for each round\r\n    uint256 roundEnds_; // time current round is over\r\n    mapping (address => Player) public players_; // data for each player\r\n    mapping (uint8 => Horse) horses_; // data for each horse\r\n    uint256 private earningsPerCarrot_; // used to keep track of dividends rewarded to carrot holders\r\n\r\n    mapping (bytes32 => address) registeredNames_;\r\n\r\n    //  ___  _ _  ___  _  _  ___ __\r\n    // | __|| | || __|| \\| ||_ _/ _|\r\n    // | _| | V || _| | \\\\ | | |\\_ \\\r\n    // |___| \\_/ |___||_|\\_| |_||__/\r\n    //\r\n\r\n    /**\r\n     * @dev fired for every set of carrots purchased or reinvested in\r\n     * @param playerAddress player making the purchase\r\n     * @param playerName players name if they have registered\r\n     * @param roundId round for which carrots were purchased\r\n     * @param horse array of two horses (stack limit hit so we use array)\r\n     *   0 - horse which horse carrots were purchased for\r\n     *   1 - horse now in the lead\r\n     * @param horseName horse name at the time of purchase\r\n     * @param roundEnds round end time\r\n     * @param timestamp block timestamp when purchase occurred\r\n     * @param data contains the following (stack limit hit so we use array)\r\n     *   0 - amount of eth\r\n     *   1 - amount of carrots\r\n     *   2 - horses total eth for the round\r\n     *   3 - horses total carrots for the round\r\n     *   4 - players total eth for the round\r\n     *   5 - players total carrots for the round\r\n     */\r\n    event OnCarrotsPurchased\r\n    (\r\n        address indexed playerAddress,\r\n        bytes32 playerName,\r\n        uint256 roundId,\r\n        uint8[2] horse,\r\n        bytes32 indexed horseName,\r\n        uint256[6] data,\r\n        uint256 roundEnds,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @dev fired each time a player withdraws ETH\r\n     * @param playerAddress players address\r\n     * @param eth amount withdrawn\r\n     */\r\n    event OnEthWithdrawn\r\n    (\r\n        address indexed playerAddress,\r\n        uint256 eth\r\n    );\r\n\r\n    /**\r\n     * @dev fired whenever a horse is given a new name\r\n     * @param playerAddress which player named the horse\r\n     * @param horse number of horse being named\r\n     * @param horseName new name of horse\r\n     * @param mostCarrotsOwned number of carrots by owned to name the horse\r\n     * @param timestamp block timestamp when horse is named\r\n     */\r\n    event OnHorseNamed\r\n    (\r\n      address playerAddress,\r\n      bytes32 playerName,\r\n      uint8 horse,\r\n      bytes32 horseName,\r\n      uint256 mostCarrotsOwned,\r\n      uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @dev fired whenever a player registers a name\r\n     * @param playerAddress which player registered a name\r\n     * @param playerName name being registered\r\n     * @param ethDonated amount of eth donated with registration\r\n     * @param timestamp block timestamp when name registered\r\n     */\r\n    event OnNameRegistered\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethDonated,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * @dev fired when a transaction is rejected\r\n     * mainly used to make it easier to write front end code\r\n     * @param playerAddress player making the purchase\r\n     * @param reason why the transaction failed\r\n     */\r\n    event OnTransactionFail\r\n    (\r\n        address indexed playerAddress,\r\n        bytes32 reason\r\n    );\r\n\r\n    constructor()\r\n      public\r\n    {\r\n        // start with Round 0 ending before now so that first purchase begins Round 1\r\n        // subtract an hour to make sure the first purchase doesn't go to round 0 (ex. same block)\r\n        roundEnds_ = block.timestamp - 1 hours;\r\n\r\n        // default horse names\r\n        horses_[H1].name = \"horse1\";\r\n        horses_[H2].name = \"horse2\";\r\n        horses_[H3].name = \"horse3\";\r\n        horses_[H4].name = \"horse4\";\r\n    }\r\n\r\n    //  _   _  _  __  _  ___  _  ___  ___  __\r\n    // | \\_/ |/ \\|  \\| || __|| || __|| o \\/ _|\r\n    // | \\_/ ( o ) o ) || _| | || _| |   /\\_ \\\r\n    // |_| |_|\\_/|__/|_||_|  |_||___||_|\\\\|__/\r\n    //\r\n\r\n    /**\r\n     * @dev verifies that a valid horse is provided\r\n     */\r\n    modifier isValidHorse(uint8 _horse) {\r\n        require(_horse == H1 || _horse == H2 || _horse == H3 || _horse == H4, \"unknown horse selected\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents smart contracts from interacting with EtherDerby\r\n     */\r\n    modifier isHuman() {\r\n        address addr = msg.sender;\r\n        uint256 codeLength;\r\n\r\n        assembly {codeLength := extcodesize(addr)}\r\n        require(codeLength == 0, \"Humans only ;)\");\r\n        require(msg.sender == tx.origin, \"Humans only ;)\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev verifies that all purchases sent include a reasonable amount of ETH\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"Not enough eth!\");\r\n        require(_eth <= 100000000000000000000000, \"Go away whale!\");\r\n        _;\r\n    }\r\n\r\n\r\n    //  ___ _ _  ___ _    _  __   ___  _ _  _  _  __  ___  _  _  _  _  __\r\n    // | o \\ | || o ) |  | |/ _| | __|| | || \\| |/ _||_ _|| |/ \\| \\| |/ _|\r\n    // |  _/ U || o \\ |_ | ( (_  | _| | U || \\\\ ( (_  | | | ( o ) \\\\ |\\_ \\\r\n    // |_| |___||___/___||_|\\__| |_|  |___||_|\\_|\\__| |_| |_|\\_/|_|\\_||__/\r\n    //\r\n\r\n    /**\r\n     * @dev register a name with Ether Derby to generate a referral link\r\n     * @param _nameStr the name being registered (see NameValidator library below\r\n     * for name requirements)\r\n     */\r\n    function registerName(string _nameStr)\r\n        public\r\n        payable\r\n        isHuman()\r\n    {\r\n        require(msg.value >= REGISTERFEE, \"You must pay the partner fee of 20 finney\");\r\n\r\n        bytes32 nameToRegister = NameValidator.validate(_nameStr);\r\n\r\n        require(registeredNames_[nameToRegister] == 0, \"Name already in use\");\r\n\r\n        registeredNames_[nameToRegister] = msg.sender;\r\n        players_[msg.sender].name = nameToRegister;\r\n\r\n        // partner fee goes to devs\r\n        players_[DEVADDR].totalReferrals = msg.value.add(players_[DEVADDR].totalReferrals);\r\n\r\n        emit OnNameRegistered(msg.sender, nameToRegister, msg.value, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev buy carrots with ETH\r\n     * @param _horse the horse carrots are being purchased for\r\n     * @param _round the round these carrots should be purchased for (send 0 to\r\n     * buy for whatever the current round is)\r\n     * @param _referrerName the player for which to reward referral bonuses to\r\n     */\r\n    function buyCarrots(uint8 _horse, uint256 _round, bytes32 _referrerName)\r\n        public\r\n        payable\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        isValidHorse(_horse)\r\n    {\r\n        if (isInvalidRound(_round)) {\r\n            emit OnTransactionFail(msg.sender, \"Invalid round\");\r\n            msg.sender.transfer(msg.value);\r\n            return;\r\n        }\r\n        buyCarrotsInternal(_horse, msg.value, _referrerName);\r\n    }\r\n\r\n    /**\r\n     * @dev buy carrots with current earnings left in smart contract\r\n     * @param _horse the horse carrots are being purchased for\r\n     * @param _round the round these carrots should be purchased for (send 0 to\r\n     * buy for whatever the current round is)\r\n     * @param _referrerName the player for which to reward referral bonuses to\r\n     */\r\n    function reinvestInCarrots(uint8 _horse, uint256 _round, uint256 _value, bytes32 _referrerName)\r\n        public\r\n        isHuman()\r\n        isWithinLimits(_value)\r\n        isValidHorse(_horse)\r\n    {\r\n        if (isInvalidRound(_round)) {\r\n            emit OnTransactionFail(msg.sender, \"Invalid round\");\r\n            return;\r\n        }\r\n        if (calcPlayerEarnings() < _value) {\r\n            // Not enough earnings in player vault\r\n            emit OnTransactionFail(msg.sender, \"Insufficient funds\");\r\n            return;\r\n        }\r\n        players_[msg.sender].totalReinvested = _value.add(players_[msg.sender].totalReinvested);\r\n\r\n        buyCarrotsInternal(_horse, _value, _referrerName);\r\n    }\r\n\r\n    /**\r\n     * @dev name horse by purchasing enough carrots to become majority holder\r\n     * @param _horse the horse being named\r\n     * @param _nameStr the desired horse name (See NameValidator for requirements)\r\n     * @param _referrerName the player for which to reward referral bonuses to\r\n     */\r\n    function nameHorse(uint8 _horse, string _nameStr, bytes32 _referrerName)\r\n      public\r\n      payable\r\n      isHuman()\r\n      isValidHorse(_horse)\r\n    {\r\n        if ((rounds_[getCurrentRound()].eth[_horse])\r\n            .carrotsReceived(msg.value)\r\n            .add(players_[msg.sender].totalCarrots[_horse]) < \r\n                horses_[_horse].mostCarrotsOwned) {\r\n            emit OnTransactionFail(msg.sender, \"Insufficient funds\");\r\n            if (msg.value > 0) {\r\n                msg.sender.transfer(msg.value);\r\n            }\r\n            return;\r\n        }\r\n        if (msg.value > 0) {\r\n            buyCarrotsInternal(_horse, msg.value, _referrerName);    \r\n        }\r\n        horses_[_horse].name = NameValidator.validate(_nameStr);\r\n        if (horses_[_horse].owner != msg.sender) {\r\n            horses_[_horse].owner = msg.sender;\r\n        }\r\n        emit OnHorseNamed(\r\n            msg.sender,\r\n            players_[msg.sender].name,\r\n            _horse,\r\n            horses_[_horse].name,\r\n            horses_[_horse].mostCarrotsOwned,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw all earnings made so far. includes winnings, dividends, and referrals\r\n     */\r\n    function withdrawEarnings()\r\n        public\r\n        isHuman()\r\n    {\r\n        managePlayer();\r\n        manageReferrer(msg.sender);\r\n\r\n        uint256 earnings = calcPlayerEarnings();\r\n        if (earnings > 0) {\r\n            players_[msg.sender].totalWithdrawn = earnings.add(players_[msg.sender].totalWithdrawn);\r\n            msg.sender.transfer(earnings);\r\n        }\r\n        emit OnEthWithdrawn(msg.sender, earnings);\r\n    }\r\n\r\n    /**\r\n     * @dev fallback function puts incoming eth into devs referrals\r\n     */\r\n    function()\r\n        public\r\n        payable\r\n    {\r\n        players_[DEVADDR].totalReferrals = msg.value.add(players_[DEVADDR].totalReferrals);\r\n    }\r\n\r\n    //  ___ ___ _  _ _   _  ___  ___   _ _  ___  _    ___ ___  ___  __\r\n    // | o \\ o \\ || | | / \\|_ _|| __| | U || __|| |  | o \\ __|| o \\/ _|\r\n    // |  _/   / || V || o || | | _|  |   || _| | |_ |  _/ _| |   /\\_ \\\r\n    // |_| |_|\\\\_| \\_/ |_n_||_| |___| |_n_||___||___||_| |___||_|\\\\|__/\r\n    //\r\n\r\n    /**\r\n     * @dev core helper method for purchasing carrots\r\n     * @param _horse the horse carrots are being purchased for\r\n     * @param _value amount of eth to spend on carrots\r\n     * @param _referrerName the player for which to reward referral bonuses to\r\n     */\r\n    function buyCarrotsInternal(uint8 _horse, uint256 _value, bytes32 _referrerName)\r\n        private\r\n    {\r\n        // check if new round needs started and update horses pending data if necessary\r\n        manageRound();\r\n\r\n        // update players winnings and reset pending data if necessary\r\n        managePlayer();\r\n\r\n        address referrer = getReferrer(_referrerName);\r\n        // update referrers total referrals and reset pending referrals if necessary\r\n        manageReferrer(referrer);\r\n        if (referrer != DEVADDR) {\r\n            // also manage dev account unless referrer is dev\r\n            manageReferrer(DEVADDR);\r\n        }\r\n\r\n        uint256 carrots = (rounds_[rID_].eth[_horse]).carrotsReceived(_value);\r\n\r\n        /*******************/\r\n        /*  Update Player  */\r\n        /*******************/\r\n\r\n        players_[msg.sender].eth[rID_][_horse] = \r\n            _value.add(players_[msg.sender].eth[rID_][_horse]);\r\n        players_[msg.sender].carrots[rID_][_horse] = \r\n            carrots.add(players_[msg.sender].carrots[rID_][_horse]);\r\n        players_[msg.sender].totalEth[_horse] =\r\n            _value.add(players_[msg.sender].totalEth[_horse]);\r\n        players_[msg.sender].totalCarrots[_horse] =\r\n            carrots.add(players_[msg.sender].totalCarrots[_horse]);\r\n\r\n        // players don't recieve dividends before buying the carrots\r\n        players_[msg.sender].dividendPayouts += SafeConversions.SafeSigned(earningsPerCarrot_.mul(carrots));\r\n\r\n        /*******************/\r\n        /* Update Referrer */\r\n        /*******************/\r\n\r\n        players_[referrer].referrals[rID_][_horse] = \r\n            ninePercent(_value).add(players_[referrer].referrals[rID_][_horse]);\r\n        // one percent to devs\r\n        // reuse referrals since functionality is the same\r\n        players_[DEVADDR].referrals[rID_][_horse] =\r\n            _value.div(100).add(players_[DEVADDR].referrals[rID_][_horse]);\r\n\r\n        // check if players new amount of total carrots for this horse is greater than mostCarrotsOwned and update\r\n        if (players_[msg.sender].totalCarrots[_horse] > horses_[_horse].mostCarrotsOwned) {\r\n          horses_[_horse].mostCarrotsOwned = players_[msg.sender].totalCarrots[_horse];\r\n        }\r\n\r\n        /*******************/\r\n        /*  Update  Round  */\r\n        /*******************/\r\n\r\n        rounds_[rID_].eth[_horse] = _value.add(rounds_[rID_].eth[_horse]);\r\n        rounds_[rID_].carrots[_horse] = carrots.add(rounds_[rID_].carrots[_horse]);\r\n\r\n        // if this horses carrots now exceeds current winner, update current winner\r\n        if (rounds_[rID_].winner != _horse &&\r\n            rounds_[rID_].carrots[_horse] > rounds_[rID_].carrots[rounds_[rID_].winner]) {\r\n            rounds_[rID_].winner = _horse;\r\n        }\r\n\r\n        /*******************/\r\n        /*  Update  Horse  */\r\n        /*******************/\r\n\r\n        horses_[_horse].totalCarrots = carrots.add(horses_[_horse].totalCarrots);\r\n        horses_[_horse].totalEth = _value.add(horses_[_horse].totalEth);\r\n\r\n        emit OnCarrotsPurchased(\r\n            msg.sender,\r\n            players_[msg.sender].name,\r\n            rID_,\r\n            [\r\n                _horse,\r\n                rounds_[rID_].winner\r\n            ],\r\n            horses_[_horse].name,\r\n            [\r\n                _value,\r\n                carrots,\r\n                rounds_[rID_].eth[_horse],\r\n                rounds_[rID_].carrots[_horse],\r\n                players_[msg.sender].eth[rID_][_horse],\r\n                players_[msg.sender].carrots[rID_][_horse]\r\n            ],\r\n            roundEnds_,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev check if now is past current rounds ends time. if so, compute round\r\n     * details and update all storage to start the next round\r\n     */\r\n    function manageRound()\r\n      private\r\n    {\r\n        if (!isRoundOver()) {\r\n            return;\r\n        }\r\n        // round over, update dividends and start next round\r\n        uint256 earningsPerCarrotThisRound = fromEthToDivies(calcRoundLosingHorsesEth(rID_));\r\n\r\n        if (earningsPerCarrotThisRound > 0) {\r\n            earningsPerCarrot_ = earningsPerCarrot_.add(earningsPerCarrotThisRound);  \r\n        }\r\n\r\n        rID_++;\r\n        roundEnds_ = block.timestamp + ROUNDMAX;\r\n    }\r\n\r\n    /**\r\n     * @dev check if a player has winnings from a previous round that have yet to\r\n     * be recorded. this needs to be called before any player interacts with Ether\r\n     * Derby to make sure there data is kept up to date\r\n     */\r\n    function managePlayer()\r\n        private\r\n    {\r\n        uint256 unrecordedWinnings = calcUnrecordedWinnings();\r\n        if (unrecordedWinnings > 0) {\r\n            players_[msg.sender].totalWinnings = unrecordedWinnings.add(players_[msg.sender].totalWinnings);\r\n        }\r\n        // if managePlayer is being called while round is over, calcUnrecordedWinnings will include\r\n        // winnings from the current round. it's important that we store rID_+1 here to make sure\r\n        // users can't double withdraw winnings from current round\r\n        if (players_[msg.sender].roundLastManaged == rID_ && isRoundOver()) {\r\n            players_[msg.sender].roundLastManaged = rID_.add(1);\r\n        }\r\n        else if (players_[msg.sender].roundLastManaged < rID_) {\r\n            players_[msg.sender].roundLastManaged = rID_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev check if a player has referral bonuses from a previous round that have yet \r\n     * to be recorded\r\n     */\r\n    function manageReferrer(address _referrer)\r\n        private\r\n    {\r\n        uint256 unrecordedRefferals = calcUnrecordedRefferals(_referrer);\r\n        if (unrecordedRefferals > 0) {\r\n            players_[_referrer].totalReferrals =\r\n                unrecordedRefferals.add(players_[_referrer].totalReferrals);\r\n        }\r\n\r\n        if (players_[_referrer].roundLastReferred == rID_ && isRoundOver()) {\r\n            players_[_referrer].roundLastReferred = rID_.add(1);\r\n        }\r\n        else if (players_[_referrer].roundLastReferred < rID_) {\r\n            players_[_referrer].roundLastReferred = rID_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculate total amount of carrots that have been purchased\r\n     */\r\n    function calcTotalCarrots()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return horses_[H1].totalCarrots\r\n            .add(horses_[H2].totalCarrots)\r\n            .add(horses_[H3].totalCarrots)\r\n            .add(horses_[H4].totalCarrots);\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players total amount of carrots including the unrecorded\r\n     */\r\n    function calcPlayerTotalCarrots()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return players_[msg.sender].totalCarrots[H1]\r\n            .add(players_[msg.sender].totalCarrots[H2])\r\n            .add(players_[msg.sender].totalCarrots[H3])\r\n            .add(players_[msg.sender].totalCarrots[H4]);\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players total amount of eth spent including unrecorded\r\n     */\r\n    function calcPlayerTotalEth()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return players_[msg.sender].totalEth[H1]\r\n            .add(players_[msg.sender].totalEth[H2])\r\n            .add(players_[msg.sender].totalEth[H3])\r\n            .add(players_[msg.sender].totalEth[H4]);\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players total earnings (able to be withdrawn)\r\n     */\r\n    function calcPlayerEarnings()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return calcPlayerWinnings()\r\n            .add(calcPlayerDividends())\r\n            .add(calcPlayerReferrals())\r\n            .sub(players_[msg.sender].totalWithdrawn)\r\n            .sub(players_[msg.sender].totalReinvested);\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players total winning including the unrecorded\r\n     */\r\n    function calcPlayerWinnings()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return players_[msg.sender].totalWinnings.add(calcUnrecordedWinnings());\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players total dividends including the unrecorded\r\n     */\r\n    function calcPlayerDividends()\r\n      private\r\n      view\r\n      returns (uint256)\r\n    {\r\n        uint256 unrecordedDividends = calcUnrecordedDividends();\r\n        uint256 carrotBalance = calcPlayerTotalCarrots();\r\n        int256 totalDividends = SafeConversions.SafeSigned(carrotBalance.mul(earningsPerCarrot_).add(unrecordedDividends));\r\n        return SafeConversions.SafeUnsigned(totalDividends - players_[msg.sender].dividendPayouts).div(MULTIPLIER);\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players total referral bonus including the unrecorded\r\n     */\r\n    function calcPlayerReferrals()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return players_[msg.sender].totalReferrals.add(calcUnrecordedRefferals(msg.sender));\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players unrecorded winnings (those not yet in Player.totalWinnings)\r\n     */\r\n    function calcUnrecordedWinnings()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 round = players_[msg.sender].roundLastManaged;\r\n        if ((round == 0) || (round > rID_) || (round == rID_ && !isRoundOver())) {\r\n            // all winnings have been recorded\r\n            return 0;\r\n        }\r\n        // round is <= rID_, not 0, and if equal then round is over\r\n        // (players eth spent on the winning horse during their last round) +\r\n        // ((players carrots for winning horse during their last round) * \r\n        // (80% of losing horses eth)) / total carrots purchased for winning horse\r\n        return players_[msg.sender].eth[round][rounds_[round].winner]\r\n            .add((players_[msg.sender].carrots[round][rounds_[round].winner]\r\n            .mul(eightyPercent(calcRoundLosingHorsesEth(round))))\r\n            .div(rounds_[round].carrots[rounds_[round].winner]));\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players unrecorded dividends (those not yet reflected in earningsPerCarrot_)\r\n     */\r\n    function calcUnrecordedDividends()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (!isRoundOver()) {\r\n            // round is not over\r\n            return 0;\r\n        }\r\n        // round has ended but next round has not yet been started, so\r\n        // dividends from the current round are reflected in earningsPerCarrot_\r\n        return fromEthToDivies(calcRoundLosingHorsesEth(rID_)).mul(calcPlayerTotalCarrots());\r\n    }\r\n\r\n    /**\r\n     * @dev calculate players unrecorded referral bonus (those not yet in Player.referrals)\r\n     */\r\n    function calcUnrecordedRefferals(address _player)\r\n        private\r\n        view\r\n        returns (uint256 ret)\r\n    {\r\n        uint256 round = players_[_player].roundLastReferred;\r\n        if (!((round == 0) || (round > rID_) || (round == rID_ && !isRoundOver()))) {\r\n            for (uint8 i = H1; i <= H4; i++) {\r\n                if (rounds_[round].winner != i) {\r\n                    ret = ret.add(players_[_player].referrals[round][i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculate total eth from all horses except the winner\r\n     */\r\n    function calcRoundLosingHorsesEth(uint256 _round)\r\n        private\r\n        view\r\n        returns (uint256 ret)\r\n    {\r\n        for (uint8 i = H1; i <= H4; i++) {\r\n            if (rounds_[_round].winner != i) {\r\n                ret = ret.add(rounds_[_round].eth[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculate the change in earningsPerCarrot_ based on new eth coming in\r\n     * @param _value amount of ETH being sent out as dividends to all carrot holders\r\n     */\r\n    function fromEthToDivies(uint256 _value)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // edge case where dividing by 0 would happen\r\n        uint256 totalCarrots = calcTotalCarrots();\r\n        if (totalCarrots == 0) {\r\n            return 0;\r\n        }\r\n        // multiply by MULTIPLIER to prevent integer division from returning 0\r\n        // when totalCarrots > losingHorsesEth\r\n        // divide by 10 because only 10% of losing horses ETH goes to dividends\r\n        return _value.mul(MULTIPLIER).div(10).div(totalCarrots);\r\n    }\r\n\r\n    /**\r\n     * @dev convert registered name to an address\r\n     * @param _referrerName name of player that referred current player\r\n     * @return address of referrer if valid, or last person to refer the current player,\r\n     * or the devs as a backup referrer\r\n     */\r\n    function getReferrer(bytes32 _referrerName)\r\n        private\r\n        returns (address)\r\n    {\r\n        address referrer;\r\n        // referrer is not empty, unregistered, or same as buyer\r\n        if (_referrerName != \"\" && registeredNames_[_referrerName] != 0 && _referrerName != players_[msg.sender].name) {\r\n            referrer = registeredNames_[_referrerName];\r\n        } else if (players_[msg.sender].lastRef != 0) {\r\n            referrer = players_[msg.sender].lastRef;\r\n        } else {\r\n            // fallback to Devs if no referrer provided\r\n            referrer = DEVADDR;\r\n        }\r\n        if (players_[msg.sender].lastRef != referrer) {\r\n            // store last referred to allow partner to continue receiving\r\n            // future purchases from this player\r\n            players_[msg.sender].lastRef = referrer;\r\n        }\r\n        return referrer;\r\n    }\r\n\r\n    /**\r\n     * @dev calculate price of buying carrots\r\n     * @param _horse which horse to calculate price for\r\n     * @param _carrots how many carrots desired\r\n     * @return ETH required to purchase X many carrots (in large format)\r\n     */\r\n    function calculateCurrentPrice(uint8 _horse, uint256 _carrots)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 currTotal = 0;\r\n        if (!isRoundOver()) {\r\n            // Round is ongoing\r\n            currTotal = rounds_[rID_].carrots[_horse];\r\n        }\r\n        return currTotal.add(_carrots).ethReceived(_carrots);\r\n    }\r\n\r\n    /**\r\n     * @dev check if a round number is valid to make a purchase for\r\n     * @param _round round to check\r\n     * @return true if _round is current (or next if current is over)\r\n     */\r\n    function isInvalidRound(uint256 _round)\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        // passing _round as 0 means buy for current round\r\n        return _round != 0 && _round != getCurrentRound();\r\n    }\r\n\r\n    /**\r\n     * @dev get current round\r\n     */\r\n    function getCurrentRound()\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (isRoundOver()) {\r\n            return (rID_ + 1);\r\n        }\r\n        return rID_;\r\n    }\r\n\r\n    /**\r\n     * @dev check if current round has ended based on current block timestamp\r\n     * @return true if round is over, false otherwise\r\n     */\r\n    function isRoundOver()\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return block.timestamp >= roundEnds_;\r\n    }\r\n\r\n    /**\r\n     * @dev compute eighty percent as whats left after subtracting 10%, 1% and 9%\r\n     * @param num_ number to compute 80% of\r\n     */\r\n    function eightyPercent(uint256 num_)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // 100% - 9% - 1% - 10% = 80%\r\n        return num_.sub(ninePercent(num_)).sub(num_.div(100)).sub(num_.div(10));\r\n    }\r\n\r\n    /**\r\n     * @dev compute eighty percent as whats left after subtracting 10% twice\r\n     * @param num_ number to compute 80% of\r\n     */\r\n    function ninePercent(uint256 num_)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return num_.mul(9).div(100);\r\n    }\r\n\r\n    //  _____ _____  ___  ___ _  _   _   _     _ _  _   _   _  ___  ___  _ _  _  __  __\r\n    // | __\\ V /_ _|| __|| o \\ \\| | / \\ | |   | | || | | \\_/ || __||_ _|| U |/ \\|  \\/ _|\r\n    // | _| ) ( | | | _| |   / \\\\ || o || |_  | U || | | \\_/ || _|  | | |   ( o ) o )_ \\\r\n    // |___/_n_\\|_| |___||_|\\\\_|\\_||_n_||___| |___||_| |_| |_||___| |_| |_n_|\\_/|__/|__/\r\n    //\r\n\r\n    /**\r\n     * @dev get stats from current round (or the last round if new has not yet started)\r\n     * @return round id\r\n     * @return round end time\r\n     * @return horse in the lead\r\n     * @return eth for each horse\r\n     * @return carrots for each horse\r\n     * @return eth invested for each horse\r\n     * @return carrots invested for each horse\r\n     * @return horse names\r\n     */\r\n    function getRoundStats()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint8, uint256[4], uint256[4], uint256[4], uint256[4], bytes32[4])\r\n    {\r\n        return\r\n        (\r\n            rID_,\r\n            roundEnds_,\r\n            rounds_[rID_].winner,\r\n            [\r\n                rounds_[rID_].eth[H1],\r\n                rounds_[rID_].eth[H2],\r\n                rounds_[rID_].eth[H3],\r\n                rounds_[rID_].eth[H4]\r\n            ],\r\n            [\r\n                rounds_[rID_].carrots[H1],\r\n                rounds_[rID_].carrots[H2],\r\n                rounds_[rID_].carrots[H3],\r\n                rounds_[rID_].carrots[H4]\r\n            ],\r\n            [\r\n                players_[msg.sender].eth[rID_][H1],\r\n                players_[msg.sender].eth[rID_][H2],\r\n                players_[msg.sender].eth[rID_][H3],\r\n                players_[msg.sender].eth[rID_][H4]\r\n            ],\r\n            [\r\n                players_[msg.sender].carrots[rID_][H1],\r\n                players_[msg.sender].carrots[rID_][H2],\r\n                players_[msg.sender].carrots[rID_][H3],\r\n                players_[msg.sender].carrots[rID_][H4]\r\n            ],\r\n            [\r\n                horses_[H1].name,\r\n                horses_[H2].name,\r\n                horses_[H3].name,\r\n                horses_[H4].name\r\n            ]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev get minimal details about a specific round (returns all 0s if round not over)\r\n     * @param _round which round to query\r\n     * @return horse that won\r\n     * @return eth for each horse\r\n     * @return carrots for each horse\r\n     * @return eth invested for each horse\r\n     * @return carrots invested for each horse\r\n     */\r\n    function getPastRoundStats(uint256 _round) \r\n        public\r\n        view\r\n        returns(uint8, uint256[4], uint256[4], uint256[4], uint256[4])\r\n    {\r\n        if ((_round == 0) || (_round > rID_) || (_round == rID_ && !isRoundOver())) {\r\n            return;\r\n        }\r\n        return\r\n        (\r\n            rounds_[rID_].winner,\r\n            [\r\n                rounds_[_round].eth[H1],\r\n                rounds_[_round].eth[H2],\r\n                rounds_[_round].eth[H3],\r\n                rounds_[_round].eth[H4]\r\n            ],\r\n            [\r\n                rounds_[_round].carrots[H1],\r\n                rounds_[_round].carrots[H2],\r\n                rounds_[_round].carrots[H3],\r\n                rounds_[_round].carrots[H4]\r\n            ],\r\n            [\r\n                players_[msg.sender].eth[_round][H1],\r\n                players_[msg.sender].eth[_round][H2],\r\n                players_[msg.sender].eth[_round][H3],\r\n                players_[msg.sender].eth[_round][H4]\r\n            ],\r\n            [\r\n                players_[msg.sender].carrots[_round][H1],\r\n                players_[msg.sender].carrots[_round][H2],\r\n                players_[msg.sender].carrots[_round][H3],\r\n                players_[msg.sender].carrots[_round][H4]\r\n            ]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev get stats for player\r\n     * @return total winnings\r\n     * @return total dividends\r\n     * @return total referral bonus\r\n     * @return total reinvested\r\n     * @return total withdrawn\r\n     */\r\n    function getPlayerStats()\r\n        public \r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        return\r\n        (\r\n            calcPlayerWinnings(),\r\n            calcPlayerDividends(),\r\n            calcPlayerReferrals(),\r\n            players_[msg.sender].totalReinvested,\r\n            players_[msg.sender].totalWithdrawn\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev get name of player\r\n     * @return players registered name if there is one\r\n     */\r\n    function getPlayerName()\r\n      public\r\n      view\r\n      returns(bytes32)\r\n    {\r\n        return players_[msg.sender].name;\r\n    }\r\n\r\n    /**\r\n     * @dev check if name is available\r\n     * @param _name name to check\r\n     * @return bool whether or not it is available\r\n     */\r\n    function isNameAvailable(bytes32 _name)\r\n      public\r\n      view\r\n      returns(bool)\r\n    {\r\n        return registeredNames_[_name] == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev get overall stats for EtherDerby\r\n     * @return total eth for each horse\r\n     * @return total carrots for each horse\r\n     * @return player total eth for each horse\r\n     * @return player total carrots for each horse\r\n     * @return horse names\r\n     */\r\n    function getStats()\r\n        public\r\n        view\r\n        returns(uint256[4], uint256[4], uint256[4], uint256[4], bytes32[4])\r\n    {\r\n        return\r\n        (\r\n            [\r\n                horses_[H1].totalEth,\r\n                horses_[H2].totalEth,\r\n                horses_[H3].totalEth,\r\n                horses_[H4].totalEth\r\n            ],\r\n            [\r\n                horses_[H1].totalCarrots,\r\n                horses_[H2].totalCarrots,\r\n                horses_[H3].totalCarrots,\r\n                horses_[H4].totalCarrots\r\n            ],\r\n            [\r\n                players_[msg.sender].totalEth[H1],\r\n                players_[msg.sender].totalEth[H2],\r\n                players_[msg.sender].totalEth[H3],\r\n                players_[msg.sender].totalEth[H4]\r\n            ],\r\n            [\r\n                players_[msg.sender].totalCarrots[H1],\r\n                players_[msg.sender].totalCarrots[H2],\r\n                players_[msg.sender].totalCarrots[H3],\r\n                players_[msg.sender].totalCarrots[H4]\r\n            ],\r\n            [\r\n                horses_[H1].name,\r\n                horses_[H2].name,\r\n                horses_[H3].name,\r\n                horses_[H4].name\r\n            ]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns data for past 50 rounds\r\n     * @param roundStart which round to start returning data at (0 means current)\r\n     * @return round number this index in the arrays corresponds to\r\n     * @return winning horses for past 50 finished rounds\r\n     * @return horse1 carrot amounts for past 50 rounds\r\n     * @return horse2 carrot amounts for past 50 rounds\r\n     * @return horse3 carrot amounts for past 50 rounds\r\n     * @return horse4 carrot amounts for past 50 rounds\r\n     * @return horse1 players carrots for past 50 rounds\r\n     * @return horse2 players carrots for past 50 rounds\r\n     * @return horse3 players carrots for past 50 rounds\r\n     * @return horse4 players carrots for past 50 rounds\r\n     * @return horseEth total eth amounts for past 50 rounds\r\n     * @return playerEth total player eth amounts for past 50 rounds\r\n     */\r\n    function getPastRounds(uint256 roundStart)\r\n        public\r\n        view\r\n        returns(\r\n            uint256[50] roundNums,\r\n            uint8[50] winners,\r\n            uint256[50] horse1Carrots,\r\n            uint256[50] horse2Carrots,\r\n            uint256[50] horse3Carrots,\r\n            uint256[50] horse4Carrots,\r\n            uint256[50] horse1PlayerCarrots,\r\n            uint256[50] horse2PlayerCarrots,\r\n            uint256[50] horse3PlayerCarrots,\r\n            uint256[50] horse4PlayerCarrots,\r\n            uint256[50] horseEth,\r\n            uint256[50] playerEth\r\n        )\r\n    {\r\n        uint256 index = 0;\r\n        uint256 round = rID_;\r\n        if (roundStart != 0 && roundStart <= rID_) {\r\n            round = roundStart;\r\n        }\r\n        while (index < 50 && round > 0) {\r\n            if (round == rID_ && !isRoundOver()) {\r\n                round--;\r\n                continue;\r\n            }\r\n            roundNums[index] = round;\r\n            winners[index] = rounds_[round].winner;\r\n            horse1Carrots[index] = rounds_[round].carrots[H1];\r\n            horse2Carrots[index] = rounds_[round].carrots[H2];\r\n            horse3Carrots[index] = rounds_[round].carrots[H3];\r\n            horse4Carrots[index] = rounds_[round].carrots[H4];\r\n            horse1PlayerCarrots[index] = players_[msg.sender].carrots[round][H1];\r\n            horse2PlayerCarrots[index] = players_[msg.sender].carrots[round][H2];\r\n            horse3PlayerCarrots[index] = players_[msg.sender].carrots[round][H3];\r\n            horse4PlayerCarrots[index] = players_[msg.sender].carrots[round][H4];\r\n            horseEth[index] = rounds_[round].eth[H1]\r\n                .add(rounds_[round].eth[H2])\r\n                .add(rounds_[round].eth[H3])\r\n                .add(rounds_[round].eth[H4]);\r\n            playerEth[index] = players_[msg.sender].eth[round][H1]\r\n                .add(players_[msg.sender].eth[round][H2])\r\n                .add(players_[msg.sender].eth[round][H3])\r\n                .add(players_[msg.sender].eth[round][H4]);\r\n            index++;\r\n            round--;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculate price of buying carrots for a specific horse\r\n     * @param _horse which horse to calculate price for\r\n     * @param _carrots how many carrots desired\r\n     * @return ETH required to purchase X many carrots\r\n     */\r\n    function getPriceOfXCarrots(uint8 _horse, uint256 _carrots)\r\n        public\r\n        view\r\n        isValidHorse(_horse)\r\n        returns(uint256)\r\n    {\r\n        return calculateCurrentPrice(_horse, _carrots.mul(1000000000000000000));\r\n    }\r\n\r\n    /**\r\n     * @dev calculate price to become majority carrot holder for a specific horse\r\n     * @param _horse which horse to calculate price for\r\n     * @return carrotsRequired\r\n     * @return ethRequired\r\n     * @return currentMax\r\n     * @return owner\r\n     * @return ownerName\r\n     */\r\n    function getPriceToName(uint8 _horse)\r\n        public\r\n        view\r\n        isValidHorse(_horse)\r\n        returns(\r\n            uint256 carrotsRequired,\r\n            uint256 ethRequired,\r\n            uint256 currentMax,\r\n            address owner,\r\n            bytes32 ownerName\r\n        )\r\n    {\r\n        if (players_[msg.sender].totalCarrots[_horse] < horses_[_horse].mostCarrotsOwned) {\r\n            // player is not already majority holder\r\n            // Have user buy one carrot more than current max\r\n            carrotsRequired = horses_[_horse].mostCarrotsOwned.sub(players_[msg.sender].totalCarrots[_horse]).add(10**DECIMALS);\r\n            ethRequired = calculateCurrentPrice(_horse, carrotsRequired);\r\n        }\r\n        currentMax = horses_[_horse].mostCarrotsOwned;\r\n        owner = horses_[_horse].owner;\r\n        ownerName = players_[horses_[_horse].owner].name;\r\n    }\r\n}\r\n\r\n\r\n//   __   _   ___ ___  _ ___    __   _   _   __  _ _  _     _  ___ _  ___\r\n//  / _| / \\ | o \\ o \\/ \\_ _|  / _| / \\ | | / _|| | || |   / \\|_ _/ \\| o \\\r\n// ( (_ | o ||   /   ( o ) |  ( (_ | o || |( (_ | U || |_ | o || ( o )   /\r\n//  \\__||_n_||_|\\\\_|\\\\\\_/|_|   \\__||_n_||___\\__||___||___||_n_||_|\\_/|_|\\\\\r\n//\r\nlibrary CalcCarrots {\r\n    using SafeMath for *;\r\n\r\n    /**\r\n     * @dev calculates number of carrots recieved given X eth\r\n     */\r\n    function carrotsReceived(uint256 _currEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return carrots((_currEth).add(_newEth)).sub(carrots(_currEth));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates amount of eth received if you sold X carrots\r\n     */\r\n    function ethReceived(uint256 _currCarrots, uint256 _sellCarrots)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return eth(_currCarrots).sub(eth(_currCarrots.sub(_sellCarrots)));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many carrots for a single horse given an amount\r\n     * of eth spent on that horse\r\n     */\r\n    function carrots(uint256 _eth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return ((((_eth).mul(62831853072000000000000000000000000000000000000)\r\n            .add(9996858654086510028837239824000000000000000000000000000000000000)).sqrt())\r\n            .sub(99984292036732000000000000000000)) / (31415926536);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how much eth would be in the contract for a single\r\n     * horse given an amount of carrots bought for that horse\r\n     */\r\n    function eth(uint256 _carrots)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return ((15707963268).mul(_carrots.mul(_carrots)).add(((199968584073464)\r\n            .mul(_carrots.mul(1000000000000000000))) / (2))) / (1000000000000000000000000000000000000);\r\n    }\r\n}\r\n\r\n\r\n//  __  _   ___  ___   _   _   _  ___  _ _\r\n// / _|/ \\ | __|| __| | \\_/ | / \\|_ _|| U |\r\n// \\_ \\ o || _| | _|  | \\_/ || o || | |   |\r\n// |__/_n_||_|  |___| |_| |_||_n_||_| |_n_|\r\n//\r\n\r\n/**\r\n * @title SafeMath library from OpenZeppelin\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeConversions {\r\n    function SafeSigned(uint256 a) internal pure returns (int256) {\r\n        int256 b = int256(a);\r\n        // If a is too large, the signed version will be negative.\r\n        assert(b >= 0);\r\n        return b;\r\n    }\r\n\r\n    function SafeUnsigned(int256 a) internal pure returns (uint256) {\r\n        // Only negative numbers are unsafe to make unsigned.\r\n        assert(a >= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\nlibrary NameValidator {\r\n    /**\r\n     * @dev throws on invalid name\r\n     * -converts uppercase to lower case\r\n     * -cannot contain space\r\n     * -cannot be only numbers\r\n     * -cannot be an address (start with 0x)\r\n     * -restricts characters to A-Z, a-z, 0-9\r\n     * @return validated string in bytes32 format\r\n     */\r\n    function validate(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory temp = bytes(_input);\r\n        uint256 length = temp.length;\r\n        \r\n        // limited to 15 characters\r\n        require (length <= 15 && length > 0, \"name must be between 1 and 15 characters\");\r\n        // cannot be an address\r\n        if (temp[0] == 0x30) {\r\n            require(temp[1] != 0x78, \"name cannot start with 0x\");\r\n            require(temp[1] != 0x58, \"name cannot start with 0X\");\r\n        }\r\n        bool _hasNonNumber;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            // if its uppercase A-Z\r\n            if (temp[i] > 0x40 && temp[i] < 0x5b) {\r\n                // convert to lower case\r\n                temp[i] = byte(uint(temp[i]) + 32);\r\n                // character is non number\r\n                if (_hasNonNumber == false) {\r\n                    _hasNonNumber = true;\r\n                }\r\n            } else {\r\n                // character should be only lowercase a-z or 0-9\r\n                require ((temp[i] > 0x60 && temp[i] < 0x7b) || (temp[i] > 0x2f && temp[i] < 0x3a), \"name contains invalid characters\");\r\n\r\n                // check if character is non number \r\n                if (_hasNonNumber == false && (temp[i] < 0x30 || temp[i] > 0x39)) {\r\n                    _hasNonNumber = true;    \r\n                }\r\n            }\r\n        }\r\n        require(_hasNonNumber == true, \"name cannot be only numbers\");\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"totalWinnings\",\"type\":\"uint256\"},{\"name\":\"totalReferrals\",\"type\":\"uint256\"},{\"name\":\"dividendPayouts\",\"type\":\"int256\"},{\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"name\":\"totalReinvested\",\"type\":\"uint256\"},{\"name\":\"roundLastManaged\",\"type\":\"uint256\"},{\"name\":\"roundLastReferred\",\"type\":\"uint256\"},{\"name\":\"lastRef\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameStr\",\"type\":\"string\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getPastRoundStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_horse\",\"type\":\"uint8\"}],\"name\":\"getPriceToName\",\"outputs\":[{\"name\":\"carrotsRequired\",\"type\":\"uint256\"},{\"name\":\"ethRequired\",\"type\":\"uint256\"},{\"name\":\"currentMax\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"ownerName\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_horse\",\"type\":\"uint8\"},{\"name\":\"_carrots\",\"type\":\"uint256\"}],\"name\":\"getPriceOfXCarrots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_horse\",\"type\":\"uint8\"},{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_referrerName\",\"type\":\"bytes32\"}],\"name\":\"buyCarrots\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"isNameAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds_\",\"outputs\":[{\"name\":\"winner\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REGISTERFEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_horse\",\"type\":\"uint8\"},{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_referrerName\",\"type\":\"bytes32\"}],\"name\":\"reinvestInCarrots\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundStart\",\"type\":\"uint256\"}],\"name\":\"getPastRounds\",\"outputs\":[{\"name\":\"roundNums\",\"type\":\"uint256[50]\"},{\"name\":\"winners\",\"type\":\"uint8[50]\"},{\"name\":\"horse1Carrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse2Carrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse3Carrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse4Carrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse1PlayerCarrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse2PlayerCarrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse3PlayerCarrots\",\"type\":\"uint256[50]\"},{\"name\":\"horse4PlayerCarrots\",\"type\":\"uint256[50]\"},{\"name\":\"horseEth\",\"type\":\"uint256[50]\"},{\"name\":\"playerEth\",\"type\":\"uint256[50]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"bytes32[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRoundStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"uint256[4]\"},{\"name\":\"\",\"type\":\"bytes32[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_horse\",\"type\":\"uint8\"},{\"name\":\"_nameStr\",\"type\":\"string\"},{\"name\":\"_referrerName\",\"type\":\"bytes32\"}],\"name\":\"nameHorse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"horse\",\"type\":\"uint8[2]\"},{\"indexed\":true,\"name\":\"horseName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"uint256[6]\"},{\"indexed\":false,\"name\":\"roundEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnCarrotsPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"OnEthWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"horse\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"horseName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"mostCarrotsOwned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnHorseNamed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethDonated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnNameRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"bytes32\"}],\"name\":\"OnTransactionFail\",\"type\":\"event\"}]","ContractName":"EtherDerby","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://59143cca1f4a30ae88a4d6456817108ad7cec9c70f0eb0d7ec65c55df0f02983"}]}