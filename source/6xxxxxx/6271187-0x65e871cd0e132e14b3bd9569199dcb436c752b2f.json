{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\nlibrary Dictionary {\r\n    uint constant private NULL = 0;\r\n\r\n    struct Node {\r\n        uint prev;\r\n        uint next;\r\n        uint data;\r\n        bool initialized;\r\n    }\r\n\r\n    struct Data {\r\n        mapping(uint => Node) list;\r\n        uint firstNodeId;\r\n        uint lastNodeId;\r\n        uint len;\r\n    }\r\n\r\n    function insertAfter(Data storage self, uint afterId, uint id, uint data) internal {\r\n        if (self.list[id].initialized) {\r\n            self.list[id].data = data;\r\n            return;\r\n        }\r\n        self.list[id].prev = afterId;\r\n        if (self.list[afterId].next == NULL) {\r\n            self.list[id].next =  NULL;\r\n            self.lastNodeId = id;\r\n        } else {\r\n            self.list[id].next = self.list[afterId].next;\r\n            self.list[self.list[afterId].next].prev = id;\r\n        }\r\n        self.list[id].data = data;\r\n        self.list[id].initialized = true;\r\n        self.list[afterId].next = id;\r\n        self.len++;\r\n    }\r\n\r\n    function insertBefore(Data storage self, uint beforeId, uint id, uint data) internal {\r\n        if (self.list[id].initialized) {\r\n            self.list[id].data = data;\r\n            return;\r\n        }\r\n        self.list[id].next = beforeId;\r\n        if (self.list[beforeId].prev == NULL) {\r\n            self.list[id].prev = NULL;\r\n            self.firstNodeId = id;\r\n        } else {\r\n            self.list[id].prev = self.list[beforeId].prev;\r\n            self.list[self.list[beforeId].prev].next = id;\r\n        }\r\n        self.list[id].data = data;\r\n        self.list[id].initialized = true;\r\n        self.list[beforeId].prev = id;\r\n        self.len++;\r\n    }\r\n\r\n    function insertBeginning(Data storage self, uint id, uint data) internal {\r\n        if (self.list[id].initialized) {\r\n            self.list[id].data = data;\r\n            return;\r\n        }\r\n        if (self.firstNodeId == NULL) {\r\n            self.firstNodeId = id;\r\n            self.lastNodeId = id;\r\n            self.list[id] = Node({ prev: 0, next: 0, data: data, initialized: true });\r\n            self.len++;\r\n        } else\r\n            insertBefore(self, self.firstNodeId, id, data);\r\n    }\r\n\r\n    function insertEnd(Data storage self, uint id, uint data) internal {\r\n        if (self.lastNodeId == NULL) insertBeginning(self, id, data);\r\n        else\r\n            insertAfter(self, self.lastNodeId, id, data);\r\n    }\r\n\r\n    function set(Data storage self, uint id, uint data) internal {\r\n        insertEnd(self, id, data);\r\n    }\r\n\r\n    function get(Data storage self, uint id) internal view returns (uint) {\r\n        return self.list[id].data;\r\n    }\r\n\r\n    function remove(Data storage self, uint id) internal returns (bool) {\r\n        uint nextId = self.list[id].next;\r\n        uint prevId = self.list[id].prev;\r\n\r\n        if (prevId == NULL) self.firstNodeId = nextId; //first node\r\n        else self.list[prevId].next = nextId;\r\n\r\n        if (nextId == NULL) self.lastNodeId = prevId; //last node\r\n        else self.list[nextId].prev = prevId;\r\n\r\n        delete self.list[id];\r\n        self.len--;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getSize(Data storage self) internal view returns (uint) {\r\n        return self.len;\r\n    }\r\n\r\n    function next(Data storage self, uint id) internal view returns (uint) {\r\n        return self.list[id].next;\r\n    }\r\n\r\n    function prev(Data storage self, uint id) internal view returns (uint) {\r\n        return self.list[id].prev;\r\n    }\r\n\r\n    function keys(Data storage self) internal constant returns (uint[]) {\r\n        uint[] memory arr = new uint[](self.len);\r\n        uint node = self.firstNodeId;\r\n        for (uint i=0; i < self.len; i++) {\r\n            arr[i] = node;\r\n            node = next(self, node);\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n\r\ninterface Provider {\r\n    function isBrickOwner(uint _brickId, address _address) external view returns (bool success);\r\n    function addBrick(uint _brickId, string _title, string _url, uint32 _expired, string _description, bytes32[] _tags, uint _value)\r\n        external returns (bool success);\r\n    function changeBrick(\r\n        uint _brickId,\r\n        string _title,\r\n        string _url,\r\n        string _description,\r\n        bytes32[] _tags,\r\n        uint _value) external returns (bool success);\r\n    function accept(uint _brickId, address[] _builderAddresses, uint[] percentages, uint _additionalValue) external returns (uint total);\r\n    function cancel(uint _brickId) external returns (uint value);\r\n    function startWork(uint _brickId, bytes32 _builderId, bytes32 _nickName, address _builderAddress) external returns(bool success);\r\n    function getBrickIds() external view returns(uint[]);\r\n    function getBrickSize() external view returns(uint);\r\n    function getBrick(uint _brickId) external view returns(\r\n        string title,\r\n        string url, \r\n        address owner,\r\n        uint value,\r\n        uint32 dateCreated,\r\n        uint32 dateCompleted, \r\n        uint32 expired,\r\n        uint status\r\n    );\r\n\r\n    function getBrickDetail(uint _brickId) external view returns(\r\n        bytes32[] tags, \r\n        string description, \r\n        uint32 builders, \r\n        address[] winners\r\n    );\r\n\r\n    function getBrickBuilders(uint _brickId) external view returns (\r\n        address[] addresses,\r\n        uint[] dates,\r\n        bytes32[] keys,\r\n        bytes32[] names\r\n    );\r\n\r\n    function filterBrick(\r\n        uint _brickId, \r\n        bytes32[] _tags, \r\n        uint _status, \r\n        uint _started,\r\n        uint _expired\r\n        ) external view returns (\r\n      bool\r\n    );\r\n\r\n\r\n    function participated( \r\n        uint _brickId,\r\n        address _builder\r\n        ) external view returns (\r\n        bool\r\n    ); \r\n}\r\n\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_4\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract WeBuildWorldImplementation is Ownable, Provider {\r\n    using SafeMath for uint256;\t\r\n    using Dictionary for Dictionary.Data;\r\n\r\n    enum BrickStatus { Inactive, Active, Completed, Cancelled }\r\n\r\n    struct Builder {\r\n        address addr;\r\n        uint dateAdded;\r\n        bytes32 key;\r\n        bytes32 nickName;\r\n    }\r\n    \r\n    struct Brick {\r\n        string title;\r\n        string url;\r\n        string description;\r\n        bytes32[] tags;\r\n        address owner;\r\n        uint value;\r\n        uint32 dateCreated;\r\n        uint32 dateCompleted;\r\n        uint32 expired;\r\n        uint32 numBuilders;\r\n        BrickStatus status;\r\n        address[] winners;\r\n        mapping (uint => Builder) builders;\r\n    }\r\n\r\n    address public main = 0x0;\r\n    mapping (uint => Brick) public bricks;\r\n\r\n    string public constant VERSION = \"0.1\";\r\n    Dictionary.Data public brickIds;\r\n    uint public constant DENOMINATOR = 10000;\r\n\r\n    modifier onlyMain() {\r\n        require(msg.sender == main);\r\n        _;\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }    \r\n\r\n    function isBrickOwner(uint _brickId, address _address) external view returns (bool success) {\r\n        return bricks[_brickId].owner == _address;\r\n    }    \r\n\r\n    function addBrick(uint _brickId, string _title, string _url, uint32 _expired, string _description, bytes32[] _tags, uint _value) \r\n        external onlyMain\r\n        returns (bool success)\r\n    {\r\n        // greater than 0.01 eth\r\n        require(_value >= 10 ** 16);\r\n        // solhint-disable-next-line\r\n        require(bricks[_brickId].owner == 0x0 || bricks[_brickId].owner == tx.origin);\r\n\r\n        Brick memory brick = Brick({\r\n            title: _title,\r\n            url: _url,\r\n            description: _description,   \r\n            tags: _tags,\r\n            // solhint-disable-next-line\r\n            owner: tx.origin,\r\n            status: BrickStatus.Active,\r\n            value: _value,\r\n            // solhint-disable-next-line \r\n            dateCreated: uint32(now),\r\n            dateCompleted: 0,\r\n            expired: _expired,\r\n            numBuilders: 0,\r\n            winners: new address[](0)\r\n        });\r\n\r\n        // only add when it's new\r\n        if (bricks[_brickId].owner == 0x0) {\r\n            brickIds.insertBeginning(_brickId, 0);\r\n        }\r\n        bricks[_brickId] = brick;\r\n\r\n        return true;\r\n    }\r\n\r\n    function changeBrick(uint _brickId, string _title, string _url, string _description, bytes32[] _tags, uint _value) \r\n        external onlyMain\r\n        returns (bool success) \r\n    {\r\n        require(bricks[_brickId].status == BrickStatus.Active);\r\n\r\n        bricks[_brickId].title = _title;\r\n        bricks[_brickId].url = _url;\r\n        bricks[_brickId].description = _description;\r\n        bricks[_brickId].tags = _tags;\r\n\r\n        // Add to the fund.\r\n        if (_value > 0) {\r\n            bricks[_brickId].value = bricks[_brickId].value.add(_value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // msg.value is tip.\r\n    function accept(uint _brickId, address[] _winners, uint[] _weights, uint _value) \r\n        external onlyMain\r\n        returns (uint) \r\n    {\r\n        require(bricks[_brickId].status == BrickStatus.Active);\r\n        require(_winners.length == _weights.length);\r\n        // disallow to take to your own.\r\n\r\n        uint total = 0;\r\n        bool included = false;\r\n        for (uint i = 0; i < _winners.length; i++) {\r\n            // solhint-disable-next-line\r\n            require(_winners[i] != tx.origin, \"Owner should not win this himself\");\r\n            for (uint j =0; j < bricks[_brickId].numBuilders; j++) {\r\n                if (bricks[_brickId].builders[j].addr == _winners[i]) {\r\n                    included = true;\r\n                    break;\r\n                }\r\n            }\r\n            total = total.add(_weights[i]);\r\n        }\r\n\r\n        require(included, \"Winner doesn't participant\");\r\n        require(total == DENOMINATOR, \"total should be in total equals to denominator\");\r\n\r\n        bricks[_brickId].status = BrickStatus.Completed;\r\n        bricks[_brickId].winners = _winners;\r\n        // solhint-disable-next-line\r\n        bricks[_brickId].dateCompleted = uint32(now);\r\n\r\n        if (_value > 0) {\r\n            bricks[_brickId].value = bricks[_brickId].value.add(_value);\r\n        }\r\n\r\n        return bricks[_brickId].value;\r\n    }\r\n\r\n    function cancel(uint _brickId) \r\n        external onlyMain\r\n        returns (uint value) \r\n    {\r\n        require(bricks[_brickId].status != BrickStatus.Completed);\r\n        require(bricks[_brickId].status != BrickStatus.Cancelled);\r\n\r\n        bricks[_brickId].status = BrickStatus.Cancelled;\r\n\r\n        return bricks[_brickId].value;\r\n    }\r\n\r\n    function startWork(uint _brickId, bytes32 _builderId, bytes32 _nickName, address _builderAddress) \r\n        external onlyMain returns(bool success)\r\n    {\r\n        require(_builderAddress != 0x0);\r\n        require(bricks[_brickId].status == BrickStatus.Active);\r\n        require(_brickId >= 0);\r\n        require(bricks[_brickId].expired >= now);\r\n\r\n        bool included = false;\r\n\r\n        for (uint i = 0; i < bricks[_brickId].numBuilders; i++) {\r\n            if (bricks[_brickId].builders[i].addr == _builderAddress) {\r\n                included = true;\r\n                break;\r\n            }\r\n        }\r\n        require(!included);\r\n\r\n        // bricks[_brickId]\r\n        Builder memory builder = Builder({\r\n            addr: _builderAddress,\r\n            key: _builderId,\r\n            nickName: _nickName,\r\n            // solhint-disable-next-line\r\n            dateAdded: now\r\n        });\r\n        bricks[_brickId].builders[bricks[_brickId].numBuilders++] = builder;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getBrickIds() external view returns(uint[]) {\r\n        return brickIds.keys();\r\n    }    \r\n\r\n    function getBrickSize() external view returns(uint) {\r\n        return brickIds.getSize();\r\n    }\r\n\r\n    function _matchedTags(bytes32[] _tags, bytes32[] _stack) private pure returns (bool){\r\n        if(_tags.length > 0){\r\n            for (uint i = 0; i < _tags.length; i++) {\r\n                for(uint j = 0; j < _stack.length; j++){\r\n                    if(_tags[i] == _stack[j]){\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }else{\r\n            return true;\r\n        } \r\n    }\r\n\r\n    function participated(\r\n        uint _brickId,   \r\n        address _builder\r\n        )\r\n        external view returns (bool) {\r\n \r\n        for (uint j = 0; j < bricks[_brickId].numBuilders; j++) {\r\n            if (bricks[_brickId].builders[j].addr == _builder) {\r\n                return true;\r\n            }\r\n        } \r\n\r\n        return false;\r\n    }\r\n\r\n    \r\n    function filterBrick(\r\n        uint _brickId, \r\n        bytes32[] _tags, \r\n        uint _status, \r\n        uint _started,\r\n        uint _expired\r\n        )\r\n        external view returns (bool) {  \r\n        Brick memory brick = bricks[_brickId];  \r\n\r\n        bool satisfy = _matchedTags(_tags, brick.tags);  \r\n\r\n        if(_started > 0){\r\n            satisfy = brick.dateCreated >= _started;\r\n        }\r\n        \r\n        if(_expired > 0){\r\n            satisfy = brick.expired >= _expired;\r\n        }\r\n \r\n        return satisfy && (uint(brick.status) == _status\r\n            || uint(BrickStatus.Cancelled) < _status \r\n            || uint(BrickStatus.Inactive) > _status);\r\n    }\r\n\r\n    function getBrick(uint _brickId) external view returns (\r\n        string title,\r\n        string url,\r\n        address owner,\r\n        uint value,\r\n        uint32 dateCreated,\r\n        uint32 dateCompleted,\r\n        uint32 expired,\r\n        uint status\r\n    ) {\r\n        Brick memory brick = bricks[_brickId];\r\n        return (\r\n            brick.title,\r\n            brick.url,\r\n            brick.owner,\r\n            brick.value,\r\n            brick.dateCreated,\r\n            brick.dateCompleted,\r\n            brick.expired,\r\n            uint(brick.status)\r\n        );\r\n    }\r\n    \r\n    function getBrickDetail(uint _brickId) external view returns (\r\n        bytes32[] tags,\r\n        string description, \r\n        uint32 builders,\r\n        address[] winners\r\n    ) {\r\n        Brick memory brick = bricks[_brickId];\r\n        return ( \r\n            brick.tags, \r\n            brick.description, \r\n            brick.numBuilders,\r\n            brick.winners\r\n        );\r\n    }\r\n\r\n    function getBrickBuilders(uint _brickId) external view returns (\r\n        address[] addresses,\r\n        uint[] dates,\r\n        bytes32[] keys,\r\n        bytes32[] names\r\n    )\r\n    {\r\n        // Brick memory brick = bricks[_brickId];\r\n        addresses = new address[](bricks[_brickId].numBuilders);\r\n        dates = new uint[](bricks[_brickId].numBuilders);\r\n        keys = new bytes32[](bricks[_brickId].numBuilders);\r\n        names = new bytes32[](bricks[_brickId].numBuilders);\r\n\r\n        for (uint i = 0; i < bricks[_brickId].numBuilders; i++) {\r\n            addresses[i] = bricks[_brickId].builders[i].addr;\r\n            dates[i] = bricks[_brickId].builders[i].dateAdded;\r\n            keys[i] = bricks[_brickId].builders[i].key;\r\n            names[i] = bricks[_brickId].builders[i].nickName;\r\n        }\r\n    }    \r\n\r\n    function setMain(address _address) public onlyOwner returns(bool) {\r\n        main = _address;\r\n        return true;\r\n    }     \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_url\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_tags\",\"type\":\"bytes32[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeBrick\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"}],\"name\":\"getBrickDetail\",\"outputs\":[{\"name\":\"tags\",\"type\":\"bytes32[]\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"builders\",\"type\":\"uint32\"},{\"name\":\"winners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_tags\",\"type\":\"bytes32[]\"},{\"name\":\"_status\",\"type\":\"uint256\"},{\"name\":\"_started\",\"type\":\"uint256\"},{\"name\":\"_expired\",\"type\":\"uint256\"}],\"name\":\"filterBrick\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bricks\",\"outputs\":[{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"dateCreated\",\"type\":\"uint32\"},{\"name\":\"dateCompleted\",\"type\":\"uint32\"},{\"name\":\"expired\",\"type\":\"uint32\"},{\"name\":\"numBuilders\",\"type\":\"uint32\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_url\",\"type\":\"string\"},{\"name\":\"_expired\",\"type\":\"uint32\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_tags\",\"type\":\"bytes32[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addBrick\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMain\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_winners\",\"type\":\"address[]\"},{\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"accept\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isBrickOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBrickIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBrickSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"main\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"}],\"name\":\"getBrickBuilders\",\"outputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"dates\",\"type\":\"uint256[]\"},{\"name\":\"keys\",\"type\":\"bytes32[]\"},{\"name\":\"names\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_builderId\",\"type\":\"bytes32\"},{\"name\":\"_nickName\",\"type\":\"bytes32\"},{\"name\":\"_builderAddress\",\"type\":\"address\"}],\"name\":\"startWork\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"brickIds\",\"outputs\":[{\"name\":\"firstNodeId\",\"type\":\"uint256\"},{\"name\":\"lastNodeId\",\"type\":\"uint256\"},{\"name\":\"len\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"},{\"name\":\"_builder\",\"type\":\"address\"}],\"name\":\"participated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_brickId\",\"type\":\"uint256\"}],\"name\":\"getBrick\",\"outputs\":[{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"dateCreated\",\"type\":\"uint32\"},{\"name\":\"dateCompleted\",\"type\":\"uint32\"},{\"name\":\"expired\",\"type\":\"uint32\"},{\"name\":\"status\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"WeBuildWorldImplementation","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7ff8375f9bc2e700c6cc2a5868f1aa56ac33bd85c535ae98bc21ccfc60a7ecf3"}]}