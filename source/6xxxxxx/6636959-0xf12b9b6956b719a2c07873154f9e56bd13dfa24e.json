{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/Bankroll.sol\r\n\r\ninterface Bankroll {\r\n\r\n    //Customer functions\r\n\r\n    /// @dev Stores ETH funds for customer\r\n    function credit(address _customerAddress, uint256 amount) external returns (uint256);\r\n\r\n    /// @dev Debits address by an amount\r\n    function debit(address _customerAddress, uint256 amount) external returns (uint256);\r\n\r\n    /// @dev Withraws balance for address; returns amount sent\r\n    function withdraw(address _customerAddress) external returns (uint256);\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) external view returns (uint256);\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) external view returns (uint256[8]);\r\n\r\n\r\n    // System functions\r\n\r\n    // @dev Deposit funds\r\n    function deposit() external payable;\r\n\r\n    // @dev Deposit on behalf of an address; it is not a credit\r\n    function depositBy(address _customerAddress) external payable;\r\n\r\n    // @dev Distribute house profit\r\n    function houseProfit(uint256 amount)  external;\r\n\r\n\r\n    /// @dev Get all the ETH stored in contract minus credits to customers\r\n    function netEthereumBalance() external view returns (uint256);\r\n\r\n\r\n    /// @dev Get all the ETH stored in contract\r\n    function totalEthereumBalance() external view returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/P4RTYRelay.sol\r\n\r\n/*\r\n * Visit: https://p4rty.io\r\n * Discord: https://discord.gg/7y3DHYF\r\n*/\r\n\r\ninterface P4RTYRelay {\r\n    /**\r\n    * @dev Will relay to internal implementation\r\n    * @param beneficiary Token purchaser\r\n    * @param tokenAmount Number of tokens to be minted\r\n    */\r\n    function relay(address beneficiary, uint256 tokenAmount) external;\r\n}\r\n\r\n// File: contracts/SessionQueue.sol\r\n\r\n/// A FIFO queue for storing addresses\r\ncontract SessionQueue {\r\n\r\n    mapping(uint256 => address) private queue;\r\n    uint256 private first = 1;\r\n    uint256 private last = 0;\r\n\r\n    /// @dev Push into queue\r\n    function enqueue(address data) internal {\r\n        last += 1;\r\n        queue[last] = data;\r\n    }\r\n\r\n    /// @dev Returns true if the queue has elements in it\r\n    function available() internal view returns (bool) {\r\n        return last >= first;\r\n    }\r\n\r\n    /// @dev Returns the size of the queue\r\n    function depth() internal view returns (uint256) {\r\n        return last - first + 1;\r\n    }\r\n\r\n    /// @dev Pops from the head of the queue\r\n    function dequeue() internal returns (address data) {\r\n        require(last >= first);\r\n        // non-empty queue\r\n\r\n        data = queue[first];\r\n\r\n        delete queue[first];\r\n        first += 1;\r\n    }\r\n\r\n    /// @dev Returns the head of the queue without a pop\r\n    function peek() internal view returns (address data) {\r\n        require(last >= first);\r\n        // non-empty queue\r\n\r\n        data = queue[first];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable {\r\n  mapping(address => bool) public whitelist;\r\n\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    require(whitelist[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    if (!whitelist[addr]) {\r\n      whitelist[addr] = true;\r\n      emit WhitelistedAddressAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (addAddressToWhitelist(addrs[i])) {\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    if (whitelist[addr]) {\r\n      whitelist[addr] = false;\r\n      emit WhitelistedAddressRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (removeAddressFromWhitelist(addrs[i])) {\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/P6.sol\r\n\r\n// solhint-disable-line\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * Visit: https://p4rty.io\r\n * Discord: https://discord.gg/7y3DHYF\r\n * Stable + DIVIS: Whale and Minow Friendly\r\n * Fees balanced for maximum dividends for ALL\r\n * Active depositors rewarded with P4RTY tokens\r\n * 50% of ETH value in earned P4RTY token rewards\r\n * 2% of dividends fund a gaming bankroll; gaming profits are paid back into P6\r\n * P4RTYRelay is notified on all dividend producing transactions\r\n * Smart Launch phase which is anti-whale & anti-snipe\r\n *\r\n * P6\r\n * The worry free way to earn A TON OF ETH & P4RTY reward tokens\r\n *\r\n * -> What?\r\n * The first Ethereum Bonded Pure Dividend Token:\r\n * [✓] The only dividend printing press that is part of the P4RTY Entertainment Network\r\n * [✓] Earn ERC20 P4RTY tokens on all ETH deposit activities\r\n * [✓] 3% P6 Faucet for free P6 / P4RTY\r\n * [✓] Auto-Reinvests\r\n * [✓] 10% exchange fees on buys and sells\r\n * [✓] 100 tokens to activate faucet\r\n *\r\n * -> How?\r\n * To replay or use the faucet the contract must be fully launched\r\n * To sell or transfer you need to be vested (maximum of 3 days) after a reinvest\r\n*/\r\n\r\ncontract P6 is Whitelist, SessionQueue {\r\n\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyTokenHolders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyDivis {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only invested; If participating in prelaunch have to buy tokens\r\n    modifier invested {\r\n        require(stats[msg.sender].invested > 0, \"Must buy tokens once to withdraw\");\r\n        _;\r\n\r\n    }\r\n\r\n    /// @dev Owner not allowed\r\n    modifier ownerRestricted {\r\n        require(msg.sender != owner, \"Reap not available, too soon\");\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev The faucet has a rewardPeriod\r\n    modifier teamPlayer {\r\n        require(msg.sender == owner || now - lastReward[msg.sender] > rewardProcessingPeriod, \"No spamming\");\r\n        _;\r\n    }\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n    event onLog(\r\n        string heading,\r\n        address caller,\r\n        address subj,\r\n        uint val\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy,\r\n        uint timestamp,\r\n        uint256 price\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned,\r\n        uint timestamp,\r\n        uint256 price\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n\r\n    event onCommunityReward(\r\n        address indexed sourceAddress,\r\n        address indexed destinationAddress,\r\n        uint256 ethereumEarned\r\n    );\r\n\r\n    event onReinvestmentProxy(\r\n        address indexed customerAddress,\r\n        address indexed destinationAddress,\r\n        uint256 ethereumReinvested\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n\r\n    event onDeposit(\r\n        address indexed customerAddress,\r\n        uint256 ethereumDeposited\r\n    );\r\n\r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    /// @dev 10% dividends for token purchase\r\n    uint256  internal entryFee_ = 10;\r\n\r\n    /// @dev 1% dividends for token transfer\r\n    uint256  internal transferFee_ = 1;\r\n\r\n    /// @dev 10% dividends for token selling\r\n    uint256  internal exitFee_ = 10;\r\n\r\n    /// @dev 3% of entryFee_  is given to faucet\r\n    /// traditional referral mechanism repurposed as a many to many faucet\r\n    /// powers auto reinvest\r\n    uint256  internal referralFee_ = 30;\r\n\r\n    /// @dev 20% of entryFee/exit fee is given to Bankroll\r\n    uint256  internal maintenanceFee_ = 20;\r\n    address  internal maintenanceAddress;\r\n\r\n    //Advanced Config\r\n    uint256 constant internal botAllowance = 10 ether;\r\n    uint256 constant internal bankrollThreshold = 0.5 ether;\r\n    uint256 constant internal botThreshold = 0.01 ether;\r\n    uint256 constant internal launchPeriod = 24 hours;\r\n    uint256 constant rewardProcessingPeriod = 3 hours;\r\n    uint256 constant reapPeriod = 7 days;\r\n    uint256 public  maxProcessingCap = 10;\r\n    uint256 constant  launchGasMaximum = 500000;\r\n    uint256 constant launchETHMaximum = 2 ether;\r\n    uint256 internal creationTime;\r\n    bool public contractIsLaunched = false;\r\n    uint public lastReaped;\r\n\r\n\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n\r\n    /// @dev proof of stake (defaults at 100 tokens)\r\n    uint256 public stakingRequirement = 100e18;\r\n\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    // bookkeeping for autoreinvest\r\n    struct Bot {\r\n        bool active;\r\n        bool queued;\r\n        uint256 lastBlock;\r\n    }\r\n\r\n    // Onchain Stats!!!\r\n    struct Stats {\r\n        uint invested;\r\n        uint reinvested;\r\n        uint withdrawn;\r\n        uint rewarded;\r\n        uint contributed;\r\n        uint transferredTokens;\r\n        uint receivedTokens;\r\n        uint faucetTokens;\r\n        uint xInvested;\r\n        uint xReinvested;\r\n        uint xRewarded;\r\n        uint xContributed;\r\n        uint xWithdrawn;\r\n        uint xTransferredTokens;\r\n        uint xReceivedTokens;\r\n        uint xFaucet;\r\n    }\r\n\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal lastReward;\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => Bot) internal bot;\r\n    mapping(address => Stats) internal stats;\r\n    //on chain referral tracking\r\n    mapping(address => address) public referrals;\r\n    uint256 internal tokenSupply_;\r\n    uint256 internal profitPerShare_;\r\n\r\n    P4RTYRelay internal relay;\r\n    Bankroll internal bankroll;\r\n    bool internal bankrollEnabled = true;\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(address relayAddress)  public {\r\n\r\n        relay = P4RTYRelay(relayAddress);\r\n        updateMaintenanceAddress(msg.sender);\r\n        creationTime = now;\r\n    }\r\n\r\n    //Maintenance Functions\r\n\r\n    /// @dev Minted P4RTY tokens are sent to the maintenance address\r\n    function updateMaintenanceAddress(address maintenance) onlyOwner public {\r\n        maintenanceAddress = maintenance;\r\n    }\r\n\r\n    /// @dev Update the bankroll; 2% of dividends go to the bankroll\r\n    function updateBankrollAddress(address bankrollAddress) onlyOwner public {\r\n        bankroll = Bankroll(bankrollAddress);\r\n    }\r\n\r\n    /// @dev The cap determines the amount of addresses processed when a user runs the faucet\r\n    function updateProcessingCap(uint cap) onlyOwner public {\r\n        require(cap >= 5 && cap <= 15, \"Capacity set outside of policy range\");\r\n        maxProcessingCap = cap;\r\n    }\r\n\r\n\r\n    function getRegisteredAddresses() public view returns (address[2]){\r\n        return [address(relay), address(bankroll)];\r\n    }\r\n\r\n\r\n    //Bot Functions\r\n\r\n    /* Activates the bot and queues if necessary; else removes */\r\n    function activateBot(bool auto) public {\r\n\r\n        if (auto) {\r\n            // does the referrer have at least X whole tokens?\r\n            // i.e is the referrer a godly chad masternode\r\n            // We are doing this to avoid spamming the queue with addresses with no P6\r\n            require(tokenBalanceLedger_[msg.sender] >= stakingRequirement);\r\n\r\n            bot[msg.sender].active = auto;\r\n\r\n            //Spam protection for customerAddress\r\n            if (!bot[msg.sender].queued) {\r\n                bot[msg.sender].queued = true;\r\n                enqueue(msg.sender);\r\n            }\r\n\r\n        } else {\r\n            // If you want to turn it off lets just do that\r\n            bot[msg.sender].active = auto;\r\n        }\r\n    }\r\n\r\n    /* Returns if the sender has the reinvestment not enabled */\r\n    function botEnabled() public view returns (bool){\r\n        return bot[msg.sender].active;\r\n    }\r\n\r\n\r\n    function fundBankRoll(uint256 amount) internal {\r\n        bankroll.deposit.value(amount)();\r\n    }\r\n\r\n    /// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress) onlyWhitelisted public payable returns (uint256) {\r\n        return purchaseTokens(_customerAddress, msg.value);\r\n    }\r\n\r\n    /// @dev Converts all incoming ethereum to tokens for the caller\r\n    function buy() public payable returns (uint256) {\r\n\r\n        if (contractIsLaunched || msg.sender == owner) {\r\n            return purchaseTokens(msg.sender, msg.value);\r\n        } else {\r\n            return launchBuy();\r\n        }\r\n    }\r\n\r\n    /// @dev Provides a buiyin and opens the contract for public use outside of the launch phase\r\n    function launchBuy() internal returns (uint256){\r\n\r\n        /* YAY WE ARE LAUNCHING BABY!!!! */\r\n\r\n        // BankrollBot needs to buyin\r\n        require(stats[owner].invested > botAllowance, \"The bot requires a minimum war chest to protect and serve\");\r\n\r\n        // Keep it fair, but this is crypto...\r\n        require(SafeMath.add(stats[msg.sender].invested, msg.value) <= launchETHMaximum, \"Exceeded investment cap\");\r\n\r\n        //See if we are done with the launchPeriod\r\n        if (now - creationTime > launchPeriod ){\r\n            contractIsLaunched = true;\r\n        }\r\n\r\n        return purchaseTokens(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev Returns the remaining time before full launch and max buys\r\n    function launchTimer() public view returns (uint256){\r\n       uint lapse = now - creationTime;\r\n\r\n       if (launchPeriod > lapse){\r\n           return SafeMath.sub(launchPeriod, lapse);\r\n       }  else {\r\n           return 0;\r\n       }\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to handle ethereum that was send straight to the contract\r\n     *  Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function() payable public {\r\n        purchaseTokens(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() onlyDivis public {\r\n        reinvestFor(msg.sender);\r\n    }\r\n\r\n    /// @dev Internal utility method for reinvesting\r\n    function reinvestFor(address _customerAddress) internal returns (uint256) {\r\n\r\n        // fetch dividends\r\n        uint256 _dividends = totalDividends(_customerAddress, false);\r\n        // retrieve ref. bonus later in the code\r\n\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // retrieve ref. bonus\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(_customerAddress, _dividends);\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n\r\n        //Stats\r\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\r\n        stats[_customerAddress].xReinvested += 1;\r\n\r\n        return _tokens;\r\n\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() onlyDivis  public {\r\n        withdrawFor(msg.sender);\r\n    }\r\n\r\n    /// @dev Utility function for withdrawing earnings\r\n    function withdrawFor(address _customerAddress) internal {\r\n\r\n        // setup data\r\n        uint256 _dividends = totalDividends(_customerAddress, false);\r\n        // get ref. bonus later in the code\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // add ref. bonus\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        // lambo delivery service\r\n        _customerAddress.transfer(_dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\r\n        stats[_customerAddress].xWithdrawn += 1;\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n\r\n\r\n    /// @dev Liquifies tokens to ethereum.\r\n    function sell(uint256 _amountOfTokens) onlyTokenHolders ownerRestricted public {\r\n        address _customerAddress = msg.sender;\r\n\r\n        //Selling deactivates auto reinvest\r\n        bot[_customerAddress].active = false;\r\n\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n\r\n\r\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\r\n        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\r\n        //maintenance and referral come out of the exitfee\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _maintenance);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _undividedDividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n\r\n        //Apply maintenance fee to the bankroll\r\n        fundBankRoll(_maintenance);\r\n\r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply_ > 0) {\r\n            // update the amount of dividends per token\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        }\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum, now, buyPrice());\r\n\r\n        //GO!!! Bankroll Bot GO!!!\r\n        brbReinvest(_customerAddress);\r\n    }\r\n\r\n    //@dev Bankroll Bot can only transfer 10% of funds during a reapPeriod\r\n    //Its funds will always be locked because it always reinvests\r\n    function reap(address _toAddress) public onlyOwner {\r\n        require(now - lastReaped > reapPeriod, \"Reap not available, too soon\");\r\n        lastReaped = now;\r\n        transferTokens(owner, _toAddress, SafeMath.div(balanceOf(owner), 10));\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from the caller to a new holder.\r\n     *  Remember, there's a 1% fee here as well.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders ownerRestricted external returns (bool){\r\n        address _customerAddress = msg.sender;\r\n        return transferTokens(_customerAddress, _toAddress, _amountOfTokens);\r\n    }\r\n\r\n    /// @dev Utility function for transfering tokens\r\n    function transferTokens(address _customerAddress, address _toAddress, uint256 _amountOfTokens) internal returns (bool){\r\n\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (totalDividends(_customerAddress, true) > 0) {\r\n            withdrawFor(_customerAddress);\r\n        }\r\n\r\n        // liquify a percentage of the tokens that are transfered\r\n        // these are dispersed to shareholders\r\n        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\r\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\r\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\r\n\r\n        // burn the fee tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\r\n\r\n        // disperse dividends among holders\r\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n\r\n        // fire event\r\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n\r\n        //Stats\r\n        stats[_customerAddress].xTransferredTokens += 1;\r\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\r\n        stats[_toAddress].receivedTokens += _taxedTokens;\r\n        stats[_toAddress].xReceivedTokens += 1;\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    /**\r\n     * @dev Method to view the current Ethereum stored in the contract\r\n     *  Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\r\n     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\r\n     *  But in the internal calculations, we want them separate.\r\n     */\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\r\n     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\r\n     *  But in the internal calculations, we want them separate.\r\n     */\r\n    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\r\n        return totalDividends(msg.sender, _includeReferralBonus);\r\n    }\r\n\r\n    function totalDividends(address _customerAddress, bool _includeReferralBonus) internal view returns (uint256) {\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) public view returns (uint256[16]){\r\n        Stats memory s = stats[_customerAddress];\r\n        uint256[16] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested, s.faucetTokens, s.xFaucet];\r\n        return statArray;\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public view returns (uint256) {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(_ethereum, exitFee_);\r\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public view returns (uint256) {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(_ethereum, entryFee_);\r\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns (uint256) {\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingEthereum) internal returns (uint256) {\r\n        // data setup\r\n        address _referredBy = msg.sender;\r\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\r\n        uint256 _maintenance = SafeMath.div(SafeMath.mul(_undividedDividends, maintenanceFee_), 100);\r\n        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, referralFee_), 100);\r\n        //maintenance and referral come out of the buyin\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, SafeMath.add(_referralBonus, _maintenance));\r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee = _dividends * magnitude;\r\n        uint256 _tokenAllocation = SafeMath.div(_incomingEthereum, 2);\r\n\r\n\r\n        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\r\n        // (or hackers)\r\n        // and yes we know that the safemath function automatically rules out the \"greater then\" equasion.\r\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\r\n\r\n        //Apply maintenance fee to bankroll\r\n        fundBankRoll(_maintenance);\r\n\r\n        // is the user referred by a masternode?\r\n        if (\r\n\r\n        // no cheating!\r\n            _referredBy != _customerAddress &&\r\n\r\n            // does the referrer have at least X whole tokens?\r\n            // i.e is the referrer a godly chad masternode\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ) {\r\n            // wealth redistribution\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n\r\n            //Stats\r\n            stats[_referredBy].rewarded = SafeMath.add(stats[_referredBy].rewarded, _referralBonus);\r\n            stats[_referredBy].xRewarded += 1;\r\n            stats[_customerAddress].contributed = SafeMath.add(stats[_customerAddress].contributed, _referralBonus);\r\n            stats[_customerAddress].xContributed += 1;\r\n\r\n            //It pays to play\r\n            emit onCommunityReward(_customerAddress, _referredBy, _referralBonus);\r\n        } else {\r\n            // no ref purchase\r\n            // add the referral bonus back to the global dividends cake\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n\r\n        // we can't give people infinite ethereum\r\n        if (tokenSupply_ > 0) {\r\n            // add tokens to the pool\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n\r\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            profitPerShare_ += (_dividends * magnitude / tokenSupply_);\r\n\r\n            // calculate the amount of tokens the customer receives over his purchase\r\n            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really i know you think you do but you don't\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens - _fee);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n        //Notifying the relay is simple and should represent the total economic activity which is the _incomingEthereum\r\n        //Every player is a customer and mints their own tokens when the buy or reinvest, relay P4RTY 50/50\r\n        relay.relay(maintenanceAddress, _tokenAllocation);\r\n        relay.relay(_customerAddress, _tokenAllocation);\r\n\r\n        // fire event\r\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy, now, buyPrice());\r\n\r\n        //Stats\r\n        stats[_customerAddress].invested = SafeMath.add(stats[_customerAddress].invested, _incomingEthereum);\r\n        stats[_customerAddress].xInvested += 1;\r\n\r\n        //GO!!! Bankroll Bot GO!!!\r\n        brbReinvest(_customerAddress);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n        (\r\n        (\r\n        // underflow attempts BTFO\r\n        SafeMath.sub(\r\n            (sqrt\r\n        (\r\n            (_tokenPriceInitial ** 2)\r\n            +\r\n            (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\r\n            +\r\n            (((tokenPriceIncremental_) ** 2) * (tokenSupply_ ** 2))\r\n            +\r\n            (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_)\r\n        )\r\n            ), _tokenPriceInitial\r\n        )\r\n        ) / (tokenPriceIncremental_)\r\n        ) - (tokenSupply_)\r\n        ;\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    /**\r\n     * Calculate token sell value.\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n        // underflow attempts BTFO\r\n        SafeMath.sub(\r\n            (\r\n            (\r\n            (\r\n            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\r\n            ) - tokenPriceIncremental_\r\n            ) * (tokens_ - 1e18)\r\n            ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\r\n        )\r\n        / 1e18);\r\n        return _etherReceived;\r\n    }\r\n\r\n    /*\r\n        Is end user eligible to process rewards?\r\n    */\r\n    function rewardAvailable() public view returns (bool){\r\n        return available() && now - lastReward[msg.sender] > rewardProcessingPeriod &&\r\n        tokenBalanceLedger_[msg.sender] >= stakingRequirement;\r\n    }\r\n\r\n    /// @dev Returns timer info used for the vesting and the faucet\r\n    function timerInfo() public view returns (uint, uint, uint){\r\n        return (now, lastReward[msg.sender], rewardProcessingPeriod);\r\n    }\r\n\r\n\r\n    //This is where all your gas goes, sorry\r\n    //Not sorry, you probably only paid 1 gwei\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    //\r\n    // BankRollBot Functions\r\n    //\r\n\r\n    //Reinvest on all buys and sells\r\n    function brbReinvest(address _customerAddress) internal {\r\n        if (_customerAddress != owner && bankrollEnabled) {\r\n            if (totalDividends(owner, true) > bankrollThreshold) {\r\n                reinvestFor(owner);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /*\r\n        Can only be run once per day from the caller avoid bots\r\n        Minimum of 100 P6\r\n        Minimum of 5 P4RTY + amount minted based on dividends processed in 24 hour period\r\n    */\r\n    function processRewards() public teamPlayer {\r\n        require(tokenBalanceLedger_[msg.sender] >= stakingRequirement, \"Must meet staking requirement\");\r\n\r\n\r\n        uint256 count = 0;\r\n        address _customer;\r\n\r\n        while (available() && count < maxProcessingCap) {\r\n\r\n            //If this queue has already been processed in this block exit without altering the queue\r\n            _customer = peek();\r\n\r\n            if (bot[_customer].lastBlock == block.number) {\r\n                break;\r\n            }\r\n\r\n            //Pop\r\n            dequeue();\r\n\r\n\r\n            //Update tracking\r\n            bot[_customer].lastBlock = block.number;\r\n            bot[_customer].queued = false;\r\n\r\n            //User could have deactivated while still being queued\r\n            if (bot[_customer].active) {\r\n\r\n                // don't queue or process empty accounts\r\n                if (tokenBalanceLedger_[_customer] >= stakingRequirement) {\r\n\r\n                    //Reinvest divs; be gas efficient\r\n                    if (totalDividends(_customer, true) > botThreshold) {\r\n\r\n                        //No bankroll reinvest when processing the queue\r\n                        bankrollEnabled = false;\r\n                        reinvestFor(_customer);\r\n                        bankrollEnabled = true;\r\n                    }\r\n\r\n                    enqueue(_customer);\r\n                    bot[_customer].queued = true;\r\n\r\n                } else {\r\n                    // If minimums aren't met deactivate\r\n                    bot[_customer].active = false;\r\n                }\r\n            }\r\n\r\n            count++;\r\n        }\r\n\r\n        stats[msg.sender].xFaucet += 1;\r\n        lastReward[msg.sender] = now;\r\n        stats[msg.sender].faucetTokens = reinvestFor(msg.sender);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bankrollAddress\",\"type\":\"address\"}],\"name\":\"updateBankrollAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProcessingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[16]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegisteredAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maintenance\",\"type\":\"address\"}],\"name\":\"updateMaintenanceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"launchTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"botEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"reap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"updateProcessingCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastReaped\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auto\",\"type\":\"bool\"}],\"name\":\"activateBot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractIsLaunched\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"relayAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"heading\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subj\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"onLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sourceAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onCommunityReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"}],\"name\":\"onReinvestmentProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumDeposited\",\"type\":\"uint256\"}],\"name\":\"onDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"P6","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000a0a80cd0ff4f906ce7617a415787614a9651e1a","Library":"","SwarmSource":"bzzr://affaf4bb23f0a1991e8027e4acc2750125cbc58244372cd123fd257c2374d2e9"}]}