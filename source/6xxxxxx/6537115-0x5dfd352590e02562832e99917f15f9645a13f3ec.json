{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * Website: www.project567.pw\r\n *\r\n *\r\n * RECOMMENDED GAS LIMIT: 200000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract InvestorsStorage {\r\n    address private owner;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    struct Investor {\r\n        uint deposit;\r\n        uint checkpoint;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function updateInfo(address _address, uint _value) external onlyOwner {\r\n        investors[_address].deposit += _value;\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function updateCheckpoint(address _address) external onlyOwner {\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function d(address _address) external view onlyOwner returns(uint) {\r\n        return investors[_address].deposit;\r\n    }\r\n\r\n    function c(address _address) external view onlyOwner returns(uint) {\r\n        return investors[_address].checkpoint;\r\n    }\r\n\r\n    function getInterest(address _address) external view onlyOwner returns(uint) {\r\n        if (investors[_address].deposit <= 3000000000000000000) {\r\n            return 500;\r\n        } else if (investors[_address].deposit <= 6000000000000000000) {\r\n            return 600;\r\n        } else {\r\n            return 700;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Project567 {\r\n    using SafeMath for uint;\r\n\r\n    address public owner;\r\n    address admin;\r\n    address marketing;\r\n\r\n    uint waveStartUp;\r\n    uint nextPayDay;\r\n\r\n    event LogInvestment(address indexed _addr, uint _value);\r\n    event LogPayment(address indexed _addr, uint _value);\r\n    event LogReferralInvestment(address indexed _referral, address indexed _referrer, uint _value);\r\n    event LogNewWave(uint _waveStartUp);\r\n\r\n    InvestorsStorage private x;\r\n\r\n    modifier notOnPause() {\r\n        require(waveStartUp <= block.timestamp);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() external {\r\n        require(msg.sender == owner);\r\n        owner = 0x0;\r\n    }\r\n\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedReferrer) {\r\n        assembly {\r\n            parsedReferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedReferrer;\r\n    }\r\n\r\n    function toReferrer(uint _value) internal {\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\n        if (_referrer != msg.sender) {\r\n            _referrer.transfer(_value / 20);\r\n            emit LogReferralInvestment(msg.sender, _referrer, _value);\r\n        }\r\n    }\r\n\r\n    constructor(address _admin, address _marketing) public {\r\n        owner = msg.sender;\r\n        admin = _admin;\r\n        marketing = _marketing;\r\n        x = new InvestorsStorage();\r\n    }\r\n\r\n    function getInfo(address _address) external view returns(uint deposit, uint amountToWithdraw) {\r\n        deposit = x.d(_address);\r\n        amountToWithdraw = block.timestamp.sub(x.c(_address)).div(1 days).mul(x.d(_address).mul(x.getInterest(_address)).div(10000));\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value == 0) {\r\n            withdraw();\r\n        } else {\r\n            invest();\r\n        }\r\n    }\r\n\r\n    function invest() notOnPause public payable {\r\n\r\n        admin.transfer(msg.value * 5 / 100);\r\n        marketing.transfer(msg.value / 10);\r\n\r\n        if (x.d(msg.sender) > 0) {\r\n            withdraw();\r\n        }\r\n\r\n        x.updateInfo(msg.sender, msg.value);\r\n\r\n        if (msg.data.length == 20) {\r\n            toReferrer(msg.value);\r\n        }\r\n\r\n        emit LogInvestment(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw() notOnPause public {\r\n\r\n        if (address(this).balance < 100000000000000000) {\r\n            nextWave();\r\n            return;\r\n        }\r\n\r\n        uint _payout = block.timestamp.sub(x.c(msg.sender)).div(1 days).mul(x.d(msg.sender).mul(x.getInterest(msg.sender)).div(10000));\r\n        x.updateCheckpoint(msg.sender);\r\n\r\n        if (_payout > 0) {\r\n            msg.sender.transfer(_payout);\r\n            emit LogPayment(msg.sender, _payout);\r\n        }\r\n    }\r\n\r\n    function nextWave() private {\r\n        x = new InvestorsStorage();\r\n        waveStartUp = block.timestamp + 7 days;\r\n        emit LogNewWave(waveStartUp);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_marketing\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogReferralInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_waveStartUp\",\"type\":\"uint256\"}],\"name\":\"LogNewWave\",\"type\":\"event\"}]","ContractName":"Project567","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b62cf05ae8e3029563bd88fa2095788def92ece3000000000000000000000000eaa63aab9ffeb216e8dc1cbe263962d13aee296f","Library":"","SwarmSource":"bzzr://5603f2fbff872d0885a7e229b6c57ae3fed128b5375bea1bd219cd0e5b2e1b73"}]}