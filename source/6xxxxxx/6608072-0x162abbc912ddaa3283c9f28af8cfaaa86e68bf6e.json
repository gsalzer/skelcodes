{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract IStorage {\r\n  function processPreSaleBonus(uint minTotalUsdAmountInCents, uint bonusPercent, uint _start, uint _limit) external returns(uint);\r\n  function checkNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents) external view returns(bool);\r\n  function getCountNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents, uint start, uint limit) external view returns(uint);\r\n  function reCountUserPreSaleBonus(uint uId, uint minTotalUsdAmountInCents, uint bonusPercent, uint maxPayTime) external returns(uint, uint);\r\n  function getContributorIndexes(uint index) external view returns(uint);\r\n  function checkNeedSendSHPC(bool proc) external view returns(bool);\r\n  function getCountNeedSendSHPC(uint start, uint limit) external view returns(uint);\r\n  function checkETHRefund(bool proc) external view returns(bool);\r\n  function getCountETHRefund(uint start, uint limit) external view returns(uint);\r\n  function addPayment(address _addr, string pType, uint _value, uint usdAmount, uint currencyUSD, uint tokenWithoutBonus, uint tokenBonus, uint bonusPercent, uint payId) public returns(bool);\r\n  function addPayment(uint uId, string pType, uint _value, uint usdAmount, uint currencyUSD, uint tokenWithoutBonus, uint tokenBonus, uint bonusPercent, uint payId) public returns(bool);\r\n  function checkUserIdExists(uint uId) public view returns(bool);\r\n  function getContributorAddressById(uint uId) public view returns(address);\r\n  function editPaymentByUserId(uint uId, uint payId, uint _payValue, uint _usdAmount, uint _currencyUSD, uint _totalToken, uint _tokenWithoutBonus, uint _tokenBonus, uint _bonusPercent) public returns(bool);\r\n  function getUserPaymentById(uint uId, uint payId) public view returns(uint time, bytes32 pType, uint currencyUSD, uint bonusPercent, uint payValue, uint totalToken, uint tokenBonus, uint tokenWithoutBonus, uint usdAbsRaisedInCents, bool refund);\r\n  function checkWalletExists(address addr) public view returns(bool result);\r\n  function checkReceivedCoins(address addr) public view returns(bool);\r\n  function getContributorId(address addr) public view returns(uint);\r\n  function getTotalCoin(address addr) public view returns(uint);\r\n  function setReceivedCoin(uint uId) public returns(bool);\r\n  function checkPreSaleReceivedBonus(address addr) public view returns(bool);\r\n  function checkRefund(address addr) public view returns(bool);\r\n  function setRefund(uint uId) public returns(bool);\r\n  function getEthPaymentContributor(address addr) public view returns(uint);\r\n  function refundPaymentByUserId(uint uId, uint payId) public returns(bool);\r\n  function changeSupportChangeMainWallet(bool support) public returns(bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title String\r\n * @dev ConcatenationString, uintToString, stringsEqual, stringToBytes32, bytes32ToString\r\n */\r\ncontract String {\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string memory) {\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    bytes memory abcde = bytes(new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length));\r\n    uint k = 0;\r\n    uint i;\r\n    for (i = 0; i < _ba.length; i++) {\r\n      abcde[k++] = _ba[i];\r\n    }\r\n    for (i = 0; i < _bb.length; i++) {\r\n      abcde[k++] = _bb[i];\r\n    }\r\n    for (i = 0; i < _bc.length; i++) {\r\n      abcde[k++] = _bc[i];\r\n    }\r\n    for (i = 0; i < _bd.length; i++) {\r\n      abcde[k++] = _bd[i];\r\n    }\r\n    for (i = 0; i < _be.length; i++) {\r\n      abcde[k++] = _be[i];\r\n    }\r\n    return string(abcde);\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d) internal pure returns(string) {\r\n    return strConcat(_a, _b, _c, _d, \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c) internal pure returns(string) {\r\n    return strConcat(_a, _b, _c, \"\", \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b) internal pure returns(string) {\r\n    return strConcat(_a, _b, \"\", \"\", \"\");\r\n  }\r\n\r\n  function uint2str(uint i) internal pure returns(string) {\r\n    if (i == 0) {\r\n      return \"0\";\r\n    }\r\n    uint j = i;\r\n    uint length;\r\n    while (j != 0) {\r\n      length++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(length);\r\n    uint k = length - 1;\r\n    while (i != 0) {\r\n      bstr[k--] = byte(uint8(48 + i % 10));\r\n      i /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n\r\n  function stringsEqual(string memory _a, string memory _b) internal pure returns(bool) {\r\n    bytes memory a = bytes(_a);\r\n    bytes memory b = bytes(_b);\r\n\r\n    if (a.length != b.length)\r\n      return false;\r\n\r\n    for (uint i = 0; i < a.length; i++) {\r\n      if (a[i] != b[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function stringToBytes32(string memory source) internal pure returns(bytes32 result) {\r\n    bytes memory _tmp = bytes(source);\r\n    if (_tmp.length == 0) {\r\n      return 0x0;\r\n    }\r\n    assembly {\r\n      result := mload(add(source, 32))\r\n    }\r\n  }\r\n\r\n  function bytes32ToString(bytes32 x) internal pure returns (string) {\r\n    bytes memory bytesString = new bytes(32);\r\n    uint charCount = 0;\r\n    uint j;\r\n    for (j = 0; j < 32; j++) {\r\n      byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n      if (char != 0) {\r\n        bytesString[charCount] = char;\r\n        charCount++;\r\n      }\r\n    }\r\n    bytes memory bytesStringTrimmed = new bytes(charCount);\r\n    for (j = 0; j < charCount; j++) {\r\n      bytesStringTrimmed[j] = bytesString[j];\r\n    }\r\n    return string(bytesStringTrimmed);\r\n  }\r\n\r\n  function inArray(string[] _array, string _value) internal pure returns(bool result) {\r\n    if (_array.length == 0 || bytes(_value).length == 0) {\r\n      return false;\r\n    }\r\n    result = false;\r\n    for (uint i = 0; i < _array.length; i++) {\r\n      if (stringsEqual(_array[i],_value)) {\r\n        result = true;\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor () public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has an owner address[], and provides basic authorization control\r\n */\r\ncontract MultiOwnable is Ownable {\r\n\r\n  struct Types {\r\n    mapping (address => bool) access;\r\n  }\r\n  mapping (uint => Types) private multiOwnersTypes;\r\n\r\n  event AddOwner(uint _type, address addr);\r\n  event AddOwner(uint[] types, address addr);\r\n  event RemoveOwner(uint _type, address addr);\r\n\r\n  modifier onlyMultiOwnersType(uint _type) {\r\n    require(multiOwnersTypes[_type].access[msg.sender] || msg.sender == owner, \"403\");\r\n    _;\r\n  }\r\n\r\n  function onlyMultiOwnerType(uint _type, address _sender) public view returns(bool) {\r\n    if (multiOwnersTypes[_type].access[_sender] || _sender == owner) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function addMultiOwnerType(uint _type, address _owner) public onlyOwner returns(bool) {\r\n    require(_owner != address(0));\r\n    multiOwnersTypes[_type].access[_owner] = true;\r\n    emit AddOwner(_type, _owner);\r\n    return true;\r\n  }\r\n  \r\n  function addMultiOwnerTypes(uint[] types, address _owner) public onlyOwner returns(bool) {\r\n    require(_owner != address(0));\r\n    require(types.length > 0);\r\n    for (uint i = 0; i < types.length; i++) {\r\n      multiOwnersTypes[types[i]].access[_owner] = true;\r\n    }\r\n    emit AddOwner(types, _owner);\r\n    return true;\r\n  }\r\n\r\n  function removeMultiOwnerType(uint types, address _owner) public onlyOwner returns(bool) {\r\n    require(_owner != address(0));\r\n    multiOwnersTypes[types].access[_owner] = false;\r\n    emit RemoveOwner(types, _owner);\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract ShipCoinStorage is IStorage, MultiOwnable, String {\r\n  using SafeMath for uint256;\r\n\r\n  /* Events */\r\n  event WhitelistAddressAdded(address addr);\r\n  event WhitelistAddressRemoved(address addr);\r\n  event AddPayment(address addr);\r\n  event GotPreSaleBonus(address addr);\r\n  event EditUserPayments(address addr, uint payId);\r\n  event RefundPayment(address addr, uint payId);\r\n  event ReceivedCoin(address addr);\r\n  event Refund(address addr);\r\n  event ChangeMainWallet(address addr);\r\n\r\n  struct PaymentData {\r\n    uint time;\r\n    bytes32 pType;\r\n    uint currencyUSD;\r\n    uint payValue;\r\n    uint totalToken;\r\n    uint tokenWithoutBonus;\r\n    uint tokenBonus;\r\n    uint bonusPercent;\r\n    uint usdAbsRaisedInCents;\r\n  }\r\n\r\n  struct StorageData {\r\n    bool active;\r\n    mapping(bytes32 => uint) payInCurrency;\r\n    uint totalToken;\r\n    uint tokenWithoutBonus;\r\n    uint tokenBonus;\r\n    uint usdAbsRaisedInCents;\r\n    mapping(uint => PaymentData) paymentInfo;\r\n    address mainWallet;\r\n    address[] wallet;\r\n  }\r\n  // uId = { }\r\n  mapping(uint => StorageData) private contributorList;\r\n  // wallet = uId\r\n  mapping(address => uint) private contributorIds;\r\n  // i++ = uId\r\n  mapping(uint => uint) private contributorIndexes;\r\n  //uId = payIds\r\n  mapping(uint => uint[]) private contributorPayIds;\r\n  uint public nextContributorIndex;\r\n\r\n  bytes32[] private currencyTicker;\r\n  // uId\r\n  mapping(uint => uint) private receivedPreSaleBonus;\r\n  // uId\r\n  mapping(uint => bool) private receivedCoin;\r\n  //payIds\r\n  mapping(uint => bool) private payIds;\r\n  //payIds\r\n  mapping(uint => bool) private refundPayIds;\r\n  //uId\r\n  mapping(uint => bool) private refundUserIds;\r\n\r\n  uint private startGenId = 100000;\r\n\r\n  bool public supportChangeMainWallet = true;\r\n\r\n  /**\r\n   * @dev Calculate contributors appoint presale bonus\r\n   */\r\n  function processPreSaleBonus(uint minTotalUsdAmountInCents, uint bonusPercent, uint _start, uint _limit) external onlyMultiOwnersType(12) returns(uint) {\r\n    require(minTotalUsdAmountInCents > 10000);\r\n    require(bonusPercent > 20 && bonusPercent < 50);\r\n    require(_limit >= 10);\r\n\r\n    uint start = _start;\r\n    uint limit = _limit;\r\n    uint bonusTokenAll = 0;\r\n    for (uint i = start; i < limit; i++) {\r\n      uint uId = contributorIndexes[i];\r\n      if (contributorList[uId].active && !checkPreSaleReceivedBonus(uId) && contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\r\n        uint bonusToken = contributorList[uId].tokenWithoutBonus.mul(bonusPercent).div(100);\r\n\r\n        contributorList[uId].totalToken += bonusToken;\r\n        contributorList[uId].tokenBonus = bonusToken;\r\n        receivedPreSaleBonus[uId] = bonusToken;\r\n        bonusTokenAll += bonusToken;\r\n        emit GotPreSaleBonus(contributorList[uId].mainWallet);\r\n      }\r\n    }\r\n\r\n    return bonusTokenAll;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks contributors who have not received their presale bonuses\r\n   */\r\n  function checkNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents) external view returns(bool) {\r\n    require(minTotalUsdAmountInCents > 10000);\r\n    bool processed = false;\r\n    for (uint i = 0; i < nextContributorIndex; i++) {\r\n      if (processed) {\r\n        break;\r\n      }\r\n      uint uId = contributorIndexes[i];\r\n      if (contributorList[uId].active && !refundUserIds[uId] && !checkPreSaleReceivedBonus(uId) && contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\r\n        processed = true;\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of contributors who have not received their presale bonuses\r\n   */\r\n  function getCountNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents, uint start, uint limit) external view returns(uint) {\r\n    require(minTotalUsdAmountInCents > 10000);\r\n    require(start >= 0 && limit >= 10);\r\n    uint processed = 0;\r\n    for (uint i = start; i < (limit > nextContributorIndex ? nextContributorIndex : limit); i++) {\r\n      uint uId = contributorIndexes[i];\r\n      if (contributorList[uId].active && !refundUserIds[uId] && !checkPreSaleReceivedBonus(uId) && contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\r\n        processed++;\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks contributors who have not received their SHPC\r\n   */\r\n  function checkNeedSendSHPC(bool proc) external view returns(bool) {\r\n    bool processed = false;\r\n    if (proc) {\r\n      for (uint i = 0; i < nextContributorIndex; i++) {\r\n        if (processed) {\r\n          break;\r\n        }\r\n        uint uId = contributorIndexes[i];\r\n        if (contributorList[uId].active && !refundUserIds[uId] && !checkReceivedCoins(uId) && contributorList[uId].totalToken > 0) {\r\n          processed = true;\r\n        }\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of contributors who have not received their SHPC\r\n   */\r\n  function getCountNeedSendSHPC(uint start, uint limit) external view returns(uint) {\r\n    require(start >= 0 && limit >= 10);\r\n    uint processed = 0;\r\n    for (uint i = start; i < (limit > nextContributorIndex ? nextContributorIndex : limit); i++) {\r\n      uint uId = contributorIndexes[i];\r\n      if (contributorList[uId].active && !refundUserIds[uId] && !checkReceivedCoins(uId) && contributorList[uId].totalToken > 0) {\r\n        processed++;\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks contributors who have not received their ETH when refund\r\n   */\r\n  function checkETHRefund(bool proc) external view returns(bool) {\r\n    bool processed = false;\r\n    if (proc) {\r\n      for (uint i = 0; i < nextContributorIndex; i++) {\r\n        if (processed) {\r\n          break;\r\n        }\r\n        uint uId = contributorIndexes[i];\r\n        if (contributorList[uId].active && !refundUserIds[uId] && getEthPaymentContributor(uId) > 0) {\r\n          processed = true;\r\n        }\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of contributors who have not received their ETH when refund\r\n   */\r\n  function getCountETHRefund(uint start, uint limit) external view returns(uint) {\r\n    require(start >= 0 && limit >= 10);\r\n    uint processed = 0;\r\n    for (uint i = start; i < (limit > nextContributorIndex ? nextContributorIndex : limit); i++) {\r\n      uint uId = contributorIndexes[i];\r\n      if (contributorList[uId].active && !refundUserIds[uId] && getEthPaymentContributor(uId) > 0) {\r\n        processed++;\r\n      }\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns uId by index;\r\n   */\r\n  function getContributorIndexes(uint index) external onlyMultiOwnersType(7) view returns(uint) {\r\n    return contributorIndexes[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Recalculation contributors presale bonus\r\n   */\r\n  function reCountUserPreSaleBonus(uint _uId, uint minTotalUsdAmountInCents, uint bonusPercent, uint maxPayTime) external onlyMultiOwnersType(13) returns(uint, uint) {\r\n    require(_uId > 0);\r\n    require(contributorList[_uId].active);\r\n    require(!refundUserIds[_uId]);\r\n    require(minTotalUsdAmountInCents > 10000);\r\n    require(bonusPercent > 20 && bonusPercent < 50);\r\n    uint bonusToken = 0;\r\n    uint uId = _uId;\r\n    uint beforeBonusToken = receivedPreSaleBonus[uId];\r\n\r\n    if (beforeBonusToken > 0) {\r\n      contributorList[uId].totalToken -= beforeBonusToken;\r\n      contributorList[uId].tokenBonus -= beforeBonusToken;\r\n      receivedPreSaleBonus[uId] = 0;\r\n    }\r\n\r\n    if (contributorList[uId].usdAbsRaisedInCents >= minTotalUsdAmountInCents) {\r\n      if (maxPayTime > 0) {\r\n        for (uint i = 0; i < contributorPayIds[uId].length; i++) {\r\n          PaymentData memory _payment = contributorList[uId].paymentInfo[contributorPayIds[uId][i]];\r\n          if (!refundPayIds[contributorPayIds[uId][i]] && _payment.bonusPercent == 0 && _payment.time < maxPayTime) {\r\n            bonusToken += _payment.tokenWithoutBonus.mul(bonusPercent).div(100);\r\n          }\r\n        }\r\n      } else {\r\n        bonusToken = contributorList[uId].tokenWithoutBonus.mul(bonusPercent).div(100);\r\n      }\r\n\r\n      if (bonusToken > 0) {\r\n        contributorList[uId].totalToken += bonusToken;\r\n        contributorList[uId].tokenBonus += bonusToken;\r\n        receivedPreSaleBonus[uId] = bonusToken;\r\n        emit GotPreSaleBonus(contributorList[uId].mainWallet);\r\n      }\r\n    }\r\n    return (beforeBonusToken, bonusToken);\r\n  }\r\n\r\n  /**\r\n   * @dev add user and wallet to whitelist\r\n   */\r\n  function addWhiteList(uint uId, address addr) public onlyMultiOwnersType(1) returns(bool success) {\r\n    require(addr != address(0), \"1\");\r\n    require(uId > 0, \"2\");\r\n    require(!refundUserIds[uId]);\r\n\r\n    if (contributorIds[addr] > 0 && contributorIds[addr] != uId) {\r\n      success = false;\r\n      revert(\"3\");\r\n    }\r\n\r\n    if (contributorList[uId].active != true) {\r\n      contributorList[uId].active = true;\r\n      contributorIndexes[nextContributorIndex] = uId;\r\n      nextContributorIndex++;\r\n      contributorList[uId].mainWallet = addr;\r\n    }\r\n\r\n    if (inArray(contributorList[uId].wallet, addr) != true && contributorList[uId].wallet.length < 3) {\r\n      contributorList[uId].wallet.push(addr);\r\n      contributorIds[addr] = uId;\r\n      emit WhitelistAddressAdded(addr);\r\n      success = true;\r\n    } else {\r\n      success = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove user wallet from whitelist\r\n   */\r\n  function removeWhiteList(uint uId, address addr) public onlyMultiOwnersType(2) returns(bool success) {\r\n    require(contributorList[uId].active, \"1\");\r\n    require(addr != address(0), \"2\");\r\n    require(uId > 0, \"3\");\r\n    require(inArray(contributorList[uId].wallet, addr));\r\n\r\n    if (contributorPayIds[uId].length > 0 || contributorList[uId].mainWallet == addr) {\r\n      success = false;\r\n      revert(\"5\");\r\n    }\r\n\r\n\r\n    contributorList[uId].wallet = removeValueFromArray(contributorList[uId].wallet, addr);\r\n    delete contributorIds[addr];\r\n\r\n    emit WhitelistAddressRemoved(addr);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Change contributor mainWallet\r\n   */\r\n  function changeMainWallet(uint uId, address addr) public onlyMultiOwnersType(3) returns(bool) {\r\n    require(supportChangeMainWallet);\r\n    require(addr != address(0));\r\n    require(uId > 0);\r\n    require(contributorList[uId].active);\r\n    require(!refundUserIds[uId]);\r\n    require(inArray(contributorList[uId].wallet, addr));\r\n\r\n    contributorList[uId].mainWallet = addr;\r\n    emit ChangeMainWallet(addr);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the right to change mainWallet\r\n   */\r\n  function changeSupportChangeMainWallet(bool support) public onlyMultiOwnersType(21) returns(bool) {\r\n    supportChangeMainWallet = support;\r\n    return supportChangeMainWallet;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns all contributor info by uId\r\n   */\r\n  function getContributionInfoById(uint _uId) public onlyMultiOwnersType(4) view returns(\r\n      bool active,\r\n      string payInCurrency,\r\n      uint totalToken,\r\n      uint tokenWithoutBonus,\r\n      uint tokenBonus,\r\n      uint usdAbsRaisedInCents,\r\n      uint[] paymentInfoIds,\r\n      address mainWallet,\r\n      address[] wallet,\r\n      uint preSaleReceivedBonus,\r\n      bool receivedCoins,\r\n      bool refund\r\n    )\r\n  {\r\n    uint uId = _uId;\r\n    return getContributionInfo(contributorList[uId].mainWallet);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns all contributor info by address\r\n   */\r\n  function getContributionInfo(address _addr)\r\n    public\r\n    view\r\n    returns(\r\n      bool active,\r\n      string payInCurrency,\r\n      uint totalToken,\r\n      uint tokenWithoutBonus,\r\n      uint tokenBonus,\r\n      uint usdAbsRaisedInCents,\r\n      uint[] paymentInfoIds,\r\n      address mainWallet,\r\n      address[] wallet,\r\n      uint preSaleReceivedBonus,\r\n      bool receivedCoins,\r\n      bool refund\r\n    )\r\n  {\r\n\r\n    address addr = _addr;\r\n    StorageData memory storData = contributorList[contributorIds[addr]];\r\n\r\n    (preSaleReceivedBonus, receivedCoins, refund) = getInfoAdditionl(addr);\r\n\r\n    return(\r\n    storData.active,\r\n    (contributorPayIds[contributorIds[addr]].length > 0 ? getContributorPayInCurrency(contributorIds[addr]) : \"[]\"),\r\n    storData.totalToken,\r\n    storData.tokenWithoutBonus,\r\n    storData.tokenBonus,\r\n    storData.usdAbsRaisedInCents,\r\n    contributorPayIds[contributorIds[addr]],\r\n    storData.mainWallet,\r\n    storData.wallet,\r\n    preSaleReceivedBonus,\r\n    receivedCoins,\r\n    refund\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns contributor id by address\r\n   */\r\n  function getContributorId(address addr) public onlyMultiOwnersType(5) view returns(uint) {\r\n    return contributorIds[addr];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns contributors address by uId\r\n   */\r\n  function getContributorAddressById(uint uId) public onlyMultiOwnersType(6) view returns(address) {\r\n    require(uId > 0);\r\n    require(contributorList[uId].active);\r\n    return contributorList[uId].mainWallet;\r\n  }\r\n\r\n  /**\r\n   * @dev Check wallet exists by address\r\n   */\r\n  function checkWalletExists(address addr) public view returns(bool result) {\r\n    result = false;\r\n    if (contributorList[contributorIds[addr]].wallet.length > 0) {\r\n      result = inArray(contributorList[contributorIds[addr]].wallet, addr);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check userId is exists\r\n   */\r\n  function checkUserIdExists(uint uId) public onlyMultiOwnersType(8) view returns(bool) {\r\n    return contributorList[uId].active;\r\n  }\r\n\r\n  /**\r\n   * @dev Add payment by address\r\n   */\r\n  function addPayment(\r\n    address _addr,\r\n    string pType,\r\n    uint _value,\r\n    uint usdAmount,\r\n    uint currencyUSD,\r\n    uint tokenWithoutBonus,\r\n    uint tokenBonus,\r\n    uint bonusPercent,\r\n    uint payId\r\n  )\r\n  public\r\n  onlyMultiOwnersType(9)\r\n  returns(bool)\r\n  {\r\n    require(_value > 0);\r\n    require(usdAmount > 0);\r\n    require(tokenWithoutBonus > 0);\r\n    require(bytes(pType).length > 0);\r\n    assert((payId == 0 && stringsEqual(pType, \"ETH\")) || (payId > 0 && !payIds[payId]));\r\n\r\n    address addr = _addr;\r\n    uint uId = contributorIds[addr];\r\n\r\n    assert(addr != address(0));\r\n    assert(checkWalletExists(addr));\r\n    assert(uId > 0);\r\n    assert(contributorList[uId].active);\r\n    assert(!refundUserIds[uId]);\r\n    assert(!receivedCoin[uId]);\r\n\r\n    if (payId == 0) {\r\n      payId = genId(addr, _value, 0);\r\n    }\r\n\r\n    bytes32 _pType = stringToBytes32(pType);\r\n    PaymentData memory userPayment;\r\n    uint totalToken = tokenWithoutBonus.add(tokenBonus);\r\n\r\n    //userPayment.payId = payId;\r\n    userPayment.time = block.timestamp;\r\n    userPayment.pType = _pType;\r\n    userPayment.currencyUSD = currencyUSD;\r\n    userPayment.payValue = _value;\r\n    userPayment.totalToken = totalToken;\r\n    userPayment.tokenWithoutBonus = tokenWithoutBonus;\r\n    userPayment.tokenBonus = tokenBonus;\r\n    userPayment.bonusPercent = bonusPercent;\r\n    userPayment.usdAbsRaisedInCents = usdAmount;\r\n\r\n    if (!inArray(currencyTicker, _pType)) {\r\n      currencyTicker.push(_pType);\r\n    }\r\n    if (payId > 0) {\r\n      payIds[payId] = true;\r\n    }\r\n\r\n    contributorList[uId].usdAbsRaisedInCents += usdAmount;\r\n    contributorList[uId].totalToken += totalToken;\r\n    contributorList[uId].tokenWithoutBonus += tokenWithoutBonus;\r\n    contributorList[uId].tokenBonus += tokenBonus;\r\n\r\n    contributorList[uId].payInCurrency[_pType] += _value;\r\n    contributorList[uId].paymentInfo[payId] = userPayment;\r\n    contributorPayIds[uId].push(payId);\r\n\r\n    emit AddPayment(addr);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Add payment by uId\r\n   */\r\n  function addPayment(\r\n    uint uId,\r\n    string pType,\r\n    uint _value,\r\n    uint usdAmount,\r\n    uint currencyUSD,\r\n    uint tokenWithoutBonus,\r\n    uint tokenBonus,\r\n    uint bonusPercent,\r\n    uint payId\r\n  )\r\n  public\r\n  returns(bool)\r\n  {\r\n    require(contributorList[uId].active);\r\n    require(contributorList[uId].mainWallet != address(0));\r\n    return addPayment(contributorList[uId].mainWallet, pType, _value, usdAmount, currencyUSD, tokenWithoutBonus, tokenBonus, bonusPercent, payId);\r\n  }\r\n\r\n  /**\r\n   * @dev Edit user payment info\r\n   */\r\n  function editPaymentByUserId(\r\n    uint uId,\r\n    uint payId,\r\n    uint _payValue,\r\n    uint _usdAmount,\r\n    uint _currencyUSD,\r\n    uint _totalToken,\r\n    uint _tokenWithoutBonus,\r\n    uint _tokenBonus,\r\n    uint _bonusPercent\r\n  )\r\n  public\r\n  onlyMultiOwnersType(10)\r\n  returns(bool)\r\n  {\r\n    require(contributorList[uId].active);\r\n    require(inArray(contributorPayIds[uId], payId));\r\n    require(!refundPayIds[payId]);\r\n    require(!refundUserIds[uId]);\r\n    require(!receivedCoin[uId]);\r\n\r\n    PaymentData memory oldPayment = contributorList[uId].paymentInfo[payId];\r\n\r\n    contributorList[uId].usdAbsRaisedInCents -= oldPayment.usdAbsRaisedInCents;\r\n    contributorList[uId].totalToken -= oldPayment.totalToken;\r\n    contributorList[uId].tokenWithoutBonus -= oldPayment.tokenWithoutBonus;\r\n    contributorList[uId].tokenBonus -= oldPayment.tokenBonus;\r\n    contributorList[uId].payInCurrency[oldPayment.pType] -= oldPayment.payValue;\r\n\r\n    contributorList[uId].paymentInfo[payId] = PaymentData(\r\n      oldPayment.time,\r\n      oldPayment.pType,\r\n      _currencyUSD,\r\n      _payValue,\r\n      _totalToken,\r\n      _tokenWithoutBonus,\r\n      _tokenBonus,\r\n      _bonusPercent,\r\n      _usdAmount\r\n    );\r\n\r\n    contributorList[uId].usdAbsRaisedInCents += _usdAmount;\r\n    contributorList[uId].totalToken += _totalToken;\r\n    contributorList[uId].tokenWithoutBonus += _tokenWithoutBonus;\r\n    contributorList[uId].tokenBonus += _tokenBonus;\r\n    contributorList[uId].payInCurrency[oldPayment.pType] += _payValue;\r\n\r\n    emit EditUserPayments(contributorList[uId].mainWallet, payId);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Refund user payment\r\n   */\r\n  function refundPaymentByUserId(uint uId, uint payId) public onlyMultiOwnersType(20) returns(bool) {\r\n    require(contributorList[uId].active);\r\n    require(inArray(contributorPayIds[uId], payId));\r\n    require(!refundPayIds[payId]);\r\n    require(!refundUserIds[uId]);\r\n    require(!receivedCoin[uId]);\r\n\r\n    PaymentData memory oldPayment = contributorList[uId].paymentInfo[payId];\r\n\r\n    assert(oldPayment.pType != stringToBytes32(\"ETH\"));\r\n\r\n    contributorList[uId].usdAbsRaisedInCents -= oldPayment.usdAbsRaisedInCents;\r\n    contributorList[uId].totalToken -= oldPayment.totalToken;\r\n    contributorList[uId].tokenWithoutBonus -= oldPayment.tokenWithoutBonus;\r\n    contributorList[uId].tokenBonus -= oldPayment.tokenBonus;\r\n    contributorList[uId].payInCurrency[oldPayment.pType] -= oldPayment.payValue;\r\n\r\n    refundPayIds[payId] = true;\r\n\r\n    emit RefundPayment(contributorList[uId].mainWallet, payId);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Reutrns user payment info by uId and paymentId\r\n   */\r\n  function getUserPaymentById(uint _uId, uint _payId) public onlyMultiOwnersType(11) view returns(\r\n    uint time,\r\n    bytes32 pType,\r\n    uint currencyUSD,\r\n    uint bonusPercent,\r\n    uint payValue,\r\n    uint totalToken,\r\n    uint tokenBonus,\r\n    uint tokenWithoutBonus,\r\n    uint usdAbsRaisedInCents,\r\n    bool refund\r\n  )\r\n  {\r\n    uint uId = _uId;\r\n    uint payId = _payId;\r\n    require(contributorList[uId].active);\r\n    require(inArray(contributorPayIds[uId], payId));\r\n\r\n    PaymentData memory payment = contributorList[uId].paymentInfo[payId];\r\n\r\n    return (\r\n      payment.time,\r\n      payment.pType,\r\n      payment.currencyUSD,\r\n      payment.bonusPercent,\r\n      payment.payValue,\r\n      payment.totalToken,\r\n      payment.tokenBonus,\r\n      payment.tokenWithoutBonus,\r\n      payment.usdAbsRaisedInCents,\r\n      refundPayIds[payId] ? true : false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Reutrns user payment info by address and payment id\r\n   */\r\n  function getUserPayment(address addr, uint _payId) public view returns(\r\n    uint time,\r\n    string pType,\r\n    uint currencyUSD,\r\n    uint bonusPercent,\r\n    uint payValue,\r\n    uint totalToken,\r\n    uint tokenBonus,\r\n    uint tokenWithoutBonus,\r\n    uint usdAbsRaisedInCents,\r\n    bool refund\r\n  )\r\n  {\r\n    address _addr = addr;\r\n    require(contributorList[contributorIds[_addr]].active);\r\n    require(inArray(contributorPayIds[contributorIds[_addr]], _payId));\r\n\r\n    uint payId = _payId;\r\n\r\n    PaymentData memory payment = contributorList[contributorIds[_addr]].paymentInfo[payId];\r\n\r\n    return (\r\n      payment.time,\r\n      bytes32ToString(payment.pType),\r\n      payment.currencyUSD,\r\n      payment.bonusPercent,\r\n      payment.payValue,\r\n      payment.totalToken,\r\n      payment.tokenBonus,\r\n      payment.tokenWithoutBonus,\r\n      payment.usdAbsRaisedInCents,\r\n      refundPayIds[payId] ? true : false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns payment in ETH from address\r\n   */\r\n  function getEthPaymentContributor(address addr) public view returns(uint) {\r\n    return contributorList[contributorIds[addr]].payInCurrency[stringToBytes32(\"ETH\")];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns SHPC from address\r\n   */\r\n  function getTotalCoin(address addr) public view returns(uint) {\r\n    return contributorList[contributorIds[addr]].totalToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Check user get pre sale bonus by address\r\n   */\r\n  function checkPreSaleReceivedBonus(address addr) public view returns(bool) {\r\n    return receivedPreSaleBonus[contributorIds[addr]] > 0 ? true : false;\r\n  }\r\n\r\n  /**\r\n   * @dev Check payment refund by payment id\r\n   */\r\n  function checkPaymentRefund(uint payId) public view returns(bool) {\r\n    return refundPayIds[payId];\r\n  }\r\n\r\n  /**\r\n   * @dev Check user refund by address\r\n   */\r\n  function checkRefund(address addr) public view returns(bool) {\r\n    return refundUserIds[contributorIds[addr]];\r\n  }\r\n\r\n  /**\r\n   * @dev Set start number generate payment id when user pay in eth\r\n   */\r\n  function setStartGenId(uint startId) public onlyMultiOwnersType(14) {\r\n    require(startId > 0);\r\n    startGenId = startId;\r\n  }\r\n\r\n  /**\r\n   * @dev Set contributer got SHPC\r\n   */\r\n  function setReceivedCoin(uint uId) public onlyMultiOwnersType(15) returns(bool) {\r\n    require(contributorList[uId].active);\r\n    require(!refundUserIds[uId]);\r\n    require(!receivedCoin[uId]);\r\n    receivedCoin[uId] = true;\r\n    emit ReceivedCoin(contributorList[uId].mainWallet);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Set contributer got refund ETH\r\n   */\r\n  function setRefund(uint uId) public onlyMultiOwnersType(16) returns(bool) {\r\n    require(contributorList[uId].active);\r\n    require(!refundUserIds[uId]);\r\n    require(!receivedCoin[uId]);\r\n    refundUserIds[uId] = true;\r\n    emit Refund(contributorList[uId].mainWallet);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Check contributor got SHPC\r\n   */\r\n  function checkReceivedCoins(address addr) public view returns(bool) {\r\n    return receivedCoin[contributorIds[addr]];\r\n  }\r\n\r\n  /**\r\n   * @dev Check contributor got ETH\r\n   */\r\n  function checkReceivedEth(address addr) public view returns(bool) {\r\n    return refundUserIds[contributorIds[addr]];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns all contributor currency amount in json\r\n   */\r\n  function getContributorPayInCurrency(uint uId) private view returns(string) {\r\n    require(uId > 0);\r\n    require(contributorList[uId].active);\r\n    string memory payInCurrency = \"{\";\r\n    for (uint i = 0; i < currencyTicker.length; i++) {\r\n      payInCurrency = strConcat(payInCurrency, strConcat(\"\\\"\", bytes32ToString(currencyTicker[i]), \"\\\":\\\"\"), uint2str(contributorList[uId].payInCurrency[currencyTicker[i]]), (i+1 < currencyTicker.length) ? \"\\\",\" : \"\\\"}\");\r\n    }\r\n    return payInCurrency;\r\n  }\r\n\r\n  /**\r\n   * @dev Check receives presale bonud by uId\r\n   */\r\n  function checkPreSaleReceivedBonus(uint uId) private view returns(bool) {\r\n    return receivedPreSaleBonus[uId] > 0 ? true : false;\r\n  }\r\n\r\n  /**\r\n   * @dev Check refund by uId\r\n   */\r\n  function checkRefund(uint uId) private view returns(bool) {\r\n    return refundUserIds[uId];\r\n  }\r\n\r\n  /**\r\n   * @dev  Check received SHPC by uI\r\n   */\r\n  function checkReceivedCoins(uint id) private view returns(bool) {\r\n    return receivedCoin[id];\r\n  }\r\n\r\n  /**\r\n   * @dev Check received eth by uId\r\n   */\r\n  function checkReceivedEth(uint id) private view returns(bool) {\r\n    return refundUserIds[id];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns new uniq payment id\r\n   */\r\n  function genId(address addr, uint ammount, uint rand) private view returns(uint) {\r\n    uint id = startGenId + uint8(keccak256(abi.encodePacked(addr, blockhash(block.number), ammount, rand))) + contributorPayIds[contributorIds[addr]].length;\r\n    if (!payIds[id]) {\r\n      return id;\r\n    } else {\r\n      return genId(addr, ammount, id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns payment in ETH from uid\r\n   */\r\n  function getEthPaymentContributor(uint uId) private view returns(uint) {\r\n    return contributorList[uId].payInCurrency[stringToBytes32(\"ETH\")];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns adittional info by contributor address\r\n   */\r\n  function getInfoAdditionl(address addr) private view returns(uint, bool, bool) {\r\n    return(receivedPreSaleBonus[contributorIds[addr]], receivedCoin[contributorIds[addr]], refundUserIds[contributorIds[addr]]);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns payments info by userId in json\r\n   */\r\n  function getArrayjsonPaymentInfo(uint uId) private view returns (string) {\r\n    string memory _array = \"{\";\r\n    for (uint i = 0; i < contributorPayIds[uId].length; i++) {\r\n      _array = strConcat(_array, getJsonPaymentInfo(contributorList[uId].paymentInfo[contributorPayIds[uId][i]], contributorPayIds[uId][i]), (i+1 == contributorPayIds[uId].length) ? \"}\" : \",\");\r\n    }\r\n    return _array;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns payment info by payment data in json\r\n   */\r\n  function getJsonPaymentInfo(PaymentData memory _obj, uint payId) private view returns (string) {\r\n    return strConcat(\r\n      strConcat(\"\\\"\", uint2str(payId), \"\\\":{\", strConcat(\"\\\"\", \"time\", \"\\\":\"), uint2str(_obj.time)),\r\n      strConcat(\",\\\"pType\\\":\\\"\", bytes32ToString(_obj.pType), \"\\\",\\\"currencyUSD\\\":\", uint2str(_obj.currencyUSD), \",\\\"payValue\\\":\\\"\"),\r\n      strConcat(uint2str(_obj.payValue), \"\\\",\\\"totalToken\\\":\\\"\", uint2str(_obj.totalToken), \"\\\",\\\"tokenWithoutBonus\\\":\\\"\", uint2str(_obj.tokenWithoutBonus)),\r\n      strConcat(\"\\\",\\\"tokenBonus\\\":\\\"\", uint2str(_obj.tokenBonus), \"\\\",\\\"bonusPercent\\\":\", uint2str(_obj.bonusPercent)),\r\n      strConcat(\",\\\"usdAbsRaisedInCents\\\":\\\"\", uint2str(_obj.usdAbsRaisedInCents), \"\\\",\\\"refund\\\":\\\"\", (refundPayIds[payId] ? \"1\" : \"0\"), \"\\\"}\")\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Check if value contains array\r\n   */\r\n  function inArray(address[] _array, address _value) private pure returns(bool result) {\r\n    if (_array.length == 0 || _value == address(0)) {\r\n      return false;\r\n    }\r\n    result = false;\r\n    for (uint i = 0; i < _array.length; i++) {\r\n      if (_array[i] == _value) {\r\n        result = true;\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check if value contains array\r\n   */\r\n  function inArray(uint[] _array, uint _value) private pure returns(bool result) {\r\n    if (_array.length == 0 || _value == 0) {\r\n      return false;\r\n    }\r\n    result = false;\r\n    for (uint i = 0; i < _array.length; i++) {\r\n      if (_array[i] == _value) {\r\n        result = true;\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check if value contains array\r\n   */\r\n  function inArray(bytes32[] _array, bytes32 _value) private pure returns(bool result) {\r\n    if (_array.length == 0 || _value.length == 0) {\r\n      return false;\r\n    }\r\n    result = false;\r\n    for (uint i = 0; i < _array.length; i++) {\r\n      if (_array[i] == _value) {\r\n        result = true;\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove value from arary\r\n   */\r\n  function removeValueFromArray(address[] _array, address _value) private pure returns(address[]) {\r\n    address[] memory arrayNew = new address[](_array.length-1);\r\n    if (arrayNew.length == 0) {\r\n      return arrayNew;\r\n    }\r\n    uint i1 = 0;\r\n    for (uint i = 0; i < _array.length; i++) {\r\n      if (_array[i] != _value) {\r\n        arrayNew[i1++] = _array[i];\r\n      }\r\n    }\r\n    return arrayNew;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getContributorId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"}],\"name\":\"setRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addMultiOwnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getTotalCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minTotalUsdAmountInCents\",\"type\":\"uint256\"}],\"name\":\"checkNeedProcessPreSaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"pType\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"name\":\"currencyUSD\",\"type\":\"uint256\"},{\"name\":\"tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint256\"},{\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"addPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkReceivedEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getCountNeedSendSHPC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkPreSaleReceivedBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proc\",\"type\":\"bool\"}],\"name\":\"checkNeedSendSHPC\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"payId\",\"type\":\"uint256\"},{\"name\":\"_payValue\",\"type\":\"uint256\"},{\"name\":\"_usdAmount\",\"type\":\"uint256\"},{\"name\":\"_currencyUSD\",\"type\":\"uint256\"},{\"name\":\"_totalToken\",\"type\":\"uint256\"},{\"name\":\"_tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"_tokenBonus\",\"type\":\"uint256\"},{\"name\":\"_bonusPercent\",\"type\":\"uint256\"}],\"name\":\"editPaymentByUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"checkPaymentRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proc\",\"type\":\"bool\"}],\"name\":\"checkETHRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkReceivedCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"}],\"name\":\"setReceivedCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"onlyMultiOwnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getEthPaymentContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minTotalUsdAmountInCents\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"processPreSaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startId\",\"type\":\"uint256\"}],\"name\":\"setStartGenId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minTotalUsdAmountInCents\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getCountNeedProcessPreSaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContributorIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"changeSupportChangeMainWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"}],\"name\":\"getContributorAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getCountETHRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportChangeMainWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"pType\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"name\":\"currencyUSD\",\"type\":\"uint256\"},{\"name\":\"tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint256\"},{\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"addPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getContributorIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_payId\",\"type\":\"uint256\"}],\"name\":\"getUserPayment\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"pType\",\"type\":\"string\"},{\"name\":\"currencyUSD\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint256\"},{\"name\":\"payValue\",\"type\":\"uint256\"},{\"name\":\"totalToken\",\"type\":\"uint256\"},{\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"name\":\"tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"usdAbsRaisedInCents\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"refundPaymentByUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"types\",\"type\":\"uint256[]\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addMultiOwnerTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"}],\"name\":\"checkUserIdExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkWalletExists\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getContributionInfo\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"payInCurrency\",\"type\":\"string\"},{\"name\":\"totalToken\",\"type\":\"uint256\"},{\"name\":\"tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"name\":\"usdAbsRaisedInCents\",\"type\":\"uint256\"},{\"name\":\"paymentInfoIds\",\"type\":\"uint256[]\"},{\"name\":\"mainWallet\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address[]\"},{\"name\":\"preSaleReceivedBonus\",\"type\":\"uint256\"},{\"name\":\"receivedCoins\",\"type\":\"bool\"},{\"name\":\"refund\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uId\",\"type\":\"uint256\"},{\"name\":\"_payId\",\"type\":\"uint256\"}],\"name\":\"getUserPaymentById\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"pType\",\"type\":\"bytes32\"},{\"name\":\"currencyUSD\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint256\"},{\"name\":\"payValue\",\"type\":\"uint256\"},{\"name\":\"totalToken\",\"type\":\"uint256\"},{\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"name\":\"tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"usdAbsRaisedInCents\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uId\",\"type\":\"uint256\"},{\"name\":\"minTotalUsdAmountInCents\",\"type\":\"uint256\"},{\"name\":\"bonusPercent\",\"type\":\"uint256\"},{\"name\":\"maxPayTime\",\"type\":\"uint256\"}],\"name\":\"reCountUserPreSaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"types\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeMultiOwnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeMainWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uId\",\"type\":\"uint256\"}],\"name\":\"getContributionInfoById\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"payInCurrency\",\"type\":\"string\"},{\"name\":\"totalToken\",\"type\":\"uint256\"},{\"name\":\"tokenWithoutBonus\",\"type\":\"uint256\"},{\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"name\":\"usdAbsRaisedInCents\",\"type\":\"uint256\"},{\"name\":\"paymentInfoIds\",\"type\":\"uint256[]\"},{\"name\":\"mainWallet\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address[]\"},{\"name\":\"preSaleReceivedBonus\",\"type\":\"uint256\"},{\"name\":\"receivedCoins\",\"type\":\"bool\"},{\"name\":\"refund\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GotPreSaleBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"EditUserPayments\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"RefundPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ReceivedCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ChangeMainWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"types\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"RemoveOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ShipCoinStorage","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://92896d1ac9935fe7cbfd28405544efbb6be07ce99291eaf24603ce3ee039097c"}]}