{"status":"1","message":"OK","result":[{"SourceCode":"//////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol 2018-04-24 add\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Base {\r\n    using SafeMath for uint256;\r\n    uint public createTime = now;\r\n    address public owner;   \r\n    uint public currentEventId = 1;\r\n    uint256 public ownerDividend = 0 ;\r\n    uint256 public thisEther = 0 ;\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner)  public  onlyOwner {\r\n        require(msg.sender == tx.origin);\r\n        userRefund();\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function getEventId() internal returns(uint _result) {  \r\n        _result = currentEventId;\r\n        currentEventId ++;\r\n    }\r\n\r\n    function userRefund() public onlyOwner returns(bool _result) {\r\n        require(msg.sender == tx.origin);\r\n        if(ownerDividend > 0 ){\r\n            msg.sender.transfer(ownerDividend);\r\n            ownerDividend = 0 ;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n    \r\ncontract FreeCell is Base{\r\n\r\n    string constant public name = \"FreeCell\";\r\n    uint256 public curPosition = 0;\r\n    uint public lastPlayTime = 0;\r\n    uint public expirationTime = 24 hours;\r\n\r\n    uint256 public BASE_BET_ETHER = 0.01 ether;\r\n    uint public REWARD_WIN_MULTIPLE_PER = 60;\r\n    uint public PRE_WIN_MULTIPLE_PER = 30;\r\n    uint public KING_WIN_MULTIPLE_PER = REWARD_WIN_MULTIPLE_PER + PRE_WIN_MULTIPLE_PER;\r\n    uint public REWARD_NUM = 200;\r\n    uint public REWARD_FORWARD_POSITION = REWARD_NUM - 1 ;\r\n    uint public CELL_ADD_SPACE = 0.0005 ether ; \r\n    uint public STEP_SIZE = 50 ;\r\n    uint public MAX_LENGTH = 1000000 ; \r\n\r\n    function FreeCell() public {\r\n        require(REWARD_WIN_MULTIPLE_PER.add(PRE_WIN_MULTIPLE_PER) < 100) ;\r\n        require(curPosition == 0);\r\n        owner = msg.sender;\r\n        lastPlayTime = now;\r\n    }\r\n\r\n    struct betInfo {\r\n        address addr;\r\n        uint256 card;\r\n    }\r\n\r\n    mapping (uint256 => betInfo) public playerBetInfoOf;\r\n    mapping (uint256 => uint256) public resultOf;\r\n\r\n    event OnGetAward(uint256 indexed _position,  address indexed _player, uint256 indexed _card, uint256  _prePosition, uint256 _rewardMoney, uint8 _type, uint256 _eventId, uint256 _eventTime);\r\n    event OnPlay(uint256 indexed _position,  address indexed _player, uint256 indexed _card, uint256 _eventId, uint256 _eventTime);\r\n\r\n    function playBatch(uint256 num) public payable returns(bool _result){\r\n        require(msg.sender == tx.origin);\r\n        uint256 userMoney = msg.value;\r\n\r\n        if(now.sub(lastPlayTime) > expirationTime){\r\n            getEventId();\r\n            address _lastPalayUser = playerBetInfoOf[curPosition].addr ;\r\n            uint256 _toLastPlayer = _rewardKing(1, MAX_LENGTH,_lastPalayUser,uint8(4));  \r\n            if(userMoney > 0){\r\n                msg.sender.transfer(userMoney);\r\n            }\r\n            if(_toLastPlayer > 0 ){\r\n                _lastPalayUser.transfer(_toLastPlayer);\r\n            }\r\n            lastPlayTime = now ;\r\n            _result = true;\r\n            return ;\r\n        }else{\r\n            lastPlayTime = now ;\r\n        }\r\n\r\n        for(uint256 i = 0;i < num; i++){\r\n            (_result,userMoney) = _play(userMoney);\r\n            if(!_result){\r\n                break ; \r\n            }\r\n        }\r\n        if(userMoney > 0){\r\n            msg.sender.transfer(userMoney);\r\n        }\r\n    }\r\n\r\n    function play() public payable returns(bool _result){\r\n        require(msg.sender == tx.origin);\r\n        uint256 userMoney = msg.value;\r\n\r\n        if(now.sub(lastPlayTime) > expirationTime){\r\n            getEventId();\r\n            address _lastPalayUser = playerBetInfoOf[curPosition].addr ;\r\n            uint256 _toLastPlayer = _rewardKing(1, MAX_LENGTH,_lastPalayUser,uint8(4));  \r\n            if(userMoney > 0){\r\n                msg.sender.transfer(userMoney);\r\n            }\r\n            if(_toLastPlayer > 0 ){\r\n                _lastPalayUser.transfer(_toLastPlayer);\r\n            }\r\n            lastPlayTime = now ;\r\n            _result = true;\r\n            return ;\r\n        }else{\r\n            lastPlayTime = now ;\r\n        }\r\n\r\n        (_result,userMoney) = _play(userMoney);\r\n        require(_result);\r\n        if(userMoney > 0){\r\n            msg.sender.transfer(userMoney);\r\n        }\r\n    }\r\n\r\n    function _isKingKong(uint256 _card) private pure returns(bool _result){\r\n        _result = false;\r\n        if(_card % 111111 == 0){\r\n           _result = true ;\r\n        }\r\n    }\r\n\r\n    function _isStraight(uint256 _card) private pure returns(bool _result){\r\n        _result = false;\r\n        if(_card >= 543210){\r\n            if(_isKingKong(_card.sub(12345)) || _isKingKong(_card.sub(543210))){\r\n                _result = true ;\r\n            }\r\n        }else if(_card > 123455){\r\n            if(_isKingKong(_card.sub(12345))){\r\n                _result = true ;\r\n            }\r\n        }else{\r\n            _result = false;\r\n        }\r\n    }\r\n\r\n    function viewPosition(uint256 _card) public view returns(uint256 _position) {\r\n        _position = resultOf[_card];\r\n        if(_position > curPosition || playerBetInfoOf[_position].card != _card){\r\n            _position = 0 ;\r\n        }\r\n    }\r\n\r\n    function viewBetEther(uint256 _position) public view returns(uint256 _betEther) {\r\n        _betEther = _position.sub(1).div(STEP_SIZE).mul(CELL_ADD_SPACE).add(BASE_BET_ETHER);\r\n        return _betEther;\r\n    }\r\n\r\n    function viewNeedBetEther(uint256 num) public view returns(uint256 _betEther) {\r\n        require(num <= 20) ;\r\n        return  viewSumEther(curPosition.add(1),curPosition.add(num));\r\n    }\r\n\r\n    function _sumEther(uint256 _position) private view returns(uint256 _totalEther){\r\n        if(_position < STEP_SIZE){\r\n            return _position.mul(BASE_BET_ETHER);     \r\n        }else if(_position % STEP_SIZE == 0){\r\n            return viewBetEther(_position).add(BASE_BET_ETHER).mul(_position).div(2);       \r\n        }else{\r\n            uint256 _remainder = _position % STEP_SIZE;\r\n            uint256 _bak = _position.sub(_remainder);\r\n            return viewBetEther(_bak).add(BASE_BET_ETHER).mul(_bak).div(2).add(viewBetEther(_position).mul(_remainder));          \r\n        }\r\n    }\r\n    \r\n    function viewSumEther(uint256 _prePosition,uint256 _curPosition) public view returns(uint256 _betEther) {\r\n        if(_prePosition <= 1){\r\n            return _sumEther(_curPosition);\r\n        }\r\n        return _sumEther(_curPosition).sub(_sumEther(_prePosition.sub(1)));\r\n    }\r\n\r\n    function _play(uint256 _userMoney) private returns(bool _result,uint256 _toUserMoney){\r\n        _result = false;\r\n        _toUserMoney = _userMoney;\r\n        \r\n        uint256 _betEther = viewBetEther(curPosition.add(1));\r\n        if(_toUserMoney < _betEther){\r\n            return (_result,_toUserMoney);\r\n        }\r\n\r\n        curPosition++;\r\n        _toUserMoney= _toUserMoney.sub(_betEther);                   \r\n        thisEther = thisEther.add(_betEther);\r\n        \r\n        uint256 seed = uint256(\r\n            keccak256(\r\n                block.timestamp,\r\n                block.difficulty,\r\n                uint256(keccak256(block.coinbase))/(now),\r\n                block.gaslimit,\r\n                uint256(keccak256(msg.sender))/ (now),\r\n                block.number,\r\n                _betEther,\r\n                getEventId(),\r\n                gasleft()\r\n            )\r\n        );\r\n\r\n        uint256 _card =  seed % MAX_LENGTH; \r\n\r\n        emit OnPlay(curPosition, msg.sender, _card, currentEventId, now);\r\n\r\n        uint256 _toRewardPlayer = 0;\r\n        if(_isKingKong(_card) || _isStraight(_card)){\r\n            if(curPosition > REWARD_FORWARD_POSITION){\r\n               uint256 _prePosition = curPosition.sub(REWARD_FORWARD_POSITION);\r\n            }else{\r\n                _prePosition = 1;\r\n            }            \r\n            _toRewardPlayer = _rewardKing(_prePosition, _card,msg.sender,uint8(3));\r\n            _toUserMoney= _toUserMoney.add(_toRewardPlayer);  \r\n            _result = true;\r\n            return (_result,_toUserMoney);\r\n       }\r\n\r\n       _prePosition = resultOf[_card];\r\n       if(_prePosition != 0 && _prePosition < curPosition && playerBetInfoOf[_prePosition].card == _card ){\r\n            _toRewardPlayer = _reward(_prePosition, _card);\r\n            _toUserMoney= _toUserMoney.add(_toRewardPlayer); \r\n            _result = true;\r\n            return (_result,_toUserMoney);\r\n       }else{\r\n            betInfo memory bi = betInfo({\r\n                addr :  msg.sender,\r\n                card : _card\r\n            });\r\n            playerBetInfoOf[curPosition] = bi;\r\n            resultOf[_card]=curPosition;\r\n            _result = true;\r\n            return (_result,_toUserMoney);\r\n       }\r\n    }\r\n\r\n    function _reward(uint256 _prePosition,uint256 _card) private returns(uint256 _toRewardPlayer){\r\n        _toRewardPlayer = 0;\r\n        require(_prePosition >= 1);\r\n\r\n        betInfo memory bi = playerBetInfoOf[_prePosition];\r\n        require(bi.addr != 0x0);\r\n\r\n        uint256 _sumRewardMoney = viewSumEther(_prePosition, curPosition);\r\n \r\n        _toRewardPlayer = _sumRewardMoney.mul(REWARD_WIN_MULTIPLE_PER).div(100) ;\r\n        uint256 _toPrePlayer = _sumRewardMoney.mul(PRE_WIN_MULTIPLE_PER).div(100) ;\r\n        uint256 _toOwner = _sumRewardMoney.sub(_toRewardPlayer).sub(_toPrePlayer);\r\n\r\n        emit OnGetAward(curPosition,msg.sender,_card,_prePosition,_toRewardPlayer,uint8(1),currentEventId,now);\r\n        emit OnGetAward(_prePosition,bi.addr,_card,curPosition,_toPrePlayer,uint8(2),currentEventId,now);\r\n\r\n        curPosition = _prePosition.sub(1);\r\n        thisEther = thisEther.sub(_sumRewardMoney);\r\n        ownerDividend = ownerDividend.add(_toOwner);\r\n        if(msg.sender != bi.addr){\r\n            bi.addr.transfer(_toPrePlayer);\r\n        }else{\r\n           _toRewardPlayer = _toRewardPlayer.add(_toPrePlayer);\r\n        }\r\n    }\r\n        \r\n    function _rewardKing(uint256 _prePosition,uint256 _card, address _user,uint8 _type) private returns(uint256 _toRewardPlayer){\r\n        _toRewardPlayer = 0;\r\n        require(_prePosition >= 1);\r\n   \r\n        uint256 _sumRewardMoney = viewSumEther(_prePosition, curPosition);\r\n        _toRewardPlayer = _sumRewardMoney.mul(KING_WIN_MULTIPLE_PER).div(100) ; \r\n        uint256 _toOwner = _sumRewardMoney.sub(_toRewardPlayer);\r\n\r\n        emit OnGetAward(curPosition,_user,_card,_prePosition,_toRewardPlayer,_type,currentEventId,now);\r\n        \r\n        curPosition = _prePosition.sub(1);\r\n        thisEther = thisEther.sub(_sumRewardMoney);\r\n        ownerDividend = ownerDividend.add(_toOwner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRE_WIN_MULTIPLE_PER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEventId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CELL_ADD_SPACE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_NUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetInfoOf\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"card\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_BET_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"playBatch\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_FORWARD_POSITION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STEP_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"viewBetEther\",\"outputs\":[{\"name\":\"_betEther\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userRefund\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"createTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KING_WIN_MULTIPLE_PER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resultOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"play\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"viewNeedBetEther\",\"outputs\":[{\"name\":\"_betEther\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPlayTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_WIN_MULTIPLE_PER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_card\",\"type\":\"uint256\"}],\"name\":\"viewPosition\",\"outputs\":[{\"name\":\"_position\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expirationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thisEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prePosition\",\"type\":\"uint256\"},{\"name\":\"_curPosition\",\"type\":\"uint256\"}],\"name\":\"viewSumEther\",\"outputs\":[{\"name\":\"_betEther\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_position\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_card\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_prePosition\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rewardMoney\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_eventTime\",\"type\":\"uint256\"}],\"name\":\"OnGetAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_position\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_card\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_eventTime\",\"type\":\"uint256\"}],\"name\":\"OnPlay\",\"type\":\"event\"}]","ContractName":"FreeCell","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2d13af736c78ccf1fbc505059cc803d54ebe4eae4c5c64c0bd7397381e641331"}]}