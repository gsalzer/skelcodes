{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Richer3D {\r\n    using SafeMath for *;\r\n    \r\n    //************\r\n    //Game Setting\r\n    //************\r\n    string constant public name = \"Richer3D\";\r\n    string constant public symbol = \"R3D\";\r\n    address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd;\r\n    address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61;\r\n    address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A;\r\n    address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d;\r\n    uint256 constant cycleTime = 24 hours;\r\n    bool calculating_target = false;\r\n    //************\r\n    //Game Data\r\n    //************\r\n    uint256 private roundNumber;\r\n    uint256 private dayNumber;\r\n    uint256 private totalPlayerNumber;\r\n    uint256 private platformBalance;\r\n    //*************\r\n    //Game DataBase\r\n    //*************\r\n    mapping(uint256=>DataModal.RoundInfo) private rInfoXrID;\r\n    mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd;\r\n    mapping(address=>uint256) private pIDXpAdd;\r\n    mapping(uint256=>address) private pAddXpID;\r\n    \r\n    //*************\r\n    // P3D Data\r\n    //*************\r\n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n \r\n    mapping(uint256=>uint256) private p3dDividesXroundID;\r\n\r\n    //*************\r\n    //Game Events\r\n    //*************\r\n    event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp);\r\n    event calculateTargetEvent(uint256 indexed _roundID);\r\n    \r\n    constructor() public {\r\n        dayNumber = 1;\r\n    }\r\n    \r\n    function() external payable {\r\n\r\n    }\r\n    \r\n    //************\r\n    //Game payable\r\n    //************\r\n    function joinGameWithInviterID(uint256 _inviterID) public payable {\r\n        uint256 _timestamp = now;\r\n        address _senderAddress = msg.sender;\r\n        uint256 _eth = msg.value;\r\n        require(_timestamp.sub(rInfoXrID[roundNumber].lastCalculateTime) < cycleTime,\"Waiting for settlement\");\r\n        if(pIDXpAdd[_senderAddress] < 1) {\r\n            registerWithInviterID(_senderAddress,_inviterID);\r\n        }\r\n        buyCore(_senderAddress,pInfoXpAdd[_senderAddress].inviterAddress,_eth);\r\n        emit newPlayerJoinGameEvent(msg.sender,msg.value,true,_timestamp);\r\n    }\r\n    \r\n    function joinGameWithInviterIDForAddress(uint256 _inviterID,address _address) public payable {\r\n        uint256 _timestamp = now;\r\n        address _senderAddress = _address;\r\n        uint256 _eth = msg.value;\r\n        require(_timestamp.sub(rInfoXrID[roundNumber].lastCalculateTime) < cycleTime,\"Waiting for settlement\");\r\n        if(pIDXpAdd[_senderAddress] < 1) {\r\n            registerWithInviterID(_senderAddress,_inviterID);\r\n        }\r\n        buyCore(_senderAddress,pInfoXpAdd[_senderAddress].inviterAddress,_eth);\r\n        emit newPlayerJoinGameEvent(msg.sender,msg.value,true,_timestamp);\r\n    }\r\n    \r\n    //********************\r\n    // Method need Gas\r\n    //********************\r\n    function joinGameWithBalance(uint256 _amount) public {\r\n        uint256 _timestamp = now;\r\n        address _senderAddress = msg.sender;\r\n        require(_timestamp.sub(rInfoXrID[roundNumber].lastCalculateTime) < cycleTime,\"Waiting for settlement\");\r\n        uint256 balance = getUserBalance(_senderAddress);\r\n        require(balance >= _amount,\"balance is not enough\");\r\n        buyCore(_senderAddress,pInfoXpAdd[_senderAddress].inviterAddress,_amount);\r\n        pInfoXpAdd[_senderAddress].withDrawNumber = pInfoXpAdd[_senderAddress].withDrawNumber.sub(_amount);\r\n        emit newPlayerJoinGameEvent(_senderAddress,_amount,false,_timestamp);\r\n    }\r\n    \r\n    function calculateTarget() public {\r\n        require(calculating_target == false,\"Waiting....\");\r\n        calculating_target = true;\r\n        uint256 _timestamp = now;\r\n        require(_timestamp.sub(rInfoXrID[roundNumber].lastCalculateTime) >= cycleTime,\"Less than cycle Time from last operation\");\r\n        //allocate p3d dividends to contract \r\n        uint256 dividends = p3dContract.myDividends(true);\r\n        if(dividends > 0) {\r\n            if(rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber > 0) {\r\n                p3dDividesXroundID[roundNumber] = p3dDividesXroundID[roundNumber].add(dividends);\r\n                p3dContract.withdraw();    \r\n            } else {\r\n                platformBalance = platformBalance.add(dividends).add(p3dDividesXroundID[roundNumber]);\r\n                p3dContract.withdraw();    \r\n            }\r\n        }\r\n        uint256 increaseBalance = getIncreaseBalance(dayNumber,roundNumber);\r\n        uint256 targetBalance = getDailyTarget(roundNumber,dayNumber);\r\n        uint256 ethForP3D = increaseBalance.div(100);\r\n        if(increaseBalance >= targetBalance) {\r\n            //buy p3d\r\n            if(increaseBalance > 0) {\r\n                p3dContract.buy.value(ethForP3D)(p3dInviterAddress);\r\n            }\r\n            //continue\r\n            dayNumber++;\r\n            rInfoXrID[roundNumber].totalDay = dayNumber;\r\n            if(rInfoXrID[roundNumber].startTime == 0) {\r\n                rInfoXrID[roundNumber].startTime = _timestamp;\r\n                rInfoXrID[roundNumber].lastCalculateTime = _timestamp;\r\n            } else {\r\n                rInfoXrID[roundNumber].lastCalculateTime = _timestamp;   \r\n            }\r\n             //dividends for mine holder\r\n            rInfoXrID[roundNumber].increaseETH = rInfoXrID[roundNumber].increaseETH.sub(getETHNeedPay(roundNumber,dayNumber.sub(1))).sub(ethForP3D);\r\n            emit calculateTargetEvent(0);\r\n        } else {\r\n            //Game over, start new round\r\n            bool haveWinner = false;\r\n            if(dayNumber > 1) {\r\n                sendBalanceForDevelop(roundNumber);\r\n                if(platformBalance > 0) {\r\n                    uint256 platformBalanceAmount = platformBalance;\r\n                    platformBalance = 0;\r\n                    sysAdminAddress.transfer(platformBalanceAmount);\r\n                } \r\n                haveWinner = true;\r\n            }\r\n            rInfoXrID[roundNumber].winnerDay = dayNumber.sub(1);\r\n            roundNumber++;\r\n            dayNumber = 1;\r\n            if(haveWinner) {\r\n                rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1)).div(10);\r\n            } else {\r\n                rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1));\r\n            }\r\n            rInfoXrID[roundNumber].totalDay = 1;\r\n            rInfoXrID[roundNumber].startTime = _timestamp;\r\n            rInfoXrID[roundNumber].lastCalculateTime = _timestamp;\r\n            emit calculateTargetEvent(roundNumber);\r\n        }\r\n        calculating_target = false;\r\n    }\r\n\r\n    function registerWithInviterID(address _senderAddress, uint256 _inviterID) private {\r\n        totalPlayerNumber++;\r\n        pIDXpAdd[_senderAddress] = totalPlayerNumber;\r\n        pAddXpID[totalPlayerNumber] = _senderAddress;\r\n        pInfoXpAdd[_senderAddress].inviterAddress = pAddXpID[_inviterID];\r\n    }\r\n    \r\n    function buyCore(address _playerAddress,address _inviterAddress,uint256 _amount) private {\r\n        require(_amount >= 0.01 ether,\"You need to pay 0.01 ether at lesat\");\r\n        //10 percent of the investment amount belongs to the inviter\r\n        address _senderAddress = _playerAddress;\r\n        if(_inviterAddress == address(0) || _inviterAddress == _senderAddress) {\r\n            platformBalance = platformBalance.add(_amount/10);\r\n        } else {\r\n            pInfoXpAdd[_inviterAddress].inviteEarnings = pInfoXpAdd[_inviterAddress].inviteEarnings.add(_amount/10);\r\n        }\r\n        //Record the order of purchase for each user\r\n        uint256 playerIndex = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber.add(1);\r\n        rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber = playerIndex;\r\n        rInfoXrID[roundNumber].dayInfoXDay[dayNumber].addXIndex[playerIndex] = _senderAddress;\r\n        //After the user purchases, they can add 50% more, except for the first user\r\n        if(rInfoXrID[roundNumber].increaseETH > 0) {\r\n            rInfoXrID[roundNumber].dayInfoXDay[dayNumber].increaseMine = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].increaseMine.add(_amount*5/2);\r\n            rInfoXrID[roundNumber].totalMine = rInfoXrID[roundNumber].totalMine.add(_amount*15/2);\r\n        } else {\r\n            rInfoXrID[roundNumber].totalMine = rInfoXrID[roundNumber].totalMine.add(_amount*5);\r\n        }\r\n        //Record the accumulated ETH in the prize pool, the newly added ETH each day, the ore and the ore actually purchased by each user\r\n        rInfoXrID[roundNumber].increaseETH = rInfoXrID[roundNumber].increaseETH.add(_amount).sub(_amount/10);\r\n        rInfoXrID[roundNumber].dayInfoXDay[dayNumber].increaseETH = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].increaseETH.add(_amount).sub(_amount/10);\r\n        rInfoXrID[roundNumber].dayInfoXDay[dayNumber].actualMine = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].actualMine.add(_amount*5);\r\n        rInfoXrID[roundNumber].dayInfoXDay[dayNumber].mineAmountXAddress[_senderAddress] = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].mineAmountXAddress[_senderAddress].add(_amount*5);\r\n        rInfoXrID[roundNumber].dayInfoXDay[dayNumber].ethPayAmountXAddress[_senderAddress] = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].ethPayAmountXAddress[_senderAddress].add(_amount);\r\n    }\r\n    \r\n    function playerWithdraw(uint256 _amount) public {\r\n        address _senderAddress = msg.sender;\r\n        uint256 balance = getUserBalance(_senderAddress);\r\n        require(balance>=_amount,\"Lack of balance\");\r\n        //The platform charges users 1% of the commission fee, and the rest is withdrawn to the user account\r\n        platformBalance = platformBalance.add(_amount.div(100));\r\n        pInfoXpAdd[_senderAddress].withDrawNumber = pInfoXpAdd[_senderAddress].withDrawNumber.add(_amount);\r\n        _senderAddress.transfer(_amount.sub(_amount.div(100)));\r\n    }\r\n    \r\n    function sendBalanceForDevelop(uint256 _roundID) private {\r\n        uint256 bouns = getBounsWithRoundID(_roundID).div(5);\r\n        sysDevelopAddress.transfer(bouns.div(2));\r\n        sysInviterAddress.transfer(bouns.sub(bouns.div(2)));\r\n    }\r\n    \r\n    //If no users participate in the game for 10 consecutive rounds, the administrator can destroy the contract\r\n    function kill() public {\r\n        require(msg.sender == sysAdminAddress,\"You can't do this\");\r\n        require(roundNumber>=10,\"Wait patiently\");\r\n        bool noPlayer;\r\n        //Check if users have participated in the last 10 rounds\r\n        for(uint256 i=0;i<10;i++) {\r\n            uint256 eth = rInfoXrID[roundNumber-i].increaseETH;\r\n            if(eth == 0) {\r\n                noPlayer = true;\r\n            } else {\r\n                noPlayer = false;\r\n            }\r\n        }\r\n        require(noPlayer,\"This cannot be done because the user is still present\");\r\n        uint256 p3dBalance = p3dContract.balanceOf(address(this));\r\n        p3dContract.transfer(sysAdminAddress,p3dBalance);\r\n        selfdestruct(sysAdminAddress);\r\n    }\r\n\r\n    //********************\r\n    // Calculate Data\r\n    //********************\r\n    function getBounsWithRoundID(uint256 _roundID) private view returns(uint256 _bouns) {\r\n        _bouns = _bouns.add(rInfoXrID[_roundID].bounsInitNumber).add(rInfoXrID[_roundID].increaseETH);\r\n        return(_bouns);\r\n    }\r\n    \r\n    function getETHNeedPay(uint256 _roundID,uint256 _dayID) private view returns(uint256 _amount) {\r\n        if(_dayID >=2) {\r\n            uint256 mineTotal = rInfoXrID[_roundID].totalMine.sub(rInfoXrID[_roundID].dayInfoXDay[_dayID].actualMine).sub(rInfoXrID[_roundID].dayInfoXDay[_dayID].increaseMine);\r\n            _amount = mineTotal.mul(getTransformRate()).div(10000);\r\n        } else {\r\n            _amount = 0;\r\n        }\r\n        return(_amount);\r\n    }\r\n    \r\n    function getIncreaseBalance(uint256 _dayID,uint256 _roundID) private view returns(uint256 _balance) {\r\n        _balance = rInfoXrID[_roundID].dayInfoXDay[_dayID].increaseETH;\r\n        return(_balance);\r\n    }\r\n    \r\n    function getMineInfoInDay(address _userAddress,uint256 _roundID, uint256 _dayID) private view returns(uint256 _totalMine,uint256 _myMine,uint256 _additional) {\r\n        //Through traversal, the total amount of ore by the end of the day, the amount of ore held by users, and the amount of additional additional secondary ore\r\n        for(uint256 i=1;i<=_dayID;i++) {\r\n            if(rInfoXrID[_roundID].increaseETH == 0) return(0,0,0);\r\n            uint256 userActualMine = rInfoXrID[_roundID].dayInfoXDay[i].mineAmountXAddress[_userAddress];\r\n            uint256 increaseMineInDay = rInfoXrID[_roundID].dayInfoXDay[i].increaseMine;\r\n            _myMine = _myMine.add(userActualMine);\r\n            _totalMine = _totalMine.add(rInfoXrID[_roundID].dayInfoXDay[i].increaseETH*50/9);\r\n            uint256 dividendsMine = _myMine.mul(increaseMineInDay).div(_totalMine);\r\n            _totalMine = _totalMine.add(increaseMineInDay);\r\n            _myMine = _myMine.add(dividendsMine);\r\n            _additional = dividendsMine;\r\n        }\r\n        return(_totalMine,_myMine,_additional);\r\n    }\r\n    \r\n    //Ore ->eth conversion rate\r\n    function getTransformRate() private pure returns(uint256 _rate) {\r\n        return(60);\r\n    }\r\n    \r\n    //Calculate the amount of eth to be paid in x day for user\r\n    function getTransformMineInDay(address _userAddress,uint256 _roundID,uint256 _dayID) private view returns(uint256 _transformedMine) {\r\n        (,uint256 userMine,) = getMineInfoInDay(_userAddress,_roundID,_dayID.sub(1));\r\n        uint256 rate = getTransformRate();\r\n        _transformedMine = userMine.mul(rate).div(10000);\r\n        return(_transformedMine);\r\n    }\r\n    \r\n    //Calculate the amount of eth to be paid in x day for all people\r\n    function calculateTotalMinePay(uint256 _roundID,uint256 _dayID) private view returns(uint256 _needToPay) {\r\n        uint256 mine = rInfoXrID[_roundID].totalMine.sub(rInfoXrID[_roundID].dayInfoXDay[_dayID].actualMine).sub(rInfoXrID[_roundID].dayInfoXDay[_dayID].increaseMine);\r\n        _needToPay = mine.mul(getTransformRate()).div(10000);\r\n        return(_needToPay);\r\n    }\r\n\r\n    //Calculate daily target values\r\n    function getDailyTarget(uint256 _roundID,uint256 _dayID) private view returns(uint256) {\r\n        uint256 needToPay = calculateTotalMinePay(_roundID,_dayID);\r\n        uint256 target = 0;\r\n        if (_dayID > 33) {\r\n            target = (SafeMath.pwr(((3).mul(_dayID).sub(100)),3).mul(50).add(1000000)).mul(needToPay).div(1000000);\r\n            return(target);\r\n        } else {\r\n            target = ((1000000).sub(SafeMath.pwr((100).sub((3).mul(_dayID)),3))).mul(needToPay).div(1000000);\r\n            if(target == 0) target = 0.0063 ether;\r\n            return(target);            \r\n        }\r\n    }\r\n    \r\n    //Query user income balance\r\n    function getUserBalance(address _userAddress) private view returns(uint256 _balance) {\r\n        if(pIDXpAdd[_userAddress] == 0) {\r\n            return(0);\r\n        }\r\n        //Amount of user withdrawal\r\n        uint256 withDrawNumber = pInfoXpAdd[_userAddress].withDrawNumber;\r\n        uint256 totalTransformed = 0;\r\n        //Calculate the number of ETH users get through the daily conversion\r\n        bool islocked = checkContructIsLocked();\r\n        for(uint256 i=1;i<=roundNumber;i++) {\r\n            if(islocked && i == roundNumber) {\r\n                return;\r\n            }\r\n            for(uint256 j=1;j<rInfoXrID[i].totalDay;j++) {\r\n                totalTransformed = totalTransformed.add(getTransformMineInDay(_userAddress,i,j));\r\n            }\r\n        }\r\n        //Get the ETH obtained by user invitation\r\n        uint256 inviteEarnings = pInfoXpAdd[_userAddress].inviteEarnings;\r\n        _balance = totalTransformed.add(inviteEarnings).add(getBounsEarnings(_userAddress)).add(getHoldEarnings(_userAddress)).add(getUserP3DDivEarnings(_userAddress)).sub(withDrawNumber);\r\n        return(_balance);\r\n    }\r\n    \r\n    //calculate how much eth user have paid\r\n    function getUserPaidInCurrentRound(address _userAddress) public view returns(uint256 _payAmount) {\r\n        if(pInfoXpAdd[_userAddress].getPaidETHBackXRoundID[roundNumber]) {\r\n            return(0);\r\n        }\r\n        for(uint256 i=1;i<=rInfoXrID[roundNumber].totalDay;i++) {\r\n             _payAmount = _payAmount.add(rInfoXrID[roundNumber].dayInfoXDay[i].ethPayAmountXAddress[_userAddress]);\r\n        }\r\n        return(_payAmount);\r\n    }\r\n    \r\n    //user can get eth back if the contract is locked\r\n    function getPaidETHBack() public {\r\n        require(checkContructIsLocked(),\"The contract is in normal operation\");\r\n        address _sender = msg.sender;\r\n        uint256 paidAmount = getUserPaidInCurrentRound(_sender);\r\n        pInfoXpAdd[_sender].getPaidETHBackXRoundID[roundNumber] = true;\r\n        _sender.transfer(paidAmount);\r\n    }\r\n    \r\n    //Calculated the number of ETH users won in the prize pool\r\n    function getBounsEarnings(address _userAddress) private view returns(uint256 _bounsEarnings) {\r\n        for(uint256 i=1;i<roundNumber;i++) {\r\n            uint256 winnerDay = rInfoXrID[i].winnerDay;\r\n            uint256 myAmountInWinnerDay=rInfoXrID[i].dayInfoXDay[winnerDay].ethPayAmountXAddress[_userAddress];\r\n            uint256 totalAmountInWinnerDay=rInfoXrID[i].dayInfoXDay[winnerDay].increaseETH*10/9;\r\n            if(winnerDay == 0 || totalAmountInWinnerDay == 0) {\r\n                _bounsEarnings = _bounsEarnings;\r\n            } else {\r\n                uint256 bouns = getBounsWithRoundID(i).mul(14).div(25);\r\n                _bounsEarnings = _bounsEarnings.add(bouns.mul(myAmountInWinnerDay).div(totalAmountInWinnerDay));\r\n            }\r\n        }\r\n        return(_bounsEarnings);\r\n    }\r\n\r\n    //Compute the ETH that the user acquires by holding the ore\r\n    function getHoldEarnings(address _userAddress) private view returns(uint256 _holdEarnings) {\r\n        for(uint256 i=1;i<roundNumber;i++) {\r\n            uint256 winnerDay = rInfoXrID[i].winnerDay;\r\n            if(winnerDay == 0) {\r\n                _holdEarnings = _holdEarnings;\r\n            } else {  \r\n                (uint256 totalMine,uint256 myMine,) = getMineInfoInDay(_userAddress,i,rInfoXrID[i].totalDay);\r\n                uint256 bouns = getBounsWithRoundID(i).mul(7).div(50);\r\n                _holdEarnings = _holdEarnings.add(bouns.mul(myMine).div(totalMine));    \r\n            }\r\n        }\r\n        return(_holdEarnings);\r\n    }\r\n    \r\n    //Calculate user's P3D bonus\r\n    function getUserP3DDivEarnings(address _userAddress) private view returns(uint256 _myP3DDivide) {\r\n        if(rInfoXrID[roundNumber].totalDay <= 1) {\r\n            return(0);\r\n        }\r\n        for(uint256 i=1;i<roundNumber;i++) {\r\n            uint256 p3dDay = rInfoXrID[i].totalDay;\r\n            uint256 myAmountInp3dDay=rInfoXrID[i].dayInfoXDay[p3dDay].ethPayAmountXAddress[_userAddress];\r\n            uint256 totalAmountInP3dDay=rInfoXrID[i].dayInfoXDay[p3dDay].increaseETH*10/9;\r\n            if(p3dDay == 0 || totalAmountInP3dDay == 0) {\r\n                _myP3DDivide = _myP3DDivide;\r\n            } else {\r\n                uint256 p3dDividesInRound = p3dDividesXroundID[i];\r\n                _myP3DDivide = _myP3DDivide.add(p3dDividesInRound.mul(myAmountInp3dDay).div(totalAmountInP3dDay));\r\n            }\r\n        }\r\n        return(_myP3DDivide);\r\n    }\r\n    \r\n    //*******************\r\n    // Check contract lock\r\n    //*******************\r\n    function checkContructIsLocked() public view returns(bool) {\r\n        uint256 time = now.sub(rInfoXrID[roundNumber].lastCalculateTime);\r\n        if(time >= 2*cycleTime) {\r\n            return(true);\r\n        } else {\r\n            return(false);\r\n        }\r\n    }\r\n\r\n    //*******************\r\n    // UI \r\n    //*******************\r\n    function getDefendPlayerList() public view returns(address[]) {\r\n        if (rInfoXrID[roundNumber].dayInfoXDay[dayNumber-1].playerNumber == 0) {\r\n            address[] memory playerListEmpty = new address[](0);\r\n            return(playerListEmpty);\r\n        }\r\n        uint256 number = rInfoXrID[roundNumber].dayInfoXDay[dayNumber-1].playerNumber;\r\n        if(number > 100) {\r\n            number == 100;\r\n        }\r\n        address[] memory playerList = new address[](number);\r\n        for(uint256 i=0;i<number;i++) {\r\n            playerList[i] = rInfoXrID[roundNumber].dayInfoXDay[dayNumber-1].addXIndex[i+1];\r\n        }\r\n        return(playerList);\r\n    }\r\n    \r\n    function getAttackPlayerList() public view returns(address[]) {\r\n        uint256 number = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber;\r\n        if(number > 100) {\r\n            number == 100;\r\n        }\r\n        address[] memory playerList = new address[](number);\r\n        for(uint256 i=0;i<number;i++) {\r\n            playerList[i] = rInfoXrID[roundNumber].dayInfoXDay[dayNumber].addXIndex[i+1];\r\n        }\r\n        return(playerList);\r\n    }\r\n    \r\n    function getCurrentFieldBalanceAndTarget() public view returns(uint256 day,uint256 bouns,uint256 todayBouns,uint256 dailyTarget) {\r\n        uint256 fieldBalance = getBounsWithRoundID(roundNumber).mul(7).div(10);\r\n        uint256 todayBalance = getIncreaseBalance(dayNumber,roundNumber) ;\r\n        dailyTarget = getDailyTarget(roundNumber,dayNumber);\r\n        return(dayNumber,fieldBalance,todayBalance,dailyTarget);\r\n    }\r\n    \r\n    function getUserIDAndInviterEarnings() public view returns(uint256 userID,uint256 inviteEarning) {\r\n        return(pIDXpAdd[msg.sender],pInfoXpAdd[msg.sender].inviteEarnings);\r\n    }\r\n    \r\n    function getCurrentRoundInfo() public view returns(uint256 _roundID,uint256 _dayNumber,uint256 _ethMineNumber,uint256 _startTime,uint256 _lastCalculateTime) {\r\n        DataModal.RoundInfo memory roundInfo = rInfoXrID[roundNumber];\r\n        (uint256 totalMine,,) = getMineInfoInDay(msg.sender,roundNumber,dayNumber);\r\n        return(roundNumber,dayNumber,totalMine,roundInfo.startTime,roundInfo.lastCalculateTime);\r\n    }\r\n    \r\n    function getUserProperty() public view returns(uint256 ethMineNumber,uint256 holdEarning,uint256 transformRate,uint256 ethBalance,uint256 ethTranslated,uint256 ethMineCouldTranslateToday,uint256 ethCouldGetToday) {\r\n        address _userAddress = msg.sender;\r\n        if(pIDXpAdd[_userAddress] <1) {\r\n            return(0,0,0,0,0,0,0);        \r\n        }\r\n        (,uint256 myMine,uint256 additional) = getMineInfoInDay(_userAddress,roundNumber,dayNumber);\r\n        ethMineNumber = myMine;\r\n        holdEarning = additional;\r\n        transformRate = getTransformRate();      \r\n        ethBalance = getUserBalance(_userAddress);\r\n        uint256 totalTransformed = 0;\r\n        for(uint256 i=1;i<rInfoXrID[roundNumber].totalDay;i++) {\r\n            totalTransformed = totalTransformed.add(getTransformMineInDay(_userAddress,roundNumber,i));\r\n        }\r\n        ethTranslated = totalTransformed;\r\n        ethCouldGetToday = getTransformMineInDay(_userAddress,roundNumber,dayNumber);\r\n        (,uint256 userMine,) = getMineInfoInDay(_userAddress,roundNumber,dayNumber.sub(1));\r\n        if(userMine == 0) {\r\n            ethCouldGetToday = 0;\r\n        }else{\r\n            ethMineCouldTranslateToday = myMine.mul(transformRate).div(10000);\r\n        }\r\n        return(\r\n            ethMineNumber,\r\n            holdEarning,\r\n            transformRate,\r\n            ethBalance,\r\n            ethTranslated,\r\n            ethMineCouldTranslateToday,\r\n            ethCouldGetToday\r\n            );\r\n    }\r\n    \r\n    function getPlatformBalance() public view returns(uint256 _platformBalance) {\r\n        require(msg.sender == sysAdminAddress,\"Ummmmm......Only admin could do this\");\r\n        return(platformBalance);\r\n    }\r\n\r\n    //************\r\n    // for statistics\r\n    //************\r\n    function getDataOfGame() public view returns(uint256 _playerNumber,uint256 _dailyIncreased,uint256 _dailyTransform,uint256 _contractBalance,uint256 _userBalanceLeft,uint256 _platformBalance,uint256 _mineBalance,uint256 _balanceOfMine) {\r\n        for(uint256 i=1;i<=totalPlayerNumber;i++) {\r\n            address userAddress = pAddXpID[i];\r\n            _userBalanceLeft = _userBalanceLeft.add(getUserBalance(userAddress));\r\n        }\r\n        return(\r\n            totalPlayerNumber,\r\n            getIncreaseBalance(dayNumber,roundNumber),\r\n            calculateTotalMinePay(roundNumber,dayNumber),\r\n            address(this).balance,\r\n            _userBalanceLeft,\r\n            platformBalance,\r\n            getBounsWithRoundID(roundNumber),\r\n            getBounsWithRoundID(roundNumber).mul(7).div(10)\r\n            );\r\n    }\r\n    \r\n    function getUserAddressList() public view returns(address[]) {\r\n        address[] memory addressList = new address[](totalPlayerNumber);\r\n        for(uint256 i=0;i<totalPlayerNumber;i++) {\r\n            addressList[i] = pAddXpID[i+1];\r\n        }\r\n        return(addressList);\r\n    }\r\n    \r\n    function getUsersInfo() public view returns(uint256[7][]){\r\n        uint256[7][] memory infoList = new uint256[7][](totalPlayerNumber);\r\n        for(uint256 i=0;i<totalPlayerNumber;i++) {\r\n            address userAddress = pAddXpID[i+1];\r\n            (,uint256 myMine,uint256 additional) = getMineInfoInDay(userAddress,roundNumber,dayNumber);\r\n            uint256 totalTransformed = 0;\r\n            for(uint256 j=1;j<=roundNumber;j++) {\r\n                for(uint256 k=1;k<=rInfoXrID[j].totalDay;k++) {\r\n                    totalTransformed = totalTransformed.add(getTransformMineInDay(userAddress,j,k));\r\n                }\r\n            }\r\n            infoList[i][0] = myMine ;\r\n            infoList[i][1] = getTransformRate();\r\n            infoList[i][2] = additional;\r\n            infoList[i][3] = getUserBalance(userAddress);\r\n            infoList[i][4] = getUserBalance(userAddress).add(pInfoXpAdd[userAddress].withDrawNumber);\r\n            infoList[i][5] = pInfoXpAdd[userAddress].inviteEarnings;\r\n            infoList[i][6] = totalTransformed;\r\n        }        \r\n        return(infoList);\r\n    }\r\n    \r\n    function getP3DInfo() public view returns(uint256 _p3dTokenInContract,uint256 _p3dDivInRound) {\r\n        _p3dTokenInContract = p3dContract.balanceOf(address(this));\r\n        _p3dDivInRound = p3dDividesXroundID[roundNumber];\r\n        return(_p3dTokenInContract,_p3dDivInRound);\r\n    }\r\n    \r\n}\r\n\r\n//P3D Interface\r\ninterface HourglassInterface {\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function withdraw() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n    function balanceOf(address _customerAddress) external view returns(uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n}\r\n\r\nlibrary DataModal {\r\n    struct PlayerInfo {\r\n        uint256 inviteEarnings;\r\n        address inviterAddress;\r\n        uint256 withDrawNumber;\r\n        mapping(uint256=>bool) getPaidETHBackXRoundID;\r\n    }\r\n    \r\n    struct DayInfo {\r\n        uint256 playerNumber;\r\n        uint256 actualMine;\r\n        uint256 increaseETH;\r\n        uint256 increaseMine;\r\n        mapping(uint256=>address) addXIndex;\r\n        mapping(address=>uint256) ethPayAmountXAddress;\r\n        mapping(address=>uint256) mineAmountXAddress;\r\n    }\r\n    \r\n    struct RoundInfo {\r\n        uint256 startTime;\r\n        uint256 lastCalculateTime;\r\n        uint256 bounsInitNumber;\r\n        uint256 increaseETH;\r\n        uint256 totalDay;\r\n        uint256 winnerDay;\r\n        uint256 totalMine;\r\n        mapping(uint256=>DayInfo) dayInfoXDay;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath div failed\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    } \r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_inviterID\",\"type\":\"uint256\"}],\"name\":\"joinGameWithInviterID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calculateTarget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserAddressList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkContructIsLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"playerWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_inviterID\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"joinGameWithInviterIDForAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"_roundID\",\"type\":\"uint256\"},{\"name\":\"_dayNumber\",\"type\":\"uint256\"},{\"name\":\"_ethMineNumber\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_lastCalculateTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getP3DInfo\",\"outputs\":[{\"name\":\"_p3dTokenInContract\",\"type\":\"uint256\"},{\"name\":\"_p3dDivInRound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserProperty\",\"outputs\":[{\"name\":\"ethMineNumber\",\"type\":\"uint256\"},{\"name\":\"holdEarning\",\"type\":\"uint256\"},{\"name\":\"transformRate\",\"type\":\"uint256\"},{\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"name\":\"ethTranslated\",\"type\":\"uint256\"},{\"name\":\"ethMineCouldTranslateToday\",\"type\":\"uint256\"},{\"name\":\"ethCouldGetToday\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefendPlayerList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getPaidETHBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAttackPlayerList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUsersInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataOfGame\",\"outputs\":[{\"name\":\"_playerNumber\",\"type\":\"uint256\"},{\"name\":\"_dailyIncreased\",\"type\":\"uint256\"},{\"name\":\"_dailyTransform\",\"type\":\"uint256\"},{\"name\":\"_contractBalance\",\"type\":\"uint256\"},{\"name\":\"_userBalanceLeft\",\"type\":\"uint256\"},{\"name\":\"_platformBalance\",\"type\":\"uint256\"},{\"name\":\"_mineBalance\",\"type\":\"uint256\"},{\"name\":\"_balanceOfMine\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlatformBalance\",\"outputs\":[{\"name\":\"_platformBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"joinGameWithBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserIDAndInviterEarnings\",\"outputs\":[{\"name\":\"userID\",\"type\":\"uint256\"},{\"name\":\"inviteEarning\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserPaidInCurrentRound\",\"outputs\":[{\"name\":\"_payAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFieldBalanceAndTarget\",\"outputs\":[{\"name\":\"day\",\"type\":\"uint256\"},{\"name\":\"bouns\",\"type\":\"uint256\"},{\"name\":\"todayBouns\",\"type\":\"uint256\"},{\"name\":\"dailyTarget\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_JoinWithEth\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"newPlayerJoinGameEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundID\",\"type\":\"uint256\"}],\"name\":\"calculateTargetEvent\",\"type\":\"event\"}]","ContractName":"Richer3D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://405c3a52501478d1aa0875913a394884c3a4d41a00bc4b69779bf149c8529b4d"}]}