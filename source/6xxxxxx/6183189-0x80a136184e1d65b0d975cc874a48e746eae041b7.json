{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b, \"Overflow - Multiplication\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"Underflow - Subtraction\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"Overflow - Addition\");\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary Contract {\r\n\r\n  using SafeMath for uint;\r\n\r\n  // Modifiers: //\r\n\r\n  // Runs two functions before and after a function -\r\n  modifier conditions(function () pure first, function () pure last) {\r\n    first();\r\n    _;\r\n    last();\r\n  }\r\n\r\n  bytes32 internal constant EXEC_PERMISSIONS = keccak256('script_exec_permissions');\r\n\r\n  // Sets up contract execution - reads execution id and sender from storage and\r\n  // places in memory, creating getters. Calling this function should be the first\r\n  // action an application does as part of execution, as it sets up memory for\r\n  // execution. Additionally, application functions in the main file should be\r\n  // external, so that memory is not touched prior to calling this function.\r\n  // The 3rd slot allocated will hold a pointer to a storage buffer, which will\r\n  // be reverted to abstract storage to store data, emit events, and forward\r\n  // wei on behalf of the application.\r\n  function authorize(address _script_exec) internal view {\r\n    // Initialize memory\r\n    initialize();\r\n\r\n    // Check that the sender is authorized as a script exec contract for this exec id\r\n    bytes32 perms = EXEC_PERMISSIONS;\r\n    bool authorized;\r\n    assembly {\r\n      // Place the script exec address at 0, and the exec permissions seed after it\r\n      mstore(0, _script_exec)\r\n      mstore(0x20, perms)\r\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\r\n      mstore(0, keccak256(0x0c, 0x34))\r\n      // Place the exec id after the hash -\r\n      mstore(0x20, mload(0x80))\r\n      // Hash the previous hash with the execution id, and check the result\r\n      authorized := sload(keccak256(0, 0x40))\r\n    }\r\n    if (!authorized)\r\n      revert(\"Sender is not authorized as a script exec address\");\r\n  }\r\n\r\n  // Sets up contract execution when initializing an instance of the application\r\n  // First, reads execution id and sender from storage (execution id should be 0xDEAD),\r\n  // then places them in memory, creating getters. Calling this function should be the first\r\n  // action an application does as part of execution, as it sets up memory for\r\n  // execution. Additionally, application functions in the main file should be\r\n  // external, so that memory is not touched prior to calling this function.\r\n  // The 3rd slot allocated will hold a pointer to a storage buffer, which will\r\n  // be reverted to abstract storage to store data, emit events, and forward\r\n  // wei on behalf of the application.\r\n  function initialize() internal view {\r\n    // No memory should have been allocated yet - expect the free memory pointer\r\n    // to point to 0x80 - and throw if it does not\r\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\r\n    // Next, set up memory for execution\r\n    assembly {\r\n      mstore(0x80, sload(0))     // Execution id, read from storage\r\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\r\n      mstore(0xc0, 0)            // Pointer to storage buffer\r\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\r\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\r\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\r\n      mstore(0x140, 0)           // Number of events pushed to buffer\r\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\r\n\r\n      // Update free memory pointer -\r\n      mstore(0x40, 0x180)\r\n    }\r\n    // Ensure that the sender and execution id returned from storage are expected values -\r\n    assert(execID() != bytes32(0) && sender() != address(0));\r\n  }\r\n\r\n  // Calls the passed-in function, performing a memory state check before and after the check\r\n  // is executed.\r\n  function checks(function () view _check) conditions(validState, validState) internal view {\r\n    _check();\r\n  }\r\n\r\n  // Calls the passed-in function, performing a memory state check before and after the check\r\n  // is executed.\r\n  function checks(function () pure _check) conditions(validState, validState) internal pure {\r\n    _check();\r\n  }\r\n\r\n  // Ensures execution completed successfully, and reverts the created storage buffer\r\n  // back to the sender.\r\n  function commit() conditions(validState, none) internal pure {\r\n    // Check value of storage buffer pointer - should be at least 0x180\r\n    bytes32 ptr = buffPtr();\r\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\r\n\r\n    assembly {\r\n      // Get the size of the buffer\r\n      let size := mload(add(0x20, ptr))\r\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\r\n      // Revert to storage\r\n      revert(ptr, add(0x40, size))\r\n    }\r\n  }\r\n\r\n  // Helpers: //\r\n\r\n  // Checks to ensure the application was correctly executed -\r\n  function validState() private pure {\r\n    if (freeMem() < 0x180)\r\n      revert('Expected Contract.execute()');\r\n\r\n    if (buffPtr() != 0 && buffPtr() < 0x180)\r\n      revert('Invalid buffer pointer');\r\n\r\n    assert(execID() != bytes32(0) && sender() != address(0));\r\n  }\r\n\r\n  // Returns a pointer to the execution storage buffer -\r\n  function buffPtr() private pure returns (bytes32 ptr) {\r\n    assembly { ptr := mload(0xc0) }\r\n  }\r\n\r\n  // Returns the location pointed to by the free memory pointer -\r\n  function freeMem() private pure returns (bytes32 ptr) {\r\n    assembly { ptr := mload(0x40) }\r\n  }\r\n\r\n  // Returns the current storage action\r\n  function currentAction() private pure returns (bytes4 action) {\r\n    if (buffPtr() == bytes32(0))\r\n      return bytes4(0);\r\n\r\n    assembly { action := mload(0xe0) }\r\n  }\r\n\r\n  // If the current action is not storing, reverts\r\n  function isStoring() private pure {\r\n    if (currentAction() != STORES)\r\n      revert('Invalid current action - expected STORES');\r\n  }\r\n\r\n  // If the current action is not emitting, reverts\r\n  function isEmitting() private pure {\r\n    if (currentAction() != EMITS)\r\n      revert('Invalid current action - expected EMITS');\r\n  }\r\n\r\n  // If the current action is not paying, reverts\r\n  function isPaying() private pure {\r\n    if (currentAction() != PAYS)\r\n      revert('Invalid current action - expected PAYS');\r\n  }\r\n\r\n  // Initializes a storage buffer in memory -\r\n  function startBuffer() private pure {\r\n    assembly {\r\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\r\n      let ptr := msize()\r\n      mstore(0xc0, ptr)\r\n      // Clear bytes at pointer -\r\n      mstore(ptr, 0)            // temp ptr\r\n      mstore(add(0x20, ptr), 0) // buffer length\r\n      // Update free memory pointer -\r\n      mstore(0x40, add(0x40, ptr))\r\n      // Set expected next function to 'NONE' -\r\n      mstore(0x100, 1)\r\n    }\r\n  }\r\n\r\n  // Checks whether or not it is valid to create a STORES action request -\r\n  function validStoreBuff() private pure {\r\n    // Get pointer to current buffer - if zero, create a new buffer -\r\n    if (buffPtr() == bytes32(0))\r\n      startBuffer();\r\n\r\n    // Ensure that the current action is not 'storing', and that the buffer has not already\r\n    // completed a STORES action -\r\n    if (stored() != 0 || currentAction() == STORES)\r\n      revert('Duplicate request - stores');\r\n  }\r\n\r\n  // Checks whether or not it is valid to create an EMITS action request -\r\n  function validEmitBuff() private pure {\r\n    // Get pointer to current buffer - if zero, create a new buffer -\r\n    if (buffPtr() == bytes32(0))\r\n      startBuffer();\r\n\r\n    // Ensure that the current action is not 'emitting', and that the buffer has not already\r\n    // completed an EMITS action -\r\n    if (emitted() != 0 || currentAction() == EMITS)\r\n      revert('Duplicate request - emits');\r\n  }\r\n\r\n  // Checks whether or not it is valid to create a PAYS action request -\r\n  function validPayBuff() private pure {\r\n    // Get pointer to current buffer - if zero, create a new buffer -\r\n    if (buffPtr() == bytes32(0))\r\n      startBuffer();\r\n\r\n    // Ensure that the current action is not 'paying', and that the buffer has not already\r\n    // completed an PAYS action -\r\n    if (paid() != 0 || currentAction() == PAYS)\r\n      revert('Duplicate request - pays');\r\n  }\r\n\r\n  // Placeholder function when no pre or post condition for a function is needed\r\n  function none() private pure { }\r\n\r\n  // Runtime getters: //\r\n\r\n  // Returns the execution id from memory -\r\n  function execID() internal pure returns (bytes32 exec_id) {\r\n    assembly { exec_id := mload(0x80) }\r\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\r\n  }\r\n\r\n  // Returns the original sender from memory -\r\n  function sender() internal pure returns (address addr) {\r\n    assembly { addr := mload(0xa0) }\r\n    require(addr != address(0), \"Sender address overwritten, or not read\");\r\n  }\r\n\r\n  // Reading from storage: //\r\n\r\n  // Reads from storage, resolving the passed-in location to its true location in storage\r\n  // by hashing with the exec id. Returns the data read from that location\r\n  function read(bytes32 _location) internal view returns (bytes32 data) {\r\n    data = keccak256(_location, execID());\r\n    assembly { data := sload(data) }\r\n  }\r\n\r\n  // Storing data, emitting events, and forwarding payments: //\r\n\r\n  bytes4 internal constant EMITS = bytes4(keccak256('Emit((bytes32[],bytes)[])'));\r\n  bytes4 internal constant STORES = bytes4(keccak256('Store(bytes32[])'));\r\n  bytes4 internal constant PAYS = bytes4(keccak256('Pay(bytes32[])'));\r\n  bytes4 internal constant THROWS = bytes4(keccak256('Error(string)'));\r\n\r\n  // Function enums -\r\n  enum NextFunction {\r\n    INVALID, NONE, STORE_DEST, VAL_SET, VAL_INC, VAL_DEC, EMIT_LOG, PAY_DEST, PAY_AMT\r\n  }\r\n\r\n  // Checks that a call pushing a storage destination to the buffer is expected and valid\r\n  function validStoreDest() private pure {\r\n    // Ensure that the next function expected pushes a storage destination -\r\n    if (expected() != NextFunction.STORE_DEST)\r\n      revert('Unexpected function order - expected storage destination to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing STORES actions -\r\n    isStoring();\r\n  }\r\n\r\n  // Checks that a call pushing a storage value to the buffer is expected and valid\r\n  function validStoreVal() private pure {\r\n    // Ensure that the next function expected pushes a storage value -\r\n    if (\r\n      expected() != NextFunction.VAL_SET &&\r\n      expected() != NextFunction.VAL_INC &&\r\n      expected() != NextFunction.VAL_DEC\r\n    ) revert('Unexpected function order - expected storage value to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing STORES actions -\r\n    isStoring();\r\n  }\r\n\r\n  // Checks that a call pushing a payment destination to the buffer is expected and valid\r\n  function validPayDest() private pure {\r\n    // Ensure that the next function expected pushes a payment destination -\r\n    if (expected() != NextFunction.PAY_DEST)\r\n      revert('Unexpected function order - expected payment destination to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing PAYS actions -\r\n    isPaying();\r\n  }\r\n\r\n  // Checks that a call pushing a payment amount to the buffer is expected and valid\r\n  function validPayAmt() private pure {\r\n    // Ensure that the next function expected pushes a payment amount -\r\n    if (expected() != NextFunction.PAY_AMT)\r\n      revert('Unexpected function order - expected payment amount to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing PAYS actions -\r\n    isPaying();\r\n  }\r\n\r\n  // Checks that a call pushing an event to the buffer is expected and valid\r\n  function validEvent() private pure {\r\n    // Ensure that the next function expected pushes an event -\r\n    if (expected() != NextFunction.EMIT_LOG)\r\n      revert('Unexpected function order - expected event to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing EMITS actions -\r\n    isEmitting();\r\n  }\r\n\r\n  // Begins creating a storage buffer - values and locations pushed will be committed\r\n  // to storage at the end of execution\r\n  function storing() conditions(validStoreBuff, isStoring) internal pure {\r\n    bytes4 action_req = STORES;\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\r\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\r\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\r\n      // Increment buffer length - 0x24 plus the previous length\r\n      mstore(ptr, add(0x24, mload(ptr)))\r\n      // Set the current action being executed (STORES) -\r\n      mstore(0xe0, action_req)\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n      // Set a pointer to the length of the current request within the buffer\r\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Sets a passed in location to a value passed in via 'to'\r\n  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - VAL_SET\r\n      mstore(0x100, 3)\r\n      // Increment STORES action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of storage slots pushed to -\r\n      mstore(0x120, add(1, mload(0x120)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return _field;\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage value to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32 _field, uint _val) internal pure {\r\n    to(_field, bytes32(_val));\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32 _field, address _val) internal pure {\r\n    to(_field, bytes32(_val));\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32 _field, bool _val) internal pure {\r\n    to(\r\n      _field,\r\n      _val ? bytes32(1) : bytes32(0)\r\n    );\r\n  }\r\n\r\n  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\r\n    // Read value stored at the location in storage -\r\n    val = keccak256(_field, execID());\r\n    assembly {\r\n      val := sload(val)\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - VAL_INC\r\n      mstore(0x100, 4)\r\n      // Increment STORES action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of storage slots pushed to -\r\n      mstore(0x120, add(1, mload(0x120)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return val;\r\n  }\r\n\r\n  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\r\n    // Read value stored at the location in storage -\r\n    val = keccak256(_field, execID());\r\n    assembly {\r\n      val := sload(val)\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - VAL_DEC\r\n      mstore(0x100, 5)\r\n      // Increment STORES action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of storage slots pushed to -\r\n      mstore(0x120, add(1, mload(0x120)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return val;\r\n  }\r\n\r\n  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\r\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\r\n    // If it is VAL_DEC, perform safe-sub on the value\r\n    if (expected() == NextFunction.VAL_INC)\r\n      _amt = _amt.add(uint(_val));\r\n    else if (expected() == NextFunction.VAL_DEC)\r\n      _amt = uint(_val).sub(_amt);\r\n    else\r\n      revert('Expected VAL_INC or VAL_DEC');\r\n\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage value to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Decreases the value at some field by a maximum amount, and sets it to 0 if there will be underflow\r\n  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\r\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\r\n    // _val and _amt, to a minimum of 0\r\n    if (expected() == NextFunction.VAL_DEC) {\r\n      if (_amt >= uint(_val))\r\n        _amt = 0;\r\n      else\r\n        _amt = uint(_val).sub(_amt);\r\n    } else {\r\n      revert('Expected VAL_DEC');\r\n    }\r\n\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage value to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Begins creating an event log buffer - topics and data pushed will be emitted by\r\n  // storage at the end of execution\r\n  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\r\n    bytes4 action_req = EMITS;\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\r\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\r\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\r\n      // Increment buffer length - 0x24 plus the previous length\r\n      mstore(ptr, add(0x24, mload(ptr)))\r\n      // Set the current action being executed (EMITS) -\r\n      mstore(0xe0, action_req)\r\n      // Set the expected next function - EMIT_LOG\r\n      mstore(0x100, 6)\r\n      // Set a pointer to the length of the current request within the buffer\r\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 0 to the end of the buffer - event will have 0 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0x40 plus the original length\r\n        mstore(ptr, add(0x40, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0x60 plus the original length\r\n        mstore(ptr, add(0x60, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 1 to the end of the buffer - event will have 1 topic\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\r\n      // Push topic to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0x60 plus the original length\r\n        mstore(ptr, add(0x60, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0x80 plus the original length\r\n        mstore(ptr, add(0x80, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 2 to the end of the buffer - event will have 2 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\r\n      // Push topics to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0x80 plus the original length\r\n        mstore(ptr, add(0x80, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0xa0 plus the original length\r\n        mstore(ptr, add(0xa0, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 3 to the end of the buffer - event will have 3 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\r\n      // Push topics to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\r\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0xa0 plus the original length\r\n        mstore(ptr, add(0xa0, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0xc0 plus the original length\r\n        mstore(ptr, add(0xc0, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 4 to the end of the buffer - event will have 4 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\r\n      // Push topics to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\r\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\r\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0xc0 plus the original length\r\n        mstore(ptr, add(0xc0, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0xe0 plus the original length\r\n        mstore(ptr, add(0xe0, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Begins creating a storage buffer - destinations entered will be forwarded wei\r\n  // before the end of execution\r\n  function paying() conditions(validPayBuff, isPaying) internal pure {\r\n    bytes4 action_req = PAYS;\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\r\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\r\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\r\n      // Increment buffer length - 0x24 plus the previous length\r\n      mstore(ptr, add(0x24, mload(ptr)))\r\n      // Set the current action being executed (PAYS) -\r\n      mstore(0xe0, action_req)\r\n      // Set the expected next function - PAY_AMT\r\n      mstore(0x100, 8)\r\n      // Set a pointer to the length of the current request within the buffer\r\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Pushes an amount of wei to forward to the buffer\r\n  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push payment amount to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - PAY_DEST\r\n      mstore(0x100, 7)\r\n      // Increment PAYS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of payment destinations to be pushed to -\r\n      mstore(0x160, add(1, mload(0x160)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return _amount;\r\n  }\r\n\r\n  // Push an address to forward wei to, to the buffer\r\n  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push payment destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - PAY_AMT\r\n      mstore(0x100, 8)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Sets the free memory pointer to point beyond all accessed memory\r\n  function setFreeMem() private pure {\r\n    assembly { mstore(0x40, msize) }\r\n  }\r\n\r\n  // Returns the enum representing the next expected function to be called -\r\n  function expected() private pure returns (NextFunction next) {\r\n    assembly { next := mload(0x100) }\r\n  }\r\n\r\n  // Returns the number of events pushed to the storage buffer -\r\n  function emitted() internal pure returns (uint num_emitted) {\r\n    if (buffPtr() == bytes32(0))\r\n      return 0;\r\n\r\n    // Load number emitted from buffer -\r\n    assembly { num_emitted := mload(0x140) }\r\n  }\r\n\r\n  // Returns the number of storage slots pushed to the storage buffer -\r\n  function stored() internal pure returns (uint num_stored) {\r\n    if (buffPtr() == bytes32(0))\r\n      return 0;\r\n\r\n    // Load number stored from buffer -\r\n    assembly { num_stored := mload(0x120) }\r\n  }\r\n\r\n  // Returns the number of payment destinations and amounts pushed to the storage buffer -\r\n  function paid() internal pure returns (uint num_paid) {\r\n    if (buffPtr() == bytes32(0))\r\n      return 0;\r\n\r\n    // Load number paid from buffer -\r\n    assembly { num_paid := mload(0x160) }\r\n  }\r\n}\r\n\r\ninterface GetterInterface {\r\n  function read(bytes32 exec_id, bytes32 location) external view returns (bytes32 data);\r\n  function readMulti(bytes32 exec_id, bytes32[] locations) external view returns (bytes32[] data);\r\n}\r\n\r\nlibrary ArrayUtils {\r\n\r\n  function toBytes4Arr(bytes32[] memory _arr) internal pure returns (bytes4[] memory _conv) {\r\n    assembly { _conv := _arr }\r\n  }\r\n\r\n  function toAddressArr(bytes32[] memory _arr) internal pure returns (address[] memory _conv) {\r\n    assembly { _conv := _arr }\r\n  }\r\n\r\n  function toUintArr(bytes32[] memory _arr) internal pure returns (uint[] memory _conv) {\r\n    assembly { _conv := _arr }\r\n  }\r\n}\r\n\r\nlibrary DutchCrowdsaleIdx {\r\n\r\n  using Contract for *;\r\n  using SafeMath for uint;\r\n  using ArrayUtils for bytes32[];\r\n\r\n  bytes32 internal constant EXEC_PERMISSIONS = keccak256('script_exec_permissions');\r\n\r\n  // Returns the storage location of a script execution address's permissions -\r\n  function execPermissions(address _exec) internal pure returns (bytes32)\r\n    { return keccak256(_exec, EXEC_PERMISSIONS); }\r\n\r\n  /// SALE ///\r\n\r\n  // Storage location of crowdsale admin address\r\n  function admin() internal pure returns (bytes32)\r\n    { return keccak256('sale_admin'); }\r\n\r\n  // Whether the crowdsale and token are configured, and the sale is ready to run\r\n  function isConfigured() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_is_configured\"); }\r\n\r\n  // Whether or not the crowdsale is post-purchase\r\n  function isFinished() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_is_completed\"); }\r\n\r\n  // Whether the unsold tokens will be burnt on finalization, or be sent to the team wallet\r\n  function burnExcess() internal pure returns (bytes32)\r\n    { return keccak256(\"burn_excess_unsold\"); }\r\n\r\n  // Storage location of the crowdsale's start time\r\n  function startTime() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_start_time\"); }\r\n\r\n  // Storage location of the amount of time the crowdsale will take, accounting for all tiers\r\n  function totalDuration() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_total_duration\"); }\r\n\r\n  // Returns the storage location of number of tokens remaining in crowdsale\r\n  function tokensRemaining() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_tokens_remaining\"); }\r\n\r\n  // Returns the storage location of crowdsale's max number of tokens to sell\r\n  function maxSellCap() internal pure returns (bytes32)\r\n    { return keccak256(\"token_sell_cap\"); }\r\n\r\n  // Returns the storage location of crowdsale's starting sale rate\r\n  function startRate() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_start_rate\"); }\r\n\r\n  // Returns the storage location of crowdsale's ending sale rate\r\n  function endRate() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_end_rate\"); }\r\n\r\n  // Storage location of the amount of tokens sold in the crowdsale so far\r\n  function tokensSold() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_tokens_sold\"); }\r\n\r\n  // Storage location of the minimum amount of tokens allowed to be purchased\r\n  function globalMinPurchaseAmt() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_min_purchase_amt\"); }\r\n\r\n  // Stores the amount of unique contributors so far in this crowdsale\r\n  function contributors() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_contributors\"); }\r\n\r\n  // Maps addresses to a boolean indicating whether or not this address has contributed\r\n  function hasContributed(address _purchaser) internal pure returns (bytes32)\r\n    { return keccak256(_purchaser, contributors()); }\r\n\r\n  /// FUNDS ///\r\n\r\n  // Storage location of team funds wallet\r\n  function wallet() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_destination_wallet\"); }\r\n\r\n  // Storage location of amount of wei raised during the crowdsale, total\r\n  function totalWeiRaised() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_tot_wei_raised\"); }\r\n\r\n  /// WHITELIST ///\r\n\r\n  // Whether or not the sale is whitelist-enabled\r\n  function isWhitelisted() internal pure returns (bytes32)\r\n    { return keccak256('sale_is_whitelisted'); }\r\n\r\n  // Stores the sale's whitelist\r\n  function saleWhitelist() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_whitelist\"); }\r\n\r\n  // Stores a spender's maximum number of tokens allowed to be purchased\r\n  function whitelistMaxTok(address _spender) internal pure returns (bytes32)\r\n    { return keccak256(_spender, \"max_tok\", saleWhitelist()); }\r\n\r\n  // Stores a spender's minimum token purchase amount\r\n  function whitelistMinTok(address _spender) internal pure returns (bytes32)\r\n    { return keccak256(_spender, \"min_tok\", saleWhitelist()); }\r\n\r\n  /// TOKEN ///\r\n\r\n  // Storage location for token name\r\n  function tokenName() internal pure returns (bytes32)\r\n    { return keccak256(\"token_name\"); }\r\n\r\n  // Storage location for token ticker symbol\r\n  function tokenSymbol() internal pure returns (bytes32)\r\n    { return keccak256(\"token_symbol\"); }\r\n\r\n  // Storage location for token decimals\r\n  function tokenDecimals() internal pure returns (bytes32)\r\n    { return keccak256(\"token_decimals\"); }\r\n\r\n  // Storage location for token totalSupply\r\n  function tokenTotalSupply() internal pure returns (bytes32)\r\n    { return keccak256(\"token_total_supply\"); }\r\n\r\n  // Storage seed for user balances mapping\r\n  bytes32 internal constant TOKEN_BALANCES = keccak256(\"token_balances\");\r\n\r\n  function balances(address _owner) internal pure returns (bytes32)\r\n    { return keccak256(_owner, TOKEN_BALANCES); }\r\n\r\n  // Storage seed for user allowances mapping\r\n  bytes32 internal constant TOKEN_ALLOWANCES = keccak256(\"token_allowances\");\r\n\r\n  function allowed(address _owner, address _spender) internal pure returns (bytes32)\r\n    { return keccak256(_spender, keccak256(_owner, TOKEN_ALLOWANCES)); }\r\n\r\n  // Storage seed for token 'transfer agent' status for any address\r\n  // Transfer agents can transfer tokens, even if the crowdsale has not yet been finalized\r\n  bytes32 internal constant TOKEN_TRANSFER_AGENTS = keccak256(\"token_transfer_agents\");\r\n\r\n  function transferAgents(address _agent) internal pure returns (bytes32)\r\n    { return keccak256(_agent, TOKEN_TRANSFER_AGENTS); }\r\n\r\n  /// INIT FUNCTION ///\r\n\r\n  /*\r\n  Creates a crowdsale with initial conditions. The admin should now configure the crowdsale's token.\r\n\r\n  @param _wallet: The team funds wallet, where crowdsale purchases are forwarded\r\n  @param _total_supply: The total supply of the token that will exist\r\n  @param _max_amount_to_sell: The maximum number of tokens that will be sold during the sale\r\n  @param _starting_rate: The price of 1 token (10^decimals) in wei at the start of the sale\r\n  @param _ending_rate: The price of 1 token (10^decimals) in wei at the end of the sale\r\n  @param _duration: The amount of time the sale will be open\r\n  @param _start_time: The time after which purchases will be enabled\r\n  @param _sale_is_whitelisted: Whether the sale will be configured with a whitelist\r\n  @param _admin: The address given permissions to complete configuration of the sale\r\n  @param _burn_excess: Whether the unpurchased tokens in the sale will be burned, or sent to the team wallet\r\n  */\r\n  function init(\r\n    address _wallet, uint _total_supply, uint _max_amount_to_sell, uint _starting_rate,\r\n    uint _ending_rate, uint _duration, uint _start_time, bool _sale_is_whitelisted,\r\n    address _admin, bool _burn_excess\r\n  ) external view {\r\n    // Ensure valid input\r\n    if (\r\n      _wallet == 0\r\n      || _max_amount_to_sell == 0\r\n      || _max_amount_to_sell > _total_supply\r\n      || _starting_rate <= _ending_rate\r\n      || _ending_rate == 0\r\n      || _start_time <= now\r\n      || _duration + _start_time <= _start_time\r\n      || _admin == 0\r\n    ) revert(\"Improper Initialization\");\r\n\r\n    // Begin execution - we are initializing an instance of this application\r\n    Contract.initialize();\r\n\r\n    // Set up STORES action requests -\r\n    Contract.storing();\r\n    // Authorize sender as an executor for this instance -\r\n    Contract.set(execPermissions(msg.sender)).to(true);\r\n    // Store admin address, team wallet, sale duration, and sale start time\r\n    Contract.set(wallet()).to(_wallet);\r\n    Contract.set(admin()).to(_admin);\r\n    Contract.set(totalDuration()).to(_duration);\r\n    Contract.set(startTime()).to(_start_time);\r\n    // Set sale starting and ending rate, and token supply, sell cap, and number remaining\r\n    Contract.set(startRate()).to(_starting_rate);\r\n    Contract.set(endRate()).to(_ending_rate);\r\n    Contract.set(tokenTotalSupply()).to(_total_supply);\r\n    Contract.set(maxSellCap()).to(_max_amount_to_sell);\r\n    Contract.set(tokensRemaining()).to(_max_amount_to_sell);\r\n    // Set sale whitelist status and admin initial balance (difference bw totalSupply and maxSellCap)\r\n    Contract.set(isWhitelisted()).to(_sale_is_whitelisted);\r\n    Contract.set(balances(_admin)).to(_total_supply - _max_amount_to_sell);\r\n    Contract.set(burnExcess()).to(_burn_excess);\r\n\r\n    // Commit state changes to storage -\r\n    Contract.commit();\r\n  }\r\n\r\n  /// CROWDSALE GETTERS ///\r\n\r\n  // Returns the address of the admin of the crowdsale\r\n  function getAdmin(address _storage, bytes32 _exec_id) external view returns (address)\r\n    { return address(GetterInterface(_storage).read(_exec_id, admin())); }\r\n\r\n  /*\r\n  Returns sale information on a crowdsale\r\n\r\n  @param _storage: The address where storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return wei_raised: The amount of wei raised in the crowdsale so far\r\n  @return team_wallet: The address to which funds are forwarded during this crowdsale\r\n  @return minimum_contribution: The minimum amount of tokens that must be purchased\r\n  @return is_initialized: Whether or not the crowdsale has been completely initialized by the admin\r\n  @return is_finalized: Whether or not the crowdsale has been completely finalized by the admin\r\n  */\r\n  function getCrowdsaleInfo(address _storage, bytes32 _exec_id) external view\r\n  returns (uint wei_raised, address team_wallet, uint minimum_contribution, bool is_initialized, bool is_finalized, bool burn_excess) {\r\n    // Set up bytes32 array to store storage seeds\r\n    bytes32[] memory seed_arr = new bytes32[](6);\r\n\r\n    //Assign each location of seed_arr to its respective seed\r\n    seed_arr[0] = totalWeiRaised();\r\n    seed_arr[1] = wallet();\r\n    seed_arr[2] = globalMinPurchaseAmt();\r\n    seed_arr[3] = isConfigured();\r\n    seed_arr[4] = isFinished();\r\n    seed_arr[5] = burnExcess();\r\n\r\n    //Read and return all wei_raised, wallet address, min_contribution, and init/finalization status\r\n    bytes32[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr);\r\n\r\n    // Assign all return values\r\n    wei_raised = uint(values_arr[0]);\r\n    team_wallet = address(values_arr[1]);\r\n    minimum_contribution = uint(values_arr[2]);\r\n    is_initialized = (values_arr[3] != 0 ? true : false);\r\n    is_finalized = (values_arr[4] != 0 ? true : false);\r\n    burn_excess = values_arr[5] != 0 ? true : false;\r\n  }\r\n\r\n  /*\r\n  Returns true if the all tokens have been sold, or if 1 wei is not enough to purchase a token\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return is_crowdsale_full: Whether or not the total number of tokens to sell in the crowdsale has been reached\r\n  @return max_sellable: The total number of tokens that can be sold in the crowdsale\r\n  */\r\n  function isCrowdsaleFull(address _storage, bytes32 _exec_id) external view returns (bool is_crowdsale_full, uint max_sellable) {\r\n    //Set up bytes32 array to store storage seeds\r\n    bytes32[] memory seed_arr = new bytes32[](2);\r\n    seed_arr[0] = tokensRemaining();\r\n    seed_arr[1] = maxSellCap();\r\n\r\n    // Read and return tokens remaining and max token sell cap\r\n    uint[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr).toUintArr();\r\n\r\n    // Assign return values\r\n    is_crowdsale_full = (values_arr[0] == 0 ? true : false);\r\n    max_sellable = values_arr[1];\r\n\r\n    // If there are still tokens remaining, calculate the amount that can be purchased by 1 wei\r\n    seed_arr = new bytes32[](5);\r\n    seed_arr[0] = startTime();\r\n    seed_arr[1] = startRate();\r\n    seed_arr[2] = totalDuration();\r\n    seed_arr[3] = endRate();\r\n    seed_arr[4] = tokenDecimals();\r\n\r\n    uint num_remaining = values_arr[0];\r\n    // Read information from storage\r\n    values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr).toUintArr();\r\n\r\n    uint current_rate;\r\n    (current_rate, ) = getRateAndTimeRemaining(values_arr[0], values_arr[2], values_arr[1], values_arr[3]);\r\n\r\n    // If the current rate and tokens remaining cannot be purchased using 1 wei, return 'true' for is_crowdsale_full\r\n    if (current_rate.mul(num_remaining).div(10 ** values_arr[4]) == 0)\r\n      return (true, max_sellable);\r\n  }\r\n\r\n  // Returns the number of unique contributors to a crowdsale\r\n  function getCrowdsaleUniqueBuyers(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, contributors())); }\r\n\r\n  /*\r\n  Returns the start and end time of the crowdsale\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return start_time: The start time of the crowdsale\r\n  @return end_time: The time at which the crowdsale ends\r\n  */\r\n  function getCrowdsaleStartAndEndTimes(address _storage, bytes32 _exec_id) external view returns (uint start_time, uint end_time) {\r\n    //Set up bytes32 array to store storage seeds\r\n    bytes32[] memory seed_arr = new bytes32[](2);\r\n    seed_arr[0] = startTime();\r\n    seed_arr[1] = totalDuration();\r\n\r\n    // Read and return start time and duration\r\n    uint[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr).toUintArr();\r\n\r\n    // Assign return values\r\n    start_time = values_arr[0];\r\n    end_time = values_arr[1] + start_time;\r\n  }\r\n\r\n  /*\r\n  Returns basic information on the status of the sale\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return start_rate: The price of 1 token (10^decimals) in wei at the start of the sale\r\n  @return end_rate: The price of 1 token (10^decimals) in wei at the end of the sale\r\n  @return current_rate: The price of 1 token (10^decimals) currently\r\n  @return sale_duration: The total duration of the sale\r\n  @return time_remaining: The amount of time remaining in the sale (factors in time till sale starts)\r\n  @return tokens_remaining: The amount of tokens still available to be sold\r\n  @return is_whitelisted: Whether the sale is whitelist-enabled\r\n  */\r\n  function getCrowdsaleStatus(address _storage, bytes32 _exec_id) external view\r\n  returns (uint start_rate, uint end_rate, uint current_rate, uint sale_duration, uint time_remaining, uint tokens_remaining, bool is_whitelisted) {\r\n    //Set up bytes32 array to storage seeds\r\n    bytes32[] memory seed_arr = new bytes32[](6);\r\n\r\n    //Assign seeds to locations of array\r\n    seed_arr[0] = startRate();\r\n    seed_arr[1] = endRate();\r\n    seed_arr[2] = startTime();\r\n    seed_arr[3] = totalDuration();\r\n    seed_arr[4] = tokensRemaining();\r\n    seed_arr[5] = isWhitelisted();\r\n\r\n    //Read and return values\r\n    uint[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr).toUintArr();\r\n\r\n    // Assign return values\r\n    start_rate = values_arr[0];\r\n    end_rate = values_arr[1];\r\n    uint start_time = values_arr[2];\r\n    sale_duration = values_arr[3];\r\n    tokens_remaining = values_arr[4];\r\n    is_whitelisted = values_arr[5] == 0 ? false : true;\r\n\r\n    (current_rate, time_remaining) =\r\n      getRateAndTimeRemaining(start_time, sale_duration, start_rate, end_rate);\r\n  }\r\n\r\n  /*\r\n  Returns the current token sale rate and time remaining\r\n\r\n  @param _start_time: The start time of the crowdsale\r\n  @param _duration: The duration of the crowdsale\r\n  @param _start_rate: The price of 1 token (10^decimals) in wei at the start of the sale\r\n  @param _end_rate: The price of 1 token (10^decimals) in wei at the end of the sale\r\n  @return current_rate: The price of 1 token (10^decimals) currently\r\n  @return time_remaining: The amount of time remaining in the sale (factors in time till sale starts)\r\n  */\r\n  function getRateAndTimeRemaining(uint _start_time, uint _duration, uint _start_rate, uint _end_rate) internal view\r\n  returns (uint current_rate, uint time_remaining)  {\r\n    // If the sale has not started, return start rate and duration plus time till start\r\n    if (now <= _start_time)\r\n      return (_start_rate, (_duration + _start_time - now));\r\n\r\n    uint time_elapsed = now - _start_time;\r\n    // If the sale has ended, return 0 for end rate and time remaining\r\n    if (time_elapsed >= _duration)\r\n      return (0, 0);\r\n\r\n    // Crowdsale is still active -\r\n    time_remaining = _duration - time_elapsed;\r\n    // Calculate current rate, adding decimals for precision -\r\n    time_elapsed *= (10 ** 18);\r\n    current_rate = ((_start_rate - _end_rate) * time_elapsed) / _duration;\r\n    current_rate /= (10 ** 18); // Remove additional precision decimals\r\n    current_rate = _start_rate - current_rate;\r\n  }\r\n\r\n  // Returns the total number of tokens sold during the sale so far\r\n  function getTokensSold(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, tokensSold())); }\r\n\r\n  /*\r\n  Returns whitelist information for a given buyer\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @param _buyer: The address of the user whose whitelist status will be returned\r\n  @return minimum_purchase_amt: The minimum ammount of tokens the buyer must purchase\r\n  @return max_tokens_remaining: The maximum amount of tokens able to be purchased\r\n  */\r\n  function getWhitelistStatus(address _storage, bytes32 _exec_id, address _buyer) external view\r\n  returns (uint minimum_purchase_amt, uint max_tokens_remaining) {\r\n    bytes32[] memory seed_arr = new bytes32[](2);\r\n    seed_arr[0] = whitelistMinTok(_buyer);\r\n    seed_arr[1] = whitelistMaxTok(_buyer);\r\n\r\n    // Read values from storage\r\n    uint[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr).toUintArr();\r\n\r\n    // Assign return values\r\n    minimum_purchase_amt = values_arr[0];\r\n    max_tokens_remaining = values_arr[1];\r\n  }\r\n\r\n  /*\r\n  Returns the list of whitelisted buyers for the crowdsale\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return num_whitelisted: The length of the sale's whitelist\r\n  @return whitelist: The sale's whitelisted addresses\r\n  */\r\n  function getCrowdsaleWhitelist(address _storage, bytes32 _exec_id) external view returns (uint num_whitelisted, address[] whitelist) {\r\n    // Read whitelist length from storage\r\n    num_whitelisted = uint(GetterInterface(_storage).read(_exec_id, saleWhitelist()));\r\n\r\n    if (num_whitelisted == 0)\r\n      return (num_whitelisted, whitelist);\r\n\r\n    // Set up storage seed array for whitelisted addresses\r\n    bytes32[] memory seed_arr = new bytes32[](num_whitelisted);\r\n\r\n    // Assign storage locations of each whitelisted address to array\r\n    for (uint i = 0; i < num_whitelisted; i++)\r\n    \tseed_arr[i] = bytes32(32 * (i + 1) + uint(saleWhitelist()));\r\n\r\n    // Read from storage an assign return value\r\n    whitelist = GetterInterface(_storage).readMulti(_exec_id, seed_arr).toAddressArr();\r\n  }\r\n\r\n  /// TOKEN GETTERS ///\r\n\r\n  // Returns the token balance of an address\r\n  function balanceOf(address _storage, bytes32 _exec_id, address _owner) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, balances(_owner))); }\r\n\r\n  // Returns the amount of tokens a spender may spend on an owner's behalf\r\n  function allowance(address _storage, bytes32 _exec_id, address _owner, address _spender) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, allowed(_owner, _spender))); }\r\n\r\n  // Returns the number of display decimals for a token\r\n  function decimals(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, tokenDecimals())); }\r\n\r\n  // Returns the total token supply\r\n  function totalSupply(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, tokenTotalSupply())); }\r\n\r\n  // Returns the token's name\r\n  function name(address _storage, bytes32 _exec_id) external view returns (bytes32)\r\n    { return GetterInterface(_storage).read(_exec_id, tokenName()); }\r\n\r\n  // Returns token's symbol\r\n  function symbol(address _storage, bytes32 _exec_id) external view returns (bytes32)\r\n    { return GetterInterface(_storage).read(_exec_id, tokenSymbol()); }\r\n\r\n  /*\r\n  Returns general information on a token - name, symbol, decimals, and total supply\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return token_name: The name of the token\r\n  @return token_symbol: The token ticker symbol\r\n  @return token_decimals: The display decimals for the token\r\n  @return total_supply: The total supply of the token\r\n  */\r\n  function getTokenInfo(address _storage, bytes32 _exec_id) external view\r\n  returns (bytes32 token_name, bytes32 token_symbol, uint token_decimals, uint total_supply) {\r\n    //Set up bytes32 array to hold storage seeds\r\n    bytes32[] memory seed_arr = new bytes32[](4);\r\n\r\n    //Assign locations of array to respective seeds\r\n    seed_arr[0] = tokenName();\r\n    seed_arr[1] = tokenSymbol();\r\n    seed_arr[2] = tokenDecimals();\r\n    seed_arr[3] = tokenTotalSupply();\r\n\r\n    //Read and return values from storage\r\n    bytes32[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr);\r\n\r\n    //Assign values to return params\r\n    token_name = values_arr[0];\r\n    token_symbol = values_arr[1];\r\n    token_decimals = uint(values_arr[2]);\r\n    total_supply = uint(values_arr[3]);\r\n  }\r\n\r\n  // Returns whether or not an address is a transfer agent, meaning they can transfer tokens before the crowdsale is finished\r\n  function getTransferAgentStatus(address _storage, bytes32 _exec_id, address _agent) external view returns (bool)\r\n    { return GetterInterface(_storage).read(_exec_id, transferAgents(_agent)) != 0 ? true : false; }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getWhitelistStatus\",\"outputs\":[{\"name\":\"minimum_purchase_amt\",\"type\":\"uint256\"},{\"name\":\"max_tokens_remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleStartAndEndTimes\",\"outputs\":[{\"name\":\"start_time\",\"type\":\"uint256\"},{\"name\":\"end_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"getTransferAgentStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"name\":\"is_crowdsale_full\",\"type\":\"bool\"},{\"name\":\"max_sellable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleUniqueBuyers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleStatus\",\"outputs\":[{\"name\":\"start_rate\",\"type\":\"uint256\"},{\"name\":\"end_rate\",\"type\":\"uint256\"},{\"name\":\"current_rate\",\"type\":\"uint256\"},{\"name\":\"sale_duration\",\"type\":\"uint256\"},{\"name\":\"time_remaining\",\"type\":\"uint256\"},{\"name\":\"tokens_remaining\",\"type\":\"uint256\"},{\"name\":\"is_whitelisted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleWhitelist\",\"outputs\":[{\"name\":\"num_whitelisted\",\"type\":\"uint256\"},{\"name\":\"whitelist\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"name\":\"token_name\",\"type\":\"bytes32\"},{\"name\":\"token_symbol\",\"type\":\"bytes32\"},{\"name\":\"token_decimals\",\"type\":\"uint256\"},{\"name\":\"total_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_total_supply\",\"type\":\"uint256\"},{\"name\":\"_max_amount_to_sell\",\"type\":\"uint256\"},{\"name\":\"_starting_rate\",\"type\":\"uint256\"},{\"name\":\"_ending_rate\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_start_time\",\"type\":\"uint256\"},{\"name\":\"_sale_is_whitelisted\",\"type\":\"bool\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_burn_excess\",\"type\":\"bool\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleInfo\",\"outputs\":[{\"name\":\"wei_raised\",\"type\":\"uint256\"},{\"name\":\"team_wallet\",\"type\":\"address\"},{\"name\":\"minimum_contribution\",\"type\":\"uint256\"},{\"name\":\"is_initialized\",\"type\":\"bool\"},{\"name\":\"is_finalized\",\"type\":\"bool\"},{\"name\":\"burn_excess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DutchCrowdsaleIdx","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0993e2a4faea5c34cc8049a3c47b3ece61666a4ab9b7e1e42a2ac267516c7339"}]}