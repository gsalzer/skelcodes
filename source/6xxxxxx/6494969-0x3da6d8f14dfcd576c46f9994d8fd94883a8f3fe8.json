{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n *  https://Smart-Pyramid.io\r\n *\r\n * Smart-Pyramid Contract\r\n *  - GAIN 1.23% PER 24 HOURS (every 5900 blocks)\r\n *  - Minimal contribution 0.01 eth\r\n *  - Currency and payment - ETH\r\n *  - Contribution allocation schemes:\r\n *    -- 84% payments\r\n *    -- 16% Marketing + Operating Expenses\r\n *\r\n *\r\n * You get MORE PROFIT if you withdraw later !\r\n * Increase of the total rate of return by 0.01% every day before the payment.\r\n * The increase in profitability affects all previous days!\r\n *  After the dividend is paid, the rate of return is returned to 1.23 % per day\r\n *\r\n *           For example: if the Deposit is 10 ETH\r\n * \r\n *                days      |   %    |   profit\r\n *          --------------------------------------\r\n *            1 (>24 hours) | 1.24 % | 0.124 ETH\r\n *              10          | 1.33 % | 1.330 ETH\r\n *              30          | 1.53 % | 4.590 ETH\r\n *              50          | 1.73 % | 8.650 ETH\r\n *              100         | 2.23 % | 22.30 ETH\r\n *\r\n *\r\n * How to use:\r\n *  1. Send any amount of ether to make an investment\r\n *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\r\n *  OR\r\n *  2b. Send more ether to reinvest AND get your profit at the same time\r\n *\r\n * RECOMMENDED GAS LIMIT: 200000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n *\r\n *\r\n * Investors Contest rules\r\n *\r\n * Investor contest lasts a whole week\r\n * The results of the competition are confirmed every MON not earlier than 13:00 MSK (10:00 UTC)\r\n * According to the results, will be determined 3 winners, who during the week invested the maximum amounts\r\n * in one payment.\r\n * If two investors invest the same amount - the highest place in the competition is occupied by the one whose operation\r\n *  was before\r\n *\r\n * Prizes:\r\n * 1st place: 2 ETH\r\n * 2nd place: 1 ETH\r\n * 3rd place: 0.5 ETH\r\n *\r\n * On the offensive (10:00 UTC) on Monday, it is necessary to initiate the summing up of the competition.\r\n * Until the results are announced - the competition is still on.\r\n * To sum up the results, you need to call the PayDay function\r\n *\r\n *\r\n * Contract reviewed and approved by experts!\r\n *\r\n */\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract InvestorsStorage {\r\n    address private owner;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    struct Investor {\r\n        uint deposit;\r\n        uint checkpoint;\r\n        address referrer;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function updateInfo(address _address, uint _value) external onlyOwner {\r\n        investors[_address].deposit += _value;\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function updateCheckpoint(address _address) external onlyOwner {\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function addReferrer(address _referral, address _referrer) external onlyOwner {\r\n        investors[_referral].referrer = _referrer;\r\n    }\r\n\r\n    function getInterest(address _address) external view returns(uint) {\r\n        if (investors[_address].deposit > 0) {\r\n            return(123 + ((block.timestamp - investors[_address].checkpoint) / 1 days));\r\n        }\r\n    }\r\n\r\n    function d(address _address) external view returns(uint) {\r\n        return investors[_address].deposit;\r\n    }\r\n\r\n    function c(address _address) external view returns(uint) {\r\n        return investors[_address].checkpoint;\r\n    }\r\n\r\n    function r(address _address) external view returns(address) {\r\n        return investors[_address].referrer;\r\n    }\r\n}\r\n\r\ncontract SmartPyramid {\r\n    using SafeMath for uint;\r\n\r\n    address admin;\r\n    uint waveStartUp;\r\n    uint nextPayDay;\r\n\r\n    mapping (uint => Leader) top;\r\n\r\n    event LogInvestment(address indexed _addr, uint _value);\r\n    event LogIncome(address indexed _addr, uint _value, string indexed _type);\r\n    event LogReferralInvestment(address indexed _referrer, address indexed _referral, uint _value);\r\n    event LogGift(address _firstAddr, uint _firstDep, address _secondAddr, uint _secondDep, address _thirdAddr, uint _thirdDep);\r\n    event LogNewWave(uint _waveStartUp);\r\n\r\n    InvestorsStorage private x;\r\n\r\n    modifier notOnPause() {\r\n        require(waveStartUp <= block.timestamp);\r\n        _;\r\n    }\r\n\r\n    struct Leader {\r\n        address addr;\r\n        uint deposit;\r\n    }\r\n\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedReferrer) {\r\n        assembly {\r\n            parsedReferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedReferrer;\r\n    }\r\n\r\n    function addReferrer(uint _value) internal {\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\n        if (_referrer != msg.sender) {\r\n            x.addReferrer(msg.sender, _referrer);\r\n            x.r(msg.sender).transfer(_value / 20);\r\n            emit LogReferralInvestment(_referrer, msg.sender, _value);\r\n            emit LogIncome(_referrer, _value / 20, \"referral\");\r\n        }\r\n    }\r\n\r\n    constructor(address _admin) public {\r\n        admin = _admin;\r\n        x = new InvestorsStorage();\r\n    }\r\n\r\n    function getInfo(address _address) external view returns(uint deposit, uint amountToWithdraw) {\r\n        deposit = x.d(_address);\r\n        if (block.timestamp >= x.c(_address) + 10 minutes) {\r\n            amountToWithdraw = (x.d(_address).mul(x.getInterest(_address)).div(10000)).mul(block.timestamp.sub(x.c(_address))).div(1 days);\r\n        } else {\r\n            amountToWithdraw = 0;\r\n        }\r\n    }\r\n\r\n    function getTop() external view returns(address, uint, address, uint, address, uint) {\r\n        return(top[1].addr, top[1].deposit, top[2].addr, top[2].deposit, top[3].addr, top[3].deposit);\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value == 0) {\r\n            withdraw();\r\n        } else {\r\n            invest();\r\n        }\r\n    }\r\n\r\n    function invest() notOnPause public payable {\r\n\r\n        admin.transfer(msg.value * 4 / 25);\r\n\r\n        if (x.d(msg.sender) > 0) {\r\n            withdraw();\r\n        }\r\n\r\n        x.updateInfo(msg.sender, msg.value);\r\n\r\n        if (msg.value > top[3].deposit) {\r\n            toTheTop();\r\n        }\r\n\r\n        if (x.r(msg.sender) != 0x0) {\r\n            x.r(msg.sender).transfer(msg.value / 20);\r\n            emit LogReferralInvestment(x.r(msg.sender), msg.sender, msg.value);\r\n            emit LogIncome(x.r(msg.sender), msg.value / 20, \"referral\");\r\n        } else if (msg.data.length == 20) {\r\n            addReferrer(msg.value);\r\n        }\r\n\r\n        emit LogInvestment(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    function withdraw() notOnPause public {\r\n\r\n        if (block.timestamp >= x.c(msg.sender) + 10 minutes) {\r\n            uint _payout = (x.d(msg.sender).mul(x.getInterest(msg.sender)).div(10000)).mul(block.timestamp.sub(x.c(msg.sender))).div(1 days);\r\n            x.updateCheckpoint(msg.sender);\r\n        }\r\n\r\n        if (_payout > 0) {\r\n\r\n            if (_payout > address(this).balance) {\r\n                nextWave();\r\n                return;\r\n            }\r\n\r\n            msg.sender.transfer(_payout);\r\n            emit LogIncome(msg.sender, _payout, \"withdrawn\");\r\n        }\r\n    }\r\n\r\n    function toTheTop() internal {\r\n        if (msg.value <= top[2].deposit) {\r\n            top[3] = Leader(msg.sender, msg.value);\r\n        } else {\r\n            if (msg.value <= top[1].deposit) {\r\n                top[3] = top[2];\r\n                top[2] = Leader(msg.sender, msg.value);\r\n            } else {\r\n                top[3] = top[2];\r\n                top[2] = top[1];\r\n                top[1] = Leader(msg.sender, msg.value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function payDay() external {\r\n        require(block.timestamp >= nextPayDay);\r\n        nextPayDay = block.timestamp.sub((block.timestamp - 1538388000).mod(7 days)).add(7 days);\r\n\r\n        emit LogGift(top[1].addr, top[1].deposit, top[2].addr, top[2].deposit, top[3].addr, top[3].deposit);\r\n\r\n        for (uint i = 0; i <= 2; i++) {\r\n            if (top[i+1].addr != 0x0) {\r\n                top[i+1].addr.transfer(2 ether / 2 ** i);\r\n                top[i+1] = Leader(0x0, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function nextWave() private {\r\n        for (uint i = 0; i <= 2; i++) {\r\n            top[i+1] = Leader(0x0, 0);\r\n        }\r\n        x = new InvestorsStorage();\r\n        waveStartUp = block.timestamp + 7 days;\r\n        emit LogNewWave(waveStartUp);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payDay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_type\",\"type\":\"string\"}],\"name\":\"LogIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogReferralInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_firstAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_firstDep\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_secondAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_secondDep\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_thirdAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_thirdDep\",\"type\":\"uint256\"}],\"name\":\"LogGift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_waveStartUp\",\"type\":\"uint256\"}],\"name\":\"LogNewWave\",\"type\":\"event\"}]","ContractName":"SmartPyramid","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007bc852706e5aef47a9805e050512cfd4c991f055","Library":"","SwarmSource":"bzzr://0dc8c0a2dc96ed5967d5e4796867fd53f82e2caf803cf709047e845f8fac4178"}]}