{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: contracts/Bankroll.sol\r\n\r\ninterface Bankroll {\r\n\r\n    //Customer functions\r\n\r\n    /// @dev Stores ETH funds for customer\r\n    function credit(address _customerAddress, uint256 amount) external returns (uint256);\r\n\r\n    /// @dev Debits address by an amount\r\n    function debit(address _customerAddress, uint256 amount) external returns (uint256);\r\n\r\n    /// @dev Withraws balance for address; returns amount sent\r\n    function withdraw(address _customerAddress) external returns (uint256);\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) external view returns (uint256);\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) external view returns (uint256[8]);\r\n\r\n\r\n    // System functions\r\n\r\n    // @dev Deposit funds\r\n    function deposit() external payable;\r\n\r\n    // @dev Deposit on behalf of an address; it is not a credit\r\n    function depositBy(address _customerAddress) external payable;\r\n\r\n    // @dev Distribute house profit\r\n    function houseProfit(uint256 amount)  external;\r\n\r\n\r\n    /// @dev Get all the ETH stored in contract minus credits to customers\r\n    function netEthereumBalance() external view returns (uint256);\r\n\r\n\r\n    /// @dev Get all the ETH stored in contract\r\n    function totalEthereumBalance() external view returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/SessionQueue.sol\r\n\r\n/// A FIFO queue for storing addresses\r\ncontract SessionQueue {\r\n\r\n    mapping(uint256 => address) private queue;\r\n    uint256 private first = 1;\r\n    uint256 private last = 0;\r\n\r\n    /// @dev Push into queue\r\n    function enqueue(address data) internal {\r\n        last += 1;\r\n        queue[last] = data;\r\n    }\r\n\r\n    /// @dev Returns true if the queue has elements in it\r\n    function available() internal view returns (bool) {\r\n        return last >= first;\r\n    }\r\n\r\n    /// @dev Returns the size of the queue\r\n    function depth() internal view returns (uint256) {\r\n        return last - first + 1;\r\n    }\r\n\r\n    /// @dev Pops from the head of the queue\r\n    function dequeue() internal returns (address data) {\r\n        require(last >= first);\r\n        // non-empty queue\r\n\r\n        data = queue[first];\r\n\r\n        delete queue[first];\r\n        first += 1;\r\n    }\r\n\r\n    /// @dev Returns the head of the queue without a pop\r\n    function peek() internal view returns (address data) {\r\n        require(last >= first);\r\n        // non-empty queue\r\n\r\n        data = queue[first];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable {\r\n  mapping(address => bool) public whitelist;\r\n\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    require(whitelist[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    if (!whitelist[addr]) {\r\n      whitelist[addr] = true;\r\n      emit WhitelistedAddressAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (addAddressToWhitelist(addrs[i])) {\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    if (whitelist[addr]) {\r\n      whitelist[addr] = false;\r\n      emit WhitelistedAddressRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (removeAddressFromWhitelist(addrs[i])) {\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Dice.sol\r\n\r\n/*\r\n * Visit: https://p4rty.io\r\n * Discord: https://discord.gg/7y3DHYF\r\n * P4RTY DICE\r\n * Provably Fair Variable Chance DICE game\r\n * Roll Under  2 to 99\r\n * Play with ETH and play using previous winnings; withdraw anytime\r\n * Upgradable and connects to P4RTY Bankroll\r\n */\r\n\r\n\r\n\r\n\r\n\r\ncontract Dice is Whitelist, SessionQueue {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /*\r\n    * checks player profit, bet size and player number is within range\r\n   */\r\n    modifier betIsValid(uint _betSize, uint _playerNumber) {\r\n        bool result = ((((_betSize * (100 - _playerNumber.sub(1))) / (_playerNumber.sub(1)) + _betSize)) * houseEdge / houseEdgeDivisor) - _betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber;\r\n        require(!result);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * checks game is currently active\r\n    */\r\n    modifier gameIsActive {\r\n        require(!gamePaused);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * Events\r\n    */\r\n\r\n    event  onSessionOpen(\r\n        uint indexed id,\r\n        uint block,\r\n        uint futureBlock,\r\n        address player,\r\n        uint wager,\r\n        uint rollUnder,\r\n        uint profit\r\n    );\r\n\r\n    event onSessionClose(\r\n        uint indexed id,\r\n        uint block,\r\n        uint futureBlock,\r\n        uint futureHash,\r\n        uint seed,\r\n        address player,\r\n        uint wager,\r\n        uint rollUnder,\r\n        uint dieRoll,\r\n        uint payout,\r\n        bool timeout\r\n    );\r\n\r\n    event onCredit(address player, uint amount);\r\n    event onWithdraw(address player, uint amount);\r\n\r\n    /**\r\n     *\r\n     * Structs\r\n    */\r\n\r\n    struct Session {\r\n        uint id;\r\n        uint block;\r\n        uint futureBlock;\r\n        uint futureHash;\r\n        address player;\r\n        uint wager;\r\n        uint dieRoll;\r\n        uint seed;\r\n        uint rollUnder;\r\n        uint profit;\r\n        uint payout;\r\n        bool complete;\r\n        bool timeout;\r\n\r\n    }\r\n\r\n    struct Stats {\r\n        uint rolls;\r\n        uint wagered;\r\n        uint profit;\r\n        uint wins;\r\n        uint loss;\r\n    }\r\n\r\n    /*\r\n     * game vars\r\n    */\r\n    uint constant public maxProfitDivisor = 1000000;\r\n    uint constant public houseEdgeDivisor = 1000;\r\n    uint constant public maxNumber = 99;\r\n    uint constant public minNumber = 2;\r\n    uint constant public futureDelta = 2;\r\n    uint internal  sessionProcessingCap = 3;\r\n    bool public gamePaused;\r\n    bool public payoutsPaused;\r\n    uint public houseEdge;\r\n    uint public maxProfit;\r\n    uint public maxProfitAsPercentOfHouse;\r\n    uint maxPendingPayouts;\r\n    uint public minBet;\r\n    uint public totalSessions;\r\n    uint public totalBets;\r\n    uint public totalWon;\r\n    uint public totalWagered;\r\n    uint private seed;\r\n\r\n    /*\r\n    * player vars\r\n   */\r\n\r\n    mapping(address => Session) sessions;\r\n    mapping(address => Stats) stats;\r\n\r\n    mapping(bytes32 => bytes32) playerBetId;\r\n    mapping(bytes32 => uint) playerBetValue;\r\n    mapping(bytes32 => uint) playerTempBetValue;\r\n    mapping(bytes32 => uint) playerDieResult;\r\n    mapping(bytes32 => uint) playerNumber;\r\n    mapping(address => uint) playerPendingWithdrawals;\r\n    mapping(bytes32 => uint) playerProfit;\r\n    mapping(bytes32 => uint) playerTempReward;\r\n\r\n    //The House\r\n    Bankroll public bankroll;\r\n\r\n\r\n\r\n    constructor() public {\r\n        /* init 990 = 99% (1% houseEdge)*/\r\n        ownerSetHouseEdge(990);\r\n        /* init 10,000 = 1%  */\r\n        ownerSetMaxProfitAsPercentOfHouse(10000);\r\n        /* init min bet (0.01 ether) */\r\n        ownerSetMinBet(10000000000000000);\r\n    }\r\n\r\n    /**\r\n     *\r\n     *Update BankRoll address\r\n     */\r\n    function updateBankrollAddress(address bankrollAddress) onlyOwner public {\r\n        bankroll = Bankroll(bankrollAddress);\r\n        setMaxProfit();\r\n    }\r\n\r\n    function contractBalance() internal view returns (uint256){\r\n        return bankroll.netEthereumBalance();\r\n    }\r\n\r\n    /**\r\n    *\r\n    *Play with ETH\r\n    */\r\n\r\n    function play(uint rollUnder) payable public {\r\n\r\n        //Fund the bankroll; a player wins back profit on a wager (not a credit, just deposit)\r\n        bankroll.depositBy.value(msg.value)(msg.sender);\r\n\r\n        //Roll\r\n        rollDice(rollUnder, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n    *\r\n    *Play with balance\r\n    */\r\n\r\n    function playWithVault(uint rollUnder, uint wager) public {\r\n        //A player can play with a previous win which is store in their vault first\r\n        require(bankroll.balanceOf(msg.sender) >= wager);\r\n\r\n        //Reduce credit\r\n        bankroll.debit(msg.sender, wager);\r\n\r\n        //Roll\r\n        rollDice(rollUnder, wager);\r\n    }\r\n\r\n\r\n    /*\r\n    * private\r\n    * player submit bet\r\n    * only if game is active & bet is valid\r\n   */\r\n    function rollDice(uint rollUnder, uint wager) internal gameIsActive betIsValid(wager, rollUnder)\r\n    {\r\n\r\n        //Complete previous sessions\r\n        processSessions();\r\n\r\n        Session memory session = sessions[msg.sender];\r\n\r\n        //Strictly cannot wager twice in the same block\r\n        require(block.number != session.block, \"Only one roll can be played at a time\");\r\n\r\n        // If there exists a roll, it must be completed\r\n        if (session.block != 0 && !session.complete) {\r\n            require(completeSession(msg.sender), \"Only one roll can be played at a time\");\r\n        }\r\n\r\n        //Increment Sessions\r\n        totalSessions += 1;\r\n\r\n        //Invalidate passive session components so it is processed\r\n        session.complete = false;\r\n        session.timeout = false;\r\n        session.payout = 0;\r\n\r\n        session.block = block.number;\r\n        session.futureBlock = block.number + futureDelta;\r\n        session.player = msg.sender;\r\n        session.rollUnder = rollUnder;\r\n        session.wager = wager;\r\n\r\n        session.profit = profit(rollUnder, wager);\r\n\r\n        session.id = generateSessionId(session);\r\n\r\n        //Save new session\r\n        sessions[msg.sender] = session;\r\n\r\n        /* safely increase maxPendingPayouts liability - calc all pending payouts under assumption they win */\r\n        maxPendingPayouts = maxPendingPayouts.add(session.profit);\r\n\r\n        /* check contract can payout on win\r\n\r\n        */\r\n        require(maxPendingPayouts < contractBalance(), \"Reached maximum wagers supported\");\r\n\r\n        /* total number of bets */\r\n        totalBets += 1;\r\n\r\n        /* total wagered */\r\n        totalWagered += session.wager;\r\n\r\n\r\n        /* Queue session, can be processed by another player */\r\n        queueSession(session);\r\n\r\n        /* Stats */\r\n        stats[session.player].rolls += 1;\r\n        stats[session.player].wagered += session.wager;\r\n\r\n        /* provides accurate numbers for listeners */\r\n        emit  onSessionOpen(session.id, session.block, session.futureBlock, session.player, session.wager, session.rollUnder, session.profit);\r\n    }\r\n\r\n    /// @dev Queue up dice session so that it can be processed by others\r\n    function queueSession(Session session) internal {\r\n        enqueue(session.player);\r\n\r\n    }\r\n\r\n    /// @dev Process sessions in bulk\r\n    function processSessions() internal {\r\n        uint256 count = 0;\r\n        address session;\r\n\r\n        while (available() && count < sessionProcessingCap) {\r\n\r\n            //If the session isn't able to be completed because of the block none added later will be\r\n            session = peek();\r\n\r\n            if (sessions[session].complete || completeSession(session)) {\r\n                dequeue();\r\n                count++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n        @dev Proceses the session if possible by the given player\r\n    */\r\n    function closeSession() public {\r\n\r\n        Session memory session = sessions[msg.sender];\r\n\r\n        // If there exists a roll, it must be completed\r\n        if (session.block != 0 && !session.complete) {\r\n            require(completeSession(msg.sender), \"Only one roll can be played at a time\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n    *\r\n    * Random num\r\n    */\r\n    function random(Session session) private returns (uint256, uint256, uint256){\r\n        uint blockHash = uint256(blockhash(session.futureBlock));\r\n        seed = uint256(keccak256(abi.encodePacked(seed, blockHash, session.id)));\r\n        return (seed, blockHash, seed % maxNumber);\r\n    }\r\n\r\n    function profit(uint rollUnder, uint wager) public view returns (uint) {\r\n\r\n        return ((((wager * (100 - (rollUnder.sub(1)))) / (rollUnder.sub(1)) + wager)) * houseEdge / houseEdgeDivisor) - wager;\r\n    }\r\n\r\n    /**\r\n    *\r\n    *Generates a unique sessionId and adds entropy to the overall random calc\r\n    */\r\n    function generateSessionId(Session session) private view returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(seed, blockhash(block.number - 1), totalSessions, session.player, session.wager, session.rollUnder, session.profit)));\r\n    }\r\n\r\n\r\n    /*\r\n     * Process roll\r\n     */\r\n    function completeSession(address _customer) private returns (bool)\r\n    {\r\n\r\n        Session memory session = sessions[_customer];\r\n\r\n\r\n        //A future block is not available until one after\r\n        if (!(block.number > session.futureBlock)) {\r\n            return false;\r\n        }\r\n\r\n\r\n        //If player does not claim it is a forefeit\r\n        //The roll is automatically 100 which is invalid\r\n        if (block.number - session.futureBlock > 256) {\r\n            session.timeout = true;\r\n            session.dieRoll = 100;\r\n        } else {\r\n            (session.seed, session.futureHash, session.dieRoll) = random(session);\r\n            session.timeout = false;\r\n        }\r\n\r\n        //Decrement maxPendingPayouts\r\n        maxPendingPayouts = maxPendingPayouts.sub(session.profit);\r\n\r\n\r\n        /*\r\n        * pay winner\r\n        * update contract balance to calculate new max bet\r\n        * send reward\r\n        * if send of reward fails save value to playerPendingWithdrawals\r\n        */\r\n        if (session.dieRoll < session.rollUnder) {\r\n\r\n            /* update total wei won */\r\n            totalWon = totalWon.add(session.profit);\r\n\r\n            /* safely calculate payout via profit plus original wager */\r\n            session.payout = session.profit.add(session.wager);\r\n\r\n            /* Stats */\r\n            stats[session.player].profit += session.profit;\r\n            stats[session.player].wins += 1;\r\n\r\n\r\n            /*\r\n            * Award Player\r\n            */\r\n\r\n            bankroll.credit(session.player, session.payout);\r\n\r\n        }\r\n\r\n        /*\r\n        * no win\r\n        * update contract balance to calculate new max bet\r\n        * session.dieRoll >= session.rollUnder || session.timeout (but basically anything not winning\r\n        */\r\n        else {\r\n\r\n            /*\r\n            * ON LOSS\r\n            * No need to debit the player; wager is paid to contract, not as a credit\r\n            * Instruct bankroll to distribute profit to the house in realtime\r\n            */\r\n\r\n            bankroll.houseProfit(session.wager);\r\n\r\n            /* Stats */\r\n            stats[session.player].loss += 1;\r\n\r\n        }\r\n\r\n        /* update maximum profit */\r\n        setMaxProfit();\r\n\r\n        //Close the session\r\n        closeSession(session);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    /// @dev Closes a session and fires event for audit\r\n    function closeSession(Session session) internal {\r\n\r\n        session.complete = true;\r\n\r\n        //Save the last session info\r\n        sessions[session.player] = session;\r\n        emit onSessionClose(session.id, session.block, session.futureBlock, session.futureHash, session.seed, session.player, session.wager, session.rollUnder, session.dieRoll, session.payout, session.timeout);\r\n\r\n    }\r\n\r\n    /// @dev Returns true if there is an active session\r\n\r\n    function isMining() public view returns (bool) {\r\n        Session memory session = sessions[msg.sender];\r\n\r\n        //A future block is not available until one after\r\n        return session.block != 0 && !session.complete && block.number <= session.futureBlock;\r\n    }\r\n\r\n    /*\r\n    * public function\r\n    * Withdraw funds for current player\r\n    */\r\n    function withdraw() public\r\n    {\r\n\r\n        //OK to fail if a roll is happening; save gas\r\n        closeSession();\r\n        bankroll.withdraw(msg.sender);\r\n    }\r\n\r\n    /*\r\n    * Return the balance of a given player\r\n    *\r\n    */\r\n    function balanceOf(address player) public view returns (uint) {\r\n        return bankroll.balanceOf(player);\r\n    }\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address player) public view returns (uint256[5]){\r\n        Stats memory s = stats[player];\r\n        uint256[5] memory statArray = [s.rolls, s.wagered, s.profit, s.wins, s.loss];\r\n        return statArray;\r\n    }\r\n\r\n    /// @dev Returns the last roll of a complete session for an address\r\n    function lastSession(address player) public view returns (address, uint[7], bytes32[3], bool[2]) {\r\n        Session memory s = sessions[player];\r\n        return (s.player, [s.block, s.futureBlock, s.wager, s.dieRoll, s.rollUnder, s.profit, s.payout], [bytes32(s.id), bytes32(s.futureHash), bytes32(s.seed)], [s.complete, s.timeout]);\r\n    }\r\n\r\n    /*\r\n    * internal function\r\n    * sets max profit\r\n    */\r\n    function setMaxProfit() internal {\r\n        if (address(bankroll) != address(0)) {\r\n            maxProfit = (contractBalance() * maxProfitAsPercentOfHouse) / maxProfitDivisor;\r\n        }\r\n    }\r\n\r\n\r\n    /* only owner address can set houseEdge */\r\n    function ownerSetHouseEdge(uint newHouseEdge) public\r\n    onlyOwner\r\n    {\r\n        houseEdge = newHouseEdge;\r\n    }\r\n\r\n    /* only owner address can set maxProfitAsPercentOfHouse */\r\n    function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\r\n    onlyOwner\r\n    {\r\n        /* restrict each bet to a maximum profit of 1% contractBalance */\r\n        require(newMaxProfitAsPercent <= 10000, \"Maximum bet exceeded\");\r\n        maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\r\n        setMaxProfit();\r\n    }\r\n\r\n    /* only owner address can set minBet */\r\n    function ownerSetMinBet(uint newMinimumBet) public\r\n    onlyOwner\r\n    {\r\n        minBet = newMinimumBet;\r\n    }\r\n\r\n    /// @dev Set the maximum amount of sessions to be processed\r\n    function ownerSetProcessingCap(uint cap) public onlyOwner {\r\n        sessionProcessingCap = cap;\r\n    }\r\n\r\n    /* only owner address can set emergency pause #1 */\r\n    function ownerPauseGame(bool newStatus) public\r\n    onlyOwner\r\n    {\r\n        gamePaused = newStatus;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"closeSession\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bankrollAddress\",\"type\":\"address\"}],\"name\":\"updateBankrollAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitAsPercentOfHouse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseEdge\",\"type\":\"uint256\"}],\"name\":\"ownerSetHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutsPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"ownerSetProcessingCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"lastSession\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256[7]\"},{\"name\":\"\",\"type\":\"bytes32[3]\"},{\"name\":\"\",\"type\":\"bool[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfitAsPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitAsPercentOfHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rollUnder\",\"type\":\"uint256\"}],\"name\":\"play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"name\":\"wager\",\"type\":\"uint256\"}],\"name\":\"profit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSessions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"name\":\"wager\",\"type\":\"uint256\"}],\"name\":\"playWithVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"futureDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"futureBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wager\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"onSessionOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"futureBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"futureHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wager\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dieRoll\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"bool\"}],\"name\":\"onSessionClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onCredit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Dice","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://23cebfcc984e68b99b2061c07b2d626a7aba7234c4f291f251ab805e923d7642"}]}