{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n* Zethell.\r\n*\r\n* Written June 2018 for Zethr (https://www.zethr.io) by Norsefire.\r\n* Special thanks to oguzhanox and Etherguy for assistance with debugging.\r\n*\r\n*/\r\n\r\ncontract ZTHReceivingContract {\r\n    function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\r\n}\r\n\r\ncontract ZTHInterface {\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n    function approve(address spender, uint tokens) public returns (bool);\r\n}\r\n\r\ncontract Zethell is ZTHReceivingContract {\r\n    using SafeMath for uint;\r\n\r\n    address private owner;\r\n    address private bankroll;\r\n\r\n    // How much of the current token balance is reserved as the house take?\r\n    uint    private houseTake;\r\n    \r\n    // How many tokens are currently being played for? (Remember, this is winner takes all)\r\n    uint    public tokensInPlay;\r\n    \r\n    // The token balance of the entire contract.\r\n    uint    public contractBalance;\r\n    \r\n    // Which address is currently winning?\r\n    address public currentWinner;\r\n\r\n    // What time did the most recent clock reset happen?\r\n    uint    public gameStarted;\r\n    \r\n    // What time will the game end if the clock isn't reset?\r\n    uint    public gameEnds;\r\n    \r\n    // Is betting allowed? (Administrative function, in the event of unforeseen bugs)\r\n    bool    public gameActive;\r\n\r\n    address private ZTHTKNADDR;\r\n    address private ZTHBANKROLL;\r\n    ZTHInterface private     ZTHTKN;\r\n\r\n    mapping (uint => bool) validTokenBet;\r\n    mapping (uint => uint) tokenToTimer;\r\n\r\n    // Fire an event whenever the clock runs out and a winner is determined.\r\n    event GameEnded(\r\n        address winner,\r\n        uint tokensWon,\r\n        uint timeOfWin\r\n    );\r\n\r\n    // Might as well notify everyone when the house takes its cut out.\r\n    event HouseRetrievedTake(\r\n        uint timeTaken,\r\n        uint tokensWithdrawn\r\n    );\r\n\r\n    // Fire an event whenever someone places a bet.\r\n    event TokensWagered(\r\n        address _wagerer,\r\n        uint _wagered,\r\n        uint _newExpiry\r\n    );\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBankroll {\r\n        require(msg.sender == bankroll);\r\n        _; \r\n    }\r\n\r\n    modifier onlyOwnerOrBankroll {\r\n        require(msg.sender == owner || msg.sender == bankroll);\r\n        _;\r\n    }\r\n\r\n    constructor(address ZethrAddress, address BankrollAddress) public {\r\n\r\n        // Set Zethr & Bankroll address from constructor params\r\n        ZTHTKNADDR = ZethrAddress;\r\n        ZTHBANKROLL = BankrollAddress;\r\n\r\n        // Set starting variables\r\n        owner         = msg.sender;\r\n        bankroll      = ZTHBANKROLL;\r\n        currentWinner = ZTHBANKROLL;\r\n\r\n        // Approve \"infinite\" token transfer to the bankroll, as part of Zethr game requirements.\r\n        ZTHTKN = ZTHInterface(ZTHTKNADDR);\r\n        ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\r\n\r\n        // To start with, we only allow bets of 5, 10, 25 or 50 ZTH.\r\n        validTokenBet[5e18]  = true;\r\n        validTokenBet[10e18] = true;\r\n        validTokenBet[25e18] = true;\r\n        validTokenBet[50e18] = true;\r\n\r\n        // Logarithmically decreasing time 'bonus' associated with higher amounts of ZTH staked.\r\n        tokenToTimer[5e18]  = 60 minutes;\r\n        tokenToTimer[10e18] = 40 minutes;\r\n        tokenToTimer[25e18] = 25 minutes;\r\n        tokenToTimer[50e18] = 15 minutes;\r\n        \r\n        // Set the initial timers to contract genesis.\r\n        gameStarted = now;\r\n        gameEnds    = now;\r\n        gameActive  = true;\r\n    }\r\n    \r\n    // Don't send Ether to this, for the love of God.\r\n    function() public payable { revert(); }\r\n\r\n    // If the contract receives tokens, bundle them up in a struct and fire them over to _stakeTokens for validation.\r\n    struct TKN { address sender; uint value; }\r\n    function tokenFallback(address _from, uint _value, bytes /* _data */) public returns (bool){\r\n        TKN memory          _tkn;\r\n        _tkn.sender       = _from;\r\n        _tkn.value        = _value;\r\n        _stakeTokens(_tkn);\r\n        return true;\r\n    }\r\n\r\n    // First, we check to see if the tokens are ZTH tokens. If not, we revert the transaction.\r\n    // Next - if the game has already ended (i.e. your bet was too late and the clock ran out)\r\n    //   the staked tokens from the previous game are transferred to the winner, the timers are\r\n    //   reset, and the game begins anew.\r\n    // If you're simply resetting the clock, the timers are reset accordingly and you are designated\r\n    //   the current winner. A 1% cut will be taken for the house, and the rest deposited in the prize\r\n    //   pool which everyone will be playing for. No second place prizes here!\r\n    function _stakeTokens(TKN _tkn) private {\r\n   \r\n        require(gameActive); \r\n        require(_zthToken(msg.sender));\r\n        require(validTokenBet[_tkn.value]);\r\n        \r\n        if (now > gameEnds) { _settleAndRestart(); }\r\n\r\n        address _customerAddress = _tkn.sender;\r\n        uint    _wagered         = _tkn.value;\r\n\r\n        uint rightNow      = now;\r\n        uint timePurchased = tokenToTimer[_tkn.value];\r\n        uint newGameEnd    = rightNow.add(timePurchased);\r\n\r\n        gameStarted   = rightNow;\r\n        gameEnds      = newGameEnd;\r\n        currentWinner = _customerAddress;\r\n\r\n        contractBalance = contractBalance.add(_wagered);\r\n        uint houseCut   = _wagered.div(100);\r\n        uint toAdd      = _wagered.sub(houseCut);\r\n        houseTake       = houseTake.add(houseCut);\r\n        tokensInPlay    = tokensInPlay.add(toAdd);\r\n\r\n        emit TokensWagered(_customerAddress, _wagered, newGameEnd);\r\n\r\n    }\r\n\r\n    // In the event of a game restart, subtract the tokens which were being played for from the balance,\r\n    //   transfer them to the winner (if the number of tokens is greater than zero: sly edge case).\r\n    // If there is *somehow* any Ether in the contract - again, please don't - it is transferred to the\r\n    //   bankroll and reinvested into Zethr at the standard 33% rate.\r\n    function _settleAndRestart() private {\r\n        gameActive      = false;\r\n        uint payment = tokensInPlay/2;\r\n        contractBalance = contractBalance.sub(payment);\r\n\r\n        if (tokensInPlay > 0) { ZTHTKN.transfer(currentWinner, payment);\r\n            if (address(this).balance > 0){\r\n                ZTHBANKROLL.transfer(address(this).balance);\r\n            }}\r\n\r\n        emit GameEnded(currentWinner, payment, now);\r\n\r\n        // Reset values.\r\n        tokensInPlay  = tokensInPlay.sub(payment);\r\n        gameActive    = true;\r\n    }\r\n\r\n    // How many tokens are in the contract overall?\r\n    function balanceOf() public view returns (uint) {\r\n        return contractBalance;\r\n    }\r\n\r\n    // Administrative function for adding a new token-time pair, should there be demand.\r\n    function addTokenTime(uint _tokenAmount, uint _timeBought) public onlyOwner {\r\n        validTokenBet[_tokenAmount] = true;\r\n        tokenToTimer[_tokenAmount]  = _timeBought;\r\n    }\r\n\r\n    // Administrative function to REMOVE a token-time pair, should one fall out of use. \r\n    function removeTokenTime(uint _tokenAmount) public onlyOwner {\r\n        validTokenBet[_tokenAmount] = false;\r\n        tokenToTimer[_tokenAmount]  = 232 days;\r\n    }\r\n\r\n    // Function to pull out the house cut to the bankroll if required (i.e. to seed other games).\r\n    function retrieveHouseTake() public onlyOwnerOrBankroll {\r\n        uint toTake = houseTake;\r\n        houseTake = 0;\r\n        contractBalance = contractBalance.sub(toTake);\r\n        ZTHTKN.transfer(bankroll, toTake);\r\n\r\n        emit HouseRetrievedTake(now, toTake);\r\n    }\r\n\r\n    // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.\r\n    function pauseGame() public onlyOwner {\r\n        gameActive = false;\r\n    }\r\n\r\n    // The converse of the above, resuming betting if a freeze had been put in place.\r\n    function resumeGame() public onlyOwner {\r\n        gameActive = true;\r\n    }\r\n\r\n    // Administrative function to change the owner of the contract.\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    // Administrative function to change the Zethr bankroll contract, should the need arise.\r\n    function changeBankroll(address _newBankroll) public onlyOwner {\r\n        bankroll = _newBankroll;\r\n    }\r\n\r\n    // Is the address that the token has come from actually ZTH?\r\n    function _zthToken(address _tokenContract) private view returns (bool) {\r\n       return _tokenContract == ZTHTKNADDR;\r\n    }\r\n}\r\n\r\n// And here's the boring bit.\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resumeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBankroll\",\"type\":\"address\"}],\"name\":\"changeBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensInPlay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_timeBought\",\"type\":\"uint256\"}],\"name\":\"addTokenTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"retrieveHouseTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"removeTokenTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ZethrAddress\",\"type\":\"address\"},{\"name\":\"BankrollAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeOfWin\",\"type\":\"uint256\"}],\"name\":\"GameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeTaken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensWithdrawn\",\"type\":\"uint256\"}],\"name\":\"HouseRetrievedTake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wagerer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_wagered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newExpiry\",\"type\":\"uint256\"}],\"name\":\"TokensWagered\",\"type\":\"event\"}]","ContractName":"Zethell","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d48b633045af65ff636f3c6edd744748351e020d0000000000000000000000007430984e1d05d5f447c747123dd26845f6f17544","Library":"","SwarmSource":"bzzr://ac3f117df1dbddf97f274005b56780246a3f290b2cf8ecfa72f81ae351417468"}]}