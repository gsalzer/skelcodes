{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Gorgona {\r\n    address public owner;\r\n\r\n    uint constant PAYOUT_PER_INVESTOR_INTERVAL = 10 minutes;\r\n    uint constant INTEREST = 3;\r\n    uint private PAYOUT_CUMULATIVE_INTERVAL = 10 minutes;\r\n    uint private MINIMUM_INVEST = 10000000000000000 wei;\r\n\r\n    uint depositAmount;\r\n    uint investorCount;\r\n    uint public payoutDate;\r\n\r\n    struct investor\r\n    {\r\n        uint id;\r\n        uint deposit;\r\n        uint deposits;\r\n        uint date;\r\n        address referrer;\r\n    }\r\n\r\n    address[] public addresses;\r\n\r\n    mapping(address => investor) public investors;\r\n\r\n    event Invest(address addr, uint amount);\r\n    event PayoutCumulative(uint amount, uint txs);\r\n    event PayoutSelf(address addr, uint amount);\r\n    event RefFee(address addr, uint amount);\r\n    event Cashback(address addr, uint amount);\r\n\r\n    modifier onlyOwner {if (msg.sender == owner) _;}\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        addresses.length = 1;\r\n        payoutDate = now;\r\n    }\r\n\r\n    function() payable public {\r\n        if (msg.value == 0) {\r\n            return;\r\n        }\r\n\r\n        require(msg.value >= MINIMUM_INVEST, \"Too small amount, minimum 0.001 ether\");\r\n\r\n        investor storage user = investors[msg.sender];\r\n\r\n        if (user.id == 0) {\r\n            user.id = addresses.length;\r\n            addresses.push(msg.sender);\r\n            addresses.length++;\r\n            investorCount ++;\r\n\r\n            // referrer\r\n            address referrer = bytesToAddress(msg.data);\r\n            if (investors[referrer].deposit > 0 && referrer != msg.sender) {\r\n                user.referrer = referrer;\r\n            }\r\n        }\r\n\r\n        // save investor\r\n        user.deposit += msg.value;\r\n        user.deposits += 1;\r\n        user.date = now;\r\n\r\n        emit Invest(msg.sender, msg.value);\r\n        depositAmount += msg.value;\r\n\r\n        // project fee\r\n        owner.transfer(msg.value / 5);\r\n\r\n        // referrer commission for all deposits\r\n        if (user.referrer > 0x0) {\r\n            uint bonusAmount = (msg.value / 100) * INTEREST;\r\n            user.referrer.transfer(bonusAmount);\r\n            emit RefFee(user.referrer, bonusAmount);\r\n\r\n            // cashback only for first deposit\r\n            if (user.deposits == 1) {\r\n                msg.sender.transfer(bonusAmount);\r\n                emit Cashback(msg.sender, bonusAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function payout(uint limit) public\r\n    {\r\n        require(now >= payoutDate + PAYOUT_CUMULATIVE_INTERVAL, \"too fast payout request\");\r\n\r\n        uint investorsPayout;\r\n        uint txs;\r\n        uint amount;\r\n\r\n        for (uint idx = addresses.length - 1; --idx >= 1;)\r\n        {\r\n            address addr = addresses[idx];\r\n            if (investors[addr].date + 24 hours > now) {\r\n                continue;\r\n            }\r\n\r\n            amount = getInvestorUnPaidAmount(addr);\r\n            investors[addr].date = now;\r\n\r\n            if (address(this).balance < amount) {\r\n                selfdestruct(owner);\r\n                return;\r\n            }\r\n\r\n            addr.transfer(amount);\r\n\r\n            investorsPayout += amount;\r\n            if (++txs >= limit) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        payoutDate = now;\r\n        emit PayoutCumulative(investorsPayout, txs);\r\n    }\r\n\r\n    function payoutSelf(address addr) public\r\n    {\r\n        require(addr == msg.sender, \"You need specify your ETH address\");\r\n\r\n        require(investors[addr].deposit > 0, \"deposit not found\");\r\n        require(now >= investors[addr].date + PAYOUT_PER_INVESTOR_INTERVAL, \"too fast payment required\");\r\n\r\n        uint amount = getInvestorUnPaidAmount(addr);\r\n        require(amount >= 1 finney, \"too small unpaid amount\");\r\n\r\n        investors[addr].date = now;\r\n        if (address(this).balance < amount) {\r\n            selfdestruct(owner);\r\n            return;\r\n        }\r\n\r\n        addr.transfer(amount);\r\n\r\n        emit PayoutSelf(addr, amount);\r\n    }\r\n\r\n    function getInvestorDeposit(address addr) public view returns (uint) {\r\n        return investors[addr].deposit;\r\n    }\r\n\r\n    function getInvestorCount() public view returns (uint) {\r\n        return investorCount;\r\n    }\r\n\r\n    function getDepositAmount() public view returns (uint) {\r\n        return depositAmount;\r\n    }\r\n\r\n    function getInvestorDatePayout(address addr) public view returns (uint) {\r\n        return investors[addr].date;\r\n    }\r\n\r\n    function getPayoutCumulativeInterval() public view returns (uint)\r\n    {\r\n        return PAYOUT_CUMULATIVE_INTERVAL;\r\n    }\r\n\r\n    function setDatePayout(address addr, uint date) onlyOwner public\r\n    {\r\n        investors[addr].date = date;\r\n    }\r\n\r\n    function setPayoutCumulativeInterval(uint interval) onlyOwner public\r\n    {\r\n        PAYOUT_CUMULATIVE_INTERVAL = interval;\r\n    }\r\n\r\n    function getInvestorUnPaidAmount(address addr) public view returns (uint)\r\n    {\r\n        return (((investors[addr].deposit / 100) * INTEREST) / 100) * ((now - investors[addr].date) * 100) / 1 days;\r\n    }\r\n\r\n    function bytesToAddress(bytes bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"payoutDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvestorDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvestorDatePayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"payoutSelf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"setPayoutCumulativeInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"deposits\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getInvestorUnPaidAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPayoutCumulativeInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"setDatePayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txs\",\"type\":\"uint256\"}],\"name\":\"PayoutCumulative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayoutSelf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Cashback\",\"type\":\"event\"}]","ContractName":"Gorgona","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8f6aef6b121075823cb73a07f9f1fdf1d151f17bad6a5f2b4e2f1979076b7fdc"}]}