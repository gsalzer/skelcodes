{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary F3Ddatasets {\r\n    struct Referee {\r\n        uint256 pID;\r\n        uint256 offer;\r\n    }\r\n    \r\n    struct EventReturns {\r\n        address winnerBigPotAddr;         // winner address\r\n        uint256 amountWonBigPot;          // amount won\r\n\r\n        address winnerSmallPotAddr;         // winner address\r\n        uint256 amountWonSmallPot;          // amount won\r\n\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 P3DAmount;          // amount distributed to p3d\r\n        uint256 genAmount;          // amount distributed to key money sharer\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n\r\n    struct PlayerVault {\r\n        address addr;   // player address\r\n        uint256 winBigPot;    // winnings vault\r\n        uint256 winSmallPot;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;\r\n    }\r\n\r\n    struct PlayerRound {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 auc;    // auction phase investment\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask\r\n        uint256 refID;  // referal right ID -- 推荐权利 ID\r\n    }\r\n\r\n    struct SmallPot {\r\n        uint256 plyr;   // pID of player in lead for Small pot\r\n        uint256 end;    // time ends/ended\r\n        uint256 strt;   // time round started\r\n        uint256 pot;     // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 keys;   // keys\r\n        uint256 eth;   // total eth\r\n        bool on;     // has round end function been ran\r\n    }\r\n\r\n    struct BigPot {\r\n        uint256 plyr;   // pID of player in lead for Big pot\r\n        uint256 end;    // time ends/ended\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 gen;\r\n        uint256 mask;\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        bool ended;     // has round end function been ran\r\n    }\r\n\r\n\r\n    struct Auction {\r\n        // auction phase\r\n        bool isAuction; // true: auction; false: bigPot\r\n        uint256 end;    // time ends/ended\r\n        uint256 strt;   // time round started\r\n        uint256 eth;    // total eth sent in during AUC phase\r\n        uint256 gen; // total eth for gen during AUC phase\r\n        uint256 keys;   // keys\r\n        // uint256 eth;    // total eth in\r\n        // uint256 mask;   // global mask\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  |  _      _ _ | _  .\r\n//  |<(/_\\/  (_(_||(_  .\r\n//=======/======================================================================\r\nlibrary F3DKeysCalcShort {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth\r\n     * @param _curEth current amount of eth in contract\r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys\r\n     * @param _curKeys current amount of keys that exist\r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\"\r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  . _ _|_ _  _ |` _  _ _  _  .\r\n//  || | | (/_| ~|~(_|(_(/__\\  .\r\n//==============================================================================\r\n\r\n\r\n\r\n\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n}\r\n\r\n\r\n\r\ncontract F3Devents {\r\n    event eventAuction(\r\n        string funName,\r\n        uint256 round,\r\n        uint256 plyr,\r\n        uint256 money,\r\n        uint256 keyPrice,\r\n        uint256 plyrEth,\r\n        uint256 plyrAuc,\r\n        uint256 plyrKeys,\r\n        uint256 aucEth,\r\n        uint256 aucKeys\r\n    );\r\n\r\n    event onPot(\r\n        uint256 plyrBP, // pID of player in lead for Big pot\r\n        uint256 ethBP,\r\n        uint256 plyrSP, // pID of player in lead for Small pot\r\n        uint256 ethSP   // eth to pot (during round) / final amount paid to winner (after round ends)\r\n    );\r\n\r\n}\r\n\r\ncontract FoMo3DFast is F3Devents {\r\n    using SafeMath for *;\r\n    //    using F3DKeysCalcShort for uint256;\r\n    //\r\n    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x77ae3DEC9462C8Ac8F1e6D222C1785B5250F0F62);\r\n\r\n    address private admin = msg.sender;\r\n    uint256 private prepareTime = 30 minutes;\r\n    uint256 private aucDur = 120 minutes;     // length of the very first ICO\r\n    // uint256 constant private rndInit_ = 88 minutes;                // round timer starts at this\r\n    uint256 constant private rndInc_ = 360 seconds;              // every full key purchased adds this much to the timer\r\n    uint256 constant private smallTime_ = 5 minutes;              // small time\r\n    uint256 constant private rndMax_ = 10080 minutes;                // max length a round timer can be\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n    uint256 constant public keyPriceAuc_ = 5000000000000000;\r\n    uint256 constant public keyPricePot_ = 10000000000000000;\r\n    //****************\r\n    // PLAYER DATA\r\n    //****************\r\n    mapping(address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping(uint256 => F3Ddatasets.PlayerVault) public plyr_;   // (pID => data) player data\r\n    // (pID => rID => data) player round data by player id & round id\r\n    mapping(uint256 => mapping(uint256 => F3Ddatasets.PlayerRound)) public plyrRnds_;\r\n    //****************\r\n    // ROUND DATA\r\n    //****************\r\n    mapping(uint256 => F3Ddatasets.Auction) public auction_;   // (rID => data) round data\r\n    mapping(uint256 => F3Ddatasets.BigPot) public bigPot_;   // (rID => data) round data\r\n    F3Ddatasets.SmallPot public smallPot_;   // (rID => data) round data\r\n    mapping(uint256 => uint256) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id\r\n\r\n\r\n    // referee  (rID => referee[] data)\r\n    mapping(uint256 => F3Ddatasets.Referee[]) public referees_;\r\n    uint256 minOfferValue_;\r\n    uint256 constant referalSlot_ = 2;\r\n\r\n    constructor()\r\n    public\r\n    {\r\n\r\n    }\r\n    //==============================================================================\r\n    //     _ _  _  _|. |`. _  _ _  .\r\n    //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n    //==============================================================================\r\n    /**\r\n    * @dev used to make sure no one can interact with contract until it has\r\n    * been activated.\r\n    */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready yet.  check ?eta in discord\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev prevents contracts from interacting with fomo3d\r\n    */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev sets boundaries for incoming tx\r\n    */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        _;\r\n    }\r\n\r\n    //==============================================================================\r\n    //     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n    //====|=========================================================================\r\n    /**\r\n    * @dev emergency buy uses last stored affiliate ID and team snek\r\n    */\r\n    function()\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        // get/set pID for current player\r\n        determinePID(msg.sender);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _now = now;\r\n        uint256 _rID = rID_;\r\n\r\n        if (_now > auction_[_rID].strt && _now < auction_[_rID].end)\r\n        {\r\n            // Auction phase\r\n            buyAuction(_pID);\r\n        } else if (_now > bigPot_[_rID].strt && _now < bigPot_[_rID].end) {\r\n            // Round(big pot) phase\r\n            buy(_pID, 9999);\r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > bigPot_[_rID].end && bigPot_[_rID].ended == false)\r\n            {\r\n                // end the round (distributes pot) & start new round\r\n                bigPot_[_rID].ended = true;\r\n                endRound();\r\n            }\r\n\r\n            // put eth in players vault\r\n            plyr_[_pID].gen = msg.value.add(plyr_[_pID].gen);\r\n        }\r\n    }\r\n\r\n    function buyXQR(address _realSender, uint256 _affID)\r\n    isActivated()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        // get/set pID for current player\r\n        determinePID(_realSender);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_realSender];\r\n        uint256 _now = now;\r\n        uint256 _rID = rID_;\r\n\r\n        if (_now > auction_[_rID].strt && _now < auction_[_rID].end)\r\n        {\r\n            // Auction phase\r\n            buyAuction(_pID);\r\n        } else if (_now > bigPot_[_rID].strt && _now < bigPot_[_rID].end) {\r\n            // Round(big pot) phase\r\n            buy(_pID, _affID);\r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > bigPot_[_rID].end && bigPot_[_rID].ended == false)\r\n            {\r\n                // end the round (distributes pot) & start new round\r\n                bigPot_[_rID].ended = true;\r\n                endRound();\r\n            }\r\n\r\n            // put eth in players vault\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n\r\n    function endRound()\r\n    private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab our winning player and team id's\r\n        uint256 _winPID = bigPot_[_rID].plyr;\r\n\r\n        // grab our pot amount\r\n        uint256 _win = bigPot_[_rID].pot;\r\n        // 10000000000000000000 10个ether\r\n\r\n        // pay our winner bigPot\r\n        plyr_[_winPID].winBigPot = _win.add(plyr_[_winPID].winBigPot);\r\n\r\n        // pay smallPot\r\n        uint256 _currentPot = smallPot_.eth;\r\n        if (smallPot_.on == true) {\r\n            uint256 _winSmallPot = smallPot_.pot;\r\n            uint256 _surplus = _currentPot.sub(_winSmallPot);\r\n            smallPot_.on = false;\r\n            smallPot_.keys = 0;\r\n            smallPot_.eth = 0;\r\n            smallPot_.pot = 0;\r\n            smallPot_.plyr = 0;\r\n            plyr_[_winPID].winSmallPot = _winSmallPot.add(plyr_[_winPID].winSmallPot);\r\n            if (_surplus > 0) {\r\n                plyr_[1].winSmallPot = _surplus.add(plyr_[1].winSmallPot);\r\n            }\r\n        } else {\r\n            if (_currentPot > 0) {\r\n                plyr_[1].winSmallPot = _currentPot.add(plyr_[1].winSmallPot);\r\n            }\r\n        }\r\n\r\n\r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        uint256 _now = now;\r\n        auction_[_rID].strt = _now;\r\n        auction_[_rID].end = _now + aucDur;\r\n\r\n        bigPot_[_rID].strt = _now + aucDur;\r\n        bigPot_[_rID].end = _now + aucDur + rndMax_;\r\n    }\r\n\r\n    function withdrawXQR(address _realSender)\r\n    payable\r\n    isActivated()\r\n    public\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[_realSender];\r\n\r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n\r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > bigPot_[_rID].end && bigPot_[_rID].ended == false && bigPot_[_rID].plyr != 0)\r\n        {\r\n            // end the round (distributes pot)\r\n            bigPot_[_rID].ended = true;\r\n            endRound();\r\n\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n\r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n            // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n\r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n        }\r\n    }\r\n\r\n    function withdrawEarnings(uint256 _pID)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        // from vaults\r\n        uint256 _earnings = (plyr_[_pID].winBigPot).add(plyr_[_pID].winSmallPot).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].winBigPot = 0;\r\n            plyr_[_pID].winSmallPot = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n        return (_earnings);\r\n    }\r\n\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n        }\r\n    }\r\n\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return( (((bigPot_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\r\n    }\r\n\r\n    function managePlayer(uint256 _pID)\r\n        private\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n    }\r\n\r\n\r\n    function buyAuction(uint256 _pID)\r\n    private\r\n    {\r\n        // setup local variables\r\n        uint256 _rID = rID_;\r\n        uint256 _keyPrice = keyPriceAuc_;\r\n\r\n        // 加入未统计的分钥匙的钱\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            managePlayer(_pID);\r\n        \r\n        // update bigPot leader\r\n        bigPot_[_rID].plyr = _pID;\r\n\r\n        uint256 _eth = msg.value;\r\n        // calculate keys purchased\r\n        uint256 _keys = _eth / _keyPrice;\r\n\r\n        // plry {eth, auc, keys}\r\n        plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n        plyrRnds_[_pID][_rID].auc = _eth.add(plyrRnds_[_pID][_rID].auc);\r\n        plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n\r\n        uint256 plyrEth = plyrRnds_[_pID][_rID].eth;\r\n        uint256 plyrAuc = plyrRnds_[_pID][_rID].auc;\r\n        uint256 plyrKeys = plyrRnds_[_pID][_rID].keys;\r\n\r\n        // auction {eth, keys}\r\n        auction_[_rID].eth = auction_[_rID].eth.add(_eth);\r\n        auction_[_rID].keys = auction_[_rID].keys.add(_keys);\r\n        uint256 aucEth = auction_[_rID].eth;\r\n        uint256 aucKeys = auction_[_rID].keys;\r\n\r\n        emit eventAuction\r\n        (\r\n            \"buyFunction\",\r\n            _rID,\r\n            _pID,\r\n            _eth,\r\n            _keyPrice,\r\n            plyrEth,\r\n            plyrAuc,\r\n            plyrKeys,\r\n            aucEth,\r\n            aucKeys\r\n        );\r\n\r\n        // update round\r\n        refereeCore(_pID, plyrRnds_[_pID][_rID].auc);\r\n\r\n        // 分钱\r\n        distributeAuction(_rID, _eth);\r\n    }\r\n\r\n    function distributeAuction(uint256 _rID, uint256 _eth)\r\n    private\r\n    {\r\n        // pay 50% out to team\r\n        uint256 _team = _eth / 2;\r\n        uint256 _pot = _eth.sub(_team);\r\n        // 50% to big Pot\r\n        uint256 _bigPot = _pot / 2;\r\n        // 50% to small Pot\r\n        uint256 _smallPot = _pot / 2;\r\n\r\n        // pay out p3d\r\n        admin.transfer(_team);\r\n\r\n        // move money to Pot\r\n        bigPot_[_rID].pot = bigPot_[_rID].pot.add(_bigPot);\r\n        smallPot_.pot = smallPot_.pot.add(_smallPot);\r\n        emit onPot(bigPot_[_rID].plyr, bigPot_[_rID].pot, smallPot_.plyr, smallPot_.pot);\r\n    }\r\n\r\n    function buy(uint256 _pID, uint256 _affID)\r\n    private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _keyPrice = keyPricePot_;\r\n\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            managePlayer(_pID);\r\n\r\n        uint256 _eth = msg.value;\r\n\r\n        uint256 _keys = _eth / _keyPrice;\r\n\r\n        if (_eth > 1000000000)\r\n        {\r\n            // if they bought at least 1 whole key\r\n            if (_eth >= 1000000000000000000)\r\n            {\r\n                updateTimer(_eth, _rID);\r\n                // set new leaders\r\n                if (bigPot_[_rID].plyr != _pID)\r\n                    bigPot_[_rID].plyr = _pID;\r\n            }\r\n\r\n\r\n            // update round\r\n            bigPot_[_rID].keys = _keys.add(bigPot_[_rID].keys);\r\n            bigPot_[_rID].eth = _eth.add(bigPot_[_rID].eth);\r\n\r\n            // update player\r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n\r\n            // key sharing earnings\r\n            uint256 _gen = _eth.mul(6) / 10;\r\n            updateMasks(_rID, _pID, _gen, _keys);\r\n            // if (_dust > 0)\r\n            //     _gen = _gen.sub(_dust);\r\n\r\n            distributeBuy(_rID, _eth, _affID);\r\n            smallPot();\r\n        }\r\n    }\r\n\r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (bigPot_[_rID].keys);\r\n        bigPot_[_rID].mask = _ppt.add(bigPot_[_rID].mask); \r\n            \r\n        // calculate player earning from their own buy (only based on the keys\r\n        // they just bought).  & update player earnings mask\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((bigPot_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n        \r\n        // calculate & return dust\r\n        return(_gen.sub((_ppt.mul(bigPot_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n\r\n    function distributeBuy(uint256 _rID, uint256 _eth, uint256 _affID)\r\n    private\r\n    {\r\n        // pay 10% out to team\r\n        uint256 _team = _eth / 10;\r\n        // 10% to aff\r\n        uint256 _aff = _eth / 10;\r\n        if (_affID == 9999) {\r\n            _team = _team.add(_aff);\r\n            _aff = 0;\r\n        }\r\n\r\n        // 10% to big Pot\r\n        uint256 _bigPot = _eth / 10;\r\n        // 10% to small Pot\r\n        uint256 _smallPot = _eth / 10;\r\n\r\n        // pay out team\r\n        admin.transfer(_team);\r\n\r\n        if (_aff != 0) {\r\n            // 通过 affID 得到 推荐玩家pID， 并将_aff驾到 pID玩家的 aff中\r\n            uint256 affPID = referees_[_rID][_affID].pID;\r\n            plyr_[affPID].aff = _aff.add(plyr_[affPID].aff);\r\n        }\r\n\r\n        // move money to Pot\r\n        bigPot_[_rID].pot = bigPot_[_rID].pot.add(_bigPot);\r\n        smallPot_.pot = smallPot_.pot.add(_smallPot);\r\n\r\n        emit onPot(bigPot_[_rID].plyr, bigPot_[_rID].pot, smallPot_.plyr, smallPot_.pot);\r\n    }\r\n\r\n    function smallPot()\r\n    private\r\n    {\r\n        uint256 _now = now;\r\n\r\n        if (smallPot_.on == false && smallPot_.keys >= (1000)) {\r\n            smallPot_.on = true;\r\n            smallPot_.pot = smallPot_.eth;\r\n            smallPot_.strt = _now;\r\n            smallPot_.end = _now + smallTime_;\r\n        } else if (smallPot_.on == true && _now > smallPot_.end) {\r\n            uint256 _winSmallPot = smallPot_.pot;\r\n            uint256 _currentPot = smallPot_.eth;\r\n            uint256 _surplus = _currentPot.sub(_winSmallPot);\r\n            uint256 _winPID = smallPot_.plyr;\r\n            smallPot_.on = false;\r\n            smallPot_.keys = 0;\r\n            smallPot_.eth = 0;\r\n            smallPot_.pot = 0;\r\n            smallPot_.plyr = 0;\r\n            plyr_[_winPID].winSmallPot = _winSmallPot.add(plyr_[_winPID].winSmallPot);\r\n            if (_surplus > 0) {\r\n                plyr_[1].winSmallPot = _surplus.add(plyr_[1].winSmallPot);\r\n            }\r\n        }\r\n    }\r\n\r\n    event onBigPot(\r\n        string eventname,\r\n        uint256 rID,\r\n        uint256 plyr, // pID of player in lead for Big pot\r\n    // big pot phase\r\n        uint256 end, // time ends/ended\r\n        uint256 strt, // time round started\r\n        uint256 eth, // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 keys, // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        bool ended     // has round end function been ran\r\n    );\r\n\r\n    function updateTimer(uint256 _keys, uint256 _rID)\r\n    private\r\n    {\r\n        emit onBigPot\r\n        (\r\n            \"updateTimer_start:\",\r\n            _rID,\r\n            bigPot_[_rID].plyr,\r\n            bigPot_[_rID].end,\r\n            bigPot_[_rID].strt,\r\n            bigPot_[_rID].eth,\r\n            bigPot_[_rID].keys,\r\n            bigPot_[_rID].ended\r\n        );\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now > bigPot_[_rID].end && bigPot_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(bigPot_[_rID].end);\r\n\r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            bigPot_[_rID].end = _newTime;\r\n        else\r\n            bigPot_[_rID].end = rndMax_.add(_now);\r\n\r\n        emit onBigPot\r\n        (\r\n            \"updateTimer_end:\",\r\n            _rID,\r\n            bigPot_[_rID].plyr,\r\n            bigPot_[_rID].end,\r\n            bigPot_[_rID].strt,\r\n            bigPot_[_rID].eth,\r\n            bigPot_[_rID].keys,\r\n            bigPot_[_rID].ended\r\n        );\r\n\r\n    }\r\n\r\n    event pidUpdate(address sender, uint256 pidOri, uint256 pidNew);\r\n\r\n    function determinePID(address _realSender)\r\n    private\r\n    {\r\n\r\n        uint256 _pID = pIDxAddr_[_realSender];\r\n        uint256 _pIDOri = _pID;\r\n        // if player is new to this version of fomo3d\r\n        if (_pID == 0)\r\n        {\r\n            // grab their player ID, name and last aff ID, from player names contract\r\n            _pID = PlayerBook.getPlayerID(_realSender);\r\n\r\n            // set up player account\r\n            pIDxAddr_[_realSender] = _pID;\r\n            plyr_[_pID].addr = _realSender;\r\n\r\n        }\r\n        emit pidUpdate(_realSender, _pIDOri, _pID);\r\n    }\r\n\r\n\r\n    function getPlayerIdxAddr(address _addr) public view returns (uint256){\r\n        if (pIDxAddr_[_addr] == 0) {\r\n            return pIDxAddr_[_addr];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    function receivePlayerInfo(uint256 _pID, address _addr)\r\n    external\r\n    {\r\n        require(msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n    }\r\n\r\n    event consolerefereeCore(\r\n        uint256 _pID, uint256 _value, uint256 minOfferIndex, uint256 minOfferpID, uint256 minOfferValue\r\n    );\r\n\r\n    function refereeCore(uint256 _pID, uint256 _value) private {\r\n        uint256 _rID = rID_;\r\n        uint256 length_ = referees_[_rID].length;\r\n        emit consolerefereeCore(_pID, _value, _rID, length_, minOfferValue_);\r\n        if (_value > minOfferValue_) {\r\n\r\n            uint256 minXvalue = _value;\r\n            uint256 minXindex = 9999;\r\n            uint256 flag = 1;\r\n\r\n            // 找到当前玩家，不改变数组，更新玩家出价\r\n            for (uint256 i = 0; i < referees_[_rID].length; i++) {\r\n                if (_pID == referees_[_rID][i].pID) {\r\n                    referees_[_rID][i].offer = _value;\r\n                    flag = 0;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // 未找到当前玩家，则改变数组，更新玩家出价\r\n            if (flag == 1) {\r\n                emit consolerefereeCore(1111, minXindex, _rID, referees_[_rID].length, minXvalue);\r\n                // 找到当前数组中最低出价及最低出价的index\r\n                for (uint256 j = 0; j < referees_[_rID].length; j++) {\r\n                    if (referees_[_rID][j].offer < minXvalue) {\r\n                        minXvalue = referees_[_rID][j].offer;\r\n                        emit consolerefereeCore(2222, minXindex, _rID, referees_[_rID].length, minXvalue);\r\n                        minXindex = j;\r\n                    }\r\n                }\r\n                emit consolerefereeCore(3333, minXindex, _rID, referees_[_rID].length, minXvalue);\r\n                // 若数组未满， 则直接加入\r\n                if (referees_[_rID].length < referalSlot_) {\r\n                    referees_[_rID].push(F3Ddatasets.Referee(_pID, _value));\r\n                } else {\r\n                    // 替换最低出价\r\n                    if (minXindex != 9999) {\r\n                        referees_[_rID][minXindex].offer = _value;\r\n                        referees_[_rID][minXindex].pID = _pID;\r\n                        minOfferValue_ = _value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //==============================================================================\r\n    //     _  _ _|__|_ _  _ _  .\r\n    //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n    //=====_|=======================================================================\r\n    /**\r\n    * @dev return the price buyer will pay for next 1 individual key.\r\n    * -functionhash- 0x018a25e8\r\n    * @return price for next key bought (in wei format)\r\n    */\r\n    // function getBuyPrice()\r\n    // public\r\n    // view\r\n    // returns (uint256)\r\n    // {\r\n    //     if (now < round_[rID_].start) {\r\n    //         // 当前轮游戏开始前\r\n    //         return 5;\r\n    //     } else if (now > round_[rID_].start && now < rndTmEth_[rID_]) {\r\n    //         // 当前轮游戏进行中\r\n    //         return 10;\r\n    //     } else if (now > rndTmEth_[rID_]) {\r\n    //         // 当前轮游戏已结束\r\n    //         return 5;\r\n    //     }\r\n    // }\r\n\r\n    function getTimeLeft() public\r\n    view returns (uint256){\r\n        return rndTmEth_[rID_] - now;\r\n    }\r\n\r\n    function getrID() public\r\n    view returns (uint256){\r\n        return rID_;\r\n    }\r\n\r\n    function getAdmin() public\r\n    view returns (address){\r\n        return admin;\r\n    }\r\n\r\n    //==============================================================================\r\n    //    (~ _  _    _._|_    .\r\n    //    _)(/_(_|_|| | | \\/  .\r\n    //====================/=========================================================\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs\r\n     * have time to set things up on the web end                            **/\r\n    bool public activated_ = false;\r\n    uint256  public end_ = 0;\r\n\r\n    function activate()\r\n    public\r\n    {\r\n        // only team just can activate\r\n        require(msg.sender == admin, \"only admin can activate\");\r\n        // can only be ran once\r\n        require(activated_ == false, \"FOMO Short already activated\");\r\n\r\n        // activate the contract\r\n        activated_ = true;\r\n\r\n        // lets start first round\r\n        rID_ = 1;\r\n        uint256 _now = now;\r\n\r\n        auction_[1].strt = _now;\r\n        auction_[1].end = _now + aucDur;\r\n\r\n        bigPot_[1].strt = _now + aucDur;\r\n        bigPot_[1].end = _now + aucDur + rndMax_;\r\n    }\r\n\r\n    function getAuctionTimer()\r\n    public\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, bool, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        return\r\n        (\r\n        _rID, //1\r\n        auction_[_rID].strt,\r\n        auction_[_rID].end,\r\n        _now,\r\n        _now > auction_[_rID].end,\r\n        bigPot_[_rID].strt,\r\n        bigPot_[_rID].end            //2\r\n        );\r\n    }\r\n\r\n\r\n    // ================== 页面数据方法 start ======================\r\n\r\n    // 获取当前轮auc数据\r\n    function getCurrentRoundAucInfo()\r\n    public\r\n    view\r\n    returns (uint256, bool, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        return\r\n        (\r\n        _rID, // round index\r\n        // auc data\r\n        auction_[_rID].isAuction, // true: auction; false: bigPot\r\n        auction_[_rID].strt,\r\n        auction_[_rID].end,\r\n        auction_[_rID].end - _now,\r\n        auction_[_rID].eth,\r\n        auction_[_rID].gen,\r\n        auction_[_rID].keys\r\n        );\r\n    }\r\n\r\n    // 获取当前轮BigPot数据\r\n    function getCurrentRoundBigPotInfo()\r\n    public\r\n    view\r\n    returns (uint256, uint256, bool, uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        uint256 _currentpID = bigPot_[_rID].plyr;\r\n        uint256 _eth = bigPot_[_rID].eth;\r\n        return\r\n        (\r\n        _rID, // round index\r\n        // bitPot data\r\n        _currentpID, // pID of player in lead for Big pot\r\n        bigPot_[_rID].ended, // has round end function been ran\r\n        bigPot_[_rID].strt, // time round started\r\n        bigPot_[_rID].end, // time ends/ended\r\n        bigPot_[_rID].end - _now,\r\n        bigPot_[_rID].keys, // keys\r\n        _eth, // total eth in\r\n        _eth.mul(60) / 100,\r\n        bigPot_[_rID].pot, // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        plyr_[_currentpID].addr, // current lead address\r\n        keyPricePot_\r\n        );\r\n    }\r\n\r\n    // 获取当前轮SmallPot数据\r\n    function getSmallPotInfo()\r\n    public\r\n    view\r\n    returns (uint256, uint256, bool, uint256, uint256, uint256, uint256, uint256, uint256, address)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        uint256 _currentpID = smallPot_.plyr;\r\n        return\r\n        (\r\n        _rID, // round index\r\n        // smallPot data\r\n        _currentpID,\r\n        smallPot_.on,\r\n        smallPot_.strt,\r\n        smallPot_.end,\r\n        smallPot_.end - _now,\r\n        smallPot_.keys,\r\n        smallPot_.eth,\r\n        smallPot_.pot,\r\n        plyr_[_currentpID].addr // current lead address\r\n        );\r\n    }\r\n\r\n    // 获取当前轮数据\r\n    function getPlayerInfoxAddr()\r\n    public\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        return\r\n        (_rID, //1\r\n        _pID, //1\r\n        plyrRnds_[_pID][_rID].eth,\r\n        plyrRnds_[_pID][_rID].auc,\r\n        plyrRnds_[_pID][_rID].keys,\r\n        plyrRnds_[_pID][_rID].mask, //2\r\n        plyrRnds_[_pID][_rID].refID //2\r\n        );\r\n    }\r\n\r\n    // 获取用户钱包信息\r\n    function getPlayerVaultxAddr()\r\n    public\r\n    view\r\n    returns (uint256, address, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        address addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[addr];\r\n        return\r\n        (\r\n        _pID, //1\r\n        plyr_[_pID].addr,\r\n        plyr_[_pID].winBigPot,\r\n        plyr_[_pID].winSmallPot,\r\n        plyr_[_pID].gen,\r\n        plyr_[_pID].aff\r\n        );\r\n    }\r\n    // ================== 页面数据方法 end ======================\r\n\r\n    event consoleRef(uint256 index, uint256 pID, uint256 value);\r\n\r\n    function getReferees()\r\n    public\r\n    payable\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        for (uint256 i = 0; i < referees_[_rID].length; i++) {\r\n            emit consoleRef(i, referees_[_rID][i].pID, referees_[_rID][i].offer);\r\n        }\r\n    }\r\n\r\n    function getPlayerInfoByAddress(address addr)\r\n    public\r\n    view\r\n    returns (uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        address _addr = addr;\r\n\r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        return\r\n        (\r\n        _pID, //0\r\n        _addr, //1\r\n        _rID, //2\r\n        plyr_[_pID].winBigPot, //3\r\n        plyr_[_pID].winSmallPot, //4\r\n        plyr_[_pID].gen, //5\r\n        plyr_[_pID].aff, //6\r\n        plyrRnds_[_pID][_rID].keys, //7\r\n        plyrRnds_[_pID][_rID].eth, //\r\n        plyrRnds_[_pID][_rID].auc, //\r\n        plyrRnds_[_pID][_rID].mask, //\r\n        plyrRnds_[_pID][_rID].refID //\r\n        );\r\n    }\r\n\r\n    function getPlayerInfoById(uint256 pID)\r\n    public\r\n    view\r\n    returns (uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 _pID = pID;\r\n        address _addr = msg.sender;\r\n        return\r\n        (\r\n        _pID, //0\r\n        _addr, //1\r\n        _rID, //2\r\n        plyr_[_pID].winBigPot, //3\r\n        plyr_[_pID].winSmallPot, //4\r\n        plyr_[_pID].gen, //5\r\n        plyr_[_pID].aff, //6\r\n        plyrRnds_[_pID][_rID].keys, //7\r\n        plyrRnds_[_pID][_rID].eth, //\r\n        plyrRnds_[_pID][_rID].auc, //\r\n        plyrRnds_[_pID][_rID].mask, //\r\n        plyrRnds_[_pID][_rID].refID //\r\n        );\r\n    }\r\n\r\n    function kill() public {\r\n        if (admin == msg.sender) { // 检查谁在调用\r\n            selfdestruct(admin); // 销毁合约\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"end_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSmallPotInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referees_\",\"outputs\":[{\"name\":\"pID\",\"type\":\"uint256\"},{\"name\":\"offer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyPriceAuc_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getrID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerInfoxAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundAucInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyPricePot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerIdxAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auction_\",\"outputs\":[{\"name\":\"isAuction\",\"type\":\"bool\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerInfoById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_realSender\",\"type\":\"address\"},{\"name\":\"_affID\",\"type\":\"uint256\"}],\"name\":\"buyXQR\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundBigPotInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"auc\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"refID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReferees\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bigPot_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smallPot_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"on\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"winBigPot\",\"type\":\"uint256\"},{\"name\":\"winSmallPot\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerVaultxAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_realSender\",\"type\":\"address\"}],\"name\":\"withdrawXQR\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eventname\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"rID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plyr\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ended\",\"type\":\"bool\"}],\"name\":\"onBigPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pidOri\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pidNew\",\"type\":\"uint256\"}],\"name\":\"pidUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_pID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minOfferIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minOfferpID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minOfferValue\",\"type\":\"uint256\"}],\"name\":\"consolerefereeCore\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"consoleRef\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"funName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plyr\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"money\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plyrEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plyrAuc\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plyrKeys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"aucEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"aucKeys\",\"type\":\"uint256\"}],\"name\":\"eventAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"plyrBP\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethBP\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plyrSP\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethSP\",\"type\":\"uint256\"}],\"name\":\"onPot\",\"type\":\"event\"}]","ContractName":"FoMo3DFast","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1376b0ccde1a0aea4b7ef28ee93b0932ce4cb9f52bae3ec918813bd7188be1b7"}]}