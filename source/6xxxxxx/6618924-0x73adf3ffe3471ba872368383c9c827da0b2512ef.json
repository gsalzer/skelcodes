{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic token) external onlyOwner {\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param from_ address The address that is transferring the tokens\r\n  * @param value_ uint256 the amount of the specified token\r\n  * @param data_ Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\r\n    from_;\r\n    value_;\r\n    data_;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/// @title PoolParty contract responsible for deploying independent Pool.sol contracts.\r\ncontract PoolParty is HasNoTokens, HasNoContracts {\r\n    using SafeMath for uint256;\r\n\r\n    event PoolCreated(uint256 poolId, address creator);\r\n\r\n    uint256 public nextPoolId;\r\n\r\n    /// @dev Holds the pool id and the corresponding pool contract address\r\n    mapping(uint256 =>address) public pools;\r\n\r\n    /// @notice Reclaim Ether that is accidentally sent to this contract.\r\n    /// @dev If a user forces ether into this contract, via selfdestruct etc..\r\n    /// Requires:\r\n    ///     - msg.sender is the owner\r\n    function reclaimEther() external onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    /// @notice Creates a new pool with custom configurations.\r\n    /// @dev Creates a new pool via the imported Pool.sol contracts.\r\n    /// Refer to Pool.sol contracts for specific details.\r\n    /// @param _admins List of admins for the new pool.\r\n    /// @param _configsUint Array of all uint256 custom configurations.\r\n    /// Refer to the Config.sol files for a description of each one.\r\n    /// @param _configsBool Array of all boolean custom configurations.\r\n    /// Refer to the Config.sol files for a description of each one.\r\n    /// @return The poolId for the created pool. Throws an exception on failure.\r\n    function createPool(\r\n        address[] _admins,\r\n        uint256[] _configsUint,\r\n        bool[] _configsBool\r\n    )\r\n        public\r\n        returns (address _pool)\r\n    {\r\n        address poolOwner = msg.sender;\r\n\r\n        _pool = new Pool(\r\n            poolOwner,\r\n            _admins,\r\n            _configsUint,\r\n            _configsBool,\r\n            nextPoolId\r\n        );\r\n\r\n        pools[nextPoolId] = _pool;\r\n        nextPoolId = nextPoolId.add(1);\r\n\r\n        emit PoolCreated(nextPoolId, poolOwner);\r\n    }\r\n}\r\n\r\n\r\n/// @title Admin functionality for Pool.sol contracts.\r\ncontract Admin {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint8;\r\n\r\n    address public owner;\r\n    address[] public admins;\r\n\r\n    /// @dev Verifies the msg.sender is a member of the admins list.\r\n    modifier isAdmin() {\r\n        bool found = false;\r\n\r\n        for (uint256 i = 0; i < admins.length; ++i) {\r\n            if (admins[i] == msg.sender) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // msg.sender is not an admin!\r\n        require(found);\r\n        _;\r\n    }\r\n\r\n    /// @dev Ensures creator of the pool is in the admin list and that there are no duplicates or 0x0 addresses.\r\n    modifier isValidAdminsList(address[] _listOfAdmins) {\r\n        bool containsSender = false;\r\n\r\n        for (uint256 i = 0; i < _listOfAdmins.length; ++i) {\r\n            // Admin list contains 0x0 address!\r\n            require(_listOfAdmins[i] != address(0));\r\n\r\n            if (_listOfAdmins[i] == owner) {\r\n                containsSender = true;\r\n            }\r\n\r\n            for (uint256 j = i + 1; j < _listOfAdmins.length; ++j) {\r\n                // Admin list contains a duplicate address!\r\n                require(_listOfAdmins[i] != _listOfAdmins[j]);\r\n            }\r\n        }\r\n\r\n        // Admin list does not contain the creators address!\r\n        require(containsSender);\r\n        _;\r\n    }\r\n\r\n    /// @dev If the list of admins is verified, the global variable admins is set to equal the _listOfAdmins.\r\n    /// throws an exception if _listOfAdmins is < 1.\r\n    /// @param _listOfAdmins the list of admin addresses for the new pool.\r\n    function createAdminsForPool(\r\n        address[] _listOfAdmins\r\n    )\r\n        internal\r\n        isValidAdminsList(_listOfAdmins)\r\n    {\r\n        admins = _listOfAdmins;\r\n    }\r\n}\r\n\r\n\r\n// @title State configurations for Pool.sol contracts.\r\ncontract State is Admin {\r\n    enum PoolState{\r\n        // @dev Pool is accepting ETH. Users can refund themselves in this state.\r\n        OPEN,\r\n\r\n        // @dev Pool is closed and the funds are locked. No user refunds allowed.\r\n        CLOSED,\r\n\r\n        // @dev ETH is transferred out and the funds are locked. No refunds can be processed.\r\n        // State cannot be re-opened.\r\n        AWAITING_TOKENS,\r\n\r\n        // @dev Available tokens are claimable by users.\r\n        COMPLETED,\r\n\r\n        // @dev Eth can be refunded to all wallets. State is final.\r\n        CANCELLED\r\n    }\r\n\r\n    event PoolIsOpen ();\r\n    event PoolIsClosed ();\r\n    event PoolIsAwaitingTokens ();\r\n    event PoolIsCompleted ();\r\n    event PoolIsCancelled ();\r\n\r\n    PoolState public state;\r\n\r\n    /// @dev Verifies the pool is in the OPEN state.\r\n    modifier isOpen() {\r\n        // Pool is not set to open!\r\n        require(state == PoolState.OPEN);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the pool is in the CLOSED state.\r\n    modifier isClosed() {\r\n        // Pool is not closed!\r\n        require(state == PoolState.CLOSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the pool is in the OPEN or CLOSED state.\r\n    modifier isOpenOrClosed() {\r\n        // Pool is not cancelable!\r\n        require(state == PoolState.OPEN || state == PoolState.CLOSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the pool is CANCELLED.\r\n    modifier isCancelled() {\r\n        // Pool is not cancelled!\r\n        require(state == PoolState.CANCELLED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the user is able to call a refund.\r\n    modifier isUserRefundable() {\r\n        // Pool is not user refundable!\r\n        require(state == PoolState.OPEN || state == PoolState.CANCELLED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies an admin is able to call a refund.\r\n    modifier isAdminRefundable() {\r\n        // Pool is not admin refundable!\r\n        require(state == PoolState.OPEN || state == PoolState.CLOSED || state == PoolState.CANCELLED);  // solium-disable-line max-len\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the pool is in the COMPLETED or AWAITING_TOKENS state.\r\n    modifier isAwaitingOrCompleted() {\r\n        // Pool is not awaiting or completed!\r\n        require(state == PoolState.COMPLETED || state == PoolState.AWAITING_TOKENS);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the pool is in the COMPLETED state.\r\n    modifier isCompleted() {\r\n        // Pool is not completed!\r\n        require(state == PoolState.COMPLETED);\r\n        _;\r\n    }\r\n\r\n    /// @notice Allows the admin to set the state of the pool to OPEN.\r\n    /// @dev Requires that the sender is an admin, and the pool is currently CLOSED.\r\n    function setPoolToOpen() public isAdmin isClosed {\r\n        state = PoolState.OPEN;\r\n        emit PoolIsOpen();\r\n    }\r\n\r\n    /// @notice Allows the admin to set the state of the pool to CLOSED.\r\n    /// @dev Requires that the sender is an admin, and the contract is currently OPEN.\r\n    function setPoolToClosed() public isAdmin isOpen {\r\n        state = PoolState.CLOSED;\r\n        emit PoolIsClosed();\r\n    }\r\n\r\n    /// @notice Cancels the project and sets the state of the pool to CANCELLED.\r\n    /// @dev Requires that the sender is an admin, and the contract is currently OPEN or CLOSED.\r\n    function setPoolToCancelled() public isAdmin isOpenOrClosed {\r\n        state = PoolState.CANCELLED;\r\n        emit PoolIsCancelled();\r\n    }\r\n\r\n    /// @dev Sets the pool to AWAITING_TOKENS.\r\n    function setPoolToAwaitingTokens() internal {\r\n        state = PoolState.AWAITING_TOKENS;\r\n        emit PoolIsAwaitingTokens();\r\n    }\r\n\r\n    /// @dev Sets the pool to COMPLETED.\r\n    function setPoolToCompleted() internal {\r\n        state = PoolState.COMPLETED;\r\n        emit PoolIsCompleted();\r\n    }\r\n}\r\n\r\n\r\n/// @title Uint256 and boolean configurations for Pool.sol contracts.\r\ncontract Config is State {\r\n    enum OptionUint256{\r\n        MAX_ALLOCATION,\r\n        MIN_CONTRIBUTION,\r\n        MAX_CONTRIBUTION,\r\n\r\n        // Number of decimal places for the ADMIN_FEE_PERCENTAGE - capped at FEE_PERCENTAGE_DECIMAL_CAP.\r\n        ADMIN_FEE_PERCENT_DECIMALS,\r\n\r\n        // The percentage of admin fee relative to the amount of ADMIN_FEE_PERCENT_DECIMALS.\r\n        ADMIN_FEE_PERCENTAGE\r\n    }\r\n\r\n    enum OptionBool{\r\n        // True when the pool requires a whitelist.\r\n        HAS_WHITELIST,\r\n\r\n        // Uses ADMIN_FEE_PAYOUT_METHOD - true = tokens, false = ether.\r\n        ADMIN_FEE_PAYOUT_TOKENS\r\n    }\r\n\r\n    uint8 public constant  OPTION_UINT256_SIZE = 5;\r\n    uint8 public constant  OPTION_BOOL_SIZE = 2;\r\n    uint8 public constant  FEE_PERCENTAGE_DECIMAL_CAP = 5;\r\n\r\n    uint256 public maxAllocation;\r\n    uint256 public minContribution;\r\n    uint256 public maxContribution;\r\n    uint256 public adminFeePercentageDecimals;\r\n    uint256 public adminFeePercentage;\r\n    uint256 public feePercentageDivisor;\r\n\r\n    bool public hasWhitelist;\r\n    bool public adminFeePayoutIsToken;\r\n\r\n    /// @notice Sets the min and the max contribution configurations.\r\n    /// @dev This will not retroactively effect previous contributions.\r\n    /// This will only be applied to contributions moving forward.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - Max contribution is <= the max allocation\r\n    ///     - Minimum contribution is <= max contribution\r\n    ///     - The pool state is currently set to OPEN or CLOSED\r\n    /// @param _min The new minimum contribution for this pool.\r\n    /// @param _max The new maximum contribution for this pool.\r\n    function setMinMaxContribution(\r\n        uint256 _min,\r\n        uint256 _max\r\n    )\r\n        public\r\n        isAdmin\r\n        isOpenOrClosed\r\n    {\r\n        // Max contribution is greater than max allocation!\r\n        require(_max <= maxAllocation);\r\n        // Minimum contribution is greater than max contribution!\r\n        require(_min <= _max);\r\n\r\n        minContribution = _min;\r\n        maxContribution = _max;\r\n    }\r\n\r\n    /// @dev Validates and sets the configurations for the new pool.\r\n    /// Throws an exception when:\r\n    ///     - The config arrays are not the correct size\r\n    ///     - The maxContribution > maxAllocation\r\n    ///     - The minContribution > maxContribution\r\n    ///     - The adminFeePercentageDecimals > FEE_PERCENTAGE_DECIMAL_CAP\r\n    ///     - The adminFeePercentage >= 100\r\n    /// @param _configsUint contains all of the uint256 configurations.\r\n    /// The indexes are as follows:\r\n    ///     - MAX_ALLOCATION\r\n    ///     - MIN_CONTRIBUTION\r\n    ///     - MAX_CONTRIBUTION\r\n    ///     - ADMIN_FEE_PERCENT_DECIMALS\r\n    ///     - ADMIN_FEE_PERCENTAGE\r\n    /// @param _configsBool contains all of the  boolean configurations.\r\n    /// The indexes are as follows:\r\n    ///     - HAS_WHITELIST\r\n    ///     - ADMIN_FEE_PAYOUT\r\n    function createConfigsForPool(\r\n        uint256[] _configsUint,\r\n        bool[] _configsBool\r\n    )\r\n        internal\r\n    {\r\n        // Wrong number of uint256 configurations!\r\n        require(_configsUint.length == OPTION_UINT256_SIZE);\r\n        // Wrong number of boolean configurations!\r\n        require(_configsBool.length == OPTION_BOOL_SIZE);\r\n\r\n        // Sets the uint256 configurations.\r\n        maxAllocation = _configsUint[uint(OptionUint256.MAX_ALLOCATION)];\r\n        minContribution = _configsUint[uint(OptionUint256.MIN_CONTRIBUTION)];\r\n        maxContribution = _configsUint[uint(OptionUint256.MAX_CONTRIBUTION)];\r\n        adminFeePercentageDecimals = _configsUint[uint(OptionUint256.ADMIN_FEE_PERCENT_DECIMALS)];\r\n        adminFeePercentage = _configsUint[uint(OptionUint256.ADMIN_FEE_PERCENTAGE)];\r\n\r\n        // Sets the boolean values.\r\n        hasWhitelist = _configsBool[uint(OptionBool.HAS_WHITELIST)];\r\n        adminFeePayoutIsToken = _configsBool[uint(OptionBool.ADMIN_FEE_PAYOUT_TOKENS)];\r\n\r\n        // @dev Test the validity of _configsUint.\r\n        // Number of decimals used for admin fee greater than cap!\r\n        require(adminFeePercentageDecimals <= FEE_PERCENTAGE_DECIMAL_CAP);\r\n        // Max contribution is greater than max allocation!\r\n        require(maxContribution <= maxAllocation);\r\n        // Minimum contribution is greater than max contribution!\r\n        require(minContribution <= maxContribution);\r\n\r\n        // Verify the admin fee is less than 100%.\r\n        feePercentageDivisor = (10 ** adminFeePercentageDecimals).mul(100);\r\n        // Admin fee percentage is >= %100!\r\n        require(adminFeePercentage < feePercentageDivisor);\r\n    }\r\n}\r\n\r\n\r\n/// @title Whitelist configurations for Pool.sol contracts.\r\ncontract Whitelist is Config {\r\n    mapping(address => bool) public whitelist;\r\n\r\n    /// @dev Checks to see if the pool whitelist is enabled.\r\n    modifier isWhitelistEnabled() {\r\n        // Pool is not whitelisted!\r\n        require(hasWhitelist);\r\n        _;\r\n    }\r\n\r\n    /// @dev If the pool is whitelisted, verifies the user is whitelisted.\r\n    modifier canDeposit(address _user) {\r\n        if (hasWhitelist) {\r\n            // User is not whitelisted!\r\n            require(whitelist[_user] != false);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @notice Adds a list of addresses to this pools whitelist.\r\n    /// @dev Forwards a call to the internal method.\r\n    /// Requires:\r\n    ///     - Msg.sender is an admin\r\n    /// @param _users The list of addresses to add to the whitelist.\r\n    function addAddressesToWhitelist(address[] _users) public isAdmin {\r\n        addAddressesToWhitelistInternal(_users);\r\n    }\r\n\r\n    /// @dev The internal version of adding addresses to the whitelist.\r\n    /// This is called directly when initializing the pool from the poolParty.\r\n    /// Requires:\r\n    ///     - The white list configuration enabled\r\n    /// @param _users The list of addresses to add to the whitelist.\r\n    function addAddressesToWhitelistInternal(\r\n        address[] _users\r\n    )\r\n        internal\r\n        isWhitelistEnabled\r\n    {\r\n        // Cannot add an empty list to whitelist!\r\n        require(_users.length > 0);\r\n\r\n        for (uint256 i = 0; i < _users.length; ++i) {\r\n            whitelist[_users[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Pool contract functionality and configurations.\r\ncontract Pool is Whitelist {\r\n    /// @dev Address points to a boolean indicating if the address has participated in the pool.\r\n    /// Even if they have been refunded and balance is zero\r\n    /// This mapping internally helps us prevent duplicates from being pushed into swimmersList\r\n    /// instead of iterating and popping from the list each time a users balance reaches 0.\r\n    mapping(address => bool) public invested;\r\n\r\n    /// @dev Address points to the current amount of wei the address has contributed to the pool.\r\n    /// Even after the wei has been transferred out.\r\n    /// Because the claim tokens function uses swimmers balances to calculate their claimable tokens.\r\n    mapping(address => uint256) public swimmers;\r\n    mapping(address => uint256) public swimmerReimbursements;\r\n    mapping(address => mapping(address => uint256)) public swimmersTokensPaid;\r\n    mapping(address => uint256) public totalTokensDistributed;\r\n    mapping(address => bool) public adminFeePaid;\r\n\r\n    address[] public swimmersList;\r\n    address[] public tokenAddress;\r\n\r\n    address public poolPartyAddress;\r\n    uint256 public adminWeiFee;\r\n    uint256 public poolId;\r\n    uint256 public weiRaised;\r\n    uint256 public reimbursementTotal;\r\n\r\n    event AdminFeePayout(uint256 value);\r\n    event Deposit(address recipient, uint256 value);\r\n    event EtherTransferredOut(uint256 value);\r\n    event ProjectReimbursed(uint256 value);\r\n    event Refund(address recipient, uint256 value);\r\n    event ReimbursementClaimed(address recipient, uint256 value);\r\n    event TokenAdded(address tokenAddress);\r\n    event TokenRemoved(address tokenAddress);\r\n    event TokenClaimed(address recipient, uint256 value, address tokenAddress);\r\n\r\n    /// @dev Verifies the msg.sender is the owner.\r\n    modifier isOwner() {\r\n        // This is not the owner!\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Makes sure that the amount being transferred + the total amount previously sent\r\n    /// is compliant with the configurations for the existing pool.\r\n    modifier depositIsConfigCompliant() {\r\n        // Value sent must be greater than 0!\r\n        require(msg.value > 0);\r\n        uint256 totalRaised = weiRaised.add(msg.value);\r\n        uint256 amount = swimmers[msg.sender].add(msg.value);\r\n\r\n        // Contribution will cause pool to be greater than max allocation!\r\n        require(totalRaised <= maxAllocation);\r\n        // Contribution is greater than max contribution!\r\n        require(amount <= maxContribution);\r\n        // Contribution is less than minimum contribution!\r\n        require(amount >= minContribution);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the user currently has funds in the pool.\r\n    modifier userHasFundedPool(address _user) {\r\n        // User does not have funds in the pool!\r\n        require(swimmers[_user] > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Verifies the index parameters are valid/not out of bounds.\r\n    modifier isValidIndex(uint256 _startIndex, uint256 _numberOfAddresses) {\r\n        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));\r\n\r\n        // The starting index is out of the array bounds!\r\n        require(_startIndex < swimmersList.length);\r\n        // The end index is out of the array bounds!\r\n        require(endIndex < swimmersList.length);\r\n        _;\r\n    }\r\n\r\n    /// @notice Creates a new pool with the parameters as custom configurations.\r\n    /// @dev Creates a new pool where:\r\n    ///     - The creator of the pool will be the owner\r\n    ///     - _admins become administrators for the pool contract and are automatically\r\n    ///      added to whitelist, if it is enabled in the _configsBool\r\n    ///     - Pool is initialised with the state set to OPEN\r\n    /// @param _poolOwner The owner of the new pool.\r\n    /// @param _admins The list of admin addresses for the new pools. This list must include\r\n    /// the creator of the pool.\r\n    /// @param _configsUint Contains all of the uint256 configurations for the new pool.\r\n    ///     - MAX_ALLOCATION\r\n    ///     - MIN_CONTRIBUTION\r\n    ///     - MAX_CONTRIBUTION\r\n    ///     - ADMIN_FEE_PERCENT_DECIMALS\r\n    ///     - ADMIN_FEE_PERCENTAGE\r\n    /// @param _configsBool Contains all of the boolean configurations for the new pool.\r\n    ///     - HAS_WHITELIST\r\n    ///     - ADMIN_FEE_PAYOUT\r\n    /// @param _poolId The corresponding poolId.\r\n    constructor(\r\n        address _poolOwner,\r\n        address[] _admins,\r\n        uint256[] _configsUint,\r\n        bool[] _configsBool,\r\n        uint256  _poolId\r\n    )\r\n        public\r\n    {\r\n        owner = _poolOwner;\r\n        state = PoolState.OPEN;\r\n        poolPartyAddress = msg.sender;\r\n        poolId = _poolId;\r\n\r\n        createAdminsForPool(_admins);\r\n        createConfigsForPool(_configsUint, _configsBool);\r\n\r\n        if (hasWhitelist) {\r\n            addAddressesToWhitelistInternal(admins);\r\n        }\r\n\r\n        emit PoolIsOpen();\r\n    }\r\n\r\n    /// @notice The user sends Ether to the pool.\r\n    /// @dev Calls the deposit function on behalf of the msg.sender.\r\n    function() public payable {\r\n        deposit(msg.sender);\r\n    }\r\n\r\n    /// @notice Returns the array of admin addresses.\r\n    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty,\r\n    /// as the EVM will not allow contracts to return dynamically sized arrays.\r\n    /// @return Returns and instance of the admins array.\r\n    function getAdminAddressArray(\r\n    )\r\n        public\r\n        view\r\n        returns (address[] _arrayToReturn)\r\n    {\r\n        _arrayToReturn = admins;\r\n    }\r\n\r\n    /// @notice Returns the array of token addresses.\r\n    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty,\r\n    /// as the EVM will not allow contracts to return dynamically sized arrays.\r\n    /// @return Returns and instance of the tokenAddress array.\r\n    function getTokenAddressArray(\r\n    )\r\n        public\r\n        view\r\n        returns (address[] _arrayToReturn)\r\n    {\r\n        _arrayToReturn = tokenAddress;\r\n    }\r\n\r\n    /// @notice Returns the amount of tokens currently in this contract.\r\n    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty.\r\n    /// @return Returns the length of the tokenAddress arrau.\r\n    function getAmountOfTokens(\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _lengthOfTokens)\r\n    {\r\n        _lengthOfTokens = tokenAddress.length;\r\n    }\r\n\r\n    /// @notice Returns the array of swimmers addresses.\r\n    /// @dev This is used specifically for the DAPP portion of PoolParty,\r\n    /// as the EVM will not allow contracts to return dynamically sized arrays.\r\n    /// @return Returns and instance of the swimmersList array.\r\n    function getSwimmersListArray(\r\n    )\r\n        public\r\n        view\r\n        returns (address[] _arrayToReturn)\r\n    {\r\n        _arrayToReturn = swimmersList;\r\n    }\r\n\r\n    /// @notice Returns the amount of swimmers currently in this contract.\r\n    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty.\r\n    /// @return Returns the length of the swimmersList array.\r\n    function getAmountOfSwimmers(\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _lengthOfSwimmers)\r\n    {\r\n        _lengthOfSwimmers = swimmersList.length;\r\n    }\r\n\r\n    /// @notice Deposit Ether where the contribution is credited to the address specified in the parameter.\r\n    /// @dev Allows a user to deposit on the behalf of someone else. Emits a Deposit event on success.\r\n    /// Requires:\r\n    ///     - The pool state is set to OPEN\r\n    ///     - The amount is > 0\r\n    ///     - The amount complies with the configurations of the pool\r\n    ///     - If the whitelist configuration is enabled, verify the _user can deposit\r\n    /// @param _user The address that will be credited with the deposit.\r\n    function deposit(\r\n        address _user\r\n    )\r\n        public\r\n        payable\r\n        isOpen\r\n        depositIsConfigCompliant\r\n        canDeposit(_user)\r\n    {\r\n        if (!invested[_user]) {\r\n            swimmersList.push(_user);\r\n            invested[_user] = true;\r\n        }\r\n\r\n        weiRaised = weiRaised.add(msg.value);\r\n        swimmers[_user] = swimmers[_user].add(msg.value);\r\n\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Process a refund.\r\n    /// @dev Allows refunds in the contract. Calls the internal refund function.\r\n    /// Requires:\r\n    ///     - The state of the pool is either OPEN or CANCELLED\r\n    ///     - The user currently has funds in the pool\r\n    function refund() public isUserRefundable userHasFundedPool(msg.sender) {\r\n        processRefundInternal(msg.sender);\r\n    }\r\n\r\n    /// @notice This triggers a refund event for a subset of users.\r\n    /// @dev Uses the internal refund function.\r\n    /// Requires:\r\n    ///     - The pool state is currently set to CANCELLED\r\n    ///     - The indexes are within the bounds of the swimmersList\r\n    /// @param _startIndex The starting index for the subset.\r\n    /// @param _numberOfAddresses The number of addresses to include past the starting index.\r\n    function refundManyAddresses(\r\n        uint256 _startIndex,\r\n        uint256 _numberOfAddresses\r\n    )\r\n        public\r\n        isCancelled\r\n        isValidIndex(_startIndex, _numberOfAddresses)\r\n    {\r\n        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));\r\n\r\n        for (uint256 i = _startIndex; i <= endIndex; ++i) {\r\n            address user = swimmersList[i];\r\n\r\n            if (swimmers[user] > 0) {\r\n                processRefundInternal(user);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice claims available tokens.\r\n    /// @dev Allows the user to claim their available tokens.\r\n    /// Requires:\r\n    ///     - The msg.sender has funded the pool\r\n    function claim() public {\r\n        claimAddress(msg.sender);\r\n    }\r\n\r\n    /// @notice Process a claim function for a specified address.\r\n    /// @dev Allows the user to claim tokens on behalf of someone else.\r\n    /// Requires:\r\n    ///     - The _address has funded the pool\r\n    ///     - The pool is in the completed state\r\n    /// @param _address The address for which tokens should be redeemed.\r\n    function claimAddress(\r\n        address _address\r\n    )\r\n        public\r\n        isCompleted\r\n        userHasFundedPool(_address)\r\n    {\r\n        for (uint256 i = 0; i < tokenAddress.length; ++i) {\r\n            ERC20Basic token = ERC20Basic(tokenAddress[i]);\r\n            uint256 poolTokenBalance = token.balanceOf(this);\r\n\r\n            payoutTokensInternal(_address, poolTokenBalance, token);\r\n        }\r\n    }\r\n\r\n    /// @notice Distribute available tokens to a subset of users.\r\n    /// @dev Allows anyone to call claim on a specified series of addresses.\r\n    /// Requires:\r\n    ///     - The indexes are within the bounds of the swimmersList\r\n    /// @param _startIndex The starting index for the subset.\r\n    /// @param _numberOfAddresses The number of addresses to include past the starting index.\r\n    function claimManyAddresses(\r\n        uint256 _startIndex,\r\n        uint256 _numberOfAddresses\r\n    )\r\n        public\r\n        isValidIndex(_startIndex, _numberOfAddresses)\r\n    {\r\n        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));\r\n\r\n        claimAddressesInternal(_startIndex, endIndex);\r\n    }\r\n\r\n    /// @notice Process a reimbursement claim.\r\n    /// @dev Allows the msg.sender to claim a reimbursement\r\n    /// Requires:\r\n    ///     - The msg.sender has a reimbursement to withdraw\r\n    ///     - The pool state is currently set to AwaitingOrCompleted\r\n    function reimbursement() public {\r\n        claimReimbursement(msg.sender);\r\n    }\r\n\r\n    /// @notice Process a reimbursement claim for a specified address.\r\n    /// @dev Calls the internal method responsible for processing a reimbursement.\r\n    /// Requires:\r\n    ///     - The specified user has a reimbursement to withdraw\r\n    ///     - The pool state is currently set to AwaitingOrCompleted\r\n    /// @param _user The user having the reimbursement processed.\r\n    function claimReimbursement(\r\n        address _user\r\n    )\r\n        public\r\n        isAwaitingOrCompleted\r\n        userHasFundedPool(_user)\r\n    {\r\n        processReimbursementInternal(_user);\r\n    }\r\n\r\n    /// @notice Process a reimbursement claim for subset of addresses.\r\n    /// @dev Allows anyone to call claimReimbursement on a specified series of address indexes.\r\n    /// Requires:\r\n    ///     - The pool state is currently set to AwaitingOrCompleted\r\n    ///     - The indexes are within the bounds of the swimmersList\r\n    /// @param _startIndex The starting index for the subset.\r\n    /// @param _numberOfAddresses The number of addresses to include past the starting index.\r\n    function claimManyReimbursements(\r\n        uint256 _startIndex,\r\n        uint256 _numberOfAddresses\r\n    )\r\n        public\r\n        isAwaitingOrCompleted\r\n        isValidIndex(_startIndex, _numberOfAddresses)\r\n    {\r\n        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));\r\n\r\n        for (uint256 i = _startIndex; i <= endIndex; ++i) {\r\n            address user = swimmersList[i];\r\n\r\n            if (swimmers[user] > 0) {\r\n                processReimbursementInternal(user);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Set a new token address where users can redeem ERC20 tokens.\r\n    /// @dev Adds a new ERC20 address to the tokenAddress array.\r\n    /// Sets the pool state to COMPLETED if it is not already.\r\n    /// Crucial that only valid ERC20 addresses be added with this function.\r\n    /// In the event a bad one is entered, it can be removed with the removeToken() method.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - The pool state is set to either AWAITING_TOKENS or COMPLETED\r\n    ///     - The token address has not previously been added\r\n    /// @param _tokenAddress The ERC20 address users can redeem from.\r\n    function addToken(\r\n        address _tokenAddress\r\n    )\r\n        public\r\n        isAdmin\r\n        isAwaitingOrCompleted\r\n    {\r\n        if (state != PoolState.COMPLETED) {\r\n            setPoolToCompleted();\r\n        }\r\n\r\n        for (uint256 i = 0; i < tokenAddress.length; ++i) {\r\n            // The address has already been added!\r\n            require(tokenAddress[i] != _tokenAddress);\r\n        }\r\n\r\n        // @dev This verifies the address we are trying to add contains an ERC20 address.\r\n        // This does not completely protect from having a bad address added, but it will reduce the likelihood.\r\n        // Any address that does not contain a balanceOf() method cannot be added.\r\n        ERC20Basic token = ERC20Basic(_tokenAddress);\r\n\r\n        // The address being added is not an ERC20!\r\n        require(token.balanceOf(this) >= 0);\r\n\r\n        tokenAddress.push(_tokenAddress);\r\n\r\n        emit TokenAdded(_tokenAddress);\r\n    }\r\n\r\n    /// @notice Remove a token address from the list of token addresses.\r\n    /// @dev Removes a token address. This prevents users from calling claim on it. Does not preserve order.\r\n    /// If it reduces the tokenAddress length to zero, then the state is set back to awaiting tokens.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - The pool state is set to COMPLETED\r\n    ///     - The token address is located in the list.\r\n    /// @param _tokenAddress The address to remove.\r\n    function removeToken(address _tokenAddress) public isAdmin isCompleted {\r\n        for (uint256 i = 0; i < tokenAddress.length; ++i) {\r\n            if (tokenAddress[i] == _tokenAddress) {\r\n                tokenAddress[i] = tokenAddress[tokenAddress.length - 1];\r\n                delete tokenAddress[tokenAddress.length - 1];\r\n                tokenAddress.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (tokenAddress.length == 0) {\r\n            setPoolToAwaitingTokens();\r\n        }\r\n\r\n        emit TokenRemoved(_tokenAddress);\r\n    }\r\n\r\n    /// @notice Removes a user from the whitelist and processes a refund.\r\n    /// @dev Removes a user from the whitelist and their ability to contribute to the pool.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - The pool state is currently set to OPEN or CLOSED or CANCELLED\r\n    ///     - The pool has enabled whitelist functionality\r\n    /// @param _address The address for which the refund is processed and removed from whitelist.\r\n    function removeAddressFromWhitelistAndRefund(\r\n        address _address\r\n    )\r\n        public\r\n        isWhitelistEnabled\r\n        canDeposit(_address)\r\n    {\r\n        whitelist[_address] = false;\r\n        refundAddress(_address);\r\n    }\r\n\r\n    /// @notice Refund a given address for all the Ether they have contributed.\r\n    /// @dev Processes a refund for a given address by calling the internal refund function.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - The pool state is currently set to OPEN or CLOSED or CANCELLED\r\n    /// @param _address The address for which the refund is processed.\r\n    function refundAddress(\r\n        address _address\r\n    )\r\n        public\r\n        isAdmin\r\n        isAdminRefundable\r\n        userHasFundedPool(_address)\r\n    {\r\n        processRefundInternal(_address);\r\n    }\r\n\r\n    /// @notice Provides a refund for the entire list of swimmers\r\n    /// to distribute at a pro-rata rate via the reimbursement functions.\r\n    /// @dev Refund users after the pool state is set to AWAITING_TOKENS or COMPLETED.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - The state is either Awaiting or Completed\r\n    function projectReimbursement(\r\n    )\r\n        public\r\n        payable\r\n        isAdmin\r\n        isAwaitingOrCompleted\r\n    {\r\n        reimbursementTotal = reimbursementTotal.add(msg.value);\r\n\r\n        emit ProjectReimbursed(msg.value);\r\n    }\r\n\r\n    /// @notice Sets the maximum allocation for the contract.\r\n    /// @dev Set the uint256 configuration for maxAllocation to the _newMax parameter.\r\n    /// If the amount of weiRaised so far is already past the limit,\r\n    //  no further deposits can be made until the weiRaised is reduced\r\n    /// Possibly by refunding some users.\r\n    /// Requires:\r\n    ///     - The msg.sender is an admin\r\n    ///     - The pool state is currently set to OPEN or CLOSED\r\n    ///     - The _newMax must be >= max contribution\r\n    /// @param _newMax The new maximum allocation for this pool contract.\r\n    function setMaxAllocation(uint256 _newMax) public isAdmin isOpenOrClosed {\r\n        // Max Allocation cannot be below Max contribution!\r\n        require(_newMax >= maxContribution);\r\n\r\n        maxAllocation = _newMax;\r\n    }\r\n\r\n    /// @notice Transfers the Ether out of the contract to the given address parameter.\r\n    /// @dev If admin fee is > 0, then call payOutAdminFee to distribute the admin fee.\r\n    /// Sets the pool state to AWAITING_TOKENS.\r\n    /// Requires:\r\n    ///     - The pool state must be currently set to CLOSED\r\n    ///     - msg.sender is the owner\r\n    /// @param _contractAddress The address to send all Ether in the pool.\r\n    function transferWei(address _contractAddress) public isOwner isClosed {\r\n        uint256 weiForTransfer = weiTransferCalculator();\r\n\r\n        if (adminFeePercentage > 0) {\r\n            weiForTransfer = payOutAdminFee(weiForTransfer);\r\n        }\r\n\r\n        // No Ether to transfer!\r\n        require(weiForTransfer > 0);\r\n        _contractAddress.transfer(weiForTransfer);\r\n\r\n        setPoolToAwaitingTokens();\r\n\r\n        emit EtherTransferredOut(weiForTransfer);\r\n    }\r\n\r\n    /// @dev Calculates the amount of wei to be transferred out of the contract.\r\n    /// Adds the difference to the refund total for participants to withdraw pro-rata from.\r\n    /// @return The difference between amount raised and the max allocation.\r\n    function weiTransferCalculator() internal returns (uint256 _amountOfWei) {\r\n        if (weiRaised > maxAllocation) {\r\n            _amountOfWei = maxAllocation;\r\n            reimbursementTotal = reimbursementTotal.add(weiRaised.sub(maxAllocation));\r\n        } else {\r\n            _amountOfWei = weiRaised;\r\n        }\r\n    }\r\n\r\n    /// @dev Payout the owner of this contract, based on the adminFeePayoutIsToken boolean.\r\n    ///  - adminFeePayoutIsToken == true -> The payout is in tokens.\r\n    /// Each member will have their portion deducted from their contribution before claiming tokens.\r\n    ///  - adminFeePayoutIsToken == false -> The adminFee is deducted from the total amount of wei\r\n    /// that would otherwise be transferred out of the contract.\r\n    /// @return The amount of wei that will be transferred out of this function.\r\n    function payOutAdminFee(\r\n        uint256 _weiTotal\r\n    )\r\n        internal\r\n        returns (uint256 _weiForTransfer)\r\n    {\r\n        adminWeiFee = _weiTotal.mul(adminFeePercentage).div(feePercentageDivisor);\r\n\r\n        if (adminFeePayoutIsToken) {\r\n            // @dev In the event the owner has wei currently contributed to the pool,\r\n            // their fee is collected before they get credited on line 420.\r\n            if (swimmers[owner] > 0) {\r\n                collectAdminFee(owner);\r\n            } else {\r\n                // @dev In the event the owner has never contributed to the pool,\r\n                // they have their address added so they can be iterated over in the claim all method.\r\n                if (!invested[owner]) {\r\n                    swimmersList.push(owner);\r\n                    invested[owner] = true;\r\n                }\r\n\r\n                adminFeePaid[owner] = true;\r\n            }\r\n\r\n            // @dev The admin gets credited for his fee upfront.\r\n            // Then the first time a swimmer claims their tokens, they will have their portion\r\n            // of the fee deducted from their contribution, via the collectAdminFee() method.\r\n            swimmers[owner] = swimmers[owner].add(adminWeiFee);\r\n            _weiForTransfer = _weiTotal;\r\n        } else {\r\n            _weiForTransfer = _weiTotal.sub(adminWeiFee);\r\n\r\n            if (adminWeiFee > 0) {\r\n                owner.transfer(adminWeiFee);\r\n\r\n                emit AdminFeePayout(adminWeiFee);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev The internal claim function for distributing available tokens.\r\n    /// Goes through each of the token addresses set by the addToken function,\r\n    /// and calculates a pro-rata rate for each pool participant to be distributed.\r\n    /// In the event that a bad token address is present, and the transfer function fails,\r\n    /// this method cannot be processed until\r\n    /// the bad address has been removed via the removeToken() method.\r\n    /// Requires:\r\n    ///     - The pool state must be set to COMPLETED\r\n    ///     - The tokenAddress array must contain ERC20 compliant addresses.\r\n    /// @param _startIndex The index we start iterating from.\r\n    /// @param _endIndex The last index we process.\r\n    function claimAddressesInternal(\r\n        uint256 _startIndex,\r\n        uint256 _endIndex\r\n    )\r\n        internal\r\n        isCompleted\r\n    {\r\n        for (uint256 i = 0; i < tokenAddress.length; ++i) {\r\n            ERC20Basic token = ERC20Basic(tokenAddress[i]);\r\n            uint256 tokenBalance = token.balanceOf(this);\r\n\r\n            for (uint256 j = _startIndex; j <= _endIndex && tokenBalance > 0; ++j) {\r\n                address user = swimmersList[j];\r\n\r\n                if (swimmers[user] > 0) {\r\n                    payoutTokensInternal(user, tokenBalance, token);\r\n                }\r\n\r\n                tokenBalance = token.balanceOf(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates the amount of tokens to be paid out for a given user.\r\n    /// Emits a TokenClaimed event upon success.\r\n    /// @param _user The user claiming tokens.\r\n    /// @param _poolBalance The current balance the pool has for the given token.\r\n    /// @param _token The token currently being calculated for.\r\n    function payoutTokensInternal(\r\n        address _user,\r\n        uint256 _poolBalance,\r\n        ERC20Basic _token\r\n    )\r\n        internal\r\n    {\r\n        // @dev The first time a user tries to claim tokens,\r\n        // they will have the admin fee subtracted from their contribution.\r\n        // This is the pro-rata portion added to swimmers[owner], in the payoutAdminFee() function.\r\n        if (!adminFeePaid[_user] && adminFeePayoutIsToken && adminFeePercentage > 0) {\r\n            collectAdminFee(_user);\r\n        }\r\n\r\n        // The total amount of tokens the contract has received.\r\n        uint256 totalTokensReceived = _poolBalance.add(totalTokensDistributed[_token]);\r\n\r\n        uint256 tokensOwedTotal = swimmers[_user].mul(totalTokensReceived).div(weiRaised);\r\n        uint256 tokensPaid = swimmersTokensPaid[_user][_token];\r\n        uint256 tokensToBePaid = tokensOwedTotal.sub(tokensPaid);\r\n\r\n        if (tokensToBePaid > 0) {\r\n            swimmersTokensPaid[_user][_token] = tokensOwedTotal;\r\n            totalTokensDistributed[_token] = totalTokensDistributed[_token].add(tokensToBePaid);\r\n\r\n            // Token transfer failed!\r\n            require(_token.transfer(_user, tokensToBePaid));\r\n\r\n            emit TokenClaimed(_user, tokensToBePaid, _token);\r\n        }\r\n    }\r\n\r\n    /// @dev Processes a reimbursement claim for a given address.\r\n    /// Emits a ReimbursementClaimed event for each successful iteration.\r\n    /// @param _user The address being processed.\r\n    function processReimbursementInternal(address _user) internal {\r\n        // @dev The first time a user tries to claim tokens or a Reimbursement,\r\n        // they will have the admin fee subtracted from their contribution.\r\n        // This is the pro-rata portion added to swimmers[owner], in the payoutAdminFee() function.\r\n        if (!adminFeePaid[_user] && adminFeePayoutIsToken && adminFeePercentage > 0) {\r\n            collectAdminFee(_user);\r\n        }\r\n\r\n        // @dev Using integer division, there is the potential to truncate the result.\r\n        // The effect is negligible because it is calculated in wei.\r\n        // There will be dust, but the cost of gas for transferring it out, costs more than it is worth.\r\n        uint256 amountContributed = swimmers[_user];\r\n        uint256 totalReimbursement = reimbursementTotal.mul(amountContributed).div(weiRaised);\r\n        uint256 alreadyReimbursed = swimmerReimbursements[_user];\r\n\r\n        uint256 reimbursementAvailable = totalReimbursement.sub(alreadyReimbursed);\r\n\r\n        if (reimbursementAvailable > 0) {\r\n            swimmerReimbursements[_user] = swimmerReimbursements[_user].add(reimbursementAvailable);\r\n            _user.transfer(reimbursementAvailable);\r\n\r\n            emit ReimbursementClaimed(_user, reimbursementAvailable);\r\n        }\r\n    }\r\n\r\n    /// @dev Subtracts the admin fee from the user's contribution.\r\n    /// This should only happen once per user.\r\n    /// Requires:\r\n    ///     - This is the first time a user has tried to claim tokens or a reimbursement.\r\n    /// @param _user The user who is paying the admin fee.\r\n    function collectAdminFee(address _user) internal {\r\n        uint256 individualFee = swimmers[_user].mul(adminFeePercentage).div(feePercentageDivisor);\r\n\r\n        // @dev adding 1 to the fee is for rounding errors.\r\n        // This will result in some left over dust, but it will cost more to transfer, than gained.\r\n        individualFee = individualFee.add(1);\r\n        swimmers[_user] = swimmers[_user].sub(individualFee);\r\n\r\n        // Indicates the user has paid their fee.\r\n        adminFeePaid[_user] = true;\r\n    }\r\n\r\n    /// @dev Processes a refund for a given address.\r\n    /// Emits a Refund event for each successful iteration.\r\n    /// @param _user The address for which the refund is processed.\r\n    function processRefundInternal(address _user) internal {\r\n        uint256 amount = swimmers[_user];\r\n\r\n        swimmers[_user] = 0;\r\n        weiRaised = weiRaised.sub(amount);\r\n        _user.transfer(amount);\r\n\r\n        emit Refund(_user, amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPoolId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admins\",\"type\":\"address[]\"},{\"name\":\"_configsUint\",\"type\":\"uint256[]\"},{\"name\":\"_configsBool\",\"type\":\"bool[]\"}],\"name\":\"createPool\",\"outputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_\",\"type\":\"address\"},{\"name\":\"value_\",\"type\":\"uint256\"},{\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PoolParty","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1c0a3e6c86fcd79bb694cb18a96903250b8a1a1f920bccf0eaaa031d871a3f2e"}]}