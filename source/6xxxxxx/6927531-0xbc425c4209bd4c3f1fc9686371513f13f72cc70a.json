{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n *  URA Mraket contract\r\n *  web site: ura.market\r\n *\r\n *  URA.market  is a decentralized trade and investment platform, created by Ethereum net.\r\n *\r\n *  URA.market is controlled without human participation,\r\n *  and by automated smart contracts with refusal from ownership activated function.\r\n *\r\n * Gas limit: 150 000 (only the first time, average ~ 50 000)\r\n * Gas price: https://ethgasstation.info/\r\n *\r\n * github: https://github.com/bigdaddy777/URA-MARKET-COIN\r\n */\r\n\r\n\r\nlibrary ToAddress {\r\n    function toAddr(uint _source) internal pure returns(address payable) {\r\n        return address(_source);\r\n    }\r\n\r\n    function toAddr(bytes memory _source) internal pure returns(address payable addr) {\r\n        // solium-disable security/no-inline-assembly\r\n        assembly { addr := mload(add(_source,0x14)) }\r\n        return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n        // solium-disable security/no-inline-assembly\r\n        uint256 length;\r\n        assembly { length := extcodesize(addr) }\r\n        return length == 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// @wiki: https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function tokensOwner() public view returns (uint256);\r\n    function contracBalance() public view returns (uint256);\r\n    function balanceOf(address _tokenOwner) public view returns (uint256 balanceOwner);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event EtherTransfer(address indexed from, address indexed to, uint256 etherAmount);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol.\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20 is ERC20Interface {\r\n    using SafeMath for uint;\r\n    using ToAddress for *;\r\n\r\n    string constant public symbol = \"URA\";\r\n    string constant public  name = \"URA market coin\";\r\n    uint8 constant internal decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get balance on contract\r\n    // ------------------------------------------------------------------------\r\n    function contracBalance() public view returns (uint256 contractBalance) {\r\n        contractBalance = address(this).balance;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address _tokenOwner) public view returns (uint256 balanceOwner) {\r\n        return balances[_tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Addon shows caller tokens.\r\n    // ------------------------------------------------------------------------\r\n    function tokensOwner() public view returns (uint256 tokens) {\r\n        tokens = balances[msg.sender];\r\n    }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Bookeeper contract that holds the amount of dividents in Ether.\r\n// ----------------------------------------------------------------------------\r\ncontract Dividend is ERC20 {\r\n\r\n    uint8 public constant dividendsCosts = 10; // Dividends 10%.\r\n    uint16 public constant day = 6000;\r\n    uint256 public dividendes; // storage for Dividends.\r\n\r\n    mapping(address => uint256) bookKeeper;\r\n\r\n\r\n    event SendOnDividend(address indexed customerAddress, uint256 dividendesAmount);\r\n    event WithdrawDividendes(address indexed customerAddress, uint256 dividendesAmount);\r\n\r\n    constructor() public {}\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Withdraw dividendes.\r\n    // ------------------------------------------------------------------------\r\n    function withdrawDividendes() external payable returns(bool success) {\r\n        require(msg.sender.isNotContract(),\r\n                \"the contract can not hold tokens\");\r\n\r\n        uint256 _tokensOwner = balanceOf(msg.sender);\r\n\r\n        require(_tokensOwner > 0, \"cannot pass 0 value\");\r\n        require(bookKeeper[msg.sender] > 0,\r\n                \"to withdraw dividends, please wait\");\r\n\r\n        uint256 _dividendesAmount = dividendesCalc(_tokensOwner);\r\n\r\n        require(_dividendesAmount > 0, \"dividendes amount > 0\");\r\n\r\n        bookKeeper[msg.sender] = block.number;\r\n        dividendes = dividendes.sub(_dividendesAmount);\r\n\r\n        msg.sender.transfer(_dividendesAmount);\r\n\r\n        emit WithdrawDividendes(msg.sender, _dividendesAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get value of dividendes.\r\n    // ------------------------------------------------------------------------\r\n    function dividendesOf(address _owner)\r\n        public\r\n        view\r\n        returns(uint256 dividendesAmount) {\r\n        uint256 _tokens = balanceOf(_owner);\r\n\r\n        dividendesAmount = dividendesCalc(_tokens);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Count percent of dividendes from ether.\r\n    // ------------------------------------------------------------------------\r\n    function onDividendes(uint256 _value, uint8 _dividendsCosts)\r\n        internal\r\n        pure\r\n        returns(uint256 forDividendes) {\r\n        return _value.mul(_dividendsCosts).div(100);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get number of dividendes in ether\r\n    // * @param _tokens: Amount customer tokens.\r\n    // * @param _dividendesPercent: Customer tokens percent in 10e18.\r\n    // *\r\n    // * @retunrs dividendesReceived: amount of dividendes in ether.\r\n    // ------------------------------------------------------------------------\r\n    function dividendesCalc(uint256 _tokensAmount)\r\n        internal\r\n        view\r\n        returns(uint256 dividendesReceived) {\r\n        if (_tokensAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _tokens = _tokensAmount.mul(10e18);\r\n        uint256 _dividendesPercent = dividendesPercent(_tokens); // Get % from tokensOwner.\r\n\r\n        dividendesReceived = dividendes.mul(_dividendesPercent).div(100);\r\n        dividendesReceived = dividendesReceived.div(10e18);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get number of dividendes in percent\r\n    // * @param _tokens: Amount of (tokens * 10e18).\r\n    // * returns: tokens % in 10e18.\r\n    // ------------------------------------------------------------------------\r\n    function dividendesPercent(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256 percent) {\r\n        if (_tokens == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _interest = accumulatedInterest();\r\n\r\n        if (_interest > 100) {\r\n            _interest = 100;\r\n        }\r\n\r\n        percent = _tokens.mul(_interest).div(totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Block value when buying.\r\n    // ------------------------------------------------------------------------\r\n    function accumulatedInterest() private view returns(uint256 interest) {\r\n        if (bookKeeper[msg.sender] == 0) {\r\n            interest = 0;\r\n        } else {\r\n            interest = block.number.sub(bookKeeper[msg.sender]).div(day);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// URA.market main contract.\r\n// ----------------------------------------------------------------------------\r\ncontract URA is ERC20, Dividend {\r\n\r\n    // The initial cost of the token, it can not be less. //\r\n    uint128 constant tokenPriceInit = 0.00000000001 ether;\r\n    uint128 public constant limiter = 15 ether;\r\n\r\n    uint8 public constant advertisingCosts = 5; // 5% for transfer advertising.\r\n    uint8 public constant forReferralCosts = 2; // 2% for transfer to referral.\r\n    uint8 public constant forWithdrawCosts = 3; // 3% for the withdraw of tokens.\r\n\r\n    // For advertising. //\r\n    address payable constant advertising = 0x4d332E1f9d55d9B89dc2a8457B693Beaa7b36b2e;\r\n\r\n\r\n    event WithdrawTokens(address indexed customerAddress, uint256 ethereumWithdrawn);\r\n    event ReverseAccess(uint256 etherAmount);\r\n    event ForReferral(uint256 etherAmount);\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public { }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Purchase\r\n    // * @param _reverseAccessOfLimiter: Excess value.\r\n    // * @param _aTokenPrice: Price For one token.\r\n    // * @param _forAdvertising: Advertising victim.\r\n    // * @param _forDividendes: Dividend sacrifice.\r\n    // * @param _amountOfTokens: Ether to tokens amount.\r\n    // * @param _reverseAccess: Change remainder in ether.\r\n    // ------------------------------------------------------------------------\r\n    function () external payable {\r\n        require(msg.sender.isNotContract(),\r\n                \"the contract can not hold tokens\");\r\n\r\n        address payable _referralAddress = msg.data.toAddr();\r\n        uint256 _incomingEthereum = msg.value;\r\n\r\n        uint256 _forReferral;\r\n        uint256 _reverseAccessOfLimiter;\r\n\r\n        if (_incomingEthereum > limiter) {\r\n            _reverseAccessOfLimiter = _incomingEthereum.sub(limiter);\r\n            _incomingEthereum = limiter;\r\n        }\r\n\r\n        uint256 _aTokenPrice = tokenPrice();\r\n        uint256 _dividendesOwner = dividendesOf(msg.sender);\r\n        uint256 _forAdvertising = _incomingEthereum.mul(advertisingCosts).div(100);\r\n        uint256 _forDividendes = onDividendes(_incomingEthereum, dividendsCosts);\r\n\r\n        if (_referralAddress != address(0)) {\r\n            _forReferral = _incomingEthereum.mul(forReferralCosts).div(100);\r\n            _forAdvertising = _forAdvertising.sub(_forReferral);\r\n        }\r\n\r\n        _incomingEthereum = _incomingEthereum.sub(\r\n            _forDividendes\r\n        ).sub(\r\n            _forAdvertising\r\n        ).sub(\r\n            _forReferral\r\n        );\r\n\r\n        require(_incomingEthereum >= _aTokenPrice,\r\n                \"the amount of ether is not enough\");\r\n\r\n        (uint256 _amountOfTokens,\r\n         uint256 _reverseAccess) = ethereumToTokens(_incomingEthereum, _aTokenPrice);\r\n\r\n        advertising.transfer(_forAdvertising);\r\n\r\n        _reverseAccessOfLimiter = _reverseAccessOfLimiter.add(_reverseAccess);\r\n\r\n        if (_reverseAccessOfLimiter > 0) {\r\n            // If there are leftovers, then return to customer. //\r\n            msg.sender.transfer(_reverseAccessOfLimiter);\r\n            emit ReverseAccess(_reverseAccessOfLimiter);\r\n        }\r\n        if (_forReferral > 0 && _referralAddress != address(0)) {\r\n            _referralAddress.transfer(_forReferral);\r\n            emit ForReferral(_forReferral);\r\n        }\r\n        if (_dividendesOwner > _aTokenPrice) {\r\n            reinvest();\r\n        }\r\n\r\n        bookKeeper[msg.sender] = block.number;\r\n        balances[msg.sender] = balances[msg.sender].add(_amountOfTokens);\r\n        totalSupply = totalSupply.add(_amountOfTokens);\r\n        dividendes = dividendes.add(_forDividendes);\r\n\r\n        emit EtherTransfer(msg.sender, advertising, _forAdvertising);\r\n        emit Transfer(address(0), msg.sender, _amountOfTokens);\r\n        emit SendOnDividend(msg.sender, _forDividendes);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Increment for token cost\r\n    // - Dynamic property that is responsible for\r\n    // - the rise and fall of the price of the token.\r\n    // ------------------------------------------------------------------------\r\n    function tokenPrice() public view returns(uint256 priceForToken) {\r\n        uint256 _contracBalance = contracBalance();\r\n\r\n        if (totalSupply == 0 || _contracBalance == 0) {\r\n            return tokenPriceInit;\r\n        }\r\n\r\n        return _contracBalance.div(totalSupply).mul(4).div(3);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Burning tokens function\r\n    // * @param _valueTokens: Amount tokens for burning.\r\n    // * @param _aTokenPrice: One token price.\r\n    // * @param _etherForTokens: Calculate the ether for burning tokens.\r\n    // * @param _forDividendes: Calculate the are common Dividendes.\r\n    // * @param _contracBalance: Get contract balance.\r\n    // * @param _dividendesAmount: Get the percentage of dividends burned tokens.\r\n    // ------------------------------------------------------------------------\r\n    function withdraw(uint256 _valueTokens) external payable returns(bool success) {\r\n        require(msg.sender.isNotContract(),\r\n                \"the contract can not hold tokens\");\r\n\r\n        uint256 _tokensOwner = balanceOf(msg.sender);\r\n\r\n        require(_valueTokens > 0, \"cannot pass 0 value\");\r\n        require(_tokensOwner >= _valueTokens,\r\n                \"you do not have so many tokens\");\r\n\r\n        uint256 _aTokenPrice = tokenPrice();\r\n        uint256 _etherForTokens = tokensToEthereum(_valueTokens, _aTokenPrice);\r\n        uint256 _contracBalance = contracBalance();\r\n        uint256 _forDividendes = onDividendes(_etherForTokens, forWithdrawCosts);\r\n        uint256 _dividendesAmount = dividendesCalc(_tokensOwner);\r\n\r\n        _etherForTokens = _etherForTokens.sub(_forDividendes);\r\n        totalSupply = totalSupply.sub(_valueTokens);\r\n\r\n        if (_dividendesAmount > 0) {\r\n            dividendes = dividendes.sub(_dividendesAmount);\r\n            _etherForTokens = _etherForTokens.add(_dividendesAmount);\r\n            emit WithdrawDividendes(msg.sender, _dividendesAmount);\r\n        }\r\n        if (_tokensOwner == _valueTokens) {\r\n            // if the owner out of system //\r\n            bookKeeper[msg.sender] = 0;\r\n            balances[msg.sender] = 0;\r\n        } else {\r\n           bookKeeper[msg.sender] = block.number;\r\n           balances[msg.sender] = balances[msg.sender].sub(_valueTokens);\r\n        }\r\n        if (_etherForTokens > _contracBalance) {\r\n            _etherForTokens = _contracBalance;\r\n        }\r\n\r\n        msg.sender.transfer(_etherForTokens);\r\n\r\n        emit WithdrawTokens(msg.sender, _etherForTokens);\r\n        emit SendOnDividend(address(0), _forDividendes);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Reinvest dividends into tokens\r\n    // ------------------------------------------------------------------------\r\n    function reinvest() public payable returns(bool success) {\r\n        require(msg.sender.isNotContract(),\r\n                \"the contract can not hold tokens\");\r\n\r\n        uint256 _dividendes = dividendesOf(msg.sender);\r\n        uint256 _aTokenPrice = tokenPrice();\r\n\r\n        require(_dividendes >= _aTokenPrice, \"not enough dividends\");\r\n\r\n        (uint256 _amountOfTokens,\r\n         uint256 _reverseAccess) = ethereumToTokens(_dividendes, _aTokenPrice);\r\n\r\n        require(_amountOfTokens > 0, \"tokens amount not zero\");\r\n\r\n        dividendes = dividendes.sub(_dividendes.sub(_reverseAccess));\r\n        balances[msg.sender] = balances[msg.sender].add(_amountOfTokens);\r\n        totalSupply = totalSupply.add(_amountOfTokens);\r\n        bookKeeper[msg.sender] = block.number;\r\n\r\n        emit Transfer(address(0), msg.sender, _amountOfTokens);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ether conversion to token\r\n    // ------------------------------------------------------------------------\r\n    function ethereumToTokens(uint256 _incomingEthereum, uint256 _aTokenPrice)\r\n        private\r\n        pure\r\n        returns(uint256 tokensReceived, uint256 reverseAccess) {\r\n        require(_incomingEthereum >= _aTokenPrice,\r\n                \"input ether > a token price\");\r\n\r\n        tokensReceived = _incomingEthereum.div(_aTokenPrice);\r\n\r\n        require(tokensReceived > 0, \"you can not buy 0 tokens\");\r\n\r\n        reverseAccess = _incomingEthereum.sub(tokensReceived.mul(_aTokenPrice));\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Inverse function ethereumToTokens (Token conversion to ether).\r\n    // ------------------------------------------------------------------------\r\n    function tokensToEthereum(uint256 _tokens, uint256 _aTokenPrice)\r\n        private\r\n        pure\r\n        returns(uint256 etherReceived) {\r\n        require(_tokens > 0, \"0 tokens cannot be counted\");\r\n\r\n        etherReceived = _aTokenPrice.mul(_tokens);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_valueTokens\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensOwner\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividendes\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsCosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balanceOwner\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limiter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contracBalance\",\"outputs\":[{\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"day\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"priceForToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forReferralCosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forWithdrawCosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingCosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"dividendesOf\",\"outputs\":[{\"name\":\"dividendesAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"ReverseAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"ForReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dividendesAmount\",\"type\":\"uint256\"}],\"name\":\"SendOnDividend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dividendesAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDividendes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"EtherTransfer\",\"type\":\"event\"}]","ContractName":"URA","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f278a165549bea30fc3ad6fa8e359da6057454e64d8f1e55b6dac4f7f0a7f6c6"}]}