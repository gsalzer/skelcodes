{"status":"1","message":"OK","result":[{"SourceCode":"// Eth Heap\r\n// Author: Zac Mitton\r\n// License: Use for all the things. And make lots of money with it.\r\n\r\npragma solidity 0.4.24;\r\n\r\nlibrary Heap{ // default max-heap\r\n\r\n  uint constant ROOT_INDEX = 1;\r\n\r\n  struct Data{\r\n    int128 idCount;\r\n    Node[] nodes; // root is index 1; index 0 not used\r\n    mapping (int128 => uint) indices; // unique id => node index\r\n  }\r\n  struct Node{\r\n    int128 id; //use with another mapping to store arbitrary object types\r\n    int128 priority;\r\n  }\r\n\r\n  //call init before anything else\r\n  function init(Data storage self) internal{\r\n    if(self.nodes.length == 0) self.nodes.push(Node(0,0));\r\n  }\r\n\r\n  function insert(Data storage self, int128 priority) internal returns(Node){//√\r\n    if(self.nodes.length == 0){ init(self); }// test on-the-fly-init\r\n    self.idCount++;\r\n    self.nodes.length++;\r\n    Node memory n = Node(self.idCount, priority);\r\n    _bubbleUp(self, n, self.nodes.length-1);\r\n    return n;\r\n  }\r\n  function extractMax(Data storage self) internal returns(Node){//√\r\n    return _extract(self, ROOT_INDEX);\r\n  }\r\n  function extractById(Data storage self, int128 id) internal returns(Node){//√\r\n    return _extract(self, self.indices[id]);\r\n  }\r\n\r\n  //view\r\n  function dump(Data storage self) internal view returns(Node[]){\r\n  //note: Empty set will return `[Node(0,0)]`. uninitialized will return `[]`.\r\n    return self.nodes;\r\n  }\r\n  function getById(Data storage self, int128 id) internal view returns(Node){\r\n    return getByIndex(self, self.indices[id]);//test that all these return the emptyNode\r\n  }\r\n  function getByIndex(Data storage self, uint i) internal view returns(Node){\r\n    return self.nodes.length > i ? self.nodes[i] : Node(0,0);\r\n  }\r\n  function getMax(Data storage self) internal view returns(Node){\r\n    return getByIndex(self, ROOT_INDEX);\r\n  }\r\n  function size(Data storage self) internal view returns(uint){\r\n    return self.nodes.length > 0 ? self.nodes.length-1 : 0;\r\n  }\r\n  function isNode(Node n) internal pure returns(bool){ return n.id > 0; }\r\n\r\n  //private\r\n  function _extract(Data storage self, uint i) private returns(Node){//√\r\n    if(self.nodes.length <= i || i <= 0){ return Node(0,0); }\r\n\r\n    Node memory extractedNode = self.nodes[i];\r\n    delete self.indices[extractedNode.id];\r\n\r\n    Node memory tailNode = self.nodes[self.nodes.length-1];\r\n    self.nodes.length--;\r\n\r\n    if(i < self.nodes.length){ // if extracted node was not tail\r\n      _bubbleUp(self, tailNode, i);\r\n      _bubbleDown(self, self.nodes[i], i); // then try bubbling down\r\n    }\r\n    return extractedNode;\r\n  }\r\n  function _bubbleUp(Data storage self, Node memory n, uint i) private{//√\r\n    if(i==ROOT_INDEX || n.priority <= self.nodes[i/2].priority){\r\n      _insert(self, n, i);\r\n    }else{\r\n      _insert(self, self.nodes[i/2], i);\r\n      _bubbleUp(self, n, i/2);\r\n    }\r\n  }\r\n  function _bubbleDown(Data storage self, Node memory n, uint i) private{//\r\n    uint length = self.nodes.length;\r\n    uint cIndex = i*2; // left child index\r\n\r\n    if(length <= cIndex){\r\n      _insert(self, n, i);\r\n    }else{\r\n      Node memory largestChild = self.nodes[cIndex];\r\n\r\n      if(length > cIndex+1 && self.nodes[cIndex+1].priority > largestChild.priority ){\r\n        largestChild = self.nodes[++cIndex];// TEST ++ gets executed first here\r\n      }\r\n\r\n      if(largestChild.priority <= n.priority){ //TEST: priority 0 is valid! negative ints work\r\n        _insert(self, n, i);\r\n      }else{\r\n        _insert(self, largestChild, i);\r\n        _bubbleDown(self, n, cIndex);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _insert(Data storage self, Node memory n, uint i) private{//√\r\n    self.nodes[i] = n;\r\n    self.indices[n.id] = i;\r\n  }\r\n}\r\n\r\n\r\ncontract BountyHeap{\r\n  using Heap for Heap.Data;\r\n  Heap.Data public data;\r\n\r\n  uint public createdAt;\r\n  address public author;\r\n\r\n  constructor(address _author) public {\r\n    data.init();\r\n    createdAt = now;\r\n    author = _author;\r\n  }\r\n\r\n  function () public payable{}\r\n\r\n  function endBounty() public{\r\n    require(now > createdAt + 2592000); //60*60*24*30 = 2592000 = 30 days\r\n    author.transfer(address(this).balance); //any remaining ETH goes back to me\r\n  }\r\n\r\n  function breakCompleteness(uint holeIndex, uint filledIndex, address recipient) public{\r\n    require(holeIndex > 0); // 0 index is empty by design (doesn't count)\r\n    require(data.getByIndex(holeIndex).id == 0); //holeIndex has nullNode\r\n    require(data.getByIndex(filledIndex).id != 0); // filledIndex has a node\r\n    require(holeIndex < filledIndex); //HOLE IN MIDDLE OF HEAP!\r\n    recipient.transfer(address(this).balance);\r\n  }\r\n  function breakParentsHaveGreaterPriority(uint indexChild, address recipient) public{\r\n    Heap.Node memory child = data.getByIndex(indexChild);\r\n    Heap.Node memory parent = data.getByIndex(indexChild/2);\r\n\r\n    require(Heap.isNode(child));\r\n    require(Heap.isNode(parent));\r\n    require(child.priority > parent.priority); // CHILD PRIORITY LARGER THAN PARENT!\r\n    recipient.transfer(address(this).balance);\r\n  }\r\n  function breakIdMaintenance(int128 id, address recipient) public{\r\n    require(data.indices[id] != 0); //id exists in mapping\r\n    require(data.nodes[data.indices[id]].id != id); // BUT NODE HAS CONTRIDICTORY ID!\r\n    recipient.transfer(address(this).balance);\r\n  }\r\n  function breakIdMaintenance2(uint index, address recipient) public{\r\n    Heap.Node memory n = data.getByIndex(index);\r\n\r\n    require(Heap.isNode(n)); //node exists in array\r\n    require(index != data.indices[n.id]); // BUT MAPPING DOESNT POINT TO IT!\r\n    recipient.transfer(address(this).balance);\r\n  }\r\n  function breakIdUniqueness(uint index1, uint index2, address recipient) public{\r\n    Heap.Node memory node1 = data.getByIndex(index1);\r\n    Heap.Node memory node2 = data.getByIndex(index2);\r\n\r\n    require(Heap.isNode(node1));\r\n    require(Heap.isNode(node2));\r\n    require(index1 != index2);     //2 different positions in the heap\r\n    require(node1.id == node2.id); //HAVE 2 NODES WITH THE SAME ID!\r\n    recipient.transfer(address(this).balance);\r\n  }\r\n\r\n  function heapify(int128[] priorities) public {\r\n    for(uint i ; i < priorities.length ; i++){\r\n    data.insert(priorities[i]);\r\n    }\r\n  }\r\n  function insert(int128 priority) public returns(int128){\r\n    return data.insert(priority).id;\r\n  }\r\n  function extractMax() public returns(int128){\r\n    return data.extractMax().priority;\r\n  }\r\n  function extractById(int128 id) public returns(int128){\r\n    return data.extractById(id).priority;\r\n  }\r\n  //view\r\n  // // Unfortunately the function below requires the experimental compiler\r\n  // // which cant be verified on etherscan or used natively with truffle.\r\n  // // Hopefully soon it will be standard.\r\n  // function dump() public view returns(Heap.Node[]){\r\n  //     return data.dump();\r\n  // }\r\n  function getIdMax() public view returns(int128){\r\n    return data.getMax().id;\r\n  }\r\n  function getMax() public view returns(int128){\r\n    return data.getMax().priority;\r\n  }\r\n  function getById(int128 id) public view returns(int128){\r\n    return data.getById(id).priority;\r\n  }\r\n  function getIdByIndex(uint i) public view returns(int128){\r\n    return data.getByIndex(i).id;\r\n  }\r\n  function getByIndex(uint i) public view returns(int128){\r\n    return data.getByIndex(i).priority;\r\n  }\r\n  function size() public view returns(uint){\r\n    return data.size();\r\n  }\r\n  function idCount() public view returns(int128){\r\n    return data.idCount;\r\n  }\r\n  function indices(int128 id) public view returns(uint){\r\n    return data.indices[id];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"endBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"int128\"}],\"name\":\"indices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMax\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"indexChild\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"breakParentsHaveGreaterPriority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIdMax\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holeIndex\",\"type\":\"uint256\"},{\"name\":\"filledIndex\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"breakCompleteness\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"int128\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"breakIdMaintenance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"name\":\"idCount\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"priority\",\"type\":\"int128\"}],\"name\":\"insert\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"extractMax\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"breakIdMaintenance2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"author\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"createdAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index1\",\"type\":\"uint256\"},{\"name\":\"index2\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"breakIdUniqueness\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"int128\"}],\"name\":\"extractById\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idCount\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"priorities\",\"type\":\"int128[]\"}],\"name\":\"heapify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"int128\"}],\"name\":\"getById\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getIdByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_author\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"BountyHeap","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001f4e7db8514ec4e99467a8d2ee3a63094a904e7a","Library":"","SwarmSource":"bzzr://48c0c80516dfb0a85df181db1d6b44f4268372dcce253bde27269503a7f7b57a"}]}