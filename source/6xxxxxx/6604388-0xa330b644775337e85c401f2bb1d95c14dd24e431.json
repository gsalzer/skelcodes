{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract IToken {\r\n\r\n\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n\r\n  /// @param _to The address of the recipient\r\n\r\n  /// @param _value The amount of token to be transferred\r\n\r\n  /// @return Whether the transfer was successful or not\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n\r\n  /// @param _from The address of the sender\r\n\r\n  /// @param _to The address of the recipient\r\n\r\n  /// @param _value The amount of token to be transferred\r\n\r\n  /// @return Whether the transfer was successful or not\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n\r\n\r\n}\r\n\r\ncontract IMarketData {\r\n\r\n\tfunction getTokenExchangeRatio(address _tokenNum, address _tokenDenom) public returns (uint256 num, uint256 denom);\r\n\r\n}\r\n\r\ncontract Ownable \r\n\r\n{\r\n\r\n  address public owner;\r\n\r\n \r\n\r\n  constructor(address _owner) public \r\n\r\n  {\r\n\r\n    owner = _owner;\r\n\r\n  }\r\n\r\n \r\n\r\n  modifier onlyOwner() \r\n\r\n  {\r\n\r\n    require(msg.sender == owner);\r\n\r\n    _;\r\n\r\n  }\r\n\r\n \r\n\r\n  function transferOwnership(address newOwner) onlyOwner \r\n\r\n  {\r\n\r\n    require(newOwner != address(0));      \r\n\r\n    owner = newOwner;\r\n\r\n  }\r\n\r\n}\r\n\r\ncontract BiLinkLoan is Ownable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\r\n\r\n\taddress public contractLoanLogic;\r\n\r\n\taddress public contractBalance;\r\n\r\n\taddress public contractMarketData;\r\n\r\n\taddress public accountCost;\r\n\r\n\tuint256 public commissionRatio;//percentage\r\n\r\n\t\r\n\r\n\tmapping (address => mapping ( bytes32 => uint256)) public account2Order2TradeAmount;\r\n\r\n\t\r\n\r\n\tmapping (address => mapping (address => uint16)) public tokenPledgeRatio;//pledge 2 borrow percentage\r\n\r\n\tbool public isLegacy;//if true, not allow new trade,new deposit\r\n\r\n\r\n\r\n\tevent OnTrade(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountPledge, uint256 amountInterest, uint256 amountBorrow, uint256 timestamp);\r\n\r\n\tevent OnUserRepay(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountPledge, uint256 amountOriginInterest, uint256 amountActualInterest\r\n\r\n\t\t, uint256 amountRepaied, uint256 amountRepaiedPledgeToken, uint256 timestamp);\r\n\r\n\tevent OnForceRepay(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountPledge, uint256 amountOriginInterest, uint256 amountActualInterest\r\n\r\n\t\t, uint256 amountRepaied, uint256 amountRepaiedPledgeToken, uint256 timestamp);\r\n\r\n\tevent OnLossCompensated(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountLoss, uint256 amountCompensated, uint256 timestamp);\r\n\r\n\tevent OnLossCompensatedByAssurance(address tokenPledge, address tokenBorrow, address borrower, address lender, uint256 amountLoss, uint256 amountCompensated, uint256 timestamp);\r\n\r\n\t\t\r\n\r\n\tconstructor(address _owner, address _accountCost, address _contractLoanLogic, address _contractMarketData, uint256 _commissionRatio) public Ownable(_owner) {\r\n\r\n\t\tcontractLoanLogic= _contractLoanLogic;\r\n\r\n\t\tcontractMarketData= _contractMarketData;\r\n\r\n\t\tisLegacy= false;\r\n\r\n\t\tcommissionRatio= _commissionRatio;\r\n\r\n\t\taccountCost= _accountCost;\r\n\r\n\t}\r\n\r\n\t\r\n\r\n\tfunction setTokenPledgeRatio(address[] _pledgeTokens, address[] _borrowTokens, uint16[] _ratioPledges) public onlyOwner {\r\n\r\n\t\tfor(uint256 i= 0; i< _pledgeTokens.length; i++) {\r\n\r\n\t\t\ttokenPledgeRatio[_pledgeTokens[i]][_borrowTokens[i]]= _ratioPledges[i];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction setThisContractAsLegacy() public onlyOwner {\r\n\r\n\t\tisLegacy= true;\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction setBalanceContract(address _contractBalance) public onlyOwner {\r\n\r\n\t\tcontractBalance= _contractBalance;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t//_arr1:tokenPledge,tokenBorrow,borrower,lender\r\n\r\n\t//_arr2:amountOrigin,amountInterest,periodDays,expireTime,amountTake\r\n\r\n\t//_arr3:rMaker,sMaker\r\n\r\n\tfunction trade(address[] _arr1, uint256[] _arr2, bool _borrowOrLend, uint8 _vMaker, bytes32[] _arr3) public {\r\n\r\n\t\trequire(isLegacy== false&& _arr2[4]<= _arr2[0]&& verifyInput( _arr1, _arr2, _borrowOrLend, _vMaker, _arr3)&& tokenPledgeRatio[_arr1[0]][_arr1[1]]> 0);\r\n\r\n\t\tif(_borrowOrLend)\r\n\r\n\t\t\trequire(msg.sender== _arr1[2]);\r\n\r\n\t\telse\r\n\r\n\t\t\trequire(msg.sender== _arr1[3]);\r\n\r\n\r\n\r\n\t\tuint256 amountPledge= ILoanLogic(contractLoanLogic).getPledgeAmount(_arr1[0], _arr1[1], _arr2[4], tokenPledgeRatio[_arr1[0]][_arr1[1]]);\r\n\r\n\t\trequire(amountPledge!= 0);\r\n\r\n\r\n\r\n\t\tuint256 amountInterest = amountPledge.mul(_arr2[1]).mul(_arr2[2]).mul(100).div(tokenPledgeRatio[_arr1[0]][_arr1[1]]).div(100000);\r\n\r\n\t\trequire(amountPledge.add(amountInterest)<= IBalance(contractBalance).getAvailableBalance(_arr1[0], _arr1[2])&&_arr2[4]<= IBalance(contractBalance).getAvailableBalance(_arr1[1], _arr1[3]));\r\n\r\n\r\n\r\n\t\tIBalance(contractBalance).modifyBalance(_arr1[3], _arr1[1], _arr2[4], false); \r\n\r\n\t\tIBalance(contractBalance).modifyBalance(_arr1[2], _arr1[1], _arr2[4], true); \r\n\r\n\r\n\r\n\t\trequire(ILoanLogic(contractLoanLogic).updateDataAfterTrade(_arr1[0], _arr1[1], _arr1[2], _arr1[3], _arr2[4], amountPledge, amountInterest, _arr2[2]));\r\n\r\n\t\t\r\n\r\n\t\temit OnTrade(_arr1[0], _arr1[1], _arr1[2], _arr1[3], amountPledge, amountInterest, _arr2[4], now);\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction verifyInput( address[] _arr1, uint256[] _arr2, bool _borrowOrLend, uint8 _vMaker, bytes32[] _arr3) private returns (bool) {\r\n\r\n\t\trequire(now <= _arr2[3]);\r\n\r\n\t\taddress _accountPledgeAssurance= IBalance(contractBalance).getTokenAssuranceAccount(_arr1[0]);\r\n\r\n\t\taddress _accountBorrowAssurance= IBalance(contractBalance).getTokenAssuranceAccount(_arr1[1]);\r\n\r\n\t\trequire(_accountPledgeAssurance!= _arr1[2]&& _accountPledgeAssurance!= _arr1[3]&& _accountBorrowAssurance!= _arr1[2]&& _accountBorrowAssurance!= _arr1[3]);\r\n\r\n\r\n\r\n\t\tbytes32 _hash= keccak256(abi.encodePacked(this, _arr1[0], _arr1[1], _arr2[1], _arr2[2], _arr2[3]));\r\n\r\n\t\trequire(ecrecover(_hash, _vMaker, _arr3[0], _arr3[1]) == (_borrowOrLend? _arr1[3] : _arr1[2]));\r\n\r\n\t\t\r\n\r\n\t\tif(_borrowOrLend) {\r\n\r\n\t\t\trequire(account2Order2TradeAmount[_arr1[3]][_hash].add(_arr2[4])<= _arr2[0]);\r\n\r\n\t\t\taccount2Order2TradeAmount[_arr1[3]][_hash]= account2Order2TradeAmount[_arr1[3]][_hash].add(_arr2[4]);\r\n\r\n\t\t}\r\n\r\n\t\telse {\r\n\r\n\t\t\trequire(account2Order2TradeAmount[_arr1[2]][_hash].add(_arr2[4])<= _arr2[0]);\r\n\r\n\t\t\taccount2Order2TradeAmount[_arr1[2]][_hash]= account2Order2TradeAmount[_arr1[2]][_hash].add(_arr2[4]);\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction getNeedRepayPledgeTokenAmount(uint256 _amountUnRepaiedPledgeTokenAmount, address _pledgeToken, address _borrowToken) private returns (uint256) {\r\n\r\n\t\treturn _amountUnRepaiedPledgeTokenAmount.mul((tokenPledgeRatio[_pledgeToken][_borrowToken] - 100)/4 + 100).div(100);\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction doRepay(uint256 _id, bool _userOrForce) private {\r\n\r\n\t\tvar (_tokenPledge,_tokenBorrow,_borrower,_lender)= ILoanLogic(contractLoanLogic).getLoanDataPart(_id);\r\n\r\n\t\trequire(_borrower!= address(0));\r\n\r\n\t\t \r\n\r\n\t\tuint256 _available= IBalance(contractBalance).getAvailableBalance(_tokenBorrow, _borrower);\r\n\r\n\t\tvar (_amount, _amountOriginInterest, _amountActualInterest,_amountUnRepaiedAmount, _amountPledge)= ILoanLogic(contractLoanLogic).updateDataAfterRepay(_id, _available);\r\n\r\n\t\trequire(_amount!= 0);\r\n\r\n\r\n\r\n\t\tuint256 _amountUnRepaiedPledgeToken= tryCompensateLossByAssurance(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountPledge, _amountUnRepaiedAmount);\r\n\r\n\r\n\r\n\t\t_available= IBalance(contractBalance).getAvailableBalance(_tokenBorrow, _borrower);\r\n\r\n\t\tuint256 _amountRepaiedPledgeToken= getNeedRepayPledgeTokenAmount(_amountUnRepaiedPledgeToken, _tokenPledge, _tokenBorrow);\r\n\r\n\t\tadjustBalancesAfterRepay(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountActualInterest, (_amountRepaiedPledgeToken< _amountPledge? _amountRepaiedPledgeToken: _amountPledge), (_available> _amount? _amount: _available)\r\n\r\n\t\t\t, (_amountUnRepaiedPledgeToken > _amountPledge? _amountUnRepaiedPledgeToken - _amountPledge: 0));\r\n\r\n\r\n\r\n\t\tif(_userOrForce)\r\n\r\n\t\t\temit OnUserRepay(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountPledge, _amountOriginInterest, _amountActualInterest, _amount, _amountRepaiedPledgeToken, now);\r\n\r\n\t\telse\r\n\r\n\t\t\temit OnForceRepay(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountPledge, _amountOriginInterest, _amountActualInterest, _amount, _amountRepaiedPledgeToken, now);\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction tryCompensateLossByAssurance(address _tokenPledge, address _tokenBorrow, address _borrower, address _lender, uint256 _amountPledge, uint256 _amountUnRepaiedAmount) private returns (uint256) {\r\n\r\n\t\tuint256 _amountUnRepaiedPledgeToken= 0;\r\n\r\n\t\taddress _accountAssurance= IBalance(contractBalance).getTokenAssuranceAccount(_tokenBorrow);\r\n\r\n\t\tuint256 _available= IBalance(contractBalance).getAvailableBalance(_tokenBorrow, _accountAssurance);\r\n\r\n\t\t(uint256 _num, uint256 _denom)= IMarketData(contractMarketData).getTokenExchangeRatio(_tokenPledge, _tokenBorrow);\r\n\r\n\t\tuint256 _equalAmount= _amountPledge.mul(_denom).div(_num);\r\n\r\n\r\n\r\n\t\tif(_amountUnRepaiedAmount > _equalAmount&& _available> 0) {\r\n\r\n\t\t\tuint256 _actualCompensatedAmountByAssurance= _amountUnRepaiedAmount.sub(_equalAmount);\r\n\r\n\t\t\tif(_available< _amountUnRepaiedAmount)\r\n\r\n\t\t\t\t_actualCompensatedAmountByAssurance= _available;\r\n\r\n\t\t\tIBalance(contractBalance).modifyBalance(_accountAssurance, _tokenBorrow, _actualCompensatedAmountByAssurance, false); \r\n\r\n\t\t\tIBalance(contractBalance).modifyBalance(_borrower, _tokenBorrow, _actualCompensatedAmountByAssurance, true); \r\n\r\n\t\t\t\r\n\r\n\t\t\temit OnLossCompensatedByAssurance(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountUnRepaiedAmount, _actualCompensatedAmountByAssurance, now);\r\n\r\n\t\t\t_amountUnRepaiedAmount= _amountUnRepaiedAmount.sub(_actualCompensatedAmountByAssurance);\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\t_amountUnRepaiedPledgeToken= _amountUnRepaiedAmount.mul(_num).div(_denom);\r\n\r\n\r\n\r\n\t\treturn _amountUnRepaiedPledgeToken;\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction userRepay(uint256 _id) public {\r\n\r\n\t\tvar (_tokenPledge, _tokenBorrow, _borrower, _lender)= ILoanLogic(contractLoanLogic).getLoanDataPart(_id);\r\n\r\n\t\trequire(msg.sender == _borrower);\r\n\r\n\t\t \r\n\r\n\t\tdoRepay(_id, true);\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction forceRepay(uint256[] _arr) public onlyOwner {\r\n\r\n\t\tfor(uint256 i= 0; i< _arr.length; i++) {\r\n\r\n\t\t\tif(ILoanLogic(contractLoanLogic).needForceClose(_arr[i])) {\r\n\r\n\t\t\t\tdoRepay(_arr[i], false);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\tfunction adjustBalancesAfterRepay(address _tokenPledge, address _tokenBorrow, address _borrower, address _lender, uint256 _amountActualInterest, uint256 _amountRepaiedPeldgeToken, uint256 _amountRepaiedBorrowToken, uint256 _amountLoss) private {\r\n\r\n\t\tuint256 _amountProfit= (_amountActualInterest.mul(commissionRatio))/ 100;\r\n\r\n\t\tIBalance(contractBalance).modifyBalance(_borrower, _tokenPledge, _amountRepaiedPeldgeToken.add(_amountActualInterest), false); \r\n\r\n\t\tIBalance(contractBalance).modifyBalance(_lender, _tokenPledge, _amountActualInterest.sub(_amountProfit), true);\r\n\r\n\t\t \t\t \r\n\r\n\t\tif(_amountRepaiedBorrowToken> 0) {\r\n\r\n\t\t\tIBalance(contractBalance).modifyBalance(_borrower, _tokenBorrow, _amountRepaiedBorrowToken, false);\r\n\r\n\t\t\tIBalance(contractBalance).modifyBalance(_lender, _tokenBorrow, _amountRepaiedBorrowToken, true);\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\tif(_amountLoss> 0) {\r\n\r\n\t\t\tif(IBalance(contractBalance).getAvailableBalance(_tokenPledge, accountCost)/ 10> _amountLoss) {\r\n\r\n\t\t\t\tIBalance(contractBalance).modifyBalance(accountCost, _tokenPledge, _amountLoss, false); \r\n\r\n\t\t\t\tIBalance(contractBalance).modifyBalance(_lender, _tokenPledge, _amountLoss, true); \r\n\r\n\t\t\t\temit OnLossCompensated(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountLoss, _amountLoss, now);\r\n\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\r\n\t\t\t\tuint256 uActualPaiedLoss= IBalance(contractBalance).getAvailableBalance(_tokenPledge, accountCost)/ 10;\r\n\r\n\t\t\t\tIBalance(contractBalance).modifyBalance(accountCost, _tokenPledge, uActualPaiedLoss, false); \r\n\r\n\t\t\t\tIBalance(contractBalance).modifyBalance(_lender, _tokenPledge, uActualPaiedLoss, true); \r\n\r\n\t\t\t\temit OnLossCompensated(_tokenPledge, _tokenBorrow, _borrower, _lender, _amountLoss, uActualPaiedLoss, now);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\tIBalance(contractBalance).modifyBalance(_lender, _tokenPledge, _amountRepaiedPeldgeToken, true);\r\n\r\n\r\n\r\n\t\tif(_tokenPledge== address(0)) {\r\n\r\n\t\t\tIBalance(contractBalance).distributeEthProfit(_lender, _amountProfit);\r\n\r\n\t\t}\r\n\r\n\t\telse {\r\n\r\n\t\t\tIBalance(contractBalance).distributeTokenProfit(_lender, _tokenPledge, _amountProfit);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n\r\n  /**\r\n\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n\r\n  */\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n    if (a == 0) {\r\n\r\n      return 0;\r\n\r\n    }\r\n\r\n    uint256 c = a * b;\r\n\r\n    require(c / a == b);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n\r\n  */\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n    require(b > 0); // Solidity automatically throws when dividing by 0\r\n\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\r\n  */\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n    require(b <= a);\r\n\r\n    return a - b;\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n\r\n  * @dev Adds two numbers, throws on overflow.\r\n\r\n  */\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n    uint256 c = a + b;\r\n\r\n    require(c >= a);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n}\r\n\r\ncontract ILoanLogic {  \r\n\r\n\tfunction setTokenExchangeRatio(address[] tokenPledge, address[] tokenBorrow, uint256[] amountDenom, uint256[] amountNum) public returns (bool);\r\n\r\n\tfunction getPledgeAmount(address tokenPledge, address tokenBorrow, uint256 amount,uint16 ratioPledge) public constant returns (uint256);\r\n\r\n\tfunction updateDataAfterTrade(address tokenPledge, address tokenBorrow, address borrower, address lender,\r\n\r\n\t\tuint256 amountPledge, uint256 amount, uint256 amountInterest, uint256 periodDays) public returns(bool);\r\n\r\n\tfunction updateDataAfterRepay(uint256 id, uint256 uBorrowerAvailableAmount) public returns (uint256, uint256, uint256, uint256, uint256);\r\n\r\n\tfunction getLoanDataPart(uint256 id) public constant returns (address, address, address, address);\r\n\r\n\tfunction needForceClose(uint256 id) public constant returns (bool);\r\n\r\n}\r\n\r\ncontract IBalance {\r\n\r\n\tfunction distributeEthProfit(address profitMaker, uint256 amount) public ;\r\n\r\n\tfunction distributeTokenProfit (address profitMaker, address token, uint256 amount) public ;\r\n\r\n\tfunction modifyBalance(address _account, address _token, uint256 _amount, bool _addOrSub) public;\r\n\r\n\tfunction getAvailableBalance(address _token, address _account) public constant returns (uint256);\r\n\r\n\tfunction getTokenAssuranceAccount(address _token) public constant returns (address);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"contractMarketData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountCost\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setThisContractAsLegacy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPledgeRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pledgeTokens\",\"type\":\"address[]\"},{\"name\":\"_borrowTokens\",\"type\":\"address[]\"},{\"name\":\"_ratioPledges\",\"type\":\"uint16[]\"}],\"name\":\"setTokenPledgeRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractLoanLogic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_arr1\",\"type\":\"address[]\"},{\"name\":\"_arr2\",\"type\":\"uint256[]\"},{\"name\":\"_borrowOrLend\",\"type\":\"bool\"},{\"name\":\"_vMaker\",\"type\":\"uint8\"},{\"name\":\"_arr3\",\"type\":\"bytes32[]\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"userRepay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractBalance\",\"type\":\"address\"}],\"name\":\"setBalanceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_arr\",\"type\":\"uint256[]\"}],\"name\":\"forceRepay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"account2Order2TradeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLegacy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_accountCost\",\"type\":\"address\"},{\"name\":\"_contractLoanLogic\",\"type\":\"address\"},{\"name\":\"_contractMarketData\",\"type\":\"address\"},{\"name\":\"_commissionRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenPledge\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenBorrow\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountPledge\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountBorrow\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenPledge\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenBorrow\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountPledge\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOriginInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountActualInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountRepaied\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountRepaiedPledgeToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnUserRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenPledge\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenBorrow\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountPledge\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOriginInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountActualInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountRepaied\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountRepaiedPledgeToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnForceRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenPledge\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenBorrow\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountLoss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountCompensated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnLossCompensated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenPledge\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenBorrow\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountLoss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountCompensated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OnLossCompensatedByAssurance\",\"type\":\"event\"}]","ContractName":"BiLinkLoan","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e4e3627034a97b75d899ee7525d446bf2d42ad6600000000000000000000000019350aa51f45965b783ec8e40538d4b88d24698a000000000000000000000000aea870ca4ad2ee820050124a7580e78176d9c806000000000000000000000000611ce695290729805e138c9c14dbddf132e76de3000000000000000000000000000000000000000000000000000000000000000a","Library":"","SwarmSource":"bzzr://d6f61256e1ddf19401040c24126c8f30c08a6a90db96b5313717e225654e98e5"}]}