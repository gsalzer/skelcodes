{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Lottery is Ownable {\r\n\r\n    string constant version = \"1.2\";\r\n\r\n    address public drawer;\r\n\r\n    struct Game {\r\n        uint startTime;\r\n        uint jackpot;\r\n        uint reserve;\r\n        uint price;\r\n        bytes winNumbers;\r\n        mapping(byte => bool) winNumbersMap;\r\n        Ticket[] tickets;\r\n        uint checkWinTicketLevel;\r\n        uint[][] winTicketIndices;\r\n        uint[] winLevelAmounts;\r\n        uint needPlayersTransfer;\r\n        uint addToJackpotAmount;\r\n        uint addToReserveAmount;\r\n        uint bitcoinBlockIndex;\r\n        string bitcoinBlockHash;\r\n        mapping(uint => uint) referalIdToTicketCount;\r\n    }\r\n\r\n    struct Ticket {\r\n        address user;\r\n        bytes numbers;\r\n    }\r\n\r\n    struct Referal {\r\n        address wallet;\r\n        uint percent;\r\n    }\r\n\r\n    mapping(address => uint[2][]) playerTickets;\r\n\r\n    Referal[][] public referals;\r\n\r\n    Game[] public games;\r\n\r\n    uint public gameIndex;\r\n\r\n    uint public gameIndexToBuy;\r\n\r\n    uint public checkGameIndex;\r\n\r\n    uint public numbersCount;\r\n\r\n    uint public numbersCountMax;\r\n\r\n    uint public ticketCountMax;\r\n\r\n    uint public jackpotGuaranteed;\r\n\r\n    uint public disableBuyingTime;\r\n\r\n    uint[] public winPercent;\r\n\r\n    address public dividendsWallet;\r\n\r\n    address public technicalWallet;\r\n\r\n    uint public dividendsPercent;\r\n\r\n    uint public technicalPercent;\r\n\r\n    uint public referalPercent;\r\n\r\n    bool public buyEnable = true;\r\n\r\n    uint public nextPrice;\r\n\r\n    uint public intervalTime;\r\n\r\n    uint public percentDivider = 10000;\r\n\r\n    modifier onlyDrawer() {\r\n        require(msg.sender == drawer);\r\n        _;\r\n    }\r\n    function setDrawer(address _drawer) public onlyOwner {\r\n        drawer = _drawer;\r\n    }\r\n\r\n\r\n    event LogDraw(uint indexed gameIndex, uint startTime, uint bitcoinBlockIndex, bytes numbers, uint riseAmount, uint transferAmount, uint addToJackpotAmount, uint addToReserveAmount);\r\n\r\n    event LogReserveUsed(uint indexed gameIndex, uint amount);\r\n\r\n    function Lottery() public {\r\n        numbersCount = 4;\r\n\r\n        dividendsPercent = 1000;\r\n        technicalPercent = 500;\r\n        referalPercent = 1500;\r\n\r\n        drawer = msg.sender;\r\n        dividendsWallet = msg.sender;\r\n        technicalWallet = msg.sender;\r\n\r\n        referals.length = 1;\r\n        referals[0].push(Referal(msg.sender, referalPercent));\r\n\r\n        disableBuyingTime = 1 hours;\r\n        intervalTime = 24 hours;\r\n\r\n        nextPrice = 0.003 ether;\r\n\r\n        games.length = 2;\r\n\r\n        if (numbersCount == 4) {\r\n            numbersCountMax = 20;\r\n            winPercent = [0, 0, 34, 33, 33];\r\n\r\n            jackpotGuaranteed = 3 ether;\r\n            ticketCountMax = 1000000;\r\n            games[0].startTime = 1520553600;\r\n        } else if (numbersCount == 5) {\r\n            numbersCountMax = 36;\r\n            winPercent = [0, 0, 25, 25, 25, 25];\r\n\r\n            jackpotGuaranteed = 143 ether;\r\n            ticketCountMax = 1000000;\r\n            games[0].startTime = 1520553600;\r\n        } else if (numbersCount == 6) {\r\n            numbersCountMax = 45;\r\n            winPercent = [0, 0, 20, 20, 20, 20, 20];\r\n\r\n            jackpotGuaranteed = 1430 ether;\r\n            ticketCountMax = 1000000;\r\n            games[0].startTime = 1520553600;\r\n        }\r\n\r\n        games[0].price = nextPrice;\r\n        games[1].price = nextPrice;\r\n\r\n        games[1].startTime = games[0].startTime + intervalTime;\r\n    }\r\n\r\n    function startTime() public view returns (uint){\r\n        return games[gameIndex].startTime;\r\n    }\r\n\r\n    function closeTime() public view returns (uint){\r\n        return games[gameIndex].startTime - disableBuyingTime;\r\n    }\r\n\r\n    function addReserve() public payable {\r\n        require(checkGameIndex == gameIndex);\r\n        games[gameIndex].reserve += msg.value;\r\n    }\r\n\r\n    function addBalance() public payable {\r\n\r\n    }\r\n\r\n    function isNeedCloseCurrentGame() public view returns (bool){\r\n        return games[gameIndex].startTime < disableBuyingTime + now && gameIndexToBuy == gameIndex;\r\n    }\r\n\r\n    function closeCurrentGame(uint bitcoinBlockIndex) public onlyDrawer {\r\n        require(isNeedCloseCurrentGame());\r\n\r\n        games[gameIndex].bitcoinBlockIndex = bitcoinBlockIndex;\r\n        gameIndexToBuy = gameIndex + 1;\r\n    }\r\n\r\n    function() public payable {\r\n        uint refLength = msg.data.length % numbersCount;\r\n        uint[] memory numbers;\r\n\r\n        if (refLength == 0) {\r\n            numbers = new uint [](msg.data.length);\r\n            for (uint i = 0; i < numbers.length; i++) {\r\n                numbers[i] = uint((msg.data[i] >> 4) & 0xF) * 10 + uint(msg.data[i] & 0xF);\r\n            }\r\n            buyTicket(numbers, 0);\r\n        } else {\r\n            uint referalId;\r\n            if (refLength == 1) {\r\n                referalId = uint(msg.data[msg.data.length - 1]);\r\n            } else if (refLength == 2) {\r\n                referalId = (uint(msg.data[msg.data.length - 2]) << 8) + uint(msg.data[msg.data.length - 1]);\r\n            }\r\n\r\n            numbers = new uint [](msg.data.length - refLength);\r\n\r\n            uint shift = referalId % 10;\r\n            if (shift == 0) shift = 1;\r\n\r\n            for (i = 0; i < numbers.length; i++) {\r\n                numbers[i] = uint(msg.data[i]) - shift;\r\n            }\r\n\r\n            buyTicket(numbers, referalId);\r\n        }\r\n    }\r\n\r\n    function buyTicket(uint[] numbers, uint referalId) public payable {\r\n        require(buyEnable);\r\n        require(referalId < referals.length);\r\n        require(numbers.length % numbersCount == 0);\r\n\r\n        Game storage game = games[gameIndexToBuy];\r\n\r\n        uint buyTicketCount = numbers.length / numbersCount;\r\n        require(msg.value == game.price * buyTicketCount);\r\n        require(game.tickets.length + buyTicketCount <= ticketCountMax);\r\n\r\n        uint i = 0;\r\n        while (i < numbers.length) {\r\n\r\n            bytes memory bet = new bytes(numbersCount);\r\n\r\n            for (uint j = 0; j < numbersCount; j++) {\r\n                bet[j] = byte(numbers[i++]);\r\n            }\r\n\r\n            require(noDuplicates(bet));\r\n\r\n            playerTickets[msg.sender].push([gameIndexToBuy, game.tickets.length]);\r\n\r\n            game.tickets.push(Ticket(msg.sender, bet));\r\n\r\n        }\r\n        game.referalIdToTicketCount[referalId] += buyTicketCount;\r\n    }\r\n\r\n    function getPlayerTickets(address player, uint offset, uint count) public view returns (int [] tickets){\r\n        uint[2][] storage list = playerTickets[player];\r\n        if (offset >= list.length) return tickets;\r\n\r\n        uint k;\r\n        uint n = offset + count;\r\n        if (n > list.length) n = list.length;\r\n\r\n        tickets = new int []((n - offset) * (numbersCount + 5));\r\n\r\n        for (uint i = offset; i < n; i++) {\r\n            uint[2] storage info = list[list.length - i - 1];\r\n            uint gameIndex = info[0];\r\n\r\n            tickets[k++] = int(gameIndex);\r\n            tickets[k++] = int(info[1]);\r\n            tickets[k++] = int(games[gameIndex].startTime);\r\n\r\n            if (games[gameIndex].winNumbers.length == 0) {\r\n                tickets[k++] = - 1;\r\n                tickets[k++] = int(games[gameIndex].price);\r\n\r\n                for (uint j = 0; j < numbersCount; j++) {\r\n                    tickets[k++] = int(games[gameIndex].tickets[info[1]].numbers[j]);\r\n                }\r\n            }\r\n            else {\r\n                uint winNumbersCount = getEqualCount(games[gameIndex].tickets[info[1]].numbers, games[gameIndex]);\r\n                tickets[k++] = int(games[gameIndex].winLevelAmounts[winNumbersCount]);\r\n                tickets[k++] = int(games[gameIndex].price);\r\n\r\n                for (j = 0; j < numbersCount; j++) {\r\n                    if (games[gameIndex].winNumbersMap[games[gameIndex].tickets[info[1]].numbers[j]]) {\r\n                        tickets[k++] = - int(games[gameIndex].tickets[info[1]].numbers[j]);\r\n                    }\r\n                    else {\r\n                        tickets[k++] = int(games[gameIndex].tickets[info[1]].numbers[j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAllTickets() public view returns (int [] tickets){\r\n        uint n = gameIndexToBuy + 1;\r\n\r\n        uint ticketCount;\r\n        for (uint gameIndex = 0; gameIndex < n; gameIndex++) {\r\n            ticketCount += games[gameIndex].tickets.length;\r\n        }\r\n\r\n        tickets = new int[](ticketCount * (numbersCount + 5));\r\n        uint k;\r\n\r\n        for (gameIndex = 0; gameIndex < n; gameIndex++) {\r\n            Ticket[] storage gameTickets = games[gameIndex].tickets;\r\n            for (uint ticketIndex = 0; ticketIndex < gameTickets.length; ticketIndex++) {\r\n\r\n                tickets[k++] = int(gameIndex);\r\n                tickets[k++] = int(ticketIndex);\r\n                tickets[k++] = int(games[gameIndex].startTime);\r\n\r\n                if (games[gameIndex].winNumbers.length == 0) {\r\n                    tickets[k++] = - 1;\r\n                    tickets[k++] = int(games[gameIndex].price);\r\n\r\n                    for (uint j = 0; j < numbersCount; j++) {\r\n                        tickets[k++] = int(games[gameIndex].tickets[ticketIndex].numbers[j]);\r\n                    }\r\n                }\r\n                else {\r\n                    uint winNumbersCount = getEqualCount(games[gameIndex].tickets[ticketIndex].numbers, games[gameIndex]);\r\n                    tickets[k++] = int(games[gameIndex].winLevelAmounts[winNumbersCount]);\r\n                    tickets[k++] = int(games[gameIndex].price);\r\n\r\n                    for (j = 0; j < numbersCount; j++) {\r\n                        if (games[gameIndex].winNumbersMap[games[gameIndex].tickets[ticketIndex].numbers[j]]) {\r\n                            tickets[k++] = - int(games[gameIndex].tickets[ticketIndex].numbers[j]);\r\n                        }\r\n                        else {\r\n                            tickets[k++] = int(games[gameIndex].tickets[ticketIndex].numbers[j]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getGames(uint offset, uint count) public view returns (uint [] res){\r\n        if (offset > gameIndex) return res;\r\n\r\n        uint k;\r\n        uint n = offset + count;\r\n        if (n > gameIndex + 1) n = gameIndex + 1;\r\n        res = new uint []((n - offset) * (numbersCount + 10));\r\n\r\n        for (uint i = offset; i < n; i++) {\r\n            uint gi = gameIndex - i;\r\n            Game storage game = games[gi];\r\n            res[k++] = gi;\r\n            res[k++] = game.startTime;\r\n            res[k++] = game.jackpot;\r\n            res[k++] = game.reserve;\r\n            res[k++] = game.price;\r\n            res[k++] = game.tickets.length;\r\n            res[k++] = game.needPlayersTransfer;\r\n            res[k++] = game.addToJackpotAmount;\r\n            res[k++] = game.addToReserveAmount;\r\n            res[k++] = game.bitcoinBlockIndex;\r\n\r\n            if (game.winNumbers.length == 0) {\r\n                for (uint j = 0; j < numbersCount; j++) {\r\n                    res[k++] = 0;\r\n                }\r\n            }\r\n            else {\r\n                for (j = 0; j < numbersCount; j++) {\r\n                    res[k++] = uint(game.winNumbers[j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getWins(uint gameIndex, uint offset, uint count) public view returns (uint[] wins){\r\n        Game storage game = games[gameIndex];\r\n        uint k;\r\n        uint n = offset + count;\r\n        uint[] memory res = new uint [](count * 4);\r\n\r\n        uint currentIndex;\r\n\r\n        for (uint level = numbersCount; level > 1; level--) {\r\n            for (uint indexInlevel = 0; indexInlevel < game.winTicketIndices[level].length; indexInlevel++) {\r\n                if (offset <= currentIndex && currentIndex < n) {\r\n                    uint ticketIndex = game.winTicketIndices[level][indexInlevel];\r\n                    Ticket storage ticket = game.tickets[ticketIndex];\r\n                    res[k++] = uint(ticket.user);\r\n                    res[k++] = level;\r\n                    res[k++] = ticketIndex;\r\n                    res[k++] = game.winLevelAmounts[level];\r\n\r\n                } else if (currentIndex >= n) {\r\n                    wins = new uint[](k);\r\n                    for (uint i = 0; i < k; i++) {\r\n                        wins[i] = res[i];\r\n                    }\r\n                    return wins;\r\n                }\r\n                currentIndex++;\r\n            }\r\n        }\r\n        wins = new uint[](k);\r\n        for (i = 0; i < k; i++) {\r\n            wins[i] = res[i];\r\n        }\r\n    }\r\n\r\n    function noDuplicates(bytes array) public pure returns (bool){\r\n        for (uint i = 0; i < array.length - 1; i++) {\r\n            for (uint j = i + 1; j < array.length; j++) {\r\n                if (array[i] == array[j]) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getWinNumbers(string bitcoinBlockHash, uint numbersCount, uint numbersCountMax) public pure returns (bytes){\r\n        bytes32 random = keccak256(bitcoinBlockHash);\r\n        bytes memory allNumbers = new bytes(numbersCountMax);\r\n        bytes memory winNumbers = new bytes(numbersCount);\r\n\r\n        for (uint i = 0; i < numbersCountMax; i++) {\r\n            allNumbers[i] = byte(i + 1);\r\n        }\r\n\r\n        for (i = 0; i < numbersCount; i++) {\r\n            uint n = numbersCountMax - i;\r\n\r\n            uint r = (uint(random[i * 4]) + (uint(random[i * 4 + 1]) << 8) + (uint(random[i * 4 + 2]) << 16) + (uint(random[i * 4 + 3]) << 24)) % n;\r\n\r\n            winNumbers[i] = allNumbers[r];\r\n\r\n            allNumbers[r] = allNumbers[n - 1];\r\n\r\n        }\r\n        return winNumbers;\r\n    }\r\n\r\n    function isNeedDrawGame(uint bitcoinBlockIndex) public view returns (bool){\r\n        Game storage game = games[gameIndex];\r\n        return bitcoinBlockIndex > game.bitcoinBlockIndex && game.bitcoinBlockIndex > 0 && now >= game.startTime;\r\n    }\r\n\r\n    function drawGame(uint bitcoinBlockIndex, string bitcoinBlockHash) public onlyDrawer {\r\n        Game storage game = games[gameIndex];\r\n\r\n        require(isNeedDrawGame(bitcoinBlockIndex));\r\n\r\n        game.bitcoinBlockIndex = bitcoinBlockIndex;\r\n        game.bitcoinBlockHash = bitcoinBlockHash;\r\n        game.winNumbers = getWinNumbers(bitcoinBlockHash, numbersCount, numbersCountMax);\r\n\r\n        for (uint i = 0; i < game.winNumbers.length; i++) {\r\n            game.winNumbersMap[game.winNumbers[i]] = true;\r\n        }\r\n\r\n        game.winTicketIndices.length = numbersCount + 1;\r\n        game.winLevelAmounts.length = numbersCount + 1;\r\n\r\n        uint riseAmount = game.tickets.length * game.price;\r\n\r\n        uint technicalAmount = riseAmount * technicalPercent / percentDivider;\r\n        uint dividendsAmount = riseAmount * dividendsPercent / percentDivider;\r\n\r\n        technicalWallet.transfer(technicalAmount);\r\n        dividendsWallet.transfer(dividendsAmount);\r\n\r\n        for (uint referalId = 0; referalId < referals.length; referalId++) {\r\n            Referal[] storage refList = referals[referalId];\r\n            riseAmount = game.referalIdToTicketCount[referalId] * game.price;\r\n            for (i = 0; i < refList.length; i++) {\r\n                Referal storage ref = refList[i];\r\n                ref.wallet.transfer(riseAmount * ref.percent / percentDivider);\r\n            }\r\n        }\r\n\r\n        games.length++;\r\n\r\n        gameIndex++;\r\n        games[gameIndex + 1].startTime = games[gameIndex].startTime + intervalTime;\r\n        games[gameIndex + 1].price = nextPrice;\r\n\r\n    }\r\n\r\n    function calcWins(Game storage game) private {\r\n        game.checkWinTicketLevel = numbersCount;\r\n\r\n        uint riseAmount = game.tickets.length * game.price * (percentDivider - technicalPercent - dividendsPercent - referalPercent) / percentDivider;\r\n\r\n        uint freeAmount = 0;\r\n\r\n        for (uint i = 2; i < numbersCount; i++) {\r\n            uint winCount = game.winTicketIndices[i].length;\r\n            uint winAmount = riseAmount * winPercent[i] / 100;\r\n            if (winCount > 0) {\r\n                game.winLevelAmounts[i] = winAmount / winCount;\r\n                game.needPlayersTransfer += winAmount;\r\n            }\r\n            else {\r\n                freeAmount += winAmount;\r\n            }\r\n        }\r\n        freeAmount += riseAmount * winPercent[numbersCount] / 100;\r\n\r\n        uint winJackpotCount = game.winTicketIndices[numbersCount].length;\r\n\r\n        uint jackpot = game.jackpot;\r\n        uint reserve = game.reserve;\r\n\r\n        if (winJackpotCount > 0) {\r\n            if (jackpot < jackpotGuaranteed) {\r\n                uint fromReserve = jackpotGuaranteed - jackpot;\r\n                if (fromReserve > reserve) fromReserve = reserve;\r\n\r\n                reserve -= fromReserve;\r\n                jackpot += fromReserve;\r\n\r\n                LogReserveUsed(checkGameIndex, fromReserve);\r\n            }\r\n\r\n            game.winLevelAmounts[numbersCount] = jackpot / winJackpotCount;\r\n\r\n            game.needPlayersTransfer += jackpot;\r\n            jackpot = 0;\r\n        }\r\n\r\n        if (reserve < jackpotGuaranteed) {\r\n            game.addToReserveAmount = freeAmount;\r\n        } else {\r\n            game.addToJackpotAmount = freeAmount;\r\n        }\r\n\r\n        games[checkGameIndex + 1].jackpot += jackpot + game.addToJackpotAmount;\r\n        games[checkGameIndex + 1].reserve += reserve + game.addToReserveAmount;\r\n\r\n    }\r\n\r\n    function getEqualCount(bytes numbers, Game storage game) constant private returns (uint count){\r\n        for (uint i = 0; i < numbers.length; i++) {\r\n            if (game.winNumbersMap[numbers[i]]) count++;\r\n        }\r\n    }\r\n\r\n    function setJackpotGuaranteed(uint _jackpotGuaranteed) public onlyOwner {\r\n        jackpotGuaranteed = _jackpotGuaranteed;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ticketCountMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTickets\",\"outputs\":[{\"name\":\"tickets\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"reserve\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"winNumbers\",\"type\":\"bytes\"},{\"name\":\"checkWinTicketLevel\",\"type\":\"uint256\"},{\"name\":\"needPlayersTransfer\",\"type\":\"uint256\"},{\"name\":\"addToJackpotAmount\",\"type\":\"uint256\"},{\"name\":\"addToReserveAmount\",\"type\":\"uint256\"},{\"name\":\"bitcoinBlockIndex\",\"type\":\"uint256\"},{\"name\":\"bitcoinBlockHash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drawer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"technicalPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isNeedCloseCurrentGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bitcoinBlockHash\",\"type\":\"string\"},{\"name\":\"numbersCount\",\"type\":\"uint256\"},{\"name\":\"numbersCountMax\",\"type\":\"uint256\"}],\"name\":\"getWinNumbers\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyEnable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotGuaranteed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkGameIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getWins\",\"outputs\":[{\"name\":\"wins\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bitcoinBlockIndex\",\"type\":\"uint256\"}],\"name\":\"isNeedDrawGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameIndexToBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"technicalWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addReserve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bitcoinBlockIndex\",\"type\":\"uint256\"}],\"name\":\"closeCurrentGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpotGuaranteed\",\"type\":\"uint256\"}],\"name\":\"setJackpotGuaranteed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disableBuyingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getPlayerTickets\",\"outputs\":[{\"name\":\"tickets\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offset\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getGames\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addBalance\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numbers\",\"type\":\"uint256[]\"},{\"name\":\"referalId\",\"type\":\"uint256\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numbersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referals\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"percent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bitcoinBlockIndex\",\"type\":\"uint256\"},{\"name\":\"bitcoinBlockHash\",\"type\":\"string\"}],\"name\":\"drawGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numbersCountMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_drawer\",\"type\":\"address\"}],\"name\":\"setDrawer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referalPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentDivider\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"array\",\"type\":\"bytes\"}],\"name\":\"noDuplicates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bitcoinBlockIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numbers\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"riseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addToJackpotAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addToReserveAmount\",\"type\":\"uint256\"}],\"name\":\"LogDraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogReserveUsed\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0d7674aa8aba713164e0de0d64f809f8e3d92c693644951ed6331f89d597db5f"}]}