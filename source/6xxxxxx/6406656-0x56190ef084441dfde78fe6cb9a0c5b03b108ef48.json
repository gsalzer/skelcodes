{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract OracleBase {\r\n\r\n  function getRandomUint(uint max) public returns (uint);\r\n\r\n  function getRandomForContract(uint max, uint index) public view returns (uint);\r\n\r\n  function getEtherDiceProfit(uint rate) public view returns (uint);\r\n\r\n  function getRandomUint256(uint txId) public returns (uint256);\r\n\r\n  function getRandomForContractClanwar(uint max, uint index) public view returns (uint);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract ContractOwner {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract Etherauction is ContractOwner {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  constructor() public payable {\r\n    owner = msg.sender;\r\n\r\n    gameId = 1;\r\n    gameStartTime = block.timestamp;\r\n    gameLastAuctionMoney = 10**15;\r\n\r\n    gameLastAuctionTime = block.timestamp;\r\n    gameSecondLeft = _getInitAuctionSeconds();\r\n  }\r\n\r\n  function adminAddMoney() public payable {\r\n    reward = reward + msg.value * 80 / 100;\r\n    nextReward = nextReward + msg.value * 20 / 100;\r\n\r\n    Contributor memory c;\r\n    contributors[gameId].push(c);\r\n    contributors[gameId][contributors[gameId].length - 1].addr = owner;\r\n    contributors[gameId][contributors[gameId].length - 1].money = msg.value * 80 / 100;\r\n  }\r\n\r\n  function addAuctionReward() public payable {\r\n    uint256 minBid = getMinAuctionValue();\r\n    if (msg.value < minBid)\r\n      revert('value error');\r\n\r\n    uint value = msg.value - minBid;\r\n\r\n    reward = reward + value * 98 / 100;\r\n    nextReward = nextReward + value * 2 / 100;\r\n\r\n    Contributor memory c;\r\n    contributors[gameId].push(c);\r\n    contributors[gameId][contributors[gameId].length - 1].addr = msg.sender;\r\n    contributors[gameId][contributors[gameId].length - 1].money = msg.value - minBid;\r\n\r\n    if (!_isUserInGame(msg.sender)) {\r\n      _auction(minBid, address(0x00));\r\n    }\r\n    \r\n  }\r\n\r\n\r\n  uint256 gameId; // gameId increase from 1\r\n  uint256 gameStartTime;  // game start time\r\n  uint256 gameLastAuctionTime;   // last auction time\r\n  uint256 gameLastAuctionMoney; \r\n  uint256 gameSecondLeft; // how many seconds left to auction\r\n\r\n\r\n  ////////////////////////// money\r\n\r\n  uint256 reward; // reward for winner\r\n  uint256 dividends;  // total dividends for players\r\n  uint256 nextReward; // reward for next round\r\n  uint256 dividendForDev;\r\n  uint256 dividendForContributor;\r\n\r\n\r\n  ////////////////////////// api\r\n\r\n  // OracleBase oracleAPI;\r\n\r\n  // function setOracleAPIAddress(address _addr) public onlyOwner {\r\n  //   oracleAPI = OracleBase(_addr);\r\n  // }\r\n\r\n  // uint rollCount = 100;\r\n\r\n  // function getRandom() internal returns (uint256) {\r\n  //   rollCount = rollCount + 1;\r\n  //   return oracleAPI.getRandomForContract(100, rollCount);\r\n  // }\r\n\r\n\r\n\r\n  ////////////////////////// game money\r\n\r\n  // 17%\r\n  function _inMoney(uint _m, address invitorAddr) internal {\r\n    if (invitorAddr != 0x00 && _isUserInGame(invitorAddr)) {\r\n\r\n      shareds[gameId][invitorAddr].addr = invitorAddr;\r\n      shareds[gameId][invitorAddr].money = shareds[gameId][invitorAddr].money + _m * 1 / 100;\r\n\r\n      dividends = dividends + _m * 6 / 100;\r\n      dividendForDev = dividendForDev + _m * 1 / 100;\r\n      dividendForContributor = dividendForContributor + _m * 3 / 100;\r\n\r\n      reward = reward + _m * 2 / 100;\r\n      nextReward = nextReward + _m * 4 / 100;\r\n\r\n      // emit GameInvited(gameId, invitorAddr, _m);\r\n    } else {\r\n\r\n      dividends = dividends + _m * 7 / 100;\r\n      dividendForDev = dividendForDev + _m * 1 / 100;\r\n      dividendForContributor = dividendForContributor + _m * 3 / 100;\r\n\r\n      reward = reward + _m * 2 / 100;\r\n      nextReward = nextReward + _m * 4 / 100;\r\n\r\n    }\r\n  }\r\n\r\n  function _startNewRound(address _addr) internal {\r\n    reward = nextReward * 80 / 100;\r\n    nextReward = nextReward * 20 / 100;\r\n    gameId = gameId + 1;\r\n    dividends = 0;\r\n\r\n    gameStartTime = block.timestamp;\r\n    gameLastAuctionTime = block.timestamp;\r\n\r\n    // have to make sure enough reward, or may get exception\r\n    uint256 price = _getMinAuctionStartPrice();\r\n    reward = reward.sub(price);\r\n\r\n    PlayerAuction memory p;\r\n    gameAuction[gameId].push(p);\r\n    gameAuction[gameId][0].addr = _addr;\r\n    gameAuction[gameId][0].money = price;\r\n    gameAuction[gameId][0].bid = price;\r\n    gameAuction[gameId][0].refunded = false;\r\n    gameAuction[gameId][0].dividended = false;\r\n\r\n    gameLastAuctionMoney = price;\r\n    gameSecondLeft = _getInitAuctionSeconds();\r\n\r\n    Contributor memory c;\r\n    contributors[gameId].push(c);\r\n    contributors[gameId][0].addr = owner;\r\n    contributors[gameId][0].money = reward;\r\n\r\n    emit GameAuction(gameId, _addr, price, price, gameSecondLeft, block.timestamp);\r\n  }\r\n\r\n  function adminPayout() public onlyOwner {\r\n    owner.transfer(dividendForDev);\r\n    dividendForDev = 0;\r\n  }\r\n\r\n  ////////////////////////// game struct\r\n\r\n  struct GameData {\r\n    uint256 gameId;\r\n    uint256 reward;\r\n    uint256 dividends;\r\n    uint256 dividendForContributor;\r\n  }\r\n\r\n  GameData[] gameData;\r\n\r\n  struct PlayerAuction {\r\n    address addr;\r\n    uint256 money;\r\n    uint256 bid;\r\n    bool refunded;\r\n    bool dividended;\r\n  }\r\n\r\n  mapping(uint256 => PlayerAuction[]) gameAuction;\r\n\r\n  struct Contributor {\r\n    address addr;\r\n    uint256 money;\r\n  }\r\n\r\n  mapping(uint256 => Contributor[]) contributors;\r\n\r\n  struct Shared {\r\n    address addr;\r\n    uint256 money;\r\n  }\r\n\r\n  mapping(uint256 => mapping(address => Shared)) shareds;\r\n\r\n  ////////////////////////// game event\r\n\r\n  event GameAuction(uint indexed gameId, address player, uint money, uint auctionValue, uint secondsLeft, uint datetime);\r\n  \r\n  event GameRewardClaim(uint indexed gameId, address indexed player, uint money);\r\n\r\n  event GameRewardRefund(uint indexed gameId, address indexed player, uint money);\r\n\r\n  event GameEnd(uint indexed gameId, address indexed winner, uint money, uint datetime);\r\n\r\n  event GameInvited(uint indexed gameId, address player, uint money);\r\n\r\n\r\n  ////////////////////////// invite \r\n\r\n  // key is msgSender, value is invitor address\r\n  mapping(address => address) public inviteMap;\r\n\r\n  function registerInvitor(address msgSender, address invitor) internal {\r\n    if (invitor == 0x0 || msgSender == 0x0) {\r\n      return;\r\n    }\r\n\r\n    inviteMap[msgSender] = invitor;\r\n  }\r\n\r\n  function getInvitor(address msgSender) internal view returns (address){\r\n    return inviteMap[msgSender];\r\n  }\r\n\r\n\r\n  ////////////////////////// game play\r\n\r\n  function getMinAuctionValue() public view returns (uint256) {\r\n    uint256 gap = _getGameAuctionGap();\r\n    uint256 auctionValue = gap + gameLastAuctionMoney;\r\n    return auctionValue;\r\n  }\r\n\r\n  function auction(address invitorAddr) public payable {\r\n    _auction(msg.value, invitorAddr);\r\n  }\r\n\r\n  function _auction(uint256 value, address invitorAddr) internal {\r\n    bool ended = (block.timestamp > gameLastAuctionTime + gameSecondLeft) ? true: false;\r\n    if (ended) {\r\n      revert('this round end!!!');\r\n    }\r\n\r\n    uint256 len = gameAuction[gameId].length;\r\n    if (len > 1) {\r\n      address bidder = gameAuction[gameId][len - 1].addr;\r\n      if (msg.sender == bidder)\r\n        revert(\"wrong action\");\r\n    }\r\n\r\n    uint256 gap = _getGameAuctionGap();\r\n    uint256 auctionValue = gap + gameLastAuctionMoney;\r\n    uint256 maxAuctionValue = 3 * gap + gameLastAuctionMoney;\r\n\r\n    if (value < auctionValue) {\r\n      revert(\"wrong eth value!\");\r\n    }\r\n\r\n\r\n    if (invitorAddr != 0x00) {\r\n      registerInvitor(msg.sender, invitorAddr);\r\n    } else\r\n      invitorAddr = getInvitor(msg.sender);\r\n\r\n\r\n    if (value >= maxAuctionValue) {\r\n      auctionValue = maxAuctionValue;\r\n    } else {\r\n      auctionValue = value;\r\n    }\r\n\r\n    gameLastAuctionMoney = auctionValue;\r\n    _inMoney(auctionValue, invitorAddr);\r\n    gameLastAuctionTime = block.timestamp;\r\n\r\n    // uint256 random = getRandom();\r\n    // gameSecondLeft = random * (_getMaxAuctionSeconds() - _getMinAuctionSeconds()) / 100 + _getMinAuctionSeconds();\r\n    gameSecondLeft = _getMaxAuctionSeconds();\r\n\r\n    PlayerAuction memory p;\r\n    gameAuction[gameId].push(p);\r\n    gameAuction[gameId][gameAuction[gameId].length - 1].addr = msg.sender;\r\n    gameAuction[gameId][gameAuction[gameId].length - 1].money = value;\r\n    gameAuction[gameId][gameAuction[gameId].length - 1].bid = auctionValue;\r\n    gameAuction[gameId][gameAuction[gameId].length - 1].refunded = false;\r\n    gameAuction[gameId][gameAuction[gameId].length - 1].dividended = false;\r\n\r\n    emit GameAuction(gameId, msg.sender, value, auctionValue, gameSecondLeft, block.timestamp);\r\n  }\r\n\r\n  function claimReward(uint256 _id) public {\r\n    _claimReward(msg.sender, _id);\r\n  }\r\n\r\n  function _claimReward(address _addr, uint256 _id) internal {\r\n    if (_id == gameId) {\r\n      bool ended = (block.timestamp > gameLastAuctionTime + gameSecondLeft) ? true: false;\r\n      if (ended == false)\r\n        revert('game is still on, cannot claim reward');\r\n    }\r\n\r\n    uint _reward = 0;\r\n    uint _dividends = 0;\r\n    uint _myMoney = 0;\r\n    uint _myDividends = 0;\r\n    uint _myRefund = 0;\r\n    uint _myReward = 0;\r\n    bool _claimed = false;\r\n    (_myMoney, _myDividends, _myRefund, _myReward, _claimed) = _getGameInfoPart1(_addr, _id);\r\n    (_reward, _dividends) = _getGameInfoPart2(_id);\r\n\r\n    uint256 contributeValue = 0;\r\n    uint256 sharedValue = 0;\r\n    (contributeValue, sharedValue) = _getGameInfoPart3(_addr, _id);\r\n\r\n    if (_claimed)\r\n      revert('already claimed!');\r\n\r\n    for (uint k = 0; k < gameAuction[_id].length; k++) {\r\n      if (gameAuction[_id][k].addr == _addr) {\r\n        gameAuction[_id][k].dividended = true;\r\n      }\r\n    }\r\n\r\n    _addr.transfer(_myDividends + _myRefund + _myReward + contributeValue + sharedValue); \r\n    emit GameRewardClaim(_id, _addr, _myDividends + _myRefund + _myReward);\r\n  }\r\n\r\n  // can only refund game still on\r\n  function refund() public {\r\n    uint256 len = gameAuction[gameId].length;\r\n    if (len > 1) {\r\n      if (msg.sender != gameAuction[gameId][len - 2].addr\r\n        && msg.sender != gameAuction[gameId][len - 1].addr) {\r\n\r\n        uint256 money = 0;\r\n        uint k = 0;\r\n        for (k = 0; k < gameAuction[gameId].length; k++) {\r\n          if (gameAuction[gameId][k].addr == msg.sender && gameAuction[gameId][k].refunded == false) {\r\n            money = money + gameAuction[gameId][k].bid * 83 / 100 + gameAuction[gameId][k].money;\r\n            gameAuction[gameId][k].refunded = true;\r\n          }\r\n        }\r\n\r\n        // if user have contribute \r\n        k = 0;\r\n        for (k = 0; k < contributors[gameId].length; k++) {\r\n          if (contributors[gameId][k].addr == msg.sender) {\r\n            contributors[gameId][k].money = 0;  // he cannot get any dividend from his contributor\r\n          }\r\n        }\r\n\r\n        // if user have invited \r\n        if (shareds[gameId][msg.sender].money > 0) {\r\n          dividends = dividends + shareds[gameId][msg.sender].money;\r\n          delete shareds[gameId][msg.sender];\r\n        }\r\n\r\n        msg.sender.transfer(money); \r\n        emit GameRewardRefund(gameId, msg.sender, money);\r\n      } else {\r\n        revert('cannot refund because you are no.2 bidder');\r\n      }\r\n    }   \r\n  }\r\n\r\n\r\n  // anyone can end this round\r\n  function gameRoundEnd() public {\r\n    bool ended = (block.timestamp > gameLastAuctionTime + gameSecondLeft) ? true: false;\r\n    if (ended == false)\r\n      revert(\"game cannot end\");\r\n\r\n    uint256 len = gameAuction[gameId].length;\r\n    address winner = gameAuction[gameId][len - 1].addr;\r\n\r\n    GameData memory d;\r\n    gameData.push(d);\r\n    gameData[gameData.length - 1].gameId = gameId;\r\n    gameData[gameData.length - 1].reward = reward;\r\n    gameData[gameData.length - 1].dividends = dividends;\r\n    gameData[gameData.length - 1].dividendForContributor = dividendForContributor;\r\n\r\n    _startNewRound(msg.sender);\r\n\r\n    _claimReward(msg.sender, gameId - 1);\r\n\r\n    emit GameEnd(gameId - 1, winner, gameData[gameData.length - 1].reward, block.timestamp);\r\n  }\r\n\r\n  function getCurrCanRefund() public view returns (bool) {\r\n\r\n    if (gameAuction[gameId].length > 1) {\r\n      if (msg.sender == gameAuction[gameId][gameAuction[gameId].length - 2].addr) {\r\n        return false;\r\n      } else if (msg.sender == gameAuction[gameId][gameAuction[gameId].length - 1].addr) {\r\n        return false;\r\n      }\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  function getCurrGameInfoPart2() public view returns (uint256 _myContributeMoney, uint256 _mySharedMoney) {\r\n    (_myContributeMoney, _mySharedMoney) = _getGameInfoPart3(msg.sender, gameId);\r\n  }\r\n\r\n  function getCurrGameInfoPart1() public view returns (uint256 _gameId, \r\n                                                          uint256 _reward, \r\n                                                          uint256 _dividends,\r\n                                                          uint256 _lastAuction, \r\n                                                          uint256 _gap, \r\n                                                          uint256 _lastAuctionTime,\r\n                                                          uint256 _secondsLeft, \r\n                                                          uint256 _myMoney,\r\n                                                          uint256 _myDividends,\r\n                                                          uint256 _myRefund,\r\n                                                          bool _ended) {\r\n    _gameId = gameId;\r\n\r\n    _reward = reward;\r\n    _dividends = dividends;\r\n    _lastAuction = gameLastAuctionMoney;\r\n    _gap = _getGameAuctionGap();\r\n    _lastAuctionTime = gameLastAuctionTime;\r\n    _secondsLeft = gameSecondLeft;\r\n    _ended = (block.timestamp > _lastAuctionTime + _secondsLeft) ? true: false;\r\n\r\n    uint256 _moneyForCal = 0;\r\n\r\n    if (gameAuction[gameId].length > 1) {\r\n\r\n      uint256 totalMoney = 0;\r\n\r\n      for (uint256 i = 0; i < gameAuction[gameId].length; i++) {\r\n        if (gameAuction[gameId][i].addr == msg.sender && gameAuction[gameId][i].dividended == true) {\r\n\r\n        }\r\n\r\n        if (gameAuction[gameId][i].addr == msg.sender && gameAuction[gameId][i].refunded == false) {\r\n\r\n          if ((i == gameAuction[gameId].length - 2) || (i == gameAuction[gameId].length - 1)) {\r\n            _myRefund = _myRefund.add(gameAuction[gameId][i].money).sub(gameAuction[gameId][i].bid);\r\n          } else {\r\n            _myRefund = _myRefund.add(gameAuction[gameId][i].money).sub(gameAuction[gameId][i].bid.mul(17).div(100));\r\n          }\r\n\r\n          _myMoney = _myMoney + gameAuction[gameId][i].money;\r\n\r\n          _moneyForCal = _moneyForCal.add((gameAuction[gameId][i].money.div(10**15)).mul(gameAuction[gameId][i].money.div(10**15)).mul(gameAuction[gameId].length + 1 - i));\r\n        }\r\n\r\n        if (gameAuction[gameId][i].refunded == false) {\r\n          totalMoney = totalMoney.add((gameAuction[gameId][i].money.div(10**15)).mul(gameAuction[gameId][i].money.div(10**15)).mul(gameAuction[gameId].length + 1 - i));\r\n        }\r\n      }\r\n\r\n      if (totalMoney != 0)\r\n        _myDividends = _moneyForCal.mul(_dividends).div(totalMoney);\r\n    }\r\n  }\r\n\r\n  function getGameDataByIndex(uint256 _index) public view returns (uint256 _id, uint256 _reward, uint256 _dividends) {\r\n    uint256 len = gameData.length;\r\n    if (len >= (_index + 1)) {\r\n      GameData memory d = gameData[_index];\r\n      _id = d.gameId;\r\n      _reward = d.reward;\r\n      _dividends = d.dividends;\r\n    }\r\n  }\r\n\r\n  function getGameInfo(uint256 _id) public view returns (uint256 _reward, uint256 _dividends, uint256 _myMoney, uint256 _myDividends, uint256 _myRefund, uint256 _myReward, uint256 _myInvestIncome, uint256 _myShared, bool _claimed) {\r\n    (_reward, _dividends) = _getGameInfoPart2(_id);\r\n    (_myMoney, _myRefund, _myDividends, _myReward, _claimed) = _getGameInfoPart1(msg.sender, _id);\r\n    (_myInvestIncome, _myShared) = _getGameInfoPart3(msg.sender, _id);\r\n  }\r\n\r\n  function _getGameInfoPart1(address _addr, uint256 _id) internal view returns (uint256 _myMoney, uint256 _myRefund, uint256 _myDividends, uint256 _myReward, bool _claimed) {\r\n    uint256 totalMoney = 0;\r\n    uint k = 0;\r\n\r\n    if (_id == gameId) {\r\n     \r\n    } else {\r\n\r\n      for (uint256 i = 0; i < gameData.length; i++) {\r\n        GameData memory d = gameData[i];\r\n        if (d.gameId == _id) {\r\n\r\n          if (gameAuction[d.gameId].length > 1) {\r\n\r\n            // no.2 bidder can refund except for the last one\r\n            if (gameAuction[d.gameId][gameAuction[d.gameId].length - 1].addr == _addr) {\r\n              // if sender is winner\r\n              _myReward = d.reward;\r\n\r\n              _myReward = _myReward + gameAuction[d.gameId][gameAuction[d.gameId].length - 2].bid;\r\n            }\r\n\r\n            // add no.2 bidder's money to winner\r\n            // address loseBidder = gameAuction[d.gameId][gameAuction[d.gameId].length - 2].addr;\r\n\r\n            totalMoney = 0;\r\n            uint256 _moneyForCal = 0;\r\n\r\n            for (k = 0; k < gameAuction[d.gameId].length; k++) {\r\n\r\n              if (gameAuction[d.gameId][k].addr == _addr && gameAuction[d.gameId][k].dividended == true) {\r\n                _claimed = true;\r\n              }\r\n\r\n              // k != (gameAuction[d.gameId].length - 2): for no.2 bidder, who cannot refund this bid\r\n              if (gameAuction[d.gameId][k].addr == _addr && gameAuction[d.gameId][k].refunded == false && k != (gameAuction[d.gameId].length - 2)) {\r\n                _myRefund = _myRefund.add( gameAuction[d.gameId][k].money.sub( gameAuction[d.gameId][k].bid.mul(17).div(100) ) );\r\n                _moneyForCal = _moneyForCal.add( (gameAuction[d.gameId][k].money.div(10**15)).mul( gameAuction[d.gameId][k].money.div(10**15) ).mul( gameAuction[d.gameId].length + 1 - k) );\r\n                _myMoney = _myMoney.add(gameAuction[d.gameId][k].money);\r\n              }\r\n\r\n              if (gameAuction[d.gameId][k].refunded == false && k != (gameAuction[d.gameId].length - 2)) {\r\n                totalMoney = totalMoney.add( ( gameAuction[d.gameId][k].money.div(10**15) ).mul( gameAuction[d.gameId][k].money.div(10**15) ).mul( gameAuction[d.gameId].length + 1 - k) );\r\n              }\r\n            }\r\n\r\n            if (totalMoney != 0)\r\n              _myDividends = d.dividends.mul(_moneyForCal).div(totalMoney);\r\n\r\n          }\r\n  \r\n          break;\r\n        }\r\n      }\r\n    } \r\n  }\r\n\r\n  function _getGameInfoPart2(uint256 _id) internal view returns (uint256 _reward, uint256 _dividends) {\r\n    if (_id == gameId) {\r\n     \r\n    } else {\r\n      for (uint256 i = 0; i < gameData.length; i++) {\r\n        GameData memory d = gameData[i];\r\n        if (d.gameId == _id) {\r\n          _reward = d.reward;\r\n          _dividends = d.dividends;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function _getGameInfoPart3(address addr, uint256 _id) public view returns (uint256 _contributeReward, uint256 _shareReward) {\r\n    uint256 contributeDividend = 0;\r\n    uint256 total = 0;\r\n    uint256 money = 0;\r\n\r\n    uint256 i = 0;\r\n\r\n    if (_id == gameId) {\r\n      contributeDividend = dividendForContributor;\r\n    } else {\r\n      for (i = 0; i < gameData.length; i++) {\r\n        GameData memory d = gameData[i];\r\n        if (d.gameId == _id) {\r\n          contributeDividend = d.dividendForContributor;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < contributors[_id].length; i++) {\r\n      total = total + contributors[_id][i].money;\r\n      if (contributors[_id][i].addr == addr) {\r\n        money = money + contributors[_id][i].money;\r\n      }\r\n    }\r\n\r\n    if (total > 0)\r\n      _contributeReward = contributeDividend.mul(money).div(total);\r\n\r\n    // for invited money \r\n    _shareReward = shareds[_id][addr].money;\r\n\r\n  }\r\n\r\n  function getCurrTotalInvest() public view returns (uint256 invest) {\r\n    for (uint i = 0; i < contributors[gameId].length; i++) {\r\n      if (contributors[gameId][i].addr == msg.sender) {\r\n        invest = invest + contributors[gameId][i].money;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _isUserInGame(address addr) internal view returns (bool) {\r\n    uint256 k = 0;\r\n    for (k = 0; k < gameAuction[gameId].length; k++) {\r\n      if (gameAuction[gameId][k].addr == addr && gameAuction[gameId][k].refunded == false) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  ////////////////////////// game rule\r\n\r\n  function _getGameStartAuctionMoney() internal pure returns (uint256) {\r\n    return 10**15;\r\n  }\r\n\r\n  function _getGameAuctionGap() internal view returns (uint256) {\r\n    if (gameLastAuctionMoney < 10**18) {\r\n      return 10**15;\r\n    }\r\n\r\n    uint256 n = 17;\r\n    for (n = 18; n < 200; n ++) {\r\n      if (gameLastAuctionMoney >= 10**n && gameLastAuctionMoney < 10**(n + 1)) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return 10**(n-2);\r\n  }\r\n\r\n  function _getMinAuctionSeconds() internal pure returns (uint256) {\r\n    return 30 * 60;\r\n    // return 1 * 60; //test\r\n  }\r\n\r\n  function _getMaxAuctionSeconds() internal pure returns (uint256) {\r\n    return 24 * 60 * 60;\r\n    // return 5 * 60;  //test\r\n  }\r\n\r\n  function _getInitAuctionSeconds() internal pure returns (uint256) {\r\n    return 3 * 24 * 60 * 60;\r\n  }\r\n\r\n  // only invoke at the beginning of auction\r\n  function _getMinAuctionStartPrice() internal view returns (uint256) {\r\n    if (reward < 10**18) {\r\n      return 10**15;\r\n    }\r\n\r\n    uint256 n = 17;\r\n    for (n = 18; n < 200; n ++) {\r\n      if (reward >= 10**n && reward < 10**(n + 1)) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return 10**(n-2);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"adminAddMoney\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrCanRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviteMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrGameInfoPart1\",\"outputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_dividends\",\"type\":\"uint256\"},{\"name\":\"_lastAuction\",\"type\":\"uint256\"},{\"name\":\"_gap\",\"type\":\"uint256\"},{\"name\":\"_lastAuctionTime\",\"type\":\"uint256\"},{\"name\":\"_secondsLeft\",\"type\":\"uint256\"},{\"name\":\"_myMoney\",\"type\":\"uint256\"},{\"name\":\"_myDividends\",\"type\":\"uint256\"},{\"name\":\"_myRefund\",\"type\":\"uint256\"},{\"name\":\"_ended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"invitorAddr\",\"type\":\"address\"}],\"name\":\"auction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_dividends\",\"type\":\"uint256\"},{\"name\":\"_myMoney\",\"type\":\"uint256\"},{\"name\":\"_myDividends\",\"type\":\"uint256\"},{\"name\":\"_myRefund\",\"type\":\"uint256\"},{\"name\":\"_myReward\",\"type\":\"uint256\"},{\"name\":\"_myInvestIncome\",\"type\":\"uint256\"},{\"name\":\"_myShared\",\"type\":\"uint256\"},{\"name\":\"_claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrGameInfoPart2\",\"outputs\":[{\"name\":\"_myContributeMoney\",\"type\":\"uint256\"},{\"name\":\"_mySharedMoney\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"_getGameInfoPart3\",\"outputs\":[{\"name\":\"_contributeReward\",\"type\":\"uint256\"},{\"name\":\"_shareReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrTotalInvest\",\"outputs\":[{\"name\":\"invest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adminPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addAuctionReward\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"gameRoundEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getGameDataByIndex\",\"outputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinAuctionValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"money\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"secondsLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"datetime\",\"type\":\"uint256\"}],\"name\":\"GameAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"GameRewardClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"GameRewardRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"money\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"datetime\",\"type\":\"uint256\"}],\"name\":\"GameEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"GameInvited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Etherauction","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dc25500335cd9d3c3d0683f21d389bbb79617fbaf141fe34d9fa70c7873ab360"}]}