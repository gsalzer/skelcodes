{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n * \r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n * \r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n *  @title Ownable\r\n *  @dev Provides a modifier that requires the caller to be the owner of the contract.\r\n */\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event OwnerTransferred(\r\n        address indexed oldOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Owner account is required\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwner(address payable newOwner)\r\n    public\r\n    onlyOwner {\r\n        require(newOwner != owner, \"New Owner cannot be the current owner\");\r\n        require(newOwner != address(0), \"New Owner cannot be zero address\");\r\n        address payable prevOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnerTransferred(prevOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n *  @title Lockable\r\n *  @dev The Lockable contract adds the ability for the contract owner to set the lock status\r\n *  of the account. A modifier is provided that checks the throws when the contract is\r\n *  in the locked state.\r\n */\r\ncontract Lockable is Ownable {\r\n    bool public isLocked;\r\n\r\n    constructor() public {\r\n        isLocked = false;\r\n    }\r\n\r\n    modifier isUnlocked() {\r\n        require(!isLocked, \"Contract is currently locked for modification\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  Set the contract to a read-only state.\r\n     *  @param locked The locked state to set the contract to.\r\n     */\r\n    function setLocked(bool locked)\r\n    onlyOwner\r\n    external {\r\n        require(isLocked != locked, \"Contract already in requested lock state\");\r\n\r\n        isLocked = locked;\r\n    }\r\n}\r\n\r\n/**\r\n *  @title Destroyable\r\n *  @dev The Destroyable contract alows the owner address to `selfdestruct` the contract.\r\n */\r\ncontract Destroyable is Ownable {\r\n    /**\r\n     *  Allow the owner to destroy this contract.\r\n     */\r\n    function kill()\r\n    onlyOwner\r\n    external {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\n/**\r\n *  Contract to facilitate locking and self destructing.\r\n */\r\ncontract LockableDestroyable is Lockable, Destroyable { }\r\n\r\nlibrary AdditiveMath {\r\n    /**\r\n     *  Adds two numbers and returns the result\r\n     *  THROWS when the result overflows\r\n     *  @return The sum of the arguments\r\n     */\r\n    function add(uint256 x, uint256 y)\r\n    internal\r\n    pure\r\n    returns (uint256) {\r\n        uint256 sum = x + y;\r\n        require(sum >= x, \"Results in overflow\");\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     *  Subtracts two numbers and returns the result\r\n     *  THROWS when the result underflows\r\n     *  @return The difference of the arguments\r\n     */\r\n    function subtract(uint256 x, uint256 y)\r\n    internal\r\n    pure\r\n    returns (uint256) {\r\n        require(y <= x, \"Results in underflow\");\r\n        return x - y;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n *  @title AddressMap\r\n *  @dev Map of unique indexed addresseses.\r\n *\r\n *  **NOTE**\r\n *    The internal collections are one-based.\r\n *    This is simply because null values are expressed as zero,\r\n *    which makes it hard to check for the existence of items within the array,\r\n *    or grabbing the first item of an array for non-existent items.\r\n *\r\n *    This is only exposed internally, so callers still use zero-based indices.\r\n *\r\n */\r\nlibrary AddressMap {\r\n    struct Data {\r\n        int256 count;\r\n        mapping(address => int256) indices;\r\n        mapping(int256 => address) items;\r\n    }\r\n\r\n    address constant ZERO_ADDRESS = address(0);\r\n\r\n    /**\r\n     *  Appends the address to the end of the map, if the address is not\r\n     *  zero and the address doesn't currently exist.\r\n     *  @param addr The address to append.\r\n     *  @return true if the address was added.\r\n     */\r\n    function append(Data storage self, address addr)\r\n    internal\r\n    returns (bool) {\r\n        if (addr == ZERO_ADDRESS) {\r\n            return false;\r\n        }\r\n\r\n        int256 index = self.indices[addr] - 1;\r\n        if (index >= 0 && index < self.count) {\r\n            return false;\r\n        }\r\n\r\n        self.count++;\r\n        self.indices[addr] = self.count;\r\n        self.items[self.count] = addr;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  Removes the given address from the map.\r\n     *  @param addr The address to remove from the map.\r\n     *  @return true if the address was removed.\r\n     */\r\n    function remove(Data storage self, address addr)\r\n    internal\r\n    returns (bool) {\r\n        int256 oneBasedIndex = self.indices[addr];\r\n        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\r\n            return false;  // address doesn't exist, or zero.\r\n        }\r\n\r\n        // When the item being removed is not the last item in the collection,\r\n        // replace that item with the last one, otherwise zero it out.\r\n        //\r\n        //  If {2} is the item to be removed\r\n        //     [0, 1, 2, 3, 4]\r\n        //  The result would be:\r\n        //     [0, 1, 4, 3]\r\n        //\r\n        if (oneBasedIndex < self.count) {\r\n            // Replace with last item\r\n            address last = self.items[self.count];  // Get the last item\r\n            self.indices[last] = oneBasedIndex;     // Update last items index to current index\r\n            self.items[oneBasedIndex] = last;       // Update current index to last item\r\n            delete self.items[self.count];          // Delete the last item, since it's moved\r\n        } else {\r\n            // Delete the address\r\n            delete self.items[oneBasedIndex];\r\n        }\r\n\r\n        delete self.indices[addr];\r\n        self.count--;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clears all items within the map.\r\n     */\r\n    function clear(Data storage self)\r\n    internal {\r\n        self.count = 0;\r\n    }\r\n\r\n    /**\r\n     *  Retrieves the address at the given index.\r\n     *  THROWS when the index is invalid.\r\n     *  @param index The index of the item to retrieve.\r\n     *  @return The address of the item at the given index.\r\n     */\r\n    function at(Data storage self, int256 index)\r\n    internal\r\n    view\r\n    returns (address) {\r\n        require(index >= 0 && index < self.count, \"Index outside of bounds.\");\r\n        return self.items[index + 1];\r\n    }\r\n\r\n    /**\r\n     *  Gets the index of the given address.\r\n     *  @param addr The address of the item to get the index for.\r\n     *  @return The index of the given address.\r\n     */\r\n    function indexOf(Data storage self, address addr)\r\n    internal\r\n    view\r\n    returns (int256) {\r\n        if (addr == ZERO_ADDRESS) {\r\n            return -1;\r\n        }\r\n\r\n        int256 index = self.indices[addr] - 1;\r\n        if (index < 0 || index >= self.count) {\r\n            return -1;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     *  Returns whether or not the given address exists within the map.\r\n     *  @param addr The address to check for existence.\r\n     *  @return If the given address exists or not.\r\n     */\r\n    function exists(Data storage self, address addr)\r\n    internal\r\n    view\r\n    returns (bool) {\r\n        int256 index = self.indices[addr] - 1;\r\n        return index >= 0 && index < self.count;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *\r\n *  @title AccountMap\r\n *  @dev Map of unique indexed accounts.\r\n *\r\n *  **NOTE**\r\n *    The internal collections are one-based.\r\n *    This is simply because null values are expressed as zero,\r\n *    which makes it hard to check for the existence of items within the array,\r\n *    or grabbing the first item of an array for non-existent items.\r\n *\r\n *    This is only exposed internally, so callers still use zero-based indices.\r\n *\r\n */\r\nlibrary AccountMap {\r\n    struct Account {\r\n        address addr;\r\n        uint8 kind;\r\n        bool frozen;\r\n        address parent;\r\n    }\r\n\r\n    struct Data {\r\n        int256 count;\r\n        mapping(address => int256) indices;\r\n        mapping(int256 => Account) items;\r\n    }\r\n\r\n    address constant ZERO_ADDRESS = address(0);\r\n\r\n    /**\r\n     *  Appends the address to the end of the map, if the addres is not\r\n     *  zero and the address doesn't currently exist.\r\n     *  @param addr The address to append.\r\n     *  @return true if the address was added.\r\n     */\r\n    function append(Data storage self, address addr, uint8 kind, bool isFrozen, address parent)\r\n    internal\r\n    returns (bool) {\r\n        if (addr == ZERO_ADDRESS) {\r\n            return false;\r\n        }\r\n\r\n        int256 index = self.indices[addr] - 1;\r\n        if (index >= 0 && index < self.count) {\r\n            return false;\r\n        }\r\n\r\n        self.count++;\r\n        self.indices[addr] = self.count;\r\n        self.items[self.count] = Account(addr, kind, isFrozen, parent);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  Removes the given address from the map.\r\n     *  @param addr The address to remove from the map.\r\n     *  @return true if the address was removed.\r\n     */\r\n    function remove(Data storage self, address addr)\r\n    internal\r\n    returns (bool) {\r\n        int256 oneBasedIndex = self.indices[addr];\r\n        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\r\n            return false;  // address doesn't exist, or zero.\r\n        }\r\n\r\n        // When the item being removed is not the last item in the collection,\r\n        // replace that item with the last one, otherwise zero it out.\r\n        //\r\n        //  If {2} is the item to be removed\r\n        //     [0, 1, 2, 3, 4]\r\n        //  The result would be:\r\n        //     [0, 1, 4, 3]\r\n        //\r\n        if (oneBasedIndex < self.count) {\r\n            // Replace with last item\r\n            Account storage last = self.items[self.count];  // Get the last item\r\n            self.indices[last.addr] = oneBasedIndex;        // Update last items index to current index\r\n            self.items[oneBasedIndex] = last;               // Update current index to last item\r\n            delete self.items[self.count];                  // Delete the last item, since it's moved\r\n        } else {\r\n            // Delete the account\r\n            delete self.items[oneBasedIndex];\r\n        }\r\n\r\n        delete self.indices[addr];\r\n        self.count--;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clears all items within the map.\r\n     */\r\n    function clear(Data storage self)\r\n    internal {\r\n        self.count = 0;\r\n    }\r\n\r\n    /**\r\n     *  Retrieves the address at the given index.\r\n     *  THROWS when the index is invalid.\r\n     *  @param index The index of the item to retrieve.\r\n     *  @return The address of the item at the given index.\r\n     */\r\n    function at(Data storage self, int256 index)\r\n    internal\r\n    view\r\n    returns (Account memory) {\r\n        require(index >= 0 && index < self.count, \"Index outside of bounds.\");\r\n        return self.items[index + 1];\r\n    }\r\n\r\n    /**\r\n     *  Gets the index of the given address.\r\n     *  @param addr The address of the item to get the index for.\r\n     *  @return The index of the given address.\r\n     */\r\n    function indexOf(Data storage self, address addr)\r\n    internal\r\n    view\r\n    returns (int256) {\r\n        if (addr == ZERO_ADDRESS) {\r\n            return -1;\r\n        }\r\n\r\n        int256 index = self.indices[addr] - 1;\r\n        if (index < 0 || index >= self.count) {\r\n            return -1;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     *  Gets the Account for the given address.\r\n     *  THROWS when an account doesn't exist for the given address.\r\n     *  @param addr The address of the item to get.\r\n     *  @return The account of the given address.\r\n     */\r\n    function get(Data storage self, address addr)\r\n    internal\r\n    view\r\n    returns (Account memory) {\r\n        return at(self, indexOf(self, addr));\r\n    }\r\n\r\n    /**\r\n     *  Returns whether or not the given address exists within the map.\r\n     *  @param addr The address to check for existence.\r\n     *  @return If the given address exists or not.\r\n     */\r\n    function exists(Data storage self, address addr)\r\n    internal\r\n    view\r\n    returns (bool) {\r\n        int256 index = self.indices[addr] - 1;\r\n        return index >= 0 && index < self.count;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  @title Registry Storage\r\n */\r\ncontract Storage is Ownable, LockableDestroyable {\r\n  \r\n    using AccountMap for AccountMap.Data;\r\n    using AddressMap for AddressMap.Data;\r\n\r\n    // ------------------------------- Variables -------------------------------\r\n    // Number of data slots available for accounts\r\n    uint8 constant MAX_DATA = 30;\r\n\r\n    // Accounts\r\n    AccountMap.Data public accounts;\r\n\r\n    // Account Data\r\n    //   - mapping of:\r\n    //     (address        => (index =>    data))\r\n    mapping(address => mapping(uint8 => bytes32)) public data;\r\n\r\n    // Address write permissions\r\n    //     (kind  => address)\r\n    mapping(uint8 => AddressMap.Data) public permissions;\r\n\r\n\r\n    // ------------------------------- Modifiers -------------------------------\r\n    /**\r\n     *  Ensures the `msg.sender` has permission for the given kind/type of account.\r\n     *\r\n     *    - The `owner` account is always allowed\r\n     *    - Addresses/Contracts must have a corresponding entry, for the given kind\r\n     */\r\n    modifier isAllowed(uint8 kind) {\r\n        require(kind > 0, \"Invalid, or missing permission\");\r\n        if (msg.sender != owner) {\r\n            require(permissions[kind].exists(msg.sender), \"Missing permission\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     *  Adds an account to storage\r\n     *  THROWS when `msg.sender` doesn't have permission\r\n     *  THROWS when the account already exists\r\n     *  @param addr The address of the account\r\n     *  @param kind The kind of account\r\n     *  @param isFrozen The frozen status of the account\r\n     *  @param parent The account parent/owner\r\n     */\r\n    function addAccount(address addr, uint8 kind, bool isFrozen, address parent)\r\n    isUnlocked\r\n    isAllowed(kind)\r\n    external {\r\n        require(accounts.append(addr, kind, isFrozen, parent), \"Account already exists\");\r\n    }\r\n\r\n    /**\r\n     *  Sets an account's frozen status\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address of the account\r\n     *  @param frozen The frozen status of the account\r\n     */\r\n    function setAccountFrozen(address addr, bool frozen)\r\n    isUnlocked\r\n    isAllowed(accounts.get(addr).kind)\r\n    external {\r\n        // NOTE: Not bounds checking `index` here, as `isAllowed` ensures the address exists.\r\n        //       Indices are one-based internally, so we need to add one to compensate.\r\n        int256 index = accounts.indexOf(addr) + 1;\r\n        accounts.items[index].frozen = frozen;\r\n    }\r\n\r\n    /**\r\n     *  Removes an account from storage\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address of the account\r\n     */\r\n    function removeAccount(address addr)\r\n    isUnlocked\r\n    isAllowed(accounts.get(addr).kind)\r\n    external {\r\n        bytes32 ZERO_BYTES = bytes32(0);\r\n        mapping(uint8 => bytes32) storage accountData = data[addr];\r\n\r\n        // Remove data\r\n        for (uint8 i = 0; i < MAX_DATA; i++) {\r\n            if (accountData[i] != ZERO_BYTES) {\r\n                delete accountData[i];\r\n            }\r\n        }\r\n\r\n        // Remove account\r\n        accounts.remove(addr);\r\n    }\r\n\r\n    /**\r\n     *  Sets data for an address/caller\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address\r\n     *  @param index The index of the data\r\n     *  @param customData The data store set\r\n     */\r\n    function setAccountData(address addr, uint8 index, bytes32 customData)\r\n    isUnlocked\r\n    isAllowed(accounts.get(addr).kind)\r\n    external {\r\n        require(index < MAX_DATA, \"index outside of bounds\");\r\n        data[addr][index] = customData;\r\n    }\r\n\r\n    /**\r\n     *  Grants the address permission for the given kind\r\n     *  @param kind The kind of address\r\n     *  @param addr The address\r\n     */\r\n    function grantPermission(uint8 kind, address addr)\r\n    isUnlocked\r\n    isAllowed(kind)\r\n    external {\r\n        permissions[kind].append(addr);\r\n    }\r\n\r\n    /**\r\n     *  Revokes the address permission for the given kind\r\n     *  @param kind The kind of address\r\n     *  @param addr The address\r\n     */\r\n    function revokePermission(uint8 kind, address addr)\r\n    isUnlocked\r\n    isAllowed(kind)\r\n    external {\r\n        permissions[kind].remove(addr);\r\n    }\r\n\r\n    // ---------------------------- Address Getters ----------------------------\r\n    /**\r\n     *  Gets the account at the given index\r\n     *  THROWS when the index is out-of-bounds\r\n     *  @param index The index of the item to retrieve\r\n     *  @return The address, kind, frozen status, and parent of the account at the given index\r\n     */\r\n    function accountAt(int256 index)\r\n    external\r\n    view\r\n    returns(address, uint8, bool, address) {\r\n        AccountMap.Account memory acct = accounts.at(index);\r\n        return (acct.addr, acct.kind, acct.frozen, acct.parent);\r\n    }\r\n\r\n    /**\r\n     *  Gets the account for the given address\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address of the item to retrieve\r\n     *  @return The address, kind, frozen status, and parent of the account at the given index\r\n     */\r\n    function accountGet(address addr)\r\n    external\r\n    view\r\n    returns(uint8, bool, address) {\r\n        AccountMap.Account memory acct = accounts.get(addr);\r\n        return (acct.kind, acct.frozen, acct.parent);\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent address for the given account address\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address of the account\r\n     *  @return The parent address\r\n     */\r\n    function accountParent(address addr)\r\n    external\r\n    view\r\n    returns(address) {\r\n        return accounts.get(addr).parent;\r\n    }\r\n\r\n    /**\r\n     *  Gets the account kind, for the given account address\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address of the account\r\n     *  @return The kind of account\r\n     */\r\n    function accountKind(address addr)\r\n    external\r\n    view\r\n    returns(uint8) {\r\n        return accounts.get(addr).kind;\r\n    }\r\n\r\n    /**\r\n     *  Gets the frozen status of the account\r\n     *  THROWS when the account doesn't exist\r\n     *  @param addr The address of the account\r\n     *  @return The frozen status of the account\r\n     */\r\n    function accountFrozen(address addr)\r\n    external\r\n    view\r\n    returns(bool) {\r\n        return accounts.get(addr).frozen;\r\n    }\r\n\r\n    /**\r\n     *  Gets the index of the account\r\n     *  Returns -1 for missing accounts\r\n     *  @param addr The address of the account to get the index for\r\n     *  @return The index of the given account address\r\n     */\r\n    function accountIndexOf(address addr)\r\n    external\r\n    view\r\n    returns(int256) {\r\n        return accounts.indexOf(addr);\r\n    }\r\n\r\n    /**\r\n     *  Returns wether or not the given address exists\r\n     *  @param addr The account address\r\n     *  @return If the given address exists\r\n     */\r\n    function accountExists(address addr)\r\n    external\r\n    view\r\n    returns(bool) {\r\n        return accounts.exists(addr);\r\n    }\r\n\r\n    /**\r\n     *  Returns wether or not the given address exists for the given kind\r\n     *  @param addr The account address\r\n     *  @param kind The kind of address\r\n     *  @return If the given address exists with the given kind\r\n     */\r\n    function accountExists(address addr, uint8 kind)\r\n    external\r\n    view\r\n    returns(bool) {\r\n        int256 index = accounts.indexOf(addr);\r\n        if (index < 0) {\r\n            return false;\r\n        }\r\n        return accounts.at(index).kind == kind;\r\n    }\r\n\r\n\r\n    // -------------------------- Permission Getters ---------------------------\r\n    /**\r\n     *  Retrieves the permission address at the index for the given type\r\n     *  THROWS when the index is out-of-bounds\r\n     *  @param kind The kind of permission\r\n     *  @param index The index of the item to retrieve\r\n     *  @return The permission address of the item at the given index\r\n     */\r\n    function permissionAt(uint8 kind, int256 index)\r\n    external\r\n    view\r\n    returns(address) {\r\n        return permissions[kind].at(index);\r\n    }\r\n\r\n    /**\r\n     *  Gets the index of the permission address for the given type\r\n     *  Returns -1 for missing permission\r\n     *  @param kind The kind of perission\r\n     *  @param addr The address of the permission to get the index for\r\n     *  @return The index of the given permission address\r\n     */\r\n    function permissionIndexOf(uint8 kind, address addr)\r\n    external\r\n    view\r\n    returns(int256) {\r\n        return permissions[kind].indexOf(addr);\r\n    }\r\n\r\n    /**\r\n     *  Returns wether or not the given permission address exists for the given type\r\n     *  @param kind The kind of permission\r\n     *  @param addr The address to check for permission\r\n     *  @return If the given address has permission or not\r\n     */\r\n    function permissionExists(uint8 kind, address addr)\r\n    external\r\n    view\r\n    returns(bool) {\r\n        return permissions[kind].exists(addr);\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface ComplianceRule {\r\n\r\n    /**\r\n     *  @dev Checks if a transfer can occur between the from/to addresses and MUST throw when the check fails.\r\n     *  @param initiator The address initiating the transfer.\r\n     *  @param from The address of the sender\r\n     *  @param to The address of the receiver\r\n     *  @param toKind The kind of the to address\r\n     *  @param tokens The number of tokens being transferred.\r\n     *  @param store The Storage contract\r\n     */\r\n    function check(address initiator, address from, address to, uint8 toKind, uint256 tokens, Storage store)\r\n    external;\r\n}\r\n\r\ninterface Compliance {\r\n\r\n    /**\r\n     *  This event is emitted when an address's frozen status has changed.\r\n     *  @param addr The address whose frozen status has been updated.\r\n     *  @param isFrozen Whether the custodian is being frozen.\r\n     *  @param owner The address that updated the frozen status.\r\n     */\r\n    event AddressFrozen(\r\n        address indexed addr,\r\n        bool indexed isFrozen,\r\n        address indexed owner\r\n    );\r\n\r\n    /**\r\n     *  Sets an address frozen status for this token\r\n     *  @param addr The address to update frozen status.\r\n     *  @param freeze Frozen status of the address.\r\n     */\r\n    function setFrozen(address addr, bool freeze)\r\n    external;\r\n\r\n    /**\r\n     *  Replaces all of the existing rules with the given ones\r\n     *  @param kind The bucket of rules to set.\r\n     *  @param rules New compliance rules.\r\n     */\r\n    function setRules(uint8 kind, ComplianceRule[] calldata rules)\r\n    external;\r\n\r\n    /**\r\n     *  Returns all of the current compliance rules for this token\r\n     *  @param kind The bucket of rules to get.\r\n     *  @return List of all compliance rules.\r\n     */\r\n    function getRules(uint8 kind)\r\n    external\r\n    view\r\n    returns (ComplianceRule[] memory);\r\n\r\n    /**\r\n     *  @dev Checks if issuance can occur between the from/to addresses.\r\n     *\r\n     *  Both addresses must be whitelisted and unfrozen\r\n     *  THROWS when the transfer should fail.\r\n     *  @param issuer The address initiating the issuance.\r\n     *  @param from The address of the sender.\r\n     *  @param to The address of the receiver.\r\n     *  @param tokens The number of tokens being transferred.\r\n     *  @return If a issuance can occur between the from/to addresses.\r\n     */\r\n    function canIssue(address issuer, address from, address to, uint256 tokens)\r\n    external\r\n    returns (bool);\r\n\r\n    /**\r\n     *  @dev Checks if a transfer can occur between the from/to addresses.\r\n     *\r\n     *  Both addresses must be whitelisted, unfrozen, and pass all compliance rule checks.\r\n     *  THROWS when the transfer should fail.\r\n     *  @param initiator The address initiating the transfer.\r\n     *  @param from The address of the sender.\r\n     *  @param to The address of the receiver.\r\n     *  @param tokens The number of tokens being transferred.\r\n     *  @return If a transfer can occur between the from/to addresses.\r\n     */\r\n    function canTransfer(address initiator, address from, address to, uint256 tokens)\r\n    external\r\n    returns (bool);\r\n\r\n    /**\r\n     *  @dev Checks if an override by the sender can occur between the from/to addresses.\r\n     *\r\n     *  Both addresses must be whitelisted and unfrozen.\r\n     *  THROWS when the sender is not allowed to override.\r\n     *  @param admin The address initiating the transfer.\r\n     *  @param from The address of the sender.\r\n     *  @param to The address of the receiver.\r\n     *  @param tokens The number of tokens being transferred.\r\n     *  @return If an override can occur between the from/to addresses.\r\n     */\r\n    function canOverride(address admin, address from, address to, uint256 tokens)\r\n    external\r\n    returns (bool);\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract T0ken is ERC20, Ownable, LockableDestroyable {\r\n\r\n    // ------------------------------- Variables -------------------------------\r\n\r\n    using AdditiveMath for uint256;\r\n    using AddressMap for AddressMap.Data;\r\n\r\n    address constant internal ZERO_ADDRESS = address(0);\r\n    string public constant name = \"TZERO PREFERRED\";\r\n    string public constant symbol = \"TZROP\";\r\n    uint8 public constant decimals = 0;\r\n\r\n    AddressMap.Data public shareholders;\r\n    Compliance public compliance;\r\n    address public issuer;\r\n    bool public issuingFinished = false;\r\n    mapping(address => address) public cancellations;\r\n\r\n    mapping(address => uint256) internal balances;\r\n    uint256 internal totalSupplyTokens;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n\r\n    // ------------------------------- Modifiers -------------------------------\r\n\r\n    modifier onlyIssuer() {\r\n        require(msg.sender == issuer, \"Only issuer allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier canIssue() {\r\n        require(!issuingFinished, \"Issuing is already finished\");\r\n        _;\r\n    }\r\n\r\n    modifier isNotCancelled(address addr) {\r\n        require(cancellations[addr] == ZERO_ADDRESS, \"Address has been cancelled\");\r\n        _;\r\n    }\r\n\r\n    modifier hasFunds(address addr, uint256 tokens) {\r\n        require(tokens <= balances[addr], \"Insufficient funds\");\r\n        _;\r\n    }\r\n\r\n    // -------------------------------- Events ---------------------------------\r\n\r\n    /**\r\n     *  This event is emitted when an address is cancelled and replaced with\r\n     *  a new address.  This happens in the case where a shareholder has\r\n     *  lost access to their original address and needs to have their share\r\n     *  reissued to a new address.  This is the equivalent of issuing replacement\r\n     *  share certificates.\r\n     *  @param original The address being superseded.\r\n     *  @param replacement The new address.\r\n     *  @param sender The address that caused the address to be superseded.\r\n    */\r\n    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);\r\n    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);\r\n    event Issue(address indexed to, uint256 tokens);\r\n    event IssueFinished();\r\n    event ShareholderAdded(address shareholder);\r\n    event ShareholderRemoved(address shareholder);\r\n\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     *  @dev Transfers tokens to the whitelisted account.\r\n     *\r\n     *  If the 'to' address is not currently a shareholder then it MUST become one.\r\n     *  If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed\r\n     *  from the list of shareholders.\r\n     *  MUST be removed from the list of shareholders.\r\n     *  @param to The address to transfer to.\r\n     *  @param tokens The number of tokens to be transferred.\r\n     */\r\n    function transfer(address to, uint256 tokens)\r\n    external\r\n    isUnlocked\r\n    isNotCancelled(to)\r\n    hasFunds(msg.sender, tokens)\r\n    returns (bool) {\r\n        bool transferAllowed;\r\n\r\n        // Issuance\r\n        if (msg.sender == issuer) {\r\n            transferAllowed = address(compliance) == ZERO_ADDRESS;\r\n            if (!transferAllowed) {\r\n                transferAllowed = compliance.canIssue(issuer, issuer, to, tokens);\r\n            }\r\n        }\r\n        // Transfer\r\n        else {\r\n            transferAllowed = canTransfer(msg.sender, to, tokens, false);\r\n        }\r\n\r\n        // Ensure the transfer is allowed.\r\n        if (transferAllowed) {\r\n            transferTokens(msg.sender, to, tokens);\r\n        }\r\n        return transferAllowed;\r\n    }\r\n\r\n    /**\r\n     *  @dev Transfers tokens between whitelisted accounts.\r\n     *\r\n     *  If the 'to' address is not currently a shareholder then it MUST become one.\r\n     *  If the transfer will reduce 'from' balance to 0 then that address MUST be removed from the list of shareholders.\r\n     *  @param from The address to transfer from\r\n     *  @param to The address to transfer to.\r\n     *  @param tokens uint256 the number of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokens)\r\n    external\r\n    isUnlocked\r\n    isNotCancelled(to)\r\n    hasFunds(from, tokens)\r\n    returns (bool) {\r\n        require(tokens <= allowed[from][msg.sender], \"Transfer exceeds allowance\");\r\n\r\n        // Transfer the tokens\r\n        bool transferAllowed = canTransfer(from, to, tokens, false);\r\n        if (transferAllowed) {\r\n            // Update the allowance to reflect the transfer\r\n            allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);\r\n            // Transfer the tokens\r\n            transferTokens(from, to, tokens);\r\n        }\r\n        return transferAllowed;\r\n    }\r\n\r\n    /**\r\n     *  @dev Overrides a transfer of tokens to the whitelisted account.\r\n     *\r\n     *  If the 'to' address is not currently a shareholder then it MUST become one.\r\n     *  If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed\r\n     *  from the list of shareholders.\r\n     *  MUST be removed from the list of shareholders.\r\n     *  @param from The address to transfer from\r\n     *  @param to The address to transfer to.\r\n     *  @param tokens The number of tokens to be transferred.\r\n     */\r\n    function transferOverride(address from, address to, uint256 tokens)\r\n    external\r\n    isUnlocked\r\n    isNotCancelled(to)\r\n    hasFunds(from, tokens)\r\n    returns (bool) {\r\n        // Ensure the sender can perform the override.\r\n        bool transferAllowed = canTransfer(from, to, tokens, true);\r\n        // Ensure the transfer is allowed.\r\n        if (transferAllowed) {\r\n            transferTokens(from, to, tokens);\r\n        }\r\n        return transferAllowed;\r\n    }\r\n\r\n    /**\r\n     *  @dev Tokens will be issued to the issuer's address only.\r\n     *  @param quantity The number of tokens to mint.\r\n     *  @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function issueTokens(uint256 quantity)\r\n    external\r\n    isUnlocked\r\n    onlyIssuer\r\n    canIssue\r\n    returns (bool) {\r\n        // Avoid doing any state changes for zero quantities\r\n        if (quantity > 0) {\r\n            totalSupplyTokens = totalSupplyTokens.add(quantity);\r\n            balances[issuer] = balances[issuer].add(quantity);\r\n            shareholders.append(issuer);\r\n        }\r\n        emit Issue(issuer, quantity);\r\n        emit Transfer(ZERO_ADDRESS, issuer, quantity);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @dev Finishes token issuance.\r\n     *  This is a single use function, once invoked it cannot be undone.\r\n     */\r\n    function finishIssuing()\r\n    external\r\n    isUnlocked\r\n    onlyIssuer\r\n    canIssue\r\n    returns (bool) {\r\n        issuingFinished = true;\r\n        emit IssueFinished();\r\n        return issuingFinished;\r\n    }\r\n\r\n    /**\r\n     *  @dev Cancel the original address and reissue the Tokens to the replacement address.\r\n     *\r\n     *  Access to this function is restricted to the Issuer only.\r\n     *  The 'original' address MUST be removed from the set of whitelisted addresses.\r\n     *  Throw if the 'original' address supplied is not a shareholder.\r\n     *  Throw if the 'replacement' address is not a whitelisted address.\r\n     *  This function MUST emit the 'VerifiedAddressSuperseded' event.\r\n     *  @param original The address to be superseded. This address MUST NOT be reused and must be whitelisted.\r\n     *  @param replacement The address  that supersedes the original. This address MUST be whitelisted.\r\n     */\r\n    function cancelAndReissue(address original, address replacement)\r\n    external\r\n    isUnlocked\r\n    onlyIssuer\r\n    isNotCancelled(replacement) {\r\n        // Ensure the reissue can take place\r\n        require(shareholders.exists(original) && !shareholders.exists(replacement), \"Original doesn't exist or replacement does\");\r\n        if (address(compliance) != ZERO_ADDRESS) {\r\n            require(compliance.canIssue(msg.sender, original, replacement, balances[original]), \"Failed 'canIssue' check.\");\r\n        }\r\n\r\n        // Replace the original shareholder with the replacement\r\n        shareholders.remove(original);\r\n        shareholders.append(replacement);\r\n        // Add the original as a cancelled address (preventing it from future trading)\r\n        cancellations[original] = replacement;\r\n        // Transfer the balance to the replacement\r\n        balances[replacement] = balances[original];\r\n        balances[original] = 0;\r\n        emit VerifiedAddressSuperseded(original, replacement, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified number of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param tokens The number of tokens of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 tokens)\r\n    external\r\n    isUnlocked\r\n    isNotCancelled(msg.sender)\r\n    returns (bool) {\r\n        require(shareholders.exists(msg.sender), \"Must be a shareholder to approve token transfer\");\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @dev Set the issuer address.\r\n     *  @param newIssuer The address of the issuer.\r\n     */\r\n    function setIssuer(address newIssuer)\r\n    external\r\n    isUnlocked\r\n    onlyOwner {\r\n        issuer = newIssuer;\r\n        emit IssuerSet(issuer, newIssuer);\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets the compliance contract address to use during transfers.\r\n     *  @param newComplianceAddress The address of the compliance contract.\r\n     */\r\n    function setCompliance(address newComplianceAddress)\r\n    external\r\n    isUnlocked\r\n    onlyOwner {\r\n        compliance = Compliance(newComplianceAddress);\r\n    }\r\n\r\n    // -------------------------------- Getters --------------------------------\r\n\r\n    /**\r\n     *  @dev Returns the total token supply\r\n     *  @return total number of tokens in existence\r\n     */\r\n    function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256) {\r\n        return totalSupplyTokens;\r\n    }\r\n\r\n    /**\r\n     *  @dev Gets the balance of the specified address.\r\n     *  @param addr The address to query the the balance of.\r\n     *  @return An uint256 representing the tokens owned by the passed address.\r\n     */\r\n    function balanceOf(address addr)\r\n    external\r\n    view\r\n    returns (uint256) {\r\n        return balances[addr];\r\n    }\r\n\r\n    /**\r\n     *  @dev Gets the number of tokens that an owner has allowed the spender to transfer.\r\n     *  @param addrOwner address The address which owns the funds.\r\n     *  @param spender address The address which will spend the funds.\r\n     *  @return A uint256 specifying the number of tokens still available for the spender.\r\n     */\r\n    function allowance(address addrOwner, address spender)\r\n    external\r\n    view\r\n    returns (uint256) {\r\n        return allowed[addrOwner][spender];\r\n    }\r\n\r\n    /**\r\n     *  By counting the number of token holders using 'holderCount'\r\n     *  you can retrieve the complete list of token holders, one at a time.\r\n     *  It MUST throw if 'index >= holderCount()'.\r\n     *  @dev Returns the holder at the given index.\r\n     *  @param index The zero-based index of the holder.\r\n     *  @return the address of the token holder with the given index.\r\n     */\r\n    function holderAt(int256 index)\r\n    external\r\n    view\r\n    returns (address){\r\n        return shareholders.at(index);\r\n    }\r\n\r\n    /**\r\n     *  @dev Checks to see if the supplied address is a share holder.\r\n     *  @param addr The address to check.\r\n     *  @return true if the supplied address owns a token.\r\n     */\r\n    function isHolder(address addr)\r\n    external\r\n    view\r\n    returns (bool) {\r\n        return shareholders.exists(addr);\r\n    }\r\n\r\n    /**\r\n     *  @dev Checks to see if the supplied address was superseded.\r\n     *  @param addr The address to check.\r\n     *  @return true if the supplied address was superseded by another address.\r\n     */\r\n    function isSuperseded(address addr)\r\n    external\r\n    view\r\n    returns (bool) {\r\n        return cancellations[addr] != ZERO_ADDRESS;\r\n    }\r\n\r\n    /**\r\n     *  Gets the most recent address, given a superseded one.\r\n     *  Addresses may be superseded multiple times, so this function needs to\r\n     *  follow the chain of addresses until it reaches the final, verified address.\r\n     *  @param addr The superseded address.\r\n     *  @return the verified address that ultimately holds the share.\r\n     */\r\n    function getSuperseded(address addr)\r\n    external\r\n    view\r\n    returns (address) {\r\n        require(addr != ZERO_ADDRESS, \"Non-zero address required\");\r\n\r\n        address candidate = cancellations[addr];\r\n        if (candidate == ZERO_ADDRESS) {\r\n            return ZERO_ADDRESS;\r\n        }\r\n        return candidate;\r\n    }\r\n\r\n\r\n    // -------------------------------- Private --------------------------------\r\n\r\n    /**\r\n     *  @dev Checks if a transfer/override may take place between the two accounts.\r\n     *\r\n     *   Validates that the transfer can take place.\r\n     *     - Ensure the 'to' address is not cancelled\r\n     *     - Ensure the transfer is compliant\r\n     *  @param from The sender address.\r\n     *  @param to The recipient address.\r\n     *  @param tokens The number of tokens being transferred.\r\n     *  @param isOverride If this is a transfer override\r\n     *  @return If the transfer can take place.\r\n     */\r\n    function canTransfer(address from, address to, uint256 tokens, bool isOverride)\r\n    private\r\n    isNotCancelled(to)\r\n    returns (bool) {\r\n        // Don't allow overrides and ignore compliance rules when compliance not set.\r\n        if (address(compliance) == ZERO_ADDRESS) {\r\n            return !isOverride;\r\n        }\r\n\r\n        // Ensure the override is valid, or that the transfer is compliant.\r\n        if (isOverride) {\r\n            return compliance.canOverride(msg.sender, from, to, tokens);\r\n        } else {\r\n            return compliance.canTransfer(msg.sender, from, to, tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Transfers tokens from one address to another\r\n     *  @param from The sender address.\r\n     *  @param to The recipient address.\r\n     *  @param tokens The number of tokens being transferred.\r\n     */\r\n    function transferTokens(address from, address to, uint256 tokens)\r\n    private {\r\n        // Update balances\r\n        balances[from] = balances[from].subtract(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(from, to, tokens);\r\n\r\n        // Adds the shareholder if they don't already exist.\r\n        if (balances[to] > 0 && shareholders.append(to)) {\r\n            emit ShareholderAdded(to);\r\n        }\r\n        // Remove the shareholder if they no longer hold tokens.\r\n        if (balances[from] == 0 && shareholders.remove(from)) {\r\n            emit ShareholderRemoved(from);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"setLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isSuperseded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cancellations\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholders\",\"outputs\":[{\"name\":\"count\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIssuer\",\"type\":\"address\"}],\"name\":\"setIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compliance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"original\",\"type\":\"address\"},{\"name\":\"replacement\",\"type\":\"address\"}],\"name\":\"cancelAndReissue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIssuing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferOverride\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"int256\"}],\"name\":\"holderAt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addrOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getSuperseded\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newComplianceAddress\",\"type\":\"address\"}],\"name\":\"setCompliance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"original\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"replacement\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"VerifiedAddressSuperseded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousIssuer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newIssuer\",\"type\":\"address\"}],\"name\":\"IssuerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Issue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IssueFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"ShareholderAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"ShareholderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"T0ken","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://aaa9c0c19f6c5795773194111572f9115f68c17c15fbd5386874d0078fb81b82"}]}