{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n   /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n   /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n   /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n   /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n   /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n   /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n   /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ICO Rocket Fuel contract for LastMile service.\r\n */\r\ncontract IcoRocketFuel is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Crowdsale states\r\n    enum States {Active, Refunding, Closed}\r\n\r\n    struct Crowdsale {\r\n        address owner;        // Crowdsale proposer\r\n        address refundWallet; // Tokens for sale will refund to this wallet\r\n        uint256 cap;          // Hard cap\r\n        uint256 goal;         // Soft cap\r\n        uint256 raised;       // wei raised\r\n        uint256 rate;         // Sell rate. Set to 10 means 1 Wei = 10 token units\r\n        uint256 minInvest;    // Minimum investment in Wei\r\n        uint256 closingTime;  // Crowdsale closing time\r\n        bool earlyClosure;    // Whether allow early closure\r\n        uint8 commission;     // Commission percentage. Set to 10 means 10%\r\n        States state;         // Crowdsale current state\r\n    }\r\n\r\n    // When crowdsale is closed, commissions will transfer to this wallet.\r\n    address public commissionWallet;    \r\n\r\n    // Use crowdsales[token] to get corresponding crowdsale.\r\n    // The token is an ERC20 token address.\r\n    mapping(address => Crowdsale) public crowdsales;\r\n\r\n    // Use deposits[buyer][token] to get deposited Wei for buying the token.\r\n    // The buyer is the buyer address.\r\n    // The token is an ERC20 token address.\r\n    mapping (address => mapping(address => uint256)) public deposits;\r\n\r\n    modifier onlyCrowdsaleOwner(address _token) {\r\n        require(\r\n            msg.sender == crowdsales[_token].owner,\r\n            \"Failed to call function due to permission denied.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier inState(address _token, States _state) {\r\n        require(\r\n            crowdsales[_token].state == _state,\r\n            \"Failed to call function due to crowdsale is not in right state.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address _token) {\r\n        require(\r\n            _token != address(0),\r\n            \"Failed to call function due to address is 0x0.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event CommissionWalletUpdated(\r\n        address indexed _previoudWallet, // Previous commission wallet address\r\n        address indexed _newWallet       // New commission wallet address\r\n    );\r\n\r\n    event CrowdsaleCreated(\r\n        address indexed _owner, // Crowdsale proposer\r\n        address indexed _token, // ERC20 token for crowdsale\r\n        address _refundWallet,  // Tokens for sale will refund to this wallet\r\n        uint256 _cap,           // Hard cap\r\n        uint256 _goal,          // Soft cap\r\n        uint256 _rate,          // Sell rate. Set to 10 means 1 Wei = 10 token units\r\n        uint256 closingTime,    // Crowdsale closing time\r\n        bool earlyClosure,      // Whether allow early closure\r\n        uint8 _commission       // Commission percentage. Set to 10 means 10%\r\n    );\r\n\r\n    event TokenBought(\r\n        address indexed _buyer, // Buyer address\r\n        address indexed _token, // Bought ERC20 token address\r\n        uint256 _value          // Spent wei amount\r\n    );\r\n\r\n    event CrowdsaleClosed(\r\n        address indexed _setter, // Address who closed crowdsale\r\n        address indexed _token   // Token address\r\n    );\r\n\r\n    event CommissionPaid(\r\n        address indexed _payer,       // Commission payer        \r\n        address indexed _token,       // Paid from this crowdsale\r\n        address indexed _beneficiary, // Commission paid to this wallet\r\n        uint256 _value                // Paid commission in Wei amount\r\n    );\r\n\r\n    event RefundsEnabled(\r\n        address indexed _setter, // Address who enabled refunds\r\n        address indexed _token   // Token address\r\n    );\r\n\r\n    event CrowdsaleTokensRefunded(\r\n        address indexed _token,        // ERC20 token for crowdsale\r\n        address indexed _refundWallet, // Token will refund to this wallet\r\n        uint256 _value                 // Refuned amount\r\n    );\r\n\r\n    event RaisedWeiClaimed(\r\n        address indexed _beneficiary, // Who claimed refunds\r\n        address indexed _token,       // Refund from this crowdsale\r\n        uint256 _value                // Raised Wei amount\r\n    );\r\n\r\n    event TokenClaimed(\r\n        address indexed _beneficiary, // Who claimed refunds\r\n        address indexed _token,       // Refund from this crowdsale\r\n        uint256 _value                // Refund Wei amount \r\n    );\r\n\r\n    event CrowdsalePaused(\r\n        address indexed _owner, // Current contract owner\r\n        address indexed _token  // Paused crowdsale\r\n    );\r\n\r\n    event WeiRefunded(\r\n        address indexed _beneficiary, // Who claimed refunds\r\n        address indexed _token,       // Refund from this crowdsale\r\n        uint256 _value                // Refund Wei amount \r\n    );\r\n\r\n    // Note no default constructor is required, but \r\n    // remember to set commission wallet before operating.\r\n\r\n    /**\r\n     * Set crowdsale commission wallet.\r\n     *\r\n     * @param _newWallet New commission wallet\r\n     */\r\n    function setCommissionWallet(\r\n        address _newWallet\r\n    )\r\n        onlyOwner\r\n        nonZeroAddress(_newWallet)\r\n        external\r\n    {\r\n        emit CommissionWalletUpdated(commissionWallet, _newWallet);\r\n        commissionWallet = _newWallet;\r\n    }\r\n\r\n    /**\r\n     * Create a crowdsale.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     * @param _refundWallet Tokens for sale will refund to this wallet\r\n     * @param _cap Crowdsale cap\r\n     * @param _goal Crowdsale goal\r\n     * @param _rate Token sell rate. Set to 10 means 1 Wei = 10 token units\r\n     * @param _minInvest Minimum investment in Wei\r\n     * @param _closingTime Crowdsale closing time\r\n     * @param _earlyClosure True: allow early closure; False: not allow\r\n     * @param _commission Commission percentage. Set to 10 means 10%\r\n     */\r\n    function createCrowdsale(\r\n        address _token,\r\n        address _refundWallet,\r\n        uint256 _cap,\r\n        uint256 _goal,\r\n        uint256 _rate,\r\n        uint256 _minInvest,\r\n        uint256 _closingTime,\r\n        bool _earlyClosure,\r\n        uint8 _commission\r\n    )\r\n        nonZeroAddress(_token)\r\n        nonZeroAddress(_refundWallet)\r\n        external\r\n    {\r\n        require(\r\n            crowdsales[_token].owner == address(0),\r\n            \"Failed to create crowdsale due to the crowdsale is existed.\"\r\n        );\r\n\r\n        require(\r\n            _goal <= _cap,\r\n            \"Failed to create crowdsale due to goal is larger than cap.\"\r\n        );\r\n\r\n        require(\r\n            _minInvest > 0,\r\n            \"Failed to create crowdsale due to minimum investment is 0.\"\r\n        );\r\n\r\n        require(\r\n            _commission <= 100,\r\n            \"Failed to create crowdsale due to commission is larger than 100.\"\r\n        );\r\n\r\n        // Leverage SafeMath to help potential overflow of maximum token untis.\r\n        _cap.mul(_rate);\r\n\r\n        crowdsales[_token] = Crowdsale({\r\n            owner: msg.sender,\r\n            refundWallet: _refundWallet,\r\n            cap: _cap,\r\n            goal: _goal,\r\n            raised: 0,\r\n            rate: _rate,\r\n            minInvest: _minInvest,\r\n            closingTime: _closingTime,\r\n            earlyClosure: _earlyClosure,\r\n            state: States.Active,\r\n            commission: _commission\r\n        });\r\n\r\n        emit CrowdsaleCreated(\r\n            msg.sender, \r\n            _token,\r\n            _refundWallet,\r\n            _cap, \r\n            _goal, \r\n            _rate,\r\n            _closingTime,\r\n            _earlyClosure,\r\n            _commission\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Buy token with Wei.\r\n     *\r\n     * The Wei will be deposited until crowdsale is finalized.\r\n     * If crowdsale is success, raised Wei will be transfered to the token.\r\n     * If crowdsale is fail, buyer can refund the Wei.\r\n     *\r\n     * Note The minimum investment is 1 ETH.\r\n     * Note the big finger issue is expected to be handled by frontends.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function buyToken(\r\n        address _token\r\n    )\r\n        inState(_token, States.Active)\r\n        nonZeroAddress(_token)\r\n        external\r\n        payable\r\n    {\r\n        require(\r\n            msg.value >= crowdsales[_token].minInvest,\r\n            \"Failed to buy token due to less than minimum investment.\"\r\n        );\r\n\r\n        require(\r\n            crowdsales[_token].raised.add(msg.value) <= (\r\n                crowdsales[_token].cap\r\n            ),\r\n            \"Failed to buy token due to exceed cap.\"\r\n        );\r\n\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            block.timestamp < crowdsales[_token].closingTime,\r\n            \"Failed to buy token due to crowdsale is closed.\"\r\n        );\r\n\r\n        deposits[msg.sender][_token] = (\r\n            deposits[msg.sender][_token].add(msg.value)\r\n        );\r\n        crowdsales[_token].raised = crowdsales[_token].raised.add(msg.value);\r\n        emit TokenBought(msg.sender, _token, msg.value);        \r\n    }\r\n\r\n    /**\r\n     * Check whether crowdsale goal was reached or not.\r\n     *\r\n     * Goal reached condition:\r\n     * 1. total raised wei >= goal (soft cap); and\r\n     * 2. Right amout of token is prepared for this contract.\r\n     *\r\n     * @param _token Deployed ERC20 token\r\n     * @return Whether crowdsale goal was reached or not\r\n     */\r\n    function _goalReached(\r\n        ERC20 _token\r\n    )\r\n        nonZeroAddress(_token)\r\n        private\r\n        view\r\n        returns(bool) \r\n    {\r\n        return (crowdsales[_token].raised >= crowdsales[_token].goal) && (\r\n            _token.balanceOf(address(this)) >= \r\n            crowdsales[_token].raised.mul(crowdsales[_token].rate)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Pay commission by raised Wei amount of crowdsale.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function _payCommission(\r\n        address _token\r\n    )\r\n        nonZeroAddress(_token)\r\n        inState(_token, States.Closed)\r\n        onlyCrowdsaleOwner(_token)\r\n        private\r\n    {\r\n        // Calculate commission, update rest raised Wei, and pay commission.\r\n        uint256 _commission = crowdsales[_token].raised\r\n            .mul(uint256(crowdsales[_token].commission))\r\n            .div(100);\r\n        crowdsales[_token].raised = crowdsales[_token].raised.sub(_commission);\r\n        emit CommissionPaid(msg.sender, _token, commissionWallet, _commission);\r\n        commissionWallet.transfer(_commission);\r\n    }\r\n\r\n    /**\r\n     * Refund crowdsale tokens to refund wallet.\r\n     *\r\n     * @param _token Deployed ERC20 token\r\n     * @param _beneficiary Crowdsale tokens will refund to this wallet\r\n     */\r\n    function _refundCrowdsaleTokens(\r\n        ERC20 _token,\r\n        address _beneficiary\r\n    ) \r\n        nonZeroAddress(_token)\r\n        inState(_token, States.Refunding)\r\n        private\r\n    {\r\n        // Set raised Wei to 0 to prevent unknown issues \r\n        // which might take Wei away. \r\n        // Theoretically, this step is unnecessary due to there is no available\r\n        // function for crowdsale owner to claim raised Wei.\r\n        crowdsales[_token].raised = 0;\r\n\r\n        uint256 _value = _token.balanceOf(address(this));\r\n        emit CrowdsaleTokensRefunded(_token, _beneficiary, _value);\r\n\r\n        if (_value > 0) {         \r\n            // Refund all tokens for crowdsale to refund wallet.\r\n            _token.transfer(_beneficiary, _token.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable refunds of crowdsale.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function _enableRefunds(\r\n        address _token\r\n    )\r\n        nonZeroAddress(_token)\r\n        inState(_token, States.Active)\r\n        private        \r\n    {\r\n        // Set state to Refunding while preventing reentry.\r\n        crowdsales[_token].state = States.Refunding;\r\n        emit RefundsEnabled(msg.sender, _token);\r\n    }\r\n\r\n    /**\r\n     * Finalize a crowdsale.\r\n     *\r\n     * Once a crowdsale is finalized, its state could be\r\n     * either Closed (success) or Refunding (fail).\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function finalize(\r\n        address _token\r\n    )\r\n        nonZeroAddress(_token)\r\n        inState(_token, States.Active)        \r\n        onlyCrowdsaleOwner(_token)\r\n        external\r\n    {\r\n        require(                    \r\n            crowdsales[_token].earlyClosure || (\r\n            // solium-disable-next-line security/no-block-members\r\n            block.timestamp >= crowdsales[_token].closingTime),                   \r\n            \"Failed to finalize due to crowdsale is opening.\"\r\n        );\r\n\r\n        if (_goalReached(ERC20(_token))) {\r\n            // Set state to Closed whiling preventing reentry.\r\n            crowdsales[_token].state = States.Closed;\r\n            emit CrowdsaleClosed(msg.sender, _token);\r\n            _payCommission(_token);                        \r\n        } else {\r\n            _enableRefunds(_token);\r\n            _refundCrowdsaleTokens(\r\n                ERC20(_token), \r\n                crowdsales[_token].refundWallet\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pause crowdsale, which will set the crowdsale state to Refunding.\r\n     *\r\n     * Note only pause crowdsales which are suspicious/scams.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function pauseCrowdsale(\r\n        address _token\r\n    )        \r\n        nonZeroAddress(_token)\r\n        onlyOwner\r\n        inState(_token, States.Active)\r\n        external\r\n    {\r\n        emit CrowdsalePaused(msg.sender, _token);\r\n        _enableRefunds(_token);\r\n        _refundCrowdsaleTokens(ERC20(_token), crowdsales[_token].refundWallet);\r\n    }\r\n\r\n    /**\r\n     * Claim crowdsale raised Wei.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function claimRaisedWei(\r\n        address _token,\r\n        address _beneficiary\r\n    )\r\n        nonZeroAddress(_token)\r\n        nonZeroAddress(_beneficiary)\r\n        inState(_token, States.Closed)\r\n        onlyCrowdsaleOwner(_token)\r\n        external\r\n    {\r\n        require(\r\n            crowdsales[_token].raised > 0,\r\n            \"Failed to claim raised Wei due to raised Wei is 0.\"\r\n        );\r\n\r\n        uint256 _raisedWei = crowdsales[_token].raised;\r\n        crowdsales[_token].raised = 0;\r\n        emit RaisedWeiClaimed(msg.sender, _token, _raisedWei);\r\n        _beneficiary.transfer(_raisedWei);\r\n    }\r\n\r\n    /**\r\n     * Claim token, which will transfer bought token amount to buyer.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function claimToken(\r\n        address _token\r\n    )\r\n        nonZeroAddress(_token)\r\n        inState(_token, States.Closed)        \r\n        external \r\n    {\r\n        require(\r\n            deposits[msg.sender][_token] > 0,\r\n            \"Failed to claim token due to deposit is 0.\"\r\n        );\r\n\r\n        // Calculate token unit amount to be transferred. \r\n        uint256 _value = (\r\n            deposits[msg.sender][_token].mul(crowdsales[_token].rate)\r\n        );\r\n        deposits[msg.sender][_token] = 0;\r\n        emit TokenClaimed(msg.sender, _token, _value);\r\n        ERC20(_token).transfer(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n     * Claim refund, which will transfer refunded Wei amount back to buyer.\r\n     *\r\n     * @param _token Deployed ERC20 token address\r\n     */\r\n    function claimRefund(\r\n        address _token\r\n    )\r\n        nonZeroAddress(_token)\r\n        inState(_token, States.Refunding)        \r\n        public \r\n    {\r\n        require(\r\n            deposits[msg.sender][_token] > 0,\r\n            \"Failed to claim refund due to deposit is 0.\"\r\n        );\r\n\r\n        uint256 _value = deposits[msg.sender][_token];\r\n        deposits[msg.sender][_token] = 0;\r\n        emit WeiRefunded(msg.sender, _token, _value);\r\n        msg.sender.transfer(_value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setCommissionWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"pauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_refundWallet\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_minInvest\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_earlyClosure\",\"type\":\"bool\"},{\"name\":\"_commission\",\"type\":\"uint8\"}],\"name\":\"createCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimRaisedWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsales\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"refundWallet\",\"type\":\"address\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"goal\",\"type\":\"uint256\"},{\"name\":\"raised\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"minInvest\",\"type\":\"uint256\"},{\"name\":\"closingTime\",\"type\":\"uint256\"},{\"name\":\"earlyClosure\",\"type\":\"bool\"},{\"name\":\"commission\",\"type\":\"uint8\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previoudWallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"CommissionWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_refundWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_cap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_goal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"earlyClosure\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_commission\",\"type\":\"uint8\"}],\"name\":\"CrowdsaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"CrowdsaleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_payer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"RefundsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_refundWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleTokensRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"RaisedWeiClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"CrowdsalePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"WeiRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IcoRocketFuel","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4808c81b74126901fd7167c5fbd8b6bed851717229d65653894af4425dc76d2d"}]}