{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/library/Ownable.sol\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/library/upgradeable/Proxied.sol\r\n\r\ncontract Proxied is Ownable {\r\n    address public target;\r\n    mapping (address => bool) public initialized;\r\n\r\n    event EventUpgrade(address indexed newTarget, address indexed oldTarget, address indexed admin);\r\n    event EventInitialized(address indexed target);\r\n\r\n    function upgradeTo(address _target) public;\r\n}\r\n\r\n// File: contracts/library/upgradeable/Upgradeable.sol\r\n\r\ncontract Upgradeable is Proxied {\r\n    /*\r\n     * @notice Modifier to make body of function only execute if the contract has not already been initialized.\r\n     */\r\n    modifier initializeOnceOnly() {\r\n         if(!initialized[target]) {\r\n             initialized[target] = true;\r\n             emit EventInitialized(target);\r\n             _;\r\n         } else revert();\r\n     }\r\n\r\n    /**\r\n     * @notice Will always fail if called. This is used as a placeholder for the contract ABI.\r\n     * @dev This is code is never executed by the Proxy using delegate call\r\n     */\r\n    function upgradeTo(address) public {\r\n        assert(false);\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize any state variables that would normally be set in the contructor.\r\n     * @dev Initialization functionality MUST be implemented in inherited upgradeable contract if the child contract requires\r\n     * variable initialization on creation. This is because the contructor of the child contract will not execute\r\n     * and set any state when the Proxy contract targets it.\r\n     * This function MUST be called stright after the Upgradeable contract is set as the target of the Proxy. This method\r\n     * can be overwridden so that it may have arguments. Make sure that the initializeOnceOnly() modifier is used to protect\r\n     * from being initialized more than once.\r\n     * If a contract is upgraded twice, pay special attention that the state variables are not initialized again\r\n     */\r\n    function initialize() initializeOnceOnly public {\r\n        // initialize contract state variables here\r\n    }\r\n}\r\n\r\n// File: contracts/MerkleClaims.sol\r\n\r\ncontract MerkleClaims is Upgradeable {\r\n    mapping (uint256 => bytes32) public rootByTimeKey;\r\n    event NewRootAdded(uint256 timeKey,bytes32 root);\r\n    function addMerkleRoot(uint256 timeKey, bytes32 root) public onlyOwner {\r\n        require(rootByTimeKey[timeKey]==0);\r\n        rootByTimeKey[timeKey] = root;\r\n        emit NewRootAdded(timeKey,root);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"timeKey\",\"type\":\"uint256\"},{\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"addMerkleRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rootByTimeKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeKey\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"NewRootAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newTarget\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oldTarget\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"EventUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"}],\"name\":\"EventInitialized\",\"type\":\"event\"}]","ContractName":"MerkleClaims","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://16497955c0b17eb35f7d14ad8a9d8e504502dfb745dc922614b7fc398ac4798c"}]}