{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       Owned.sol\r\nversion:    1.1\r\nauthor:     Anton Jurisevic\r\n            Dominic Romanowski\r\n\r\ndate:       2018-2-26\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nAn Owned contract, to be inherited by other contracts.\r\nRequires its owner to be explicitly set in the constructor.\r\nProvides an onlyOwner access modifier.\r\n\r\nTo change owner, the current owner must nominate the next owner,\r\nwho then has to accept the nomination. The nomination can be\r\ncancelled before it is accepted by the new owner by having the\r\nprevious owner change the nomination (setting it to 0).\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title A contract with an owner.\r\n * @notice Contract ownership can be transferred by first nominating the new owner,\r\n * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    /**\r\n     * @dev Owned Constructor\r\n     */\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Nominate a new owner of this contract.\r\n     * @dev Only the current owner may nominate a new owner.\r\n     */\r\n    function nominateNewOwner(address _owner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Accept the nomination to be owner.\r\n     */\r\n    function acceptOwnership()\r\n        external\r\n    {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       SelfDestructible.sol\r\nversion:    1.2\r\nauthor:     Anton Jurisevic\r\n\r\ndate:       2018-05-29\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nThis contract allows an inheriting contract to be destroyed after\r\nits owner indicates an intention and then waits for a period\r\nwithout changing their mind. All ether contained in the contract\r\nis forwarded to a nominated beneficiary upon destruction.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title A contract that can be destroyed by its owner after a delay elapses.\r\n */\r\ncontract SelfDestructible is Owned {\r\n\t\r\n\tuint public initiationTime;\r\n\tbool public selfDestructInitiated;\r\n\taddress public selfDestructBeneficiary;\r\n\tuint public constant SELFDESTRUCT_DELAY = 4 weeks;\r\n\r\n\t/**\r\n\t * @dev Constructor\r\n\t * @param _owner The account which controls this contract.\r\n\t */\r\n\tconstructor(address _owner)\r\n\t    Owned(_owner)\r\n\t    public\r\n\t{\r\n\t\trequire(_owner != address(0), \"Owner must not be the zero address\");\r\n\t\tselfDestructBeneficiary = _owner;\r\n\t\temit SelfDestructBeneficiaryUpdated(_owner);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Set the beneficiary address of this contract.\r\n\t * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\r\n\t * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\r\n\t */\r\n\tfunction setSelfDestructBeneficiary(address _beneficiary)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\trequire(_beneficiary != address(0), \"Beneficiary must not be the zero address\");\r\n\t\tselfDestructBeneficiary = _beneficiary;\r\n\t\temit SelfDestructBeneficiaryUpdated(_beneficiary);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Begin the self-destruction counter of this contract.\r\n\t * Once the delay has elapsed, the contract may be self-destructed.\r\n\t * @dev Only the contract owner may call this.\r\n\t */\r\n\tfunction initiateSelfDestruct()\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\tinitiationTime = now;\r\n\t\tselfDestructInitiated = true;\r\n\t\temit SelfDestructInitiated(SELFDESTRUCT_DELAY);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Terminate and reset the self-destruction timer.\r\n\t * @dev Only the contract owner may call this.\r\n\t */\r\n\tfunction terminateSelfDestruct()\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\tinitiationTime = 0;\r\n\t\tselfDestructInitiated = false;\r\n\t\temit SelfDestructTerminated();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice If the self-destruction delay has elapsed, destroy this contract and\r\n\t * remit any ether it owns to the beneficiary address.\r\n\t * @dev Only the contract owner may call this.\r\n\t */\r\n\tfunction selfDestruct()\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\trequire(selfDestructInitiated, \"Self destruct has not yet been initiated\");\r\n\t\trequire(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay has not yet elapsed\");\r\n\t\taddress beneficiary = selfDestructBeneficiary;\r\n\t\temit SelfDestructed(beneficiary);\r\n\t\tselfdestruct(beneficiary);\r\n\t}\r\n\r\n\tevent SelfDestructTerminated();\r\n\tevent SelfDestructed(address beneficiary);\r\n\tevent SelfDestructInitiated(uint selfDestructDelay);\r\n\tevent SelfDestructBeneficiaryUpdated(address newBeneficiary);\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       Pausable.sol\r\nversion:    1.0\r\nauthor:     Kevin Brown\r\n\r\ndate:       2018-05-22\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nThis contract allows an inheriting contract to be marked as\r\npaused. It also defines a modifier which can be used by the\r\ninheriting contract to prevent actions while paused.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title A contract that can be paused by its owner\r\n */\r\ncontract Pausable is Owned {\r\n    \r\n    uint public lastPauseTime;\r\n    bool public paused;\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _owner The account which controls this contract.\r\n     */\r\n    constructor(address _owner)\r\n        Owned(_owner)\r\n        public\r\n    {\r\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\r\n    }\r\n\r\n    /**\r\n     * @notice Change the paused state of the contract\r\n     * @dev Only the contract owner may call this.\r\n     */\r\n    function setPaused(bool _paused)\r\n        external\r\n        onlyOwner\r\n    {\r\n        // Ensure we're actually changing the state before we do anything\r\n        if (_paused == paused) {\r\n            return;\r\n        }\r\n\r\n        // Set our paused state.\r\n        paused = _paused;\r\n        \r\n        // If applicable, set the last pause time.\r\n        if (paused) {\r\n            lastPauseTime = now;\r\n        }\r\n\r\n        // Let everyone know that our pause state has changed.\r\n        emit PauseChanged(paused);\r\n    }\r\n\r\n    event PauseChanged(bool isPaused);\r\n\r\n    modifier notPaused {\r\n        require(!paused, \"This action cannot be performed while the contract is paused\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       SafeDecimalMath.sol\r\nversion:    1.0\r\nauthor:     Anton Jurisevic\r\n\r\ndate:       2018-2-5\r\n\r\nchecked:    Mike Spain\r\napproved:   Samuel Brooks\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA fixed point decimal library that provides basic mathematical\r\noperations, and checks for unsafe arguments, for example that\r\nwould lead to overflows.\r\n\r\nExceptions are thrown whenever those unsafe operations\r\noccur.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\r\n * @dev Functions accepting uints in this contract and derived contracts\r\n * are taken to be such fixed point decimals (including fiat, ether, and nomin quantities).\r\n */\r\ncontract SafeDecimalMath {\r\n\r\n    /* Number of decimal places in the representation. */\r\n    uint8 public constant decimals = 18;\r\n\r\n    /* The number representing 1.0. */\r\n    uint public constant UNIT = 10 ** uint(decimals);\r\n\r\n    /**\r\n     * @return True iff adding x and y will not overflow.\r\n     */\r\n    function addIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return x + y >= y;\r\n    }\r\n\r\n    /**\r\n     * @return The result of adding x and y, throwing an exception in case of overflow.\r\n     */\r\n    function safeAdd(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(x + y >= y, \"Safe add failed\");\r\n        return x + y;\r\n    }\r\n\r\n    /**\r\n     * @return True iff subtracting y from x will not overflow in the negative direction.\r\n     */\r\n    function subIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return y <= x;\r\n    }\r\n\r\n    /**\r\n     * @return The result of subtracting y from x, throwing an exception in case of overflow.\r\n     */\r\n    function safeSub(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(y <= x, \"Safe sub failed\");\r\n        return x - y;\r\n    }\r\n\r\n    /**\r\n     * @return True iff multiplying x and y would not overflow.\r\n     */\r\n    function mulIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (x == 0) {\r\n            return true;\r\n        }\r\n        return (x * y) / x == y;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, throwing an exception in case of overflow.\r\n     */\r\n    function safeMul(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n        uint p = x * y;\r\n        require(p / x == y, \"Safe mul failed\");\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\r\n     * decimals. Throws an exception in case of overflow.\r\n     * \r\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\r\n     * so that product must be less than 2**256.\r\n     * Incidentally, the internal division always rounds down: one could have rounded to the nearest integer,\r\n     * but then one would be spending a significant fraction of a cent (of order a microether\r\n     * at present gas prices) in order to save less than one part in 0.5 * 10^18 per operation, if the operands\r\n     * contain small enough fractional components. It would also marginally diminish the \r\n     * domain this function is defined upon. \r\n     */\r\n    function safeMul_dec(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        return safeMul(x, y) / UNIT;\r\n\r\n    }\r\n\r\n    /**\r\n     * @return True iff the denominator of x/y is nonzero.\r\n     */\r\n    function divIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return y != 0;\r\n    }\r\n\r\n    /**\r\n     * @return The result of dividing x by y, throwing an exception if the divisor is zero.\r\n     */\r\n    function safeDiv(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Although a 0 denominator already throws an exception,\r\n         * it is equivalent to a THROW operation, which consumes all gas.\r\n         * A require statement emits REVERT instead, which remits remaining gas. */\r\n        require(y != 0, \"Denominator cannot be zero\");\r\n        return x / y;\r\n    }\r\n\r\n    /**\r\n     * @return The result of dividing x by y, interpreting the operands as fixed point decimal numbers.\r\n     * @dev Throws an exception in case of overflow or zero divisor; x must be less than 2^256 / UNIT.\r\n     * Internal rounding is downward: a similar caveat holds as with safeDecMul().\r\n     */\r\n    function safeDiv_dec(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Reintroduce the UNIT factor that will be divided out by y. */\r\n        return safeDiv(safeMul(x, UNIT), y);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert an unsigned integer to a unsigned fixed-point decimal.\r\n     * Throw an exception if the result would be out of range.\r\n     */\r\n    function intToDec(uint i)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        return safeMul(i, UNIT);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       State.sol\r\nversion:    1.1\r\nauthor:     Dominic Romanowski\r\n            Anton Jurisevic\r\n\r\ndate:       2018-05-15\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nThis contract is used side by side with external state token\r\ncontracts, such as Havven and Nomin.\r\nIt provides an easy way to upgrade contract logic while\r\nmaintaining all user balances and allowances. This is designed\r\nto make the changeover as easy as possible, since mappings\r\nare not so cheap or straightforward to migrate.\r\n\r\nThe first deployed contract would create this state contract,\r\nusing it as its store of balances.\r\nWhen a new contract is deployed, it links to the existing\r\nstate contract, whose owner would then change its associated\r\ncontract to the new one.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\ncontract State is Owned {\r\n    // the address of the contract that can modify variables\r\n    // this can only be changed by the owner of this contract\r\n    address public associatedContract;\r\n\r\n\r\n    constructor(address _owner, address _associatedContract)\r\n        Owned(_owner)\r\n        public\r\n    {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    // Change the associated contract to a new address\r\n    function setAssociatedContract(address _associatedContract)\r\n        external\r\n        onlyOwner\r\n    {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyAssociatedContract\r\n    {\r\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AssociatedContractUpdated(address associatedContract);\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       TokenState.sol\r\nversion:    1.1\r\nauthor:     Dominic Romanowski\r\n            Anton Jurisevic\r\n\r\ndate:       2018-05-15\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA contract that holds the state of an ERC20 compliant token.\r\n\r\nThis contract is used side by side with external state token\r\ncontracts, such as Havven and Nomin.\r\nIt provides an easy way to upgrade contract logic while\r\nmaintaining all user balances and allowances. This is designed\r\nto make the changeover as easy as possible, since mappings\r\nare not so cheap or straightforward to migrate.\r\n\r\nThe first deployed contract would create this state contract,\r\nusing it as its store of balances.\r\nWhen a new contract is deployed, it links to the existing\r\nstate contract, whose owner would then change its associated\r\ncontract to the new one.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title ERC20 Token State\r\n * @notice Stores balance information of an ERC20 token contract.\r\n */\r\ncontract TokenState is State {\r\n\r\n    /* ERC20 fields. */\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _owner The address which controls this contract.\r\n     * @param _associatedContract The ERC20 contract whose state this composes.\r\n     */\r\n    constructor(address _owner, address _associatedContract)\r\n        State(_owner, _associatedContract)\r\n        public\r\n    {}\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set ERC20 allowance.\r\n     * @dev Only the associated contract may call this.\r\n     * @param tokenOwner The authorising party.\r\n     * @param spender The authorised party.\r\n     * @param value The total value the authorised party may spend on the\r\n     * authorising party's behalf.\r\n     */\r\n    function setAllowance(address tokenOwner, address spender, uint value)\r\n        external\r\n        onlyAssociatedContract\r\n    {\r\n        allowance[tokenOwner][spender] = value;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the balance in a given account\r\n     * @dev Only the associated contract may call this.\r\n     * @param account The account whose value to set.\r\n     * @param value The new balance of the given account.\r\n     */\r\n    function setBalanceOf(address account, uint value)\r\n        external\r\n        onlyAssociatedContract\r\n    {\r\n        balanceOf[account] = value;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       Proxy.sol\r\nversion:    1.3\r\nauthor:     Anton Jurisevic\r\n\r\ndate:       2018-05-29\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA proxy contract that, if it does not recognise the function\r\nbeing called on it, passes all value and call data to an\r\nunderlying target contract.\r\n\r\nThis proxy has the capacity to toggle between DELEGATECALL\r\nand CALL style proxy functionality.\r\n\r\nThe former executes in the proxy's context, and so will preserve \r\nmsg.sender and store data at the proxy address. The latter will not.\r\nTherefore, any contract the proxy wraps in the CALL style must\r\nimplement the Proxyable interface, in order that it can pass msg.sender\r\ninto the underlying contract as the state parameter, messageSender.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\ncontract Proxy is Owned {\r\n\r\n    Proxyable public target;\r\n    bool public useDELEGATECALL;\r\n\r\n    constructor(address _owner)\r\n        Owned(_owner)\r\n        public\r\n    {}\r\n\r\n    function setTarget(Proxyable _target)\r\n        external\r\n        onlyOwner\r\n    {\r\n        target = _target;\r\n        emit TargetUpdated(_target);\r\n    }\r\n\r\n    function setUseDELEGATECALL(bool value) \r\n        external\r\n        onlyOwner\r\n    {\r\n        useDELEGATECALL = value;\r\n    }\r\n\r\n    function _emit(bytes callData, uint numTopics,\r\n                   bytes32 topic1, bytes32 topic2,\r\n                   bytes32 topic3, bytes32 topic4)\r\n        external\r\n        onlyTarget\r\n    {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n\r\n        assembly {\r\n            /* The first 32 bytes of callData contain its length (as specified by the abi). \r\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\r\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\r\n             * This means moving call_data across 32 bytes guarantees we correctly access\r\n             * the data itself. */\r\n            switch numTopics\r\n            case 0 {\r\n                log0(add(_callData, 32), size)\r\n            } \r\n            case 1 {\r\n                log1(add(_callData, 32), size, topic1)\r\n            }\r\n            case 2 {\r\n                log2(add(_callData, 32), size, topic1, topic2)\r\n            }\r\n            case 3 {\r\n                log3(add(_callData, 32), size, topic1, topic2, topic3)\r\n            }\r\n            case 4 {\r\n                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\r\n            }\r\n        }\r\n    }\r\n\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        if (useDELEGATECALL) {\r\n            assembly {\r\n                /* Copy call data into free memory region. */\r\n                let free_ptr := mload(0x40)\r\n                calldatacopy(free_ptr, 0, calldatasize)\r\n\r\n                /* Forward all gas and call data to the target contract. */\r\n                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\r\n                returndatacopy(free_ptr, 0, returndatasize)\r\n\r\n                /* Revert if the call failed, otherwise return the result. */\r\n                if iszero(result) { revert(free_ptr, returndatasize) }\r\n                return(free_ptr, returndatasize)\r\n            }\r\n        } else {\r\n            /* Here we are as above, but must send the messageSender explicitly \r\n             * since we are using CALL rather than DELEGATECALL. */\r\n            target.setMessageSender(msg.sender);\r\n            assembly {\r\n                let free_ptr := mload(0x40)\r\n                calldatacopy(free_ptr, 0, calldatasize)\r\n\r\n                /* We must explicitly forward ether to the underlying contract as well. */\r\n                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\r\n                returndatacopy(free_ptr, 0, returndatasize)\r\n\r\n                if iszero(result) { revert(free_ptr, returndatasize) }\r\n                return(free_ptr, returndatasize)\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier onlyTarget {\r\n        require(Proxyable(msg.sender) == target, \"This action can only be performed by the proxy target\");\r\n        _;\r\n    }\r\n\r\n    event TargetUpdated(Proxyable newTarget);\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       Proxyable.sol\r\nversion:    1.1\r\nauthor:     Anton Jurisevic\r\n\r\ndate:       2018-05-15\r\n\r\nchecked:    Mike Spain\r\napproved:   Samuel Brooks\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA proxyable contract that works hand in hand with the Proxy contract\r\nto allow for anyone to interact with the underlying contract both\r\ndirectly and through the proxy.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n// This contract should be treated like an abstract contract\r\ncontract Proxyable is Owned {\r\n    /* The proxy this contract exists behind. */\r\n    Proxy public proxy;\r\n\r\n    /* The caller of the proxy, passed through to this contract.\r\n     * Note that every function using this member must apply the onlyProxy or\r\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */ \r\n    address messageSender; \r\n\r\n    constructor(address _proxy, address _owner)\r\n        Owned(_owner)\r\n        public\r\n    {\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setProxy(address _proxy)\r\n        external\r\n        onlyOwner\r\n    {\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setMessageSender(address sender)\r\n        external\r\n        onlyProxy\r\n    {\r\n        messageSender = sender;\r\n    }\r\n\r\n    modifier onlyProxy {\r\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier optionalProxy\r\n    {\r\n        if (Proxy(msg.sender) != proxy) {\r\n            messageSender = msg.sender;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier optionalProxy_onlyOwner\r\n    {\r\n        if (Proxy(msg.sender) != proxy) {\r\n            messageSender = msg.sender;\r\n        }\r\n        require(messageSender == owner, \"This action can only be performed by the owner\");\r\n        _;\r\n    }\r\n\r\n    event ProxyUpdated(address proxyAddress);\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       ExternStateToken.sol\r\nversion:    1.0\r\nauthor:     Kevin Brown\r\ndate:       2018-08-06\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nThis contract offers a modifer that can prevent reentrancy on\r\nparticular actions. It will not work if you put it on multiple\r\nfunctions that can be called from each other. Specifically guard\r\nexternal entry points to the contract with the modifier only.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\ncontract ReentrancyPreventer {\r\n    /* ========== MODIFIERS ========== */\r\n    bool isInFunctionBody = false;\r\n\r\n    modifier preventReentrancy {\r\n        require(!isInFunctionBody, \"Reverted to prevent reentrancy\");\r\n        isInFunctionBody = true;\r\n        _;\r\n        isInFunctionBody = false;\r\n    }\r\n}\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       ExternStateToken.sol\r\nversion:    1.3\r\nauthor:     Anton Jurisevic\r\n            Dominic Romanowski\r\n\r\ndate:       2018-05-29\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA partial ERC20 token contract, designed to operate with a proxy.\r\nTo produce a complete ERC20 token, transfer and transferFrom\r\ntokens must be implemented, using the provided _byProxy internal\r\nfunctions.\r\nThis contract utilises an external state for upgradeability.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title ERC20 Token contract, with detached state and designed to operate behind a proxy.\r\n */\r\ncontract ExternStateToken is SafeDecimalMath, SelfDestructible, Proxyable, ReentrancyPreventer {\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /* Stores balances and allowances. */\r\n    TokenState public tokenState;\r\n\r\n    /* Other ERC20 fields.\r\n     * Note that the decimals field is defined in SafeDecimalMath.*/\r\n    string public name;\r\n    string public symbol;\r\n    uint public totalSupply;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _proxy The proxy associated with this contract.\r\n     * @param _name Token's ERC20 name.\r\n     * @param _symbol Token's ERC20 symbol.\r\n     * @param _totalSupply The total supply of the token.\r\n     * @param _tokenState The TokenState contract address.\r\n     * @param _owner The owner of this contract.\r\n     */\r\n    constructor(address _proxy, TokenState _tokenState,\r\n                string _name, string _symbol, uint _totalSupply,\r\n                address _owner)\r\n        SelfDestructible(_owner)\r\n        Proxyable(_proxy, _owner)\r\n        public\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _totalSupply;\r\n        tokenState = _tokenState;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\r\n     * @param owner The party authorising spending of their funds.\r\n     * @param spender The party spending tokenOwner's funds.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return tokenState.allowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the ERC20 token balance of a given account.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return tokenState.balanceOf(account);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Set the address of the TokenState contract.\r\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\r\n     * as balances would be unreachable.\r\n     */ \r\n    function setTokenState(TokenState _tokenState)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        tokenState = _tokenState;\r\n        emitTokenStateUpdated(_tokenState);\r\n    }\r\n\r\n    function _internalTransfer(address from, address to, uint value) \r\n        internal\r\n        preventReentrancy\r\n        returns (bool)\r\n    { \r\n        /* Disallow transfers to irretrievable-addresses. */\r\n        require(to != address(0), \"Cannot transfer to the 0 address\");\r\n        require(to != address(this), \"Cannot transfer to the underlying contract\");\r\n        require(to != address(proxy), \"Cannot transfer to the proxy contract\");\r\n\r\n        /* Insufficient balance will be handled by the safe subtraction. */\r\n        tokenState.setBalanceOf(from, safeSub(tokenState.balanceOf(from), value));\r\n        tokenState.setBalanceOf(to, safeAdd(tokenState.balanceOf(to), value));\r\n\r\n        /*\r\n        If we're transferring to a contract and it implements the havvenTokenFallback function, call it.\r\n        This isn't ERC223 compliant because:\r\n           1. We don't revert if the contract doesn't implement havvenTokenFallback.\r\n              This is because many DEXes and other contracts that expect to work with the standard\r\n              approve / transferFrom workflow don't implement tokenFallback but can still process our tokens as\r\n              usual, so it feels very harsh and likely to cause trouble if we add this restriction after having\r\n              previously gone live with a vanilla ERC20.\r\n           2. We don't pass the bytes parameter.\r\n              This is because of this solidity bug: https://github.com/ethereum/solidity/issues/2884\r\n           3. We also don't let the user use a custom tokenFallback. We figure as we're already not standards\r\n              compliant, there won't be a use case where users can't just implement our specific function.\r\n\r\n        As such we've called the function havvenTokenFallback to be clear that we are not following the standard.\r\n        */\r\n\r\n        // Is the to address a contract? We can check the code size on that address and know.\r\n        uint length;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Retrieve the size of the code on the recipient address\r\n            length := extcodesize(to)\r\n        }\r\n\r\n        // If there's code there, it's a contract\r\n        if (length > 0) {\r\n            // Now we need to optionally call havvenTokenFallback(address from, uint value).\r\n            // We can't call it the normal way because that reverts when the recipient doesn't implement the function.\r\n            // We'll use .call(), which means we need the function selector. We've pre-computed\r\n            // abi.encodeWithSignature(\"havvenTokenFallback(address,uint256)\"), to save some gas.\r\n\r\n            // solium-disable-next-line security/no-low-level-calls\r\n            to.call(0xcbff5d96, messageSender, value);\r\n\r\n            // And yes, we specifically don't care if this call fails, so we're not checking the return value.\r\n        }\r\n\r\n        // Emit a standard ERC20 transfer event\r\n        emitTransfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\r\n     * the onlyProxy or optionalProxy modifiers.\r\n     */\r\n    function _transfer_byProxy(address from, address to, uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _internalTransfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\r\n     * possessing the optionalProxy or optionalProxy modifiers.\r\n     */\r\n    function _transferFrom_byProxy(address sender, address from, address to, uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* Insufficient allowance will be handled by the safe subtraction. */\r\n        tokenState.setAllowance(from, sender, safeSub(tokenState.allowance(from, sender), value));\r\n        return _internalTransfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Approves spender to transfer on the message sender's behalf.\r\n     */\r\n    function approve(address spender, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        address sender = messageSender;\r\n\r\n        tokenState.setAllowance(sender, spender, value);\r\n        emitApproval(sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    bytes32 constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\r\n    function emitTransfer(address from, address to, uint value) internal {\r\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, bytes32(from), bytes32(to), 0);\r\n    }\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    bytes32 constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\r\n    function emitApproval(address owner, address spender, uint value) internal {\r\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, bytes32(owner), bytes32(spender), 0);\r\n    }\r\n\r\n    event TokenStateUpdated(address newTokenState);\r\n    bytes32 constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\r\n    function emitTokenStateUpdated(address newTokenState) internal {\r\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       FeeToken.sol\r\nversion:    1.3\r\nauthor:     Anton Jurisevic\r\n            Dominic Romanowski\r\n            Kevin Brown\r\n\r\ndate:       2018-05-29\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA token which also has a configurable fee rate\r\ncharged on its transfers. This is designed to be overridden in\r\norder to produce an ERC20-compliant token.\r\n\r\nThese fees accrue into a pool, from which a nominated authority\r\nmay withdraw.\r\n\r\nThis contract utilises an external state for upgradeability.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title ERC20 Token contract, with detached state.\r\n * Additionally charges fees on each transfer.\r\n */\r\ncontract FeeToken is ExternStateToken {\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /* ERC20 members are declared in ExternStateToken. */\r\n\r\n    /* A percentage fee charged on each transfer. */\r\n    uint public transferFeeRate;\r\n    /* Fee may not exceed 10%. */\r\n    uint constant MAX_TRANSFER_FEE_RATE = UNIT / 10;\r\n    /* The address with the authority to distribute fees. */\r\n    address public feeAuthority;\r\n    /* The address that fees will be pooled in. */\r\n    address public constant FEE_ADDRESS = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;\r\n\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _proxy The proxy associated with this contract.\r\n     * @param _name Token's ERC20 name.\r\n     * @param _symbol Token's ERC20 symbol.\r\n     * @param _totalSupply The total supply of the token.\r\n     * @param _transferFeeRate The fee rate to charge on transfers.\r\n     * @param _feeAuthority The address which has the authority to withdraw fees from the accumulated pool.\r\n     * @param _owner The owner of this contract.\r\n     */\r\n    constructor(address _proxy, TokenState _tokenState, string _name, string _symbol, uint _totalSupply,\r\n                uint _transferFeeRate, address _feeAuthority, address _owner)\r\n        ExternStateToken(_proxy, _tokenState,\r\n                         _name, _symbol, _totalSupply,\r\n                         _owner)\r\n        public\r\n    {\r\n        feeAuthority = _feeAuthority;\r\n\r\n        /* Constructed transfer fee rate should respect the maximum fee rate. */\r\n        require(_transferFeeRate <= MAX_TRANSFER_FEE_RATE, \"Constructed transfer fee rate should respect the maximum fee rate\");\r\n        transferFeeRate = _transferFeeRate;\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set the transfer fee, anywhere within the range 0-10%.\r\n     * @dev The fee rate is in decimal format, with UNIT being the value of 100%.\r\n     */\r\n    function setTransferFeeRate(uint _transferFeeRate)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        require(_transferFeeRate <= MAX_TRANSFER_FEE_RATE, \"Transfer fee rate must be below MAX_TRANSFER_FEE_RATE\");\r\n        transferFeeRate = _transferFeeRate;\r\n        emitTransferFeeRateUpdated(_transferFeeRate);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of the user/contract responsible for collecting or\r\n     * distributing fees.\r\n     */\r\n    function setFeeAuthority(address _feeAuthority)\r\n        public\r\n        optionalProxy_onlyOwner\r\n    {\r\n        feeAuthority = _feeAuthority;\r\n        emitFeeAuthorityUpdated(_feeAuthority);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Calculate the Fee charged on top of a value being sent\r\n     * @return Return the fee charged\r\n     */\r\n    function transferFeeIncurred(uint value)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return safeMul_dec(value, transferFeeRate);\r\n        /* Transfers less than the reciprocal of transferFeeRate should be completely eaten up by fees.\r\n         * This is on the basis that transfers less than this value will result in a nil fee.\r\n         * Probably too insignificant to worry about, but the following code will achieve it.\r\n         *      if (fee == 0 && transferFeeRate != 0) {\r\n         *          return _value;\r\n         *      }\r\n         *      return fee;\r\n         */\r\n    }\r\n\r\n    /**\r\n     * @notice The value that you would need to send so that the recipient receives\r\n     * a specified value.\r\n     */\r\n    function transferPlusFee(uint value)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return safeAdd(value, transferFeeIncurred(value));\r\n    }\r\n\r\n    /**\r\n     * @notice The amount the recipient will receive if you send a certain number of tokens.\r\n     */\r\n    function amountReceived(uint value)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return safeDiv_dec(value, safeAdd(UNIT, transferFeeRate));\r\n    }\r\n\r\n    /**\r\n     * @notice Collected fees sit here until they are distributed.\r\n     * @dev The balance of the nomin contract itself is the fee pool.\r\n     */\r\n    function feePool()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return tokenState.balanceOf(FEE_ADDRESS);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Base of transfer functions\r\n     */\r\n    function _internalTransfer(address from, address to, uint amount, uint fee)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* Disallow transfers to irretrievable-addresses. */\r\n        require(to != address(0), \"Cannot transfer to the 0 address\");\r\n        require(to != address(this), \"Cannot transfer to the underlying contract\");\r\n        require(to != address(proxy), \"Cannot transfer to the proxy contract\");\r\n\r\n        /* Insufficient balance will be handled by the safe subtraction. */\r\n        tokenState.setBalanceOf(from, safeSub(tokenState.balanceOf(from), safeAdd(amount, fee)));\r\n        tokenState.setBalanceOf(to, safeAdd(tokenState.balanceOf(to), amount));\r\n        tokenState.setBalanceOf(FEE_ADDRESS, safeAdd(tokenState.balanceOf(FEE_ADDRESS), fee));\r\n\r\n        /* Emit events for both the transfer itself and the fee. */\r\n        emitTransfer(from, to, amount);\r\n        emitTransfer(from, FEE_ADDRESS, fee);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice ERC20 friendly transfer function.\r\n     */\r\n    function _transfer_byProxy(address sender, address to, uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint received = amountReceived(value);\r\n        uint fee = safeSub(value, received);\r\n\r\n        return _internalTransfer(sender, to, received, fee);\r\n    }\r\n\r\n    /**\r\n     * @notice ERC20 friendly transferFrom function.\r\n     */\r\n    function _transferFrom_byProxy(address sender, address from, address to, uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* The fee is deducted from the amount sent. */\r\n        uint received = amountReceived(value);\r\n        uint fee = safeSub(value, received);\r\n\r\n        /* Reduce the allowance by the amount we're transferring.\r\n         * The safeSub call will handle an insufficient allowance. */\r\n        tokenState.setAllowance(from, sender, safeSub(tokenState.allowance(from, sender), value));\r\n\r\n        return _internalTransfer(from, to, received, fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Ability to transfer where the sender pays the fees (not ERC20)\r\n     */\r\n    function _transferSenderPaysFee_byProxy(address sender, address to, uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* The fee is added to the amount sent. */\r\n        uint fee = transferFeeIncurred(value);\r\n        return _internalTransfer(sender, to, value, fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Ability to transferFrom where they sender pays the fees (not ERC20).\r\n     */\r\n    function _transferFromSenderPaysFee_byProxy(address sender, address from, address to, uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* The fee is added to the amount sent. */\r\n        uint fee = transferFeeIncurred(value);\r\n        uint total = safeAdd(value, fee);\r\n\r\n        /* Reduce the allowance by the amount we're transferring. */\r\n        tokenState.setAllowance(from, sender, safeSub(tokenState.allowance(from, sender), total));\r\n\r\n        return _internalTransfer(from, to, value, fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw tokens from the fee pool into a given account.\r\n     * @dev Only the fee authority may call this.\r\n     */\r\n    function withdrawFees(address account, uint value)\r\n        external\r\n        onlyFeeAuthority\r\n        returns (bool)\r\n    {\r\n        require(account != address(0), \"Must supply an account address to withdraw fees\");\r\n\r\n        /* 0-value withdrawals do nothing. */\r\n        if (value == 0) {\r\n            return false;\r\n        }\r\n\r\n        /* Safe subtraction ensures an exception is thrown if the balance is insufficient. */\r\n        tokenState.setBalanceOf(FEE_ADDRESS, safeSub(tokenState.balanceOf(FEE_ADDRESS), value));\r\n        tokenState.setBalanceOf(account, safeAdd(tokenState.balanceOf(account), value));\r\n\r\n        emitFeesWithdrawn(account, value);\r\n        emitTransfer(FEE_ADDRESS, account, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Donate tokens from the sender's balance into the fee pool.\r\n     */\r\n    function donateToFeePool(uint n)\r\n        external\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        address sender = messageSender;\r\n        /* Empty donations are disallowed. */\r\n        uint balance = tokenState.balanceOf(sender);\r\n        require(balance != 0, \"Must have a balance in order to donate to the fee pool\");\r\n\r\n        /* safeSub ensures the donor has sufficient balance. */\r\n        tokenState.setBalanceOf(sender, safeSub(balance, n));\r\n        tokenState.setBalanceOf(FEE_ADDRESS, safeAdd(tokenState.balanceOf(FEE_ADDRESS), n));\r\n\r\n        emitFeesDonated(sender, n);\r\n        emitTransfer(sender, FEE_ADDRESS, n);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyFeeAuthority\r\n    {\r\n        require(msg.sender == feeAuthority, \"Only the fee authority can do this action\");\r\n        _;\r\n    }\r\n\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event TransferFeeRateUpdated(uint newFeeRate);\r\n    bytes32 constant TRANSFERFEERATEUPDATED_SIG = keccak256(\"TransferFeeRateUpdated(uint256)\");\r\n    function emitTransferFeeRateUpdated(uint newFeeRate) internal {\r\n        proxy._emit(abi.encode(newFeeRate), 1, TRANSFERFEERATEUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event FeeAuthorityUpdated(address newFeeAuthority);\r\n    bytes32 constant FEEAUTHORITYUPDATED_SIG = keccak256(\"FeeAuthorityUpdated(address)\");\r\n    function emitFeeAuthorityUpdated(address newFeeAuthority) internal {\r\n        proxy._emit(abi.encode(newFeeAuthority), 1, FEEAUTHORITYUPDATED_SIG, 0, 0, 0);\r\n    } \r\n\r\n    event FeesWithdrawn(address indexed account, uint value);\r\n    bytes32 constant FEESWITHDRAWN_SIG = keccak256(\"FeesWithdrawn(address,uint256)\");\r\n    function emitFeesWithdrawn(address account, uint value) internal {\r\n        proxy._emit(abi.encode(value), 2, FEESWITHDRAWN_SIG, bytes32(account), 0, 0);\r\n    }\r\n\r\n    event FeesDonated(address indexed donor, uint value);\r\n    bytes32 constant FEESDONATED_SIG = keccak256(\"FeesDonated(address,uint256)\");\r\n    function emitFeesDonated(address donor, uint value) internal {\r\n        proxy._emit(abi.encode(value), 2, FEESDONATED_SIG, bytes32(donor), 0, 0);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       Nomin.sol\r\nversion:    1.2\r\nauthor:     Anton Jurisevic\r\n            Mike Spain\r\n            Dominic Romanowski\r\n            Kevin Brown\r\n\r\ndate:       2018-05-29\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nHavven-backed nomin stablecoin contract.\r\n\r\nThis contract issues nomins, which are tokens worth 1 USD each.\r\n\r\nNomins are issuable by Havven holders who have to lock up some\r\nvalue of their havvens to issue H * Cmax nomins. Where Cmax is\r\nsome value less than 1.\r\n\r\nA configurable fee is charged on nomin transfers and deposited\r\ninto a common pot, which havven holders may withdraw from once\r\nper fee period.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\ncontract Nomin is FeeToken {\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    Havven public havven;\r\n\r\n    // Accounts which have lost the privilege to transact in nomins.\r\n    mapping(address => bool) public frozen;\r\n\r\n    // Nomin transfers incur a 15 bp fee by default.\r\n    uint constant TRANSFER_FEE_RATE = 15 * UNIT / 10000;\r\n    string constant TOKEN_NAME = \"Nomin USD\";\r\n    string constant TOKEN_SYMBOL = \"nUSD\";\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(address _proxy, TokenState _tokenState, Havven _havven,\r\n                uint _totalSupply,\r\n                address _owner)\r\n        FeeToken(_proxy, _tokenState,\r\n                 TOKEN_NAME, TOKEN_SYMBOL, _totalSupply,\r\n                 TRANSFER_FEE_RATE,\r\n                 _havven, // The havven contract is the fee authority.\r\n                 _owner)\r\n        public\r\n    {\r\n        require(_proxy != 0, \"_proxy cannot be 0\");\r\n        require(address(_havven) != 0, \"_havven cannot be 0\");\r\n        require(_owner != 0, \"_owner cannot be 0\");\r\n\r\n        // It should not be possible to transfer to the fee pool directly (or confiscate its balance).\r\n        frozen[FEE_ADDRESS] = true;\r\n        havven = _havven;\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    function setHavven(Havven _havven)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        // havven should be set as the feeAuthority after calling this depending on\r\n        // havven's internal logic\r\n        havven = _havven;\r\n        setFeeAuthority(_havven);\r\n        emitHavvenUpdated(_havven);\r\n    }\r\n\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /* Override ERC20 transfer function in order to check\r\n     * whether the recipient account is frozen. Note that there is\r\n     * no need to check whether the sender has a frozen account,\r\n     * since their funds have already been confiscated,\r\n     * and no new funds can be transferred to it.*/\r\n    function transfer(address to, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        require(!frozen[to], \"Cannot transfer to frozen address\");\r\n        return _transfer_byProxy(messageSender, to, value);\r\n    }\r\n\r\n    /* Override ERC20 transferFrom function in order to check\r\n     * whether the recipient account is frozen. */\r\n    function transferFrom(address from, address to, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        require(!frozen[to], \"Cannot transfer to frozen address\");\r\n        return _transferFrom_byProxy(messageSender, from, to, value);\r\n    }\r\n\r\n    function transferSenderPaysFee(address to, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        require(!frozen[to], \"Cannot transfer to frozen address\");\r\n        return _transferSenderPaysFee_byProxy(messageSender, to, value);\r\n    }\r\n\r\n    function transferFromSenderPaysFee(address from, address to, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        require(!frozen[to], \"Cannot transfer to frozen address\");\r\n        return _transferFromSenderPaysFee_byProxy(messageSender, from, to, value);\r\n    }\r\n\r\n    /* The owner may allow a previously-frozen contract to once\r\n     * again accept and transfer nomins. */\r\n    function unfreezeAccount(address target)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        require(frozen[target] && target != FEE_ADDRESS, \"Account must be frozen, and cannot be the fee address\");\r\n        frozen[target] = false;\r\n        emitAccountUnfrozen(target);\r\n    }\r\n\r\n    /* Allow havven to issue a certain number of\r\n     * nomins from an account. */\r\n    function issue(address account, uint amount)\r\n        external\r\n        onlyHavven\r\n    {\r\n        tokenState.setBalanceOf(account, safeAdd(tokenState.balanceOf(account), amount));\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n        emitTransfer(address(0), account, amount);\r\n        emitIssued(account, amount);\r\n    }\r\n\r\n    /* Allow havven to burn a certain number of\r\n     * nomins from an account. */\r\n    function burn(address account, uint amount)\r\n        external\r\n        onlyHavven\r\n    {\r\n        tokenState.setBalanceOf(account, safeSub(tokenState.balanceOf(account), amount));\r\n        totalSupply = safeSub(totalSupply, amount);\r\n        emitTransfer(account, address(0), amount);\r\n        emitBurned(account, amount);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyHavven() {\r\n        require(Havven(msg.sender) == havven, \"Only the Havven contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event HavvenUpdated(address newHavven);\r\n    bytes32 constant HAVVENUPDATED_SIG = keccak256(\"HavvenUpdated(address)\");\r\n    function emitHavvenUpdated(address newHavven) internal {\r\n        proxy._emit(abi.encode(newHavven), 1, HAVVENUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event AccountFrozen(address indexed target, uint balance);\r\n    bytes32 constant ACCOUNTFROZEN_SIG = keccak256(\"AccountFrozen(address,uint256)\");\r\n    function emitAccountFrozen(address target, uint balance) internal {\r\n        proxy._emit(abi.encode(balance), 2, ACCOUNTFROZEN_SIG, bytes32(target), 0, 0);\r\n    }\r\n\r\n    event AccountUnfrozen(address indexed target);\r\n    bytes32 constant ACCOUNTUNFROZEN_SIG = keccak256(\"AccountUnfrozen(address)\");\r\n    function emitAccountUnfrozen(address target) internal {\r\n        proxy._emit(abi.encode(), 2, ACCOUNTUNFROZEN_SIG, bytes32(target), 0, 0);\r\n    }\r\n\r\n    event Issued(address indexed account, uint amount);\r\n    bytes32 constant ISSUED_SIG = keccak256(\"Issued(address,uint256)\");\r\n    function emitIssued(address account, uint amount) internal {\r\n        proxy._emit(abi.encode(amount), 2, ISSUED_SIG, bytes32(account), 0, 0);\r\n    }\r\n\r\n    event Burned(address indexed account, uint amount);\r\n    bytes32 constant BURNED_SIG = keccak256(\"Burned(address,uint256)\");\r\n    function emitBurned(address account, uint amount) internal {\r\n        proxy._emit(abi.encode(amount), 2, BURNED_SIG, bytes32(account), 0, 0);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       LimitedSetup.sol\r\nversion:    1.1\r\nauthor:     Anton Jurisevic\r\n\r\ndate:       2018-05-15\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nA contract with a limited setup period. Any function modified\r\nwith the setup modifier will cease to work after the\r\nconclusion of the configurable-length post-construction setup period.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title Any function decorated with the modifier this contract provides\r\n * deactivates after a specified setup period.\r\n */\r\ncontract LimitedSetup {\r\n\r\n    uint setupExpiryTime;\r\n\r\n    /**\r\n     * @dev LimitedSetup Constructor.\r\n     * @param setupDuration The time the setup period will last for.\r\n     */\r\n    constructor(uint setupDuration)\r\n        public\r\n    {\r\n        setupExpiryTime = now + setupDuration;\r\n    }\r\n\r\n    modifier onlyDuringSetup\r\n    {\r\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       HavvenEscrow.sol\r\nversion:    1.1\r\nauthor:     Anton Jurisevic\r\n            Dominic Romanowski\r\n            Mike Spain\r\n\r\ndate:       2018-05-29\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nThis contract allows the foundation to apply unique vesting\r\nschedules to havven funds sold at various discounts in the token\r\nsale. HavvenEscrow gives users the ability to inspect their\r\nvested funds, their quantities and vesting dates, and to withdraw\r\nthe fees that accrue on those funds.\r\n\r\nThe fees are handled by withdrawing the entire fee allocation\r\nfor all havvens inside the escrow contract, and then allowing\r\nthe contract itself to subdivide that pool up proportionally within\r\nitself. Every time the fee period rolls over in the main Havven\r\ncontract, the HavvenEscrow fee pool is remitted back into the\r\nmain fee pool to be redistributed in the next fee period.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title A contract to hold escrowed havvens and free them at given schedules.\r\n */\r\ncontract HavvenEscrow is SafeDecimalMath, Owned, LimitedSetup(8 weeks) {\r\n    /* The corresponding Havven contract. */\r\n    Havven public havven;\r\n\r\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\r\n     * These are the times at which each given quantity of havvens vests. */\r\n    mapping(address => uint[2][]) public vestingSchedules;\r\n\r\n    /* An account's total vested havven balance to save recomputing this for fee extraction purposes. */\r\n    mapping(address => uint) public totalVestedAccountBalance;\r\n\r\n    /* The total remaining vested balance, for verifying the actual havven balance of this contract against. */\r\n    uint public totalVestedBalance;\r\n\r\n    uint constant TIME_INDEX = 0;\r\n    uint constant QUANTITY_INDEX = 1;\r\n\r\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules. */\r\n    uint constant MAX_VESTING_ENTRIES = 20;\r\n\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(address _owner, Havven _havven)\r\n        Owned(_owner)\r\n        public\r\n    {\r\n        havven = _havven;\r\n    }\r\n\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    function setHavven(Havven _havven)\r\n        external\r\n        onlyOwner\r\n    {\r\n        havven = _havven;\r\n        emit HavvenUpdated(_havven);\r\n    }\r\n\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice A simple alias to totalVestedAccountBalance: provides ERC20 balance integration.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return totalVestedAccountBalance[account];\r\n    }\r\n\r\n    /**\r\n     * @notice The number of vesting dates in an account's schedule.\r\n     */\r\n    function numVestingEntries(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return vestingSchedules[account].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a particular schedule entry for an account.\r\n     * @return A pair of uints: (timestamp, havven quantity).\r\n     */\r\n    function getVestingScheduleEntry(address account, uint index)\r\n        public\r\n        view\r\n        returns (uint[2])\r\n    {\r\n        return vestingSchedules[account][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the time at which a given schedule entry will vest.\r\n     */\r\n    function getVestingTime(address account, uint index)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getVestingScheduleEntry(account,index)[TIME_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the quantity of havvens associated with a given schedule entry.\r\n     */\r\n    function getVestingQuantity(address account, uint index)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getVestingScheduleEntry(account,index)[QUANTITY_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\r\n     */\r\n    function getNextVestingIndex(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint len = numVestingEntries(account);\r\n        for (uint i = 0; i < len; i++) {\r\n            if (getVestingTime(account, i) != 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the next schedule entry that will vest for a given user.\r\n     * @return A pair of uints: (timestamp, havven quantity). */\r\n    function getNextVestingEntry(address account)\r\n        public\r\n        view\r\n        returns (uint[2])\r\n    {\r\n        uint index = getNextVestingIndex(account);\r\n        if (index == numVestingEntries(account)) {\r\n            return [uint(0), 0];\r\n        }\r\n        return getVestingScheduleEntry(account, index);\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\r\n     */\r\n    function getNextVestingTime(address account)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getNextVestingEntry(account)[TIME_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\r\n     */\r\n    function getNextVestingQuantity(address account)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\r\n    }\r\n\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Withdraws a quantity of havvens back to the havven contract.\r\n     * @dev This may only be called by the owner during the contract's setup period.\r\n     */\r\n    function withdrawHavvens(uint quantity)\r\n        external\r\n        onlyOwner\r\n        onlyDuringSetup\r\n    {\r\n        havven.transfer(havven, quantity);\r\n    }\r\n\r\n    /**\r\n     * @notice Destroy the vesting information associated with an account.\r\n     */\r\n    function purgeAccount(address account)\r\n        external\r\n        onlyOwner\r\n        onlyDuringSetup\r\n    {\r\n        delete vestingSchedules[account];\r\n        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);\r\n        delete totalVestedAccountBalance[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\r\n     * @dev A call to this should be accompanied by either enough balance already available\r\n     * in this contract, or a corresponding call to havven.endow(), to ensure that when\r\n     * the funds are withdrawn, there is enough balance, as well as correctly calculating\r\n     * the fees.\r\n     * This may only be called by the owner during the contract's setup period.\r\n     * Note; although this function could technically be used to produce unbounded\r\n     * arrays, it's only in the foundation's command to add to these lists.\r\n     * @param account The account to append a new vesting entry to.\r\n     * @param time The absolute unix timestamp after which the vested quantity may be withdrawn.\r\n     * @param quantity The quantity of havvens that will vest.\r\n     */\r\n    function appendVestingEntry(address account, uint time, uint quantity)\r\n        public\r\n        onlyOwner\r\n        onlyDuringSetup\r\n    {\r\n        /* No empty or already-passed vesting entries allowed. */\r\n        require(now < time, \"Time must be in the future\");\r\n        require(quantity != 0, \"Quantity cannot be zero\");\r\n\r\n        /* There must be enough balance in the contract to provide for the vesting entry. */\r\n        totalVestedBalance = safeAdd(totalVestedBalance, quantity);\r\n        require(totalVestedBalance <= havven.balanceOf(this), \"Must be enough balance in the contract to provide for the vesting entry\");\r\n\r\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\r\n        uint scheduleLength = vestingSchedules[account].length;\r\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\r\n\r\n        if (scheduleLength == 0) {\r\n            totalVestedAccountBalance[account] = quantity;\r\n        } else {\r\n            /* Disallow adding new vested havvens earlier than the last one.\r\n             * Since entries are only appended, this means that no vesting date can be repeated. */\r\n            require(getVestingTime(account, numVestingEntries(account) - 1) < time, \"Cannot add new vested entries earlier than the last one\");\r\n            totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account], quantity);\r\n        }\r\n\r\n        vestingSchedules[account].push([time, quantity]);\r\n    }\r\n\r\n    /**\r\n     * @notice Construct a vesting schedule to release a quantities of havvens\r\n     * over a series of intervals.\r\n     * @dev Assumes that the quantities are nonzero\r\n     * and that the sequence of timestamps is strictly increasing.\r\n     * This may only be called by the owner during the contract's setup period.\r\n     */\r\n    function addVestingSchedule(address account, uint[] times, uint[] quantities)\r\n        external\r\n        onlyOwner\r\n        onlyDuringSetup\r\n    {\r\n        for (uint i = 0; i < times.length; i++) {\r\n            appendVestingEntry(account, times[i], quantities[i]);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Allow a user to withdraw any havvens in their schedule that have vested.\r\n     */\r\n    function vest()\r\n        external\r\n    {\r\n        uint numEntries = numVestingEntries(msg.sender);\r\n        uint total;\r\n        for (uint i = 0; i < numEntries; i++) {\r\n            uint time = getVestingTime(msg.sender, i);\r\n            /* The list is sorted; when we reach the first future time, bail out. */\r\n            if (time > now) {\r\n                break;\r\n            }\r\n            uint qty = getVestingQuantity(msg.sender, i);\r\n            if (qty == 0) {\r\n                continue;\r\n            }\r\n\r\n            vestingSchedules[msg.sender][i] = [0, 0];\r\n            total = safeAdd(total, qty);\r\n        }\r\n\r\n        if (total != 0) {\r\n            totalVestedBalance = safeSub(totalVestedBalance, total);\r\n            totalVestedAccountBalance[msg.sender] = safeSub(totalVestedAccountBalance[msg.sender], total);\r\n            havven.transfer(msg.sender, total);\r\n            emit Vested(msg.sender, now, total);\r\n        }\r\n    }\r\n\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event HavvenUpdated(address newHavven);\r\n\r\n    event Vested(address indexed beneficiary, uint time, uint value);\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION\r\n-----------------------------------------------------------------\r\n\r\nfile:       Havven.sol\r\nversion:    1.2\r\nauthor:     Anton Jurisevic\r\n            Dominic Romanowski\r\n\r\ndate:       2018-05-15\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nHavven token contract. Havvens are transferable ERC20 tokens,\r\nand also give their holders the following privileges.\r\nAn owner of havvens may participate in nomin confiscation votes, they\r\nmay also have the right to issue nomins at the discretion of the\r\nfoundation for this version of the contract.\r\n\r\nAfter a fee period terminates, the duration and fees collected for that\r\nperiod are computed, and the next period begins. Thus an account may only\r\nwithdraw the fees owed to them for the previous period, and may only do\r\nso once per period. Any unclaimed fees roll over into the common pot for\r\nthe next period.\r\n\r\n== Average Balance Calculations ==\r\n\r\nThe fee entitlement of a havven holder is proportional to their average\r\nissued nomin balance over the last fee period. This is computed by\r\nmeasuring the area under the graph of a user's issued nomin balance over\r\ntime, and then when a new fee period begins, dividing through by the\r\nduration of the fee period.\r\n\r\nWe need only update values when the balances of an account is modified.\r\nThis occurs when issuing or burning for issued nomin balances,\r\nand when transferring for havven balances. This is for efficiency,\r\nand adds an implicit friction to interacting with havvens.\r\nA havven holder pays for his own recomputation whenever he wants to change\r\nhis position, which saves the foundation having to maintain a pot dedicated\r\nto resourcing this.\r\n\r\nA hypothetical user's balance history over one fee period, pictorially:\r\n\r\n      s ____\r\n       |    |\r\n       |    |___ p\r\n       |____|___|___ __ _  _\r\n       f    t   n\r\n\r\nHere, the balance was s between times f and t, at which time a transfer\r\noccurred, updating the balance to p, until n, when the present transfer occurs.\r\nWhen a new transfer occurs at time n, the balance being p,\r\nwe must:\r\n\r\n  - Add the area p * (n - t) to the total area recorded so far\r\n  - Update the last transfer time to n\r\n\r\nSo if this graph represents the entire current fee period,\r\nthe average havvens held so far is ((t-f)*s + (n-t)*p) / (n-f).\r\nThe complementary computations must be performed for both sender and\r\nrecipient.\r\n\r\nNote that a transfer keeps global supply of havvens invariant.\r\nThe sum of all balances is constant, and unmodified by any transfer.\r\nSo the sum of all balances multiplied by the duration of a fee period is also\r\nconstant, and this is equivalent to the sum of the area of every user's\r\ntime/balance graph. Dividing through by that duration yields back the total\r\nhavven supply. So, at the end of a fee period, we really do yield a user's\r\naverage share in the havven supply over that period.\r\n\r\nA slight wrinkle is introduced if we consider the time r when the fee period\r\nrolls over. Then the previous fee period k-1 is before r, and the current fee\r\nperiod k is afterwards. If the last transfer took place before r,\r\nbut the latest transfer occurred afterwards:\r\n\r\nk-1       |        k\r\n      s __|_\r\n       |  | |\r\n       |  | |____ p\r\n       |__|_|____|___ __ _  _\r\n          |\r\n       f  | t    n\r\n          r\r\n\r\nIn this situation the area (r-f)*s contributes to fee period k-1, while\r\nthe area (t-r)*s contributes to fee period k. We will implicitly consider a\r\nzero-value transfer to have occurred at time r. Their fee entitlement for the\r\nprevious period will be finalised at the time of their first transfer during the\r\ncurrent fee period, or when they query or withdraw their fee entitlement.\r\n\r\nIn the implementation, the duration of different fee periods may be slightly irregular,\r\nas the check that they have rolled over occurs only when state-changing havven\r\noperations are performed.\r\n\r\n== Issuance and Burning ==\r\n\r\nIn this version of the havven contract, nomins can only be issued by\r\nthose that have been nominated by the havven foundation. Nomins are assumed\r\nto be valued at $1, as they are a stable unit of account.\r\n\r\nAll nomins issued require a proportional value of havvens to be locked,\r\nwhere the proportion is governed by the current issuance ratio. This\r\nmeans for every $1 of Havvens locked up, $(issuanceRatio) nomins can be issued.\r\ni.e. to issue 100 nomins, 100/issuanceRatio dollars of havvens need to be locked up.\r\n\r\nTo determine the value of some amount of havvens(H), an oracle is used to push\r\nthe price of havvens (P_H) in dollars to the contract. The value of H\r\nwould then be: H * P_H.\r\n\r\nAny havvens that are locked up by this issuance process cannot be transferred.\r\nThe amount that is locked floats based on the price of havvens. If the price\r\nof havvens moves up, less havvens are locked, so they can be issued against,\r\nor transferred freely. If the price of havvens moves down, more havvens are locked,\r\neven going above the initial wallet balance.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title Havven ERC20 contract.\r\n * @notice The Havven contracts does not only facilitate transfers and track balances,\r\n * but it also computes the quantity of fees each havven holder is entitled to.\r\n */\r\ncontract Havven is ExternStateToken {\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /* A struct for handing values associated with average balance calculations */\r\n    struct IssuanceData {\r\n        /* Sums of balances*duration in the current fee period.\r\n        /* range: decimals; units: havven-seconds */\r\n        uint currentBalanceSum;\r\n        /* The last period's average balance */\r\n        uint lastAverageBalance;\r\n        /* The last time the data was calculated */\r\n        uint lastModified;\r\n    }\r\n\r\n    /* Issued nomin balances for individual fee entitlements */\r\n    mapping(address => IssuanceData) public issuanceData;\r\n    /* The total number of issued nomins for determining fee entitlements */\r\n    IssuanceData public totalIssuanceData;\r\n\r\n    /* The time the current fee period began */\r\n    uint public feePeriodStartTime;\r\n    /* The time the last fee period began */\r\n    uint public lastFeePeriodStartTime;\r\n\r\n    /* Fee periods will roll over in no shorter a time than this. \r\n     * The fee period cannot actually roll over until a fee-relevant\r\n     * operation such as withdrawal or a fee period duration update occurs,\r\n     * so this is just a target, and the actual duration may be slightly longer. */\r\n    uint public feePeriodDuration = 4 weeks;\r\n    /* ...and must target between 1 day and six months. */\r\n    uint constant MIN_FEE_PERIOD_DURATION = 1 days;\r\n    uint constant MAX_FEE_PERIOD_DURATION = 26 weeks;\r\n\r\n    /* The quantity of nomins that were in the fee pot at the time */\r\n    /* of the last fee rollover, at feePeriodStartTime. */\r\n    uint public lastFeesCollected;\r\n\r\n    /* Whether a user has withdrawn their last fees */\r\n    mapping(address => bool) public hasWithdrawnFees;\r\n\r\n    Nomin public nomin;\r\n    HavvenEscrow public escrow;\r\n\r\n    /* The address of the oracle which pushes the havven price to this contract */\r\n    address public oracle;\r\n    /* The price of havvens written in UNIT */\r\n    uint public price;\r\n    /* The time the havven price was last updated */\r\n    uint public lastPriceUpdateTime;\r\n    /* How long will the contract assume the price of havvens is correct */\r\n    uint public priceStalePeriod = 3 hours;\r\n\r\n    /* A quantity of nomins greater than this ratio\r\n     * may not be issued against a given value of havvens. */\r\n    uint public issuanceRatio = UNIT / 5;\r\n    /* No more nomins may be issued than the value of havvens backing them. */\r\n    uint constant MAX_ISSUANCE_RATIO = UNIT;\r\n\r\n    /* Whether the address can issue nomins or not. */\r\n    mapping(address => bool) public isIssuer;\r\n    /* The number of currently-outstanding nomins the user has issued. */\r\n    mapping(address => uint) public nominsIssued;\r\n\r\n    uint constant HAVVEN_SUPPLY = 1e8 * UNIT;\r\n    uint constant ORACLE_FUTURE_LIMIT = 10 minutes;\r\n    string constant TOKEN_NAME = \"Havven\";\r\n    string constant TOKEN_SYMBOL = \"HAV\";\r\n    \r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _tokenState A pre-populated contract containing token balances.\r\n     * If the provided address is 0x0, then a fresh one will be constructed with the contract owning all tokens.\r\n     * @param _owner The owner of this contract.\r\n     */\r\n    constructor(address _proxy, TokenState _tokenState, address _owner, address _oracle,\r\n                uint _price, address[] _issuers, Havven _oldHavven)\r\n        ExternStateToken(_proxy, _tokenState, TOKEN_NAME, TOKEN_SYMBOL, HAVVEN_SUPPLY, _owner)\r\n        public\r\n    {\r\n        oracle = _oracle;\r\n        price = _price;\r\n        lastPriceUpdateTime = now;\r\n\r\n        uint i;\r\n        if (_oldHavven == address(0)) {\r\n            feePeriodStartTime = now;\r\n            lastFeePeriodStartTime = now - feePeriodDuration;\r\n            for (i = 0; i < _issuers.length; i++) {\r\n                isIssuer[_issuers[i]] = true;\r\n            }\r\n        } else {\r\n            feePeriodStartTime = _oldHavven.feePeriodStartTime();\r\n            lastFeePeriodStartTime = _oldHavven.lastFeePeriodStartTime();\r\n\r\n            uint cbs;\r\n            uint lab;\r\n            uint lm;\r\n            (cbs, lab, lm) = _oldHavven.totalIssuanceData();\r\n            totalIssuanceData.currentBalanceSum = cbs;\r\n            totalIssuanceData.lastAverageBalance = lab;\r\n            totalIssuanceData.lastModified = lm;\r\n\r\n            for (i = 0; i < _issuers.length; i++) {\r\n                address issuer = _issuers[i];\r\n                isIssuer[issuer] = true;\r\n                uint nomins = _oldHavven.nominsIssued(issuer);\r\n                if (nomins == 0) {\r\n                    // It is not valid in general to skip those with no currently-issued nomins.\r\n                    // But for this release, issuers with nonzero issuanceData have current issuance.\r\n                    continue;\r\n                }\r\n                (cbs, lab, lm) = _oldHavven.issuanceData(issuer);\r\n                nominsIssued[issuer] = nomins;\r\n                issuanceData[issuer].currentBalanceSum = cbs;\r\n                issuanceData[issuer].lastAverageBalance = lab;\r\n                issuanceData[issuer].lastModified = lm;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set the associated Nomin contract to collect fees from.\r\n     * @dev Only the contract owner may call this.\r\n     */\r\n    function setNomin(Nomin _nomin)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        nomin = _nomin;\r\n        emitNominUpdated(_nomin);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the associated havven escrow contract.\r\n     * @dev Only the contract owner may call this.\r\n     */\r\n    function setEscrow(HavvenEscrow _escrow)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        escrow = _escrow;\r\n        emitEscrowUpdated(_escrow);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the targeted fee period duration.\r\n     * @dev Only callable by the contract owner. The duration must fall within\r\n     * acceptable bounds (1 day to 26 weeks). Upon resetting this the fee period\r\n     * may roll over if the target duration was shortened sufficiently.\r\n     */\r\n    function setFeePeriodDuration(uint duration)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        require(MIN_FEE_PERIOD_DURATION <= duration && duration <= MAX_FEE_PERIOD_DURATION,\r\n            \"Duration must be between MIN_FEE_PERIOD_DURATION and MAX_FEE_PERIOD_DURATION\");\r\n        feePeriodDuration = duration;\r\n        emitFeePeriodDurationUpdated(duration);\r\n        rolloverFeePeriodIfElapsed();\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Oracle that pushes the havven price to this contract\r\n     */\r\n    function setOracle(address _oracle)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        oracle = _oracle;\r\n        emitOracleUpdated(_oracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the stale period on the updated havven price\r\n     * @dev No max/minimum, as changing it wont influence anything but issuance by the foundation\r\n     */\r\n    function setPriceStalePeriod(uint time)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        priceStalePeriod = time;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the issuanceRatio for issuance calculations.\r\n     * @dev Only callable by the contract owner.\r\n     */\r\n    function setIssuanceRatio(uint _issuanceRatio)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, \"New issuance ratio must be less than or equal to MAX_ISSUANCE_RATIO\");\r\n        issuanceRatio = _issuanceRatio;\r\n        emitIssuanceRatioUpdated(_issuanceRatio);\r\n    }\r\n\r\n    /**\r\n     * @notice Set whether the specified can issue nomins or not.\r\n     */\r\n    function setIssuer(address account, bool value)\r\n        external\r\n        optionalProxy_onlyOwner\r\n    {\r\n        isIssuer[account] = value;\r\n        emitIssuersUpdated(account, value);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function issuanceCurrentBalanceSum(address account)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return issuanceData[account].currentBalanceSum;\r\n    }\r\n\r\n    function issuanceLastAverageBalance(address account)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return issuanceData[account].lastAverageBalance;\r\n    }\r\n\r\n    function issuanceLastModified(address account)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return issuanceData[account].lastModified;\r\n    }\r\n\r\n    function totalIssuanceCurrentBalanceSum()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return totalIssuanceData.currentBalanceSum;\r\n    }\r\n\r\n    function totalIssuanceLastAverageBalance()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return totalIssuanceData.lastAverageBalance;\r\n    }\r\n\r\n    function totalIssuanceLastModified()\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        return totalIssuanceData.lastModified;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice ERC20 transfer function.\r\n     */\r\n    function transfer(address to, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        address sender = messageSender;\r\n        require(nominsIssued[sender] == 0 || value <= transferableHavvens(sender), \"Value to transfer exceeds available havvens\");\r\n        /* Perform the transfer: if there is a problem,\r\n         * an exception will be thrown in this call. */\r\n        _transfer_byProxy(sender, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice ERC20 transferFrom function.\r\n     */\r\n    function transferFrom(address from, address to, uint value)\r\n        public\r\n        optionalProxy\r\n        returns (bool)\r\n    {\r\n        address sender = messageSender;\r\n        require(nominsIssued[from] == 0 || value <= transferableHavvens(from), \"Value to transfer exceeds available havvens\");\r\n        /* Perform the transfer: if there is a problem,\r\n         * an exception will be thrown in this call. */\r\n        _transferFrom_byProxy(sender, from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the last period's fee entitlement for the message sender\r\n     * and then deposit it into their nomin account.\r\n     */\r\n    function withdrawFees()\r\n        external\r\n        optionalProxy\r\n    {\r\n        address sender = messageSender;\r\n        rolloverFeePeriodIfElapsed();\r\n        /* Do not deposit fees into frozen accounts. */\r\n        require(!nomin.frozen(sender), \"Cannot deposit fees into frozen accounts\");\r\n\r\n        /* Check the period has rolled over first. */\r\n        updateIssuanceData(sender, nominsIssued[sender], nomin.totalSupply());\r\n\r\n        /* Only allow accounts to withdraw fees once per period. */\r\n        require(!hasWithdrawnFees[sender], \"Fees have already been withdrawn in this period\");\r\n\r\n        uint feesOwed;\r\n        uint lastTotalIssued = totalIssuanceData.lastAverageBalance;\r\n\r\n        if (lastTotalIssued > 0) {\r\n            /* Sender receives a share of last period's collected fees proportional\r\n             * with their average fraction of the last period's issued nomins. */\r\n            feesOwed = safeDiv_dec(\r\n                safeMul_dec(issuanceData[sender].lastAverageBalance, lastFeesCollected),\r\n                lastTotalIssued\r\n            );\r\n        }\r\n\r\n        hasWithdrawnFees[sender] = true;\r\n\r\n        if (feesOwed != 0) {\r\n            nomin.withdrawFees(sender, feesOwed);\r\n        }\r\n        emitFeesWithdrawn(messageSender, feesOwed);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the havven balance averages since the last transfer\r\n     * or entitlement adjustment.\r\n     * @dev Since this updates the last transfer timestamp, if invoked\r\n     * consecutively, this function will do nothing after the first call.\r\n     * Also, this will adjust the total issuance at the same time.\r\n     */\r\n    function updateIssuanceData(address account, uint preBalance, uint lastTotalSupply)\r\n        internal\r\n    {\r\n        /* update the total balances first */\r\n        totalIssuanceData = computeIssuanceData(lastTotalSupply, totalIssuanceData);\r\n\r\n        if (issuanceData[account].lastModified < feePeriodStartTime) {\r\n            hasWithdrawnFees[account] = false;\r\n        }\r\n\r\n        issuanceData[account] = computeIssuanceData(preBalance, issuanceData[account]);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Compute the new IssuanceData on the old balance\r\n     */\r\n    function computeIssuanceData(uint preBalance, IssuanceData preIssuance)\r\n        internal\r\n        view\r\n        returns (IssuanceData)\r\n    {\r\n\r\n        uint currentBalanceSum = preIssuance.currentBalanceSum;\r\n        uint lastAverageBalance = preIssuance.lastAverageBalance;\r\n        uint lastModified = preIssuance.lastModified;\r\n\r\n        if (lastModified < feePeriodStartTime) {\r\n            if (lastModified < lastFeePeriodStartTime) {\r\n                /* The balance was last updated before the previous fee period, so the average\r\n                 * balance in this period is their pre-transfer balance. */\r\n                lastAverageBalance = preBalance;\r\n            } else {\r\n                /* The balance was last updated during the previous fee period. */\r\n                /* No overflow or zero denominator problems, since lastFeePeriodStartTime < feePeriodStartTime < lastModified. \r\n                 * implies these quantities are strictly positive. */\r\n                uint timeUpToRollover = feePeriodStartTime - lastModified;\r\n                uint lastFeePeriodDuration = feePeriodStartTime - lastFeePeriodStartTime;\r\n                uint lastBalanceSum = safeAdd(currentBalanceSum, safeMul(preBalance, timeUpToRollover));\r\n                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;\r\n            }\r\n            /* Roll over to the next fee period. */\r\n            currentBalanceSum = safeMul(preBalance, now - feePeriodStartTime);\r\n        } else {\r\n            /* The balance was last updated during the current fee period. */\r\n            currentBalanceSum = safeAdd(\r\n                currentBalanceSum,\r\n                safeMul(preBalance, now - lastModified)\r\n            );\r\n        }\r\n\r\n        return IssuanceData(currentBalanceSum, lastAverageBalance, now);\r\n    }\r\n\r\n    /**\r\n     * @notice Recompute and return the given account's last average balance.\r\n     */\r\n    function recomputeLastAverageBalance(address account)\r\n        external\r\n        returns (uint)\r\n    {\r\n        updateIssuanceData(account, nominsIssued[account], nomin.totalSupply());\r\n        return issuanceData[account].lastAverageBalance;\r\n    }\r\n\r\n    /**\r\n     * @notice Issue nomins against the sender's havvens.\r\n     * @dev Issuance is only allowed if the havven price isn't stale and the sender is an issuer.\r\n     */\r\n    function issueNomins(uint amount)\r\n        public\r\n        optionalProxy\r\n        requireIssuer(messageSender)\r\n        /* No need to check if price is stale, as it is checked in issuableNomins. */\r\n    {\r\n        address sender = messageSender;\r\n        require(amount <= remainingIssuableNomins(sender), \"Amount must be less than or equal to remaining issuable nomins\");\r\n        uint lastTot = nomin.totalSupply();\r\n        uint preIssued = nominsIssued[sender];\r\n        nomin.issue(sender, amount);\r\n        nominsIssued[sender] = safeAdd(preIssued, amount);\r\n        updateIssuanceData(sender, preIssued, lastTot);\r\n    }\r\n\r\n    function issueMaxNomins()\r\n        external\r\n        optionalProxy\r\n    {\r\n        issueNomins(remainingIssuableNomins(messageSender));\r\n    }\r\n\r\n    /**\r\n     * @notice Burn nomins to clear issued nomins/free havvens.\r\n     */\r\n    function burnNomins(uint amount)\r\n        /* it doesn't matter if the price is stale or if the user is an issuer, as non-issuers have issued no nomins.*/\r\n        external\r\n        optionalProxy\r\n    {\r\n        address sender = messageSender;\r\n\r\n        uint lastTot = nomin.totalSupply();\r\n        uint preIssued = nominsIssued[sender];\r\n        /* nomin.burn does a safeSub on balance (so it will revert if there are not enough nomins). */\r\n        nomin.burn(sender, amount);\r\n        /* This safe sub ensures amount <= number issued */\r\n        nominsIssued[sender] = safeSub(preIssued, amount);\r\n        updateIssuanceData(sender, preIssued, lastTot);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the fee period has rolled over. If it has, set the new fee period start\r\n     * time, and record the fees collected in the nomin contract.\r\n     */\r\n    function rolloverFeePeriodIfElapsed()\r\n        public\r\n    {\r\n        /* If the fee period has rolled over... */\r\n        if (now >= feePeriodStartTime + feePeriodDuration) {\r\n            lastFeesCollected = nomin.feePool();\r\n            lastFeePeriodStartTime = feePeriodStartTime;\r\n            feePeriodStartTime = now;\r\n            emitFeePeriodRollover(now);\r\n        }\r\n    }\r\n\r\n    /* ========== Issuance/Burning ========== */\r\n\r\n    /**\r\n     * @notice The maximum nomins an issuer can issue against their total havven quantity. This ignores any\r\n     * already issued nomins.\r\n     */\r\n    function maxIssuableNomins(address issuer)\r\n        view\r\n        public\r\n        priceNotStale\r\n        returns (uint)\r\n    {\r\n        if (!isIssuer[issuer]) {\r\n            return 0;\r\n        }\r\n        if (escrow != HavvenEscrow(0)) {\r\n            uint totalOwnedHavvens = safeAdd(tokenState.balanceOf(issuer), escrow.balanceOf(issuer));\r\n            return safeMul_dec(HAVtoUSD(totalOwnedHavvens), issuanceRatio);\r\n        } else {\r\n            return safeMul_dec(HAVtoUSD(tokenState.balanceOf(issuer)), issuanceRatio);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The remaining nomins an issuer can issue against their total havven quantity.\r\n     */\r\n    function remainingIssuableNomins(address issuer)\r\n        view\r\n        public\r\n        returns (uint)\r\n    {\r\n        uint issued = nominsIssued[issuer];\r\n        uint max = maxIssuableNomins(issuer);\r\n        if (issued > max) {\r\n            return 0;\r\n        } else {\r\n            return safeSub(max, issued);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The total havvens owned by this account, both escrowed and unescrowed,\r\n     * against which nomins can be issued.\r\n     * This includes those already being used as collateral (locked), and those\r\n     * available for further issuance (unlocked).\r\n     */\r\n    function collateral(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint bal = tokenState.balanceOf(account);\r\n        if (escrow != address(0)) {\r\n            bal = safeAdd(bal, escrow.balanceOf(account));\r\n        }\r\n        return bal;\r\n    }\r\n\r\n    /**\r\n     * @notice The collateral that would be locked by issuance, which can exceed the account's actual collateral.\r\n     */\r\n    function issuanceDraft(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint issued = nominsIssued[account];\r\n        if (issued == 0) {\r\n            return 0;\r\n        }\r\n        return USDtoHAV(safeDiv_dec(issued, issuanceRatio));\r\n    }\r\n\r\n    /**\r\n     * @notice Collateral that has been locked due to issuance, and cannot be\r\n     * transferred to other addresses. This is capped at the account's total collateral.\r\n     */\r\n    function lockedCollateral(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint debt = issuanceDraft(account);\r\n        uint collat = collateral(account);\r\n        if (debt > collat) {\r\n            return collat;\r\n        }\r\n        return debt;\r\n    }\r\n\r\n    /**\r\n     * @notice Collateral that is not locked and available for issuance.\r\n     */\r\n    function unlockedCollateral(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint locked = lockedCollateral(account);\r\n        uint collat = collateral(account);\r\n        return safeSub(collat, locked);\r\n    }\r\n\r\n    /**\r\n     * @notice The number of havvens that are free to be transferred by an account.\r\n     * @dev If they have enough available Havvens, it could be that\r\n     * their havvens are escrowed, however the transfer would then\r\n     * fail. This means that escrowed havvens are locked first,\r\n     * and then the actual transferable ones.\r\n     */\r\n    function transferableHavvens(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint draft = issuanceDraft(account);\r\n        uint collat = collateral(account);\r\n        // In the case where the issuanceDraft exceeds the collateral, nothing is free\r\n        if (draft > collat) {\r\n            return 0;\r\n        }\r\n\r\n        uint bal = balanceOf(account);\r\n        // In the case where the draft exceeds the escrow, but not the whole collateral\r\n        //   return the fraction of the balance that remains free\r\n        if (draft > safeSub(collat, bal)) {\r\n            return safeSub(collat, draft);\r\n        }\r\n        // In the case where the draft doesn't exceed the escrow, return the entire balance\r\n        return bal;\r\n    }\r\n\r\n    /**\r\n     * @notice The value in USD for a given amount of HAV\r\n     */\r\n    function HAVtoUSD(uint hav_dec)\r\n        public\r\n        view\r\n        priceNotStale\r\n        returns (uint)\r\n    {\r\n        return safeMul_dec(hav_dec, price);\r\n    }\r\n\r\n    /**\r\n     * @notice The value in HAV for a given amount of USD\r\n     */\r\n    function USDtoHAV(uint usd_dec)\r\n        public\r\n        view\r\n        priceNotStale\r\n        returns (uint)\r\n    {\r\n        return safeDiv_dec(usd_dec, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Access point for the oracle to update the price of havvens.\r\n     */\r\n    function updatePrice(uint newPrice, uint timeSent)\r\n        external\r\n        onlyOracle  /* Should be callable only by the oracle. */\r\n    {\r\n        /* Must be the most recently sent price, but not too far in the future.\r\n         * (so we can't lock ourselves out of updating the oracle for longer than this) */\r\n        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT,\r\n            \"Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT\");\r\n\r\n        price = newPrice;\r\n        lastPriceUpdateTime = timeSent;\r\n        emitPriceUpdated(newPrice, timeSent);\r\n\r\n        /* Check the fee period rollover within this as the price should be pushed every 15min. */\r\n        rolloverFeePeriodIfElapsed();\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the price of havvens hasn't been updated for longer than the stale period.\r\n     */\r\n    function priceIsStale()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return safeAdd(lastPriceUpdateTime, priceStalePeriod) < now;\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier requireIssuer(address account)\r\n    {\r\n        require(isIssuer[account], \"Must be issuer to perform this action\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracle\r\n    {\r\n        require(msg.sender == oracle, \"Must be oracle to perform this action\");\r\n        _;\r\n    }\r\n\r\n    modifier priceNotStale\r\n    {\r\n        require(!priceIsStale(), \"Price must not be stale to perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event PriceUpdated(uint newPrice, uint timestamp);\r\n    bytes32 constant PRICEUPDATED_SIG = keccak256(\"PriceUpdated(uint256,uint256)\");\r\n    function emitPriceUpdated(uint newPrice, uint timestamp) internal {\r\n        proxy._emit(abi.encode(newPrice, timestamp), 1, PRICEUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event IssuanceRatioUpdated(uint newRatio);\r\n    bytes32 constant ISSUANCERATIOUPDATED_SIG = keccak256(\"IssuanceRatioUpdated(uint256)\");\r\n    function emitIssuanceRatioUpdated(uint newRatio) internal {\r\n        proxy._emit(abi.encode(newRatio), 1, ISSUANCERATIOUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event FeePeriodRollover(uint timestamp);\r\n    bytes32 constant FEEPERIODROLLOVER_SIG = keccak256(\"FeePeriodRollover(uint256)\");\r\n    function emitFeePeriodRollover(uint timestamp) internal {\r\n        proxy._emit(abi.encode(timestamp), 1, FEEPERIODROLLOVER_SIG, 0, 0, 0);\r\n    } \r\n\r\n    event FeePeriodDurationUpdated(uint duration);\r\n    bytes32 constant FEEPERIODDURATIONUPDATED_SIG = keccak256(\"FeePeriodDurationUpdated(uint256)\");\r\n    function emitFeePeriodDurationUpdated(uint duration) internal {\r\n        proxy._emit(abi.encode(duration), 1, FEEPERIODDURATIONUPDATED_SIG, 0, 0, 0);\r\n    } \r\n\r\n    event FeesWithdrawn(address indexed account, uint value);\r\n    bytes32 constant FEESWITHDRAWN_SIG = keccak256(\"FeesWithdrawn(address,uint256)\");\r\n    function emitFeesWithdrawn(address account, uint value) internal {\r\n        proxy._emit(abi.encode(value), 2, FEESWITHDRAWN_SIG, bytes32(account), 0, 0);\r\n    }\r\n\r\n    event OracleUpdated(address newOracle);\r\n    bytes32 constant ORACLEUPDATED_SIG = keccak256(\"OracleUpdated(address)\");\r\n    function emitOracleUpdated(address newOracle) internal {\r\n        proxy._emit(abi.encode(newOracle), 1, ORACLEUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event NominUpdated(address newNomin);\r\n    bytes32 constant NOMINUPDATED_SIG = keccak256(\"NominUpdated(address)\");\r\n    function emitNominUpdated(address newNomin) internal {\r\n        proxy._emit(abi.encode(newNomin), 1, NOMINUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event EscrowUpdated(address newEscrow);\r\n    bytes32 constant ESCROWUPDATED_SIG = keccak256(\"EscrowUpdated(address)\");\r\n    function emitEscrowUpdated(address newEscrow) internal {\r\n        proxy._emit(abi.encode(newEscrow), 1, ESCROWUPDATED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event IssuersUpdated(address indexed account, bool indexed value);\r\n    bytes32 constant ISSUERSUPDATED_SIG = keccak256(\"IssuersUpdated(address,bool)\");\r\n    function emitIssuersUpdated(address account, bool value) internal {\r\n        proxy._emit(abi.encode(), 3, ISSUERSUPDATED_SIG, bytes32(account), bytes32(value ? 1 : 0), 0);\r\n    }\r\n\r\n}\r\n\r\n\r\n/*\r\n-----------------------------------------------------------------\r\nFILE INFORMATION -----------------------------------------------------------------\r\n\r\nfile:       IssuanceController.sol\r\nversion:    2.0\r\nauthor:     Kevin Brown\r\n\r\ndate:       2018-07-18\r\n\r\n-----------------------------------------------------------------\r\nMODULE DESCRIPTION\r\n-----------------------------------------------------------------\r\n\r\nIssuance controller contract. The issuance controller provides\r\na way for users to acquire nomins (Nomin.sol) and havvens\r\n(Havven.sol) by paying ETH and a way for users to acquire havvens\r\n(Havven.sol) by paying nomins. Users can also deposit their nomins\r\nand allow other users to purchase them with ETH. The ETH is sent\r\nto the user who offered their nomins for sale.\r\n\r\nThis smart contract contains a balance of each currency, and\r\nallows the owner of the contract (the Havven Foundation) to\r\nmanage the available balance of havven at their discretion, while\r\nusers are allowed to deposit and withdraw their own nomin deposits\r\nif they have not yet been taken up by another user.\r\n\r\n-----------------------------------------------------------------\r\n*/\r\n\r\n\r\n/**\r\n * @title Issuance Controller Contract.\r\n */\r\ncontract IssuanceController is SafeDecimalMath, SelfDestructible, Pausable {\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n    Havven public havven;\r\n    Nomin public nomin;\r\n\r\n    // Address where the ether raised is transfered to\r\n    address public fundsWallet;\r\n\r\n    /* The address of the oracle which pushes the USD price havvens and ether to this contract */\r\n    address public oracle;\r\n    /* Do not allow the oracle to submit times any further forward into the future than\r\n       this constant. */\r\n    uint constant ORACLE_FUTURE_LIMIT = 10 minutes;\r\n\r\n    /* How long will the contract assume the price of any asset is correct */\r\n    uint public priceStalePeriod = 3 hours;\r\n\r\n    /* The time the prices were last updated */\r\n    uint public lastPriceUpdateTime;\r\n    /* The USD price of havvens denominated in UNIT */\r\n    uint public usdToHavPrice;\r\n    /* The USD price of ETH denominated in UNIT */\r\n    uint public usdToEthPrice;\r\n    \r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _owner The owner of this contract.\r\n     * @param _fundsWallet The recipient of ETH and Nomins that are sent to this contract while exchanging.\r\n     * @param _havven The Havven contract we'll interact with for balances and sending.\r\n     * @param _nomin The Nomin contract we'll interact with for balances and sending.\r\n     * @param _oracle The address which is able to update price information.\r\n     * @param _usdToEthPrice The current price of ETH in USD, expressed in UNIT.\r\n     * @param _usdToHavPrice The current price of Havven in USD, expressed in UNIT.\r\n     */\r\n    constructor(\r\n        // Ownable\r\n        address _owner,\r\n\r\n        // Funds Wallet\r\n        address _fundsWallet,\r\n\r\n        // Other contracts needed\r\n        Havven _havven,\r\n        Nomin _nomin,\r\n\r\n        // Oracle values - Allows for price updates\r\n        address _oracle,\r\n        uint _usdToEthPrice,\r\n        uint _usdToHavPrice\r\n    )\r\n        /* Owned is initialised in SelfDestructible */\r\n        SelfDestructible(_owner)\r\n        Pausable(_owner)\r\n        public\r\n    {\r\n        fundsWallet = _fundsWallet;\r\n        havven = _havven;\r\n        nomin = _nomin;\r\n        oracle = _oracle;\r\n        usdToEthPrice = _usdToEthPrice;\r\n        usdToHavPrice = _usdToHavPrice;\r\n        lastPriceUpdateTime = now;\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set the funds wallet where ETH raised is held\r\n     * @param _fundsWallet The new address to forward ETH and Nomins to\r\n     */\r\n    function setFundsWallet(address _fundsWallet)\r\n        external\r\n        onlyOwner\r\n    {\r\n        fundsWallet = _fundsWallet;\r\n        emit FundsWalletUpdated(fundsWallet);\r\n    }\r\n    \r\n    /**\r\n     * @notice Set the Oracle that pushes the havven price to this contract\r\n     * @param _oracle The new oracle address\r\n     */\r\n    function setOracle(address _oracle)\r\n        external\r\n        onlyOwner\r\n    {\r\n        oracle = _oracle;\r\n        emit OracleUpdated(oracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Nomin contract that the issuance controller uses to issue Nomins.\r\n     * @param _nomin The new nomin contract target\r\n     */\r\n    function setNomin(Nomin _nomin)\r\n        external\r\n        onlyOwner\r\n    {\r\n        nomin = _nomin;\r\n        emit NominUpdated(_nomin);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Havven contract that the issuance controller uses to issue Havvens.\r\n     * @param _havven The new havven contract target\r\n     */\r\n    function setHavven(Havven _havven)\r\n        external\r\n        onlyOwner\r\n    {\r\n        havven = _havven;\r\n        emit HavvenUpdated(_havven);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the stale period on the updated price variables\r\n     * @param _time The new priceStalePeriod\r\n     */\r\n    function setPriceStalePeriod(uint _time)\r\n        external\r\n        onlyOwner \r\n    {\r\n        priceStalePeriod = _time;\r\n        emit PriceStalePeriodUpdated(priceStalePeriod);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n    /**\r\n     * @notice Access point for the oracle to update the prices of havvens / eth.\r\n     * @param newEthPrice The current price of ether in USD, specified to 18 decimal places.\r\n     * @param newHavvenPrice The current price of havvens in USD, specified to 18 decimal places.\r\n     * @param timeSent The timestamp from the oracle when the transaction was created. This ensures we don't consider stale prices as current in times of heavy network congestion.\r\n     */\r\n    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent)\r\n        external\r\n        onlyOracle\r\n    {\r\n        /* Must be the most recently sent price, but not too far in the future.\r\n         * (so we can't lock ourselves out of updating the oracle for longer than this) */\r\n        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, \r\n            \"Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT\");\r\n\r\n        usdToEthPrice = newEthPrice;\r\n        usdToHavPrice = newHavvenPrice;\r\n        lastPriceUpdateTime = timeSent;\r\n\r\n        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Fallback function (exchanges ETH to nUSD)\r\n     */\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        exchangeEtherForNomins();\r\n    } \r\n\r\n    /**\r\n     * @notice Exchange ETH to nUSD.\r\n     */\r\n    function exchangeEtherForNomins()\r\n        public \r\n        payable\r\n        pricesNotStale\r\n        notPaused\r\n        returns (uint) // Returns the number of Nomins (nUSD) received\r\n    {\r\n        // The multiplication works here because usdToEthPrice is specified in\r\n        // 18 decimal places, just like our currency base.\r\n        uint requestedToPurchase = safeMul_dec(msg.value, usdToEthPrice);\r\n\r\n        // Store the ETH in our funds wallet\r\n        fundsWallet.transfer(msg.value);\r\n\r\n        // Send the nomins.\r\n        // Note: Fees are calculated by the Nomin contract, so when \r\n        //       we request a specific transfer here, the fee is\r\n        //       automatically deducted and sent to the fee pool.\r\n        nomin.transfer(msg.sender, requestedToPurchase);\r\n\r\n        emit Exchange(\"ETH\", msg.value, \"nUSD\", requestedToPurchase);\r\n\r\n        return requestedToPurchase;\r\n    }\r\n\r\n    /**\r\n     * @notice Exchange ETH to nUSD while insisting on a particular rate. This allows a user to\r\n     *         exchange while protecting against frontrunning by the contract owner on the exchange rate.\r\n     * @param guaranteedRate The exchange rate (ether price) which must be honored or the call will revert.\r\n     */\r\n    function exchangeEtherForNominsAtRate(uint guaranteedRate)\r\n        public\r\n        payable\r\n        pricesNotStale\r\n        notPaused\r\n        returns (uint) // Returns the number of Nomins (nUSD) received\r\n    {\r\n        require(guaranteedRate == usdToEthPrice);\r\n\r\n        return exchangeEtherForNomins();\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Exchange ETH to HAV.\r\n     */\r\n    function exchangeEtherForHavvens()\r\n        public \r\n        payable\r\n        pricesNotStale\r\n        notPaused\r\n        returns (uint) // Returns the number of Havvens (HAV) received\r\n    {\r\n        // How many Havvens are they going to be receiving?\r\n        uint havvensToSend = havvensReceivedForEther(msg.value);\r\n\r\n        // Store the ETH in our funds wallet\r\n        fundsWallet.transfer(msg.value);\r\n\r\n        // And send them the Havvens.\r\n        havven.transfer(msg.sender, havvensToSend);\r\n\r\n        emit Exchange(\"ETH\", msg.value, \"HAV\", havvensToSend);\r\n\r\n        return havvensToSend;\r\n    }\r\n\r\n    /**\r\n     * @notice Exchange ETH to HAV while insisting on a particular set of rates. This allows a user to\r\n     *         exchange while protecting against frontrunning by the contract owner on the exchange rates.\r\n     * @param guaranteedEtherRate The ether exchange rate which must be honored or the call will revert.\r\n     * @param guaranteedHavvenRate The havven exchange rate which must be honored or the call will revert.\r\n     */\r\n    function exchangeEtherForHavvensAtRate(uint guaranteedEtherRate, uint guaranteedHavvenRate)\r\n        public\r\n        payable\r\n        pricesNotStale\r\n        notPaused\r\n        returns (uint) // Returns the number of Havvens (HAV) received\r\n    {\r\n        require(guaranteedEtherRate == usdToEthPrice);\r\n        require(guaranteedHavvenRate == usdToHavPrice);\r\n\r\n        return exchangeEtherForHavvens();\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Exchange nUSD for Havvens\r\n     * @param nominAmount The amount of nomins the user wishes to exchange.\r\n     */\r\n    function exchangeNominsForHavvens(uint nominAmount)\r\n        public \r\n        pricesNotStale\r\n        notPaused\r\n        returns (uint) // Returns the number of Havvens (HAV) received\r\n    {\r\n        // How many Havvens are they going to be receiving?\r\n        uint havvensToSend = havvensReceivedForNomins(nominAmount);\r\n        \r\n        // Ok, transfer the Nomins to our address.\r\n        nomin.transferFrom(msg.sender, this, nominAmount);\r\n\r\n        // And send them the Havvens.\r\n        havven.transfer(msg.sender, havvensToSend);\r\n\r\n        emit Exchange(\"nUSD\", nominAmount, \"HAV\", havvensToSend);\r\n\r\n        return havvensToSend; \r\n    }\r\n\r\n    /**\r\n     * @notice Exchange nUSD for Havvens while insisting on a particular rate. This allows a user to\r\n     *         exchange while protecting against frontrunning by the contract owner on the exchange rate.\r\n     * @param nominAmount The amount of nomins the user wishes to exchange.\r\n     * @param guaranteedRate A rate (havven price) the caller wishes to insist upon.\r\n     */\r\n    function exchangeNominsForHavvensAtRate(uint nominAmount, uint guaranteedRate)\r\n        public \r\n        pricesNotStale\r\n        notPaused\r\n        returns (uint) // Returns the number of Havvens (HAV) received\r\n    {\r\n        require(guaranteedRate == usdToHavPrice);\r\n\r\n        return exchangeNominsForHavvens(nominAmount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Allows the owner to withdraw havvens from this contract if needed.\r\n     * @param amount The amount of havvens to attempt to withdraw (in 18 decimal places).\r\n     */\r\n    function withdrawHavvens(uint amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        havven.transfer(owner, amount);\r\n        \r\n        // We don't emit our own events here because we assume that anyone\r\n        // who wants to watch what the Issuance Controller is doing can\r\n        // just watch ERC20 events from the Nomin and/or Havven contracts\r\n        // filtered to our address.\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw nomins: Allows the owner to withdraw nomins from this contract if needed.\r\n     * @param amount The amount of nomins to attempt to withdraw (in 18 decimal places).\r\n     */\r\n    function withdrawNomins(uint amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        nomin.transfer(owner, amount);\r\n        \r\n        // We don't emit our own events here because we assume that anyone\r\n        // who wants to watch what the Issuance Controller is doing can\r\n        // just watch ERC20 events from the Nomin and/or Havven contracts\r\n        // filtered to our address.\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n    /**\r\n     * @notice Check if the prices haven't been updated for longer than the stale period.\r\n     */\r\n    function pricesAreStale()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return safeAdd(lastPriceUpdateTime, priceStalePeriod) < now;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate how many havvens you will receive if you transfer\r\n     *         an amount of nomins.\r\n     * @param amount The amount of nomins (in 18 decimal places) you want to ask about\r\n     */\r\n    function havvensReceivedForNomins(uint amount)\r\n        public \r\n        view\r\n        returns (uint)\r\n    {\r\n        // How many nomins would we receive after the transfer fee?\r\n        uint nominsReceived = nomin.amountReceived(amount);\r\n\r\n        // And what would that be worth in havvens based on the current price?\r\n        return safeDiv_dec(nominsReceived, usdToHavPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate how many havvens you will receive if you transfer\r\n     *         an amount of ether.\r\n     * @param amount The amount of ether (in wei) you want to ask about\r\n     */\r\n    function havvensReceivedForEther(uint amount)\r\n        public \r\n        view\r\n        returns (uint)\r\n    {\r\n        // How much is the ETH they sent us worth in nUSD (ignoring the transfer fee)?\r\n        uint valueSentInNomins = safeMul_dec(amount, usdToEthPrice); \r\n\r\n        // Now, how many HAV will that USD amount buy?\r\n        return havvensReceivedForNomins(valueSentInNomins);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate how many nomins you will receive if you transfer\r\n     *         an amount of ether.\r\n     * @param amount The amount of ether (in wei) you want to ask about\r\n     */\r\n    function nominsReceivedForEther(uint amount)\r\n        public \r\n        view\r\n        returns (uint)\r\n    {\r\n        // How many nomins would that amount of ether be worth?\r\n        uint nominsTransferred = safeMul_dec(amount, usdToEthPrice);\r\n\r\n        // And how many of those would you receive after a transfer (deducting the transfer fee)\r\n        return nomin.amountReceived(nominsTransferred);\r\n    }\r\n    \r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyOracle\r\n    {\r\n        require(msg.sender == oracle, \"Must be oracle to perform this action\");\r\n        _;\r\n    }\r\n\r\n    modifier pricesNotStale\r\n    {\r\n        require(!pricesAreStale(), \"Prices must not be stale to perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event FundsWalletUpdated(address newFundsWallet);\r\n    event OracleUpdated(address newOracle);\r\n    event NominUpdated(Nomin newNominContract);\r\n    event HavvenUpdated(Havven newHavvenContract);\r\n    event PriceStalePeriodUpdated(uint priceStalePeriod);\r\n    event PricesUpdated(uint newEthPrice, uint newHavvenPrice, uint timeSent);\r\n    event Exchange(string fromCurrency, uint fromAmount, string toCurrency, uint toAmount);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initiationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawHavvens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"havvensReceivedForEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setSelfDestructBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceStalePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setPriceStalePeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nominAmount\",\"type\":\"uint256\"},{\"name\":\"guaranteedRate\",\"type\":\"uint256\"}],\"name\":\"exchangeNominsForHavvensAtRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminateSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricesAreStale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newEthPrice\",\"type\":\"uint256\"},{\"name\":\"newHavvenPrice\",\"type\":\"uint256\"},{\"name\":\"timeSent\",\"type\":\"uint256\"}],\"name\":\"updatePrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeEtherForHavvens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeEtherForNomins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nominAmount\",\"type\":\"uint256\"}],\"name\":\"exchangeNominsForHavvens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPriceUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_havven\",\"type\":\"address\"}],\"name\":\"setHavven\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"havvensReceivedForNomins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nomin\",\"type\":\"address\"}],\"name\":\"setNomin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guaranteedRate\",\"type\":\"uint256\"}],\"name\":\"exchangeEtherForNominsAtRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundsWallet\",\"type\":\"address\"}],\"name\":\"setFundsWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"havven\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELFDESTRUCT_DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"nominsReceivedForEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructInitiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdToEthPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guaranteedEtherRate\",\"type\":\"uint256\"},{\"name\":\"guaranteedHavvenRate\",\"type\":\"uint256\"}],\"name\":\"exchangeEtherForHavvensAtRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initiateSelfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdToHavPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nomin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawNomins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_fundsWallet\",\"type\":\"address\"},{\"name\":\"_havven\",\"type\":\"address\"},{\"name\":\"_nomin\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_usdToEthPrice\",\"type\":\"uint256\"},{\"name\":\"_usdToHavPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFundsWallet\",\"type\":\"address\"}],\"name\":\"FundsWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newNominContract\",\"type\":\"address\"}],\"name\":\"NominUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newHavvenContract\",\"type\":\"address\"}],\"name\":\"HavvenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"priceStalePeriod\",\"type\":\"uint256\"}],\"name\":\"PriceStalePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newEthPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newHavvenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeSent\",\"type\":\"uint256\"}],\"name\":\"PricesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromCurrency\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toCurrency\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SelfDestructTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selfDestructDelay\",\"type\":\"uint256\"}],\"name\":\"SelfDestructInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructBeneficiaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"IssuanceController","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b0a23f40de7f776a4f20153e8995ed3e7d7c8487000000000000000000000000a15184a8c8c3f47a8b54572cdccb30358abfb7a1000000000000000000000000d989a04ad891528b571ef73dacaefeb0402a65b300000000000000000000000092812526ebc2f4df9e0b77db74da0803b8f023fa000000000000000000000000ac1ed4fabbd5204e02950d68b6fc8c446ac9536200000000000000000000000000000000000000000000000f6d340be38a6c1ae00000000000000000000000000000000000000000000000000161d3ac8dd65b2a","Library":"","SwarmSource":"bzzr://a4e86388d15ff16b6d552a05035ccc99d730bb042a1eafe4dca23a50b010c895"}]}