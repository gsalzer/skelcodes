{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n *\r\n *                                ...........       ...........\r\n *                           .....                              t...\r\n *                          TT..                                  ..T.\r\n *                       TUx.                                        .TT\r\n *                       .XtTT......                          ....TTtXXT\r\n *                        UT..  ....                                 XU.\r\n *                        Tt .                                      TUX.\r\n *                        TXT..                  ..                .UU.\r\n *                        .UU T.                 ....              TXT\r\n *                         tX...                   T.. .           UX.\r\n *                         TXT..      .             ......        .UU\r\n *                         TUU..     TT.           ..    ..       TXx\r\n *                         xtUT..     ....uUXUXXUT...    ..       UXT\r\n *                          Utx .       TXUXXXXXUXU. .....       .UU\r\n *                          tUt .       XXtTXUUXuUXU      .      TXx\r\n *                          TXt..       XX .tXT. uXX   ....      UXT\r\n *                          uUUT .      TX.     .XXX.   ..  . . .XUx\r\n *                           Utx .T.  . .X...... XUXu      .... .XTx\r\n *                           uxu ..xT. TXT        XUXt.   . .   TXT.\r\n *                           Txt . TXXUXT .        UXXXt        tXt.\r\n *                           uUx  XUXXXUXUXx      XUUUXUXT... . Uxx\r\n *                            Xt  .XUXUXXXX.  .x.tUXUXXXXT.Tu.  .Tu\r\n *                            tx.  .XxXXt.  .  x............x. ..TX.\r\n *                            TT.....  .  .txt x   rm-rf/  .x.. .Tt\r\n *                            xTT. ... . TUUU..x ...........x.. .Tt\r\n *                             xT........ .UXTTTT.TTxTTTTTTut...Tx\r\n *                             ttt..........xTTxTTTuxxuxTTTTTu. Tt\r\n *                             uUt........  .................. .T\r\n *                              Xxtt........     ....    . ....Tt\r\n *                               xxuU... .     .       . . tttUu\r\n *                                 UTuut                uuuUu..\r\n *                                   T...................TT..\r\n *\r\n *\r\n *\r\n * @title CCCosmos SAT\r\n *  \r\n * The only official website: https://cccosmos.com\r\n * \r\n *     CCCosmos is a game Dapp that runs on Ethereum. The mode of smart contract makes it run in a decentralized way. \r\n * Code logic prevents any others' control and keep the game fun, fair, and feasible. Unlike most DApps that require a browser\r\n * plug-in, the well-designed CCCosmos can easily help you win great bonuses via any decentralized Ethereum wallet \r\n * on your phone.\r\n *   \r\n *                                        ///Game Description///\r\n * # The first-time user can activate his/her Ethereum address by just paying an amount more than 0.01eth.\r\n * \r\n * # The contract will automatically calculate the user's SAT account according to the price, and may immediately \r\n * receive up to seven-fold rewards.\r\n * \r\n * # Holding SAT brings users continuous earnings; if you are the last one to get SAT at the end of the game, you \r\n * will win the huge sum in the final pot!\r\n * \r\n * # Final Prize\r\n * As the game countdown ends, the last SAT buyer will win the Final Pot.\r\n * \r\n * # Early Birds\r\n * Whenever a player buys SAT, the SAT price goes up; the early birds would get rich earnings.\r\n * \r\n * # Late Surprise\r\n * SAT buyers will have the chance to win multiplied rewards in betting; later users may win more eths.\r\n * \r\n * # Be Dealers\r\n * The top three users holding the most SATs are dealers who will continuously receive dealer funds for the day.\r\n * \r\n * # Happy Ending\r\n * After the game is over, all users will divide up the whole prize pot to win bonuses, and then a new round of \r\n * game starts.\r\n * \r\n *                                              ///Rules///\r\n * 1. The countdown to the end is initially set to be 24 hours. Whenever a user buys a SAT, the remaining time will \r\n * be extended by 30 seconds; but the total extension will not exceed 24 hours.\r\n * \r\n * 2. Any amount of eth a user transfers to the contract address, with 0.01 eth deducted for activation fee, can be \r\n * used to buy SAT. The remaining sum of SAT can be checked in any Ethereum wallet.\r\n * \r\n * 3. The initial SAT price is 0.000088eth, and the price will increase by 0.000000002eth for every SAT purchased.\r\n * \r\n * 4. All eths the users spent on SAT are put into the prize pot, 50% of which enters the Share Pot, 20% the Final \r\n * Pot, 25.5% the Lucky Pot, and the rest 4.5% the Dealer Pot.\r\n * \r\n * 5. When users transfer a certain amount of SAT to the contract address, the corresponding response function \r\n * will be triggered and then the transferred SAT will be refunded in full.\r\n * \r\n *    # To get all the eth gains earned at your address by transferring back 0.08 SAT.\r\n * \r\n *    # To make an instant re-investment and buy SAT with all eth gains earned at your address by transferring \r\n *      back 0.01 SAT.\r\n * \r\n *    # After the game is over, you can get all the eth gains earned at your address by transferring back any \r\n *      amount of SAT.\r\n * \r\n *    # The average withdrawal rate is less than 7.5% and decreases as the total SAT issuance increases. When the \r\n *      SAT price reaches 0.1eth, zero-fee is charged!\r\n * \r\n * 6. Users have a 50% chance to get instant rewards in different proportions, maximally seven-fold, after they buy \r\n * SAT immediately.! (The maximum amount of the rewards cannot exceed 1/2 of the current lucky pot.)\r\n * \r\n *                             Probability of Winning Rewards\r\n * \r\n *                          Reward ratio           probability\r\n *                               10%                   30%\r\n *                               20%                   10%\r\n *                               50%                   5%\r\n *                               100%                  3%\r\n *                               300%                  2%\r\n *                               700%                  1%\r\n * \r\n * 7. Users can log into cccosmos.com to check the earnings and get other detailed information.\r\n * \r\n * 8. The top three Ethereum addresses with the most SAT purchase for the day will divide up the present Dealer \r\n *    Fund!\r\n * \r\n * 9. One month after the game ends, the unclaimed eths will be automatically transferred to the CCCosmos \r\n *    Developer Fund for subsequent development and services.\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Saturn\r\n * @dev The Saturn token.\r\n */\r\ncontract Saturn is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Player {\r\n        uint256 pid; // player ID, start with 1\r\n        uint256 ethTotal; // total buy amount in ETH\r\n        uint256 ethBalance; // the ETH balance which can be withdraw\r\n        uint256 ethWithdraw; // total eth which has already been withdrawn by player\r\n        uint256 ethShareWithdraw; // total shared pot which has already been withdrawn by player\r\n        uint256 tokenBalance; // token balance\r\n        uint256 tokenDay; // the day which player last buy\r\n        uint256 tokenDayBalance; // the token balance for last day\r\n    }\r\n\r\n    struct LuckyRecord {\r\n        address player; // player address\r\n        uint256 amount; // lucky reward amount\r\n        uint64 txId; // tx ID\r\n        uint64 time; // lucky reward time\r\n        // lucky reward level.\r\n        // reward amount: 1: 700%, 2: 300%, 3: 100%, 4: 50%, 5: 20%, 6: 10%\r\n        // reward chance: 1: 1%, 2: 2%, 3: 3%, 4: 5%, 5: 10%, 6: 30%\r\n        uint64 level;\r\n    }\r\n\r\n    // Keep lucky player which is pending for reward after next block\r\n    struct LuckyPending {\r\n        address player; // player address\r\n        uint256 amount; // player total eth for this tx\r\n        uint64 txId; // tx id\r\n        uint64 block; // current block number\r\n        uint64 level; // lucky level\r\n    }\r\n\r\n    struct InternalBuyEvent {\r\n        // flag1\r\n        // 0 - new player (bool)\r\n        // 1-20 - tx ID\r\n        // 21-31 - finish time\r\n        // 32-46 - dealer1 ID\r\n        // 47-61 - dealer2 ID\r\n        // 62-76 - dealer3 ID\r\n        uint256 flag1;\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Buy(\r\n        address indexed _token, address indexed _player, uint256 _amount, uint256 _total,\r\n        uint256 _totalSupply, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot,\r\n        uint256 _price, uint256 _flag1\r\n    );\r\n    event Withdraw(address indexed _token, address indexed _player, uint256 _amount);\r\n    event Win(address indexed _token, address indexed _winner, uint256 _winAmount);\r\n\r\n    string constant public name = \"Saturn\";\r\n    string constant public symbol = \"SAT\";\r\n    uint8 constant public decimals = 18;\r\n\r\n    uint256 constant private FEE_REGISTER_ACCOUNT = 10 finney; // register fee per player\r\n    uint256 constant private BUY_AMOUNT_MIN = 1000000000; // buy token minimal ETH\r\n    uint256 constant private BUY_AMOUNT_MAX = 100000000000000000000000; // buy token maximal ETH\r\n    uint256 constant private TIME_DURATION_INCREASE = 30 seconds; // time increased by each token\r\n    uint256 constant private TIME_DURATION_MAX = 24 hours; // max duration for game\r\n    uint256 constant private ONE_TOKEN = 1000000000000000000; // one token which is 10^18\r\n\r\n    mapping(address => Player) public playerOf; // player address => player info\r\n    mapping(uint256 => address) public playerIdOf; // player id => player address\r\n    uint256 public playerCount; // total player\r\n\r\n    uint256 public totalSupply; // token total supply\r\n\r\n    uint256 public totalPot; // total eth which players bought\r\n    uint256 public sharePot; // shared pot for all players\r\n    uint256 public finalPot; // final win pot for winner (last player)\r\n    uint256 public luckyPot; // lucky pot based on random number.\r\n\r\n    uint64 public txCount; // total transaction\r\n    uint256 public finishTime; // game finish time. It will be set startTime+24 hours when activate the contract.\r\n    uint256 public startTime; // the game is activated when now>=startTime.\r\n\r\n    address public lastPlayer; // last player which by at least one key.\r\n    address public winner; // winner for final pot.\r\n    uint256 public winAmount; // win amount for winner, which will be final pot.\r\n\r\n    uint256 public price; // token price\r\n\r\n    address[3] public dealers; // top 3 token owners for daily. Dealers will be reset every midnight (00:00) UTC±00:00\r\n    uint256 public dealerDay; // The midnight time in UTC±00:00 which last player bought the token (without hour, minute, second)\r\n\r\n    LuckyPending[] public luckyPendings;\r\n    uint256 public luckyPendingIndex;\r\n    LuckyRecord[] public luckyRecords; // The lucky player history.\r\n\r\n    address public feeOwner; // fee owner. all fee will be send to this address.\r\n    uint256 public feeAmount; // current fee amount. new fee will be added to it.\r\n\r\n    // withdraw fee price levels.\r\n    uint64[16] public feePrices = [uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];\r\n    // withdraw fee percent. if feePrices[i]<=current price<feePrices[i + 1], then the withdraw fee will be (feePercents[i]/1000)*withdrawAmount\r\n    uint8[16] public feePercents = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];\r\n    // current withdraw fee index. it will be updated when player buy token\r\n    uint256 public feeIndex;\r\n\r\n    /**\r\n    * @dev Init the contract with fee owner. the game is not ready before activate function is called.\r\n    * Token total supply will be 0.\r\n    */\r\n    constructor(uint256 _startTime, address _feeOwner) public {\r\n        require(_startTime >= now && _feeOwner != address(0));\r\n        startTime = _startTime;\r\n        finishTime = _startTime + TIME_DURATION_MAX;\r\n        totalSupply = 0;\r\n        price = 88000000000000;\r\n        feeOwner = _feeOwner;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if game is not ready\r\n     */\r\n    modifier isActivated() {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if sender is not account (contract etc.).\r\n     * This is not 100% guarantee that the caller is account (ie after account abstraction is implemented), but it is good enough.\r\n     */\r\n    modifier isAccount() {\r\n        address _address = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_address)}\r\n        require(_codeLength == 0 && tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Token balance for player\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return playerOf[_owner].tokenBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Get lucky pending size\r\n     */\r\n    function getLuckyPendingSize() public view returns (uint256) {\r\n        return luckyPendings.length;\r\n    }\r\n    /**\r\n     * @dev Get lucky record size\r\n     */\r\n    function getLuckyRecordSize() public view returns (uint256) {\r\n        return luckyRecords.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the game info\r\n     */\r\n    function getGameInfo() public view returns (\r\n        uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price,\r\n        uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent\r\n    ) {\r\n        _balance = address(this).balance;\r\n        _totalPot = totalPot;\r\n        _sharePot = sharePot;\r\n        _finalPot = finalPot;\r\n        _luckyPot = luckyPot;\r\n        _rewardPot = _sharePot;\r\n        uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot);\r\n        if (_totalPot > _withdraw) {\r\n            _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw));\r\n        }\r\n        _price = price;\r\n        _totalSupply = totalSupply;\r\n        _now = now;\r\n        _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex];\r\n        if (now < finishTime) {\r\n            _timeLeft = finishTime - now;\r\n        } else {\r\n            _timeLeft = 0;\r\n            _winner = winner != address(0) ? winner : lastPlayer;\r\n            _winAmount = winner != address(0) ? winAmount : finalPot;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the player info by address\r\n     */\r\n    function getPlayerInfo(address _playerAddress) public view returns (\r\n        uint256 _pid, uint256 _ethTotal, uint256 _ethBalance, uint256 _ethWithdraw,\r\n        uint256 _tokenBalance, uint256 _tokenDayBalance\r\n    ) {\r\n        Player storage _player = playerOf[_playerAddress];\r\n        if (_player.pid > 0) {\r\n            _pid = _player.pid;\r\n            _ethTotal = _player.ethTotal;\r\n            uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\r\n            _ethBalance = _player.ethBalance;\r\n            if (_sharePot > _player.ethShareWithdraw) {\r\n                _ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw));\r\n            }\r\n            _ethWithdraw = _player.ethWithdraw;\r\n            _tokenBalance = _player.tokenBalance;\r\n            uint256 _day = (now / 86400) * 86400;\r\n            if (_player.tokenDay == _day) {\r\n                _tokenDayBalance = _player.tokenDayBalance;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get dealer and lucky records\r\n     */\r\n    function getDealerAndLuckyInfo(uint256 _luckyOffset) public view returns (\r\n        address[3] _dealerPlayers, uint256[3] _dealerDayTokens, uint256[3] _dealerTotalTokens,\r\n        address[5] _luckyPlayers, uint256[5] _luckyAmounts, uint256[5] _luckyLevels, uint256[5] _luckyTimes\r\n    ) {\r\n        uint256 _day = (now / 86400) * 86400;\r\n        if (dealerDay == _day) {\r\n            for (uint256 _i = 0; _i < 3; ++_i) {\r\n                if (dealers[_i] != address(0)) {\r\n                    Player storage _player = playerOf[dealers[_i]];\r\n                    _dealerPlayers[_i] = dealers[_i];\r\n                    _dealerDayTokens[_i] = _player.tokenDayBalance;\r\n                    _dealerTotalTokens[_i] = _player.tokenBalance;\r\n                }\r\n            }\r\n        }\r\n        uint256 _size = _luckyOffset >= luckyRecords.length ? 0 : luckyRecords.length - _luckyOffset;\r\n        if (_luckyPlayers.length < _size) {\r\n            _size = _luckyPlayers.length;\r\n        }\r\n        for (_i = 0; _i < _size; ++_i) {\r\n            LuckyRecord memory _record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i];\r\n            _luckyPlayers[_i] = _record.player;\r\n            _luckyAmounts[_i] = _record.amount;\r\n            _luckyLevels[_i] = _record.level;\r\n            _luckyTimes[_i] = _record.time;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw the balance and share pot.\r\n    *\r\n    * Override ERC20 transfer token function. This token is not allowed to transfer between players.\r\n    * So the _to address must be the contract address.\r\n    * 1. When game already finished: Player can send any amount of token to contract, and the contract will send the eth balance and share pot to player.\r\n    * 2. When game is not finished yet:\r\n    *    A. Withdraw. Player send 0.08 Token to contract, and the contract will send the eth balance and share pot to player.\r\n    *    B. ReBuy. Player send 0.01 Token to contract, then player's eth balance and share pot will be used to buy token.\r\n    *    C. Invalid. Other value is invalid.\r\n    * @param _to address The address which you want to transfer/sell to. MUST be contract address.\r\n    * @param _value uint256 the amount of tokens to be transferred/sold.\r\n    */\r\n    function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\r\n        require(_to == address(this));\r\n        Player storage _player = playerOf[msg.sender];\r\n        require(_player.pid > 0);\r\n        if (now >= finishTime) {\r\n            if (winner == address(0)) {\r\n                // If the endGame is not called, then call it.\r\n                endGame();\r\n            }\r\n            // Player want to withdraw.\r\n            _value = 80000000000000000;\r\n        } else {\r\n            // Only withdraw or rebuy allowed.\r\n            require(_value == 80000000000000000 || _value == 10000000000000000);\r\n        }\r\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\r\n        uint256 _eth = 0;\r\n        // the total share pot need to sub amount which already be withdrawn by player.\r\n        if (_sharePot > _player.ethShareWithdraw) {\r\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\r\n            _player.ethShareWithdraw = _sharePot;\r\n        }\r\n        // add the player's eth balance\r\n        _eth = _eth.add(_player.ethBalance);\r\n        _player.ethBalance = 0;\r\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\r\n        if (_value == 80000000000000000) {\r\n            // Player want to withdraw\r\n            // Calculate fee based on price level.\r\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\r\n            if (_fee > 0) {\r\n                feeAmount = feeAmount.add(_fee);\r\n                _eth = _eth.sub(_fee);\r\n            }\r\n            sendFeeIfAvailable();\r\n            msg.sender.transfer(_eth);\r\n            emit Withdraw(_to, msg.sender, _eth);\r\n            emit Transfer(msg.sender, _to, 0);\r\n        } else {\r\n            // Player want to rebuy token\r\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\r\n                flag1: 0\r\n                });\r\n            buy(_player, _buyEvent, _eth);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Buy token using ETH\r\n    * Player sends ETH to this contract, then his token balance will be increased based on price.\r\n    * The total supply will also be increased.\r\n    * Player need 0.01 ETH register fee to register this address (first time buy).\r\n    * The buy amount need between 0.000000001ETH and 100000ETH\r\n    */\r\n    function() isActivated isAccount payable public {\r\n        uint256 _eth = msg.value;\r\n        require(now < finishTime);\r\n        InternalBuyEvent memory _buyEvent = InternalBuyEvent({\r\n            flag1: 0\r\n            });\r\n        Player storage _player = playerOf[msg.sender];\r\n        if (_player.pid == 0) {\r\n            // Register the player, make sure the eth is enough.\r\n            require(_eth >= FEE_REGISTER_ACCOUNT);\r\n            // Reward player BUY_AMOUNT_MIN for register. So the final register fee will be FEE_REGISTER_ACCOUNT-BUY_AMOUNT_MIN\r\n            uint256 _fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN);\r\n            _eth = _eth.sub(_fee);\r\n            // The register fee will go to fee owner\r\n            feeAmount = feeAmount.add(_fee);\r\n            playerCount = playerCount.add(1);\r\n            Player memory _p = Player({\r\n                pid: playerCount,\r\n                ethTotal: 0,\r\n                ethBalance: 0,\r\n                ethWithdraw: 0,\r\n                ethShareWithdraw: 0,\r\n                tokenBalance: 0,\r\n                tokenDay: 0,\r\n                tokenDayBalance: 0\r\n                });\r\n            playerOf[msg.sender] = _p;\r\n            playerIdOf[_p.pid] = msg.sender;\r\n            _player = playerOf[msg.sender];\r\n            // The player is newly register first time.\r\n            _buyEvent.flag1 += 1;\r\n        }\r\n        buy(_player, _buyEvent, _eth);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy the token\r\n     */\r\n    function buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\r\n        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\r\n        // Calculate the midnight\r\n        uint256 _day = (now / 86400) * 86400;\r\n        uint256 _backEth = 0;\r\n        uint256 _eth = _amount;\r\n        if (totalPot < 200000000000000000000) {\r\n            // If the totalPot<200ETH, we are allow to buy 5ETH each time.\r\n            if (_eth >= 5000000000000000000) {\r\n                // the other eth will add to player's ethBalance\r\n                _backEth = _eth.sub(5000000000000000000);\r\n                _eth = 5000000000000000000;\r\n            }\r\n        }\r\n        txCount = txCount + 1; // do not need use safe math\r\n        _buyEvent.flag1 += txCount * 10; // do not need use safe math\r\n        _player.ethTotal = _player.ethTotal.add(_eth);\r\n        totalPot = totalPot.add(_eth);\r\n        // Calculate the new total supply based on totalPot\r\n        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\r\n        // The player will get the token with totalSupply delta\r\n        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\r\n        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\r\n        // If the player buy token before today, then add the tokenDayBalance.\r\n        // otherwise reset tokenDayBalance\r\n        if (_player.tokenDay == _day) {\r\n            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\r\n        } else {\r\n            _player.tokenDay = _day;\r\n            _player.tokenDayBalance = _tokenAmount;\r\n        }\r\n        // Update the token price by new total supply\r\n        updatePrice(_newTotalSupply);\r\n        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\r\n        if (_backEth > 0) {\r\n            _player.ethBalance = _player.ethBalance.add(_backEth);\r\n        }\r\n        sendFeeIfAvailable();\r\n        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\r\n    }\r\n\r\n    /**\r\n     * @dev Handle the pot (share, final, lucky and dealer)\r\n     */\r\n    function handlePot(uint256 _day, uint256 _eth, uint256 _newTotalSupply, uint256 _tokenAmount, Player storage _player, InternalBuyEvent memory _buyEvent) private {\r\n        uint256 _sharePotDelta = _eth.div(2); // share pot: 50%\r\n        uint256 _finalPotDelta = _eth.div(5); // final pot: 20%;\r\n        uint256 _luckyPotDelta = _eth.mul(255).div(1000); // lucky pot: 25.5%;\r\n        uint256 _dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta); // dealer pot: 4.5%\r\n        sharePot = sharePot.add(_sharePotDelta);\r\n        finalPot = finalPot.add(_finalPotDelta);\r\n        luckyPot = luckyPot.add(_luckyPotDelta);\r\n        totalSupply = _newTotalSupply;\r\n        handleDealerPot(_day, _dealerPotDelta, _player, _buyEvent);\r\n        handleLuckyPot(_eth, _player);\r\n        // The player need to buy at least one token to change the finish time and last player.\r\n        if (_tokenAmount >= ONE_TOKEN) {\r\n            updateFinishTime(_tokenAmount);\r\n            lastPlayer = msg.sender;\r\n        }\r\n        _buyEvent.flag1 += finishTime * 1000000000000000000000; // do not need use safe math\r\n    }\r\n\r\n    /**\r\n     * @dev Handle lucky pot. The player can lucky pot by random number. The maximum amount will be half of total lucky pot\r\n     * The lucky reward will be added to player's eth balance\r\n     */\r\n    function handleLuckyPot(uint256 _eth, Player storage _player) private {\r\n        uint256 _seed = uint256(keccak256(abi.encodePacked(\r\n                (block.timestamp).add\r\n                (block.difficulty).add\r\n                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n                (block.gaslimit).add\r\n                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n                (block.number)\r\n            )));\r\n        _seed = _seed - ((_seed / 1000) * 1000);\r\n        uint64 _level = 0;\r\n        if (_seed < 227) { // 22.7%\r\n            _level = 1;\r\n        } else if (_seed < 422) { // 19.5%\r\n            _level = 2;\r\n        } else if (_seed < 519) { // 9.7%\r\n            _level = 3;\r\n        } else if (_seed < 600) { // 8.1%\r\n            _level = 4;\r\n        } else if (_seed < 700) { // 10%\r\n            _level = 5;\r\n        } else {  // 30%\r\n            _level = 6;\r\n        }\r\n        if (_level >= 5) {\r\n            // if level is 5 and 6, we will reward immediately\r\n            handleLuckyReward(txCount, _level, _eth, _player);\r\n        } else {\r\n            // otherwise we will save it for next block to check if it is reward or not\r\n            LuckyPending memory _pending = LuckyPending({\r\n                player: msg.sender,\r\n                amount: _eth,\r\n                txId: txCount,\r\n                block: uint64(block.number + 1),\r\n                level: _level\r\n                });\r\n            luckyPendings.push(_pending);\r\n        }\r\n        // handle the pending lucky reward\r\n        handleLuckyPending(_level >= 5 ? 0 : 1);\r\n    }\r\n\r\n    function handleLuckyPending(uint256 _pendingSkipSize) private {\r\n        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\r\n            LuckyPending storage _pending = luckyPendings[luckyPendingIndex];\r\n            if (_pending.block <= block.number) {\r\n                uint256 _seed = uint256(keccak256(abi.encodePacked(\r\n                        (block.timestamp).add\r\n                        (block.difficulty).add\r\n                        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n                        (block.gaslimit).add\r\n                        (block.number)\r\n                    )));\r\n                _seed = _seed - ((_seed / 1000) * 1000);\r\n                handleLucyPendingForOne(_pending, _seed);\r\n                if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\r\n                    _pending = luckyPendings[luckyPendingIndex];\r\n                    if (_pending.block <= block.number) {\r\n                        handleLucyPendingForOne(_pending, _seed);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function handleLucyPendingForOne(LuckyPending storage _pending, uint256 _seed) private {\r\n        luckyPendingIndex = luckyPendingIndex.add(1);\r\n        bool _reward = false;\r\n        if (_pending.level == 4) {\r\n            _reward = _seed < 617;\r\n        } else if (_pending.level == 3) {\r\n            _reward = _seed < 309;\r\n        } else if (_pending.level == 2) {\r\n            _reward = _seed < 102;\r\n        } else if (_pending.level == 1) {\r\n            _reward = _seed < 44;\r\n        }\r\n        if (_reward) {\r\n            handleLuckyReward(_pending.txId, _pending.level, _pending.amount, playerOf[_pending.player]);\r\n        }\r\n    }\r\n\r\n    function handleLuckyReward(uint64 _txId, uint64 _level, uint256 _eth, Player storage _player) private {\r\n        uint256 _amount;\r\n        if (_level == 1) {\r\n            _amount = _eth.mul(7); // 700%\r\n        } else if (_level == 2) {\r\n            _amount = _eth.mul(3); // 300%\r\n        } else if (_level == 3) {\r\n            _amount = _eth;        // 100%\r\n        } else if (_level == 4) {\r\n            _amount = _eth.div(2); // 50%\r\n        } else if (_level == 5) {\r\n            _amount = _eth.div(5); // 20%\r\n        } else if (_level == 6) {\r\n            _amount = _eth.div(10); // 10%\r\n        }\r\n        uint256 _maxPot = luckyPot.div(2);\r\n        if (_amount > _maxPot) {\r\n            _amount = _maxPot;\r\n        }\r\n        luckyPot = luckyPot.sub(_amount);\r\n        _player.ethBalance = _player.ethBalance.add(_amount);\r\n        LuckyRecord memory _record = LuckyRecord({\r\n            player: msg.sender,\r\n            amount: _amount,\r\n            txId: _txId,\r\n            level: _level,\r\n            time: uint64(now)\r\n            });\r\n        luckyRecords.push(_record);\r\n    }\r\n\r\n    /**\r\n     * @dev Handle dealer pot. The top 3 of total day token (daily) will get dealer reward.\r\n     * The dealer reward will be added to player's eth balance\r\n     */\r\n    function handleDealerPot(uint256 _day, uint256 _dealerPotDelta, Player storage _player, InternalBuyEvent memory _buyEvent) private {\r\n        uint256 _potUnit = _dealerPotDelta.div(dealers.length);\r\n        // If this is the first buy in today, then reset the dealers info.\r\n        if (dealerDay != _day || dealers[0] == address(0)) {\r\n            dealerDay = _day;\r\n            dealers[0] = msg.sender;\r\n            dealers[1] = address(0);\r\n            dealers[2] = address(0);\r\n            _player.ethBalance = _player.ethBalance.add(_potUnit);\r\n            feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit));\r\n            _buyEvent.flag1 += _player.pid * 100000000000000000000000000000000; // do not need safe math\r\n            return;\r\n        }\r\n        // Sort the dealers info by daily token balance.\r\n        for (uint256 _i = 0; _i < dealers.length; ++_i) {\r\n            if (dealers[_i] == address(0)) {\r\n                dealers[_i] = msg.sender;\r\n                break;\r\n            }\r\n            if (dealers[_i] == msg.sender) {\r\n                break;\r\n            }\r\n            Player storage _dealer = playerOf[dealers[_i]];\r\n            if (_dealer.tokenDayBalance < _player.tokenDayBalance) {\r\n                for (uint256 _j = dealers.length - 1; _j > _i; --_j) {\r\n                    if (dealers[_j - 1] != msg.sender) {\r\n                        dealers[_j] = dealers[_j - 1];\r\n                    }\r\n                }\r\n                dealers[_i] = msg.sender;\r\n                break;\r\n            }\r\n        }\r\n        // the all dealers share the dealer reward.\r\n        uint256 _fee = _dealerPotDelta;\r\n        for (_i = 0; _i < dealers.length; ++_i) {\r\n            if (dealers[_i] == address(0)) {\r\n                break;\r\n            }\r\n            _dealer = playerOf[dealers[_i]];\r\n            _dealer.ethBalance = _dealer.ethBalance.add(_potUnit);\r\n            _fee = _fee.sub(_potUnit);\r\n            _buyEvent.flag1 += _dealer.pid *\r\n            (_i == 0 ? 100000000000000000000000000000000 :\r\n            (_i == 1 ? 100000000000000000000000000000000000000000000000 :\r\n            (_i == 2 ? 100000000000000000000000000000000000000000000000000000000000000 : 0))); // do not need safe math, only keep top 3 dealers ID\r\n        }\r\n        if (_fee > 0) {\r\n            feeAmount = feeAmount.add(_fee);\r\n        }\r\n    }\r\n\r\n    function emitEndTxEvents(uint256 _eth, uint256 _tokenAmount, InternalBuyEvent memory _buyEvent) private {\r\n        emit Transfer(address(this), msg.sender, _tokenAmount);\r\n        emit Buy(\r\n            address(this), msg.sender, _eth, _tokenAmount,\r\n            totalSupply, totalPot, sharePot, finalPot, luckyPot,\r\n            price, _buyEvent.flag1\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev End the game.\r\n     */\r\n    function endGame() private {\r\n        // The fee owner will get the lucky pot, because no player will allow to buy the token.\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        // Set the winner information if it is not set.\r\n        // The winner reward will go to winner eth balance.\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update the finish time. each token will increase 30 seconds, up to 24 hours\r\n     */\r\n    function updateFinishTime(uint256 _tokenAmount) private {\r\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\r\n        uint256 _finishTime = finishTime.add(_timeDelta);\r\n        uint256 _maxTime = now.add(TIME_DURATION_MAX);\r\n        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\r\n    }\r\n\r\n    function updatePrice(uint256 _newTotalSupply) private {\r\n        price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000);\r\n        uint256 _idx = feeIndex + 1;\r\n        while (_idx < feePrices.length && price >= feePrices[_idx]) {\r\n            feeIndex = _idx;\r\n            ++_idx;\r\n        }\r\n    }\r\n\r\n    function calculateTotalSupply(uint256 _newTotalPot) private pure returns(uint256) {\r\n        return _newTotalPot.mul(10000000000000000000000000000)\r\n        .add(193600000000000000000000000000000000000000000000)\r\n        .sqrt()\r\n        .sub(440000000000000000000000);\r\n    }\r\n\r\n    function sendFeeIfAvailable() private {\r\n        if (feeAmount > 1000000000000000000) {\r\n            feeOwner.transfer(feeAmount);\r\n            feeAmount = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Change the fee owner.\r\n    *\r\n    * @param _feeOwner The new fee owner.\r\n    */\r\n    function changeFeeOwner(address _feeOwner) onlyOwner public {\r\n        require(_feeOwner != feeOwner && _feeOwner != address(0));\r\n        feeOwner = _feeOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw the fee. The owner can withdraw the money after 30 days of game finish.\r\n    * This prevents the money is not locked in this contract.\r\n    * Player can contact the contract owner to get back money if the money is withdrawn.\r\n    * @param _amount The amount which will be withdrawn.\r\n    */\r\n    function withdrawFee(uint256 _amount) onlyOwner public {\r\n        require(now >= finishTime.add(30 days));\r\n        if (winner == address(0)) {\r\n            endGame();\r\n        }\r\n        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\r\n        feeOwner.transfer(_amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"},{\"name\":\"_totalPot\",\"type\":\"uint256\"},{\"name\":\"_sharePot\",\"type\":\"uint256\"},{\"name\":\"_finalPot\",\"type\":\"uint256\"},{\"name\":\"_luckyPot\",\"type\":\"uint256\"},{\"name\":\"_rewardPot\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_now\",\"type\":\"uint256\"},{\"name\":\"_timeLeft\",\"type\":\"uint256\"},{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_winAmount\",\"type\":\"uint256\"},{\"name\":\"_feePercent\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feePercents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLuckyPendingSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_luckyOffset\",\"type\":\"uint256\"}],\"name\":\"getDealerAndLuckyInfo\",\"outputs\":[{\"name\":\"_dealerPlayers\",\"type\":\"address[3]\"},{\"name\":\"_dealerDayTokens\",\"type\":\"uint256[3]\"},{\"name\":\"_dealerTotalTokens\",\"type\":\"uint256[3]\"},{\"name\":\"_luckyPlayers\",\"type\":\"address[5]\"},{\"name\":\"_luckyAmounts\",\"type\":\"uint256[5]\"},{\"name\":\"_luckyLevels\",\"type\":\"uint256[5]\"},{\"name\":\"_luckyTimes\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"_pid\",\"type\":\"uint256\"},{\"name\":\"_ethTotal\",\"type\":\"uint256\"},{\"name\":\"_ethBalance\",\"type\":\"uint256\"},{\"name\":\"_ethWithdraw\",\"type\":\"uint256\"},{\"name\":\"_tokenBalance\",\"type\":\"uint256\"},{\"name\":\"_tokenDayBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeOwner\",\"type\":\"address\"}],\"name\":\"changeFeeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerIdOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sharePot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckyRecords\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"txId\",\"type\":\"uint64\"},{\"name\":\"time\",\"type\":\"uint64\"},{\"name\":\"level\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dealerDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyPendingIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckyPendings\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"txId\",\"type\":\"uint64\"},{\"name\":\"block\",\"type\":\"uint64\"},{\"name\":\"level\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLuckyRecordSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dealers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerOf\",\"outputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"ethTotal\",\"type\":\"uint256\"},{\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"name\":\"ethWithdraw\",\"type\":\"uint256\"},{\"name\":\"ethShareWithdraw\",\"type\":\"uint256\"},{\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"name\":\"tokenDay\",\"type\":\"uint256\"},{\"name\":\"tokenDayBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_feeOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_sharePot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_finalPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_luckyPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_flag1\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_winAmount\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Saturn","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005b7b8e4000000000000000000000000026084710f23e5dd055510c90995156b51220ca53","Library":"","SwarmSource":"bzzr://fa719dd45a251e11c4f23c615aaffe315049e747f6c0f3f3fecfd3bce65139ad"}]}