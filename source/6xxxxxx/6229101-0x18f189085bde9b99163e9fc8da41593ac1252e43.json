{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathLibrary {\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer module of two numbers, truncating the quotient.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner public {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    bool public paused = false;\r\n\r\n    event Pause();\r\n\r\n    event Unpause();\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract Operator is Ownable {\r\n    mapping(address => bool) public operators;\r\n\r\n    event OperatorAddressAdded(address addr);\r\n    event OperatorAddressRemoved(address addr);\r\n\r\n    /**\r\n     * @dev Throws if called by any account that's not operator.\r\n     */\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev add an address to the operators\r\n     * @param addr address\r\n     * @return true if the address was added to the operators, false if the address was already in the operators\r\n     */\r\n    function addAddressToOperators(address addr) onlyOwner public returns(bool success) {\r\n        if (!operators[addr]) {\r\n            operators[addr] = true;\r\n            emit OperatorAddressAdded(addr);\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev add addresses to the operators\r\n     * @param addrs addresses\r\n     * @return true if at least one address was added to the operators,\r\n     * false if all addresses were already in the operators\r\n     */\r\n    function addAddressesToOperators(address[] addrs) onlyOwner public returns(bool success) {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            if (addAddressToOperators(addrs[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address from the operators\r\n     * @param addr address\r\n     * @return true if the address was removed from the operators,\r\n     * false if the address wasn't in the operators in the first place\r\n     */\r\n    function removeAddressFromOperators(address addr) onlyOwner public returns(bool success) {\r\n        if (operators[addr]) {\r\n            operators[addr] = false;\r\n            emit OperatorAddressRemoved(addr);\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev remove addresses from the operators\r\n     * @param addrs addresses\r\n     * @return true if at least one address was removed from the operators,\r\n     * false if all addresses weren't in the operators in the first place\r\n     */\r\n    function removeAddressesFromOperators(address[] addrs) onlyOwner public returns(bool success) {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            if (removeAddressFromOperators(addrs[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Whitelist is Operator {\r\n    mapping(address => bool) public whitelist;\r\n\r\n    event WhitelistedAddressAdded(address addr);\r\n    event WhitelistedAddressRemoved(address addr);\r\n\r\n    /**\r\n     * @dev Throws if called by any account that's not whitelisted.\r\n     */\r\n    modifier onlyWhitelisted() {\r\n        require(whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev add an address to the whitelist\r\n     * @param addr address\r\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n     */\r\n    function addAddressToWhitelist(address addr) onlyOperator public returns(bool success) {\r\n        if (!whitelist[addr]) {\r\n            whitelist[addr] = true;\r\n            emit WhitelistedAddressAdded(addr);\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev add addresses to the whitelist\r\n     * @param addrs addresses\r\n     * @return true if at least one address was added to the whitelist,\r\n     * false if all addresses were already in the whitelist\r\n     */\r\n    function addAddressesToWhitelist(address[] addrs) onlyOperator public returns(bool success) {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            if (addAddressToWhitelist(addrs[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address from the whitelist\r\n     * @param addr address\r\n     * @return true if the address was removed from the whitelist,\r\n     * false if the address wasn't in the whitelist in the first place\r\n     */\r\n    function removeAddressFromWhitelist(address addr) onlyOperator public returns(bool success) {\r\n        if (whitelist[addr]) {\r\n            whitelist[addr] = false;\r\n            emit WhitelistedAddressRemoved(addr);\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev remove addresses from the whitelist\r\n     * @param addrs addresses\r\n     * @return true if at least one address was removed from the whitelist,\r\n     * false if all addresses weren't in the whitelist in the first place\r\n     */\r\n    function removeAddressesFromWhitelist(address[] addrs) onlyOperator public returns(bool success) {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            if (removeAddressFromWhitelist(addrs[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\ninterface Token {\r\n    function transferFrom(address from, address to, uint amount) external returns(bool);\r\n}\r\n\r\ncontract Crowdsale is Pausable, Whitelist {\r\n    using SafeMathLibrary for uint;\r\n\r\n    address private EMPTY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\r\n\r\n    Token public token;\r\n\r\n    address public beneficiary;\r\n    address public pool;\r\n    \r\n    uint internal decimals = 10 ** 18;\r\n\r\n    struct Funding {\r\n        address[] buyers;\r\n        address[] winners;\r\n        uint32 exchangeRatio;\r\n        uint8 minAccepting;\r\n        uint8 maxAccepting;\r\n        uint8 maxLotteryNumber;\r\n    }\r\n\r\n    struct BuyerStage {\r\n        uint8 funded;\r\n        bool lotteryBonusWon;\r\n        bool ultimateBonusWon;\r\n        bool bonusReleased;\r\n    }\r\n\r\n    struct Bonus {\r\n        uint32 buying;\r\n        uint32 lottery;\r\n        uint32 ultimate;\r\n    }\r\n\r\n    struct Stage {\r\n        Bonus bonus;\r\n        address[] buyers;\r\n        address[] winners;\r\n        address ultimateBonusWinner;\r\n        uint32 openingTime;\r\n        uint16 fundGoal;\r\n        uint16 fundRaised;\r\n        uint16 nextLotteryRaised;\r\n    }\r\n\r\n    Funding private funding;\r\n\r\n    mapping(address => mapping(uint8 => BuyerStage)) private buyers;\r\n\r\n    mapping(uint8 => Stage) private stages;\r\n\r\n    event BuyerFunded(address indexed buyer, uint8 stageIndex, uint8 amount);\r\n    event BuyerLotteryBonusWon(address indexed buyer, uint8 stageIndex, uint8 lotteryNumber, uint16 fundRaised);\r\n    event BuyerUltimateBonusWon(address indexed buyer, uint8 stageIndex);\r\n    event StageOpeningTimeSet(uint8 index);\r\n    event StageGoalReached(uint8 index);\r\n    event FinalGoalReached();\r\n\r\n    constructor (\r\n        address _tokenContractAddress,\r\n        address _beneficiary,\r\n        address _pool\r\n    ) public {\r\n        token = Token(_tokenContractAddress);\r\n        beneficiary = _beneficiary;\r\n        pool = _pool;\r\n\r\n        funding.exchangeRatio = 75000;\r\n        funding.minAccepting = 1;\r\n        funding.maxAccepting = 10;\r\n        funding.maxLotteryNumber = 9;\r\n\r\n        stages[1].openingTime = 1535500800;\r\n        stages[1].fundGoal = 3000;\r\n        stages[1].bonus.buying = 3600000; // 80%\r\n        stages[1].bonus.lottery = 450000; // 10%\r\n        stages[1].bonus.ultimate = 450000; // 10%\r\n\r\n        stages[2].fundGoal = 3000;\r\n        stages[2].bonus.buying = 2250000; // 50%\r\n        stages[2].bonus.lottery = 1125000; // 25%\r\n        stages[2].bonus.ultimate = 1125000; // 25%\r\n\r\n        stages[3].fundGoal = 3000;\r\n        stages[3].bonus.buying = 1350000; // 30%\r\n        stages[3].bonus.lottery = 1575000; // 35%\r\n        stages[3].bonus.ultimate = 1575000; // 35%\r\n\r\n        stages[4].fundGoal = 3000;\r\n        stages[4].bonus.buying = 0; // 0%\r\n        stages[4].bonus.lottery = 2250000; // 50%\r\n        stages[4].bonus.ultimate = 2250000; // 50%\r\n\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            stages[i].ultimateBonusWinner = EMPTY_ADDRESS;\r\n        }\r\n    }\r\n    \r\n    function getStageAverageBonus(uint8 _index) public view returns(\r\n        uint32 buying,\r\n        uint32 lottery,\r\n        uint32 ultimate\r\n    ) {\r\n        Stage storage stage = stages[_index];\r\n        buying = stage.bonus.buying > 0 ? stage.bonus.buying / stage.fundGoal : 0;\r\n        if (stageFundGoalReached(_index) == true) {\r\n            lottery = stage.bonus.lottery / uint16(stage.winners.length);\r\n            ultimate = stage.bonus.ultimate + (stage.bonus.lottery - lottery * uint16(stage.winners.length));\r\n        }\r\n    } \r\n\r\n    function getOpenedStageIndex() public view returns(uint8) {\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            if (stages[i].openingTime > 0 && now >= stages[i].openingTime && stages[i].fundRaised < stages[i].fundGoal) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getRandomNumber(uint256 power) private view returns (uint256) {\r\n        uint256 ddb = uint256(blockhash(block.number - 1));\r\n        uint256 r = uint256(keccak256(abi.encodePacked(ddb - 1)));\r\n        while (r == 0) {\r\n            ddb += 256;\r\n            r = uint256(keccak256(abi.encodePacked(ddb - 1)));\r\n        }\r\n        return uint256(keccak256(abi.encodePacked(r, block.difficulty, now))) % power;\r\n    }\r\n\r\n    function getTodayLotteryNumber() public view returns(uint8) {\r\n        return uint8(uint256(keccak256(abi.encodePacked(uint16(now / 1 days)))) % funding.maxLotteryNumber);\r\n    }\r\n\r\n    function getSummary() public view returns(\r\n        uint32 exchangeRatio,\r\n        uint16 fundGoal,\r\n        uint32 bonus,\r\n        uint16 fundRaised,\r\n        uint16 buyersCount,\r\n        uint16 winnersCount,\r\n        uint8 minAccepting,\r\n        uint8 maxAccepting,\r\n        uint8 openedStageIndex,\r\n        uint8 todayLotteryNumber\r\n    ) {\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            fundGoal += stages[i].fundGoal;\r\n            fundRaised += stages[i].fundRaised;\r\n            bonus += stages[i].bonus.buying + stages[i].bonus.lottery + stages[i].bonus.ultimate;\r\n        }\r\n\r\n        exchangeRatio = funding.exchangeRatio;\r\n        minAccepting = funding.minAccepting;\r\n        maxAccepting = funding.maxAccepting;\r\n        buyersCount = uint16(funding.buyers.length);\r\n        winnersCount = uint16(funding.winners.length);\r\n        openedStageIndex = getOpenedStageIndex();\r\n        todayLotteryNumber = getTodayLotteryNumber();\r\n    }\r\n\r\n    function setStageOpeningTime(uint8 _index, uint32 _openingTime) public onlyOwner whenNotPaused returns(bool) {\r\n        if (stages[_index].openingTime > 0) {\r\n            require(stages[_index].openingTime > now, \"Stage has been already opened.\");\r\n        }\r\n        stages[_index].openingTime = _openingTime;\r\n        emit StageOpeningTimeSet(_index);\r\n        return true;\r\n    }\r\n\r\n    function getStages() public view returns(\r\n        uint8[4] index,\r\n        uint32[4] openingTime,\r\n        uint32[4] buyingBonus,\r\n        uint32[4] lotteryBonus,\r\n        uint32[4] ultimateBonus,\r\n        uint16[4] fundGoal,\r\n        uint16[4] fundRaised,\r\n        uint16[4] buyersCount,\r\n        uint16[4] winnersCount,\r\n        address[4] ultimateBonusWinner\r\n    ) {\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            uint8 _i = i - 1;\r\n            index[_i] = i;\r\n            openingTime[_i] = stages[i].openingTime;\r\n            buyingBonus[_i] = stages[i].bonus.buying;\r\n            lotteryBonus[_i] = stages[i].bonus.lottery;\r\n            ultimateBonus[_i] = stages[i].bonus.ultimate;\r\n            fundGoal[_i] = stages[i].fundGoal;\r\n            fundRaised[_i] = stages[i].fundRaised;\r\n            buyersCount[_i] = uint16(stages[i].buyers.length);\r\n            winnersCount[_i] = uint16(stages[i].winners.length);\r\n            ultimateBonusWinner[_i] = stages[i].ultimateBonusWinner == EMPTY_ADDRESS ? address(0) : stages[i].ultimateBonusWinner;\r\n        }\r\n    }\r\n\r\n    function getBuyers(uint16 _offset, uint8 _limit) public view returns(\r\n        uint16 total,\r\n        uint16 start,\r\n        uint16 end,\r\n        uint8 count,\r\n        address[] items\r\n    ) {\r\n        total = uint16(funding.buyers.length);\r\n        if (total > 0) {\r\n            start = _offset > total - 1 ? total - 1 : _offset;\r\n            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\r\n            count = uint8(end - start + 1);\r\n        }\r\n\r\n        if (count > 0) {\r\n            address[] memory _items = new address[](count);\r\n            uint8 j = 0;\r\n            for (uint16 i = start; i <= end; i++) {\r\n                _items[j] = funding.buyers[i];\r\n                j++;\r\n            }\r\n            items = _items;\r\n        }\r\n    }\r\n\r\n    function getWinners(uint16 _offset, uint8 _limit) public view returns(\r\n        uint16 total,\r\n        uint16 start,\r\n        uint16 end,\r\n        uint8 count,\r\n        address[] items\r\n    ) {\r\n        total = uint16(funding.winners.length);\r\n        if (total > 0) {\r\n            start = _offset > total - 1 ? total - 1 : _offset;\r\n            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\r\n            count = uint8(end - start + 1);\r\n        }\r\n\r\n        if (count > 0) {\r\n            address[] memory _items = new address[](count);\r\n            uint8 j = 0;\r\n            for (uint16 i = start; i <= end; i++) {\r\n                _items[j] = funding.winners[i];\r\n                j++;\r\n            }\r\n            items = _items;\r\n        }\r\n    }\r\n\r\n    function getStageBuyers(uint8 _index, uint16 _offset, uint8 _limit) public view returns(\r\n        uint16 total,\r\n        uint16 start,\r\n        uint16 end,\r\n        uint8 count,\r\n        address[] items\r\n    ) {\r\n        Stage storage stage = stages[_index];\r\n\r\n        total = uint16(stage.buyers.length);\r\n        if (total > 0) {\r\n            start = _offset > total - 1 ? total - 1 : _offset;\r\n            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\r\n            count = uint8(end - start + 1);\r\n        }\r\n\r\n        if (count > 0) {\r\n            address[] memory _items = new address[](count);\r\n            uint8 j = 0;\r\n            for (uint16 i = start; i <= end; i++) {\r\n                _items[j] = stage.buyers[i];\r\n                j++;\r\n            }\r\n            items = _items;\r\n        }\r\n    }\r\n\r\n    function getStageWinners(uint8 _index, uint16 _offset, uint8 _limit) public view returns(\r\n        uint16 total,\r\n        uint16 start,\r\n        uint16 end,\r\n        uint8 count,\r\n        address[] items\r\n    ) {\r\n        Stage storage stage = stages[_index];\r\n\r\n        total = uint16(stage.winners.length);\r\n        if (total > 0) {\r\n            start = _offset > total - 1 ? total - 1 : _offset;\r\n            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\r\n            count = uint8(end - start + 1);\r\n        }\r\n\r\n        if (count > 0) {\r\n            address[] memory _items = new address[](count);\r\n            uint8 j = 0;\r\n            for (uint16 i = start; i <= end; i++) {\r\n                _items[j] = stage.winners[i];\r\n                j++;\r\n            }\r\n            items = _items;\r\n        }\r\n    }\r\n\r\n    function getBuyer(address _buyer) public view returns(\r\n        uint8[4] funded,\r\n        uint32[4] buyingBonus,\r\n        uint32[4] lotteryBonus,\r\n        uint32[4] ultimateBonus,\r\n        bool[4] lotteryBonusWon,\r\n        bool[4] ultimateBonusWon,\r\n        bool[4] bonusReleasable,\r\n        bool[4] bonusReleased\r\n    ) {\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            BuyerStage storage buyerStage = buyers[_buyer][i];\r\n            funded[i - 1] = buyerStage.funded;\r\n            lotteryBonusWon[i - 1] = buyerStage.lotteryBonusWon;\r\n            ultimateBonusWon[i - 1] = buyerStage.ultimateBonusWon;\r\n            bonusReleasable[i - 1] = stageFundGoalReached(i);\r\n            bonusReleased[i - 1] = buyerStage.bonusReleased;\r\n\r\n            uint32 _buyingBonus;\r\n            uint32 _lotteryBonus;\r\n            uint32 _ultimateBonus;\r\n\r\n            (_buyingBonus, _lotteryBonus, _ultimateBonus) = getStageAverageBonus(i);\r\n            \r\n            buyingBonus[i - 1] = buyerStage.funded * _buyingBonus;\r\n\r\n            if (buyerStage.lotteryBonusWon == true) {\r\n                lotteryBonus[i - 1] = _lotteryBonus;\r\n            }\r\n            \r\n            if (buyerStage.ultimateBonusWon == true) {\r\n                ultimateBonus[i - 1] = _ultimateBonus;\r\n            }\r\n        }\r\n    }\r\n\r\n    function finalFundGoalReached() public view returns(bool) {\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            if (stageFundGoalReached(i) == false) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function stageFundGoalReached(uint8 _index) public view returns(bool) {\r\n        Stage storage stage = stages[_index];\r\n        return (stage.openingTime > 0 && stage.openingTime <= now && stage.fundRaised >= stage.fundGoal);\r\n    }\r\n\r\n    function tokenFallback(address _from, uint256 _value) public returns(bool) {\r\n        require(msg.sender == address(token));\r\n        return true;\r\n    }\r\n\r\n    function releasableViewOrSend(address _buyer, bool _send) private returns(uint32) {\r\n        uint32 bonus;\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            BuyerStage storage buyerStage = buyers[_buyer][i];\r\n\r\n            if (stageFundGoalReached(i) == false || buyerStage.bonusReleased == true) {\r\n                continue;\r\n            }\r\n            \r\n            uint32 buyingBonus;\r\n            uint32 lotteryBonus;\r\n            uint32 ultimateBonus;\r\n\r\n            (buyingBonus, lotteryBonus, ultimateBonus) = getStageAverageBonus(i);\r\n\r\n            bonus += buyerStage.funded * buyingBonus;\r\n            if (buyerStage.lotteryBonusWon == true) {\r\n                bonus += lotteryBonus;\r\n            }\r\n            if (buyerStage.ultimateBonusWon == true) {\r\n                bonus += ultimateBonus;\r\n            }\r\n            \r\n            if (_send == true) {\r\n                buyerStage.bonusReleased = true;\r\n            }\r\n        }\r\n        \r\n        if (_send == true) {\r\n            require(bonus > 0, \"No bonus.\");\r\n            token.transferFrom(pool, _buyer, uint256(bonus).mul(decimals));\r\n        }\r\n        \r\n        return bonus;\r\n    }\r\n\r\n    function releasable(address _buyer) public view returns(uint32) {\r\n        return releasableViewOrSend(_buyer, false);\r\n    }\r\n\r\n    function release(address _buyer) private {\r\n        releasableViewOrSend(_buyer, true);\r\n    }\r\n\r\n    function getBuyerFunded(address _buyer) private view returns(uint8) {\r\n        uint8 funded;\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            funded += buyers[_buyer][i].funded;\r\n        }\r\n        return funded;\r\n    }\r\n\r\n    function hasBuyerLotteryBonusWon(address _buyer) private view returns(bool) {\r\n        for (uint8 i = 1; i <= 4; i++) {\r\n            if (buyers[_buyer][i].lotteryBonusWon) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function buy(address _buyer, uint256 value) private {\r\n        uint8 i = getOpenedStageIndex();\r\n        require(i > 0, \"No opening stage found.\");\r\n        require(value >= 1 ether, \"The amount too low.\");\r\n\r\n        Stage storage stage = stages[i];\r\n\r\n        uint16 remain;\r\n        uint16 funded = getBuyerFunded(_buyer);\r\n        uint256 amount = value.div(1 ether);\r\n        uint256 refund = value.sub(amount.mul(1 ether));\r\n\r\n        remain = funding.maxAccepting - funded;\r\n        require(remain > 0, \"Total amount too high.\");\r\n        if (remain < amount) {\r\n            refund = refund.add(amount.sub(uint256(remain)).mul(1 ether));\r\n            amount = remain;\r\n        }\r\n\r\n        remain = stage.fundGoal - stage.fundRaised;\r\n        require(remain > 0, \"Stage funding goal reached.\");\r\n        if (remain < amount) {\r\n            refund = refund.add(amount.sub(uint256(remain)).mul(1 ether));\r\n            amount = remain;\r\n        }\r\n\r\n        if (refund > 0) {\r\n            require(_buyer.send(refund), \"Refund failed.\");\r\n        }\r\n\r\n        BuyerStage storage buyerStage = buyers[_buyer][i];\r\n\r\n        if (funded == 0) {\r\n            funding.buyers.push(_buyer);\r\n        }\r\n        if (buyerStage.funded == 0) {\r\n            stage.buyers.push(_buyer);\r\n        }\r\n        buyerStage.funded += uint8(amount);\r\n\r\n        stage.fundRaised += uint16(amount);\r\n\r\n        emit BuyerFunded(_buyer, i, uint8(amount));\r\n\r\n        uint8 todayLotteryNumber = getTodayLotteryNumber();\r\n\r\n        if (stage.nextLotteryRaised == 0) {\r\n            stage.nextLotteryRaised = todayLotteryNumber;\r\n        }\r\n        \r\n        uint8 mod;\r\n        if (stage.fundRaised > 10) {\r\n            mod = uint8(stage.fundRaised % 10);\r\n            if (mod == 0) {\r\n                mod = 10;\r\n            }\r\n        } else {\r\n            mod = uint8(stage.fundRaised);\r\n        }\r\n        if (mod >= todayLotteryNumber && stage.fundRaised >= stage.nextLotteryRaised) {\r\n            if (hasBuyerLotteryBonusWon(_buyer) == false) {\r\n                funding.winners.push(_buyer);\r\n            }\r\n            if (buyerStage.lotteryBonusWon == false) {\r\n                buyerStage.lotteryBonusWon = true;\r\n                stage.winners.push(_buyer);\r\n                emit BuyerLotteryBonusWon(_buyer, i, todayLotteryNumber, stage.fundRaised);\r\n            }\r\n            stage.nextLotteryRaised += 10;\r\n        }\r\n\r\n        if (stage.fundGoal == stage.fundRaised) {\r\n            stage.ultimateBonusWinner = stage.winners[uint16(getRandomNumber(stage.winners.length - 1))];\r\n            buyers[stage.ultimateBonusWinner][i].ultimateBonusWon = true;\r\n\r\n            emit StageGoalReached(i);\r\n            emit BuyerUltimateBonusWon(_buyer, i);\r\n        }\r\n\r\n        if (finalFundGoalReached() == true) {\r\n            emit FinalGoalReached();\r\n        }\r\n\r\n        uint256 tokens = amount * funding.exchangeRatio;\r\n        require(beneficiary.send(amount.mul(1 ether)), \"Send failed.\");\r\n        require(token.transferFrom(pool, _buyer, tokens.mul(decimals)), \"Deliver failed.\");\r\n    }\r\n\r\n    function () whenNotPaused onlyWhitelisted public payable {\r\n        require(beneficiary != msg.sender, \"The beneficiary cannot buy CATT.\");\r\n        if (msg.value == 0) {\r\n            release(msg.sender);\r\n        } else {\r\n            buy(msg.sender, msg.value);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromOperators\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToOperators\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_offset\",\"type\":\"uint16\"},{\"name\":\"_limit\",\"type\":\"uint8\"}],\"name\":\"getWinners\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint16\"},{\"name\":\"start\",\"type\":\"uint16\"},{\"name\":\"end\",\"type\":\"uint16\"},{\"name\":\"count\",\"type\":\"uint8\"},{\"name\":\"items\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSummary\",\"outputs\":[{\"name\":\"exchangeRatio\",\"type\":\"uint32\"},{\"name\":\"fundGoal\",\"type\":\"uint16\"},{\"name\":\"bonus\",\"type\":\"uint32\"},{\"name\":\"fundRaised\",\"type\":\"uint16\"},{\"name\":\"buyersCount\",\"type\":\"uint16\"},{\"name\":\"winnersCount\",\"type\":\"uint16\"},{\"name\":\"minAccepting\",\"type\":\"uint8\"},{\"name\":\"maxAccepting\",\"type\":\"uint8\"},{\"name\":\"openedStageIndex\",\"type\":\"uint8\"},{\"name\":\"todayLotteryNumber\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getBuyer\",\"outputs\":[{\"name\":\"funded\",\"type\":\"uint8[4]\"},{\"name\":\"buyingBonus\",\"type\":\"uint32[4]\"},{\"name\":\"lotteryBonus\",\"type\":\"uint32[4]\"},{\"name\":\"ultimateBonus\",\"type\":\"uint32[4]\"},{\"name\":\"lotteryBonusWon\",\"type\":\"bool[4]\"},{\"name\":\"ultimateBonusWon\",\"type\":\"bool[4]\"},{\"name\":\"bonusReleasable\",\"type\":\"bool[4]\"},{\"name\":\"bonusReleased\",\"type\":\"bool[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"},{\"name\":\"_offset\",\"type\":\"uint16\"},{\"name\":\"_limit\",\"type\":\"uint8\"}],\"name\":\"getStageBuyers\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint16\"},{\"name\":\"start\",\"type\":\"uint16\"},{\"name\":\"end\",\"type\":\"uint16\"},{\"name\":\"count\",\"type\":\"uint8\"},{\"name\":\"items\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_offset\",\"type\":\"uint16\"},{\"name\":\"_limit\",\"type\":\"uint8\"}],\"name\":\"getBuyers\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint16\"},{\"name\":\"start\",\"type\":\"uint16\"},{\"name\":\"end\",\"type\":\"uint16\"},{\"name\":\"count\",\"type\":\"uint8\"},{\"name\":\"items\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTodayLotteryNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStages\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint8[4]\"},{\"name\":\"openingTime\",\"type\":\"uint32[4]\"},{\"name\":\"buyingBonus\",\"type\":\"uint32[4]\"},{\"name\":\"lotteryBonus\",\"type\":\"uint32[4]\"},{\"name\":\"ultimateBonus\",\"type\":\"uint32[4]\"},{\"name\":\"fundGoal\",\"type\":\"uint16[4]\"},{\"name\":\"fundRaised\",\"type\":\"uint16[4]\"},{\"name\":\"buyersCount\",\"type\":\"uint16[4]\"},{\"name\":\"winnersCount\",\"type\":\"uint16[4]\"},{\"name\":\"ultimateBonusWinner\",\"type\":\"address[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalFundGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToOperators\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenedStageIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"releasable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"},{\"name\":\"_offset\",\"type\":\"uint16\"},{\"name\":\"_limit\",\"type\":\"uint8\"}],\"name\":\"getStageWinners\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint16\"},{\"name\":\"start\",\"type\":\"uint16\"},{\"name\":\"end\",\"type\":\"uint16\"},{\"name\":\"count\",\"type\":\"uint8\"},{\"name\":\"items\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromOperators\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"}],\"name\":\"getStageAverageBonus\",\"outputs\":[{\"name\":\"buying\",\"type\":\"uint32\"},{\"name\":\"lottery\",\"type\":\"uint32\"},{\"name\":\"ultimate\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"}],\"name\":\"stageFundGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"},{\"name\":\"_openingTime\",\"type\":\"uint32\"}],\"name\":\"setStageOpeningTime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_pool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stageIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"BuyerFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stageIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"lotteryNumber\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"fundRaised\",\"type\":\"uint16\"}],\"name\":\"BuyerLotteryBonusWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stageIndex\",\"type\":\"uint8\"}],\"name\":\"BuyerUltimateBonusWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"StageOpeningTimeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"StageGoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FinalGoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OperatorAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OperatorAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c4838a37422ddd180f6bf34393873b1489db6faa000000000000000000000000b69e3f64e2dce857afa296030796a7882d9f4e34000000000000000000000000f19552cd86c189ddf0c1b8e3fee83f7c3b1582a8","Library":"","SwarmSource":"bzzr://0a1d84374e449c22316c9f2e806235497d400dbdf2bc76129e86ef8cbec6712b"}]}