{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: contracts/IAccounting.sol\r\n\r\ninterface IAccounting {\r\n  function contribute(\r\n    address contributor,\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external returns(uint128 deposited, uint128 depositedFees);\r\n\r\n  function withdrawContribution(address contributor) external returns(\r\n    uint128 withdrawn,\r\n    uint128 withdrawnFees\r\n  );\r\n\r\n  function finalize(uint128 amountDisputed) external;\r\n\r\n  function getOwner() external view returns(address);\r\n\r\n  function isFinalized() external view returns(bool);\r\n\r\n  /**\r\n   * Return value is how much REP and dispute tokens the contributor is entitled to.\r\n   *\r\n   * Does not change the state, as accounting is finalized at that moment.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateProceeds(address contributor) external view returns(\r\n    uint128 rep,\r\n    uint128 disputeTokens\r\n  );\r\n\r\n  /**\r\n   * Calculate fee that will be split between contract admin and\r\n   * account that triggered dispute transaction.\r\n   *\r\n   * In case of partial fill, we round down, leaving some dust in the contract.\r\n   */\r\n  function calculateFees() external view returns(uint128);\r\n\r\n  function addFeesOnTop(\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external pure returns(uint128);\r\n}\r\n\r\n// File: contracts/IAccountingFactory.sol\r\n\r\ninterface IAccountingFactory {\r\n  function create(address owner) external returns(IAccounting);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/IDisputer.sol\r\n\r\n/**\r\n * Interface of what the disputer contract should do.\r\n *\r\n * Its main responsibility to interact with Augur. Only minimal glue methods\r\n * are added apart from that in order for crowdsourcer to be able to interact\r\n * with it.\r\n *\r\n * This contract holds the actual crowdsourced REP for dispute, so it doesn't\r\n * need to transfer it from elsewhere at the moment of dispute. It doesn't care\r\n * at all who this REP belongs to, it just spends it for dispute. Accounting\r\n * is done in other contracts.\r\n */\r\ninterface IDisputer {\r\n  /**\r\n   * This function should use as little gas as possible, as it will be called\r\n   * during rush time. Unnecessary operations are postponed for later.\r\n   *\r\n   * Can by called by anyone, but only once.\r\n   */\r\n  function dispute(address feeReceiver) external;\r\n\r\n  // intentionally can be called by anyone, as no user input is used\r\n  function approveManagerToSpendDisputeTokens() external;\r\n\r\n  function getOwner() external view returns(address);\r\n\r\n  function hasDisputed() external view returns(bool);\r\n\r\n  function feeReceiver() external view returns(address);\r\n\r\n  function getREP() external view returns(IERC20);\r\n\r\n  function getDisputeTokenAddress() external view returns(IERC20);\r\n}\r\n\r\n// File: contracts/augur/feeWindow.sol\r\n\r\ninterface FeeWindow {\r\n  function getStartTime() external view returns(uint256);\r\n}\r\n\r\n// File: contracts/augur/universe.sol\r\n\r\ninterface Universe {\r\n  function getDisputeRoundDurationInSeconds() external view returns(uint256);\r\n  function isForking() external view returns(bool);\r\n}\r\n\r\n// File: contracts/augur/reportingParticipant.sol\r\n\r\n/**\r\n * This should've been an interface, but interfaces cannot inherit interfaces\r\n */\r\ncontract ReportingParticipant is IERC20 {\r\n  function getStake() external view returns(uint256);\r\n  function getPayoutDistributionHash() external view returns(bytes32);\r\n}\r\n\r\n// File: contracts/augur/market.sol\r\n\r\ninterface Market {\r\n  function contribute(\r\n    uint256[] _payoutNumerators,\r\n    bool _invalid,\r\n    uint256 _amount\r\n  ) external returns(bool);\r\n\r\n  function getReputationToken() external view returns(IERC20);\r\n\r\n  function getUniverse() external view returns(Universe);\r\n\r\n  function derivePayoutDistributionHash(\r\n    uint256[] _payoutNumerators,\r\n    bool _invalid\r\n  ) external view returns(bytes32);\r\n\r\n  function getCrowdsourcer(\r\n    bytes32 _payoutDistributionHash\r\n  ) external view returns(ReportingParticipant);\r\n\r\n  function getNumParticipants() external view returns(uint256);\r\n\r\n  function getReportingParticipant(uint256 _index) external view returns(\r\n    ReportingParticipant\r\n  );\r\n\r\n  function isFinalized() external view returns(bool);\r\n\r\n  function getFeeWindow() external view returns(FeeWindow);\r\n\r\n  function getWinningReportingParticipant() external view returns(\r\n    ReportingParticipant\r\n  );\r\n}\r\n\r\n// File: contracts/IDisputerFactory.sol\r\n\r\ninterface IDisputerFactory {\r\n  event DisputerCreated(\r\n    address _owner,\r\n    IDisputer _address,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  );\r\n\r\n  function create(\r\n    address owner,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) external returns(IDisputer);\r\n}\r\n\r\n// File: contracts/ICrowdsourcerParent.sol\r\n\r\n/**\r\n * Parent of a crowdsourcer that is passed into it on construction. Used\r\n * to determine destination for fees.\r\n */\r\ninterface ICrowdsourcerParent {\r\n  function getContractFeeReceiver() external view returns(address);\r\n}\r\n\r\n// File: contracts/ICrowdsourcer.sol\r\n\r\n/**\r\n * Crowdsourcer for specific market/outcome/round.\r\n */\r\ninterface ICrowdsourcer {\r\n  event ContributionAccepted(\r\n    address contributor,\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  );\r\n\r\n  event ContributionWithdrawn(address contributor, uint128 amount);\r\n\r\n  event CrowdsourcerFinalized(uint128 amountDisputeTokensAcquired);\r\n\r\n  event ProceedsWithdrawn(\r\n    address contributor,\r\n    uint128 disputeTokensAmount,\r\n    uint128 repAmount\r\n  );\r\n\r\n  event FeesWithdrawn(\r\n    address contractAuthor,\r\n    address executor,\r\n    uint128 contractAuthorAmount,\r\n    uint128 executorAmount\r\n  );\r\n\r\n  event Initialized();\r\n\r\n  // initialization stage\r\n  function initialize() external;\r\n\r\n  // pre-dispute stage\r\n  function contribute(uint128 amount, uint128 feeNumerator) external;\r\n\r\n  function withdrawContribution() external;\r\n\r\n  // finalization (after dispute happened)\r\n  function finalize() external;\r\n\r\n  // after finalization\r\n\r\n  // intentionally anyone can call it, since they won't harm contributor\r\n  // by helping them withdraw their proceeds\r\n  function withdrawProceeds(address contributor) external;\r\n\r\n  function withdrawFees() external;\r\n\r\n  function hasDisputed() external view returns(bool);\r\n\r\n  function isInitialized() external view returns(bool);\r\n\r\n  function getParent() external view returns(ICrowdsourcerParent);\r\n\r\n  function getDisputer() external view returns(IDisputer);\r\n\r\n  function getAccounting() external view returns(IAccounting);\r\n\r\n  function getREP() external view returns(IERC20);\r\n\r\n  function getDisputeToken() external view returns(IERC20);\r\n\r\n  function isFinalized() external view returns(bool);\r\n}\r\n\r\n// File: contracts/DisputerParams.sol\r\n\r\nlibrary DisputerParams {\r\n  struct Params {\r\n    Market market;\r\n    uint256 feeWindowId;\r\n    uint256[] payoutNumerators;\r\n    bool invalid;\r\n  }\r\n}\r\n\r\n// File: contracts/Crowdsourcer.sol\r\n\r\ncontract Crowdsourcer is ICrowdsourcer {\r\n  bool public m_isInitialized = false;\r\n  DisputerParams.Params public m_disputerParams;\r\n  IAccountingFactory public m_accountingFactory;\r\n  IDisputerFactory public m_disputerFactory;\r\n\r\n  IAccounting public m_accounting;\r\n  ICrowdsourcerParent public m_parent;\r\n  IDisputer public m_disputer;\r\n\r\n  mapping(address => bool) public m_proceedsCollected;\r\n  bool public m_feesCollected = false;\r\n\r\n  constructor(\r\n    ICrowdsourcerParent parent,\r\n    IAccountingFactory accountingFactory,\r\n    IDisputerFactory disputerFactory,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) public {\r\n    m_parent = parent;\r\n    m_accountingFactory = accountingFactory;\r\n    m_disputerFactory = disputerFactory;\r\n    m_disputerParams = DisputerParams.Params(\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n  }\r\n\r\n  modifier beforeDisputeOnly() {\r\n    require(!hasDisputed(), \"Method only allowed before dispute\");\r\n    _;\r\n  }\r\n\r\n  modifier requiresInitialization() {\r\n    require(isInitialized(), \"Must call initialize() first\");\r\n    _;\r\n  }\r\n\r\n  modifier requiresFinalization() {\r\n    if (!isFinalized()) {\r\n      finalize();\r\n      assert(isFinalized());\r\n    }\r\n    _;\r\n  }\r\n\r\n  function initialize() external {\r\n    require(!m_isInitialized, \"Already initialized\");\r\n    m_isInitialized = true;\r\n    m_accounting = m_accountingFactory.create(this);\r\n    m_disputer = m_disputerFactory.create(\r\n      this,\r\n      m_disputerParams.market,\r\n      m_disputerParams.feeWindowId,\r\n      m_disputerParams.payoutNumerators,\r\n      m_disputerParams.invalid\r\n    );\r\n    emit Initialized();\r\n  }\r\n\r\n  function contribute(\r\n    uint128 amount,\r\n    uint128 feeNumerator\r\n  ) external requiresInitialization beforeDisputeOnly {\r\n    uint128 amountWithFees = m_accounting.addFeesOnTop(amount, feeNumerator);\r\n\r\n    IERC20 rep = getREP();\r\n    require(rep.balanceOf(msg.sender) >= amountWithFees, \"Not enough funds\");\r\n    require(\r\n      rep.allowance(msg.sender, this) >= amountWithFees,\r\n      \"Now enough allowance\"\r\n    );\r\n\r\n    // record contribution in accounting (will perform validations)\r\n    uint128 deposited;\r\n    uint128 depositedFees;\r\n    (deposited, depositedFees) = m_accounting.contribute(\r\n      msg.sender,\r\n      amount,\r\n      feeNumerator\r\n    );\r\n\r\n    assert(deposited == amount);\r\n    assert(deposited + depositedFees == amountWithFees);\r\n\r\n    // actually transfer tokens and revert tx if any problem\r\n    assert(rep.transferFrom(msg.sender, m_disputer, deposited));\r\n    assert(rep.transferFrom(msg.sender, this, depositedFees));\r\n\r\n    emit ContributionAccepted(msg.sender, amount, feeNumerator);\r\n  }\r\n\r\n  function withdrawContribution(\r\n\r\n  ) external requiresInitialization beforeDisputeOnly {\r\n    IERC20 rep = getREP();\r\n\r\n    // record withdrawal in accounting (will perform validations)\r\n    uint128 withdrawn;\r\n    uint128 withdrawnFees;\r\n    (withdrawn, withdrawnFees) = m_accounting.withdrawContribution(msg.sender);\r\n\r\n    // actually transfer tokens and revert tx if any problem\r\n    assert(rep.transferFrom(m_disputer, msg.sender, withdrawn));\r\n    assert(rep.transfer(msg.sender, withdrawnFees));\r\n\r\n    emit ContributionWithdrawn(msg.sender, withdrawn);\r\n  }\r\n\r\n  function withdrawProceeds(address contributor) external requiresFinalization {\r\n    require(\r\n      !m_proceedsCollected[contributor],\r\n      \"Can only collect proceeds once\"\r\n    );\r\n\r\n    // record proceeds have been collected\r\n    m_proceedsCollected[contributor] = true;\r\n\r\n    uint128 refund;\r\n    uint128 proceeds;\r\n\r\n    // calculate how much this contributor is entitled to\r\n    (refund, proceeds) = m_accounting.calculateProceeds(contributor);\r\n\r\n    IERC20 rep = getREP();\r\n    IERC20 disputeTokenAddress = getDisputeToken();\r\n\r\n    // actually deliver the proceeds/refund\r\n    assert(rep.transfer(contributor, refund));\r\n    assert(disputeTokenAddress.transfer(contributor, proceeds));\r\n\r\n    emit ProceedsWithdrawn(contributor, proceeds, refund);\r\n  }\r\n\r\n  function withdrawFees() external requiresFinalization {\r\n    require(!m_feesCollected, \"Can only collect fees once\");\r\n\r\n    m_feesCollected = true;\r\n\r\n    uint128 feesTotal = m_accounting.calculateFees();\r\n    // 10% of fees go to contract author\r\n    uint128 feesForContractAuthor = feesTotal / 10;\r\n    uint128 feesForExecutor = feesTotal - feesForContractAuthor;\r\n\r\n    assert(feesForContractAuthor + feesForExecutor == feesTotal);\r\n\r\n    address contractFeesRecipient = m_parent.getContractFeeReceiver();\r\n    address executorFeesRecipient = m_disputer.feeReceiver();\r\n\r\n    IERC20 rep = getREP();\r\n\r\n    assert(rep.transfer(contractFeesRecipient, feesForContractAuthor));\r\n    assert(rep.transfer(executorFeesRecipient, feesForExecutor));\r\n\r\n    emit FeesWithdrawn(\r\n      contractFeesRecipient,\r\n      executorFeesRecipient,\r\n      feesForContractAuthor,\r\n      feesForExecutor\r\n    );\r\n  }\r\n\r\n  function getParent() external view returns(ICrowdsourcerParent) {\r\n    return m_parent;\r\n  }\r\n\r\n  function getDisputer() external view requiresInitialization returns(\r\n    IDisputer\r\n  ) {\r\n    return m_disputer;\r\n  }\r\n\r\n  function getAccounting() external view requiresInitialization returns(\r\n    IAccounting\r\n  ) {\r\n    return m_accounting;\r\n  }\r\n\r\n  function finalize() public requiresInitialization {\r\n    require(hasDisputed(), \"Can only finalize after dispute\");\r\n    require(!isFinalized(), \"Can only finalize once\");\r\n\r\n    // now that we've disputed we must know dispute token address\r\n    IERC20 disputeTokenAddress = getDisputeToken();\r\n    IERC20 rep = getREP();\r\n\r\n    m_disputer.approveManagerToSpendDisputeTokens();\r\n\r\n    // retrieve all tokens from disputer for proceeds distribution\r\n    // This wouldn't work extremely well if it is called from disputer's\r\n    // dispute() method, but it should only call Augur which we trust.\r\n    assert(rep.transferFrom(m_disputer, this, rep.balanceOf(m_disputer)));\r\n    assert(\r\n      disputeTokenAddress.transferFrom(\r\n        m_disputer,\r\n        this,\r\n        disputeTokenAddress.balanceOf(m_disputer)\r\n      )\r\n    );\r\n\r\n    uint256 amountDisputed = disputeTokenAddress.balanceOf(this);\r\n    uint128 amountDisputed128 = uint128(amountDisputed);\r\n\r\n    // REP has only so many tokens\r\n    assert(amountDisputed128 == amountDisputed);\r\n\r\n    m_accounting.finalize(amountDisputed128);\r\n\r\n    assert(isFinalized());\r\n\r\n    emit CrowdsourcerFinalized(amountDisputed128);\r\n  }\r\n\r\n  function isInitialized() public view returns(bool) {\r\n    return m_isInitialized;\r\n  }\r\n\r\n  function getREP() public view requiresInitialization returns(IERC20) {\r\n    return m_disputer.getREP();\r\n  }\r\n\r\n  function getDisputeToken() public view requiresInitialization returns(\r\n    IERC20\r\n  ) {\r\n    return m_disputer.getDisputeTokenAddress();\r\n  }\r\n\r\n  function hasDisputed() public view requiresInitialization returns(bool) {\r\n    return m_disputer.hasDisputed();\r\n  }\r\n\r\n  function isFinalized() public view requiresInitialization returns(bool) {\r\n    return m_accounting.isFinalized();\r\n  }\r\n}\r\n\r\n// File: contracts/CrowdsourcerFactory.sol\r\n\r\n/**\r\n * NOTE: the created crowdsourcers trust the market that was passed in constructor.\r\n * If a malicious market is passed in, all bets are off.\r\n *\r\n * Individual crowdsourcers have no trust relationships with each other.\r\n */\r\ncontract CrowdsourcerFactory is ICrowdsourcerParent {\r\n  event CrowdsourcerCreated(\r\n    ICrowdsourcer crowdsourcer,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  );\r\n\r\n  IAccountingFactory public m_accountingFactory;\r\n  IDisputerFactory public m_disputerFactory;\r\n\r\n  address public m_feeCollector;\r\n  mapping(bytes32 => ICrowdsourcer) public m_crowdsourcers;\r\n\r\n  constructor(\r\n    IAccountingFactory accountingFactory,\r\n    IDisputerFactory disputerFactory,\r\n    address feeCollector\r\n  ) public {\r\n    m_accountingFactory = accountingFactory;\r\n    m_disputerFactory = disputerFactory;\r\n    m_feeCollector = feeCollector;\r\n  }\r\n\r\n  function transferFeeCollection(address recipient) external {\r\n    require(msg.sender == m_feeCollector, \"Not authorized\");\r\n    m_feeCollector = recipient;\r\n  }\r\n\r\n  function getInitializedCrowdsourcer(\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) external returns(ICrowdsourcer) {\r\n    ICrowdsourcer crowdsourcer = getCrowdsourcer(\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    if (!crowdsourcer.isInitialized()) {\r\n      crowdsourcer.initialize();\r\n      assert(crowdsourcer.isInitialized());\r\n    }\r\n    return crowdsourcer;\r\n  }\r\n\r\n  function getContractFeeReceiver() external view returns(address) {\r\n    return m_feeCollector;\r\n  }\r\n\r\n  function maybeGetCrowdsourcer(\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) external view returns(ICrowdsourcer) {\r\n    bytes32 paramsHash = hashParams(\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    return m_crowdsourcers[paramsHash];\r\n  }\r\n\r\n  function getCrowdsourcer(\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) public returns(ICrowdsourcer) {\r\n    bytes32 paramsHash = hashParams(\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    ICrowdsourcer existing = m_crowdsourcers[paramsHash];\r\n    if (address(existing) != 0) {\r\n      return existing;\r\n    }\r\n    ICrowdsourcer created = new Crowdsourcer(\r\n      this,\r\n      m_accountingFactory,\r\n      m_disputerFactory,\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    emit CrowdsourcerCreated(\r\n      created,\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    m_crowdsourcers[paramsHash] = created;\r\n    return created;\r\n  }\r\n\r\n  function hashParams(\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) public pure returns(bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(market, feeWindowId, payoutNumerators, invalid)\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"getCrowdsourcer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_accountingFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"maybeGetCrowdsourcer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferFeeCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"m_crowdsourcers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"getInitializedCrowdsourcer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"hashParams\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_disputerFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_feeCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractFeeReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"accountingFactory\",\"type\":\"address\"},{\"name\":\"disputerFactory\",\"type\":\"address\"},{\"name\":\"feeCollector\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"crowdsourcer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"CrowdsourcerCreated\",\"type\":\"event\"}]","ContractName":"CrowdsourcerFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000065b8f55457971cdaeef2fb1bc1ed01ac5d426922000000000000000000000000ecd4cf359a05a2b473c95ae68b2b0a7d432dfcc90000000000000000000000002404a39e447d0c8b417049fc42b468a26990b4cc","Library":"","SwarmSource":"bzzr://afc43b9d67d575413eba53b070dd3c21a3f7f47ede9ff8f2d3a3cdc734e78e66"}]}