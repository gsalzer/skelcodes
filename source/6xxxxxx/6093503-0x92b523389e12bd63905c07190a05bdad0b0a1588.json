{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n _______  _______  ______    _______  _______  _______  ______   _______  _______  ______    _______  \r\n|   _   ||  _    ||    _ |  |   _   ||       ||   _   ||      | |   _   ||  _    ||    _ |  |   _   | \r\n|  |_|  || |_|   ||   | ||  |  |_|  ||       ||  |_|  ||  _    ||  |_|  || |_|   ||   | ||  |  |_|  | \r\n|       ||       ||   |_||_ |       ||       ||       || | |   ||       ||       ||   |_||_ |       | \r\n|       ||  _   | |    __  ||       ||      _||       || |_|   ||       ||  _   | |    __  ||       | \r\n|   _   || |_|   ||   |  | ||   _   ||     |_ |   _   ||       ||   _   || |_|   ||   |  | ||   _   | \r\n|__| |__||_______||___|  |_||__| |__||_______||__| |__||______| |__| |__||_______||___|  |_||__| |__| \r\n                                                                                                     \r\n                                       \r\n                                 _       \r\n                                | |      \r\n  _ __  _ __ ___  ___  ___ _ __ | |_ ___ \r\n | '_ \\| '__/ _ \\/ __|/ _ \\ '_ \\| __/ __|\r\n | |_) | | |  __/\\__ \\  __/ | | | |_\\__ \\\r\n | .__/|_|  \\___||___/\\___|_| |_|\\__|___/\r\n | |                                     \r\n |_|                                     \r\n                                                                                                      \r\n                                                                                                      \r\n _______  __   __  _______        _______  _______  __   __        _______  _______  __   __  _______ \r\n|       ||  | |  ||       |      |       ||       ||  | |  |      |       ||   _   ||  |_|  ||       |\r\n|_     _||  |_|  ||    ___|      |    ___||_     _||  |_|  |      |    ___||  |_|  ||       ||    ___|\r\n  |   |  |       ||   |___       |   |___   |   |  |       |      |   | __ |       ||       ||   |___ \r\n  |   |  |       ||    ___|      |    ___|  |   |  |       |      |   ||  ||       ||       ||    ___|\r\n  |   |  |   _   ||   |___       |   |___   |   |  |   _   |      |   |_| ||   _   || ||_|| ||   |___ \r\n  |___|  |__| |__||_______|      |_______|  |___|  |__| |__|      |_______||__| |__||_|   |_||_______|\r\n\r\nCopyright 2018 - theethgame.com\r\n*/\r\n\r\npragma solidity ^0.4.13;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\ncontract TheEthGame {\r\n    using SafeMath for uint256;\r\n    \r\n    struct Player {\r\n        uint256 score;\r\n        uint256 lastCellBoughtOnBlockNumber;\r\n        uint256 numberOfCellsOwned;\r\n        uint256 numberOfCellsBought;\r\n        uint256 earnings;\r\n\r\n        uint256 partialHarmonicSum;\r\n        uint256 partialScoreSum;\r\n        \r\n        address referreal;\r\n\r\n        bytes32 name;\r\n    }\r\n    \r\n    struct Cell {\r\n        address owner;\r\n        uint256 price;\r\n    }\r\n    \r\n    address public owner;\r\n    \r\n    uint256 constant private NUMBER_OF_LINES = 6;\r\n    uint256 constant private NUMBER_OF_COLUMNS = 6;\r\n    uint256 constant private NUMBER_OF_CELLS = NUMBER_OF_COLUMNS * NUMBER_OF_LINES;\r\n    uint256 constant private DEFAULT_POINTS_PER_CELL = 3;\r\n    uint256 constant private POINTS_PER_NEIGHBOUR = 1;\r\n\r\n    uint256 constant private CELL_STARTING_PRICE = 0.01 ether;\r\n    uint256 constant private BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME = 10000;\r\n    uint256 constant private PRICE_INCREASE_PERCENTAGE = uint(2);\r\n    uint256 constant private REFERREAL_PERCENTAGE = uint(10);\r\n    uint256 constant private POT_PERCENTAGE = uint(30);\r\n    uint256 constant private DEVELOPER_PERCENTAGE = uint(5);\r\n    uint256 constant private SCORE_PERCENTAGE = uint(25);\r\n    uint256 constant private NUMBER_OF_CELLS_PERCENTAGE = uint(30);\r\n    \r\n    Cell[NUMBER_OF_CELLS] cells;\r\n    \r\n    address[] private ranking;\r\n    mapping(address => Player) players;\r\n    mapping(bytes32 => address) nameToAddress;\r\n    \r\n    uint256 public numberOfCellsBought;\r\n    uint256 private totalScore;\r\n    \r\n    uint256 private developersCut = 0 ether;\r\n    uint256 private potCut = 0 ether;\r\n    uint256 private harmonicSum;\r\n    uint256 private totalScoreSum;\r\n    \r\n    address private rankOnePlayerAddress;\r\n    uint256 private isFirstSinceBlock;\r\n    \r\n    address public trophyAddress;\r\n    \r\n    event Bought (address indexed _from, address indexed _to);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        trophyAddress = new TheEthGameTrophy();\r\n    }\r\n    \r\n    /* Modifiers */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    /* Buying */\r\n    function nextPriceOf (uint256 _cellId) public view returns (uint256 _nextPrice) {\r\n        return priceOf(_cellId).mul(100 + PRICE_INCREASE_PERCENTAGE) / 100;\r\n    }\r\n    \r\n    function priceOf (uint256 _cellId) public view returns (uint256 _price) {\r\n        if (cells[_cellId].price == 0) {\r\n            return CELL_STARTING_PRICE;\r\n        }\r\n        \r\n        return cells[_cellId].price;\r\n    }\r\n    \r\n    function earningsFromNumberOfCells (address _address) internal view returns (uint256 _earnings) {\r\n        return harmonicSum.sub(players[_address].partialHarmonicSum).mul(players[_address].numberOfCellsBought);\r\n    }\r\n    \r\n    function distributeEarningsBasedOnNumberOfCells (address _address) internal {\r\n        players[_address].earnings = players[_address].earnings.add(earningsFromNumberOfCells(_address));\r\n        players[_address].partialHarmonicSum = harmonicSum;\r\n    }\r\n    \r\n    function earningsFromScore (address _address) internal view returns (uint256 _earnings) {\r\n        return totalScoreSum.sub(players[_address].partialScoreSum).mul(scoreOf(_address));\r\n    }\r\n    \r\n    function distributeEarningsBasedOnScore (address _newOwner, address _oldOwner) internal {\r\n        players[_newOwner].earnings = players[_newOwner].earnings.add(earningsFromScore(_newOwner));\r\n        players[_newOwner].partialScoreSum = totalScoreSum;\r\n        \r\n        if (_oldOwner != address(0)) {\r\n            players[_oldOwner].earnings = players[_oldOwner].earnings.add(earningsFromScore(_oldOwner));\r\n            players[_oldOwner].partialScoreSum = totalScoreSum;\r\n        }\r\n    }\r\n    \r\n    function earningsOfPlayer () public view returns (uint256 _wei) {\r\n        return players[msg.sender].earnings.add(earningsFromScore(msg.sender)).add(earningsFromNumberOfCells(msg.sender));\r\n    }\r\n    \r\n    function getRankOnePlayer (address _oldOwner) internal view returns (address _address, uint256 _oldOwnerIndex) {\r\n        address rankOnePlayer;\r\n        uint256 oldOwnerIndex;\r\n        \r\n        for (uint256 i = 0; i < ranking.length; i++) {\r\n            if (scoreOf(ranking[i]) > scoreOf(rankOnePlayer)) {\r\n                    rankOnePlayer = ranking[i];\r\n            } else if (scoreOf(ranking[i]) == scoreOf(rankOnePlayer) && players[ranking[i]].lastCellBoughtOnBlockNumber > players[rankOnePlayer].lastCellBoughtOnBlockNumber) {\r\n                    rankOnePlayer = ranking[i];\r\n            }\r\n            \r\n            if (ranking[i] == _oldOwner) {\r\n                oldOwnerIndex = i;\r\n            }\r\n        }\r\n        \r\n        \r\n        return (rankOnePlayer, oldOwnerIndex);\r\n    }\r\n\r\n    function buy (uint256 _cellId, address _referreal) payable public {\r\n        require(msg.value >= priceOf(_cellId));\r\n        require(!isContract(msg.sender));\r\n        require(_cellId < NUMBER_OF_CELLS);\r\n        require(msg.sender != address(0));\r\n        require(!isGameFinished()); //If game is finished nobody can buy cells.\r\n        require(ownerOf(_cellId) != msg.sender);\r\n        require(msg.sender != _referreal);\r\n        \r\n        address oldOwner = ownerOf(_cellId);\r\n        address newOwner = msg.sender;\r\n        uint256 price = priceOf(_cellId);\r\n        uint256 excess = msg.value.sub(price);\r\n\r\n        bool isReferrealDistributed = distributeToReferreal(price, _referreal);\r\n        \r\n        //If numberOfCellsBought > 0 imply totalScore > 0\r\n        if (numberOfCellsBought > 0) {\r\n            harmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\r\n            if (isReferrealDistributed) {\r\n                totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\r\n            } else {\r\n                totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\r\n            }\r\n        }else{\r\n            //First cell bought price goes to the pot.\r\n            potCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\r\n        }\r\n        \r\n        numberOfCellsBought++;\r\n        \r\n        distributeEarningsBasedOnNumberOfCells(newOwner);\r\n        \r\n        players[newOwner].numberOfCellsBought++;\r\n        players[newOwner].numberOfCellsOwned++;\r\n        \r\n        if (ownerOf(_cellId) != address(0)) {\r\n             players[oldOwner].numberOfCellsOwned--;\r\n        }\r\n        \r\n        players[newOwner].lastCellBoughtOnBlockNumber = block.number;\r\n         \r\n        address oldRankOnePlayer = rankOnePlayerAddress;\r\n        \r\n        (uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\r\n        \r\n        distributeEarningsBasedOnScore(newOwner, oldOwner);\r\n        \r\n        totalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\r\n                \r\n        players[newOwner].score = newOwnerScore;\r\n        players[oldOwner].score = oldOwnerScore;\r\n        \r\n        totalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\r\n\r\n        cells[_cellId].price = nextPriceOf(_cellId);\r\n        \r\n        //It had 0 cells before\r\n        if (players[newOwner].numberOfCellsOwned == 1) {\r\n           ranking.push(newOwner);\r\n        }\r\n        \r\n        if (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\r\n            (address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner); \r\n            if (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\r\n                delete ranking[oldOwnerIndex];\r\n            }\r\n            rankOnePlayerAddress = rankOnePlayer;\r\n        }else{ //Otherwise check if the new owner score is greater or equal than the rank one player score.\r\n            if (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\r\n                rankOnePlayerAddress = newOwner;\r\n            }\r\n        }\r\n        \r\n        if (rankOnePlayerAddress != oldRankOnePlayer) {\r\n            isFirstSinceBlock = block.number;\r\n        }\r\n        \r\n\r\n        developersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\r\n        potCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\r\n\r\n        _transfer(oldOwner, newOwner, _cellId);\r\n        \r\n        emit Bought(oldOwner, newOwner);\r\n        \r\n        if (excess > 0) {\r\n          newOwner.transfer(excess);\r\n        }\r\n    }\r\n    \r\n    function distributeToReferreal (uint256 _price, address _referreal) internal returns (bool _isDstributed) {\r\n        if (_referreal != address(0) && _referreal != msg.sender) {\r\n            players[msg.sender].referreal = _referreal;\r\n        }\r\n        \r\n        //Distribute to referreal\r\n        if (players[msg.sender].referreal != address(0)) {\r\n            address ref = players[msg.sender].referreal;\r\n            players[ref].earnings = players[ref].earnings.add(_price.mul(REFERREAL_PERCENTAGE) / 100);\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /* Game */\r\n    function getPlayers () external view returns(uint256[] _scores, uint256[] _lastCellBoughtOnBlock, address[] _addresses, bytes32[] _names) {\r\n        uint256[] memory scores = new uint256[](ranking.length);\r\n        address[] memory addresses = new address[](ranking.length);\r\n        uint256[] memory lastCellBoughtOnBlock = new uint256[](ranking.length);\r\n        bytes32[] memory names = new bytes32[](ranking.length);\r\n        \r\n        for (uint256 i = 0; i < ranking.length; i++) {\r\n            Player memory p = players[ranking[i]];\r\n            \r\n            scores[i] = p.score;\r\n            addresses[i] = ranking[i];\r\n            lastCellBoughtOnBlock[i] = p.lastCellBoughtOnBlockNumber;\r\n            names[i] = p.name;\r\n        }\r\n        \r\n        return (scores, lastCellBoughtOnBlock, addresses, names);\r\n    }\r\n    \r\n    function getCells () external view returns (uint256[] _prices, uint256[] _nextPrice, address[] _owner, bytes32[] _names) {\r\n        uint256[] memory prices = new uint256[](NUMBER_OF_CELLS);\r\n        address[] memory owners = new address[](NUMBER_OF_CELLS);\r\n        bytes32[] memory names = new bytes32[](NUMBER_OF_CELLS);\r\n        uint256[] memory nextPrices = new uint256[](NUMBER_OF_CELLS);\r\n        \r\n        for (uint256 i = 0; i < NUMBER_OF_CELLS; i++) {\r\n             prices[i] = priceOf(i);\r\n             owners[i] = ownerOf(i);\r\n             names[i] = players[ownerOf(i)].name;\r\n             nextPrices[i] = nextPriceOf(i);\r\n        }\r\n        \r\n        return (prices, nextPrices, owners, names);\r\n    }\r\n    \r\n    function getPlayer () external view returns (bytes32 _name, uint256 _score, uint256 _earnings, uint256 _numberOfCellsBought) {\r\n        return (players[msg.sender].name, players[msg.sender].score, earningsOfPlayer(), players[msg.sender].numberOfCellsBought);\r\n    }\r\n    \r\n    function getCurrentPotSize () public view returns (uint256 _wei) {\r\n        return potCut;\r\n    }\r\n    \r\n    function getCurrentWinner () public view returns (address _address) {\r\n        return rankOnePlayerAddress;\r\n    }\r\n    \r\n    function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\r\n        return int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\r\n    }\r\n    \r\n    function scoreOf (address _address) public view returns (uint256 _score) {\r\n        return players[_address].score;\r\n    }\r\n    \r\n    function ownerOf (uint256 _cellId) public view returns (address _owner) {\r\n        return cells[_cellId].owner;\r\n    }\r\n    \r\n    function isGameFinished() public view returns (bool _isGameFinished) {\r\n        return rankOnePlayerAddress != address(0) && getNumberOfBlocksRemainingToWin() < 0;\r\n    }\r\n    \r\n    function calculateScoresIfCellIsBought (address _newOwner, address _oldOwner, uint256 _cellId) internal view returns (uint256 _newOwnerScore, uint256 _oldOwnerScore) {\r\n        //Minus 2 points at the old owner.\r\n        uint256 oldOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\r\n        \r\n        //Plus 2 points at the new owner.\r\n        uint256 newOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\r\n        \r\n        //Calulcate the number of neightbours of _cellId for the old \r\n        //and the new owner, then double the number and multiply it by POINTS_PER_NEIGHBOUR.\r\n        oldOwnerScoreAdjustment = oldOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _oldOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\r\n        newOwnerScoreAdjustment = newOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _newOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\r\n        \r\n        if (_oldOwner == address(0)) {\r\n            oldOwnerScoreAdjustment = 0;\r\n        }\r\n        \r\n        return (scoreOf(_newOwner).add(newOwnerScoreAdjustment), scoreOf(_oldOwner).sub(oldOwnerScoreAdjustment));\r\n    }\r\n    \r\n    //Diagonal is not considered.\r\n    function calculateNumberOfNeighbours(uint256 _cellId, address _address) internal view returns (uint256 _numberOfNeighbours) {\r\n        uint256 numberOfNeighbours;\r\n        \r\n        (uint256 top, uint256 bottom, uint256 left, uint256 right) = getNeighbourhoodOf(_cellId);\r\n        \r\n        if (top != NUMBER_OF_CELLS && ownerOf(top) == _address) {\r\n            numberOfNeighbours = numberOfNeighbours.add(1);\r\n        }\r\n        \r\n        if (bottom != NUMBER_OF_CELLS && ownerOf(bottom) == _address) {\r\n            numberOfNeighbours = numberOfNeighbours.add(1);\r\n        }\r\n        \r\n        if (left != NUMBER_OF_CELLS && ownerOf(left) == _address) {\r\n            numberOfNeighbours = numberOfNeighbours.add(1);\r\n        }\r\n        \r\n        if (right != NUMBER_OF_CELLS && ownerOf(right) == _address) {\r\n            numberOfNeighbours = numberOfNeighbours.add(1);\r\n        }\r\n        \r\n        return numberOfNeighbours;\r\n    }\r\n\r\n    function getNeighbourhoodOf(uint256 _cellId) internal pure returns (uint256 _top, uint256 _bottom, uint256 _left, uint256 _right) {\r\n        //IMPORTANT: The number 'NUMBER_OF_CELLS' is used  to indicate that a cell does not exists.\r\n        \r\n        //Set top cell as non existent.\r\n        uint256 topCellId = NUMBER_OF_CELLS;\r\n        \r\n        //If cell id is not on the first line set the correct _cellId as topCellId.\r\n        if(_cellId >= NUMBER_OF_LINES){\r\n           topCellId = _cellId.sub(NUMBER_OF_LINES);\r\n        }\r\n        \r\n        //Get the cell under _cellId by adding the number of cells per line.\r\n        uint256 bottomCellId = _cellId.add(NUMBER_OF_LINES);\r\n        \r\n        //If it's greater or equal than NUMBER_OF_CELLS bottom cell does not exists.\r\n        if (bottomCellId >= NUMBER_OF_CELLS) {\r\n            bottomCellId = NUMBER_OF_CELLS;\r\n        }\r\n        \r\n        //Set left cell as non existent.\r\n        uint256 leftCellId = NUMBER_OF_CELLS;\r\n        \r\n        //If the remainder of _cellId / NUMBER_OF_LINES is not 0 then _cellId is on\r\n        //not the first column and thus has a left neighbour.\r\n        if ((_cellId % NUMBER_OF_LINES) != 0) {\r\n            leftCellId = _cellId.sub(1);\r\n        }\r\n        \r\n        //Get the cell on the right by adding 1.\r\n        uint256 rightCellId = _cellId.add(1);\r\n\r\n        //If the remainder of rightCellId / NUMBER_OF_LINES is 0 then _cellId is on\r\n        //the last column and thus has no right neighbour.\r\n        if ((rightCellId % NUMBER_OF_LINES) == 0) {\r\n            rightCellId = NUMBER_OF_CELLS;\r\n        }\r\n        \r\n        return (topCellId, bottomCellId, leftCellId, rightCellId);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _cellId) internal {\r\n        require(_cellId < NUMBER_OF_CELLS);\r\n        require(ownerOf(_cellId) == _from);\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        cells[_cellId].owner = _to;\r\n    }\r\n    \r\n    /*Withdraws*/\r\n    function withdrawPot(string _message) public {\r\n        require(!isContract(msg.sender));\r\n        require(msg.sender != owner);\r\n        //A player can withdraw the pot if he is the rank one player\r\n        //and the game is finished.\r\n        require(rankOnePlayerAddress == msg.sender);\r\n        require(isGameFinished());\r\n        \r\n        uint256 toWithdraw = potCut;\r\n        potCut = 0;\r\n        msg.sender.transfer(toWithdraw);\r\n        \r\n        TheEthGameTrophy trophy = TheEthGameTrophy(trophyAddress);\r\n        trophy.award(msg.sender, _message);\r\n    }\r\n    \r\n    function withdrawDevelopersCut () onlyOwner() public {\r\n        uint256 toWithdraw = developersCut;\r\n        developersCut = 0;\r\n        owner.transfer(toWithdraw);\r\n    }\r\n  \r\n    function withdrawEarnings () public {\r\n        distributeEarningsBasedOnScore(msg.sender, address(0));\r\n        distributeEarningsBasedOnNumberOfCells(msg.sender);\r\n        \r\n        uint256 toWithdraw = earningsOfPlayer();\r\n        players[msg.sender].earnings = 0;\r\n        \r\n        msg.sender.transfer(toWithdraw);\r\n    }\r\n    \r\n    /* Player Name */\r\n    function setName(bytes32 _name) public {\r\n        if (nameToAddress[_name] != address(0)) {\r\n            return;\r\n        }\r\n        \r\n        players[msg.sender].name = _name;\r\n        nameToAddress[_name] = msg.sender;\r\n    }\r\n    \r\n    function nameOf(address _address) external view returns(bytes32 _name) {\r\n        return players[_address].name;\r\n    }\r\n    \r\n    function addressOf(bytes32 _name) external view returns (address _address) {\r\n        return nameToAddress[_name];\r\n    }\r\n    \r\n    /* Util */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) } // solium-disable-line\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract TheEthGameTrophy {\r\n    string public name; \r\n    string public description;\r\n    string public message;\r\n    \r\n    address public creator;\r\n    address public owner;\r\n    address public winner;\r\n    uint public rank;\r\n    \r\n    bool private isAwarded = false;\r\n    \r\n    event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\r\n    event Transfer (address indexed _from, address indexed _to);\r\n\r\n    constructor () public {\r\n        name = \"The Eth Game Winner\";\r\n        description = \"2019-08-17\";\r\n        rank = 1;\r\n        creator = msg.sender;\r\n    }\r\n    \r\n    function name() constant public returns (string _name) {\r\n        return name;\r\n    }\r\n    \r\n    function description() constant public returns (string _description) {\r\n        return description;\r\n    }\r\n    \r\n    function message() constant public returns (string _message) {\r\n        return message;\r\n    }\r\n    \r\n    function creator() constant public returns (address _creator) {\r\n        return creator;\r\n    }\r\n    \r\n    function owner() constant public returns (address _owner) {\r\n        return owner;\r\n    }\r\n    \r\n    function winner() constant public returns (address _winner) {\r\n        return winner;\r\n    }\r\n    \r\n    function rank() constant public returns (uint _rank) {\r\n        return rank;\r\n    }\r\n  \r\n    function award(address _address, string _message) public {\r\n        require(msg.sender == creator && !isAwarded);\r\n        isAwarded = true;\r\n        owner = _address;\r\n        winner = _address;\r\n        message = _message;\r\n        \r\n        emit Award(block.number, block.timestamp, _address);\r\n    }\r\n    \r\n    function transfer(address _to) private returns (bool success) {\r\n        require(msg.sender == owner);\r\n        owner = _to;\r\n        emit Transfer(msg.sender, _to);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"numberOfCellsBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"scoreOf\",\"outputs\":[{\"name\":\"_score\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentWinner\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayer\",\"outputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_score\",\"type\":\"uint256\"},{\"name\":\"_earnings\",\"type\":\"uint256\"},{\"name\":\"_numberOfCellsBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCells\",\"outputs\":[{\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"name\":\"_nextPrice\",\"type\":\"uint256[]\"},{\"name\":\"_owner\",\"type\":\"address[]\"},{\"name\":\"_names\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cellId\",\"type\":\"uint256\"}],\"name\":\"nextPriceOf\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cellId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDevelopersCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trophyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cellId\",\"type\":\"uint256\"},{\"name\":\"_referreal\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayers\",\"outputs\":[{\"name\":\"_scores\",\"type\":\"uint256[]\"},{\"name\":\"_lastCellBoughtOnBlock\",\"type\":\"uint256[]\"},{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_names\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cellId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"addressOf\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"withdrawPot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earningsOfPlayer\",\"outputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPotSize\",\"outputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfBlocksRemainingToWin\",\"outputs\":[{\"name\":\"_numberOfBlocks\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGameFinished\",\"outputs\":[{\"name\":\"_isGameFinished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"nameOf\",\"outputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Bought\",\"type\":\"event\"}]","ContractName":"TheEthGame","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7ccd717568d11b6d8882f67766e9b6c998daf22e780bab94199bc108f5c324d9"}]}