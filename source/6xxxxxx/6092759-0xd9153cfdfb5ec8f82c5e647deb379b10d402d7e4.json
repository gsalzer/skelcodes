{"status":"1","message":"OK","result":[{"SourceCode":"/*************************************************************************\r\n * This contract has been merged with solidify\r\n * https://github.com/tiesnetwork/solidify\r\n *************************************************************************/\r\n \r\n pragma solidity ^0.4.18;\r\n\r\n\r\n/*************************************************************************\r\n * import \"zeppelin-solidity/contracts/math/SafeMath.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n/*************************************************************************\r\n * import \"zeppelin-solidity/contracts/math/SafeMath.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"zeppelin-solidity/contracts/token/MintableToken.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n/*************************************************************************\r\n * import \"./StandardToken.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n/*************************************************************************\r\n * import \"./BasicToken.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n/*************************************************************************\r\n * import \"./ERC20Basic.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/*************************************************************************\r\n * import \"./ERC20Basic.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n/*************************************************************************\r\n * import \"./BasicToken.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./ERC20.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/*************************************************************************\r\n * import \"./ERC20.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n/*************************************************************************\r\n * import \"./StandardToken.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../ownership/Ownable.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n/*************************************************************************\r\n * import \"../ownership/Ownable.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n/*************************************************************************\r\n * import \"zeppelin-solidity/contracts/token/MintableToken.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\ncontract HC8 is MintableToken {\r\n\r\n    /* Token constants */\r\n\r\n    string public name = \"Hydrocarbon8\";\r\n\r\n    string public symbol = \"HC8\";\r\n\r\n    uint public decimals = 6;\r\n\r\n    /* Blocks token transfers until ICO is finished.*/\r\n    bool public tokensBlocked = true;\r\n\r\n    // list of addresses with time-freezend tokens\r\n    mapping (address => uint) public teamTokensFreeze;\r\n\r\n    event debugLog(string key, uint value);\r\n\r\n\r\n\r\n\r\n    /* Allow token transfer.*/\r\n    function unblock() external onlyOwner {\r\n        tokensBlocked = false;\r\n    }\r\n\r\n    /* Override some function to add support of blocking .*/\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(!tokensBlocked);\r\n        require(allowTokenOperations(_to));\r\n        require(allowTokenOperations(msg.sender));\r\n        super.transfer(_to, _value);\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(!tokensBlocked);\r\n        require(allowTokenOperations(_from));\r\n        require(allowTokenOperations(_to));\r\n        super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(!tokensBlocked);\r\n        require(allowTokenOperations(_spender));\r\n        super.approve(_spender, _value);\r\n    }\r\n\r\n    // Hold team/founders tokens for defined time\r\n    function freezeTokens(address _holder, uint time) public onlyOwner {\r\n        require(_holder != 0x0);\r\n        teamTokensFreeze[_holder] = time;\r\n    }\r\n\r\n    function allowTokenOperations(address _holder) public constant returns (bool) {\r\n        return teamTokensFreeze[_holder] == 0 || now >= teamTokensFreeze[_holder];\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract HC8ICO {\r\n    using SafeMath for uint;\r\n\r\n    //==========\r\n    // Variables\r\n    //==========\r\n    //States\r\n    enum IcoState {Running, Paused, Failed, Finished}\r\n\r\n    // ico successed\r\n    bool public isSuccess = false;\r\n\r\n    // contract hardcoded owner\r\n    address public owner = 0x07c88CC4316F47131d5D3AD84B3151397E858120;\r\n    address public wallet = 0x81c9Ad6B14F6cBd71155B504e6E88963420f1829;\r\n    address public unsold = 0x7Cb4C67d020042537476Bc13033461ce154bD3e0;\r\n    // Start time\r\n    uint public constant startTime = 1533715688;\r\n    // End time\r\n    uint public endTime = startTime + 60 days;\r\n\r\n    // decimals multiplier for calculation & debug\r\n    uint public constant multiplier = 1000000;\r\n\r\n    // minimal amount of tokens for sale\r\n    uint private constant minTokens = 50  * multiplier;\r\n\r\n    // one million\r\n    uint public constant mln = 1000000;\r\n\r\n    // ICO max tokens for sale\r\n    uint public constant tokensCap = 99 * mln * multiplier;\r\n\r\n    //ICO success\r\n    uint public constant minSuccess = 2 * mln * multiplier;\r\n\r\n    // Amount of sold tokens\r\n    uint public totalSupply = 0;\r\n    // Amount of tokens w/o bonus\r\n    uint public tokensSoldTotal = 0;\r\n\r\n\r\n    // State of ICO - default Running\r\n    IcoState public icoState = IcoState.Running;\r\n\r\n\r\n    // @dev for debug\r\n    uint private constant rateDivider = 1;\r\n\r\n    // initial price in wei\r\n    uint public priceInWei = 2481641572 / rateDivider;\r\n\r\n\r\n    // robot address\r\n    address public _robot = 0x63b247db491D3d3E32A9629509Fb459386Aff921;\r\n\r\n    // if ICO not finished - we must send all old contract eth to new\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // The token being sold\r\n    HC8 public token;\r\n\r\n    // Structure for holding bonuses and tokens for btc investors\r\n    // We can now deprecate rate/bonus_tokens/value without bitcoin holding mechanism - we don't need it\r\n    struct TokensHolder {\r\n    uint value; //amount of wei\r\n    uint tokens; //amount of tokens\r\n    uint bonus; //amount of bonus tokens\r\n    uint total; //total tokens\r\n    uint rate; //conversion rate for hold moment\r\n    uint change; //unused wei amount if tx reaches cap\r\n    }\r\n\r\n    //wei amount\r\n    mapping (address => uint) public investors;\r\n\r\n    struct teamTokens {\r\n    address holder;\r\n    uint freezePeriod;\r\n    uint percent;\r\n    uint divider;\r\n    uint maxTokens;\r\n    }\r\n\r\n    teamTokens[] public listTeamTokens;\r\n\r\n    // Bonus params\r\n    uint[] public bonusPatterns = [80, 60, 40, 20];\r\n\r\n    uint[] public bonusLimit = [5 * mln * multiplier, 10 * mln * multiplier, 15 * mln * multiplier, 20 * mln * multiplier];\r\n\r\n    // flag to prevent team tokens regen with external call\r\n    bool public teamTokensGenerated = false;\r\n\r\n\r\n    //=========\r\n    //Modifiers\r\n    //=========\r\n\r\n    // Active ICO\r\n    modifier ICOActive {\r\n        require(icoState == IcoState.Running);\r\n        require(now >= (startTime));\r\n        require(now <= (endTime));\r\n        _;\r\n    }\r\n\r\n    // Finished ICO\r\n    modifier ICOFinished {\r\n        require(icoState == IcoState.Finished);\r\n        _;\r\n    }\r\n\r\n    // Failed ICO - time is over \r\n    modifier ICOFailed {\r\n        require(now >= (endTime));\r\n        require(icoState == IcoState.Failed || !isSuccess);\r\n        _;\r\n    }\r\n\r\n\r\n    // Allows some methods to be used by team or robot\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTeam() {\r\n        require(msg.sender == owner || msg.sender == _robot);\r\n        _;\r\n    }\r\n\r\n    modifier successICOState() {\r\n        require(isSuccess);\r\n        _;\r\n    }\r\n\r\n    \r\n  \r\n\r\n    //=======\r\n    // Events\r\n    //=======\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint value, uint amount);\r\n\r\n    event RunIco();\r\n\r\n    event PauseIco();\r\n\r\n    event SuccessIco();\r\n\r\n    \r\n    event ICOFails();\r\n\r\n    event updateRate(uint time, uint rate);\r\n\r\n    event debugLog(string key, uint value);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    //========\r\n    // Methods\r\n    //========\r\n\r\n    // Constructor\r\n    function HC8ICO() public {\r\n        token = new HC8();\r\n        //if (owner == 0x0) {//owner not set in contract\r\n        //    owner = msg.sender;\r\n        //}\r\n        //uint freezePeriod;\r\n        //uint percent;\r\n        //uint divider;\r\n        //\r\n\r\n        \r\n        // Company tokens 10%, blocked for 182 days\r\n        listTeamTokens.push(teamTokens(0x1b83619057f2230060ea672E7C03C5DAe8A1eEE6, 182 days, 10, 1, 0));\r\n\r\n        // Company tokens 10%, blocked for 1 year\r\n        listTeamTokens.push(teamTokens(0xB7F2BD192baAe546F5a48570b5d5990be2C31433, 1 years, 10, 1, 0));\r\n\r\n\r\n        // Team tokens 6.667%\r\n        listTeamTokens.push(teamTokens(0xB6e2E9019AC0282Bc20b6874dea8488Db4E41512, 0, 32, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x0adC0CC5E9625E893Ec5C56Ee9D189644FF3744F, 0, 16, 10, 0));\r\n        listTeamTokens.push(teamTokens(0xB5c5C8C3615A48c03BF0F2a30fD1EC3Aea8C5A20, 0, 16, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x79C3659236c51C82b7c0A5CD02932551470fA8cF, 0, 200, 1000, 0));\r\n        listTeamTokens.push(teamTokens(0x644dEd1858174fc9b91d614846d1545Ad510074B, 0, 6670, 100000, 0));\r\n        \r\n        \r\n        // Team tokens 6.667%, blocked for 1 year\r\n        listTeamTokens.push(teamTokens(0xa110C057DD30042eE9c1a8734F5AD14ef4DA7D28, 1 years, 32, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x2323eaD3137195F70aFEC27283649F515D7cdf40, 1 years, 16, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x4A536E9F10c19112C33DEA04BFC62216792a197D, 1 years, 16, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x93c7338D6D23Ed36c6eD5d05C80Dc54BDB2ebCcd, 1 years, 200, 1000, 0));\r\n        listTeamTokens.push(teamTokens(0x3bFF85649F76bf0B6719657D1a7Ea7de4C6F77F5, 1 years, 6670, 100000, 0));\r\n\r\n  \r\n        // Team tokes 6.667%, blocked for 2 years\r\n        listTeamTokens.push(teamTokens(0x1543E108cDA983eA3e4DF7fa599096EBa2BDC26b, 2 years, 32, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x0d05195af835F64cf42bC01276196E7D313Ca572, 2 years, 16, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x5a9447368cF7D1Ae134444263c51E07e8d8091eA, 2 years, 16, 10, 0));\r\n        listTeamTokens.push(teamTokens(0x9293824d3A66Af4fdE6f29Aa016b784408B5cA5F, 2 years, 200, 1000, 0));\r\n        listTeamTokens.push(teamTokens(0x8bbBd613EA5a840FDE29DFa6F6E53E93FE998c7F, 2 years, 6660, 100000, 0));\r\n\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function() public payable ICOActive {\r\n        require(!isReachedLimit());\r\n        TokensHolder memory tokens = calculateTokens(msg.value);\r\n        require(tokens.total > 0);\r\n        token.mint(msg.sender, tokens.total);\r\n        TokenPurchase(msg.sender, msg.sender, tokens.value, tokens.total);\r\n        if (tokens.change > 0 && tokens.change <= msg.value) {\r\n            msg.sender.transfer(tokens.change);\r\n        }\r\n        investors[msg.sender] = investors[msg.sender].add(tokens.value);\r\n        addToStat(tokens.tokens, tokens.bonus);\r\n\t\tdebugLog(\"rate \", priceInWei);\r\n        manageStatus();\r\n    }\r\n\r\n    function hasStarted() public constant returns (bool) {\r\n        return now >= startTime;\r\n    }\r\n\r\n    function hasFinished() public constant returns (bool) {\r\n        return now >= endTime || isReachedLimit();\r\n    }\r\n\r\n    // Calculates amount of bonus tokens\r\n    function getBonus(uint _value, uint _sold) internal constant returns (TokensHolder) {\r\n        TokensHolder memory result;\r\n        uint _bonus = 0;\r\n\r\n        result.tokens = _value;\r\n        for (uint8 i = 0; _value > 0 && i < bonusLimit.length; ++i) {\r\n            uint current_bonus_part = 0;\r\n\r\n            if (_value > 0 && _sold < bonusLimit[i]) {\r\n                uint bonus_left = bonusLimit[i] - _sold;\r\n                uint _bonusedPart = min(_value, bonus_left);\r\n                current_bonus_part = current_bonus_part.add(percent(_bonusedPart, bonusPatterns[i]));\r\n                _value = _value.sub(_bonusedPart);\r\n                _sold = _sold.add(_bonusedPart);                \r\n            }\r\n            if (current_bonus_part > 0) {\r\n                _bonus = _bonus.add(current_bonus_part);\r\n            }\r\n            \r\n        }\r\n        result.bonus = _bonus;\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n    // Are we reached tokens limit?\r\n    function isReachedLimit() internal constant returns (bool) {\r\n        return tokensCap.sub(totalSupply) == 0;\r\n    }\r\n\r\n    function manageStatus() internal {\r\n        if (totalSupply >= minSuccess && !isSuccess) {\r\n            successICO();\r\n        }\r\n        bool capIsReached = (totalSupply == tokensCap);\r\n        if (capIsReached || (now >= endTime)) {\r\n            if (!isSuccess) {\r\n                failICO();\r\n            }\r\n            else {\r\n                finishICO(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateForValue(uint value) public constant returns (uint, uint, uint)\r\n    {\r\n        TokensHolder memory tokens = calculateTokens(value);\r\n        return (tokens.total, tokens.tokens, tokens.bonus);\r\n    }\r\n\r\n    function calculateTokens(uint value) internal constant returns (TokensHolder)\r\n    {\r\n        require(value > 0);\r\n        require(priceInWei * minTokens <= value);\r\n\r\n        uint tokens = value.div(priceInWei);\r\n        require(tokens > 0);\r\n        uint remain = tokensCap.sub(totalSupply);\r\n        uint change = 0;\r\n        uint value_clear = 0;\r\n        if (remain <= tokens) {\r\n            tokens = remain;\r\n            change = value.sub(tokens.mul(priceInWei));\r\n            value_clear = value.sub(change);\r\n        }\r\n        else {\r\n            value_clear = value;\r\n        }\r\n\r\n        TokensHolder memory bonus = getBonus(tokens, tokensSoldTotal);\r\n\r\n        uint total = tokens + bonus.bonus;\r\n        bonus.tokens = tokens;\r\n        bonus.total = total;\r\n        bonus.change = change;\r\n        bonus.rate = priceInWei;\r\n        bonus.value = value_clear;\r\n        return bonus;\r\n\r\n    }\r\n\r\n    // Add tokens&bonus amount to counters\r\n    function addToStat(uint tokens, uint bonus) internal {\r\n        uint total = tokens + bonus;\r\n        totalSupply = totalSupply.add(total);\r\n        //tokensBought = tokensBought.add(tokens.div(multiplier));\r\n        //tokensBonus = tokensBonus.add(bonus.div(multiplier));\r\n        tokensSoldTotal = tokensSoldTotal.add(tokens);\r\n    }\r\n\r\n    // manual start ico after pause\r\n    function startIco() external onlyOwner {\r\n        require(icoState == IcoState.Paused);\r\n        icoState = IcoState.Running;\r\n        RunIco();\r\n    }\r\n\r\n    // manual pause ico\r\n    function pauseIco() external onlyOwner {\r\n        require(icoState == IcoState.Running);\r\n        icoState = IcoState.Paused;\r\n        PauseIco();\r\n    }\r\n\r\n    // auto success ico - cat withdraw ether now\r\n    function successICO() internal\r\n    {\r\n        isSuccess = true;\r\n        SuccessIco();\r\n    }\r\n\r\n\r\n    function finishICO(bool manualFinish) internal successICOState\r\n    {\r\n        if(!manualFinish) {\r\n            bool capIsReached = (totalSupply == tokensCap);\r\n            if (capIsReached && now < endTime) {\r\n                endTime = now;\r\n            }\r\n        } else {\r\n            endTime = now;\r\n        }\r\n        icoState = IcoState.Finished;\r\n        tokensAreFrozen = false;\r\n        // maybe this must be called as external one-time call\r\n        token.unblock();\r\n    }\r\n\r\n    function failICO() internal\r\n    {\r\n        icoState = IcoState.Failed;\r\n        ICOFails();\r\n    }\r\n\r\n\r\n    function refund() public ICOFailed\r\n    {\r\n        require(msg.sender != 0x0);\r\n        require(investors[msg.sender] > 0);\r\n        uint refundVal = investors[msg.sender];\r\n        investors[msg.sender] = 0;\r\n\r\n        uint balance = token.balanceOf(msg.sender);\r\n        totalSupply = totalSupply.sub(balance);\r\n        msg.sender.transfer(refundVal);\r\n\r\n    }\r\n\r\n    // Withdraw allowed only on success\r\n    function withdraw(uint value) external onlyOwner successICOState {\r\n        wallet.transfer(value);\r\n    }\r\n\r\n    // Generates team tokens after ICO finished\r\n    function generateTeamTokens() internal ICOFinished {\r\n        require(!teamTokensGenerated);\r\n        teamTokensGenerated = true;\r\n        if(tokensCap > totalSupply) {\r\n            uint unsoldAmount = tokensCap.sub(totalSupply);\r\n            token.mint(unsold, unsoldAmount);\r\n            //debugLog('unsold ', unsoldAmount);\r\n            totalSupply = totalSupply.add(unsoldAmount);\r\n            \r\n        }\r\n        uint totalSupplyTokens = totalSupply;\r\n        totalSupplyTokens = totalSupplyTokens.mul(100);\r\n        totalSupplyTokens = totalSupplyTokens.div(60);\r\n        \r\n        for (uint8 i = 0; i < listTeamTokens.length; ++i) {\r\n            uint teamTokensPart = percent(totalSupplyTokens, listTeamTokens[i].percent);\r\n\r\n            if (listTeamTokens[i].divider != 0) {\r\n                teamTokensPart = teamTokensPart.div(listTeamTokens[i].divider);\r\n            }\r\n\r\n            if (listTeamTokens[i].maxTokens != 0 && listTeamTokens[i].maxTokens < teamTokensPart) {\r\n                teamTokensPart = listTeamTokens[i].maxTokens;\r\n            }\r\n\r\n            token.mint(listTeamTokens[i].holder, teamTokensPart);\r\n\r\n            \r\n            if(listTeamTokens[i].freezePeriod != 0) {\r\n                token.freezeTokens(listTeamTokens[i].holder, endTime + listTeamTokens[i].freezePeriod);\r\n            }\r\n            addToStat(teamTokensPart, 0);\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n\r\n    //==========================\r\n    // Methods for bots requests\r\n    //==========================\r\n    // set/update robot address\r\n    function setRobot(address robot) public onlyOwner {\r\n        require(robot != 0x0);\r\n        _robot = robot;\r\n    }\r\n\r\n    // update token price in wei\r\n    function setRate(uint newRate) public onlyTeam {\r\n        require(newRate > 0);\r\n        //todo min rate check! 0 - for debug\r\n        priceInWei = newRate;\r\n        updateRate(now, newRate);\r\n    }\r\n\r\n    // mb deprecated\r\n    function robotRefund(address investor) public onlyTeam ICOFailed\r\n    {\r\n        require(investor != 0x0);\r\n        require(investors[investor] > 0);\r\n        uint refundVal = investors[investor];\r\n        investors[investor] = 0;\r\n\r\n        uint balance = token.balanceOf(investor);\r\n        totalSupply = totalSupply.sub(balance);\r\n        investor.transfer(refundVal);\r\n    }\r\n\r\n\r\n    function manualFinish() public onlyTeam successICOState\r\n    {\r\n        require(!hasFinished());\r\n        finishICO(true);\r\n        generateTeamTokens();\r\n    }\r\n\r\n    function autoFinishTime() public onlyTeam\r\n    {\r\n        require(hasFinished());\r\n        manageStatus();\r\n        generateTeamTokens();\r\n    }\r\n\r\n    //========\r\n    // Helpers\r\n    //========\r\n\r\n    // calculation of min value\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n\r\n    function percent(uint value, uint bonus) internal pure returns (uint) {\r\n        return (value * bonus).div(100);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokensCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"robotRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualFinish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"robot\",\"type\":\"address\"}],\"name\":\"setRobot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listTeamTokens\",\"outputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"freezePeriod\",\"type\":\"uint256\"},{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"divider\",\"type\":\"uint256\"},{\"name\":\"maxTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSoldTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calculateForValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_robot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokensGenerated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"autoFinishTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSuccess\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusPatterns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unsold\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAreFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mln\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RunIco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseIco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SuccessIco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOFails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"debugLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HC8ICO","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c9ee006ec32e995dcdf6f3639731d9a590655e6f5f67cb271c23ee5b10a137b1"}]}