{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/vendors/kyber/ERC20Interface.sol\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/vendors/kyber/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    constructor () public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/vendors/kyber/Withdrawable.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/vendors/kyber/Utils.sol\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/vendors/kyber/Utils2.sol\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/vendors/kyber/KyberNetworkInterface.sol\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress,\r\n        uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n// File: contracts/vendors/kyber/KyberNetworkProxyInterface.sol\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n// File: contracts/vendors/kyber/SimpleNetworkInterface.sol\r\n\r\n/// @title simple interface for Kyber Network \r\ninterface SimpleNetworkInterface {\r\n    function swapTokenToToken(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) public payable returns(uint);\r\n    function swapTokenToEther(ERC20 token, uint srcAmount, uint minConversionRate) public returns(uint);\r\n}\r\n\r\n// File: contracts/vendors/kyber/KyberNetworkProxy.sol\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title Kyber Network proxy for main contract\r\ncontract KyberNetworkProxy is KyberNetworkProxyInterface, SimpleNetworkInterface, Withdrawable, Utils2 {\r\n\r\n    KyberNetworkInterface public kyberNetworkContract;\r\n\r\n    function KyberNetworkProxy(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade between src and dest token and send dest tokens to msg sender\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest Destination token\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapTokenToToken(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        uint minConversionRate\r\n    )\r\n        public\r\n        returns(uint)\r\n    {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade from Ether to token. Sends token to msg sender\r\n    /// @param token Destination token\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) public payable returns(uint) {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.value,\r\n            token,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade from token to Ether, sends Ether to msg sender\r\n    /// @param token Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapTokenToEther(ERC20 token, uint srcAmount, uint minConversionRate) public returns(uint) {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            token,\r\n            srcAmount,\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    struct UserBalance {\r\n        uint srcBalance;\r\n        uint destBalance;\r\n    }\r\n\r\n    event ExecuteTrade(address indexed trader, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @param hint will give hints for the trade.\r\n    /// @return amount of actual dest tokens\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId,\r\n        bytes hint\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(src == ETH_TOKEN_ADDRESS || msg.value == 0);\r\n        \r\n        UserBalance memory userBalanceBefore;\r\n\r\n        userBalanceBefore.srcBalance = getBalance(src, msg.sender);\r\n        userBalanceBefore.destBalance = getBalance(dest, destAddress);\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            userBalanceBefore.srcBalance += msg.value;\r\n        } else {\r\n            require(src.transferFrom(msg.sender, kyberNetworkContract, srcAmount));\r\n        }\r\n\r\n        uint reportedDestAmount = kyberNetworkContract.tradeWithHint.value(msg.value)(\r\n            msg.sender,\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId,\r\n            hint\r\n        );\r\n\r\n        TradeOutcome memory tradeOutcome = calculateTradeOutcome(\r\n            userBalanceBefore.srcBalance,\r\n            userBalanceBefore.destBalance,\r\n            src,\r\n            dest,\r\n            destAddress\r\n        );\r\n\r\n        require(reportedDestAmount == tradeOutcome.userDeltaDestAmount);\r\n        require(tradeOutcome.userDeltaDestAmount <= maxDestAmount);\r\n        require(tradeOutcome.actualRate >= minConversionRate);\r\n\r\n        ExecuteTrade(msg.sender, src, dest, tradeOutcome.userDeltaSrcAmount, tradeOutcome.userDeltaDestAmount);\r\n        return tradeOutcome.userDeltaDestAmount;\r\n    }\r\n\r\n    event KyberNetworkSet(address newNetworkContract, address oldNetworkContract);\r\n\r\n    function setKyberNetworkContract(KyberNetworkInterface _kyberNetworkContract) public onlyAdmin {\r\n\r\n        require(_kyberNetworkContract != address(0));\r\n\r\n        KyberNetworkSet(_kyberNetworkContract, kyberNetworkContract);\r\n\r\n        kyberNetworkContract = _kyberNetworkContract;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns(uint expectedRate, uint slippageRate)\r\n    {\r\n        return kyberNetworkContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return kyberNetworkContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) {\r\n        return kyberNetworkContract.getUserCapInTokenWei(user, token);\r\n    }\r\n\r\n    function maxGasPrice() public view returns(uint) {\r\n        return kyberNetworkContract.maxGasPrice();\r\n    }\r\n\r\n    function enabled() public view returns(bool) {\r\n        return kyberNetworkContract.enabled();\r\n    }\r\n\r\n    function info(bytes32 field) public view returns(uint) {\r\n        return kyberNetworkContract.info(field);\r\n    }\r\n\r\n    struct TradeOutcome {\r\n        uint userDeltaSrcAmount;\r\n        uint userDeltaDestAmount;\r\n        uint actualRate;\r\n    }\r\n\r\n    function calculateTradeOutcome (uint srcBalanceBefore, uint destBalanceBefore, ERC20 src, ERC20 dest,\r\n        address destAddress)\r\n        internal returns(TradeOutcome outcome)\r\n    {\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        //protect from underflow\r\n        require(userDestBalanceAfter > destBalanceBefore);\r\n        require(srcBalanceBefore > userSrcBalanceAfter);\r\n\r\n        outcome.userDeltaDestAmount = userDestBalanceAfter - destBalanceBefore;\r\n        outcome.userDeltaSrcAmount = srcBalanceBefore - userSrcBalanceAfter;\r\n\r\n        outcome.actualRate = calcRateFromQty(\r\n                outcome.userDeltaSrcAmount,\r\n                outcome.userDeltaDestAmount,\r\n                getDecimalsSafe(src),\r\n                getDecimalsSafe(dest)\r\n            );\r\n    }\r\n}\r\n\r\n// File: contracts/vendors/kyber/KyberReserveInterface.sol\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\n// File: contracts/vendors/kyber/WhiteListInterface.sol\r\n\r\ncontract WhiteListInterface {\r\n    function getUserCapInWei(address user) external view returns (uint userCapWei);\r\n}\r\n\r\n// File: contracts/vendors/kyber/ExpectedRateInterface.sol\r\n\r\ninterface ExpectedRateInterface {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\n// File: contracts/vendors/kyber/FeeBurnerInterface.sol\r\n\r\ninterface FeeBurnerInterface {\r\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\r\n}\r\n\r\n// File: contracts/vendors/kyber/KyberNetwork.sol\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title Kyber Network main contract\r\ncontract KyberNetwork is Withdrawable, Utils2, KyberNetworkInterface {\r\n\r\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\r\n    KyberReserveInterface[] public reserves;\r\n    mapping(address=>bool) public isReserve;\r\n    WhiteListInterface public whiteListContract;\r\n    ExpectedRateInterface public expectedRateContract;\r\n    FeeBurnerInterface    public feeBurnerContract;\r\n    address               public kyberNetworkProxyContract;\r\n    uint                  public maxGasPriceValue = 50 * 1000 * 1000 * 1000; // 50 gwei\r\n    bool                  public isEnabled = false; // network is enabled\r\n    mapping(bytes32=>uint) public infoFields; // this is only a UI field for external app.\r\n    mapping(address=>address[]) public reservesPerTokenSrc; //reserves supporting token to eth\r\n    mapping(address=>address[]) public reservesPerTokenDest;//reserves support eth to token\r\n\r\n    function KyberNetwork(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    event EtherReceival(address indexed sender, uint amount);\r\n\r\n    /* solhint-disable no-complex-fallback */\r\n    // To avoid users trying to swap tokens using default payable function. We added this short code\r\n    //  to verify Ethers will be received only from reserves if transferred without a specific function call.\r\n    function() public payable {\r\n        require(isReserve[msg.sender]);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }\r\n    /* solhint-enable no-complex-fallback */\r\n\r\n    struct TradeInput {\r\n        address trader;\r\n        ERC20 src;\r\n        uint srcAmount;\r\n        ERC20 dest;\r\n        address destAddress;\r\n        uint maxDestAmount;\r\n        uint minConversionRate;\r\n        address walletId;\r\n        bytes hint;\r\n    }\r\n\r\n    function tradeWithHint(\r\n        address trader,\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId,\r\n        bytes hint\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(hint.length == 0);\r\n        require(msg.sender == kyberNetworkProxyContract);\r\n\r\n        TradeInput memory tradeInput;\r\n\r\n        tradeInput.trader = trader;\r\n        tradeInput.src = src;\r\n        tradeInput.srcAmount = srcAmount;\r\n        tradeInput.dest = dest;\r\n        tradeInput.destAddress = destAddress;\r\n        tradeInput.maxDestAmount = maxDestAmount;\r\n        tradeInput.minConversionRate = minConversionRate;\r\n        tradeInput.walletId = walletId;\r\n        tradeInput.hint = hint;\r\n\r\n        return trade(tradeInput);\r\n    }\r\n\r\n    event AddReserveToNetwork(KyberReserveInterface reserve, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev add or deletes a reserve to/from the network.\r\n    /// @param reserve The reserve address.\r\n    /// @param add If true, the add reserve. Otherwise delete reserve.\r\n    function addReserve(KyberReserveInterface reserve, bool add) public onlyAdmin {\r\n\r\n        if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    event ListReservePairs(address reserve, ERC20 src, ERC20 dest, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserve The reserve address.\r\n    /// @param token token address\r\n    /// @param ethToToken will it support ether to token trade\r\n    /// @param tokenToEth will it support token to ether trade\r\n    /// @param add If true then list this pair, otherwise unlist it.\r\n    function listPairForReserve(address reserve, ERC20 token, bool ethToToken, bool tokenToEth, bool add)\r\n        public onlyAdmin\r\n    {\r\n        require(isReserve[reserve]);\r\n\r\n        if (ethToToken) {\r\n            listPairs(reserve, token, false, add);\r\n\r\n            ListReservePairs(reserve, ETH_TOKEN_ADDRESS, token, add);\r\n        }\r\n\r\n        if (tokenToEth) {\r\n            listPairs(reserve, token, true, add);\r\n            if (add) {\r\n                token.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                token.approve(reserve, 0);\r\n            }\r\n\r\n            ListReservePairs(reserve, token, ETH_TOKEN_ADDRESS, add);\r\n        }\r\n\r\n        setDecimals(token);\r\n    }\r\n\r\n    function setWhiteList(WhiteListInterface whiteList) public onlyAdmin {\r\n        require(whiteList != address(0));\r\n        whiteListContract = whiteList;\r\n    }\r\n\r\n    function setExpectedRate(ExpectedRateInterface expectedRate) public onlyAdmin {\r\n        require(expectedRate != address(0));\r\n        expectedRateContract = expectedRate;\r\n    }\r\n\r\n    function setFeeBurner(FeeBurnerInterface feeBurner) public onlyAdmin {\r\n        require(feeBurner != address(0));\r\n        feeBurnerContract = feeBurner;\r\n    }\r\n\r\n    function setParams(\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_negligibleRateDiff <= 100 * 100); // at most 100%\r\n\r\n        maxGasPriceValue = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n    }\r\n\r\n    function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n            require(kyberNetworkProxyContract != address(0));\r\n        }\r\n        isEnabled = _enable;\r\n    }\r\n\r\n    function setInfo(bytes32 field, uint value) public onlyOperator {\r\n        infoFields[field] = value;\r\n    }\r\n\r\n    event KyberProxySet(address proxy, address sender);\r\n\r\n    function setKyberProxy(address networkProxy) public onlyAdmin {\r\n        require(networkProxy != address(0));\r\n        kyberNetworkProxyContract = networkProxy;\r\n        KyberProxySet(kyberNetworkProxyContract, msg.sender);\r\n    }\r\n\r\n    /// @dev returns number of reserves\r\n    /// @return number of reserves\r\n    function getNumReserves() public view returns(uint) {\r\n        return reserves.length;\r\n    }\r\n\r\n    /// @notice should be called off chain with as much gas as needed\r\n    /// @dev get an array of all reserves\r\n    /// @return An array of all reserves\r\n    function getReserves() public view returns(KyberReserveInterface[]) {\r\n        return reserves;\r\n    }\r\n\r\n    function maxGasPrice() public view returns(uint) {\r\n        return maxGasPriceValue;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns(uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) {\r\n        //future feature\r\n        user;\r\n        token;\r\n        require(false);\r\n    }\r\n\r\n    struct BestRateResult {\r\n        uint rate;\r\n        address reserve1;\r\n        address reserve2;\r\n        uint weiAmount;\r\n        uint rateSrcToEth;\r\n        uint rateEthToDest;\r\n        uint destAmount;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /// @return obsolete - used to return best reserve index. not relevant anymore for this API.\r\n    function findBestRate(ERC20 src, ERC20 dest, uint srcAmount) public view returns(uint obsolete, uint rate) {\r\n        BestRateResult memory result = findBestRateTokenToToken(src, dest, srcAmount);\r\n        return(0, result.rate);\r\n    }\r\n\r\n    function enabled() public view returns(bool) {\r\n        return isEnabled;\r\n    }\r\n\r\n    function info(bytes32 field) public view returns(uint) {\r\n        return infoFields[field];\r\n    }\r\n\r\n    /* solhint-disable code-complexity */\r\n    // Not sure how solhing defines complexity. Anyway, from our point of view, below code follows the required\r\n    //  algorithm to choose a reserve, it has been tested, reviewed and found to be clear enough.\r\n    //@dev this function always src or dest are ether. can't do token to token\r\n    function searchBestRate(ERC20 src, ERC20 dest, uint srcAmount) public view returns(address, uint) {\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n\r\n        //return 1 for ether to ether\r\n        if (src == dest) return (reserves[bestReserve], PRECISION);\r\n\r\n        address[] memory reserveArr;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            reserveArr = reservesPerTokenDest[dest];\r\n        } else {\r\n            reserveArr = reservesPerTokenSrc[src];\r\n        }\r\n\r\n        if (reserveArr.length == 0) return (reserves[bestReserve], bestRate);\r\n\r\n        uint[] memory rates = new uint[](reserveArr.length);\r\n        uint[] memory reserveCandidates = new uint[](reserveArr.length);\r\n\r\n        for (uint i = 0; i < reserveArr.length; i++) {\r\n            //list all reserves that have this token.\r\n            rates[i] = (KyberReserveInterface(reserveArr[i])).getConversionRate(src, dest, srcAmount, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < reserveArr.length; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (reserveArr[bestReserve], bestRate);\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function findBestRateTokenToToken(ERC20 src, ERC20 dest, uint srcAmount) internal view\r\n        returns(BestRateResult result)\r\n    {\r\n        (result.reserve1, result.rateSrcToEth) = searchBestRate(src, ETH_TOKEN_ADDRESS, srcAmount);\r\n        result.weiAmount = calcDestAmount(src, ETH_TOKEN_ADDRESS, srcAmount, result.rateSrcToEth);\r\n\r\n        (result.reserve2, result.rateEthToDest) = searchBestRate(ETH_TOKEN_ADDRESS, dest, result.weiAmount);\r\n        result.destAmount = calcDestAmount(ETH_TOKEN_ADDRESS, dest, result.weiAmount, result.rateEthToDest);\r\n\r\n        result.rate = calcRateFromQty(srcAmount, result.destAmount, getDecimals(src), getDecimals(dest));\r\n    }\r\n\r\n    function listPairs(address reserve, ERC20 token, bool isTokenToEth, bool add) internal {\r\n        uint i;\r\n        address[] storage reserveArr = reservesPerTokenDest[token];\r\n\r\n        if (isTokenToEth) {\r\n            reserveArr = reservesPerTokenSrc[token];\r\n        }\r\n\r\n        for (i = 0; i < reserveArr.length; i++) {\r\n            if (reserve == reserveArr[i]) {\r\n                if (add) {\r\n                    break; //already added\r\n                } else {\r\n                    //remove\r\n                    reserveArr[i] = reserveArr[reserveArr.length - 1];\r\n                    reserveArr.length--;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (add && i == reserveArr.length) {\r\n            //if reserve wasn't found add it\r\n            reserveArr.push(reserve);\r\n        }\r\n    }\r\n\r\n    event KyberTrade(address srcAddress, ERC20 srcToken, uint srcAmount, address destAddress, ERC20 destToken,\r\n        uint destAmount);\r\n    /* solhint-disable function-max-lines */\r\n    // Most of the lins here are functions calls spread over multiple lines. We find this function readable enough\r\n    //  and keep its size as is.\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev trade api for kyber network.\r\n    /// @param tradeInput structure of trade inputs\r\n    function trade(TradeInput tradeInput) internal returns(uint) {\r\n        require(isEnabled);\r\n        require(tx.gasprice <= maxGasPriceValue);\r\n        require(validateTradeInput(tradeInput.src, tradeInput.srcAmount, tradeInput.dest, tradeInput.destAddress));\r\n\r\n        BestRateResult memory rateResult =\r\n        findBestRateTokenToToken(tradeInput.src, tradeInput.dest, tradeInput.srcAmount);\r\n\r\n        require(rateResult.rate > 0);\r\n        require(rateResult.rate < MAX_RATE);\r\n        require(rateResult.rate >= tradeInput.minConversionRate);\r\n\r\n        uint actualDestAmount;\r\n        uint weiAmount;\r\n        uint actualSrcAmount;\r\n\r\n        (actualSrcAmount, weiAmount, actualDestAmount) = calcActualAmounts(tradeInput.src,\r\n            tradeInput.dest,\r\n            tradeInput.srcAmount,\r\n            tradeInput.maxDestAmount,\r\n            rateResult);\r\n\r\n        if (actualSrcAmount < tradeInput.srcAmount) {\r\n            //if there is \"change\" send back to trader\r\n            if (tradeInput.src == ETH_TOKEN_ADDRESS) {\r\n                tradeInput.trader.transfer(tradeInput.srcAmount - actualSrcAmount);\r\n            } else {\r\n                tradeInput.src.transfer(tradeInput.trader, (tradeInput.srcAmount - actualSrcAmount));\r\n            }\r\n        }\r\n\r\n        // verify trade size is smaller than user cap\r\n        require(weiAmount <= getUserCapInWei(tradeInput.trader));\r\n\r\n        //do the trade\r\n        //src to ETH\r\n        require(doReserveTrade(\r\n                tradeInput.src,\r\n                actualSrcAmount,\r\n                ETH_TOKEN_ADDRESS,\r\n                this,\r\n                weiAmount,\r\n                KyberReserveInterface(rateResult.reserve1),\r\n                rateResult.rateSrcToEth,\r\n                true));\r\n\r\n        //Eth to dest\r\n        require(doReserveTrade(\r\n                ETH_TOKEN_ADDRESS,\r\n                weiAmount,\r\n                tradeInput.dest,\r\n                tradeInput.destAddress,\r\n                actualDestAmount,\r\n                KyberReserveInterface(rateResult.reserve2),\r\n                rateResult.rateEthToDest,\r\n                true));\r\n\r\n        //when src is ether, reserve1 is doing a \"fake\" trade. (ether to ether) - don't burn.\r\n        //when dest is ether, reserve2 is doing a \"fake\" trade. (ether to ether) - don't burn.\r\n        if (tradeInput.src != ETH_TOKEN_ADDRESS)\r\n            require(feeBurnerContract.handleFees(weiAmount, rateResult.reserve1, tradeInput.walletId));\r\n        if (tradeInput.dest != ETH_TOKEN_ADDRESS)\r\n            require(feeBurnerContract.handleFees(weiAmount, rateResult.reserve2, tradeInput.walletId));\r\n\r\n        KyberTrade(tradeInput.trader, tradeInput.src, actualSrcAmount, tradeInput.destAddress, tradeInput.dest,\r\n            actualDestAmount);\r\n\r\n        return actualDestAmount;\r\n    }\r\n    /* solhint-enable function-max-lines */\r\n\r\n    function calcActualAmounts (ERC20 src, ERC20 dest, uint srcAmount, uint maxDestAmount, BestRateResult rateResult)\r\n        internal view returns(uint actualSrcAmount, uint weiAmount, uint actualDestAmount)\r\n    {\r\n        if (rateResult.destAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            weiAmount = calcSrcAmount(ETH_TOKEN_ADDRESS, dest, actualDestAmount, rateResult.rateEthToDest);\r\n            actualSrcAmount = calcSrcAmount(src, ETH_TOKEN_ADDRESS, weiAmount, rateResult.rateSrcToEth);\r\n            require(actualSrcAmount <= srcAmount);\r\n        } else {\r\n            actualDestAmount = rateResult.destAmount;\r\n            actualSrcAmount = srcAmount;\r\n            weiAmount = rateResult.weiAmount;\r\n        }\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a reserve\r\n    /// @param src Src token\r\n    /// @param amount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param reserve Reserve to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is successful\r\n    function doReserveTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserveInterface reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n\r\n        if (src == dest) {\r\n            //this is for a \"fake\" trade when both src and dest are ethers.\r\n            if (destAddress != (address(this)))\r\n                destAddress.transfer(amount);\r\n            return true;\r\n        }\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (destAddress != address(this)) {\r\n            //for token to token dest address is network. and Ether / token already here...\r\n            if (dest == ETH_TOKEN_ADDRESS) {\r\n                destAddress.transfer(expectedDestAmount);\r\n            } else {\r\n                require(dest.transfer(destAddress, expectedDestAmount));\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @return true if tradeInput is valid\r\n    function validateTradeInput(ERC20 src, uint srcAmount, ERC20 dest, address destAddress)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(srcAmount != 0);\r\n        require(destAddress != address(0));\r\n        require(src != dest);\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == srcAmount);\r\n        } else {\r\n            require(msg.value == 0);\r\n            //funds should have been moved to this contract already.\r\n            require(src.balanceOf(this) >= srcAmount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/Token.sol\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\n// File: contracts/interfaces/TokenConverter.sol\r\n\r\ncontract TokenConverter {\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);\r\n    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);\r\n}\r\n\r\n// File: contracts/interfaces/AvailableProvider.sol\r\n\r\ninterface AvailableProvider {\r\n   function isAvailable(Token _from, Token _to, uint256 _amount) external view returns (bool);\r\n}\r\n\r\n// File: contracts/utils/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event SetOwner(address _owner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"msg.sender is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit SetOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev Transfers the ownership of the contract.\r\n\r\n        @param _to Address of the new owner\r\n    */\r\n    function transferTo(address _to) public onlyOwner returns (bool) {\r\n        require(_to != address(0), \"Can't transfer to address 0x0\");\r\n        emit SetOwner(_to);\r\n        owner = _to;\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/KyberProxy.sol\r\n\r\ncontract KyberConverter is TokenConverter, AvailableProvider, Ownable {\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    KyberNetworkProxy kyber;\r\n\r\n    event Swap(address indexed sender, ERC20 srcToken, ERC20 destToken, uint amount);\r\n\r\n    event WithdrawTokens(address _token, address _to, uint256 _amount);\r\n    event WithdrawEth(address _to, uint256 _amount);\r\n    event SetKyber(address _kyber);\r\n\r\n    constructor (KyberNetworkProxy _kyber) public {\r\n        kyber = _kyber;\r\n        emit SetKyber(_kyber);\r\n    }\r\n\r\n    function setKyber(KyberNetworkProxy _kyber) external onlyOwner returns (bool) {\r\n        kyber = _kyber;\r\n        emit SetKyber(_kyber);\r\n        return true;\r\n    }\r\n\r\n    function isAvailable(Token, Token, uint256) external view returns (bool) {\r\n        KyberNetworkProxy _kyber = kyber;\r\n        return tx.gasprice <= _kyber.maxGasPrice() && _kyber.enabled();\r\n    }\r\n\r\n    function getReturn(\r\n        Token from,\r\n        Token to, \r\n        uint256 srcQty\r\n    ) external view returns (uint256) {\r\n        ERC20 srcToken = ERC20(from);\r\n        ERC20 destToken = ERC20(to);   \r\n        (uint256 amount,) = kyber.getExpectedRate(srcToken, destToken, srcQty);\r\n        return amount;\r\n    }\r\n\r\n    function convert(\r\n        Token from,\r\n        Token to, \r\n        uint256 srcQty, \r\n        uint256 minReturn\r\n    ) external payable returns (uint256 destAmount) {\r\n\r\n        ERC20 srcToken = ERC20(from);\r\n        ERC20 destToken = ERC20(to);       \r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS && destToken != ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == srcQty, \"ETH not enought\");\r\n            execSwapEtherToToken(srcToken, srcQty, msg.sender);\r\n        } else if (srcToken != ETH_TOKEN_ADDRESS && destToken == ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == 0, \"ETH not required\");    \r\n            execSwapTokenToEther(srcToken, srcQty, destToken);\r\n        } else {\r\n            require(msg.value == 0, \"ETH not required\");    \r\n            execSwapTokenToToken(srcToken, srcQty, destToken, msg.sender);\r\n        }\r\n\r\n        require(destAmount > minReturn, \"Return amount too low\");   \r\n        emit Swap(msg.sender, srcToken, destToken, destAmount);\r\n    \r\n        return destAmount;\r\n    }\r\n\r\n    /*\r\n    @dev Swap the user's ETH to ERC20 token\r\n    @param token destination token contract address\r\n    @param destAddress address to send swapped tokens to\r\n    */\r\n    function execSwapEtherToToken(\r\n        ERC20 token, \r\n        uint srcQty,\r\n        address destAddress\r\n    ) internal returns (uint) {\r\n\r\n        (uint minConversionRate,) = kyber.getExpectedRate(ETH_TOKEN_ADDRESS, token, srcQty);\r\n\r\n        // Swap the ETH to ERC20 token\r\n        uint destAmount = kyber.swapEtherToToken.value(srcQty)(token, minConversionRate);\r\n\r\n        // Send the swapped tokens to the destination address\r\n        require(token.transfer(destAddress, destAmount), \"Error sending tokens\");\r\n\r\n        return destAmount;\r\n\r\n    }\r\n\r\n    /*\r\n    @dev Swap the user's ERC20 token to ETH\r\n    @param token source token contract address\r\n    @param tokenQty amount of source tokens\r\n    @param destAddress address to send swapped ETH to\r\n    */\r\n    function execSwapTokenToEther(\r\n        ERC20 token, \r\n        uint256 tokenQty, \r\n        address destAddress\r\n    ) internal returns (uint) {\r\n            \r\n        // Check that the player has transferred the token to this contract\r\n        require(token.transferFrom(msg.sender, this, tokenQty), \"Error pulling tokens\");\r\n\r\n        // Set the spender's token allowance to tokenQty\r\n        require(token.approve(kyber, tokenQty), \"Error pulling tokens\");\r\n\r\n        (uint minConversionRate,) = kyber.getExpectedRate(token, ETH_TOKEN_ADDRESS, tokenQty);\r\n\r\n        // Swap the ERC20 token to ETH\r\n        uint destAmount = kyber.swapTokenToEther(token, tokenQty, minConversionRate);\r\n\r\n        // Send the swapped ETH to the destination address\r\n        require(destAddress.send(destAmount), \"Error sending ETH\");\r\n\r\n        return destAmount;\r\n\r\n    }\r\n\r\n    /*\r\n    @dev Swap the user's ERC20 token to another ERC20 token\r\n    @param srcToken source token contract address\r\n    @param srcQty amount of source tokens\r\n    @param destToken destination token contract address\r\n    @param destAddress address to send swapped tokens to\r\n    */\r\n    function execSwapTokenToToken(\r\n        ERC20 srcToken, \r\n        uint256 srcQty, \r\n        ERC20 destToken, \r\n        address destAddress\r\n    ) internal returns (uint) {\r\n\r\n        // Check that the player has transferred the token to this contract\r\n        require(srcToken.transferFrom(msg.sender, this, srcQty), \"Error pulling tokens\");\r\n\r\n        // Set the spender's token allowance to tokenQty\r\n        require(srcToken.approve(kyber, srcQty), \"Error approve transfer tokens\");\r\n\r\n        (uint minConversionRate,) = kyber.getExpectedRate(srcToken, ETH_TOKEN_ADDRESS, srcQty);\r\n\r\n        // Swap the ERC20 token to ERC20\r\n        uint destAmount = kyber.swapTokenToToken(srcToken, srcQty, destToken, minConversionRate);\r\n\r\n        // Send the swapped tokens to the destination address\r\n        require(destToken.transfer(destAddress, destAmount), \"Error sending tokens\");\r\n\r\n        return destAmount;\r\n    }\r\n\r\n    function withdrawTokens(\r\n        Token _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner returns (bool) {\r\n        emit WithdrawTokens(_token, _to, _amount);\r\n        return _token.transfer(_to, _amount);\r\n    }\r\n\r\n    function withdrawEther(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        emit WithdrawEth(_to, _amount);\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function setConverter(\r\n        KyberNetworkProxy _converter\r\n    ) public onlyOwner returns (bool) {\r\n        kyber = _converter;\r\n    }\r\n\r\n    function getConverter() public view returns (address) {\r\n        return address(kyber);\r\n    }\r\n\r\n    function() external payable {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kyber\",\"type\":\"address\"}],\"name\":\"setKyber\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"},{\"name\":\"minReturn\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"destAmount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"setConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_kyber\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_kyber\",\"type\":\"address\"}],\"name\":\"SetKyber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"}]","ContractName":"KyberConverter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755","Library":"","SwarmSource":"bzzr://f9ca6c29e3ae1b0b4595b0a7881cbf433c31add7b818cb8c687600fbe712d2a8"}]}