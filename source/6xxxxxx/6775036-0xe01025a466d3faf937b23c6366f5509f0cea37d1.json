{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary DataSet {\r\n\r\n    enum RoundState {\r\n        UNKNOWN,        // aim to differ from normal states\r\n        STARTED,        // start current round\r\n        STOPPED,        // stop current round\r\n        DRAWN,          // draw winning number\r\n        ASSIGNED        // assign to foundation, winner\r\n    }\r\n\r\n    struct Round {\r\n        uint256                         count;              // record total numbers sold already\r\n        uint256                         timestamp;          // timestamp refer to first bet(round start)\r\n        uint256                         blockNumber;        // block number refer to last bet\r\n        uint256                         drawBlockNumber;    // block number refer to draw winning number\r\n        RoundState                      state;              // round state\r\n        uint256                         pond;               // amount refer to current round\r\n        uint256                         winningNumber;      // winning number\r\n        address                         winner;             // winner's address\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title NumberCompressor\r\n * @dev Number compressor to storage the begin and end numbers into a uint256\r\n */\r\nlibrary NumberCompressor {\r\n\r\n    uint256 constant private MASK = 16777215;   // 2 ** 24 - 1\r\n\r\n    function encode(uint256 _begin, uint256 _end, uint256 _ceiling) internal pure returns (uint256)\r\n    {\r\n        require(_begin <= _end && _end < _ceiling, \"number is invalid\");\r\n\r\n        return _begin << 24 | _end;\r\n    }\r\n\r\n    function decode(uint256 _value) internal pure returns (uint256, uint256)\r\n    {\r\n        uint256 end = _value & MASK;\r\n        uint256 begin = (_value >> 24) & MASK;\r\n        return (begin, end);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\ncontract Events {\r\n\r\n    event onActivate\r\n    (\r\n        address indexed addr,\r\n        uint256 timestamp,\r\n        uint256 bonus,\r\n        uint256 issued_numbers\r\n    );\r\n\r\n    event onDraw\r\n    (\r\n        uint256 timestatmp,\r\n        uint256 blockNumber,\r\n        uint256 roundID,\r\n        uint256 winningNumber\r\n    );\r\n\r\n    event onStartRunnd\r\n    (\r\n        uint256 timestamp,\r\n        uint256 roundID\r\n    );\r\n\r\n    event onBet\r\n    (\r\n        address indexed addr,\r\n        uint256 timestamp,\r\n        uint256 roundID,\r\n        uint256 beginNumber,\r\n        uint256 endNumber\r\n    );\r\n\r\n    event onAssign\r\n    (\r\n        address indexed operatorAddr,\r\n        uint256 timestatmp,\r\n        address indexed winnerAddr,\r\n        uint256 roundID,\r\n        uint256 pond,\r\n        uint256 bonus,      // assigned to winner\r\n        uint256 fund        // assigned to platform\r\n    );\r\n\r\n    event onRefund\r\n    (\r\n        address indexed operatorAddr,\r\n        uint256 timestamp,\r\n        address indexed playerAddr,\r\n        uint256 count,\r\n        uint256 amount\r\n    );\r\n\r\n    event onLastRefund\r\n    (\r\n        address indexed operatorAddr,\r\n        uint256 timestamp,\r\n        address indexed platformAddr,\r\n        uint256 amout\r\n    );\r\n\r\n}\r\n\r\ncontract Winner is Events {\r\n\r\n    using SafeMath for *;\r\n\r\n    uint256     constant private    MIN_BET = 0.01 ether;                                   // min bet every time\r\n    uint256     constant private    PRICE   = 0.01 ether;                                   // 0.01 ether every number\r\n    uint256     constant private    MAX_DURATION = 30 days;                                 // max duration every round\r\n    uint256     constant private    REFUND_RATE = 90;                                       // refund rate to player(%)\r\n    address     constant private    platform = 0xD51bD6EB7aA3661c9c5726403315F0B0f8d96C2e;  // paltform's address\r\n    uint256     private             curRoundID;                                             // current round\r\n    uint256     private             drawnRoundID;                                           // already drawn round\r\n    uint256     private             drawnBlockNumber;                                       // already drawn a round in block\r\n    uint256     private             bonus;                                                  // bonus assigned to the winner\r\n    uint256     private             issued_numbers;                                         // total numbers every round\r\n    bool        private             initialized;                                            // game is initialized or not\r\n\r\n    // (roundID => data) returns round data\r\n    mapping (uint256 => DataSet.Round) private rounds;\r\n    // (roundID => address => numbers) returns player's numbers in round\r\n    mapping (uint256 => mapping(address => uint256[])) private playerNumbers;\r\n    mapping (address => bool) private administrators;\r\n\r\n    // default constructor\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n     * @dev check sender must be administrators\r\n     */\r\n    modifier isAdmin() {\r\n        require(administrators[msg.sender], \"only administrators\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev make sure no one can interact with contract until it has\r\n     * been initialized.\r\n     */\r\n    modifier isInitialized () {\r\n        require(initialized == true, \"game is inactive\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevent contract from interacting with external contracts.\r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry, humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check the bet's bound\r\n     * @param _eth the eth amount\r\n     * In order to ensure as many as possiable players envolve in the\r\n     * game, you can only buy no more than 2 * issued_numbers every time.\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= MIN_BET, \"the bet is too small\");\r\n        require(_eth <= PRICE.mul(issued_numbers).mul(2), \"the bet is too big\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev default to bet\r\n     */\r\n    function() public payable isHuman() isInitialized() isWithinLimits(msg.value)\r\n    {\r\n        bet(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev initiate game\r\n     * @param _bonus the bonus assigned the winner every round\r\n     * @param _issued_numbers the quantity of candidate numbers every round\r\n     */\r\n    function initiate(uint256 _bonus, uint256 _issued_numbers) public isHuman()\r\n    {\r\n        // can only be initialized once\r\n        require(initialized == false, \"it has been initialized already\");\r\n        require(_bonus > 0, \"bonus is invalid\");\r\n        require(_issued_numbers > 0, \"issued_numbers is invalid\");\r\n\r\n        // initiate global parameters\r\n        initialized = true;\r\n        administrators[msg.sender] = true;\r\n        bonus = _bonus;\r\n        issued_numbers = _issued_numbers;\r\n\r\n        emit onActivate(msg.sender, block.timestamp, bonus, issued_numbers);\r\n\r\n        // start the first round game\r\n        curRoundID = 1;\r\n        rounds[curRoundID].state = DataSet.RoundState.STARTED;\r\n        rounds[curRoundID].timestamp = block.timestamp;\r\n        drawnRoundID = 0;\r\n\r\n        emit onStartRunnd(block.timestamp, curRoundID);\r\n    }\r\n\r\n    /**\r\n     * @dev draw winning number\r\n     */\r\n    function drawNumber() private view returns(uint256) {\r\n        return uint256(keccak256(abi.encodePacked(\r\n\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 1))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 2))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 3))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 4))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 5))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 6))))) / (block.timestamp))\r\n\r\n        ))) % issued_numbers;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev bet\r\n     * @param _amount the amount for a bet\r\n     */\r\n    function bet(uint256 _amount) private\r\n    {\r\n        // 1. draw the winning number if it is necessary\r\n        if (block.number != drawnBlockNumber\r\n            && curRoundID > drawnRoundID\r\n            && rounds[drawnRoundID + 1].count == issued_numbers\r\n            && block.number >= rounds[drawnRoundID + 1].blockNumber + 7)\r\n        {\r\n            drawnBlockNumber = block.number;\r\n            drawnRoundID += 1;\r\n\r\n            rounds[drawnRoundID].winningNumber = drawNumber();\r\n            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;\r\n            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;\r\n\r\n            emit onDraw(block.timestamp, drawnBlockNumber, drawnRoundID, rounds[drawnRoundID].winningNumber);\r\n        }\r\n\r\n        // 2. bet\r\n        uint256 amount = _amount;\r\n        while (true)\r\n        {\r\n            // in every round, one can buy min(max, available) numbers.\r\n            uint256 max = issued_numbers - rounds[curRoundID].count;\r\n            uint256 available = amount.div(PRICE).min(max);\r\n\r\n            if (available == 0)\r\n            {\r\n                // on condition that the PRICE is 0.01 eth, if the player pays 0.056 eth for\r\n                // a bet, then the player can exchange only five number, as 0.056/0.01 = 5,\r\n                // and the rest 0.06 eth distributed to the pond of current round.\r\n                if (amount != 0)\r\n                {\r\n                    rounds[curRoundID].pond += amount;\r\n                }\r\n                break;\r\n            }\r\n            uint256[] storage numbers = playerNumbers[curRoundID][msg.sender];\r\n            uint256 begin = rounds[curRoundID].count;\r\n            uint256 end = begin + available - 1;\r\n            uint256 compressedNumber = NumberCompressor.encode(begin, end, issued_numbers);\r\n            numbers.push(compressedNumber);\r\n            rounds[curRoundID].pond += available.mul(PRICE);\r\n            rounds[curRoundID].count += available;\r\n            amount -= available.mul(PRICE);\r\n\r\n            emit onBet(msg.sender, block.timestamp, curRoundID, begin, end);\r\n\r\n            if (rounds[curRoundID].count == issued_numbers)\r\n            {\r\n                // end current round and start the next round\r\n                rounds[curRoundID].blockNumber = block.number;\r\n                rounds[curRoundID].state = DataSet.RoundState.STOPPED;\r\n                curRoundID += 1;\r\n                rounds[curRoundID].state = DataSet.RoundState.STARTED;\r\n                rounds[curRoundID].timestamp = block.timestamp;\r\n\r\n                emit onStartRunnd(block.timestamp, curRoundID);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev assign for a round\r\n     * @param _roundID the round ID\r\n     */\r\n    function assign(uint256 _roundID) external isHuman() isInitialized()\r\n    {\r\n        assign2(msg.sender, _roundID);\r\n    }\r\n\r\n    /**\r\n     * @dev assign for a round\r\n     * @param _player the player's address\r\n     * @param _roundID the round ID\r\n     */\r\n    function assign2(address _player, uint256 _roundID) public isHuman() isInitialized()\r\n    {\r\n        require(rounds[_roundID].state == DataSet.RoundState.DRAWN, \"it's not time for assigning\");\r\n\r\n        uint256[] memory numbers = playerNumbers[_roundID][_player];\r\n        require(numbers.length > 0, \"player did not involve in\");\r\n        uint256 targetNumber = rounds[_roundID].winningNumber;\r\n        for (uint256 i = 0; i < numbers.length; i ++)\r\n        {\r\n            (uint256 start, uint256 end) = NumberCompressor.decode(numbers[i]);\r\n            if (targetNumber >= start && targetNumber <= end)\r\n            {\r\n                // assgin bonus to player, and the rest of the pond to platform\r\n                uint256 fund = rounds[_roundID].pond.sub(bonus);\r\n                _player.transfer(bonus);\r\n                platform.transfer(fund);\r\n                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;\r\n                rounds[_roundID].winner = _player;\r\n\r\n                emit onAssign(msg.sender, block.timestamp, _player, _roundID, rounds[_roundID].pond, bonus, fund);\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev refund to player and platform\r\n     */\r\n    function refund() external isHuman() isInitialized()\r\n    {\r\n        refund2(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev refund to player and platform\r\n     * @param _player the player's address\r\n     */\r\n    function refund2(address _player) public isInitialized() isHuman()\r\n    {\r\n        require(block.timestamp.sub(rounds[curRoundID].timestamp) >= MAX_DURATION, \"it's not time for refunding\");\r\n\r\n        // 1. count numbers owned by the player\r\n        uint256[] storage numbers = playerNumbers[curRoundID][_player];\r\n        require(numbers.length > 0, \"player did not involve in\");\r\n\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < numbers.length; i ++)\r\n        {\r\n            (uint256 begin, uint256 end) = NumberCompressor.decode(numbers[i]);\r\n            count += (end - begin + 1);\r\n        }\r\n\r\n        // 2. refund 90% to the player\r\n        uint256 amount = count.mul(PRICE).mul(REFUND_RATE).div(100);\r\n        rounds[curRoundID].pond = rounds[curRoundID].pond.sub(amount);\r\n        _player.transfer(amount);\r\n\r\n        emit onRefund(msg.sender, block.timestamp, _player, count, amount);\r\n\r\n        // 3. refund the rest(abount 10% of the pond) to the platform if the player is the last to refund\r\n        rounds[curRoundID].count -= count;\r\n        if (rounds[curRoundID].count == 0)\r\n        {\r\n            uint256 last = rounds[curRoundID].pond;\r\n            platform.transfer(last);\r\n            rounds[curRoundID].pond = 0;\r\n\r\n            emit onLastRefund(msg.sender, block.timestamp, platform, last);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev return player's numbers in the round\r\n     * @param _roundID round ID\r\n     * @param _palyer player's address\r\n     * @return uint256[], player's numbers\r\n     */\r\n    function getPlayerRoundNumbers(uint256 _roundID, address _palyer) public view returns(uint256[])\r\n    {\r\n        return playerNumbers[_roundID][_palyer];\r\n    }\r\n\r\n    /**\r\n     * @dev return round's information\r\n     * @param _roundID round ID\r\n     * @return uint256, quantity of round's numbers\r\n     * @return uint256, block number refer to last bet\r\n     * @return uint256, block number refer to draw winning number\r\n     * @return uint256, round's running state\r\n     * @return uint256, round's pond\r\n     * @return uint256, round's winning number if drawn\r\n     * @return address, round's winner if assigned\r\n     */\r\n    function getRoundInfo(uint256 _roundID) public view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, address)\r\n    {\r\n        return (\r\n            rounds[_roundID].count,\r\n            rounds[_roundID].blockNumber,\r\n            rounds[_roundID].drawBlockNumber,\r\n            uint256(rounds[_roundID].state),\r\n            rounds[_roundID].pond,\r\n            rounds[_roundID].winningNumber,\r\n            rounds[_roundID].winner\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev return game's information\r\n     * @return bool, game is active or not\r\n     * @return uint256, bonus assigned to the winner\r\n     * @return uint256, total numbers every round\r\n     * @return uint256, current round ID\r\n     * @return uint256, already drawn round ID\r\n     */\r\n    function gameInfo() public view\r\n        returns(bool, uint256, uint256, uint256, uint256)\r\n    {\r\n        return (\r\n            initialized,\r\n            bonus,\r\n            issued_numbers,\r\n            curRoundID,\r\n            drawnRoundID\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () public payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0), \"address invalid\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant implementationPosition = keccak256(\"you are the lucky man.proxy\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = implementationPosition;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param newImplementation address representing the new implementation to be set\r\n    */\r\n    function setImplementation(address newImplementation) internal {\r\n        bytes32 position = implementationPosition;\r\n        assembly {\r\n            sstore(position, newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != newImplementation, \"new address is the same\");\r\n        setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n}\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant proxyOwnerPosition = keccak256(\"you are the lucky man.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor() public {\r\n        setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner(), \"owner only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function setUpgradeabilityOwner(address newProxyOwner) internal {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            sstore(position, newProxyOwner)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"address is invalid\");\r\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n        setUpgradeabilityOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address implementation) public onlyProxyOwner {\r\n        _upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\r\n    * to initialize whatever is needed through a low level call.\r\n    * @param implementation representing the address of the new implementation to be set.\r\n    * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    * signature of the implementation to be called with the needed payload\r\n    */\r\n    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {\r\n        upgradeTo(implementation);\r\n        require(address(this).call.value(msg.value)(data), \"data is invalid\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"implementation\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]","ContractName":"OwnedUpgradeabilityProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c9d81ef2ba7a6caf1b19465465cf1e8c2938aed6fe3d1d9b9d57921bff1026a1"}]}