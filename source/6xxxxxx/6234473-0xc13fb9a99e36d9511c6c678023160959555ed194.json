{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n    // address where funds are collected\r\n    address public wallet;\r\n\r\n    // amount of raised money in wei\r\n    uint256 public weiRaised;\r\n\r\n    uint256 public tokenAllocated;\r\n\r\n    uint256 public hardCap = 60000 ether;\r\n\r\n    constructor (address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n    }\r\n}\r\n\r\ninterface IContractErc20Token {\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n    function balanceOf(address _owner) external constant returns (uint256 balance);\r\n    function mint(address _to, uint256 _amount, address _owner) external returns (bool);\r\n}\r\n\r\n\r\ncontract CryptoCasherCrowdsale is Ownable, Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    IContractErc20Token public tokenContract;\r\n\r\n    mapping (address => uint256) public deposited;\r\n    mapping(address => bool) public whitelist;\r\n    // List of admins\r\n    mapping (address => bool) public contractAdmins;\r\n    mapping (address => uint256) public paidTokens;\r\n    uint8 constant decimals = 18;\r\n\r\n    uint256 fundForSale = 525 * 10**5 * (10 ** uint256(decimals));\r\n\r\n    address addressFundNonKYCReserv = 0x7AEcFB881B6Ff010E4b7fb582C562aa3FCCb2170;\r\n    address addressFundBlchainReferal = 0x2F9092Fe1dACafF1165b080BfF3afFa6165e339a;\r\n\r\n    uint256[] discount  = [200, 150, 75, 50, 25, 10];\r\n\r\n    uint256 weiMinSale = 0.1 ether;\r\n\r\n    uint256 priceToken = 714;\r\n\r\n    uint256 public countInvestor;\r\n    uint256 percentReferal = 5;\r\n\r\n    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\r\n    event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event NonWhitelistPurchase(address indexed _buyer, uint256 _tokens);\r\n    event HardCapReached();\r\n\r\n    constructor (address _owner, address _wallet) public\r\n    Crowdsale(_wallet)\r\n    {\r\n        uint256 fundAdvisors = 6 * 10**6 * (10 ** uint256(decimals));\r\n        uint256 fundBountyRefferal = 525 * 10**4 * (10 ** uint256(decimals));\r\n        uint256 fundTeam = 1125 * 10**4 * (10 ** 18);\r\n\r\n        require(_owner != address(0));\r\n        require(_wallet != address(0));\r\n        owner = _owner;\r\n        //owner = msg.sender; //for test's\r\n\r\n        tokenAllocated = tokenAllocated.add(fundAdvisors).add(fundBountyRefferal).add(fundTeam);\r\n    }\r\n\r\n    function setContractErc20Token(address _addressContract) public {\r\n        require(_addressContract != address(0));\r\n        tokenContract = IContractErc20Token(_addressContract);\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function() payable public {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function setPriceToken(uint256 _newPrice) public onlyOwner {\r\n        require(_newPrice > 0);\r\n        priceToken = _newPrice;\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address _investor) public payable returns (uint256){\r\n        require(_investor != address(0));\r\n        uint256 weiAmount = msg.value;\r\n        uint256 tokens = validPurchaseTokens(weiAmount);\r\n        if (tokens == 0) {revert();}\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokenAllocated = tokenAllocated.add(tokens);\r\n        if(whitelist[_investor]) {\r\n            tokenContract.mint(_investor, tokens, owner);\r\n        } else {\r\n            tokenContract.mint(addressFundNonKYCReserv, tokens, owner);\r\n            paidTokens[_investor] = paidTokens[_investor].add(tokens);\r\n            emit NonWhitelistPurchase(_investor, tokens);\r\n        }\r\n        emit TokenPurchase(_investor, weiAmount, tokens);\r\n        if (deposited[_investor] == 0) {\r\n            countInvestor = countInvestor.add(1);\r\n        }\r\n        deposit(_investor);\r\n        checkReferalLink(tokens);\r\n        wallet.transfer(weiAmount);\r\n        return tokens;\r\n    }\r\n\r\n    function getTotalAmountOfTokens(uint256 _weiAmount) internal view returns (uint256) {\r\n        uint256 currentDate = now;\r\n        uint256 currentPeriod = getPeriod(currentDate);\r\n        uint256 amountOfTokens = 0;\r\n        if(0 <= currentPeriod && currentPeriod < 7 && _weiAmount >= weiMinSale){\r\n            amountOfTokens = _weiAmount.mul(priceToken).mul(discount[currentPeriod] + 1000).div(1000);\r\n        }\r\n        return amountOfTokens;\r\n    }\r\n\r\n    function getPeriod(uint256 _currentDate) public pure returns (uint) {\r\n        //1538488800 - Tuesday, 2. October 2018 14:00:00 GMT && 1538499600 - Tuesday, 2. October 2018 17:00:00 GMT\r\n        if( 1538488800 <= _currentDate && _currentDate <= 1538499600){\r\n            return 0;\r\n        }\r\n        //1538499601  - Tuesday, 2. October 2018 17:00:01 GMT GMT && 1541167200 - Friday, 2. November 2018 14:00:00 GMT\r\n        if( 1538499601  <= _currentDate && _currentDate <= 1541167200){\r\n            return 1;\r\n        }\r\n\r\n        //1541167201 - Friday, 2. November 2018 14:00:01 GMT && 1543759200 - Sunday, 2. December 2018 14:00:00 GMT\r\n        if( 1541167201 <= _currentDate && _currentDate <= 1543759200){\r\n            return 2;\r\n        }\r\n        //1543759201 - Sunday, 2. December 2018 14:00:01 GMT && 1546437600 - Wednesday, 2. January 2019 14:00:00 GMT\r\n        if( 1543759201 <= _currentDate && _currentDate <= 1546437600){\r\n            return 3;\r\n        }\r\n        //1546437601 - Wednesday, 2. January 2019 14:00:01 GMT && 1549116000 - Saturday, 2. February 2019 14:00:00 GMT\r\n        if( 1546437601 <= _currentDate && _currentDate <= 1549116000){\r\n            return 4;\r\n        }\r\n        //1549116001 - Saturday, 2. February 2019 14:00:01 GMT && 1551535200 - Saturday, 2. March 2019 14:00:00\r\n        if( 1549116001 <= _currentDate && _currentDate <= 1551535200){\r\n            return 5;\r\n        }\r\n\r\n        return 10;\r\n    }\r\n\r\n    function deposit(address investor) internal {\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n\r\n    function checkReferalLink(uint256 _amountToken) internal returns(uint256 _refererTokens) {\r\n        _refererTokens = 0;\r\n        if(msg.data.length == 20) {\r\n            address referer = bytesToAddress(bytes(msg.data));\r\n            require(referer != msg.sender);\r\n            _refererTokens = _amountToken.mul(percentReferal).div(100);\r\n            if(tokenContract.balanceOf(addressFundBlchainReferal) >= _refererTokens.mul(2)) {\r\n                tokenContract.mint(referer, _refererTokens, addressFundBlchainReferal);\r\n                tokenContract.mint(msg.sender, _refererTokens, addressFundBlchainReferal);\r\n            }\r\n        }\r\n    }\r\n\r\n    function bytesToAddress(bytes source) internal pure returns(address) {\r\n        uint result;\r\n        uint mul = 1;\r\n        for(uint i = 20; i > 0; i--) {\r\n            result += uint8(source[i-1])*mul;\r\n            mul = mul*256;\r\n        }\r\n        return address(result);\r\n    }\r\n\r\n    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {\r\n        uint256 addTokens = getTotalAmountOfTokens(_weiAmount);\r\n        if (tokenAllocated.add(addTokens) > fundForSale) {\r\n            emit TokenLimitReached(tokenAllocated, addTokens);\r\n            return 0;\r\n        }\r\n        if (weiRaised.add(_weiAmount) > hardCap) {\r\n            emit HardCapReached();\r\n            return 0;\r\n        }\r\n        return addTokens;\r\n    }\r\n\r\n    /**\r\n    * @dev Add an contract admin\r\n    */\r\n    function setContractAdmin(address _admin, bool _isAdmin) external onlyOwner {\r\n        require(_admin != address(0));\r\n        contractAdmins[_admin] = _isAdmin;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds single address to whitelist.\r\n    * @param _beneficiary Address to be added to the whitelist\r\n    */\r\n    function addToWhitelist(address _beneficiary) external onlyOwnerOrAnyAdmin {\r\n        whitelist[_beneficiary] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing.\r\n     * @param _beneficiaries Addresses to be added to the whitelist\r\n     */\r\n    function addManyToWhitelist(address[] _beneficiaries) external onlyOwnerOrAnyAdmin {\r\n        require(_beneficiaries.length < 101);\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            whitelist[_beneficiaries[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes single address from whitelist.\r\n     * @param _beneficiary Address to be removed to the whitelist\r\n     */\r\n    function removeFromWhitelist(address _beneficiary) external onlyOwnerOrAnyAdmin {\r\n        whitelist[_beneficiary] = false;\r\n    }\r\n\r\n    modifier onlyOwnerOrAnyAdmin() {\r\n        require(msg.sender == owner || contractAdmins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Peterson's Law Protection\r\n     * Claim tokens\r\n     */\r\n    function claimTokens(address _token) public onlyOwner {\r\n        if (_token == 0x0) {\r\n            owner.transfer(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        uint256 balance = tokenContract.balanceOf(this);\r\n        tokenContract.transfer(owner, balance);\r\n        emit Transfer(_token, owner, balance);\r\n    }\r\n\r\n    modifier onlyFundNonKYCReserv() {\r\n        require(msg.sender == addressFundNonKYCReserv);\r\n        _;\r\n    }\r\n\r\n    function batchTransferPaidTokens(address[] _recipients, uint256[] _values) external onlyFundNonKYCReserv returns (bool) {\r\n        require( _recipients.length > 0 && _recipients.length == _values.length);\r\n        uint256 total = 0;\r\n        for(uint i = 0; i < _values.length; i++){\r\n            total = total.add(_values[i]);\r\n        }\r\n        require(total <= tokenContract.balanceOf(msg.sender));\r\n        for(uint j = 0; j < _recipients.length; j++){\r\n            require(0 <= _values[j]);\r\n            require(_values[j] <= paidTokens[_recipients[j]]);\r\n            paidTokens[_recipients[j]].sub(_values[j]);\r\n            tokenContract.transferFrom(addressFundNonKYCReserv, _recipients[j], _values[j]);\r\n            emit Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return tokenContract.balanceOf(_owner);\r\n    }\r\n\r\n    function balanceOfNonKYC(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return paidTokens[_owner];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferPaidTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_currentDate\",\"type\":\"uint256\"}],\"name\":\"getPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPriceToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressContract\",\"type\":\"address\"}],\"name\":\"setContractErc20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"addManyToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfNonKYC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_isAdmin\",\"type\":\"bool\"}],\"name\":\"setContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractAdmins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"validPurchaseTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"purchasedToken\",\"type\":\"uint256\"}],\"name\":\"TokenLimitReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"NonWhitelistPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HardCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"CryptoCasherCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003038bdac92efb4a9392396bc97db8730e18cff030000000000000000000000003cfe0e6ed20901e01d29ab7699243be2b8b6ac54","Library":"","SwarmSource":"bzzr://143a68defbf5ee66208370148cbf638d6279e81c085ea571a158d4e050d1edbe"}]}