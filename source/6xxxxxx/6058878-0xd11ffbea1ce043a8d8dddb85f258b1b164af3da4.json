{"status":"1","message":"OK","result":[{"SourceCode":"// basic multisig wallet with spending limits, token types and other controls built in\r\n// wondering if I should build in a master lock which enables free spend after a certain time?\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic\r\n{\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract MultiSig\r\n{\r\n  address constant internal CONTRACT_SIGNATURE1 = 0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37; // SB\r\n  address constant internal CONTRACT_SIGNATURE2 = 0x9115a6162D6bC3663dC7f4Ea46ad87db6B9CB926; // SM\r\n  \r\n  mapping(address => uint256) internal mSignatures;\r\n  mapping(address => uint256) internal mLastSpend;\r\n  \r\n  // gas limit\r\n  uint256 public GAS_PRICE_LIMIT = 200 * 10**9;                       // Gas limit 200 gwei\r\n  \r\n  // live parameters\r\n  uint256 public constant WHOLE_ETHER = 10**18;\r\n  uint256 public constant FRACTION_ETHER = 10**14;\r\n  uint256 public constant COSIGN_MAX_TIME= 900; // maximum delay between signatures\r\n  uint256 public constant DAY_LENGTH  = 300; // length of day in seconds\r\n  \r\n  // ether spending\r\n  uint256 public constant MAX_DAILY_SOLO_SPEND = (5*WHOLE_ETHER); // amount which can be withdrawn without co-signing\r\n  uint256 public constant MAX_DAILY_COSIGN_SEND = (500*WHOLE_ETHER);\r\n  \r\n  // token spending\r\n  uint256 public constant MAX_DAILY_TOKEN_SOLO_SPEND = 2500000*WHOLE_ETHER; // ~5 eth\r\n  uint256 public constant MAX_DAILY_TOKEN_COSIGN_SPEND = 250000000*WHOLE_ETHER; // ~500 eth\r\n  \r\n  uint256 internal mAmount1=0;\r\n  uint256 internal mAmount2=0;\r\n\r\n  // set the time of a signature\r\n  function sendsignature() internal\r\n  {\r\n       // check if these signatures are authorised\r\n        require((msg.sender == CONTRACT_SIGNATURE1 || msg.sender == CONTRACT_SIGNATURE2));//, \"Only signatories can sign\");\r\n        \r\n        // assign signature\r\n        uint256 timestamp = block.timestamp;\r\n        mSignatures[msg.sender] = timestamp;\r\n  }\r\n  \r\n  // inserted for paranoia but may need to change gas prices in future\r\n  function SetGasLimit(uint256 newGasLimit) public\r\n  {\r\n      require((msg.sender == CONTRACT_SIGNATURE1 || msg.sender == CONTRACT_SIGNATURE2));//, \"Only signatories can call\");\r\n      GAS_PRICE_LIMIT = newGasLimit;                       // Gas limit default 200 gwei\r\n  }\r\n    \r\n  // implicitly calls spend - if both signatures have signed we then spend\r\n  function spendlarge(uint256 _to, uint256 _main, uint256 _fraction) public returns (bool valid)\r\n  {\r\n        require( _to != 0x0);//, \"Must send to valid address\");\r\n        require( _main<= MAX_DAILY_COSIGN_SEND);//, \"Cannot spend more than 500 eth\");\r\n        require( _fraction< (WHOLE_ETHER/FRACTION_ETHER));//, \"Fraction must be less than 10000\");\r\n        require (tx.gasprice <= GAS_PRICE_LIMIT);//, \"tx.gasprice exceeds limit\");\r\n        // usually called after sign but will work if top level function is called by both parties\r\n        sendsignature();\r\n        \r\n        uint256 currentTime = block.timestamp;\r\n        uint256 valid1=0;\r\n        uint256 valid2=0;\r\n        \r\n        // check both signatures have been logged within the time frame\r\n        // one of these times will obviously be zero\r\n        if (block.timestamp - mSignatures[CONTRACT_SIGNATURE1] < COSIGN_MAX_TIME)\r\n        {\r\n            mAmount1 = _main*WHOLE_ETHER + _fraction*FRACTION_ETHER;\r\n            valid1=1;\r\n        }\r\n        \r\n        if (block.timestamp - mSignatures[CONTRACT_SIGNATURE2] < COSIGN_MAX_TIME)\r\n        {\r\n            mAmount2 = _main*WHOLE_ETHER + _fraction*FRACTION_ETHER;\r\n            valid2=1;\r\n        }\r\n        \r\n        if (valid1==1 && valid2==1) //\"Both signatures must sign\");\r\n        {\r\n            // if this was called in less than 24 hours then don't allow spend\r\n            require( (currentTime - mLastSpend[msg.sender]) > DAY_LENGTH);//, \"You can't call this more than once per day per signature\");\r\n        \r\n            if (mAmount1 == mAmount2)\r\n            {\r\n                // transfer eth to the destination\r\n                address(_to).transfer(mAmount1);\r\n                \r\n                // clear the state\r\n                valid1=0;\r\n                valid2=0;\r\n                mAmount1=0;\r\n                mAmount2=0;\r\n                \r\n                // clear the signature timestamps\r\n                endsigning();\r\n                \r\n                return true;\r\n            }\r\n        }\r\n        \r\n        // out of time or need another signature\r\n        return false;\r\n  }\r\n  \r\n  // used for individual wallet holders to take a small amount of ether\r\n  function takedaily(address _to) public returns (bool valid)\r\n  {\r\n    require( _to != 0x0);//, \"Must send to valid address\");\r\n    require (tx.gasprice <= GAS_PRICE_LIMIT);//, \"tx.gasprice exceeds limit\");\r\n    \r\n    // check if these signatures are authorised\r\n    require((msg.sender == CONTRACT_SIGNATURE1 || msg.sender == CONTRACT_SIGNATURE2));//, \"Only signatories can sign\");\r\n        \r\n    uint256 currentTime = block.timestamp;\r\n        \r\n    // if this was called in less than 24 hours then don't allow spend\r\n    require(currentTime - mLastSpend[msg.sender] > DAY_LENGTH);//, \"You can't call this more than once per day per signature\");\r\n    \r\n    // transfer eth to the destination\r\n    _to.transfer(MAX_DAILY_SOLO_SPEND);\r\n                \r\n    mLastSpend[msg.sender] = currentTime;\r\n                \r\n    return true;\r\n  }\r\n  \r\n  // implicitly calls spend - if both signatures have signed we then spend\r\n  function spendtokens(ERC20Basic contractaddress, uint256 _to, uint256 _main, uint256 _fraction) public returns (bool valid)\r\n  {\r\n        require( _to != 0x0);//, \"Must send to valid address\");\r\n        require(_main <= MAX_DAILY_TOKEN_COSIGN_SPEND);// , \"Cannot spend more than 150000000 per day\");\r\n        require(_fraction< (WHOLE_ETHER/FRACTION_ETHER));//, \"Fraction must be less than 10000\");\r\n        \r\n        // usually called after sign but will work if top level function is called by both parties\r\n        sendsignature();\r\n        \r\n        uint256 currentTime = block.timestamp;\r\n        uint256 valid1=0;\r\n        uint256 valid2=0;\r\n        \r\n        // check both signatures have been logged within the time frame\r\n        // one of these times will obviously be zero\r\n        if (block.timestamp - mSignatures[CONTRACT_SIGNATURE1] < COSIGN_MAX_TIME)\r\n        {\r\n            mAmount1 = _main*WHOLE_ETHER + _fraction*FRACTION_ETHER;\r\n            valid1=1;\r\n        }\r\n        \r\n        if (block.timestamp - mSignatures[CONTRACT_SIGNATURE2] < COSIGN_MAX_TIME)\r\n        {\r\n            mAmount2 = _main*WHOLE_ETHER + _fraction*FRACTION_ETHER;\r\n            valid2=1;\r\n        }\r\n        \r\n        if (valid1==1 && valid2==1) //\"Both signatures must sign\");\r\n        {\r\n            // if this was called in less than 24 hours then don't allow spend\r\n            require(currentTime - mLastSpend[msg.sender] > DAY_LENGTH);//, \"You can't call this more than once per day per signature\");\r\n        \r\n            if (mAmount1 == mAmount2)\r\n            {\r\n                uint256 valuetosend = _main*WHOLE_ETHER + _fraction*FRACTION_ETHER;\r\n                // transfer eth to the destination\r\n                contractaddress.transfer(address(_to), valuetosend);\r\n                \r\n                // clear the state\r\n                valid1=0;\r\n                valid2=0;\r\n                mAmount1=0;\r\n                mAmount2=0;\r\n                \r\n                // clear the signature timestamps\r\n                endsigning();\r\n                \r\n                return true;\r\n            }\r\n        }\r\n        \r\n        // out of time or need another signature\r\n        return false;\r\n  }\r\n        \r\n\r\n  // used to take a small amount of daily tokens\r\n  function taketokendaily(ERC20Basic contractaddress, uint256 _to) public returns (bool valid)\r\n  {\r\n    require( _to != 0x0);//, \"Must send to valid address\");\r\n    \r\n    // check if these signatures are authorised\r\n    require((msg.sender == CONTRACT_SIGNATURE1 || msg.sender == CONTRACT_SIGNATURE2));//, \"Only signatories can sign\");\r\n        \r\n    uint256 currentTime = block.timestamp;\r\n        \r\n    // if this was called in less than 24 hours then don't allow spend\r\n    require(currentTime - mLastSpend[msg.sender] > DAY_LENGTH);//, \"You can't call this more than once per day per signature\");\r\n    \r\n    // transfer eth to the destination\r\n    contractaddress.transfer(address(_to), MAX_DAILY_TOKEN_SOLO_SPEND);\r\n                \r\n    mLastSpend[msg.sender] = currentTime;\r\n                \r\n    return true;\r\n  }\r\n    \r\n  function endsigning() internal\r\n  {\r\n      // only called when spending was successful - sets the timestamp of last call\r\n      mLastSpend[CONTRACT_SIGNATURE1]=block.timestamp;\r\n      mLastSpend[CONTRACT_SIGNATURE2]=block.timestamp;\r\n      mSignatures[CONTRACT_SIGNATURE1]=0;\r\n      mSignatures[CONTRACT_SIGNATURE2]=0;\r\n  }\r\n  \r\n  function () public payable \r\n    {\r\n       \r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"contractaddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"uint256\"},{\"name\":\"_main\",\"type\":\"uint256\"},{\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"spendtokens\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"uint256\"},{\"name\":\"_main\",\"type\":\"uint256\"},{\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"spendlarge\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DAILY_TOKEN_SOLO_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractaddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"taketokendaily\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAY_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DAILY_COSIGN_SEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DAILY_SOLO_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"takedaily\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WHOLE_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COSIGN_MAX_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DAILY_TOKEN_COSIGN_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FRACTION_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_PRICE_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGasLimit\",\"type\":\"uint256\"}],\"name\":\"SetGasLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"MultiSig","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4df69f19eee5601f30596d0d8e44bf386e53b29da34b4a6924cb267ba0f7803a"}]}