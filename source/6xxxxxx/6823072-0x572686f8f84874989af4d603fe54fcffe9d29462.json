{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Pulled from OpenZeppelin: https://git.io/vbaRf\r\n *   When this is in a public release we will switch to not vendoring this file\r\n *\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Extracting these values isn't possible without assembly\r\n    // solhint-disable no-inline-assembly\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SigningLogic is contract implementing signature recovery from typed data signatures\r\n * @notice Recovers signatures based on the SignTypedData implementation provided by ethSigUtil\r\n * @dev This contract is inherited by other contracts.\r\n */\r\ncontract SigningLogic {\r\n\r\n  // Signatures contain a nonce to make them unique. usedSignatures tracks which signatures\r\n  //  have been used so they can't be replayed\r\n  mapping (bytes32 => bool) public usedSignatures;\r\n\r\n  function burnSignatureDigest(bytes32 _signatureDigest, address _sender) internal {\r\n    bytes32 _txDataHash = keccak256(abi.encode(_signatureDigest, _sender));\r\n    require(!usedSignatures[_txDataHash], \"Signature not unique\");\r\n    usedSignatures[_txDataHash] = true;\r\n  }\r\n\r\n  bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n  );\r\n\r\n  bytes32 constant ATTESTATION_REQUEST_TYPEHASH = keccak256(\r\n    \"AttestationRequest(bytes32 dataHash,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ADD_ADDRESS_TYPEHASH = keccak256(\r\n    \"AddAddress(address addressToAdd,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant REMOVE_ADDRESS_TYPEHASH = keccak256(\r\n    \"RemoveAddress(address addressToRemove,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant PAY_TOKENS_TYPEHASH = keccak256(\r\n    \"PayTokens(address sender,address receiver,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant RELEASE_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"ReleaseTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ATTEST_FOR_TYPEHASH = keccak256(\r\n    \"AttestFor(address subject,address requester,uint256 reward,bytes32 dataHash,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant CONTEST_FOR_TYPEHASH = keccak256(\r\n    \"ContestFor(address requester,uint256 reward,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant REVOKE_ATTESTATION_FOR_TYPEHASH = keccak256(\r\n    \"RevokeAttestationFor(bytes32 link,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant VOTE_FOR_TYPEHASH = keccak256(\r\n    \"VoteFor(uint16 choice,address voter,bytes32 nonce,address poll)\"\r\n  );\r\n\r\n  bytes32 constant LOCKUP_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"LockupTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 DOMAIN_SEPARATOR;\r\n\r\n  constructor (string name, string version, uint256 chainId) public {\r\n    DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n      name: name,\r\n      version: version,\r\n      chainId: chainId,\r\n      verifyingContract: this\r\n    }));\r\n  }\r\n\r\n  struct EIP712Domain {\r\n      string  name;\r\n      string  version;\r\n      uint256 chainId;\r\n      address verifyingContract;\r\n  }\r\n\r\n  function hash(EIP712Domain eip712Domain) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      EIP712DOMAIN_TYPEHASH,\r\n      keccak256(bytes(eip712Domain.name)),\r\n      keccak256(bytes(eip712Domain.version)),\r\n      eip712Domain.chainId,\r\n      eip712Domain.verifyingContract\r\n    ));\r\n  }\r\n\r\n  struct AttestationRequest {\r\n      bytes32 dataHash;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AttestationRequest request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTESTATION_REQUEST_TYPEHASH,\r\n      request.dataHash,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AddAddress {\r\n      address addressToAdd;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AddAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ADD_ADDRESS_TYPEHASH,\r\n      request.addressToAdd,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct RemoveAddress {\r\n      address addressToRemove;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RemoveAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REMOVE_ADDRESS_TYPEHASH,\r\n      request.addressToRemove,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct PayTokens {\r\n      address sender;\r\n      address receiver;\r\n      uint256 amount;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(PayTokens request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      PAY_TOKENS_TYPEHASH,\r\n      request.sender,\r\n      request.receiver,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AttestFor {\r\n      address subject;\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 dataHash;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(AttestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTEST_FOR_TYPEHASH,\r\n      request.subject,\r\n      request.requester,\r\n      request.reward,\r\n      request.dataHash,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct ContestFor {\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(ContestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      CONTEST_FOR_TYPEHASH,\r\n      request.requester,\r\n      request.reward,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct RevokeAttestationFor {\r\n      bytes32 link;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RevokeAttestationFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REVOKE_ATTESTATION_FOR_TYPEHASH,\r\n      request.link,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct VoteFor {\r\n      uint16 choice;\r\n      address voter;\r\n      bytes32 nonce;\r\n      address poll;\r\n  }\r\n\r\n  function hash(VoteFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      VOTE_FOR_TYPEHASH,\r\n      request.choice,\r\n      request.voter,\r\n      request.nonce,\r\n      request.poll\r\n    ));\r\n  }\r\n\r\n  struct LockupTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(LockupTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      LOCKUP_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct ReleaseTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(ReleaseTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      RELEASE_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  function generateRequestAttestationSchemaHash(\r\n    bytes32 _dataHash,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestationRequest(\r\n          _dataHash,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAddAddressSchemaHash(\r\n    address _addressToAdd,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AddAddress(\r\n          _addressToAdd,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRemoveAddressSchemaHash(\r\n    address _addressToRemove,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RemoveAddress(\r\n          _addressToRemove,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generatePayTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(PayTokens(\r\n          _sender,\r\n          _receiver,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestFor(\r\n          _subject,\r\n          _requester,\r\n          _reward,\r\n          _dataHash,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ContestFor(\r\n          _requester,\r\n          _reward,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRevokeAttestationForDelegationSchemaHash(\r\n    bytes32 _link,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RevokeAttestationFor(\r\n          _link,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(VoteFor(\r\n          _choice,\r\n          _voter,\r\n          _nonce,\r\n          _poll\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(LockupTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateReleaseTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ReleaseTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function recoverSigner(bytes32 _hash, bytes _sig) internal pure returns (address) {\r\n    address signer = ECRecovery.recover(_hash, _sig);\r\n    require(signer != address(0));\r\n\r\n    return signer;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @notice TokenEscrowMarketplace is an ERC20 payment channel that enables users to send BLT by exchanging signatures off-chain\r\n *  Users approve the contract address to transfer BLT on their behalf using the standard ERC20.approve function\r\n *  After approval, either the user or the contract admin initiates the transfer of BLT into the contract\r\n *  Once in the contract, users can send payments via a signed message to another user. \r\n *  The signature transfers BLT from lockup to the recipient's balance\r\n *  Users can withdraw funds at any time. Or the admin can release them on the user's behalf\r\n *  \r\n *  BLT is stored in the contract by address\r\n *  \r\n *  Only the AttestationLogic contract is authorized to release funds once a jobs is complete\r\n */\r\ncontract TokenEscrowMarketplace is SigningLogic {\r\n  using SafeERC20 for ERC20;\r\n  using SafeMath for uint256;\r\n\r\n  address public attestationLogic;\r\n\r\n  mapping(address => uint256) public tokenEscrow;\r\n  ERC20 public token;\r\n\r\n  event TokenMarketplaceWithdrawal(address escrowPayer, uint256 amount);\r\n  event TokenMarketplaceEscrowPayment(address escrowPayer, address escrowPayee, uint256 amount);\r\n  event TokenMarketplaceDeposit(address escrowPayer, uint256 amount);\r\n\r\n  /**\r\n   * @notice The TokenEscrowMarketplace constructor initializes the interfaces to the other contracts\r\n   * @dev Some actions are restricted to be performed by the attestationLogic contract.\r\n   *  Signing logic is upgradeable in case the signTypedData spec changes\r\n   * @param _token Address of BLT\r\n   * @param _attestationLogic Address of current attestation logic contract\r\n   */\r\n  constructor(\r\n    ERC20 _token,\r\n    address _attestationLogic\r\n    ) public SigningLogic(\"Bloom Token Escrow Marketplace\", \"2\", 1) {\r\n    token = _token;\r\n    attestationLogic = _attestationLogic;\r\n  }\r\n\r\n  modifier onlyAttestationLogic() {\r\n    require(msg.sender == attestationLogic);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Lockup tokens for set time period on behalf of user. Must be preceeded by approve\r\n   * @dev Authorized by a signTypedData signature by sender\r\n   *  Sigs can only be used once. They contain a unique nonce\r\n   *  So an action can be repeated, with a different signature\r\n   * @param _sender User locking up their tokens\r\n   * @param _amount Tokens to lock up\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function moveTokensToEscrowLockupFor(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n    ) external {\r\n      validateLockupTokensSig(\r\n        _sender,\r\n        _amount,\r\n        _nonce,\r\n        _delegationSig\r\n      );\r\n      moveTokensToEscrowLockupForUser(_sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify lockup signature is valid\r\n   * @param _sender User locking up their tokens\r\n   * @param _amount Tokens to lock up\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function validateLockupTokensSig(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n  ) private {\r\n    bytes32 _signatureDigest = generateLockupTokensDelegationSchemaHash(_sender, _amount, _nonce);\r\n    require(_sender == recoverSigner(_signatureDigest, _delegationSig), 'Invalid LockupTokens Signature');\r\n    burnSignatureDigest(_signatureDigest, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Lockup tokens by user. Must be preceeded by approve\r\n   * @param _amount Tokens to lock up\r\n   */\r\n  function moveTokensToEscrowLockup(uint256 _amount) external {\r\n    moveTokensToEscrowLockupForUser(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Lockup tokens for set time. Must be preceeded by approve\r\n   * @dev Private function called by appropriate public function\r\n   * @param _sender User locking up their tokens\r\n   * @param _amount Tokens to lock up\r\n   */\r\n  function moveTokensToEscrowLockupForUser(\r\n    address _sender,\r\n    uint256 _amount\r\n    ) private {\r\n    token.safeTransferFrom(_sender, this, _amount);\r\n    addToEscrow(_sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw tokens from escrow back to requester\r\n   * @dev Authorized by a signTypedData signature by sender\r\n   *  Sigs can only be used once. They contain a unique nonce\r\n   *  So an action can be repeated, with a different signature\r\n   * @param _sender User withdrawing their tokens\r\n   * @param _amount Tokens to withdraw\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function releaseTokensFromEscrowFor(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n    ) external {\r\n      validateReleaseTokensSig(\r\n        _sender,\r\n        _amount,\r\n        _nonce,\r\n        _delegationSig\r\n      );\r\n      releaseTokensFromEscrowForUser(_sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify lockup signature is valid\r\n   * @param _sender User withdrawing their tokens\r\n   * @param _amount Tokens to lock up\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function validateReleaseTokensSig(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n\r\n  ) private {\r\n    bytes32 _signatureDigest = generateReleaseTokensDelegationSchemaHash(_sender, _amount, _nonce);\r\n    require(_sender == recoverSigner(_signatureDigest, _delegationSig), 'Invalid ReleaseTokens Signature');\r\n    burnSignatureDigest(_signatureDigest, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Release tokens back to payer's available balance if lockup expires\r\n   * @dev Token balance retreived by accountId. Can be different address from the one that deposited tokens\r\n   * @param _amount Tokens to retreive from escrow\r\n   */\r\n  function releaseTokensFromEscrow(uint256 _amount) external {\r\n    releaseTokensFromEscrowForUser(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Release tokens back to payer's available balance\r\n   * @param _payer User retreiving tokens from escrow\r\n   * @param _amount Tokens to retreive from escrow\r\n   */\r\n  function releaseTokensFromEscrowForUser(\r\n    address _payer,\r\n    uint256 _amount\r\n    ) private {\r\n      subFromEscrow(_payer, _amount);\r\n      token.safeTransfer(_payer, _amount);\r\n      emit TokenMarketplaceWithdrawal(_payer, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Pay from escrow of payer to available balance of receiever\r\n   * @dev Private function to modify balances on payment\r\n   * @param _payer User with tokens in escrow\r\n   * @param _receiver User receiving tokens\r\n   * @param _amount Tokens being sent\r\n   */\r\n  function payTokensFromEscrow(address _payer, address _receiver, uint256 _amount) private {\r\n    subFromEscrow(_payer, _amount);\r\n    token.safeTransfer(_receiver, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Pay tokens to receiver from payer's escrow given a valid signature\r\n   * @dev Execution restricted to attestationLogic contract\r\n   * @param _payer User paying tokens from escrow\r\n   * @param _receiver User receiving payment\r\n   * @param _amount Tokens being paid\r\n   * @param _nonce Unique Id for sig to make it one-time-use\r\n   * @param _paymentSig Signed parameters by payer authorizing payment\r\n   */\r\n  function requestTokenPayment(\r\n    address _payer,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _paymentSig\r\n    ) external onlyAttestationLogic {\r\n\r\n    validatePaymentSig(\r\n      _payer,\r\n      _receiver,\r\n      _amount,\r\n      _nonce,\r\n      _paymentSig\r\n    );\r\n    payTokensFromEscrow(_payer, _receiver, _amount);\r\n    emit TokenMarketplaceEscrowPayment(_payer, _receiver, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify payment signature is valid\r\n   * @param _payer User paying tokens from escrow\r\n   * @param _receiver User receiving payment\r\n   * @param _amount Tokens being paid\r\n   * @param _nonce Unique Id for sig to make it one-time-use\r\n   * @param _paymentSig Signed parameters by payer authorizing payment\r\n   */\r\n  function validatePaymentSig(\r\n    address _payer,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _paymentSig\r\n\r\n  ) private {\r\n    bytes32 _signatureDigest = generatePayTokensSchemaHash(_payer, _receiver, _amount, _nonce);\r\n    require(_payer == recoverSigner(_signatureDigest, _paymentSig), 'Invalid Payment Signature');\r\n    burnSignatureDigest(_signatureDigest, _payer);\r\n  }\r\n\r\n  /**\r\n   * @notice Helper function to add to escrow balance \r\n   * @param _from Account address for escrow mapping\r\n   * @param _amount Tokens to lock up\r\n   */\r\n  function addToEscrow(address _from, uint256 _amount) private {\r\n    tokenEscrow[_from] = tokenEscrow[_from].add(_amount);\r\n    emit TokenMarketplaceDeposit(_from, _amount);\r\n  }\r\n\r\n  /**\r\n   * Helper function to reduce escrow token balance of user\r\n   */\r\n  function subFromEscrow(address _from, uint256 _amount) private {\r\n    require(tokenEscrow[_from] >= _amount);\r\n    tokenEscrow[_from] = tokenEscrow[_from].sub(_amount);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"name\":\"_delegationSig\",\"type\":\"bytes\"}],\"name\":\"moveTokensToEscrowLockupFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"attestationLogic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"releaseTokensFromEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payer\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"name\":\"_paymentSig\",\"type\":\"bytes\"}],\"name\":\"requestTokenPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveTokensToEscrowLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"name\":\"_delegationSig\",\"type\":\"bytes\"}],\"name\":\"releaseTokensFromEscrowFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_attestationLogic\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"escrowPayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenMarketplaceWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"escrowPayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"escrowPayee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenMarketplaceEscrowPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"escrowPayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenMarketplaceDeposit\",\"type\":\"event\"}]","ContractName":"TokenEscrowMarketplace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000107c4504cd79c5d2696ea0030a8dd4e92601b82e000000000000000000000000ceec7aaa57e3a77c73a9954b9b7d5b32ab688318","Library":"ECRecovery:7a75cb349d9a9d4c2d3eb8a22cb3090222d8557b","SwarmSource":"bzzr://e869245a4673d474717965c81d14c8355794f517683a97e86f2d3b15c2e30618"}]}