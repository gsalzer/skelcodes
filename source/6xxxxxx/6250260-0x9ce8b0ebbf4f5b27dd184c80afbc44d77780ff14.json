{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = false;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}\r\n\r\ninterface EtheremonMonsterNFTInterface {\r\n   function triggerTransferEvent(address _from, address _to, uint _tokenId) external;\r\n   function getMonsterCP(uint64 _monsterId) constant external returns(uint cp);\r\n}\r\n\r\ncontract EtheremonEnum {\r\n\r\n    enum ResultCode {\r\n        SUCCESS,\r\n        ERROR_CLASS_NOT_FOUND,\r\n        ERROR_LOW_BALANCE,\r\n        ERROR_SEND_FAIL,\r\n        ERROR_NOT_TRAINER,\r\n        ERROR_NOT_ENOUGH_MONEY,\r\n        ERROR_INVALID_AMOUNT\r\n    }\r\n    \r\n    enum ArrayType {\r\n        CLASS_TYPE,\r\n        STAT_STEP,\r\n        STAT_START,\r\n        STAT_BASE,\r\n        OBJ_SKILL\r\n    }\r\n    \r\n    enum PropertyType {\r\n        ANCESTOR,\r\n        XFACTOR\r\n    }\r\n}\r\n\r\ncontract EtheremonDataBase {\r\n    \r\n    uint64 public totalMonster;\r\n    uint32 public totalClass;\r\n    \r\n    // write\r\n    function addElementToArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint8 _value) external returns(uint);\r\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) external returns(uint64);\r\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) external;\r\n    \r\n    // read\r\n    function getElementInArrayType(EtheremonEnum.ArrayType _type, uint64 _id, uint _index) constant external returns(uint8);\r\n    function getMonsterClass(uint32 _classId) constant external returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\r\n    function getMonsterObj(uint64 _objId) constant external returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\r\n}\r\n\r\ncontract EtheremonWorldNFT is BasicAccessControl {\r\n    uint8 constant public STAT_COUNT = 6;\r\n    uint8 constant public STAT_MAX = 32;\r\n    \r\n    struct MonsterClassAcc {\r\n        uint32 classId;\r\n        uint256 price;\r\n        uint256 returnPrice;\r\n        uint32 total;\r\n        bool catchable;\r\n    }\r\n\r\n    struct MonsterObjAcc {\r\n        uint64 monsterId;\r\n        uint32 classId;\r\n        address trainer;\r\n        string name;\r\n        uint32 exp;\r\n        uint32 createIndex;\r\n        uint32 lastClaimIndex;\r\n        uint createTime;\r\n    }\r\n    \r\n    address public dataContract;\r\n    address public monsterNFT;\r\n    \r\n    mapping(uint32 => bool) classWhitelist;\r\n    mapping(address => bool) addressWhitelist;\r\n    \r\n    uint public gapFactor = 5;\r\n    uint public priceIncreasingRatio = 1000;\r\n    \r\n    function setContract(address _dataContract, address _monsterNFT) onlyModerators external {\r\n        dataContract = _dataContract;\r\n        monsterNFT = _monsterNFT;\r\n    }\r\n    \r\n    function setConfig(uint _gapFactor, uint _priceIncreasingRatio) onlyModerators external {\r\n        gapFactor = _gapFactor;\r\n        priceIncreasingRatio = _priceIncreasingRatio;\r\n    }\r\n    \r\n    function setClassWhitelist(uint32 _classId, bool _status) onlyModerators external {\r\n        classWhitelist[_classId] = _status;\r\n    }\r\n\r\n    function setAddressWhitelist(address _smartcontract, bool _status) onlyModerators external {\r\n        addressWhitelist[_smartcontract] = _status;\r\n    }\r\n    \r\n    function withdrawEther(address _sendTo, uint _amount) onlyOwner public {\r\n        if (_amount > address(this).balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }\r\n    \r\n    function mintMonster(uint32 _classId, address _trainer, string _name) onlyModerators external returns(uint){\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        // add monster\r\n        uint64 objId = data.addMonsterObj(_classId, _trainer, _name);\r\n        uint8 value;\r\n        uint seed = getRandom(_trainer, block.number-1, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i+= 1) {\r\n            value = uint8((seed * (i + 1)) % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n        \r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(address(0), _trainer, objId);\r\n        return objId;\r\n    }\r\n    \r\n    function burnMonster(uint64 _tokenId) onlyModerators external {\r\n        // need to check condition before calling this function\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_tokenId);\r\n        require(obj.trainer != address(0));\r\n        data.removeMonsterIdMapping(obj.trainer, _tokenId);\r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(obj.trainer, address(0), _tokenId);\r\n    }\r\n    \r\n    // public api \r\n    function getRandom(address _player, uint _block, uint _count) view public returns(uint) {\r\n        return uint(keccak256(abi.encodePacked(blockhash(_block), _player, _count)));\r\n    }\r\n    \r\n    function getMonsterClassBasic(uint32 _classId) constant external returns(uint256, uint256, uint256, bool) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        return (class.price, class.returnPrice, class.total, class.catchable);\r\n    }\r\n    \r\n    function getPrice(uint32 _classId) constant external returns(bool catchable, uint price) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        \r\n        price = class.price;\r\n        if (class.total > 0)\r\n            price += class.price*(class.total-1)/priceIncreasingRatio;\r\n        \r\n        if (class.catchable == false) {\r\n            return (classWhitelist[_classId], price);\r\n        } else {\r\n            return (true, price);\r\n        }\r\n    }\r\n    \r\n    function catchMonsterNFT(uint32 _classId, string _name) isActive external payable{\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        if (class.classId == 0 || class.catchable == false) {\r\n            revert();\r\n        }\r\n        \r\n        uint price = class.price;\r\n        if (class.total > 0)\r\n            price += class.price*(class.total-1)/priceIncreasingRatio;\r\n        if (msg.value < price) {\r\n            revert();\r\n        }\r\n        \r\n        // add new monster \r\n        uint64 objId = data.addMonsterObj(_classId, msg.sender, _name);\r\n        uint8 value;\r\n        uint seed = getRandom(msg.sender, block.number-1, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i+= 1) {\r\n            value = uint8((seed * (i + 1)) % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n        \r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(address(0), msg.sender, objId);\r\n        // refund extra\r\n        if (msg.value > price) {\r\n            msg.sender.transfer((msg.value - price));\r\n        }\r\n    }\r\n    \r\n    // for whitelist contracts, no refund extra\r\n    function catchMonster(address _player, uint32 _classId, string _name) isActive external payable returns(uint tokenId) {\r\n        if (addressWhitelist[msg.sender] == false) {\r\n            revert();\r\n        }\r\n        \r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        if (class.classId == 0) {\r\n            revert();\r\n        }\r\n        \r\n        if (class.catchable == false && classWhitelist[_classId] == false) {\r\n            revert();\r\n        }\r\n        \r\n        uint price = class.price;\r\n        if (class.total > gapFactor) {\r\n            price += class.price*(class.total - gapFactor)/priceIncreasingRatio;\r\n        }\r\n        if (msg.value < price) {\r\n            revert();\r\n        }\r\n        \r\n        // add new monster \r\n        uint64 objId = data.addMonsterObj(_classId, _player, _name);\r\n        uint8 value;\r\n        uint seed = getRandom(_player, block.number-1, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i+= 1) {\r\n            value = uint8((seed * (i + 1)) % STAT_MAX) + data.getElementInArrayType(EtheremonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EtheremonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n        \r\n        EtheremonMonsterNFTInterface(monsterNFT).triggerTransferEvent(address(0), _player, objId);\r\n        return objId; \r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_trainer\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"mintMonster\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"moderators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"catchMonsterNFT\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gapFactor\",\"type\":\"uint256\"},{\"name\":\"_priceIncreasingRatio\",\"type\":\"uint256\"}],\"name\":\"setConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataContract\",\"type\":\"address\"},{\"name\":\"_monsterNFT\",\"type\":\"address\"}],\"name\":\"setContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setClassWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isMaintaining\",\"type\":\"bool\"}],\"name\":\"UpdateMaintaining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAT_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalModerators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sendTo\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monsterNFT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newModerator\",\"type\":\"address\"}],\"name\":\"AddModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint64\"}],\"name\":\"burnMonster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"}],\"name\":\"getMonsterClassBasic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_smartcontract\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAddressWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldModerator\",\"type\":\"address\"}],\"name\":\"RemoveModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"catchMonster\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gapFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_block\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getRandom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAT_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"catchable\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceIncreasingRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMaintaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtheremonWorldNFT","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c487092e6bab47beee44fc454895afff61aa580de1996fc055591102ee61add5"}]}