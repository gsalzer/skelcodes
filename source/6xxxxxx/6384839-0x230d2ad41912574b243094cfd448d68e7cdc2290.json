{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n\r\nlibrary Player{\r\n\r\n    using NameFilter for string;\r\n\r\n    address public constant AUTHOR =  0x001C9b3392f473f8f13e9Eaf0619c405AF22FC26a7;\r\n    \r\n    struct Map{\r\n        mapping(address=>uint256) map;\r\n        mapping(address=>address) referrerMap;\r\n        mapping(address=>bytes32) addrNameMap;\r\n        mapping(bytes32=>address) nameAddrMap;\r\n    }\r\n    \r\n    function deposit(Map storage  ps,address adr,uint256 v) internal returns(uint256) {\r\n       ps.map[adr]+=v;\r\n        return v;\r\n    }\r\n    \r\n    function depositAuthor(Map storage  ps,uint256 v) public returns(uint256) {\r\n        return deposit(ps,AUTHOR,v);\r\n    }\r\n\r\n    function withdrawal(Map storage  ps,address adr,uint256 num) public returns(uint256) {\r\n        uint256 sum = ps.map[adr];\r\n        if(sum==num){\r\n            withdrawalAll(ps,adr);\r\n        }\r\n        require(sum > num);\r\n        ps.map[adr] = (sum-num);\r\n        return sum;\r\n    }\r\n    \r\n    function withdrawalAll(Map storage  ps,address adr) public returns(uint256) {\r\n        uint256 sum = ps.map[adr];\r\n        require(sum >= 0);\r\n        delete ps.map[adr];\r\n        return sum;\r\n    }\r\n    \r\n    function getAmmount(Map storage ps,address adr) public view returns(uint256) {\r\n        return ps.map[adr];\r\n    }\r\n    \r\n    function registerName(Map storage ps,bytes32 _name)internal  {\r\n        require(ps.nameAddrMap[_name] == address(0) );\r\n        ps.nameAddrMap[_name] = msg.sender;\r\n        ps.addrNameMap[msg.sender] = _name;\r\n    }\r\n    \r\n    function isEmptyName(Map storage ps,bytes32 _name) public view returns(bool) {\r\n        return ps.nameAddrMap[_name] == address(0);\r\n    }\r\n    \r\n    function getByName(Map storage ps,bytes32 _name)public view returns(address) {\r\n        return ps.nameAddrMap[_name] ;\r\n    }\r\n    \r\n    function getName(Map storage ps) public view returns(bytes32){\r\n        return ps.addrNameMap[msg.sender];\r\n    }\r\n    \r\n    function getNameByAddr(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getReferrer(Map storage ps,address adr)public view returns(address){\r\n        return ps.referrerMap[adr];\r\n    }\r\n    \r\n    function getReferrerName(Map storage ps,address adr)public view returns(bytes32){\r\n        return getNameByAddr(ps,getReferrer(ps,adr));\r\n    }\r\n    \r\n    function setReferrer(Map storage ps,address self,address referrer)internal {\r\n         ps.referrerMap[self] = referrer;\r\n    }\r\n    \r\n    function applyReferrer(Map storage ps,string referrer)internal {\r\n        require(getReferrer(ps,msg.sender) == address(0));\r\n        bytes32 rbs = referrer.nameFilter();\r\n        address referrerAdr = getByName(ps,rbs);\r\n        if(referrerAdr != msg.sender){\r\n            setReferrer(ps,msg.sender,referrerAdr);\r\n        }\r\n    }    \r\n    \r\n    function withdrawalFee(Map storage ps,uint256 fee) public returns (uint256){\r\n        if(msg.value > 0){\r\n            require(msg.value >= fee,\"msg.value < fee\");\r\n            return fee;\r\n        }\r\n        require(getAmmount(ps,msg.sender)>=fee ,\"players.getAmmount(msg.sender)<fee\");\r\n        withdrawal(ps,msg.sender,fee);\r\n        return fee;\r\n    }   \r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n    \r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n    \r\n    function pwrFloat(uint256 tar,uint256 numerator,uint256 denominator,uint256 pwrN) public pure returns(uint256) {\r\n        for(uint256 i=0;i<pwrN;i++){\r\n            tar = tar * numerator / denominator;\r\n        }\r\n        return tar ;\r\n        \r\n    }\r\n\r\n    \r\n    function mulRate(uint256 tar,uint256 rate) public pure returns (uint256){\r\n        return tar *rate / 100;\r\n    }\r\n \r\n    \r\n    \r\n}\r\n\r\nlibrary ArrayUtils {\r\n    \r\n    function removeByIdx(uint256[] array,uint256 idx) public pure returns(uint256[] memory){\r\n         uint256[] memory ans = copy(array,array.length-1);\r\n        while((idx+1) < array.length){\r\n            ans[idx] = array[idx+1];\r\n            idx++;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function copy(uint256[] array,uint256 len) public pure returns(uint256[] memory){\r\n        uint256[] memory ans = new uint256[](len);\r\n        len = len > array.length? array.length : len;\r\n        for(uint256 i =0;i<len;i++){\r\n            ans[i] = array[i];\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function getHash(uint256[] array) public pure returns(uint256) {\r\n        uint256 baseStep =100;\r\n        uint256 pow = 1;\r\n        uint256 ans = 0;\r\n        for(uint256 i=0;i<array.length;i++){\r\n            ans= ans+ uint256(array[i] *pow ) ;\r\n            pow= pow* baseStep;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function contains(address[] adrs,address adr)public pure returns(bool){\r\n        for(uint256 i=0;i<adrs.length;i++){\r\n            if(adrs[i] ==  adr) return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n}\r\n\r\nlibrary CommUtils{\r\n    \r\n    using ArrayUtils for uint256[];\r\n    \r\n    function random(uint256 max,uint256 mixed) public view returns(uint256){\r\n        uint256 lastBlockNumber = block.number - 1;\r\n        uint256 hashVal = uint256(blockhash(lastBlockNumber));\r\n        hashVal += 31*uint256(block.coinbase);\r\n        hashVal += 19*mixed;\r\n        hashVal += 17*uint256(block.difficulty);\r\n        hashVal += 13*uint256(block.gaslimit );\r\n        hashVal += 11*uint256(now );\r\n        hashVal += 7*uint256(block.timestamp );\r\n        hashVal += 3*uint256(tx.origin);\r\n        return uint256(hashVal % max);\r\n    } \r\n    \r\n    function getIdxArray(uint256 len) public pure returns(uint256[]){\r\n        uint256[] memory ans = new uint256[](len);\r\n        for(uint128 i=0;i<len;i++){\r\n            ans[i] = i;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function genRandomArray(uint256 digits,uint256 templateLen,uint256 base) public view returns(uint256[]) {\r\n        uint256[] memory ans = new uint256[](digits);\r\n        uint256[] memory idxs  = getIdxArray( templateLen);\r\n       for(uint256 i=0;i<digits;i++){\r\n            uint256  idx = random(idxs.length,i+base);\r\n            uint256 wordIdx = idxs[idx];\r\n            ans[i] = wordIdx;\r\n            idxs = idxs.removeByIdx(idx);\r\n           \r\n       }\r\n       return ans;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary PlayerReply{\r\n    \r\n    using ArrayUtils for address[];\r\n    using ArrayUtils for uint256[];\r\n    \r\n    uint256 constant VISABLE_NONE = 0;\r\n    uint256 constant VISABLE_FINAL = 1;\r\n    uint256 constant VISABLE_ALL = 2;\r\n    uint256 constant VISABLE_OWNER = 3;\r\n    uint256 constant VISABLE_BUYED = 4;\r\n    \r\n    uint256 constant HIDE_TIME = 5*60;\r\n    \r\n    uint256 constant GRAND_TOTAL_TIME = 10*60;\r\n    \r\n    \r\n    struct Data{\r\n        address[] ownerIds;\r\n        uint256 aCount;\r\n        uint256 bCount;\r\n        uint256[] answer;\r\n        uint replyAt;\r\n    }\r\n    \r\n    struct List{\r\n        uint256 size;\r\n        mapping (uint256 => uint256) hashIds;\r\n        mapping (uint256 => Data) map;\r\n        mapping (uint256=>uint256) sellPriceMap;\r\n        mapping (uint256=>address) seller;\r\n        mapping (uint256=>address[]) buyer;\r\n    }\r\n    \r\n    \r\n    function init(Data storage d,uint256 ac,uint256 bc,address own) internal{\r\n          d.ownerIds.push(own)  ;\r\n          d.aCount = ac;\r\n          d.bCount = bc;\r\n          d.replyAt = now;\r\n    }\r\n    \r\n    function clear(List storage ds) internal{\r\n        for(uint256 i =0;i<ds.size;i++){\r\n            uint256 key = ds.hashIds[i];\r\n            delete ds.map[key];\r\n            delete ds.sellPriceMap[key];\r\n            delete ds.seller[key];\r\n            delete ds.buyer[key];\r\n            delete ds.hashIds[i];\r\n        }\r\n        ds.size = 0;\r\n    }\r\n    \r\n    function setSellPrice(List storage ds,uint256 ansHash,uint256 price) internal {\r\n        require(ds.map[ansHash].ownerIds.contains(msg.sender));\r\n        require(ds.seller[ansHash] == address(0));\r\n        ds.seller[ansHash] = msg.sender;\r\n        ds.sellPriceMap[ansHash] = price;\r\n    }\r\n    \r\n    function getSellPrice(List storage ds,uint256 idx) public view returns(uint256) {\r\n        return ds.sellPriceMap[ds.hashIds[idx]] ;\r\n    }\r\n    \r\n    function isOwner(Data storage d) internal view returns(bool){\r\n        return d.replyAt>0 && d.answer.length>0 && d.ownerIds.contains(msg.sender);\r\n    }\r\n    \r\n    function isWined(Data storage d) internal view returns(bool){\r\n        return d.replyAt>0 && d.answer.length>0 && d.aCount == d.answer.length ;\r\n    }\r\n    \r\n    function getWin(List storage ds) internal view returns(Data storage lastAns){\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            Data storage d = get(ds,i);\r\n           if(isWined(d)){\r\n             return d;  \r\n           } \r\n        }\r\n        \r\n        return lastAns;\r\n    }\r\n    \r\n    function getVisibleType(List storage ds,uint256 ansHash) internal view returns(uint256) {\r\n        Data storage d = ds.map[ansHash];\r\n        if(d.ownerIds.contains(msg.sender)){\r\n            return VISABLE_OWNER;\r\n        }else if(d.answer.length == d.aCount){\r\n            return VISABLE_FINAL;\r\n        }else if(ds.buyer[ansHash].contains(msg.sender)){\r\n            return VISABLE_BUYED;\r\n        }else if((now - d.replyAt)> HIDE_TIME && ds.sellPriceMap[ansHash] == 0){\r\n            return VISABLE_ALL;\r\n        }\r\n        return VISABLE_NONE;\r\n    }\r\n    \r\n    function getReplay(List storage ds,uint256 idx) internal view returns(\r\n        uint256 ,//aCount;\r\n        uint256,// bCount;\r\n        uint256[],// answer;\r\n        uint,// Timeline;\r\n        uint256, // VisibleType\r\n        uint256, //sellPrice\r\n        uint256 //ansHash\r\n        ) {\r\n            uint256 ansHash = ds.hashIds[idx];\r\n            uint256 sellPrice = ds.sellPriceMap[ansHash];\r\n            Data storage d= ds.map[ansHash];\r\n            uint256 vt = getVisibleType(ds,ansHash);\r\n        return (\r\n            d.aCount,\r\n            d.bCount,\r\n            vt!=VISABLE_NONE ?  d.answer : new uint256[](0),\r\n            now-d.replyAt,\r\n            vt,\r\n            sellPrice,\r\n            vt!=VISABLE_NONE ? ansHash : 0\r\n        );\r\n    } \r\n    \r\n    function listBestScore(List storage ds) internal view returns(\r\n        uint256 aCount , //aCount    \r\n        uint256 bCount , //bCount\r\n        uint256 bestCount // Count\r\n        ){\r\n        uint256 sorce = 0;\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            Data storage d = get(ds,i);\r\n            uint256 curSore = (d.aCount *100) + d.bCount;\r\n            if(curSore > sorce){\r\n                aCount = d.aCount;\r\n                bCount = d.bCount;\r\n                sorce = curSore;\r\n                bestCount = 1;\r\n            }else if(curSore == sorce){\r\n                bestCount++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function getOrGenByAnwser(List storage ds,uint256[] ans) internal  returns(Data storage ){\r\n        uint256 ansHash = ans.getHash();\r\n        Data storage d = ds.map[ansHash];\r\n        if(d.answer.length>0) return d;\r\n        d.answer = ans;\r\n        ds.hashIds[ds.size] = ansHash;\r\n        ds.size ++;\r\n        return d;\r\n    }\r\n    \r\n    \r\n    function get(List storage ds,uint256 idx) public view returns(Data storage){\r\n        return ds.map[ ds.hashIds[idx]];\r\n    }\r\n    \r\n    function getByHash(List storage ds ,uint256 ansHash)public view returns(Data storage){\r\n        return ds.map[ansHash];\r\n    }\r\n    \r\n    \r\n    function getLastReplyAt(List storage list) internal view returns(uint256){\r\n        return list.size>0 ? (now- get(list,list.size-1).replyAt) : 0;\r\n    }\r\n    \r\n    function getLastReply(List storage ds) internal view returns(Data storage d){\r\n        if( ds.size>0){\r\n            return get(ds,ds.size-1);\r\n        }\r\n        return d;\r\n    }    \r\n    \r\n    function countByGrand(List storage ds) internal view returns(uint256) {\r\n        if(ds.size == 0 ) return 0;\r\n        uint256 count = 0;\r\n        uint256 _lastAt = now;\r\n        uint256 lastIdx = ds.size-1;\r\n        Data memory d = get(ds,lastIdx-count);\r\n        while((_lastAt - d.replyAt)<= GRAND_TOTAL_TIME ){\r\n            count++;\r\n            _lastAt = d.replyAt;\r\n            if(count>lastIdx) return count;\r\n            d = get(ds,lastIdx-count);\r\n        }\r\n        return count;       \r\n    }\r\n    \r\n}\r\n\r\n\r\nlibrary RoomInfo{\r\n    \r\n    using PlayerReply for PlayerReply.Data;\r\n    using PlayerReply for PlayerReply.List;\r\n    using Player for Player.Map;\r\n    using ArrayUtils for uint256[];\r\n    uint256 constant DIVIDEND_AUTH = 5;\r\n    uint256 constant DIVIDEND_INVITE = 2;\r\n    uint256 constant DIVIDEND_INVITE_REFOUND = 3;\r\n    uint256 constant DECIMAL_PLACE = 100;\r\n\r\n    uint256 constant GRAND_RATE = 110;\r\n    \r\n    \r\n    \r\n    struct Data{\r\n        address ownerId;\r\n        uint256 charsLength;\r\n        uint256[] answer;\r\n        PlayerReply.List replys;\r\n        bytes32 name;\r\n        uint256 prize;\r\n        uint256 minReplyFee;\r\n        uint256 replayCount;\r\n        uint256 firstReplayAt;\r\n        uint256 rateCode;\r\n        uint256 round;\r\n        uint256 maxReplyFeeRate;\r\n        uint256 toAnswerRate;\r\n        uint256 toOwner;\r\n        uint256 nextRoundRate;\r\n        uint256 increaseRate_1000;\r\n        uint256 initAwardTime ;\r\n        uint256 plusAwardTime ;\r\n    }\r\n    \r\n    struct List{\r\n        mapping(uint256 => Data)  map;\r\n        uint256  size ;\r\n    }\r\n    \r\n    \r\n    \r\n    function genOrGetReplay(Data storage d,uint256[] ans) internal returns(PlayerReply.Data storage ) {\r\n        (PlayerReply.Data storage replayData)  = d.replys.getOrGenByAnwser(ans);\r\n        d.replayCount++;\r\n        if(d.firstReplayAt == 0) d.firstReplayAt = now;\r\n        return (replayData);\r\n    }\r\n    \r\n    function tryAnswer(Data storage d ,uint256[] _t ) internal view returns(uint256,uint256){\r\n        require(d.answer.length == _t.length);\r\n        uint256 aCount;\r\n        uint256 bCount;\r\n        for(uint256 i=0;i<_t.length;i++){\r\n            for(uint256 j=0;j<d.answer.length;j++){\r\n                if(d.answer[j] == _t[i]){\r\n                    if(i == j){\r\n                        aCount++;\r\n                    }else{\r\n                        bCount ++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return (aCount,bCount);\r\n    }\r\n\r\n    function init(\r\n        Data storage d,\r\n        uint256 digits,\r\n        uint256 templateLen,\r\n        bytes32 n,\r\n        uint256 toAnswerRate,\r\n        uint256 toOwner,\r\n        uint256 nextRoundRate,\r\n        uint256 minReplyFee,\r\n        uint256 maxReplyFeeRate,\r\n        uint256 increaseRate_1000,\r\n        uint256 initAwardTime,\r\n        uint256 plusAwardTime\r\n        ) public {\r\n        require(maxReplyFeeRate<1000 && maxReplyFeeRate > 5 );\r\n        require(minReplyFee<= msg.value *maxReplyFeeRate /DECIMAL_PLACE && minReplyFee>= 0.000005 ether);\r\n        require(digits>=2 && digits <= 9 );\r\n        require((toAnswerRate+toOwner)<=90);\r\n        require(msg.value >= 0.001 ether);\r\n        require(nextRoundRate <= 70);\r\n        require(templateLen >= 10);\r\n        require(initAwardTime < 60*60*24*90);\r\n        require(plusAwardTime < 60*60*24*20);\r\n        require(SafeMath.mulRate(msg.value,100-nextRoundRate) >= minReplyFee);\r\n        \r\n        d.charsLength = templateLen;\r\n        d.answer = CommUtils.genRandomArray(digits,templateLen,0);       \r\n        d.ownerId = msg.sender;\r\n        d.name = n;\r\n        d.prize = msg.value;\r\n        d.minReplyFee = minReplyFee;\r\n        d.round = 1;\r\n        d.maxReplyFeeRate = maxReplyFeeRate;\r\n        d.toAnswerRate = toAnswerRate;\r\n        d.toOwner = toOwner;\r\n        d.nextRoundRate = nextRoundRate;\r\n        d.increaseRate_1000 = increaseRate_1000;\r\n        d.initAwardTime = initAwardTime;\r\n        d.plusAwardTime = plusAwardTime;\r\n        \r\n    }\r\n    \r\n    function replayAnser(Data storage r,Player.Map storage ps,uint256 fee,uint256[] tryA) internal returns(\r\n            uint256, // aCount\r\n            uint256 // bCount\r\n        )  {\r\n        (uint256 a, uint256 b) = tryAnswer(r,tryA);\r\n        saveReplyFee(r,ps,fee);\r\n        (PlayerReply.Data storage pr) = genOrGetReplay(r,tryA);\r\n        pr.init(a,b,msg.sender); \r\n        return (a,b);\r\n    }\r\n    \r\n    function saveReplyFee(Data storage d,Player.Map storage ps,uint256 replayFee) internal  {\r\n        uint256 lessFee = replayFee;\r\n        //uint256 toAnswerRate= rates[IdxToAnswerRate];\r\n        //uint256 toOwner = rates[IdxToOwnerRate];\r\n        \r\n        lessFee -=sendReplayDividend(d,ps,replayFee*d.toAnswerRate/DECIMAL_PLACE);\r\n        address refer = ps.getReferrer(msg.sender);\r\n        if(refer == address(0)){\r\n            lessFee -=ps.depositAuthor(replayFee*(DIVIDEND_AUTH+DIVIDEND_INVITE+DIVIDEND_INVITE_REFOUND)/DECIMAL_PLACE);            \r\n        }else{\r\n            lessFee -=ps.deposit(msg.sender,replayFee*DIVIDEND_INVITE_REFOUND/DECIMAL_PLACE);\r\n            lessFee -=ps.deposit(refer,replayFee*DIVIDEND_INVITE/DECIMAL_PLACE);\r\n            lessFee -=ps.depositAuthor(replayFee*DIVIDEND_AUTH/DECIMAL_PLACE);\r\n        }\r\n        lessFee -=ps.deposit(d.ownerId,replayFee*d.toOwner/DECIMAL_PLACE);\r\n        \r\n        d.prize += lessFee;\r\n    }\r\n    \r\n    function sendReplayDividend(Data storage d,Player.Map storage ps,uint256 ammount) private returns(uint256) {\r\n        if(d.replayCount <=0) return 0;\r\n        uint256 oneD = ammount /  d.replayCount;\r\n        for(uint256 i=0;i<d.replys.size;i++){\r\n            PlayerReply.Data storage rp = d.replys.get(i);\r\n            for(uint256 j=0;j<rp.ownerIds.length;j++){\r\n                ps.deposit(rp.ownerIds[j],oneD);          \r\n            }\r\n        }\r\n        return ammount;\r\n    }\r\n\r\n    \r\n    \r\n    function getReplay(Data storage d,uint256 replayIdx) internal view returns(\r\n        uint256 ,//aCount;\r\n        uint256,// bCount;\r\n        uint256[],// answer;\r\n        uint,// replyAt;\r\n        uint256, // VisibleType\r\n        uint256, //sellPrice\r\n        uint256 //ansHash\r\n        ) {\r\n        return d.replys.getReplay(replayIdx);\r\n    }   \r\n    \r\n    function isAbleNextRound(Data storage d,uint256 nextRound) internal view returns(bool){\r\n        return ( SafeMath.mulRate(nextRound,100-d.nextRoundRate)> d.minReplyFee  );\r\n    }    \r\n    \r\n    function clearAndNextRound(Data storage d,uint256 prize) internal {\r\n        d.prize = prize;\r\n        d.replys.clear();\r\n        d.replayCount  = 0;\r\n        d.firstReplayAt = 0;\r\n        d.round++;\r\n        d.answer = CommUtils.genRandomArray(d.answer.length,d.charsLength,0); \r\n    }\r\n    \r\n    function getReplyFee(Data storage d) internal view returns(uint256){\r\n        uint256 prizeMax = (d.prize *  d.maxReplyFeeRate ) /DECIMAL_PLACE;\r\n        uint256 ans = SafeMath.pwrFloat(d.minReplyFee, d.increaseRate_1000 +1000,1000,d.replys.size);\r\n        ans = ans > prizeMax ? prizeMax : ans;\r\n        uint256 count = d.replys.countByGrand();\r\n        if(count>0){\r\n            ans = SafeMath.pwrFloat(ans,GRAND_RATE,DECIMAL_PLACE,count);       \r\n        }\r\n        ans = ans < d.minReplyFee ? d.minReplyFee : ans;\r\n        return ans;\r\n    }\r\n    \r\n    function sellReply(Data storage d,Player.Map storage ps,uint256 ansHash,uint256 price,uint256 fee) internal{\r\n        d.replys.setSellPrice(ansHash,price);\r\n        saveReplyFee(d,ps,fee);\r\n    }\r\n    \r\n    function buyReply(Data storage d,Player.Map storage ps,uint256 replyIdx,uint256 buyFee) internal{\r\n        uint256 ansHash = d.replys.hashIds[replyIdx];\r\n        require(buyFee >= d.replys.getSellPrice(replyIdx) ,\"buyFee to less\");\r\n        require(d.replys.seller[ansHash]!=address(0),\"d.replys.seller[ansHash]!=address(0)\");\r\n        d.replys.buyer[ansHash].push(msg.sender);\r\n        uint256 lessFee = buyFee;\r\n        address refer = ps.referrerMap[msg.sender];\r\n        if(refer == address(0)){\r\n            lessFee -=ps.depositAuthor(buyFee*(DIVIDEND_AUTH+DIVIDEND_INVITE+DIVIDEND_INVITE_REFOUND)/100);            \r\n        }else{\r\n            lessFee -=ps.deposit(msg.sender,buyFee*DIVIDEND_INVITE_REFOUND/100);\r\n            lessFee -=ps.deposit(refer,buyFee*DIVIDEND_INVITE/100);\r\n            lessFee -=ps.depositAuthor(buyFee*DIVIDEND_AUTH/100);\r\n        }        \r\n        lessFee -=ps.deposit(d.ownerId,buyFee*    d.toOwner  /100);\r\n        ps.deposit(d.replys.seller[ansHash],lessFee);\r\n    }\r\n    \r\n    \r\n    function getGameItem(Data storage d) public view returns(\r\n        bytes32, //name\r\n        uint256, //bestACount \r\n        uint256, //bestBCount\r\n        uint256, //answer count\r\n        uint256, //totalPrize\r\n        uint256, // reply Fee\r\n        uint256 //OverTimeLeft\r\n        ){\r\n             (uint256 aCount,uint256 bCount,uint256 bestCount) = d.replys.listBestScore();\r\n             bestCount = bestCount;\r\n             uint256 fee = getReplyFee(d);\r\n             uint256 overTimeLeft = getOverTimeLeft(d);\r\n             uint256 replySize = d.replys.size;\r\n        return(\r\n            d.name,\r\n            d.prize,\r\n            aCount,\r\n            bCount,\r\n            replySize,\r\n            fee,\r\n            overTimeLeft\r\n        );  \r\n        \r\n    }    \r\n    \r\n    function getByPrizeLeast(List storage ds) internal view returns (Data storage){\r\n        Data storage ans = ds.map[0];\r\n        uint256 _cp = ans.prize;\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            if(_cp > ds.map[i].prize){\r\n                ans= ds.map[i];\r\n                _cp = ans.prize;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function getByPrizeLargestIdx(List storage ds) internal view returns (uint256 ){\r\n        uint256 ans = 0;\r\n        uint256 _cp = 0;\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            if(_cp < ds.map[i].prize){\r\n                ans= i;\r\n                _cp = ds.map[i].prize;\r\n            }\r\n        }\r\n        return ans;\r\n    }    \r\n    \r\n    function getByName(List storage ds,bytes32 name) internal view returns( Data ){\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            if(ds.map[i].name == name){\r\n                return ds.map[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getIdxByNameElseLargest(List storage ds,bytes32 name) internal view returns( uint256 ){\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            if(ds.map[i].name == name){\r\n                return i;\r\n            }\r\n        }\r\n        return getByPrizeLargestIdx(ds);\r\n    } \r\n    \r\n    function getEmpty(List storage ds) internal returns(Data storage){\r\n        for(uint256 i=0;i<ds.size;i++){\r\n            if(ds.map[i].ownerId == address(0)){\r\n                return ds.map[i];\r\n            }\r\n        }\r\n        uint256 lastIdx= ds.size++;\r\n        return ds.map[lastIdx];\r\n    }\r\n    \r\n    \r\n    function award(RoomInfo.Data storage r,Player.Map storage players) internal  returns(\r\n            address[] memory winners,\r\n            uint256[] memory rewords,\r\n            uint256 nextRound\r\n        \r\n        )  {\r\n        (PlayerReply.Data storage pr) = getWinReply(r);\r\n        require( pr.isOwner(),\" pr.isSelfWinnwer()\");\r\n        \r\n        nextRound = r.nextRoundRate * r.prize / 100;\r\n        require(nextRound<=r.prize, \"nextRound<=r.prize\");\r\n        uint256 reward = r.prize - nextRound;\r\n        address[] storage ownerIds = pr.ownerIds;\r\n        winners = new address[](ownerIds.length);\r\n        rewords = new uint256[](ownerIds.length);\r\n        uint256 sum = 0;\r\n        if(ownerIds.length==1){\r\n            sum +=players.deposit(msg.sender , reward);\r\n            winners[0] = msg.sender;\r\n            rewords[0] = reward;\r\n           // emit Wined(msg.sender , reward,roomIdx ,players.getNameByAddr(msg.sender) );\r\n        }else{\r\n            uint256 otherReward = reward * 30 /100;\r\n            reward -= otherReward;\r\n            otherReward = otherReward / (ownerIds.length-1);\r\n            bool firstGived = false;\r\n            for(uint256 i=0;i<ownerIds.length;i++){\r\n                if(!firstGived && ownerIds[i] == msg.sender){\r\n                    firstGived = true;\r\n                    sum +=players.deposit(ownerIds[i] , reward);\r\n                    winners[i] = ownerIds[i];\r\n                    rewords[i] = reward;\r\n                   // emit Wined(ownerIds[i] , reward,roomIdx,players.getNameByAddr(ownerIds[i] ));\r\n                }else{\r\n                    sum +=players.deposit(ownerIds[i] , otherReward);\r\n                    //emit Wined(ownerIds[i] , otherReward,roomIdx,players.getNameByAddr(ownerIds[i] ));\r\n                    winners[i] = ownerIds[i];\r\n                    rewords[i] = otherReward;\r\n                }\r\n            }\r\n        }     \r\n        if(sum>(r.prize-nextRound)){\r\n            revert(\"sum>(r.prize-nextRound)\");\r\n        }\r\n    }    \r\n    \r\n    function getOverTimeLeft(Data storage d) internal view returns(uint256){\r\n        if(d.replayCount == 0) return 0;\r\n        //uint256 time = (d.replayCount * 5 * 60 )+ (3*24*60*60) ;\r\n        uint256 time = (d.replayCount *d.plusAwardTime )+ d.initAwardTime ;\r\n        uint256 spendT = (now-d.firstReplayAt);\r\n        if(time<spendT) return 0;\r\n        return time - spendT ;\r\n    }\r\n    \r\n    \r\n    function getWinReply(Data storage d) internal view returns (PlayerReply.Data storage){\r\n        PlayerReply.Data storage pr = d.replys.getWin();\r\n        if(pr.isWined()) return pr;\r\n        if(d.replayCount > 0 && getOverTimeLeft(d)==0 ) return d.replys.getLastReply();\r\n        return pr;\r\n    }\r\n    \r\n    function getRoomExReplyInfo(Data storage r) internal view returns(uint256 time,uint256 count) {\r\n        time = r.replys.getLastReplyAt();\r\n        count = r.replys.countByGrand();\r\n    }\r\n    \r\n    function get(List storage ds,uint256 idx) internal view returns(Data storage){\r\n        return ds.map[idx];\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"d\",\"type\":\"RoomInfo.Data storage\"},{\"name\":\"digits\",\"type\":\"uint256\"},{\"name\":\"templateLen\",\"type\":\"uint256\"},{\"name\":\"n\",\"type\":\"bytes32\"},{\"name\":\"toAnswerRate\",\"type\":\"uint256\"},{\"name\":\"toOwner\",\"type\":\"uint256\"},{\"name\":\"nextRoundRate\",\"type\":\"uint256\"},{\"name\":\"minReplyFee\",\"type\":\"uint256\"},{\"name\":\"maxReplyFeeRate\",\"type\":\"uint256\"},{\"name\":\"increaseRate_1000\",\"type\":\"uint256\"},{\"name\":\"initAwardTime\",\"type\":\"uint256\"},{\"name\":\"plusAwardTime\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"d\",\"type\":\"RoomInfo.Data storage\"}],\"name\":\"getGameItem\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RoomInfo","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"CommUtils:6e03977259acd6877fe0c5fc12c91d479a173a32;SafeMath:7ece3cf62ce9ecc907fd3fc5765c56bbe2ca262d","SwarmSource":"bzzr://0ae011f392f61e8a050b0f71b240186b0a877b534403ad5e7320a6857ea66113"}]}