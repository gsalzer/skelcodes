{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract WorldByEth {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    \r\n\r\n    string constant public name = \"ETH world cq\";\r\n    string constant public symbol = \"ecq\";\r\n    uint256 public rID_;\r\n    uint256 public pID_;\r\n    uint256 public com_;\r\n    address public comaddr = 0x9ca974f2c49d68bd5958978e81151e6831290f57;\r\n    mapping(uint256 => uint256) public pot_;\r\n    mapping(uint256 => mapping(uint256 => Ctry)) public ctry_;\r\n    uint public gap = 1 hours;\r\n    uint public timeleft;\r\n    address public lastplayer = 0x9ca974f2c49d68bd5958978e81151e6831290f57;\r\n    address public lastwinner;\r\n    uint[] public validplayers;\r\n\r\n    struct Ctry {\r\n        uint256 id;\r\n        uint256 price;\r\n        bytes32 name;\r\n        bytes32 mem;\r\n        address owner;\r\n    }\r\n\r\n    mapping(uint256 => uint256) public totalinvest_;\r\n\r\n    //===========\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        require(_addr == tx.origin);\r\n        \r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    constructor()\r\n    public\r\n    {\r\n        pID_++;\r\n        rID_++;\r\n        validplayers.length = 0;\r\n        timeleft = now + 24 hours;\r\n    }\r\n\r\n    function getvalid()\r\n    public\r\n    returns(uint[]){\r\n        return validplayers;\r\n    }\r\n    \r\n    function changemem(uint id, bytes32 mem)\r\n    isHuman\r\n    public\r\n    payable\r\n    {\r\n        require(msg.value >= 0.1 ether);\r\n        require(msg.sender == ctry_[rID_][id].owner);\r\n        com_ += msg.value;\r\n        if (mem != \"\"){\r\n            ctry_[rID_][id].mem = mem;\r\n        }\r\n    }\r\n\r\n    function buy(uint id, bytes32 mem)\r\n    isHuman\r\n    public\r\n    payable\r\n    {\r\n        require(msg.value >= 0.01 ether);\r\n        require(msg.value >=ctry_[rID_][id].price);\r\n\r\n        if (mem != \"\"){\r\n            ctry_[rID_][id].mem = mem;\r\n        }\r\n\r\n        if (update() == true) {\r\n            uint com = (msg.value).div(100);\r\n            com_ += com;\r\n\r\n            uint pot = (msg.value).mul(9).div(100);\r\n            pot_[rID_] += pot;\r\n\r\n            uint pre = msg.value - com - pot;\r\n        \r\n            if (ctry_[rID_][id].owner != address(0x0)){\r\n                ctry_[rID_][id].owner.transfer(pre);\r\n            }else{\r\n                validplayers.push(id);\r\n            }    \r\n            ctry_[rID_][id].owner = msg.sender;\r\n            ctry_[rID_][id].price = (msg.value).mul(14).div(10);\r\n        }else{\r\n            rID_++;\r\n            validplayers.length = 0;\r\n            ctry_[rID_][id].owner = msg.sender;\r\n            ctry_[rID_][id].price = (0.01 ether).mul(14).div(10);\r\n            validplayers.push(id);\r\n            (msg.sender).transfer(msg.value - 0.01 ether);\r\n        }\r\n\r\n        lastplayer = msg.sender;\r\n        totalinvest_[rID_] += msg.value;\r\n        ctry_[rID_][id].id = id;\r\n    }\r\n\r\n    function update()\r\n    private\r\n    returns(bool)\r\n    {\r\n        if (now > timeleft) {\r\n            lastplayer.transfer(pot_[rID_].mul(6).div(10));\r\n            lastwinner = lastplayer;\r\n            com_ += pot_[rID_].div(10);\r\n            pot_[rID_+1] += pot_[rID_].mul(3).div(10);\r\n            timeleft = now + 24 hours;\r\n            return false;\r\n        }\r\n\r\n        timeleft += gap;\r\n        if (timeleft > now + 24 hours) {\r\n            timeleft = now + 24 hours;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function()\r\n    public\r\n    payable\r\n    {\r\n        com_ += msg.value;\r\n    }\r\n\r\n    modifier onlyDevs() {\r\n        require(\r\n            msg.sender == 0x9ca974f2c49d68bd5958978e81151e6831290f57,\r\n            \"only team just can activate\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // upgrade withdraw com_ and clear it to 0\r\n    function withcom()\r\n    onlyDevs\r\n    public\r\n    {\r\n        if (com_ <= address(this).balance){\r\n            comaddr.transfer(com_);\r\n            com_ = 0;\r\n        }else{\r\n            comaddr.transfer(address(this).balance);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n// File: contracts/library/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastplayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withcom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validplayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeleft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"mem\",\"type\":\"bytes32\"}],\"name\":\"changemem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ctry_\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"mem\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalinvest_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"com_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getvalid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"mem\",\"type\":\"bytes32\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastwinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"WorldByEth","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ae99dc082c367b90198edfb83d036b19398fe9eb31c8038d50111487ea85290"}]}