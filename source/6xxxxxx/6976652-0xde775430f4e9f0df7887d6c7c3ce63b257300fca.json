{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/lib/ownership/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n       require(newOwner != address(0));\r\n       emit OwnershipTransferred(owner, newOwner);\r\n       owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/lifecycle/Destructible.sol\r\n\r\ncontract Destructible is Ownable {\r\n\tfunction selfDestruct() public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n\tfunction addImmutableContract(string contractName, address newAddress) external;\r\n\tfunction updateContract(string contractName, address newAddress) external;\r\n\tfunction getContractName(uint index) public view returns (string);\r\n\tfunction getContract(string contractName) public view returns (address);\r\n\tfunction updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/lib/ownership/Upgradable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Upgradable {\r\n\r\n\taddress coordinatorAddr;\r\n\tZapCoordinatorInterface coordinator;\r\n\r\n\tconstructor(address c) public{\r\n\t\tcoordinatorAddr = c;\r\n\t\tcoordinator = ZapCoordinatorInterface(c);\r\n\t}\r\n\r\n    function updateDependencies() external coordinatorOnly {\r\n       _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal;\r\n\r\n    modifier coordinatorOnly() {\r\n    \trequire(msg.sender == coordinatorAddr, \"Error: Coordinator Only Function\");\r\n    \t_;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/platform/PiecewiseLogic.sol\r\n\r\nlibrary PiecewiseLogic {\r\n    function sumOfPowers(uint n, uint i) internal pure returns (uint) {\r\n        require(i <= 6 && i >= 0, \"Error: Invalid Piecewise Logic\");\r\n\r\n        if ( i == 0 ) return n;\r\n        if ( i == 1 ) return (n * (n + 1)) / 2;\r\n        if ( i == 2 ) return (n * (n + 1) * (2 * n + 1)) / 6;\r\n        if ( i == 3 ) return ((n * (n + 1)) / 2) ** 2;\r\n        if ( i == 4 ) return (n * (n + 1) * (2 * n + 1) * (3 * n * n + 3 * n - 1)) / 30;\r\n        if ( i == 5 ) return (n * (n + 1)) ** 2 * (2 * n ** 2 + 2 * n - 1);\r\n        if ( i == 6 ) return (n * (n + 1) * (2 * n + 1) * (3 * n ** 4 + 6 * n ** 3 - 3 * n + 1)) / 42;\r\n\r\n        // impossible\r\n        return 0;\r\n    }\r\n\r\n    function evaluateFunction(int[] curve, uint a, uint b) internal pure returns (int) {\r\n        uint i = 0;\r\n        int sum = 0;\r\n\r\n        // Require to be within the dot limit\r\n        require(a + b <= uint(curve[curve.length - 1]), \"Error: Function not in dot limit\");\r\n\r\n        // Loop invariant: i should always point to the start of a piecewise piece (the length)\r\n        while ( i < curve.length ) {\r\n            uint l = uint(curve[i]);\r\n            uint end = uint(curve[i + l + 1]);\r\n\r\n            // Index of the next piece's end\r\n            uint nextIndex = i + l + 2;\r\n\r\n            if ( a > end ) { // move on to the next piece\r\n                i = nextIndex;\r\n                continue;\r\n            }\r\n\r\n            sum += evaluatePiece(curve, i, a, (a + b > end) ? end - a : b);\r\n\r\n            if ( a + b <= end ) {\r\n                // Entire calculation is within this piece\r\n                return sum;\r\n            }\r\n            else {\r\n                b -= end - a + 1; // Remove the dots we've already bound from b\r\n                a = end;          // Move a up to the end\r\n                i = nextIndex;    // Move index up\r\n            }\r\n        }\r\n    }\r\n\r\n    function evaluatePiece(int[] curve, uint index, uint a, uint b) internal pure returns (int){\r\n        int sum = 0;\r\n        uint len = uint(curve[index]);\r\n        uint base = index + 1;\r\n        uint end = base + len; // index of last term\r\n\r\n        // iterate between index+1 and the end of this piece\r\n        for ( uint i = base; i < end; i++ ) {\r\n            sum += curve[i] * int(sumOfPowers(a + b, i - base) - sumOfPowers(a - 1, i - base));\r\n        }\r\n\r\n        require(sum >= 0, \"Error: Cost must be greater than zero\");\r\n        return sum;\r\n    }\r\n}\r\n\r\n// File: contracts/platform/registry/RegistryInterface.sol\r\n\r\n// Technically an abstract contract, not interface (solidity compiler devs are working to fix this right now)\r\n\r\ncontract RegistryInterface {\r\n    function initiateProvider(uint256, bytes32) public returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);\r\n    function setEndpointParams(bytes32, bytes32[]) public;\r\n    function getEndpointParams(address, bytes32) public view returns (bytes32[]);\r\n    function getProviderPublicKey(address) public view returns (uint256);\r\n    function getProviderTitle(address) public view returns (bytes32);\r\n    function setProviderParameter(bytes32, bytes) public;\r\n    function getProviderParameter(address, bytes32) public view returns (bytes);\r\n    function getAllProviderParams(address) public view returns (bytes32[]);\r\n    function getProviderCurveLength(address, bytes32) public view returns (uint256);\r\n    function getProviderCurve(address, bytes32) public view returns (int[]);\r\n    function isProviderInitiated(address) public view returns (bool);\r\n    function getAllOracles() external view returns (address[]);\r\n    function getProviderEndpoints(address) public view returns (bytes32[]);\r\n    function getEndpointBroker(address, bytes32) public view returns (address);\r\n}\r\n\r\n// File: contracts/platform/bondage/currentCost/CurrentCostInterface.sol\r\n\r\ncontract CurrentCostInterface {    \r\n    function _currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function _dotLimit(address, bytes32) public view returns (uint256);\r\n    function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/bondage/currentCost/CurrentCost.sol\r\n\r\ncontract CurrentCost is Destructible, CurrentCostInterface, Upgradable {\r\n\r\n    RegistryInterface registry;\r\n\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        registry = RegistryInterface(coordinator.getContract(\"REGISTRY\"));\r\n    }\r\n\r\n    /// @dev calculates current cost of dot\r\n    /// @param oracleAddress oracle address\r\n    /// @param endpoint oracle endpoint\r\n    /// @param start nth dot to calculate price of\r\n    /// @return cost of next dot\r\n    function _currentCostOfDot(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 start\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 cost)\r\n    {\r\n        return _costOfNDots(oracleAddress, endpoint, start, 0);\r\n    }\r\n\r\n    /// @dev calculates cost of n dots\r\n    /// @param oracleAddress oracle address\r\n    /// @param endpoint oracle endpoint\r\n    /// @param start nth dot to start calculating price at\r\n    /// @param nDots to bond\r\n    /// @return cost of next dot\r\n    function _costOfNDots(\r\n        address oracleAddress,\r\n        bytes32 endpoint,\r\n        uint256 start,\r\n        uint256 nDots\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 cost)\r\n    {\r\n\r\n\r\n        uint256 length = registry.getProviderCurveLength(oracleAddress,endpoint);\r\n        int[] memory curve = new int[](length);\r\n        curve = registry.getProviderCurve(oracleAddress, endpoint);\r\n\r\n        int res = PiecewiseLogic.evaluateFunction(curve, start, nDots);\r\n        require(res >= 0, \"Error: Cost of dots cannot be negative\");\r\n        return uint256(res);\r\n    }\r\n\r\n   function _dotLimit( \r\n        address oracleAddress,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 length = registry.getProviderCurveLength(oracleAddress,endpoint);\r\n        int[] memory curve = new int[](length);\r\n        curve = registry.getProviderCurve(oracleAddress, endpoint);\r\n\r\n        return uint(curve[length-1]);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"nDots\",\"type\":\"uint256\"}],\"name\":\"_costOfNDots\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"_dotLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"_currentCostOfDot\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"c\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CurrentCost","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a16","Library":"","SwarmSource":"bzzr://0e613ca071342f4e31e419171b20730db2bef1eb52556200b724ec7c83521ebd"}]}