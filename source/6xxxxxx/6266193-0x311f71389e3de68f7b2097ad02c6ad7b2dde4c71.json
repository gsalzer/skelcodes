{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n*\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* Web              - https://333eth.io\r\n* Twitter          - https://twitter.com/333eth_io\r\n* Telegram_channel - https://t.me/Ethereum333\r\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\r\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\r\n* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\r\n* Email:             mailto:support(at sign)333eth.io\r\n* \r\n*  - GAIN 3,33% PER 24 HOURS (every 5900 blocks)\r\n*  - Life-long payments\r\n*  - The revolutionary reliability\r\n*  - Minimal contribution 0.01 eth\r\n*  - Currency and payment - ETH\r\n*  - Contribution allocation schemes:\r\n*    -- 83% payments\r\n*    -- 17% Marketing + Operating Expenses\r\n*\r\n*   ---About the Project\r\n*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \r\n*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \r\n*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \r\n*  freely accessed online. In order to insure our investors' complete security, full control over the \r\n*  project has been transferred from the organizers to the smart contract: nobody can influence the \r\n*  system's permanent autonomous functioning.\r\n* \r\n* ---How to use:\r\n*  1. Send from ETH wallet to the smart contract address 0x311f71389e3DE68f7B2097Ad02c6aD7B2dDE4C71\r\n*     any amount from 0.01 ETH.\r\n*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \r\n*     of your wallet.\r\n*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \r\n*      spending too much on GAS)\r\n*  OR\r\n*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \r\n*      transaction), and only after that, deposit the amount that you want to reinvest.\r\n*  \r\n* RECOMMENDED GAS LIMIT: 200000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* You can check the payments on the etherscan.io site, in the \"Internal Txns\" tab of your wallet.\r\n*\r\n* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \r\n* have private keys.\r\n* \r\n* Contracts reviewed and approved by pros!\r\n* \r\n* Main contract - Revolution. Scroll down to find it.\r\n*/\r\n\r\n\r\ncontract InvestorsStorage {\r\n  struct investor {\r\n    uint keyIndex;\r\n    uint value;\r\n    uint paymentTime;\r\n    uint refBonus;\r\n  }\r\n  struct itmap {\r\n    mapping(address => investor) data;\r\n    address[] keys;\r\n  }\r\n  itmap private s;\r\n  address private owner;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"access denied\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    s.keys.length++;\r\n  }\r\n\r\n  function insert(address addr, uint value) public onlyOwner returns (bool) {\r\n    uint keyIndex = s.data[addr].keyIndex;\r\n    if (keyIndex != 0) return false;\r\n    s.data[addr].value = value;\r\n    keyIndex = s.keys.length++;\r\n    s.data[addr].keyIndex = keyIndex;\r\n    s.keys[keyIndex] = addr;\r\n    return true;\r\n  }\r\n\r\n  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint) {\r\n    return (\r\n      s.data[addr].keyIndex,\r\n      s.data[addr].value,\r\n      s.data[addr].paymentTime,\r\n      s.data[addr].refBonus\r\n    );\r\n  }\r\n\r\n  function investorBaseInfo(address addr) public view returns(uint, uint, uint) {\r\n    return (\r\n      s.data[addr].value,\r\n      s.data[addr].paymentTime,\r\n      s.data[addr].refBonus\r\n    );\r\n  }\r\n\r\n  function investorShortInfo(address addr) public view returns(uint, uint) {\r\n    return (\r\n      s.data[addr].value,\r\n      s.data[addr].refBonus\r\n    );\r\n  }\r\n\r\n  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].refBonus += refBonus;\r\n    return true;\r\n  }\r\n\r\n  function addValue(address addr, uint value) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].value += value;\r\n    return true;\r\n  }\r\n\r\n  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].paymentTime = paymentTime;\r\n    return true;\r\n  }\r\n\r\n  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\r\n    if (s.data[addr].keyIndex == 0) return false;\r\n    s.data[addr].refBonus = refBonus;\r\n    return true;\r\n  }\r\n\r\n  function keyFromIndex(uint i) public view returns (address) {\r\n    return s.keys[i];\r\n  }\r\n\r\n  function contains(address addr) public view returns (bool) {\r\n    return s.data[addr].keyIndex > 0;\r\n  }\r\n\r\n  function size() public view returns (uint) {\r\n    return s.keys.length;\r\n  }\r\n\r\n  function iterStart() public pure returns (uint) {\r\n    return 1;\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) return 0;\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  enum AccessRank { None, Payout, Paymode, Full }\r\n  mapping(address => AccessRank) internal m_admins;\r\n  modifier onlyAdmin(AccessRank  r) {\r\n    require(\r\n      m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full,\r\n      \"access denied\"\r\n    );\r\n    _;\r\n  }\r\n  event LogProvideAccess(address indexed whom, uint when,  AccessRank rank);\r\n\r\n  constructor() public {\r\n    m_admins[msg.sender] = AccessRank.Full;\r\n    emit LogProvideAccess(msg.sender, now, AccessRank.Full);\r\n  }\r\n  \r\n  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Full) {\r\n    require(rank <= AccessRank.Full, \"invalid access rank\");\r\n    require(m_admins[addr] != AccessRank.Full, \"cannot change full access rank\");\r\n    if (m_admins[addr] != rank) {\r\n      m_admins[addr] = rank;\r\n      emit LogProvideAccess(addr, now, rank);\r\n    }\r\n  }\r\n\r\n  function access(address addr) public view returns(AccessRank rank) {\r\n    rank = m_admins[addr];\r\n  }\r\n}\r\n\r\n\r\ncontract PaymentSystem {\r\n  // https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\r\n  enum Paymode { Push, Pull }\r\n  struct PaySys {\r\n    uint latestTime;\r\n    uint latestKeyIndex;\r\n    Paymode mode; \r\n  }\r\n  PaySys internal m_paysys;\r\n\r\n  modifier atPaymode(Paymode mode) {\r\n    require(m_paysys.mode == mode, \"pay mode does not the same\");\r\n    _;\r\n  }\r\n  event LogPaymodeChanged(uint when, Paymode indexed mode);\r\n  \r\n  function paymode() public view returns(Paymode mode) {\r\n    mode = m_paysys.mode;\r\n  }\r\n\r\n  function changePaymode(Paymode mode) internal {\r\n    require(mode <= Paymode.Pull, \"invalid pay mode\");\r\n    if (mode == m_paysys.mode ) return; \r\n    if (mode == Paymode.Pull) require(m_paysys.latestTime != 0, \"cannot set pull pay mode if latest time is 0\");\r\n    if (mode == Paymode.Push) m_paysys.latestTime = 0;\r\n    m_paysys.mode = mode;\r\n    emit LogPaymodeChanged(now, m_paysys.mode);\r\n  }\r\n}\r\n\r\n\r\nlibrary Zero {\r\n  function requireNotZero(uint a) internal pure {\r\n    require(a != 0, \"require not zero\");\r\n  }\r\n\r\n  function requireNotZero(address addr) internal pure {\r\n    require(addr != address(0), \"require not zero address\");\r\n  }\r\n\r\n  function notZero(address addr) internal pure returns(bool) {\r\n    return !(addr == address(0));\r\n  }\r\n\r\n  function isZero(address addr) internal pure returns(bool) {\r\n    return addr == address(0);\r\n  }\r\n}\r\n\r\n\r\nlibrary ToAddress {\r\n  function toAddr(uint source) internal pure returns(address) {\r\n    return address(source);\r\n  }\r\n\r\n  function toAddr(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n}\r\n\r\n\r\ncontract Revolution is Accessibility, PaymentSystem {\r\n  using Percent for Percent.percent;\r\n  using SafeMath for uint;\r\n  using Zero for *;\r\n  using ToAddress for *;\r\n\r\n  // investors storage - iterable map;\r\n  InvestorsStorage private m_investors;\r\n  mapping(address => bool) private m_referrals;\r\n  bool private m_nextWave;\r\n\r\n  // automatically generates getters\r\n  address public adminAddr;\r\n  address public payerAddr;\r\n  uint public waveStartup;\r\n  uint public investmentsNum;\r\n  uint public constant minInvesment = 10 finney; // 0.01 eth\r\n  uint public constant maxBalance = 333e5 ether; // 33,300,000 eth\r\n  uint public constant pauseOnNextWave = 168 hours; \r\n\r\n  // percents \r\n  Percent.percent private m_dividendsPercent = Percent.percent(333, 10000); // 333/10000*100% = 3.33%\r\n  Percent.percent private m_adminPercent = Percent.percent(1, 10); // 1/10*100% = 10%\r\n  Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7/100*100% = 7%\r\n  Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 3%\r\n\r\n  // more events for easy read from blockchain\r\n  event LogNewInvestor(address indexed addr, uint when, uint value);\r\n  event LogNewInvesment(address indexed addr, uint when, uint value);\r\n  event LogNewReferral(address indexed addr, uint when, uint value);\r\n  event LogPayDividends(address indexed addr, uint when, uint value);\r\n  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\r\n  event LogBalanceChanged(uint when, uint balance);\r\n  event LogAdminAddrChanged(address indexed addr, uint when);\r\n  event LogPayerAddrChanged(address indexed addr, uint when);\r\n  event LogNextWave(uint when);\r\n\r\n  modifier balanceChanged {\r\n    _;\r\n    emit LogBalanceChanged(now, address(this).balance);\r\n  }\r\n\r\n  modifier notOnPause() {\r\n    require(waveStartup+pauseOnNextWave <= now, \"pause on next wave not expired\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    adminAddr = msg.sender;\r\n    emit LogAdminAddrChanged(msg.sender, now);\r\n\r\n    payerAddr = msg.sender;\r\n    emit LogPayerAddrChanged(msg.sender, now);\r\n\r\n    nextWave();\r\n    waveStartup = waveStartup.sub(pauseOnNextWave);\r\n  }\r\n\r\n  function() public payable {\r\n    // investor get him dividends\r\n    if (msg.value == 0) {\r\n      getMyDividends();\r\n      return;\r\n    }\r\n\r\n    // sender do invest\r\n    address a = msg.data.toAddr();\r\n    address[3] memory refs;\r\n    if (a.notZero()) {\r\n      refs[0] = a;\r\n      doInvest(refs); \r\n    } else {\r\n      doInvest(refs);\r\n    }\r\n  }\r\n\r\n  function investorsNumber() public view returns(uint) {\r\n    return m_investors.size()-1;\r\n    // -1 because see InvestorsStorage constructor where keys.length++ \r\n  }\r\n\r\n  function balanceETH() public view returns(uint) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function payerPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_payerPercent.num, m_payerPercent.den);\r\n  }\r\n\r\n  function dividendsPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\r\n  }\r\n\r\n  function adminPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\r\n  }\r\n\r\n  function referrerPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_refPercent.num, m_refPercent.den);\r\n  }\r\n\r\n  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {\r\n    (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);\r\n    isReferral = m_referrals[addr];\r\n  }\r\n\r\n  function latestPayout() public view returns(uint timestamp) {\r\n    return m_paysys.latestTime;\r\n  }\r\n\r\n  function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {\r\n    // check investor info\r\n    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\r\n    require(investor.keyIndex > 0, \"sender is not investor\"); \r\n    if (investor.paymentTime < m_paysys.latestTime) {\r\n      assert(m_investors.setPaymentTime(msg.sender, m_paysys.latestTime));\r\n      investor.paymentTime = m_paysys.latestTime;\r\n    }\r\n\r\n    // calculate days after latest payment\r\n    uint256 daysAfter = now.sub(investor.paymentTime).div(24 hours);\r\n    require(daysAfter > 0, \"the latest payment was earlier than 24 hours\");\r\n    assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n    // check enough eth \r\n    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\r\n    if (address(this).balance < value + investor.refBonus) {\r\n      nextWave();\r\n      return;\r\n    }\r\n\r\n    // send dividends and ref bonus\r\n    if (investor.refBonus > 0) {\r\n      assert(m_investors.setRefBonus(msg.sender, 0));\r\n      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\r\n    } else {\r\n      sendDividends(msg.sender, value);\r\n    }\r\n  }\r\n\r\n  function doInvest(address[3] refs) public payable notOnPause balanceChanged {\r\n    require(msg.value >= minInvesment, \"msg.value must be >= minInvesment\");\r\n    require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\n    uint value = msg.value;\r\n    // ref system works only once for sender-referral\r\n    if (!m_referrals[msg.sender]) {\r\n      // level 1\r\n      if (notZeroNotSender(refs[0]) && m_investors.contains(refs[0])) {\r\n        uint reward = m_refPercent.mul(value);\r\n        assert(m_investors.addRefBonus(refs[0], reward)); // referrer 1 bonus\r\n        m_referrals[msg.sender] = true;\r\n        value = m_dividendsPercent.add(value); // referral bonus\r\n        emit LogNewReferral(msg.sender, now, value);\r\n        // level 2\r\n        if (notZeroNotSender(refs[1]) && m_investors.contains(refs[1]) && refs[0] != refs[1]) { \r\n          assert(m_investors.addRefBonus(refs[1], reward)); // referrer 2 bonus\r\n          // level 3\r\n          if (notZeroNotSender(refs[2]) && m_investors.contains(refs[2]) && refs[0] != refs[2] && refs[1] != refs[2]) { \r\n            assert(m_investors.addRefBonus(refs[2], reward)); // referrer 3 bonus\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // commission\r\n    adminAddr.transfer(m_adminPercent.mul(msg.value));\r\n    payerAddr.transfer(m_payerPercent.mul(msg.value));    \r\n    \r\n    // write to investors storage\r\n    if (m_investors.contains(msg.sender)) {\r\n      assert(m_investors.addValue(msg.sender, value));\r\n    } else {\r\n      assert(m_investors.insert(msg.sender, value));\r\n      emit LogNewInvestor(msg.sender, now, value); \r\n    }\r\n    \r\n    if (m_paysys.mode == Paymode.Pull)\r\n      assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n    emit LogNewInvesment(msg.sender, now, value);   \r\n    investmentsNum++;\r\n  }\r\n\r\n  function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {\r\n    if (m_nextWave) {\r\n      nextWave(); \r\n      return;\r\n    }\r\n   \r\n    // if m_paysys.latestKeyIndex == m_investors.iterStart() then payout NOT in process and we must check latest time of payment.\r\n    if (m_paysys.latestKeyIndex == m_investors.iterStart()) {\r\n      require(now>m_paysys.latestTime+12 hours, \"the latest payment was earlier than 12 hours\");\r\n      m_paysys.latestTime = now;\r\n    }\r\n\r\n    uint i = m_paysys.latestKeyIndex;\r\n    uint value;\r\n    uint refBonus;\r\n    uint size = m_investors.size();\r\n    address investorAddr;\r\n    \r\n    // gasleft and latest key index  - prevent gas block limit \r\n    for (i; i < size && gasleft() > 50000; i++) {\r\n      investorAddr = m_investors.keyFromIndex(i);\r\n      (value, refBonus) = m_investors.investorShortInfo(investorAddr);\r\n      value = m_dividendsPercent.mul(value);\r\n\r\n      if (address(this).balance < value + refBonus) {\r\n        m_nextWave = true;\r\n        break;\r\n      }\r\n\r\n      if (refBonus > 0) {\r\n        require(m_investors.setRefBonus(investorAddr, 0), \"internal error\");\r\n        sendDividendsWithRefBonus(investorAddr, value, refBonus);\r\n        continue;\r\n      }\r\n\r\n      sendDividends(investorAddr, value);\r\n    }\r\n\r\n    if (i == size) \r\n      m_paysys.latestKeyIndex = m_investors.iterStart();\r\n    else \r\n      m_paysys.latestKeyIndex = i;\r\n  }\r\n\r\n  function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {\r\n    addr.requireNotZero();\r\n    if (adminAddr != addr) {\r\n      adminAddr = addr;\r\n      emit LogAdminAddrChanged(addr, now);\r\n    }    \r\n  }\r\n\r\n  function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {\r\n    addr.requireNotZero();\r\n    if (payerAddr != addr) {\r\n      payerAddr = addr;\r\n      emit LogPayerAddrChanged(addr, now);\r\n    }  \r\n  }\r\n\r\n  function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {\r\n    changePaymode(Paymode.Pull);\r\n  }\r\n\r\n  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\r\n    (uint a, uint b, uint c, uint d) = m_investors.investorFullInfo(addr);\r\n    return InvestorsStorage.investor(a, b, c, d);\r\n  }\r\n\r\n  function notZeroNotSender(address addr) internal view returns(bool) {\r\n    return addr.notZero() && addr != msg.sender;\r\n  }\r\n\r\n  function sendDividends(address addr, uint value) private {\r\n    if (addr.send(value)) emit LogPayDividends(addr, now, value); \r\n  }\r\n\r\n  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\r\n    if (addr.send(value+refBonus)) {\r\n      emit LogPayDividends(addr, now, value);\r\n      emit LogPayReferrerBonus(addr, now, refBonus);\r\n    }\r\n  }\r\n\r\n  function nextWave() private {\r\n    m_investors = new InvestorsStorage();\r\n    changePaymode(Paymode.Push);\r\n    m_paysys.latestKeyIndex = m_investors.iterStart();\r\n    investmentsNum = 0;\r\n    waveStartup = now;\r\n    m_nextWave = false;\r\n    emit LogNextWave(now);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"refs\",\"type\":\"address[3]\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPayerAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"access\",\"outputs\":[{\"name\":\"rank\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseOnNextWave\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymode\",\"outputs\":[{\"name\":\"mode\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestPayout\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payerPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"provideAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"refBonus\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setPullPaymode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayReferrerBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogAdminAddrChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogPayerAddrChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNextWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"mode\",\"type\":\"uint8\"}],\"name\":\"LogPaymodeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"LogProvideAccess\",\"type\":\"event\"}]","ContractName":"Revolution","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://202cd60ed611d02a3542cf0ddd798bf96ca6c1a5b963d3e40b3387a9e48dd648"}]}