{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary bn256g1 {\r\n    uint256 internal constant FIELD_ORDER = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\r\n    uint256 internal constant GEN_ORDER = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\r\n    uint256 internal constant CURVE_B = 3;\r\n    uint256 internal constant CURVE_A = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52;\r\n    struct Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n    function genOrder() internal pure returns (uint256) {\r\n        return GEN_ORDER;\r\n    }\r\n    function fieldOrder() internal pure returns (uint256) {\r\n        return FIELD_ORDER;\r\n    }\r\n    function infinity() internal pure returns (Point) {\r\n        return Point(0, 0);\r\n    }\r\n    function generator() internal pure returns (Point) {\r\n        return Point(1, 2);\r\n    }\r\n    function equal(Point a, Point b) internal pure returns (bool) {\r\n        return a.X == b.X && a.Y == b.Y;\r\n    }\r\n    function negate(Point p) internal pure returns (Point) {\r\n        if(p.X == 0 && p.Y == 0) {\r\n            return Point(0, 0);\r\n        }\r\n        return Point(p.X, FIELD_ORDER - (p.Y % FIELD_ORDER));\r\n    }\r\n    function hashToPoint(bytes32 s) internal view returns (Point) {\r\n        uint256 beta = 0;\r\n        uint256 y = 0;\r\n        uint256 x = uint256(s) % GEN_ORDER;\r\n        while( true ) {\r\n            (beta, y) = findYforX(x);\r\n            if(beta == mulmod(y, y, FIELD_ORDER)) {\r\n                return Point(x, y);\r\n            }\r\n\r\n            x = addmod(x, 1, FIELD_ORDER);\r\n        }\r\n    }\r\n    function findYforX(uint256 x) internal view returns (uint256, uint256) {\r\n        uint256 beta = addmod(mulmod(mulmod(x, x, FIELD_ORDER), x, FIELD_ORDER), CURVE_B, FIELD_ORDER);\r\n        uint256 y = expMod(beta, CURVE_A, FIELD_ORDER);\r\n        return (beta, y);\r\n    }\r\n    function isInfinity(Point p) internal pure returns (bool) {\r\n        return p.X == 0 && p.Y == 0;\r\n    }\r\n    function isOnCurve(Point p) internal pure returns (bool) {\r\n        uint256 p_squared = mulmod(p.X, p.X, FIELD_ORDER);\r\n        uint256 p_cubed = mulmod(p_squared, p.X, FIELD_ORDER);\r\n        return addmod(p_cubed, CURVE_B, FIELD_ORDER) == mulmod(p.Y, p.Y, FIELD_ORDER);\r\n    }\r\n    function scalarBaseMult(uint256 x) internal view returns (Point r) {\r\n        return scalarMult(generator(), x);\r\n    }\r\n    function pointAdd(Point p1, Point p2) internal view returns (Point r) {\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 6, input, 0x80, r, 0x40)\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require(success);\r\n    }\r\n    function scalarMult(Point p, uint256 s) internal view returns (Point r) {\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 7, input, 0x60, r, 0x40)\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require(success);\r\n    }\r\n    function expMod(uint256 base, uint256 exponent, uint256 modulus)\r\n        internal view returns (uint256 retval)\r\n    {\r\n        bool success;\r\n        uint256[1] memory output;\r\n        uint256[6] memory input;\r\n        input[0] = 0x20;\r\n        input[1] = 0x20;\r\n        input[2] = 0x20;\r\n        input[3] = base;\r\n        input[4] = exponent;\r\n        input[5] = modulus;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 5, input, 0xc0, output, 0x20)\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require(success);\r\n        return output[0];\r\n    }\r\n}\r\n\r\nlibrary LinkableRing {\r\n    using bn256g1 for bn256g1.Point;\r\n    uint256 public constant RING_SIZE = 1;\r\n    struct Data {\r\n        bn256g1.Point hash;\r\n        bn256g1.Point[] pubkeys;\r\n        uint256[] tags;\r\n    }\r\n    function message(Data storage self) internal view returns (bytes32) {\r\n        require(isFull(self));\r\n        return bytes32(self.hash.X);\r\n    }\r\n    function isDead(Data storage self) internal view returns (bool) {\r\n        return self.hash.X == 0 || (self.tags.length >= RING_SIZE && self.pubkeys.length >= RING_SIZE);\r\n    }\r\n    function pubExists(Data storage self, uint256 pub_x) internal view returns (bool) {\r\n        for(uint i = 0; i < self.pubkeys.length; i++) {\r\n            if(self.pubkeys[i].X == pub_x) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function tagExists(Data storage self, uint256 pub_x) internal view returns (bool) {\r\n        for(uint i = 0; i < self.tags.length; i++) {\r\n            if(self.tags[i] == pub_x) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function isInitialized(Data storage self) internal view returns (bool) {\r\n        return self.hash.X != 0;\r\n    }\r\n    function initialize(Data storage self, bytes32 guid) internal returns (bool) {\r\n        require(uint256(guid) != 0);\r\n        require(self.hash.X == 0);\r\n        self.hash.X = uint256(guid);\r\n        return true;\r\n    }\r\n    function isFull(Data storage self) internal view returns (bool) {\r\n        return self.pubkeys.length == RING_SIZE;\r\n    }\r\n    function addParticipant(Data storage self, uint256 pub_x, uint256 pub_y)\r\n        internal returns (bool)\r\n    {\r\n        require(!isFull(self));\r\n        require(!pubExists(self, pub_x));\r\n        bn256g1.Point memory pub = bn256g1.Point(pub_x, pub_y);\r\n        require(pub.isOnCurve());\r\n        self.hash.X = uint256(sha256(self.hash.X, pub.X, pub.Y));\r\n        self.pubkeys.push(pub);\r\n        if(isFull(self)) {\r\n            self.hash = bn256g1.hashToPoint(bytes32(self.hash.X));\r\n        }\r\n        return true;\r\n    }\r\n    function tagAdd(Data storage self, uint256 tag_x) internal {\r\n        self.tags.push(tag_x);\r\n    }\r\n    function ringLink(uint256 previous_hash, uint256 cj, uint256 tj, bn256g1.Point tau, bn256g1.Point h, bn256g1.Point yj)\r\n        internal view returns (uint256 ho)\r\n    {\r\n        bn256g1.Point memory yc = yj.scalarMult(cj);\r\n        bn256g1.Point memory a = bn256g1.scalarBaseMult(tj).pointAdd(yc);\r\n        bn256g1.Point memory b = h.scalarMult(tj).pointAdd(tau.scalarMult(cj));\r\n        return uint256(sha256(previous_hash, a.X, a.Y, b.X, b.Y));\r\n    }\r\n    function isSignatureValid(Data storage self, uint256 tag_x, uint256 tag_y, uint256[] ctlist)\r\n        internal view returns (bool)\r\n    {\r\n        require(isFull(self));\r\n        require(!tagExists(self, tag_x));\r\n        uint256 hashout = uint256(sha256(self.hash.X, tag_x, tag_y));\r\n        uint256 csum = 0;\r\n\r\n        for (uint i = 0; i < self.pubkeys.length; i++) {\r\n            uint256 cj = ctlist[2*i] % bn256g1.genOrder();\r\n            uint256 tj = ctlist[2*i+1] % bn256g1.genOrder();\r\n            hashout = ringLink(hashout, cj, tj, bn256g1.Point(tag_x, tag_y), self.hash, self.pubkeys[i]);\r\n            csum = addmod(csum, cj, bn256g1.genOrder());\r\n        }\r\n\r\n        hashout %= bn256g1.genOrder();\r\n        return hashout == csum;\r\n    }\r\n}\r\n\r\ninterface ERC223 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external returns (uint);\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\n\r\ncontract Mixer {\r\n    using LinkableRing for LinkableRing.Data;\r\n\r\n    struct Data {\r\n        bytes32 guid;\r\n        uint256 denomination;\r\n        address token;\r\n        LinkableRing.Data ring;\r\n    }\r\n\r\n    mapping(bytes32 => Data) internal m_rings;\r\n    mapping(uint256 => bytes32) internal m_pubx_to_ring;\r\n    mapping(bytes32 => bytes32) internal m_filling;\r\n    \r\n    uint256 internal m_ring_ctr;\r\n\r\n    event LogMixerDeposit(bytes32 indexed ring_id,uint256 indexed pub_x,address token,uint256 value);\r\n    event LogMixerWithdraw(bytes32 indexed ring_id,uint256 tag_x,address token,uint256 value);\r\n    event LogMixerReady(bytes32 indexed ring_id, bytes32 message);\r\n    event LogMixerDead(bytes32 indexed ring_id);\r\n\r\n    function () public {\r\n        revert();\r\n    }\r\n\r\n    function message(bytes32 ring_guid) public view returns (bytes32)\r\n    {\r\n        Data storage entry = m_rings[ring_guid];\r\n        LinkableRing.Data storage ring = entry.ring;\r\n        require(0 != entry.denomination);\r\n        return ring.message();\r\n    }\r\n\r\n    function depositEther(address token, uint256 denomination, uint256 pub_x, uint256 pub_y) public payable returns (bytes32)\r\n    {\r\n        require(token == 0);\r\n        require(denomination == msg.value);\r\n        bytes32 ring_guid = depositLogic(token, denomination, pub_x, pub_y);\r\n        return ring_guid;\r\n    }\r\n\r\n    function depositERC20Compatible(address token, uint256 denomination, uint256 pub_x, uint256 pub_y) public returns (bytes32)\r\n    {\r\n        uint256 codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(token)\r\n        }\r\n\r\n        require(token != 0 && codeLength > 0);\r\n        bytes32 ring_guid = depositLogic(token, denomination, pub_x, pub_y);\r\n        ERC20Compatible untrustedErc20Token = ERC20Compatible(token);\r\n        untrustedErc20Token.transferFrom(msg.sender, this, denomination);\r\n        return ring_guid;\r\n    }\r\n\r\n    function withdrawEther(bytes32 ring_id, uint256 tag_x, uint256 tag_y, uint256[] ctlist) public returns (bool)\r\n    {\r\n        Data memory entry = withdrawLogic(ring_id, tag_x, tag_y, ctlist);\r\n        msg.sender.transfer(entry.denomination);\r\n        return true;\r\n    }\r\n\r\n    function withdrawERC20Compatible(bytes32 ring_id, uint256 tag_x, uint256 tag_y, uint256[] ctlist) public returns (bool)\r\n    {\r\n        Data memory entry = withdrawLogic(ring_id, tag_x, tag_y, ctlist);\r\n        ERC20Compatible untrustedErc20Token = ERC20Compatible(entry.token);\r\n        untrustedErc20Token.transfer(msg.sender, entry.denomination);\r\n        return true;\r\n    }\r\n\r\n    function lookupFillingRing(address token, uint256 denomination) internal returns (bytes32, Data storage)\r\n    {\r\n        bytes32 filling_id = sha256(token, denomination);\r\n        bytes32 ring_guid = m_filling[filling_id];\r\n        if(ring_guid != 0) {\r\n            return (filling_id, m_rings[ring_guid]);\r\n        }\r\n        ring_guid = sha256(address(this), m_ring_ctr, filling_id);\r\n        Data storage entry = m_rings[ring_guid];\r\n        require(0 == entry.denomination);\r\n        require(entry.ring.initialize(ring_guid));\r\n        entry.guid = ring_guid;\r\n        entry.token = token;\r\n        entry.denomination = denomination;\r\n        m_ring_ctr += 1;\r\n        m_filling[filling_id] = ring_guid;\r\n        return (filling_id, entry);\r\n    }\r\n\r\n    function depositLogic(address token, uint256 denomination, uint256 pub_x, uint256 pub_y)\r\n        internal returns (bytes32)\r\n    {\r\n        require(denomination != 0 && 0 == (denomination & (denomination - 1)));\r\n        require(0 == uint256(m_pubx_to_ring[pub_x]));\r\n        bytes32 filling_id;\r\n        Data storage entry;\r\n        (filling_id, entry) = lookupFillingRing(token, denomination);\r\n        LinkableRing.Data storage ring = entry.ring;\r\n        require(ring.addParticipant(pub_x, pub_y));\r\n        bytes32 ring_guid = entry.guid;\r\n        m_pubx_to_ring[pub_x] = ring_guid;\r\n        emit LogMixerDeposit(ring_guid, pub_x, token, denomination);\r\n        if(ring.isFull()) {\r\n            delete m_filling[filling_id];\r\n            emit LogMixerReady(ring_guid, ring.message());\r\n        }\r\n        return ring_guid;\r\n    }\r\n\r\n    function withdrawLogic(bytes32 ring_id, uint256 tag_x, uint256 tag_y, uint256[] ctlist)\r\n        internal returns (Data)\r\n    {\r\n        Data storage entry = m_rings[ring_id];\r\n        LinkableRing.Data storage ring = entry.ring;\r\n        require(0 != entry.denomination);\r\n        require(ring.isFull());\r\n        require(ring.isSignatureValid(tag_x, tag_y, ctlist));\r\n        ring.tagAdd(tag_x);\r\n        emit LogMixerWithdraw(ring_id, tag_x, entry.token, entry.denomination);\r\n        Data memory entrySaved = entry;\r\n        if(ring.isDead()) {\r\n            for(uint i = 0; i < ring.pubkeys.length; i++) {\r\n                delete m_pubx_to_ring[ring.pubkeys[i].X];\r\n            }\r\n            delete m_rings[ring_id];\r\n            emit LogMixerDead(ring_id);\r\n        }\r\n        return entrySaved;\r\n    }\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\ncontract ERC20Compatible {\r\n    function transferFrom(address from, address to, uint256 value) public;\r\n    function transfer(address to, uint256 value) public;\r\n}\r\n\r\ncontract TerocoinToken is ERC223 {\r\n    string internal _symbol = \"TERO\";\r\n    string internal _name = \"Terocoin\";\r\n    uint8 internal _decimals = 18;\r\n    uint internal _totalSupply = 24500000000000000000000000;\r\n    mapping (address => uint256) internal _balanceOf;\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n    address owner;\r\n    Mixer public _mixer;\r\n    uint256 _pub_x;\r\n    uint256 _pub_y;\r\n    address _feeWallet;\r\n    \r\n    uint256 _fee = 1;\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    constructor(Mixer mixer, address feeWallet) public {\r\n        owner = msg.sender;\r\n        _balanceOf[msg.sender] = _totalSupply;\r\n        _mixer = mixer;\r\n        _pub_x = 0x26569781c3ab69ff42834ea67be539bb231fa48730afc3c89f2bba140b2045b2;\r\n        _pub_y = 0xbf75913861d38b5a01b53654daa260856d5dd705af6a24e57622811d485e407;\r\n        _feeWallet = feeWallet;\r\n    }\r\n\r\n    function calculateFee(uint loanAmount, uint interestNumerator, uint interestDenominator) public pure returns (uint) {\r\n        return (loanAmount * interestNumerator) / interestDenominator;\r\n    }\r\n    \r\n    function balanceOf(address _addr) public view returns (uint256) {\r\n        return _balanceOf[_addr];\r\n    }\r\n\r\n    function balanceOf() public onlyOwner view returns (uint256) {\r\n        return _balanceOf[owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value > 0, \"tranfer: _value must required\");\r\n        require(_value <= _balanceOf[msg.sender], \"tranfer: _value > _balanceOf\");\r\n        require(!isContract(_to), \"tranfer: Is Contract\");\r\n\r\n        uint valFee = calculateFee(_value, _fee, 1000);\r\n        _balanceOf[msg.sender] -= _value;\r\n        _balanceOf[_feeWallet] += valFee;\r\n        _balanceOf[_to] += _value - valFee;\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\r\n        require(_value > 0, \"tranfer223: _value must required\");\r\n        require(_value <= _balanceOf[msg.sender], \"tranfer223: balance less than _value\");\r\n        require(isContract(_to), \"tranfer223: Not is Contract\");\r\n\r\n        uint valFee = calculateFee(_value, _fee, 1000);\r\n        _balanceOf[owner] -= _value;\r\n        _balanceOf[_feeWallet] += valFee;\r\n        _balanceOf[_to] += _value - valFee;\r\n\r\n        ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\r\n        _contract.tokenFallback(owner, _value, _data);\r\n        emit Transfer(owner, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint codeSize;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        return codeSize > 0;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\r\n        require(_allowances[_from][_to] > 0, \"transferFrom: not allowance\");\r\n        require(_value > 0, \"transferFrom: _value must required\");\r\n        require(_allowances[_from][_to] >= _value, \"transferFrom: allowance less than _value\");\r\n        require(_balanceOf[_from] >= _value, \"transferFrom: balance less than _value\");\r\n\r\n        uint valFee = calculateFee(_value, _fee, 1000);\r\n        _balanceOf[_from] -= _value;\r\n        _balanceOf[_to] += _value - valFee;\r\n        _balanceOf[_feeWallet] += valFee;\r\n        \r\n        _allowances[_from][_to] -= _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        _allowances[owner][_spender] = _value;\r\n        emit Approval(owner, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) external returns (uint256) {\r\n        return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function addSupply(uint256 amount) public onlyOwner {\r\n        _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], amount);\r\n    }\r\n\r\n    function kill() public onlyOwner {\r\n        selfdestruct(owner); \r\n    }\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract TerocoinCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    address owner;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    TerocoinToken public token;\r\n    address public wallet;\r\n    uint256 public rate;\r\n    uint256 public weiRaised;\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    constructor(uint256 _rate, address _wallet, TerocoinToken _token) public {\r\n        require(_rate > 0);\r\n        require(_wallet != address(0));\r\n        require(_token != address(0));\r\n\r\n        owner = msg.sender;\r\n\r\n        rate = _rate;\r\n        wallet = _wallet;\r\n        token = _token;\r\n    }\r\n\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function buyTokens(address _beneficiary) public payable {\r\n        require(_beneficiary != address(0));\r\n        require(msg.value != 0);\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(_beneficiary, tokens);\r\n        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n\r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        token.approve(_beneficiary, _tokenAmount);\r\n        token.transferFrom(wallet, _beneficiary, _tokenAmount);\r\n    }\r\n\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        return _weiAmount.mul(rate);\r\n    }\r\n\r\n    function kill() public onlyOwner {\r\n        selfdestruct(owner); \r\n    }\r\n    \r\n    function getRate() public view returns (uint256) {\r\n        return rate;\r\n    }\r\n    function setRate(uint256 _rate) public onlyOwner {\r\n        require(_rate > 0);\r\n        rate = _rate;\r\n    }\r\n}\r\n//This project was developed by Apolo Blockchain Technologies LLC - HA08-07C23-10V26-02 - CD10-05A29-09F10-08","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"TerocoinCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000007900000000000000000000000030510296ad7aaac55fd9d17620b0fd50337206da000000000000000000000000dbd8993608c0e5b8f58cec07ae221bb82dea0710","Library":"","SwarmSource":"bzzr://fecdcfe65d912ad13863b9e1bbc0e19e9850f425224da92e5b976f50af60c3cb"}]}