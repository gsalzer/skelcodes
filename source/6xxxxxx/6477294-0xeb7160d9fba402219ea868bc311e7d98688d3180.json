{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n\r\n\r\n\r\ncontract Verifier{\r\nfunction verifyTx(\r\nuint[2],\r\nuint[2],\r\nuint[2][2],\r\nuint[2],\r\nuint[2],\r\nuint[2],\r\nuint[2],\r\nuint[2],\r\naddress\r\n) public pure returns (bool){}\r\n\r\n\r\n\r\n\r\n/**\r\n@notice © Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\r\n*/\r\nfunction getInputBits(uint, address) public view returns(bytes8){}\r\n}\r\n\r\n\r\n\r\n\r\ncontract TokenShield{\r\n\r\n\r\n\r\n\r\n/**\r\n@notice © Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\r\n\r\n\r\n\r\n\r\nContract to enable the management of hidden non fungible toke transactions.\r\n*/\r\n\r\n\r\n\r\n\r\naddress public owner;\r\nbytes8[merkleWidth] private ns; //store spent token nullifiers\r\nbytes8[merkleWidth] private ds; //store the double-spend prevention hashes\r\nuint constant merkleWidth = 256;\r\nuint constant merkleDepth = 9;\r\nuint constant lastRow = merkleDepth-1;\r\nbytes8[merkleWidth] private zs; //array holding the tokens.  Basically the bottom row of the merkle tree\r\nuint private zCount; //remember the number of tokens we hold\r\nuint private nCount; //remember the number of tokens we spent\r\nbytes8[] private roots; //holds each root we've calculated so that we can pull the one relevant to the prover\r\nuint public currentRootIndex; //holds the index for the current root so that the\r\n//prover can provide it later and this contract can look up the relevant root\r\nVerifier mv; //the verification smart contract that the mint function uses\r\nVerifier tv; //the verification smart contract that the transfer function uses\r\nVerifier jv; //the verification smart contract that the join function uses\r\nVerifier sv; //the verification smart contract that the split function uses\r\n//uint i; //just a loop counter, should be local but moved here to preserve stack space\r\nstruct Proof { //recast this as a struct because otherwise, as a set of local variable, it takes too much stack space\r\nuint[2] a;\r\nuint[2] a_p;\r\nuint[2][2] b;\r\nuint[2] b_p;\r\nuint[2] c;\r\nuint[2] c_p;\r\nuint[2] h;\r\nuint[2] k;\r\n}\r\n\r\n\r\n\r\n\r\nmapping(address => Proof) private proofs;\r\n\r\n\r\n\r\n\r\nconstructor(address mintVerifier, address transferVerifier, address joinVerifier, address splitVerifier) public {\r\n//TODO - you can get a way with a single, generic verifier.\r\nowner = msg.sender;\r\nmv = Verifier(mintVerifier);\r\ntv = Verifier(transferVerifier);\r\njv = Verifier(joinVerifier);\r\nsv = Verifier(splitVerifier);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//only owner  modifier\r\nmodifier onlyOwner () {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nself destruct added by westlad\r\n*/\r\nfunction close() public onlyOwner {\r\nselfdestruct(owner);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getMintVerifier() public view returns(address){\r\nreturn address(mv);\r\n}\r\n\r\n\r\n\r\n\r\nfunction getTransferVerifier() public view returns(address){\r\nreturn address(tv);\r\n}\r\n\r\n\r\n\r\n\r\nfunction getJoinVerifier() public view returns(address){\r\nreturn address(jv);\r\n}\r\n\r\n\r\n\r\n\r\nfunction getSplitVerifier() public view returns(address){\r\nreturn address(sv);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThe mint function accepts a Preventifier, H(A), where A is the assetHash; a\r\nZ token and a proof that both the token and the Preventifier contain A.\r\nIt's done as an array because the stack on EVM is too small to hold all the locals otherwise.\r\nFor the same reason, the proof is set up by calling setProofParams first.\r\n*/\r\nfunction mint() public {\r\n//first, verify the proof\r\nbool result = mv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\n\r\n\r\n\r\n\r\nrequire(result); //the proof must check out.\r\nbytes8 d = mv.getInputBits(0, msg.sender); //recover the input params from MintVerifier\r\nbytes8 z = mv.getInputBits(64, msg.sender);\r\nfor (uint i=0; i<zCount; i++) { //check the preventifier doesn't exist\r\nrequire(ds[i]!= d);\r\n}\r\nzs[zCount] = z; //add the commitment\r\nds[zCount++] = d; //add the preventifier\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThe transfer function transfers a commitment to a new owner\r\n*/\r\nfunction transfer() public {\r\nbool result = tv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\nrequire(result); //the proof must verify. The spice must flow.\r\nbytes8 n = tv.getInputBits(0, msg.sender);\r\nbytes8 z = tv.getInputBits(128, msg.sender);\r\nfor (uint i=0; i<nCount; i++) { //check this is an unspent commitment\r\nrequire(ns[i]!=n);\r\n}\r\nns[nCount++] = n; //remember we spent it\r\nzs[zCount++] = z; //add Bob's token to the list of tokens\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThe join function joins multiple commitments into one z-commitment and\r\ntransfers to the public of key recipient specified\r\n*/\r\nfunction join() public {\r\n//verification contract\r\nbool result = jv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\nrequire(result); //the proof must verify. The spice must flow.\r\nbytes8 na1 = jv.getInputBits(0, msg.sender);\r\nbytes8 na2 = jv.getInputBits(64, msg.sender);\r\nbytes8 zb = jv.getInputBits(192, msg.sender);\r\nbytes8 db = jv.getInputBits(256, msg.sender);\r\nfor (uint i=0; i<nCount; i++) { //check this is an unspent commitment\r\nrequire(ns[i]!=na1 && ns[i]!=na2);\r\n}\r\nfor (uint j=0; j<zCount; j++) { //check the preventifier doesn't exist\r\nrequire(ds[j]!= db);\r\n}\r\nns[nCount++] = na1; //remember we spent it\r\nns[nCount++] = na2; //remember we spent it\r\nzs[zCount] = zb; //add the commitment\r\nds[zCount++] = db; //add the preventifier\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThe split function splits a commitment into multiple commitments and transfers\r\nto the public of key recipient specified\r\n*/\r\nfunction split() public {\r\n//verification contract\r\nbool result = sv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\nrequire(result); //the proof must verify. The spice must flow.\r\nbytes8 na = sv.getInputBits(0, msg.sender);\r\nbytes8 zb1 = sv.getInputBits(128, msg.sender);\r\nbytes8 zb2 = sv.getInputBits(192, msg.sender);\r\nbytes8 db1 = sv.getInputBits(256, msg.sender); //TODO do not add if already in the list of double spend preventifier\r\nbytes8 db2 = sv.getInputBits(320, msg.sender); //TODO do not add if already in the list of double spend preventifier\r\nfor (uint i=0; i<nCount; i++) { //check this is an unspent coin\r\nrequire(ns[i]!=na);\r\n}\r\nns[nCount++] = na; //remember we spent it\r\nzs[zCount] = zb1; //add the commitment\r\nds[zCount++] = db1; //add the preventifier\r\nzs[zCount] = zb2; //add the commitment\r\nds[zCount++] = db2; //add the preventifier\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThis function is only needed because otherwise mint and transfer use too many\r\nlocal variables for the limited stack space. Rather than pass a proof as\r\nparameters to these functions (more logical)\r\n*/\r\nfunction setProofParams(\r\nuint[2] a,\r\nuint[2] a_p,\r\nuint[2][2] b,\r\nuint[2] b_p,\r\nuint[2] c,\r\nuint[2] c_p,\r\nuint[2] h,\r\nuint[2] k)\r\npublic {\r\n//this is long, think of a better way\r\nproofs[msg.sender].a[0] = a[0];\r\nproofs[msg.sender].a[1] = a[1];\r\nproofs[msg.sender].a_p[0] = a_p[0];\r\nproofs[msg.sender].a_p[1] = a_p[1];\r\nproofs[msg.sender].b[0][0] = b[0][0];\r\nproofs[msg.sender].b[0][1] = b[0][1];\r\nproofs[msg.sender].b[1][0] = b[1][0];\r\nproofs[msg.sender].b[1][1] = b[1][1];\r\nproofs[msg.sender].b_p[0] = b_p[0];\r\nproofs[msg.sender].b_p[1] = b_p[1];\r\nproofs[msg.sender].c[0] = c[0];\r\nproofs[msg.sender].c[1] = c[1];\r\nproofs[msg.sender].c_p[0] = c_p[0];\r\nproofs[msg.sender].c_p[1] = c_p[1];\r\nproofs[msg.sender].h[0] = h[0];\r\nproofs[msg.sender].h[1] = h[1];\r\nproofs[msg.sender].k[0] = k[0];\r\nproofs[msg.sender].k[1] = k[1];\r\n}\r\n\r\n\r\n\r\n\r\nfunction getTokens() public view returns(bytes8[merkleWidth], uint root) {\r\n//need the commitments to compute a proof and also an index to look up the current\r\n//root.\r\nreturn (zs,currentRootIndex);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nFunction to return the root that was current at rootIndex\r\n*/\r\nfunction getRoot(uint rootIndex) view public returns(bytes8) {\r\nreturn roots[rootIndex];\r\n}\r\n\r\n\r\n\r\n\r\nfunction computeMerkle() public view returns (bytes8){//for backwards compat\r\nreturn merkle(0,0);\r\n}\r\n\r\n\r\n\r\n\r\nfunction merkle(uint r, uint t) public view returns (bytes8) {\r\n//This is a recursive approach, which seems efficient but we do end up\r\n//calculating the whole tree fro scratch each time.  Need to look at storing\r\n//intermediate values and seeing if that will make it cheaper.\r\nif (r==lastRow) {\r\nreturn zs[t];\r\n} else {\r\nreturn bytes8(sha256(merkle(r+1,2*t)^merkle(r+1,2*t+1))<<192);\r\n}\r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"computeMerkle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJoinVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256[2]\"},{\"name\":\"a_p\",\"type\":\"uint256[2]\"},{\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"name\":\"b_p\",\"type\":\"uint256[2]\"},{\"name\":\"c\",\"type\":\"uint256[2]\"},{\"name\":\"c_p\",\"type\":\"uint256[2]\"},{\"name\":\"h\",\"type\":\"uint256[2]\"},{\"name\":\"k\",\"type\":\"uint256[2]\"}],\"name\":\"setProofParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRootIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rootIndex\",\"type\":\"uint256\"}],\"name\":\"getRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8[256]\"},{\"name\":\"root\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"join\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransferVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSplitVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"merkle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"split\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"mintVerifier\",\"type\":\"address\"},{\"name\":\"transferVerifier\",\"type\":\"address\"},{\"name\":\"joinVerifier\",\"type\":\"address\"},{\"name\":\"splitVerifier\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TokenShield","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c5daef66b7752d9c5920c15e9e0145aa839843f30000000000000000000000008d993aaf8e92c2027a5358b9914392050b03356d000000000000000000000000f8cb6400dcf523bf6397a79bccd35a6af1a88edd000000000000000000000000b065dcb7651b448e042a0acc729ae64d2ea3ba51","Library":"","SwarmSource":"bzzr://1299135b9cc12c65515fd6dce45db1c1517f7f705d348be0574c1d688fe06375"}]}