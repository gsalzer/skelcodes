{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/libs/PointsCalculator.sol\r\n\r\nlibrary PointsCalculator {\r\n\r\n    uint8 constant MATCHES_NUMBER = 20;\r\n    uint8 constant BONUS_MATCHES = 5;\r\n    \r\n    uint16 constant EXTRA_STATS_MASK = 65535;\r\n    uint8 constant MATCH_UNDEROVER_MASK = 1;\r\n    uint8 constant MATCH_RESULT_MASK = 3;\r\n    uint8 constant MATCH_TOUCHDOWNS_MASK = 31;\r\n    uint8 constant BONUS_STAT_MASK = 63;\r\n\r\n    struct MatchResult{\r\n        uint8 result; /*  0-> draw, 1-> won 1, 2-> won 2 */\r\n        uint8 under49;\r\n        uint8 touchdowns;\r\n    }\r\n\r\n    struct Extras {\r\n        uint16 interceptions;\r\n        uint16 missedFieldGoals;\r\n        uint16 overtimes;\r\n        uint16 sacks;\r\n        uint16 fieldGoals;\r\n        uint16 fumbles;\r\n    }\r\n\r\n    struct BonusMatch {\r\n        uint16 bonus;\r\n    }    \r\n    \r\n    /**\r\n    * @notice get points from a single match \r\n    * @param matchIndex index of the match\r\n    * @param matches token predictions\r\n    * @return \r\n    */\r\n    function getMatchPoints (uint256 matchIndex, uint160 matches, MatchResult[] matchResults, bool[] starMatches) private pure returns(uint16 matchPoints) {\r\n\r\n        uint8 tResult = uint8(matches & MATCH_RESULT_MASK);\r\n        uint8 tUnder49 = uint8((matches >> 2) & MATCH_UNDEROVER_MASK);\r\n        uint8 tTouchdowns = uint8((matches >> 3) & MATCH_TOUCHDOWNS_MASK);\r\n\r\n        uint8 rResult = matchResults[matchIndex].result;\r\n        uint8 rUnder49 = matchResults[matchIndex].under49;\r\n        uint8 rTouchdowns = matchResults[matchIndex].touchdowns;\r\n        \r\n        if (rResult == tResult) {\r\n            matchPoints += 5;\r\n            if(rResult == 0) {\r\n                matchPoints += 5;\r\n            }\r\n            if(starMatches[matchIndex]) {\r\n                matchPoints += 2;\r\n            }\r\n        }\r\n        if(tUnder49 == rUnder49) {\r\n            matchPoints += 1;\r\n        }\r\n        if(tTouchdowns == rTouchdowns) {\r\n            matchPoints += 4;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice calculates points won by yellow and red cards predictions\r\n    * @param extras token predictions\r\n    * @return amount of points\r\n    */\r\n    function getExtraPoints(uint96 extras, Extras extraStats) private pure returns(uint16 extraPoints){\r\n\r\n        uint16 interceptions = uint16(extras & EXTRA_STATS_MASK);\r\n        extras = extras >> 16;\r\n        uint16 missedFieldGoals = uint16(extras & EXTRA_STATS_MASK);\r\n        extras = extras >> 16;\r\n        uint16 overtimes = uint16(extras & EXTRA_STATS_MASK);\r\n        extras = extras >> 16;\r\n        uint16 sacks = uint16(extras & EXTRA_STATS_MASK);\r\n        extras = extras >> 16;\r\n        uint16 fieldGoals = uint16(extras & EXTRA_STATS_MASK);\r\n        extras = extras >> 16;\r\n        uint16 fumbles = uint16(extras & EXTRA_STATS_MASK);\r\n\r\n        if (interceptions == extraStats.interceptions){\r\n            extraPoints += 6;\r\n        }\r\n        \r\n        if (missedFieldGoals == extraStats.missedFieldGoals){\r\n            extraPoints += 6;\r\n        }\r\n\r\n        if (overtimes == extraStats.overtimes){\r\n            extraPoints += 6;\r\n        }\r\n\r\n        if (sacks == extraStats.sacks){\r\n            extraPoints += 6;\r\n        }\r\n\r\n        if (fieldGoals == extraStats.fieldGoals){\r\n            extraPoints += 6;\r\n        }\r\n\r\n        if (fumbles == extraStats.fumbles){\r\n            extraPoints += 6;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    *\r\n    *\r\n    *\r\n    */\r\n    function getBonusPoints (uint256 bonusId, uint32 bonuses, BonusMatch[] bonusMatches) private pure returns(uint16 bonusPoints) {\r\n        uint8 bonus = uint8(bonuses & BONUS_STAT_MASK);\r\n\r\n        if(bonusMatches[bonusId].bonus == bonus) {\r\n            bonusPoints += 2;\r\n        }\r\n    }\r\n\r\n\r\n    function calculateTokenPoints (uint160 tMatchResults, uint32 tBonusMatches, uint96 tExtraStats, MatchResult[] storage matchResults, Extras storage extraStats, BonusMatch[] storage bonusMatches, bool[] starMatches) \r\n    external pure returns(uint16 points){\r\n        \r\n        //Matches\r\n        uint160 m = tMatchResults;\r\n        for (uint256 i = 0; i < MATCHES_NUMBER; i++){\r\n            points += getMatchPoints(MATCHES_NUMBER - i - 1, m, matchResults, starMatches);\r\n            m = m >> 8;\r\n        }\r\n\r\n        //BonusMatches\r\n        uint32 b = tBonusMatches;\r\n        for(uint256 j = 0; j < BONUS_MATCHES; j++) {\r\n            points += getBonusPoints(BONUS_MATCHES - j - 1, b, bonusMatches);\r\n            b = b >> 6;\r\n        }\r\n\r\n        //Extras\r\n        points += getExtraPoints(tExtraStats, extraStats);\r\n\r\n    }\r\n}\r\n\r\n// File: contracts/dataSource/DataSourceInterface.sol\r\n\r\ncontract DataSourceInterface {\r\n\r\n    function isDataSource() public pure returns (bool);\r\n\r\n    function getMatchResults() external;\r\n    function getExtraStats() external;\r\n    function getBonusResults() external;\r\n\r\n}\r\n\r\n// File: contracts/game/GameStorage.sol\r\n\r\n// Matches\r\n    // 0  Baltimore,Cleveland   Bonus\r\n    // 1  Denver,New York       Bonus\r\n    // 2  Atlanta,Pittsburgh\r\n    // 3  New York,Carolina\r\n    // 4 Minnesota,Philadelphia Bonus\r\n    // 5 Arizona,San Francisco\r\n    // 6 Los Angeles,Seattle\r\n    // 7 Dallas,Houston         Star\r\n\r\n\r\n\r\n\r\n\r\ncontract GameStorage{\r\n\r\n    event LogTokenBuilt(address creatorAddress, uint256 tokenId, string message, uint160 m, uint96 e, uint32 b);\r\n    event LogTokenGift(address creatorAddress, address giftedAddress, uint256 tokenId, string message, uint160 m, uint96 e, uint32 b);\r\n    event LogPrepaidTokenBuilt(address creatorAddress, bytes32 secret);\r\n    event LogPrepaidRedeemed(address redeemer, uint256 tokenId, string message, uint160 m, uint96 e, uint32 b);\r\n\r\n    uint256 constant STARTING_PRICE = 50 finney;\r\n    uint256 constant FIRST_PHASE  = 1540393200;\r\n    uint256 constant EVENT_START = 1541084400;\r\n\r\n    uint8 constant MATCHES_NUMBER = 20;\r\n    uint8 constant BONUS_MATCHES = 5;\r\n\r\n    //6, 12, 18    \r\n    bool[] internal starMatches = [false, false, false, false, false, false, true, false, false, false, false, false, true, false, false, false, false, false, true, false];\r\n    \r\n    uint16 constant EXTRA_STATS_MASK = 65535;\r\n    uint8 constant MATCH_UNDEROVER_MASK = 1;\r\n    uint8 constant MATCH_RESULT_MASK = 3;\r\n    uint8 constant MATCH_TOUCHDOWNS_MASK = 31;\r\n    uint8 constant BONUS_STAT_MASK = 63;\r\n\r\n    uint256 public prizePool = 0;\r\n    uint256 public adminPool = 0;\r\n\r\n    mapping (uint256 => uint16) public tokenToPointsMap;    \r\n    mapping (uint256 => uint256) public tokenToPayoutMap;\r\n    mapping (bytes32 => uint8) public secretsMap;\r\n\r\n\r\n    address public dataSourceAddress;\r\n    DataSourceInterface internal dataSource;\r\n\r\n\r\n    enum pointsValidationState { Unstarted, LimitSet, LimitCalculated, OrderChecked, TopWinnersAssigned, WinnersAssigned, Finished }\r\n    pointsValidationState public pValidationState = pointsValidationState.Unstarted;\r\n\r\n    uint256 internal pointsLimit = 0;\r\n    uint32 internal lastCalculatedToken = 0;\r\n    uint32 internal lastCheckedToken = 0;\r\n    uint32 internal winnerCounter = 0;\r\n    uint32 internal lastAssigned = 0;\r\n    uint32 internal payoutRange = 0;\r\n    uint32 internal lastPrizeGiven = 0;\r\n\r\n    uint16 internal superiorQuota;\r\n    \r\n    uint16[] internal payDistributionAmount = [1,1,1,1,1,1,1,1,1,1,5,5,10,20,50,100,100,200,500,1500,2500];\r\n    uint24[21] internal payoutDistribution;\r\n\r\n    uint256[] internal sortedWinners;\r\n\r\n    PointsCalculator.MatchResult[] public matchResults;\r\n    PointsCalculator.BonusMatch[] public bonusMatches;\r\n    PointsCalculator.Extras public extraStats;\r\n\r\n\r\n}\r\n\r\n// File: contracts/CryptocupStorage.sol\r\n\r\ncontract CryptocupStorage is GameStorage {\r\n\r\n}\r\n\r\n// File: contracts/ticket/TicketInterface.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ninterface TicketInterface {\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n    function getOwnedTokens(address _from) public view returns(uint256[]);\r\n\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) public;\r\n\r\n}\r\n\r\n// File: contracts/ticket/TicketStorage.sol\r\n\r\ncontract TicketStorage is TicketInterface{\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    struct Token {\r\n        uint160 matches;\r\n        uint32 bonusMatches;\r\n        uint96 extraStats;\r\n        uint64 timeStamp;\r\n        string message;  \r\n    }\r\n    \r\n    // List of all tokens\r\n    Token[] tokens;\r\n\r\n    mapping (uint256 => address) public tokenOwner;\r\n    mapping (uint256 => address) public tokenApprovals;\r\n    mapping (address => uint256[]) internal ownedTokens;\r\n    mapping (address => mapping (address => bool)) public operatorApprovals;\r\n\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/helpers/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/access/AccessStorage.sol\r\n\r\ncontract AccessStorage{\r\n\r\n\tbool public paused = false;\r\n    bool public finalized = false;\r\n    \r\n    address public adminAddress;\r\n    address public dataSourceAddress;\r\n    address public marketplaceAddress;\r\n\r\n    uint256 internal deploymentTime = 0;\r\n    uint256 public gameFinishedTime = 0; \r\n    uint256 public finalizedTime = 0;\r\n\r\n}\r\n\r\n// File: contracts/access/AccessRegistry.sol\r\n\r\n/**\r\n* @title AccessControlLayer\r\n* @author CryptoCup Team (https://cryptocup.io/about)\r\n* @dev Containes basic admin modifiers to restrict access to some functions. Allows\r\n* for pauseing, and setting emergency stops.\r\n*/\r\ncontract AccessRegistry is AccessStorage {\r\n\r\n\r\n   /**\r\n   * @dev Main modifier to limit access to delicate functions.\r\n   */\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Only admin.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Main modifier to limit access to delicate functions.\r\n   */\r\n    modifier onlyDataSource() {\r\n        require(msg.sender == dataSourceAddress, \"Only dataSource.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Main modifier to limit access to delicate functions.\r\n   */\r\n    modifier onlyMarketPlace() {\r\n        require(msg.sender == marketplaceAddress, \"Only marketplace.\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract is not paused\r\n    */\r\n    modifier isNotPaused() {\r\n        require(!paused, \"Only if not paused.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract is paused\r\n    */\r\n    modifier isPaused() {\r\n        require(paused, \"Only if paused.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract has finished successfully\r\n    */\r\n    modifier hasFinished() {\r\n        require((gameFinishedTime != 0) && now >= (gameFinishedTime + (15 days)), \"Only if game has finished.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract has finalized\r\n    */\r\n    modifier hasFinalized() {\r\n        require(finalized, \"Only if game has finalized.\");\r\n        _;\r\n    }\r\n\r\n    function setPause () internal {\r\n        paused = true;\r\n    }\r\n\r\n    function unSetPause() internal {\r\n        paused = false;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer contract's ownership\r\n    * @param _newAdmin Address to be set\r\n    */\r\n    function setAdmin(address _newAdmin) external onlyAdmin {\r\n\r\n        require(_newAdmin != address(0));\r\n        adminAddress = _newAdmin;\r\n    }\r\n\r\n     /**\r\n    * @dev Adds contract's mkt\r\n    * @param _newMkt Address to be set\r\n    */\r\n    function setMarketplaceAddress(address _newMkt) external onlyAdmin {\r\n\r\n        require(_newMkt != address(0));\r\n        marketplaceAddress = _newMkt;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the contract pause state\r\n    * @param state True to pause\r\n    */\r\n    function setPauseState(bool state) external onlyAdmin {\r\n        paused = state;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the contract to finalized\r\n    * @param state True to finalize\r\n    */\r\n    function setFinalized(bool state) external onlyAdmin {\r\n        paused = state;\r\n        finalized = state;\r\n        if(finalized == true)\r\n            finalizedTime = now;\r\n    }\r\n}\r\n\r\n// File: contracts/ticket/TicketRegistry.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract TicketRegistry is TicketInterface, TicketStorage, AccessRegistry{\r\n\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n    \r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param _owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownedTokens[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param _tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets tokens of owner\r\n     * @param _from address of the owner\r\n     * @return array with token ids\r\n     */\r\n    function getOwnedTokens(address _from) public view returns(uint256[]) {\r\n        return ownedTokens[_from];   \r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param _tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param _to address to be approved for the given token ID\r\n     * @param _tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        tokenApprovals[_tokenId] = _to;\r\n        emit Approval(owner, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * @param _tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param _to operator address to set the approval\r\n     * @param _approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require(_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param _owner owner address which you want to query the approval of\r\n     * @param _operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool)  {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public isNotPaused{\r\n        \r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require (_from != _to);\r\n        \r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        // require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param _spender address of the spender to query\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *  is an operator of the owner, or is the owner of the token\r\n     */\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool){\r\n        address owner = ownerOf(_tokenId);\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (\r\n            _spender == owner ||\r\n            getApproved(_tokenId) == _spender ||\r\n            isApprovedForAll(owner, _spender)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param _to The address that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n     */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        //emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to clear current approval of a given token ID\r\n     * Reverts if the given address is not indeed the owner of the token\r\n     * @param _owner owner of the token\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to add a token ID to the list of a given address\r\n     * @param _to address representing the new owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokens[_to].push(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a token ID from the list of a given address\r\n     * @param _from address representing the previous owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n\r\n        require(ownerOf(_tokenId) == _from);\r\n        require(ownedTokens[_from].length < 100);\r\n\r\n        tokenOwner[_tokenId] = address(0);\r\n\r\n        uint256[] storage tokenArray = ownedTokens[_from];\r\n        for (uint256 i = 0; i < tokenArray.length; i++){\r\n            if(tokenArray[i] == _tokenId){\r\n                tokenArray[i] = tokenArray[tokenArray.length-1];\r\n            }\r\n        }\r\n        \r\n        delete tokenArray[tokenArray.length-1];\r\n        tokenArray.length--;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n// File: contracts/libs/PayoutDistribution.sol\r\n\r\nlibrary PayoutDistribution {\r\n\r\n\tfunction getDistribution(uint256 tokenCount) external pure returns (uint24[21] payoutDistribution) {\r\n\r\n\t\tif(tokenCount < 101){\r\n            payoutDistribution = [289700, 189700, 120000, 92500, 75000, 62500, 52500, 42500, 40000, 35600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n        }else if(tokenCount < 201){\r\n            payoutDistribution = [265500, 165500, 105500, 75500, 63000, 48000, 35500, 20500, 20000, 19500, 18500, 17800, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n        }else if(tokenCount < 301){\r\n            payoutDistribution = [260700, 155700, 100700, 70900, 60700, 45700, 35500, 20500, 17900, 12500, 11500, 11000, 10670, 0, 0, 0, 0, 0, 0, 0, 0];\r\n        }else if(tokenCount < 501){\r\n            payoutDistribution = [238600, 138600, 88800, 63800, 53800, 43800, 33800, 18800, 17500, 12500, 9500, 7500, 7100, 6700, 0, 0, 0, 0, 0, 0, 0];\r\n        }else if(tokenCount < 1001){\r\n            payoutDistribution = [218300, 122300, 72300, 52400, 43900, 33900, 23900, 16000, 13000, 10000, 9000, 7000, 5000, 4000, 3600, 0, 0, 0, 0, 0, 0];\r\n        }else if(tokenCount < 2001){\r\n            payoutDistribution = [204500, 114000, 64000, 44100, 35700, 26700, 22000, 15000, 11000, 9500, 8500, 6500, 4600, 2500, 2000, 1800, 0, 0, 0, 0, 0];\r\n        }else if(tokenCount < 3001){\r\n            payoutDistribution = [189200, 104800, 53900, 34900, 29300, 19300, 15300, 14000, 10500, 8300, 8000, 6000, 3800, 2500, 2000, 1500, 1100, 0, 0, 0, 0];\r\n        }else if(tokenCount < 5001){\r\n            payoutDistribution = [178000, 100500, 47400, 30400, 24700, 15500, 15000, 12000, 10200, 7800, 7400, 5500, 3300, 2000, 1500, 1200, 900, 670, 0, 0, 0];\r\n        }else if(tokenCount < 10001){\r\n            payoutDistribution = [157600, 86500, 39000, 23100, 18900, 15000, 14000, 11000, 9300, 6100, 6000, 5000, 3800, 1500, 1100, 900, 700, 500, 360, 0, 0];\r\n        }else if(tokenCount < 25001){\r\n            payoutDistribution = [132500, 70200, 31300, 18500, 17500, 14000, 13500, 10500, 7500, 5500, 5000, 4000, 3000, 1000, 900, 700, 600, 400, 200, 152, 0];\r\n        } else {\r\n            payoutDistribution = [120000, 63000,  27000, 18800, 17300, 13700, 13000, 10000, 6300, 5000, 4500, 3900, 2500, 900, 800, 600, 500, 350, 150, 100, 70];\r\n        }\r\n\t}\r\n\r\n\tfunction getSuperiorQuota(uint256 tokenCount) external pure returns (uint16 superiorQuota){\r\n\r\n\t\tif(tokenCount < 101){\r\n            superiorQuota = 10;\r\n        }else if(tokenCount < 201){\r\n            superiorQuota = 20;\r\n        }else if(tokenCount < 301){\r\n            superiorQuota = 30;\r\n        }else if(tokenCount < 501){\r\n            superiorQuota = 50;\r\n        }else if(tokenCount < 1001){\r\n            superiorQuota = 100;\r\n        }else if(tokenCount < 2001){\r\n            superiorQuota = 200;\r\n        }else if(tokenCount < 3001){\r\n            superiorQuota = 300;\r\n        }else if(tokenCount < 5001){\r\n            superiorQuota = 500;\r\n        }else if(tokenCount < 10001){\r\n            superiorQuota = 1000;\r\n        }else if(tokenCount < 25001){\r\n            superiorQuota = 2500;\r\n        } else {\r\n            superiorQuota = 5000;\r\n        }\r\n\t}\r\n\r\n}\r\n\r\n// File: contracts/game/GameRegistry.sol\r\n\r\ncontract GameRegistry is CryptocupStorage, TicketRegistry{\r\n\t\r\n    using PointsCalculator for PointsCalculator.MatchResult;\r\n    using PointsCalculator for PointsCalculator.BonusMatch;\r\n    using PointsCalculator for PointsCalculator.Extras;\r\n\r\n     /**\r\n    * @dev Checks if pValidationState is in the provided stats\r\n    * @param state State required to run\r\n    */\r\n    modifier checkState(pointsValidationState state){\r\n        require(pValidationState == state, \"Points validation stage invalid.\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @notice Gets current token price \r\n    */\r\n    function _getTokenPrice() internal view returns(uint256 tokenPrice){\r\n\r\n        if (now >= FIRST_PHASE) {\r\n            tokenPrice = (80 finney);\r\n        } else {\r\n            tokenPrice = STARTING_PRICE;\r\n        }\r\n\r\n        require(tokenPrice >= STARTING_PRICE && tokenPrice <= (80 finney));\r\n\r\n    }\r\n\r\n    function _prepareMatchResultsArray() internal {\r\n        matchResults.length = MATCHES_NUMBER;\r\n    }\r\n\r\n    function _prepareBonusResultsArray() internal {\r\n        bonusMatches.length = BONUS_MATCHES;\r\n    }\r\n\r\n    /** \r\n    * @notice Builds ERC721 token with the predictions provided by the user.\r\n    * @param matches  - Matches results (who wins, amount of points)\r\n    * @param bonusMatches -  Stats from bonus matches\r\n    * @param extraStats - Total number of extra stats like touchdonws, etc.\r\n    * @dev An automatic timestamp is added for internal use.\r\n    */\r\n    function _createToken(uint160 matches, uint32 bonusMatches, uint96 extraStats, string userMessage) internal returns (uint256){\r\n\r\n        Token memory token = Token({\r\n            matches: matches,\r\n            bonusMatches: bonusMatches,\r\n            extraStats: extraStats,\r\n            timeStamp: uint64(now),\r\n            message: userMessage\r\n        });\r\n\r\n        uint256 tokenId = tokens.push(token) - 1;\r\n        require(tokenId == uint256(uint32(tokenId)), \"Failed to convert tokenId to uint256.\");\r\n        \r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the data source contract address \r\n    * @param _address Address to be set\r\n    */\r\n    function setDataSourceAddress(address _address) external onlyAdmin {\r\n        \r\n        DataSourceInterface c = DataSourceInterface(_address);\r\n\r\n        require(c.isDataSource());\r\n\r\n        dataSource = c;\r\n        dataSourceAddress = _address;\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Called by the development team once the World Cup has ended (adminPool is set) \r\n    * @dev Allows dev team to retrieve adminPool\r\n    */\r\n    function adminWithdrawBalance() external onlyAdmin {\r\n\r\n        uint256 adminPrize = adminPool;\r\n\r\n        adminPool = 0;\r\n        adminAddress.transfer(adminPrize);\r\n\r\n    }\r\n\r\n\r\n     /**\r\n    * @notice Let the admin cash-out the entire contract balance 10 days after game has finished.\r\n    */\r\n    function finishedGameWithdraw() external onlyAdmin hasFinished{\r\n\r\n        uint256 balance = address(this).balance;\r\n        adminAddress.transfer(balance);\r\n\r\n    }\r\n    \r\n    /**\r\n    * @notice Let the admin cash-out the entire contract balance 10 days after game has finished.\r\n    */\r\n    function emergencyWithdrawAdmin() external hasFinalized onlyAdmin{\r\n\r\n        require(finalizedTime != 0 &&  now >= finalizedTime + 10 days );\r\n        msg.sender.transfer(address(this).balance);\r\n\r\n    }\r\n\r\n\r\n    function isDataSourceCallback() external pure returns (bool){\r\n        return true;\r\n    }\r\n\r\n    function dataSourceGetMatchesResults() external onlyAdmin {\r\n        dataSource.getMatchResults();\r\n    }\r\n\r\n    function dataSourceGetBonusResults() external onlyAdmin{\r\n        dataSource.getBonusResults();\r\n    }\r\n\r\n    function dataSourceGetExtraStats() external onlyAdmin{\r\n        dataSource.getExtraStats();\r\n    }\r\n\r\n    function dataSourceCallbackMatch(uint160 matches) external onlyDataSource{\r\n        uint160 m = matches;\r\n        for(uint256 i = 0; i < MATCHES_NUMBER; i++) {\r\n            matchResults[MATCHES_NUMBER - i - 1].result = uint8(m & MATCH_RESULT_MASK);\r\n            matchResults[MATCHES_NUMBER - i - 1].under49 = uint8((m >> 2) & MATCH_UNDEROVER_MASK);\r\n            matchResults[MATCHES_NUMBER - i - 1].touchdowns = uint8((m >> 3) & MATCH_TOUCHDOWNS_MASK);\r\n            m = m >> 8;\r\n        }\r\n    }\r\n\r\n    function dataSourceCallbackBonus(uint32 bonusResults) external onlyDataSource{\r\n        uint32 b = bonusResults;\r\n        for(uint256 i = 0; i < BONUS_MATCHES; i++) {\r\n            bonusMatches[BONUS_MATCHES - i - 1].bonus = uint8(b & BONUS_STAT_MASK);\r\n            b = b >> 6;\r\n        }\r\n    }\r\n\r\n    function dataSourceCallbackExtras(uint96 es) external onlyDataSource{\r\n        uint96 e = es;\r\n        extraStats.interceptions = uint16(e & EXTRA_STATS_MASK);\r\n        e = e >> 16;\r\n        extraStats.missedFieldGoals = uint16(e & EXTRA_STATS_MASK);\r\n        e = e >> 16;\r\n        extraStats.overtimes = uint16(e & EXTRA_STATS_MASK);\r\n        e = e >> 16;\r\n        extraStats.sacks = uint16(e & EXTRA_STATS_MASK);\r\n        e = e >> 16;\r\n        extraStats.fieldGoals = uint16(e & EXTRA_STATS_MASK);\r\n        e = e >> 16;\r\n        extraStats.fumbles = uint16(e & EXTRA_STATS_MASK);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the points of all the tokens between the last chunk set and the amount given.\r\n    * @dev This function uses all the data collected earlier by oraclize to calculate points.\r\n    * @param amount The amount of tokens that should be analyzed.\r\n    */\r\n    function calculatePointsBlock(uint32 amount) external{\r\n\r\n        require (gameFinishedTime == 0);\r\n        require(amount + lastCheckedToken <= tokens.length);\r\n\r\n        for (uint256 i = lastCalculatedToken; i < (lastCalculatedToken + amount); i++) {\r\n            uint16 points = PointsCalculator.calculateTokenPoints(tokens[i].matches, tokens[i].bonusMatches,\r\n                tokens[i].extraStats, matchResults, extraStats, bonusMatches, starMatches);\r\n            tokenToPointsMap[i] = points;\r\n        }\r\n\r\n        lastCalculatedToken += amount;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the structures for payout distribution, last position and superior quota. Payout distribution is the\r\n    * percentage of the pot each position gets, last position is the percentage of the pot the last position gets,\r\n    * and superior quota is the total amount OF winners that are given a prize.\r\n    * @dev Each of this structures is dynamic and is assigned depending on the total amount of tokens in the game  \r\n    */\r\n    function setPayoutDistributionId () internal {\r\n\r\n        uint24[21] memory auxArr = PayoutDistribution.getDistribution(tokens.length);\r\n\r\n        for(uint256 i = 0; i < auxArr.length; i++){\r\n            payoutDistribution[i] = auxArr[i];\r\n        }\r\n        \r\n        superiorQuota = PayoutDistribution.getSuperiorQuota(tokens.length);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the id of the last token that will be given a prize.\r\n    * @dev This is done to offload some of the calculations needed for sorting, and to cap the number of sorts\r\n    * needed to just the winners and not the whole array of tokens.\r\n    * @param tokenId last token id\r\n    */\r\n    function setLimit(uint256 tokenId) external onlyAdmin{\r\n        require(tokenId < tokens.length);\r\n        require(pValidationState == pointsValidationState.Unstarted || pValidationState == pointsValidationState.LimitSet);\r\n        pointsLimit = tokenId;\r\n        pValidationState = pointsValidationState.LimitSet;\r\n        lastCheckedToken = 0;\r\n        lastCalculatedToken = 0;\r\n        winnerCounter = 0;\r\n        \r\n        setPause();\r\n        setPayoutDistributionId();\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Sets the 10th percentile of the sorted array of points\r\n    * @param amount tokens in a chunk\r\n    */\r\n    function calculateWinners(uint32 amount) external onlyAdmin checkState(pointsValidationState.LimitSet){\r\n        require(amount + lastCheckedToken <= tokens.length);\r\n        uint256 points = tokenToPointsMap[pointsLimit];\r\n\r\n        for(uint256 i = lastCheckedToken; i < lastCheckedToken + amount; i++){\r\n            if(tokenToPointsMap[i] > points ||\r\n                (tokenToPointsMap[i] == points && i <= pointsLimit)){\r\n                winnerCounter++;\r\n            }\r\n        }\r\n        lastCheckedToken += amount;\r\n\r\n        if(lastCheckedToken == tokens.length){\r\n            require(superiorQuota == winnerCounter);\r\n            pValidationState = pointsValidationState.LimitCalculated;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Checks if the order given offchain coincides with the order of the actual previously calculated points\r\n    * in the smart contract.\r\n    * @dev the token sorting is done offchain so as to save on the huge amount of gas and complications that \r\n    * could occur from doing all the sorting onchain.\r\n    * @param sortedChunk chunk sorted by points\r\n    */\r\n    function checkOrder(uint32[] sortedChunk) external onlyAdmin checkState(pointsValidationState.LimitCalculated){\r\n        require(sortedChunk.length + sortedWinners.length <= winnerCounter);\r\n\r\n        for(uint256 i = 0; i < sortedChunk.length - 1; i++){\r\n            uint256 id = sortedChunk[i];\r\n            uint256 sigId = sortedChunk[i+1];\r\n            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] &&\r\n                id < sigId));\r\n        }\r\n\r\n        if(sortedWinners.length != 0){\r\n            uint256 id2 = sortedWinners[sortedWinners.length-1];\r\n            uint256 sigId2 = sortedChunk[0];\r\n            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] ||\r\n                (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));\r\n        }\r\n\r\n        for(uint256 j = 0; j < sortedChunk.length; j++){\r\n            sortedWinners.push(sortedChunk[j]);\r\n        }\r\n\r\n        if(sortedWinners.length == winnerCounter){\r\n            require(sortedWinners[sortedWinners.length-1] == pointsLimit);\r\n            pValidationState = pointsValidationState.OrderChecked;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice If anything during the point calculation and sorting part should fail, this function can reset \r\n    * data structures to their initial position, so as to  \r\n    */\r\n    function resetWinners(uint256 newLength) external onlyAdmin checkState(pointsValidationState.LimitCalculated){\r\n        \r\n        sortedWinners.length = newLength;\r\n    \r\n    }\r\n\r\n    /**\r\n    * @notice Assigns prize percentage for the lucky top 30 winners. Each token will be assigned a uint256 inside\r\n    * tokenToPayoutMap structure that represents the size of the pot that belongs to that token. If any tokens\r\n    * tie inside of the first 30 tokens, the prize will be summed and divided equally. \r\n    */\r\n    function setTopWinnerPrizes() external onlyAdmin checkState(pointsValidationState.OrderChecked){\r\n\r\n        uint256 percent = 0;\r\n        uint[] memory tokensEquals = new uint[](30);\r\n        uint16 tokenEqualsCounter = 0;\r\n        uint256 currentTokenId;\r\n        uint256 currentTokenPoints;\r\n        uint256 lastTokenPoints;\r\n        uint32 counter = 0;\r\n        uint256 maxRange = 13;\r\n        if(tokens.length < 201){\r\n            maxRange = 10;\r\n        }\r\n        \r\n\r\n        while(payoutRange < maxRange){\r\n            uint256 inRangecounter = payDistributionAmount[payoutRange];\r\n            while(inRangecounter > 0){\r\n                currentTokenId = sortedWinners[counter];\r\n                currentTokenPoints = tokenToPointsMap[currentTokenId];\r\n\r\n                inRangecounter--;\r\n\r\n                //Special case for the last one\r\n                if(inRangecounter == 0 && payoutRange == maxRange - 1){\r\n                    if(currentTokenPoints == lastTokenPoints){\r\n                        percent += payoutDistribution[payoutRange];\r\n                        tokensEquals[tokenEqualsCounter] = currentTokenId;\r\n                        tokenEqualsCounter++;\r\n                    } else {\r\n                        tokenToPayoutMap[currentTokenId] = payoutDistribution[payoutRange];\r\n                    }\r\n                }\r\n\r\n                //Fix second condition\r\n                if(counter != 0 && (currentTokenPoints != lastTokenPoints || (inRangecounter == 0 && payoutRange == maxRange - 1))){ \r\n                    for(uint256 i = 0; i < tokenEqualsCounter; i++){\r\n                        tokenToPayoutMap[tokensEquals[i]] = percent.div(tokenEqualsCounter);\r\n                    }\r\n                    percent = 0;\r\n                    tokensEquals = new uint[](30);\r\n                    tokenEqualsCounter = 0;\r\n                }\r\n\r\n                percent += payoutDistribution[payoutRange];\r\n                tokensEquals[tokenEqualsCounter] = currentTokenId;\r\n                \r\n                tokenEqualsCounter++;\r\n                counter++;\r\n\r\n                lastTokenPoints = currentTokenPoints;\r\n            }\r\n            payoutRange++;\r\n        }\r\n\r\n        pValidationState = pointsValidationState.TopWinnersAssigned;\r\n        lastPrizeGiven = counter;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets prize percentage to every address that wins from the position 30th onwards\r\n    * @dev If there are less than 300 tokens playing, then this function will set nothing.\r\n    * @param amount tokens in a chunk\r\n    */\r\n    function setWinnerPrizes(uint32 amount) external onlyAdmin checkState(pointsValidationState.TopWinnersAssigned){\r\n        require(lastPrizeGiven + amount <= winnerCounter);\r\n        \r\n        uint16 inRangeCounter = payDistributionAmount[payoutRange];\r\n        for(uint256 i = 0; i < amount; i++){\r\n            if (inRangeCounter == 0){\r\n                payoutRange++;\r\n                inRangeCounter = payDistributionAmount[payoutRange];\r\n            }\r\n\r\n            uint256 tokenId = sortedWinners[i + lastPrizeGiven];\r\n\r\n            tokenToPayoutMap[tokenId] = payoutDistribution[payoutRange];\r\n\r\n            inRangeCounter--;\r\n        }\r\n        //i + amount prize was not given yet, so amount -1\r\n        lastPrizeGiven += amount;\r\n        payDistributionAmount[payoutRange] = inRangeCounter;\r\n\r\n        if(lastPrizeGiven == winnerCounter){\r\n            pValidationState = pointsValidationState.WinnersAssigned;\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n     /**\r\n    * @notice Sets prizes for last tokens and sets prize pool amount\r\n    */\r\n    function setEnd() external onlyAdmin checkState(pointsValidationState.WinnersAssigned){\r\n            \r\n        uint256 balance = address(this).balance;\r\n        adminPool = balance.mul(10).div(100);\r\n        prizePool = balance.mul(90).div(100);\r\n\r\n        pValidationState = pointsValidationState.Finished;\r\n        gameFinishedTime = now;\r\n        unSetPause();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/CryptocupNFL.sol\r\n\r\ncontract CryptocupNFL is GameRegistry {\r\n\r\n\tconstructor() public {\r\n        adminAddress = msg.sender;\r\n        deploymentTime = now;\r\n\r\n        _prepareMatchResultsArray();\r\n        _prepareBonusResultsArray();\r\n    }\r\n\r\n     /** \r\n    * @dev Only accept eth from the admin\r\n    */\r\n    function() external payable {\r\n        require(msg.sender == adminAddress || msg.sender == marketplaceAddress);\r\n\r\n    }\r\n\r\n    function buildToken(uint160 matches, uint32 bonusMatches, uint96 extraStats, string message) external payable isNotPaused returns(uint256){\r\n\r\n        require(msg.value >= _getTokenPrice(), \"Eth sent is not enough.\");\r\n        require(msg.sender != address(0), \"Sender cannot be 0 address.\");\r\n        require(ownedTokens[msg.sender].length < 100, \"Sender cannot have more than 100 tokens.\");\r\n        require(now < EVENT_START, \"Event already started.\"); //Event Start\r\n        require (bytes(message).length <= 100);\r\n        \r\n\r\n        uint256 tokenId = _createToken(matches, bonusMatches, extraStats, message);\r\n        \r\n        _mint(msg.sender, tokenId);\r\n        \r\n        emit LogTokenBuilt(msg.sender, tokenId, message, matches, extraStats, bonusMatches);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function giftToken(address giftedAddress, uint160 matches, uint32 bonusMatches, uint96 extraStats, string message) external payable isNotPaused returns(uint256){\r\n\r\n        require(msg.value >= _getTokenPrice(), \"Eth sent is not enough.\");\r\n        require(msg.sender != address(0), \"Sender cannot be 0 address.\");\r\n        require(ownedTokens[giftedAddress].length < 100, \"Sender cannot have more than 100 tokens.\");\r\n        require(now < EVENT_START, \"Event already started.\"); //Event Start\r\n        require (bytes(message).length <= 100);\r\n\r\n        uint256 tokenId = _createToken(matches, bonusMatches, extraStats, message);\r\n\r\n        _mint(giftedAddress, tokenId);\r\n        \r\n        emit LogTokenGift(msg.sender, giftedAddress, tokenId, message, matches, extraStats, bonusMatches);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function buildPrepaidToken(bytes32 secret) external payable onlyAdmin isNotPaused {\r\n\r\n        require(msg.value >= _getTokenPrice(), \"Eth sent is not enough.\");\r\n        require(msg.sender != address(0), \"Sender cannot be 0 address.\");\r\n        require(now < EVENT_START, \"Event already started.\"); //Event Start\r\n\r\n        secretsMap[secret] = 1;\r\n        \r\n        emit LogPrepaidTokenBuilt(msg.sender, secret);\r\n    }\r\n\r\n    function redeemPrepaidToken(bytes32 preSecret, uint160 matches, uint32 bonusMatches, uint96 extraStats, string message) external isNotPaused returns(uint256){\r\n\r\n        require(msg.sender != address(0), \"Sender cannot be 0 address.\");\r\n        require(ownedTokens[msg.sender].length < 100, \"Sender cannot have more than 100 tokens.\");\r\n        require(now < EVENT_START, \"Event already started.\"); //Event Start\r\n        require (bytes(message).length <= 100);\r\n\r\n        bytes32 secret = keccak256(preSecret);\r\n\r\n        require (secretsMap[secret] == 1, \"Invalid secret.\");\r\n        \r\n        secretsMap[secret] = 0;\r\n\r\n        uint256 tokenId = _createToken(matches, bonusMatches, extraStats, message);\r\n        _mint(msg.sender, tokenId);\r\n        \r\n        emit LogPrepaidRedeemed(msg.sender, tokenId, message, matches, extraStats, bonusMatches);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n\r\n    /** \r\n    * @param tokenId - ID of token to get.\r\n    * @return Returns all the valuable information about a specific token.\r\n    */\r\n    function getToken(uint256 tokenId) external view returns (uint160 matches, uint32 bonusMatches, uint96 extraStats, uint64 timeStamp, string message) {\r\n\r\n        Token storage token = tokens[tokenId];\r\n\r\n        matches = token.matches;\r\n        bonusMatches = token.bonusMatches;\r\n        extraStats = token.extraStats;\r\n        timeStamp = token.timeStamp;\r\n        message = token.message;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Allows any user to retrieve their asigned prize. This would be the sum of the price of all the tokens\r\n    * owned by the caller of this function.\r\n    * @dev If the caller has no prize, the function will revert costing no gas to the caller.\r\n    */\r\n    function withdrawPrize() external checkState(pointsValidationState.Finished){\r\n        \r\n        uint256 prize = 0;\r\n        uint256[] memory tokenList = ownedTokens[msg.sender];\r\n        \r\n        for(uint256 i = 0;i < tokenList.length; i++){\r\n            prize += tokenToPayoutMap[tokenList[i]];\r\n            tokenToPayoutMap[tokenList[i]] = 0;\r\n        }\r\n        \r\n        require(prize > 0);\r\n        msg.sender.transfer((prizePool.mul(prize)).div(1000000));   \r\n    }\r\n\r\n\r\n    //EMERGENCY CALLS\r\n    //If something goes wrong or fails, these functions will allow retribution for token holders \r\n\r\n    /**\r\n    * @notice if there is an unresolvable problem, users can call to this function to get a refund.\r\n    */\r\n    function emergencyWithdraw() external hasFinalized{\r\n\r\n        uint256 balance = STARTING_PRICE * ownedTokens[msg.sender].length;\r\n\r\n        delete ownedTokens[msg.sender];\r\n        msg.sender.transfer(balance);\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"operatorApprovals\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dataSourceGetBonusResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dataSourceGetExtraStats\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setFinalized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"secretsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"calculateWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToPayoutMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setDataSourceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToPointsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matches\",\"type\":\"uint160\"}],\"name\":\"dataSourceCallbackMatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDataSourceCallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setTopWinnerPrizes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"preSecret\",\"type\":\"bytes32\"},{\"name\":\"matches\",\"type\":\"uint160\"},{\"name\":\"bonusMatches\",\"type\":\"uint32\"},{\"name\":\"extraStats\",\"type\":\"uint96\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"redeemPrepaidToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLength\",\"type\":\"uint256\"}],\"name\":\"resetWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sortedChunk\",\"type\":\"uint32[]\"}],\"name\":\"checkOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matches\",\"type\":\"uint160\"},{\"name\":\"bonusMatches\",\"type\":\"uint32\"},{\"name\":\"extraStats\",\"type\":\"uint96\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"buildToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pValidationState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"es\",\"type\":\"uint96\"}],\"name\":\"dataSourceCallbackExtras\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"setWinnerPrizes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdrawAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusResults\",\"type\":\"uint32\"}],\"name\":\"dataSourceCallbackBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenApprovals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishedGameWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"calculatePointsBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMkt\",\"type\":\"address\"}],\"name\":\"setMarketplaceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"giftedAddress\",\"type\":\"address\"},{\"name\":\"matches\",\"type\":\"uint160\"},{\"name\":\"bonusMatches\",\"type\":\"uint32\"},{\"name\":\"extraStats\",\"type\":\"uint96\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"giftToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPauseState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataSourceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dataSourceGetMatchesResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"buildPrepaidToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"getOwnedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketplaceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"name\":\"matches\",\"type\":\"uint160\"},{\"name\":\"bonusMatches\",\"type\":\"uint32\"},{\"name\":\"extraStats\",\"type\":\"uint96\"},{\"name\":\"timeStamp\",\"type\":\"uint64\"},{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusMatches\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matchResults\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"under49\",\"type\":\"uint8\"},{\"name\":\"touchdowns\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraStats\",\"outputs\":[{\"name\":\"interceptions\",\"type\":\"uint16\"},{\"name\":\"missedFieldGoals\",\"type\":\"uint16\"},{\"name\":\"overtimes\",\"type\":\"uint16\"},{\"name\":\"sacks\",\"type\":\"uint16\"},{\"name\":\"fieldGoals\",\"type\":\"uint16\"},{\"name\":\"fumbles\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adminWithdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameFinishedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"m\",\"type\":\"uint160\"},{\"indexed\":false,\"name\":\"e\",\"type\":\"uint96\"},{\"indexed\":false,\"name\":\"b\",\"type\":\"uint32\"}],\"name\":\"LogTokenBuilt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"giftedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"m\",\"type\":\"uint160\"},{\"indexed\":false,\"name\":\"e\",\"type\":\"uint96\"},{\"indexed\":false,\"name\":\"b\",\"type\":\"uint32\"}],\"name\":\"LogTokenGift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"LogPrepaidTokenBuilt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"m\",\"type\":\"uint160\"},{\"indexed\":false,\"name\":\"e\",\"type\":\"uint96\"},{\"indexed\":false,\"name\":\"b\",\"type\":\"uint32\"}],\"name\":\"LogPrepaidRedeemed\",\"type\":\"event\"}]","ContractName":"CryptocupNFL","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"PayoutDistribution:fab06e5f52820a397f1b9c79e59c84897e168813;PointsCalculator:2e2ae45a3e2ff04a441e043be45dfba3f7a083ed","SwarmSource":"bzzr://e1378936021c34c8727a49e5ce6ccb1e23120da769c9f755a61123be90acb2f9"}]}