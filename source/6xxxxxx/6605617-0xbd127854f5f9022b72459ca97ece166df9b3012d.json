{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(value <= _allowed[from][msg.sender]);\r\n\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].sub(subtractedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(value <= _balances[from]);\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    require(value <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    require(value <= _allowed[account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(!has(role, account));\r\n\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(has(role, account));\r\n\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\r\n\r\ncontract MinterRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event MinterAdded(address indexed account);\r\n  event MinterRemoved(address indexed account);\r\n\r\n  Roles.Role private minters;\r\n\r\n  constructor() internal {\r\n    _addMinter(msg.sender);\r\n  }\r\n\r\n  modifier onlyMinter() {\r\n    require(isMinter(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isMinter(address account) public view returns (bool) {\r\n    return minters.has(account);\r\n  }\r\n\r\n  function addMinter(address account) public onlyMinter {\r\n    _addMinter(account);\r\n  }\r\n\r\n  function renounceMinter() public {\r\n    _removeMinter(msg.sender);\r\n  }\r\n\r\n  function _addMinter(address account) internal {\r\n    minters.add(account);\r\n    emit MinterAdded(account);\r\n  }\r\n\r\n  function _removeMinter(address account) internal {\r\n    minters.remove(account);\r\n    emit MinterRemoved(account);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\r\n\r\n/**\r\n * @title ERC20Mintable\r\n * @dev ERC20 minting logic\r\n */\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param to The address that will receive the minted tokens.\r\n   * @param value The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    onlyMinter\r\n    returns (bool)\r\n  {\r\n    _mint(to, value);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract ERC20Burnable is ERC20 {\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 value) public {\r\n    _burn(msg.sender, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n   * @param from address The address which you want to send tokens from\r\n   * @param value uint256 The amount of token to be burned\r\n   */\r\n  function burnFrom(address from, uint256 value) public {\r\n    _burnFrom(from, value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor(string name, string symbol, uint8 decimals) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return the name of the token.\r\n   */\r\n  function name() public view returns(string) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return the symbol of the token.\r\n   */\r\n  function symbol() public view returns(string) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return the number of decimals of the token.\r\n   */\r\n  function decimals() public view returns(uint8) {\r\n    return _decimals;\r\n  }\r\n}\r\n\r\n// File: contracts/robonomics/XRT.sol\r\n\r\ncontract XRT is ERC20Mintable, ERC20Burnable, ERC20Detailed {\r\n    constructor() public ERC20Detailed(\"Robonomics Beta 3\", \"XRT\", 9) {\r\n        uint256 INITIAL_SUPPLY = 1000 * (10 ** 9);\r\n        _mint(msg.sender, INITIAL_SUPPLY);\r\n    }\r\n}\r\n\r\n// File: contracts/robonomics/RobotLiabilityAPI.sol\r\n\r\n//import './LiabilityFactory.sol';\r\n\r\n\r\ncontract RobotLiabilityAPI {\r\n    bytes   public model;\r\n    bytes   public objective;\r\n    bytes   public result;\r\n\r\n    ERC20   public token;\r\n    uint256 public cost;\r\n    uint256 public lighthouseFee;\r\n    uint256 public validatorFee;\r\n\r\n    bytes32 public demandHash;\r\n    bytes32 public offerHash;\r\n\r\n    address public promisor;\r\n    address public promisee;\r\n    address public lighthouse;\r\n    address public validator;\r\n\r\n    bool    public isSuccess;\r\n    bool    public isFinalized;\r\n\r\n    LiabilityFactory public factory;\r\n\r\n    event Finalized(bool indexed success, bytes result);\r\n}\r\n\r\n// File: contracts/robonomics/LightContract.sol\r\n\r\ncontract LightContract {\r\n    /**\r\n     * @dev Shared code smart contract \r\n     */\r\n    address lib;\r\n\r\n    constructor(address _library) public {\r\n        lib = _library;\r\n    }\r\n\r\n    function() public {\r\n        require(lib.delegatecall(msg.data));\r\n    }\r\n}\r\n\r\n// File: contracts/robonomics/RobotLiability.sol\r\n\r\n// Standard robot liability light contract\r\ncontract RobotLiability is RobotLiabilityAPI, LightContract {\r\n    constructor(address _lib) public LightContract(_lib)\r\n    { factory = LiabilityFactory(msg.sender); }\r\n}\r\n\r\n// File: contracts/robonomics/SingletonHash.sol\r\n\r\ncontract SingletonHash {\r\n    event HashConsumed(bytes32 indexed hash);\r\n\r\n    /**\r\n     * @dev Used hash accounting\r\n     */\r\n    mapping(bytes32 => bool) public isHashConsumed;\r\n\r\n    /**\r\n     * @dev Parameter can be used only once\r\n     * @param _hash Single usage hash\r\n     */\r\n    function singletonHash(bytes32 _hash) internal {\r\n        require(!isHashConsumed[_hash]);\r\n        isHashConsumed[_hash] = true;\r\n        emit HashConsumed(_hash);\r\n    }\r\n}\r\n\r\n// File: contracts/robonomics/DutchAuction.sol\r\n\r\n/// @title Dutch auction contract - distribution of XRT tokens using an auction.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\n/// @author Airalab - <research@aira.life> \r\ncontract DutchAuction {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event BidSubmission(address indexed sender, uint256 amount);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_TOKENS_SOLD = 800 * 10**9; // 8M XRT = 10M - 1M (Foundation) - 1M (Early investors base)\r\n    uint constant public WAITING_PERIOD = 0; // 1 days;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    XRT     public xrt;\r\n    address public ambix;\r\n    address public wallet;\r\n    address public owner;\r\n    uint public ceiling;\r\n    uint public priceFactor;\r\n    uint public startBlock;\r\n    uint public endTime;\r\n    uint public totalReceived;\r\n    uint public finalPrice;\r\n    mapping (address => uint) public bids;\r\n    Stages public stage;\r\n\r\n    /*\r\n     *  Enums\r\n     */\r\n    enum Stages {\r\n        AuctionDeployed,\r\n        AuctionSetUp,\r\n        AuctionStarted,\r\n        AuctionEnded,\r\n        TradingStarted\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier atStage(Stages _stage) {\r\n        // Contract on stage\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        // Only owner is allowed to proceed\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier isWallet() {\r\n        // Only wallet is allowed to proceed\r\n        require(msg.sender == wallet);\r\n        _;\r\n    }\r\n\r\n    modifier isValidPayload() {\r\n        require(msg.data.length == 4 || msg.data.length == 36);\r\n        _;\r\n    }\r\n\r\n    modifier timedTransitions() {\r\n        if (stage == Stages.AuctionStarted && calcTokenPrice() <= calcStopPrice())\r\n            finalizeAuction();\r\n        if (stage == Stages.AuctionEnded && now > endTime + WAITING_PERIOD)\r\n            stage = Stages.TradingStarted;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Contract constructor function sets owner.\r\n    /// @param _wallet Multisig wallet.\r\n    /// @param _ceiling Auction ceiling.\r\n    /// @param _priceFactor Auction price factor.\r\n    constructor(address _wallet, uint _ceiling, uint _priceFactor)\r\n        public\r\n    {\r\n        require(_wallet != 0 && _ceiling > 0 && _priceFactor > 0);\r\n\r\n        owner = msg.sender;\r\n        wallet = _wallet;\r\n        ceiling = _ceiling;\r\n        priceFactor = _priceFactor;\r\n        stage = Stages.AuctionDeployed;\r\n    }\r\n\r\n    /// @dev Setup function sets external contracts' addresses.\r\n    /// @param _xrt Robonomics token address.\r\n    /// @param _ambix Distillation cube address.\r\n    function setup(address _xrt, address _ambix)\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionDeployed)\r\n    {\r\n        // Validate argument\r\n        require(_xrt != 0 && _ambix != 0);\r\n\r\n        xrt = XRT(_xrt);\r\n        ambix = _ambix;\r\n\r\n        // Validate token balance\r\n        require(xrt.balanceOf(this) == MAX_TOKENS_SOLD);\r\n\r\n        stage = Stages.AuctionSetUp;\r\n    }\r\n\r\n    /// @dev Starts auction and sets startBlock.\r\n    function startAuction()\r\n        public\r\n        isWallet\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        stage = Stages.AuctionStarted;\r\n        startBlock = block.number;\r\n    }\r\n\r\n    /// @dev Calculates current token price.\r\n    /// @return Returns token price.\r\n    function calcCurrentTokenPrice()\r\n        public\r\n        timedTransitions\r\n        returns (uint)\r\n    {\r\n        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)\r\n            return finalPrice;\r\n        return calcTokenPrice();\r\n    }\r\n\r\n    /// @dev Returns correct stage, even if a function with timedTransitions modifier has not yet been called yet.\r\n    /// @return Returns current auction stage.\r\n    function updateStage()\r\n        public\r\n        timedTransitions\r\n        returns (Stages)\r\n    {\r\n        return stage;\r\n    }\r\n\r\n    /// @dev Allows to send a bid to the auction.\r\n    /// @param receiver Bid will be assigned to this address if set.\r\n    function bid(address receiver)\r\n        public\r\n        payable\r\n        isValidPayload\r\n        timedTransitions\r\n        atStage(Stages.AuctionStarted)\r\n        returns (uint amount)\r\n    {\r\n        require(msg.value > 0);\r\n        amount = msg.value;\r\n\r\n        // If a bid is done on behalf of a user via ShapeShift, the receiver address is set.\r\n        if (receiver == 0)\r\n            receiver = msg.sender;\r\n\r\n        // Prevent that more than 90% of tokens are sold. Only relevant if cap not reached.\r\n        uint maxWei = MAX_TOKENS_SOLD * calcTokenPrice() / 10**9 - totalReceived;\r\n        uint maxWeiBasedOnTotalReceived = ceiling - totalReceived;\r\n        if (maxWeiBasedOnTotalReceived < maxWei)\r\n            maxWei = maxWeiBasedOnTotalReceived;\r\n\r\n        // Only invest maximum possible amount.\r\n        if (amount > maxWei) {\r\n            amount = maxWei;\r\n            // Send change back to receiver address. In case of a ShapeShift bid the user receives the change back directly.\r\n            receiver.transfer(msg.value - amount);\r\n        }\r\n\r\n        // Forward funding to ether wallet\r\n        wallet.transfer(amount);\r\n\r\n        bids[receiver] += amount;\r\n        totalReceived += amount;\r\n        emit BidSubmission(receiver, amount);\r\n\r\n        // Finalize auction when maxWei reached\r\n        if (amount == maxWei)\r\n            finalizeAuction();\r\n    }\r\n\r\n    /// @dev Claims tokens for bidder after auction.\r\n    /// @param receiver Tokens will be assigned to this address if set.\r\n    function claimTokens(address receiver)\r\n        public\r\n        isValidPayload\r\n        timedTransitions\r\n        atStage(Stages.TradingStarted)\r\n    {\r\n        if (receiver == 0)\r\n            receiver = msg.sender;\r\n        uint tokenCount = bids[receiver] * 10**9 / finalPrice;\r\n        bids[receiver] = 0;\r\n        require(xrt.transfer(receiver, tokenCount));\r\n    }\r\n\r\n    /// @dev Calculates stop price.\r\n    /// @return Returns stop price.\r\n    function calcStopPrice()\r\n        view\r\n        public\r\n        returns (uint)\r\n    {\r\n        return totalReceived * 10**9 / MAX_TOKENS_SOLD + 1;\r\n    }\r\n\r\n    /// @dev Calculates token price.\r\n    /// @return Returns token price.\r\n    function calcTokenPrice()\r\n        view\r\n        public\r\n        returns (uint)\r\n    {\r\n        return priceFactor * 10**18 / (block.number - startBlock + 7500) + 1;\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n    function finalizeAuction()\r\n        private\r\n    {\r\n        stage = Stages.AuctionEnded;\r\n        finalPrice = totalReceived == ceiling ? calcTokenPrice() : calcStopPrice();\r\n        uint soldTokens = totalReceived * 10**9 / finalPrice;\r\n\r\n        if (totalReceived == ceiling) {\r\n            // Auction contract transfers all unsold tokens to Ambix contract\r\n            require(xrt.transfer(ambix, MAX_TOKENS_SOLD - soldTokens));\r\n        } else {\r\n            // Auction contract burn all unsold tokens\r\n            xrt.burn(MAX_TOKENS_SOLD - soldTokens);\r\n        }\r\n\r\n        endTime = now;\r\n    }\r\n}\r\n\r\n// File: contracts/robonomics/LighthouseAPI.sol\r\n\r\n//import './LiabilityFactory.sol';\r\n\r\n\r\ncontract LighthouseAPI {\r\n    address[] public members;\r\n\r\n    function membersLength() public view returns (uint256)\r\n    { return members.length; }\r\n\r\n    mapping(address => uint256) indexOf;\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    uint256 public minimalFreeze;\r\n    uint256 public timeoutBlocks;\r\n\r\n    LiabilityFactory public factory;\r\n    XRT              public xrt;\r\n\r\n    uint256 public keepaliveBlock = 0;\r\n    uint256 public marker = 0;\r\n    uint256 public quota = 0;\r\n\r\n    function quotaOf(address _member) public view returns (uint256)\r\n    { return balances[_member] / minimalFreeze; }\r\n}\r\n\r\n// File: contracts/robonomics/Lighthouse.sol\r\n\r\ncontract Lighthouse is LighthouseAPI, LightContract {\r\n    constructor(\r\n        address _lib,\r\n        uint256 _minimalFreeze,\r\n        uint256 _timeoutBlocks\r\n    ) \r\n        public\r\n        LightContract(_lib)\r\n    {\r\n        require(_minimalFreeze > 0 && _timeoutBlocks > 0);\r\n\r\n        minimalFreeze = _minimalFreeze;\r\n        timeoutBlocks = _timeoutBlocks;\r\n        factory = LiabilityFactory(msg.sender);\r\n        xrt = factory.xrt();\r\n    }\r\n}\r\n\r\n// File: ens/contracts/AbstractENS.sol\r\n\r\ncontract AbstractENS {\r\n    function owner(bytes32 node) constant returns(address);\r\n    function resolver(bytes32 node) constant returns(address);\r\n    function ttl(bytes32 node) constant returns(uint64);\r\n    function setOwner(bytes32 node, address owner);\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\r\n    function setResolver(bytes32 node, address resolver);\r\n    function setTTL(bytes32 node, uint64 ttl);\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n}\r\n\r\n// File: ens/contracts/ENS.sol\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENS is AbstractENS {\r\n    struct Record {\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping(bytes32=>Record) records;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier only_owner(bytes32 node) {\r\n        if(records[node].owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new ENS registrar.\r\n     */\r\n    function ENS() {\r\n        records[0].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Returns the address that owns the specified node.\r\n     */\r\n    function owner(bytes32 node) constant returns (address) {\r\n        return records[node].owner;\r\n    }\r\n\r\n    /**\r\n     * Returns the address of the resolver for the specified node.\r\n     */\r\n    function resolver(bytes32 node) constant returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * Returns the TTL of a node, and any records associated with it.\r\n     */\r\n    function ttl(bytes32 node) constant returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a node to a new address. May only be called by the current\r\n     * owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) only_owner(node) {\r\n        Transfer(node, owner);\r\n        records[node].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\r\n     * called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) {\r\n        var subnode = sha3(node, label);\r\n        NewOwner(node, label, owner);\r\n        records[subnode].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) only_owner(node) {\r\n        NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) only_owner(node) {\r\n        NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n}\r\n\r\n// File: ens/contracts/PublicResolver.sol\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver {\r\n    AbstractENS ens;\r\n    mapping(bytes32=>address) addresses;\r\n    mapping(bytes32=>bytes32) hashes;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        if(ens.owner(node) != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    function PublicResolver(AbstractENS ensAddr) {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Fallback function.\r\n     */\r\n    function() {\r\n        throw;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the specified node has the specified record type.\r\n     * @param node The ENS node to query.\r\n     * @param kind The record type name, as specified in EIP137.\r\n     * @return True if this resolver has a record of the provided type on the\r\n     *         provided node.\r\n     */\r\n    function has(bytes32 node, bytes32 kind) constant returns (bool) {\r\n        return (kind == \"addr\" && addresses[node] != 0) || (kind == \"hash\" && hashes[node] != 0);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) constant returns (bool) {\r\n        return interfaceID == 0x3b3b57de || interfaceID == 0xd8389dc5;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) constant returns (address ret) {\r\n        ret = addresses[node];\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) only_owner(node) {\r\n        addresses[node] = addr;\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) constant returns (bytes32 ret) {\r\n        ret = hashes[node];\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) only_owner(node) {\r\n        hashes[node] = hash;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    // safeApprove should only be called when setting an initial allowance, \r\n    // or when resetting it to zero. To increase and decrease it, use \r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (token.allowance(msg.sender, spender) == 0));\r\n    require(token.approve(spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n}\r\n\r\n// File: contracts/robonomics/LiabilityFactory.sol\r\n\r\ncontract LiabilityFactory is SingletonHash {\r\n    constructor(\r\n        address _robot_liability_lib,\r\n        address _lighthouse_lib,\r\n        DutchAuction _auction,\r\n        XRT _xrt,\r\n        ENS _ens\r\n    ) public {\r\n        robotLiabilityLib = _robot_liability_lib;\r\n        lighthouseLib = _lighthouse_lib;\r\n        auction = _auction;\r\n        xrt = _xrt;\r\n        ens = _ens;\r\n    }\r\n\r\n    using SafeERC20 for XRT;\r\n    using SafeERC20 for ERC20;\r\n\r\n    /**\r\n     * @dev New liability created \r\n     */\r\n    event NewLiability(address indexed liability);\r\n\r\n    /**\r\n     * @dev New lighthouse created\r\n     */\r\n    event NewLighthouse(address indexed lighthouse, string name);\r\n\r\n    /**\r\n     * @dev Robonomics dutch auction contract\r\n     */\r\n    DutchAuction public auction;\r\n\r\n    /**\r\n     * @dev Robonomics network protocol token\r\n     */\r\n    XRT public xrt;\r\n\r\n    /**\r\n     * @dev Ethereum name system\r\n     */\r\n    ENS public ens;\r\n\r\n    /**\r\n     * @dev Total GAS utilized by Robonomics network\r\n     */\r\n    uint256 public totalGasUtilizing = 0;\r\n\r\n    /**\r\n     * @dev GAS utilized by liability contracts\r\n     */\r\n    mapping(address => uint256) public gasUtilizing;\r\n\r\n    /**\r\n     * @dev The count of utilized gas for switch to next epoch \r\n     */\r\n    uint256 public constant gasEpoch = 347 * 10**10;\r\n\r\n    /**\r\n     * @dev SMMA filter with function: SMMA(i) = (SMMA(i-1)*(n-1) + PRICE(i)) / n\r\n     * @param _prePrice PRICE[n-1]\r\n     * @param _price PRICE[n]\r\n     * @return filtered price\r\n     */\r\n    function smma(uint256 _prePrice, uint256 _price) internal returns (uint256) {\r\n        return (_prePrice * (smmaPeriod - 1) + _price) / smmaPeriod;\r\n    }\r\n\r\n    /**\r\n     * @dev SMMA filter period\r\n     */\r\n    uint256 public constant smmaPeriod = 100;\r\n\r\n    /**\r\n     * @dev Current gas price in wei\r\n     */\r\n    uint256 public gasPrice = 10 * 10**9;\r\n\r\n    /**\r\n     * @dev Lighthouse accounting\r\n     */\r\n    mapping(address => bool) public isLighthouse;\r\n\r\n    /**\r\n     * @dev Robot liability shared code smart contract\r\n     */\r\n    address public robotLiabilityLib;\r\n\r\n    /**\r\n     * @dev Lightouse shared code smart contract\r\n     */\r\n    address public lighthouseLib;\r\n\r\n    /**\r\n     * @dev XRT emission value for utilized gas\r\n     */\r\n    function wnFromGas(uint256 _gas) view returns (uint256) {\r\n        // Just return wn=gas when auction isn't finish\r\n        if (auction.finalPrice() == 0)\r\n            return _gas;\r\n\r\n        // Current gas utilization epoch\r\n        uint256 epoch = totalGasUtilizing / gasEpoch;\r\n\r\n        // XRT emission with addition coefficient by gas utilzation epoch\r\n        uint256 wn = _gas * 10**9 * gasPrice * 2**epoch / 3**epoch / auction.finalPrice();\r\n\r\n        // Check to not permit emission decrease below wn=gas\r\n        return wn < _gas ? _gas : wn;\r\n    }\r\n\r\n    /**\r\n     * @dev Only lighthouse guard\r\n     */\r\n    modifier onlyLighthouse {\r\n        require(isLighthouse[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier gasPriceEstimated {\r\n        gasPrice = smma(gasPrice, tx.gasprice);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Create robot liability smart contract\r\n     * @param _demand ABI-encoded demand message \r\n     * @param _offer ABI-encoded offer message \r\n     */\r\n    function createLiability(\r\n        bytes _demand,\r\n        bytes _offer\r\n    )\r\n        external \r\n        onlyLighthouse\r\n        gasPriceEstimated\r\n        returns (RobotLiability liability) { // Store in memory available gas\r\n        uint256 gasinit = gasleft();\r\n\r\n        // Create liability\r\n        liability = new RobotLiability(robotLiabilityLib);\r\n        emit NewLiability(liability);\r\n\r\n        // Parse messages\r\n        require(liability.call(abi.encodePacked(bytes4(0xd9ff764a), _demand))); // liability.demand(...)\r\n        singletonHash(liability.demandHash());\r\n\r\n        require(liability.call(abi.encodePacked(bytes4(0xd5056962), _offer))); // liability.offer(...)\r\n        singletonHash(liability.offerHash());\r\n\r\n        // Transfer lighthouse fee to lighthouse worker directly\r\n        if (liability.lighthouseFee() > 0)\r\n            xrt.safeTransferFrom(liability.promisor(),\r\n                                 tx.origin,\r\n                                 liability.lighthouseFee());\r\n\r\n        // Transfer liability security and hold on contract\r\n        ERC20 token = liability.token();\r\n        if (liability.cost() > 0)\r\n            token.safeTransferFrom(liability.promisee(),\r\n                                   liability,\r\n                                   liability.cost());\r\n\r\n        // Transfer validator fee and hold on contract\r\n        if (address(liability.validator()) != 0 && liability.validatorFee() > 0)\r\n            xrt.safeTransferFrom(liability.promisee(),\r\n                                 liability,\r\n                                 liability.validatorFee());\r\n\r\n        // Accounting gas usage of transaction\r\n        uint256 gas = gasinit - gasleft() + 110525; // Including observation error\r\n        totalGasUtilizing       += gas;\r\n        gasUtilizing[liability] += gas;\r\n     }\r\n\r\n    /**\r\n     * @dev Create lighthouse smart contract\r\n     * @param _minimalFreeze Minimal freeze value of XRT token\r\n     * @param _timeoutBlocks Max time of lighthouse silence in blocks\r\n     * @param _name Lighthouse subdomain,\r\n     *              example: for 'my-name' will created 'my-name.lighthouse.1.robonomics.eth' domain\r\n     */\r\n    function createLighthouse(\r\n        uint256 _minimalFreeze,\r\n        uint256 _timeoutBlocks,\r\n        string  _name\r\n    )\r\n        external\r\n        returns (address lighthouse)\r\n    {\r\n        bytes32 lighthouseNode\r\n            // lighthouse.3.robonomics.eth\r\n            = 0x87bd923a85f096b00a4a347fb56cef68e95319b3d9dae1dff59259db094afd02;\r\n\r\n        // Name reservation check\r\n        bytes32 subnode = keccak256(abi.encodePacked(lighthouseNode, keccak256(_name)));\r\n        require(ens.resolver(subnode) == 0);\r\n\r\n        // Create lighthouse\r\n        lighthouse = new Lighthouse(lighthouseLib, _minimalFreeze, _timeoutBlocks);\r\n        emit NewLighthouse(lighthouse, _name);\r\n        isLighthouse[lighthouse] = true;\r\n\r\n        // Register subnode\r\n        ens.setSubnodeOwner(lighthouseNode, keccak256(_name), this);\r\n\r\n        // Register lighthouse address\r\n        PublicResolver resolver = PublicResolver(ens.resolver(lighthouseNode));\r\n        ens.setResolver(subnode, resolver);\r\n        resolver.setAddr(subnode, lighthouse);\r\n    }\r\n\r\n    /**\r\n     * @dev Is called whan after liability finalization\r\n     * @param _gas Liability finalization gas expenses\r\n     */\r\n    function liabilityFinalized(\r\n        uint256 _gas\r\n    )\r\n        external\r\n        gasPriceEstimated\r\n        returns (bool)\r\n    {\r\n        require(gasUtilizing[msg.sender] > 0);\r\n\r\n        uint256 gas = _gas - gasleft();\r\n        require(_gas > gas);\r\n\r\n        totalGasUtilizing        += gas;\r\n        gasUtilizing[msg.sender] += gas;\r\n\r\n        require(xrt.mint(tx.origin, wnFromGas(gasUtilizing[msg.sender])));\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"robotLiabilityLib\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xrt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimalFreeze\",\"type\":\"uint256\"},{\"name\":\"_timeoutBlocks\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createLighthouse\",\"outputs\":[{\"name\":\"lighthouse\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gasUtilizing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smmaPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLighthouse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGasUtilizing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"liabilityFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_demand\",\"type\":\"bytes\"},{\"name\":\"_offer\",\"type\":\"bytes\"}],\"name\":\"createLiability\",\"outputs\":[{\"name\":\"liability\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"wnFromGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lighthouseLib\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isHashConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_robot_liability_lib\",\"type\":\"address\"},{\"name\":\"_lighthouse_lib\",\"type\":\"address\"},{\"name\":\"_auction\",\"type\":\"address\"},{\"name\":\"_xrt\",\"type\":\"address\"},{\"name\":\"_ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"liability\",\"type\":\"address\"}],\"name\":\"NewLiability\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lighthouse\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewLighthouse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"HashConsumed\",\"type\":\"event\"}]","ContractName":"LiabilityFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000002b133a8daa10f1ce6e3a75dc93959c0cfbc7bc200000000000000000000000039420eb0d79f4a3d72682c986aad28cc37268c2600000000000000000000000047953cd1f4bdd5a30589ae8fa6628456ad6fe0d500000000000000000000000098dfc5247da729c045d4938babd081a61a455776000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b","Library":"","SwarmSource":"bzzr://9de73599600476528b458c71fb054eaa04655539e81065d61209ede643b06d93"}]}