{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC20Interface {\r\n    function name() public view returns(bytes32);\r\n    function symbol() public view returns(bytes32);\r\n    function balanceOf (address _owner) public view returns(uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n\r\ncontract AppCoins is ERC20Interface{\r\n    // Public variables of the token\r\n    address public owner;\r\n    bytes32 private token_name;\r\n    bytes32 private token_symbol;\r\n    uint8 public decimals = 18;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    function AppCoins() public {\r\n        owner = msg.sender;\r\n        token_name = \"AppCoins\";\r\n        token_symbol = \"APPC\";\r\n        uint256 _totalSupply = 1000000;\r\n        totalSupply = _totalSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        balances[owner] = totalSupply;                // Give the creator all initial tokens\r\n    }\r\n\r\n    function name() public view returns(bytes32) {\r\n        return token_name;\r\n    }\r\n\r\n    function symbol() public view returns(bytes32) {\r\n        return token_symbol;\r\n    }\r\n\r\n    function balanceOf (address _owner) public view returns(uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[_from] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        // Subtract from the sender\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balances[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer (address _to, uint256 _amount) public returns (bool success) {\r\n        if( balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            emit Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return allowance[_from][msg.sender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract AppCoinsTimelock {\r\n\r\n    // AppCoins token\r\n    AppCoins private appc;\r\n\r\n    // beneficiary of tokens\r\n    mapping (address => uint) balances;\r\n\r\n    // timestamp when token release is enabled\r\n    uint private releaseTime;\r\n\r\n    event NewFundsAllocated(address _address,  uint _amount);\r\n    event FundsReleased(address _address,  uint _amount);\r\n\r\n    constructor(\r\n        address _addrAppc,\r\n        uint256 _releaseTime\r\n    )\r\n    public\r\n    {\r\n        appc = AppCoins(_addrAppc);\r\n        releaseTime = _releaseTime;\r\n    }\r\n\r\n    function getReleaseTime() public view returns(uint256) {\r\n        return releaseTime;\r\n    }\r\n\r\n\r\n    function getBalanceOf(address _address) public view returns(uint256){\r\n        return balances[_address];\r\n    }\r\n\r\n \r\n    function allocateFunds(address _address, uint256 _amount) public {\r\n        require(appc.allowance(msg.sender, address(this)) >= _amount);\r\n        appc.transferFrom(msg.sender, address(this), _amount);\r\n        balances[_address] = balances[_address] + _amount;\r\n        emit NewFundsAllocated(_address, balances[_address]);\r\n    }\r\n\r\n    function allocateFundsBulk(address[] _addresses, uint256[] _amounts) public {\r\n        require(_addresses.length == _amounts.length);\r\n        for(uint i = 0; i < _addresses.length; i++){\r\n            allocateFunds(_addresses[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    function release(address _address) public {\r\n        require(balances[_address] > 0);\r\n        uint nowInMilliseconds = block.timestamp * 1000;\r\n        require(nowInMilliseconds >= releaseTime);\r\n        uint amount = balances[_address];\r\n        balances[_address] = 0;\r\n        appc.transfer(_address, amount);\r\n        emit FundsReleased(_address, amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allocateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReleaseTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"allocateFundsBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addrAppc\",\"type\":\"address\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"NewFundsAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundsReleased\",\"type\":\"event\"}]","ContractName":"AppCoinsTimelock","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001a7a8bd9106f2b8d977e08582dc7d24c723ab0db0000000000000000000000000000000000000000000000000000016d849dd800","Library":"","SwarmSource":"bzzr://f6dbeeb80ddc857a6c0409f3f2163881c1d342d116efe420633552c92a7496b7"}]}