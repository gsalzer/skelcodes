{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/// @dev Interface required by league roster contract to access\r\n/// the mintPlayers(...) function\r\ninterface CSportsRosterInterface {\r\n\r\n    /// @dev Called by core contract as a sanity check\r\n    function isLeagueRosterContract() external pure returns (bool);\r\n\r\n    /// @dev Called to indicate that a commissioner auction has completed\r\n    function commissionerAuctionComplete(uint32 _rosterIndex, uint128 _price) external;\r\n\r\n    /// @dev Called to indicate that a commissioner auction was canceled\r\n    function commissionerAuctionCancelled(uint32 _rosterIndex) external view;\r\n\r\n    /// @dev Returns the metadata for a specific real world player token\r\n    function getMetadata(uint128 _md5Token) external view returns (string);\r\n\r\n    /// @dev Called to return a roster index given the MD5\r\n    function getRealWorldPlayerRosterIndex(uint128 _md5Token) external view returns (uint128);\r\n\r\n    /// @dev Returns a player structure given its index\r\n    function realWorldPlayerFromIndex(uint128 idx) external view returns (uint128 md5Token, uint128 prevCommissionerSalePrice, uint64 lastMintedTime, uint32 mintedCount, bool hasActiveCommissionerAuction, bool mintingEnabled);\r\n\r\n    /// @dev Called to update a real world player entry - only used dureing development\r\n    function updateRealWorldPlayer(uint32 _rosterIndex, uint128 _prevCommissionerSalePrice, uint64 _lastMintedTime, uint32 _mintedCount, bool _hasActiveCommissionerAuction, bool _mintingEnabled) external;\r\n\r\n}\r\n\r\n/// @title A facet of CSportsCore that holds all important constants and modifiers\r\n/// @author CryptoSports, Inc. (https://cryptosports.team))\r\n/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\r\ncontract CSportsConstants {\r\n\r\n    /// @dev The maximum # of marketing tokens that can ever be created\r\n    /// by the commissioner.\r\n    uint16 public MAX_MARKETING_TOKENS = 2500;\r\n\r\n    /// @dev The starting price for commissioner auctions (if the average\r\n    ///   of the last 2 is less than this, we will use this value)\r\n    ///   A finney is 1/1000 of an ether.\r\n    uint256 public COMMISSIONER_AUCTION_FLOOR_PRICE = 5 finney; // 5 finney for production, 15 for script testing and 1 finney for Rinkeby\r\n\r\n    /// @dev The duration of commissioner auctions\r\n    uint256 public COMMISSIONER_AUCTION_DURATION = 14 days; // 30 days for testing;\r\n\r\n    /// @dev Number of seconds in a week\r\n    uint32 constant WEEK_SECS = 1 weeks;\r\n\r\n}\r\n\r\n/// @title A facet of CSportsCore that manages an individual's authorized role against access privileges.\r\n/// @author CryptoSports, Inc. (https://cryptosports.team))\r\n/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\r\ncontract CSportsAuth is CSportsConstants {\r\n    // This facet controls access control for CryptoSports. There are four roles managed here:\r\n    //\r\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\r\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\r\n    //         set to the address that created the smart contract in the CSportsCore constructor.\r\n    //\r\n    //     - The CFO: The CFO can withdraw funds from CSportsCore and its auction contracts.\r\n    //\r\n    //     - The COO: The COO can perform administrative functions.\r\n    //\r\n    //     - The Commisioner can perform \"oracle\" functions like adding new real world players,\r\n    //       setting players active/inactive, and scoring contests.\r\n    //\r\n\r\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\r\n    event ContractUpgrade(address newContract);\r\n\r\n    /// The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n    address public commissionerAddress;\r\n\r\n    /// @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Flag that identifies whether or not we are in development and should allow development\r\n    /// only functions to be called.\r\n    bool public isDevelopment = true;\r\n\r\n    /// @dev Access modifier to allow access to development mode functions\r\n    modifier onlyUnderDevelopment() {\r\n      require(isDevelopment == true);\r\n      _;\r\n    }\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for Commissioner-only functionality\r\n    modifier onlyCommissioner() {\r\n        require(msg.sender == commissionerAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Requires any one of the C level addresses\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress ||\r\n            msg.sender == commissionerAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev prevents contracts from hitting the method\r\n    modifier notContract() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev One way switch to set the contract into prodution mode. This is one\r\n    /// way in that the contract can never be set back into development mode. Calling\r\n    /// this function will block all future calls to functions that are meant for\r\n    /// access only while we are under development. It will also enable more strict\r\n    /// additional checking on various parameters and settings.\r\n    function setProduction() public onlyCEO onlyUnderDevelopment {\r\n      isDevelopment = false;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) public onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address _newCFO) public onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) public onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Commissioner. Only available to the current CEO.\r\n    /// @param _newCommissioner The address of the new COO\r\n    function setCommissioner(address _newCommissioner) public onlyCEO {\r\n        require(_newCommissioner != address(0));\r\n\r\n        commissionerAddress = _newCommissioner;\r\n    }\r\n\r\n    /// @dev Assigns all C-Level addresses\r\n    /// @param _ceo CEO address\r\n    /// @param _cfo CFO address\r\n    /// @param _coo COO address\r\n    /// @param _commish Commissioner address\r\n    function setCLevelAddresses(address _ceo, address _cfo, address _coo, address _commish) public onlyCEO {\r\n        require(_ceo != address(0));\r\n        require(_cfo != address(0));\r\n        require(_coo != address(0));\r\n        require(_commish != address(0));\r\n        ceoAddress = _ceo;\r\n        cfoAddress = _cfo;\r\n        cooAddress = _coo;\r\n        commissionerAddress = _commish;\r\n    }\r\n\r\n    /// @dev Transfers the balance of this contract to the CFO\r\n    function withdrawBalance() external onlyCFO {\r\n        cfoAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() public onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n/// @title CSportsTeam Interface\r\n/// @dev This interface defines methods required by the CSportsContestCore\r\n///   in implementing a contest.\r\n/// @author CryptoSports\r\ncontract CSportsTeam {\r\n\r\n    bool public isTeamContract;\r\n\r\n    /// @dev Define team events\r\n    event TeamCreated(uint256 teamId, address owner);\r\n    event TeamUpdated(uint256 teamId);\r\n    event TeamReleased(uint256 teamId);\r\n    event TeamScored(uint256 teamId, int32 score, uint32 place);\r\n    event TeamPaid(uint256 teamId);\r\n\r\n    function setCoreContractAddress(address _address) public;\r\n    function setLeagueRosterContractAddress(address _address) public;\r\n    function setContestContractAddress(address _address) public;\r\n    function createTeam(address _owner, uint32[] _tokenIds) public returns (uint32);\r\n    function updateTeam(address _owner, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public;\r\n    function releaseTeam(uint32 _teamId) public;\r\n    function getTeamOwner(uint32 _teamId) public view returns (address);\r\n    function scoreTeams(uint32[] _teamIds, int32[] _scores, uint32[] _places) public;\r\n    function getScore(uint32 _teamId) public view returns (int32);\r\n    function getPlace(uint32 _teamId) public view returns (uint32);\r\n    function ownsPlayerTokens(uint32 _teamId) public view returns (bool);\r\n    function refunded(uint32 _teamId) public;\r\n    function tokenIdsForTeam(uint32 _teamId) public view returns (uint32, uint32[50]);\r\n    function getTeam(uint32 _teamId) public view returns (\r\n        address _owner,\r\n        int32 _score,\r\n        uint32 _place,\r\n        bool _holdsEntryFee,\r\n        bool _ownsPlayerTokens);\r\n}\r\n\r\n/// @title CSportsContestBase base class for contests and teams contracts\r\n/// @dev This interface defines base class for contests and teams contracts\r\n/// @author CryptoSports\r\ncontract CSportsContestBase {\r\n\r\n    /// @dev Structure holding the player token IDs for a team\r\n    struct Team {\r\n      address owner;              // Address of the owner of the player tokens\r\n      int32 score;                // Score assigned to this team after a contest\r\n      uint32 place;               // Place this team finished in its contest\r\n      bool holdsEntryFee;         // TRUE if this team currently holds an entry fee\r\n      bool ownsPlayerTokens;      // True if the tokens are being escrowed by the Team contract\r\n      uint32[] playerTokenIds;    // IDs of the tokens held by this team\r\n    }\r\n\r\n}\r\n\r\n/// @dev Interface required by league roster contract to access\r\n/// the mintPlayers(...) function\r\ninterface CSportsCoreInterface {\r\n\r\n    /// @dev Called as a sanity check to make sure we have linked the core contract\r\n    function isCoreContract() external pure returns (bool);\r\n\r\n    /// @dev Escrows all of the tokensIds passed by transfering ownership\r\n    ///   to the teamContract. CAN ONLY BE CALLED BY THE CURRENT TEAM CONTRACT.\r\n    /// @param _owner - Current owner of the token being authorized for transfer\r\n    /// @param _tokenIds The IDs of the PlayerTokens that can be transferred if this call succeeds.\r\n    function batchEscrowToTeamContract(address _owner, uint32[] _tokenIds) external;\r\n\r\n    /// @dev Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _to The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n}\r\n/// @title Generic CSports Team Contract\r\n/// @dev Implementation of interface CSportsTeam for a generic team contract\r\n/// that supports a variable # players per team (set in constructor)\r\ncontract CSportsTeamGeneric is CSportsAuth, CSportsTeam,  CSportsContestBase {\r\n\r\n  /// STORAGE\r\n\r\n  /// @dev Reference to core contract ownership of player tokens\r\n  CSportsCoreInterface public coreContract;\r\n\r\n  /// @dev Reference to contest contract ownership of player tokens\r\n  address public contestContractAddress;\r\n\r\n  /// @dev Instance of our CSportsLeagueRoster contract. Can be set by\r\n  ///   the CEO.\r\n  CSportsRosterInterface public leagueRosterContract;\r\n\r\n  // Next team ID to assign\r\n  uint64 uniqueTeamId;\r\n\r\n  // Number of players on a team\r\n  uint32 playersPerTeam;\r\n\r\n  /// @dev Structure to hold our active teams\r\n  mapping (uint32 => Team) teamIdToTeam;\r\n\r\n  /// PUBLIC METHODS\r\n\r\n  /// @dev Class constructor creates the main CSportsTeamMlb smart contract instance.\r\n  constructor(uint32 _playersPerTeam) public {\r\n\r\n      // All C-level roles are the message sender\r\n      ceoAddress = msg.sender;\r\n      cfoAddress = msg.sender;\r\n      cooAddress = msg.sender;\r\n      commissionerAddress = msg.sender;\r\n\r\n      // Notice our uniqueTeamId starts at 1, making a 0 value indicate\r\n      // a non-existent team.\r\n      uniqueTeamId = 1;\r\n\r\n      // Initialize parent properties\r\n      isTeamContract = true;\r\n\r\n      // Players per team\r\n      playersPerTeam = _playersPerTeam;\r\n  }\r\n\r\n  /// @dev Sets the contestContractAddress that we interact with\r\n  /// @param _address - Address of our contest contract\r\n  function setContestContractAddress(address _address) public onlyCEO {\r\n    contestContractAddress = _address;\r\n  }\r\n\r\n  /// @dev Sets the coreContract that we interact with\r\n  /// @param _address - Address of our core contract\r\n  function setCoreContractAddress(address _address) public onlyCEO {\r\n    CSportsCoreInterface candidateContract = CSportsCoreInterface(_address);\r\n    require(candidateContract.isCoreContract());\r\n    coreContract = candidateContract;\r\n  }\r\n\r\n  /// @dev Sets the leagueRosterContract that we interact with\r\n  /// @param _address - The address of our league roster contract\r\n  function setLeagueRosterContractAddress(address _address) public onlyCEO {\r\n    CSportsRosterInterface candidateContract = CSportsRosterInterface(_address);\r\n    require(candidateContract.isLeagueRosterContract());\r\n    leagueRosterContract = candidateContract;\r\n  }\r\n\r\n  /// @dev Consolidates setting of contract links into a single call for deployment expediency\r\n  function setLeagueRosterAndCoreAndContestContractAddress(address _league, address _core, address _contest) public onlyCEO {\r\n    setLeagueRosterContractAddress(_league);\r\n    setCoreContractAddress(_core);\r\n    setContestContractAddress(_contest);\r\n  }\r\n\r\n  /// @dev Called to create a team for use in CSports.\r\n  ///   _escrow(...) Verifies that all of the tokens presented\r\n  ///   are owned by the sender, and transfers ownership to this contract. This\r\n  ///   assures that the PlayerTokens cannot be sold in an auction, or entered\r\n  ///   into a different contest. CALLED ONLY BY CONTEST CONTRACT\r\n  ///\r\n  ///   Also note that the size of the _tokenIds array passed must be 10. This is\r\n  ///   particular to the kind of contest we are running (10 players fielded).\r\n  /// @param _owner - Owner of the team, must own all of the player tokens being\r\n  ///   associated with the team.\r\n  /// @param _tokenIds - Player token IDs to associate with the team, must be owned\r\n  ///   by _owner and will be held in escrow unless released through an update\r\n  ///   or the team is destroyed.\r\n  function createTeam(address _owner, uint32[] _tokenIds) public returns (uint32) {\r\n    require(msg.sender == contestContractAddress);\r\n    require(_tokenIds.length == playersPerTeam);\r\n\r\n    // Escrow the player tokens held by this team\r\n    // it will throw if _owner does not own any of the tokens or this CSportsTeam contract\r\n    // has not been set in the CSportsCore contract.\r\n    coreContract.batchEscrowToTeamContract(_owner, _tokenIds);\r\n\r\n    uint32 _teamId =  _createTeam(_owner, _tokenIds);\r\n\r\n    emit TeamCreated(_teamId, _owner);\r\n\r\n    return _teamId;\r\n  }\r\n\r\n  /// @dev Upates the player tokens held by a specific team. Throws if the\r\n  ///   message sender does not own the team, or if the team does not\r\n  ///   exist. CALLED ONLY BY CONTEST CONTRACT\r\n  /// @param _owner - Owner of the team\r\n  /// @param _teamId - ID of the team we wish to update\r\n  /// @param _indices - Indices of playerTokens to be replaced\r\n  /// @param _tokenIds - Array of player token IDs that will replace those\r\n  ///   currently held at the indices specified.\r\n  function updateTeam(address _owner, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public {\r\n    require(msg.sender == contestContractAddress);\r\n    require(_owner != address(0));\r\n    require(_tokenIds.length <= playersPerTeam);\r\n    require(_indices.length <= playersPerTeam);\r\n    require(_indices.length == _tokenIds.length);\r\n\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_owner == _team.owner);\r\n\r\n    // Escrow the player tokens that will replace those in the team currently -\r\n    // it will throw if _owner does not own any of the tokens or this CSportsTeam contract\r\n    // has not been set in the CSportsCore contract.\r\n    coreContract.batchEscrowToTeamContract(_owner, _tokenIds);\r\n\r\n    // Loop through the indices we are updating, and make the update\r\n    for (uint8 i = 0; i < _indices.length; i++) {\r\n      require(_indices[i] <= playersPerTeam);\r\n\r\n      uint256 _oldTokenId = uint256(_team.playerTokenIds[_indices[i]]);\r\n      uint256 _newTokenId = _tokenIds[i];\r\n\r\n      // Release the _oldToken back to its original owner.\r\n      // (note _owner == _team.owner == original owner of token we are returning)\r\n      coreContract.approve(_owner, _oldTokenId);\r\n      coreContract.transferFrom(address(this), _owner, _oldTokenId);\r\n\r\n      // Update the token ID in the team at the same index as the player token removed.\r\n      _team.playerTokenIds[_indices[i]] = uint32(_newTokenId);\r\n\r\n    }\r\n\r\n    emit TeamUpdated(_teamId);\r\n  }\r\n\r\n  /// @dev Releases the team by returning all of the tokens held by the team and removing\r\n  ///   the team from our mapping. CALLED ONLY BY CONTEST CONTRACT\r\n  /// @param _teamId - team id of the team being destroyed\r\n  function releaseTeam(uint32 _teamId) public {\r\n\r\n    require(msg.sender == contestContractAddress);\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_team.owner != address(0));\r\n\r\n    if (_team.ownsPlayerTokens) {\r\n      // Loop through all of the player tokens held by the team, and\r\n      // release them back to the original owner.\r\n      for (uint32 i = 0; i < _team.playerTokenIds.length; i++) {\r\n        uint32 _tokenId = _team.playerTokenIds[i];\r\n        coreContract.approve(_team.owner, _tokenId);\r\n        coreContract.transferFrom(address(this), _team.owner, _tokenId);\r\n      }\r\n\r\n      // This team's player tokens are no longer held in escrow\r\n      _team.ownsPlayerTokens = false;\r\n\r\n      emit TeamReleased(_teamId);\r\n    }\r\n\r\n  }\r\n\r\n  /// @dev Marks the team as having its entry fee refunded\r\n  ///   CALLED ONLY BY CONTEST CONTRACT\r\n  /// @param _teamId - ID of team to refund entry fee.\r\n  function refunded(uint32 _teamId) public {\r\n    require(msg.sender == contestContractAddress);\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_team.owner != address(0));\r\n    _team.holdsEntryFee = false;\r\n  }\r\n\r\n  /// @dev Assigns a score and place for an array of teams. The indexes into the\r\n  ///   arrays are what tie a particular teamId to score and place.\r\n  ///   CALLED ONLY BY CONTEST CONTRACT\r\n  /// @param _teamIds - IDs of the teams we are scoring\r\n  /// @param _scores - Scores to assign\r\n  /// @param _places - Places to assign\r\n  function scoreTeams(uint32[] _teamIds, int32[] _scores, uint32[] _places) public {\r\n\r\n    require(msg.sender == contestContractAddress);\r\n    require ((_teamIds.length == _scores.length) && (_teamIds.length == _places.length)) ;\r\n    for (uint i = 0; i < _teamIds.length; i++) {\r\n      Team storage _team = teamIdToTeam[_teamIds[i]];\r\n      if (_team.owner != address(0)) {\r\n        _team.score = _scores[i];\r\n        _team.place = _places[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the score assigned to a particular team.\r\n  /// @param _teamId ID of the team we are inquiring about\r\n  function getScore(uint32 _teamId) public view returns (int32) {\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_team.owner != address(0));\r\n    return _team.score;\r\n  }\r\n\r\n  /// @dev Returns the place assigned to a particular team.\r\n  /// @param _teamId ID of the team we are inquiring about\r\n  function getPlace(uint32 _teamId) public view returns (uint32) {\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_team.owner != address(0));\r\n    return _team.place;\r\n  }\r\n\r\n  /// @dev Returns whether or not this team owns the player tokens it\r\n  ///   references in the playerTokenIds property.\r\n  /// @param _teamId ID of the team we are inquiring about\r\n  function ownsPlayerTokens(uint32 _teamId) public view returns (bool) {\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_team.owner != address(0));\r\n    return _team.ownsPlayerTokens;\r\n  }\r\n\r\n  /// @dev Returns the owner of a specific team\r\n  /// @param _teamId - ID of team we are inquiring about\r\n  function getTeamOwner(uint32 _teamId) public view returns (address) {\r\n    Team storage _team = teamIdToTeam[_teamId];\r\n    require(_team.owner != address(0));\r\n    return _team.owner;\r\n  }\r\n\r\n  /// @dev Returns all of the token id held by a particular team. Throws if the\r\n  ///   _teamId isn't valid. Anybody can call this, making teams visible to the\r\n  ///   world.\r\n  /// @param _teamId - ID of the team we are looking to get player tokens for.\r\n  function tokenIdsForTeam(uint32 _teamId) public view returns (uint32 count, uint32[50]) {\r\n\r\n     /// @dev A fixed array we can return current auction price information in.\r\n     uint32[50] memory _tokenIds;\r\n\r\n     Team storage _team = teamIdToTeam[_teamId];\r\n     require(_team.owner != address(0));\r\n\r\n     for (uint32 i = 0; i < _team.playerTokenIds.length; i++) {\r\n       _tokenIds[i] = _team.playerTokenIds[i];\r\n     }\r\n\r\n     return (uint32(_team.playerTokenIds.length), _tokenIds);\r\n  }\r\n\r\n  /// @dev Returns the entire team structure (less the token IDs) for a specific team\r\n  /// @param _teamId - ID of team we are inquiring about\r\n  function getTeam(uint32 _teamId) public view returns (\r\n      address _owner,\r\n      int32 _score,\r\n      uint32 _place,\r\n      bool _holdsEntryFee,\r\n      bool _ownsPlayerTokens\r\n    ) {\r\n    Team storage t = teamIdToTeam[_teamId];\r\n    require(t.owner != address(0));\r\n    _owner = t.owner;\r\n    _score = t.score;\r\n    _place = t.place;\r\n    _holdsEntryFee = t.holdsEntryFee;\r\n    _ownsPlayerTokens = t.ownsPlayerTokens;\r\n  }\r\n\r\n  /// INTERNAL METHODS\r\n\r\n  /// @dev Internal function that creates a new team entry. We know that the\r\n  ///   size of the _tokenIds array is correct at this point (checked in calling method)\r\n  /// @param _owner - Account address of team owner (should own all _playerTokenIds)\r\n  /// @param _playerTokenIds - Token IDs of team players\r\n  function _createTeam(address _owner, uint32[] _playerTokenIds) internal returns (uint32) {\r\n\r\n    Team memory _team = Team({\r\n      owner: _owner,\r\n      score: 0,\r\n      place: 0,\r\n      holdsEntryFee: true,\r\n      ownsPlayerTokens: true,\r\n      playerTokenIds: _playerTokenIds\r\n    });\r\n\r\n    uint32 teamIdToReturn = uint32(uniqueTeamId);\r\n    teamIdToTeam[teamIdToReturn] = _team;\r\n\r\n    // Increment our team ID for the next one.\r\n    uniqueTeamId++;\r\n\r\n    // It's probably never going to happen, 4 billion teams is A LOT, but\r\n    // let's just be 100% sure we never let this happen because teamIds are\r\n    // often cast as uint32.\r\n    require(uniqueTeamId < 4294967295);\r\n\r\n    // We should do additional validation on the team here (like are the player\r\n    // positions correct, etc.)\r\n\r\n    return teamIdToReturn;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint32[]\"}],\"name\":\"createTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"releaseTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCoreContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDevelopment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamIds\",\"type\":\"uint32[]\"},{\"name\":\"_scores\",\"type\":\"int32[]\"},{\"name\":\"_places\",\"type\":\"uint32[]\"}],\"name\":\"scoreTeams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSIONER_AUCTION_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ceo\",\"type\":\"address\"},{\"name\":\"_cfo\",\"type\":\"address\"},{\"name\":\"_coo\",\"type\":\"address\"},{\"name\":\"_commish\",\"type\":\"address\"}],\"name\":\"setCLevelAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_league\",\"type\":\"address\"},{\"name\":\"_core\",\"type\":\"address\"},{\"name\":\"_contest\",\"type\":\"address\"}],\"name\":\"setLeagueRosterAndCoreAndContestContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLeagueRosterContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"tokenIdsForTeam\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32[50]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCommissioner\",\"type\":\"address\"}],\"name\":\"setCommissioner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MARKETING_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTeamContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"getScore\",\"outputs\":[{\"name\":\"\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"getTeam\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_score\",\"type\":\"int32\"},{\"name\":\"_place\",\"type\":\"uint32\"},{\"name\":\"_holdsEntryFee\",\"type\":\"bool\"},{\"name\":\"_ownsPlayerTokens\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"getPlace\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setContestContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"getTeamOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSIONER_AUCTION_FLOOR_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_teamId\",\"type\":\"uint32\"},{\"name\":\"_indices\",\"type\":\"uint8[]\"},{\"name\":\"_tokenIds\",\"type\":\"uint32[]\"}],\"name\":\"updateTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leagueRosterContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"refunded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setProduction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contestContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint32\"}],\"name\":\"ownsPlayerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_playersPerTeam\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"TeamCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"TeamUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"TeamReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"score\",\"type\":\"int32\"},{\"indexed\":false,\"name\":\"place\",\"type\":\"uint32\"}],\"name\":\"TeamScored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"TeamPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"CSportsTeamGeneric","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000003","Library":"","SwarmSource":"bzzr://a254c38acc0f55ae298b77b46345cb3c65790a7b47745167d87bc94b6f995239"}]}