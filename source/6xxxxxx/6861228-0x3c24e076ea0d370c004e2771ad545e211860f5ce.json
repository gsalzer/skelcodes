{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/MultiOwnable.sol\r\n\r\n/**\r\n * @title MultiOwnable.sol\r\n * @dev Provide multi-ownable functionality to a smart contract.\r\n * @dev Note this contract preserves the idea of a master owner where this owner\r\n * cannot be removed or deleted. Master owner's are the only owner's who can add\r\n * and remove other owner's. Transfer of master ownership is supported and can \r\n * also only be transferred by the current master owner\r\n * @dev When master ownership is transferred the original master owner is not\r\n * removed from the additional owners list\r\n */\r\npragma solidity 0.4.25;\r\n\r\n/**\r\n * @dev OpenZeppelin Solidity v2.0.0 imports (Using: npm openzeppelin-solidity@2.0.0)\r\n */\r\n\r\n\r\ncontract MultiOwnable is Ownable {\r\n\t/**\r\n\t * @dev Mapping of additional addresses that are considered owners\r\n\t */\r\n\tmapping (address => bool) additionalOwners;\r\n\r\n\t/**\r\n\t * @dev Modifier that overrides 'Ownable' to support multiple owners\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\t// Ensure that msg.sender is an owner or revert\r\n\t\trequire(isOwner(msg.sender), \"Permission denied [owner].\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier that provides additional testing to ensure msg.sender\r\n\t * is master owner, or first address to deploy contract\r\n\t */\r\n\tmodifier onlyMaster() {\r\n\t\t// Ensure that msg.sender is the master user\r\n\t\trequire(super.isOwner(), \"Permission denied [master].\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ownership added event for Dapps interested in this event\r\n\t */\r\n\tevent OwnershipAdded (\r\n\t\taddress indexed addedOwner\r\n\t);\r\n\t\r\n\t/**\r\n\t * @dev Ownership removed event for Dapps interested in this event\r\n\t */\r\n\tevent OwnershipRemoved (\r\n\t\taddress indexed removedOwner\r\n\t);\r\n\r\n  \t/**\r\n\t * @dev MultiOwnable .cTor responsible for initialising the masterOwner\r\n\t * or contract super-user\r\n\t * @dev The super user cannot be deleted from the ownership mapping and\r\n\t * can only be transferred\r\n\t */\r\n\tconstructor() \r\n\tOwnable()\r\n\tpublic\r\n\t{\r\n\t\t// Obtain owner of the contract (msg.sender)\r\n\t\taddress masterOwner = owner();\r\n\t\t// Add the master owner to the additional owners list\r\n\t\tadditionalOwners[masterOwner] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the owner status of the specified address\r\n\t */\r\n\tfunction isOwner(address _ownerAddressToLookup)\r\n\tpublic\r\n\tview\r\n\treturns (bool)\r\n\t{\r\n\t\t// Return the ownership state of the specified owner address\r\n\t\treturn additionalOwners[_ownerAddressToLookup];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the master status of the specfied address\r\n\t */\r\n\tfunction isMaster(address _masterAddressToLookup)\r\n\tpublic\r\n\tview\r\n\treturns (bool)\r\n\t{\r\n\t\treturn (super.owner() == _masterAddressToLookup);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add a new owner address to additional owners mapping\r\n\t * @dev Only the master owner can add additional owner addresses\r\n\t */\r\n\tfunction addOwner(address _ownerToAdd)\r\n\tonlyMaster\r\n\tpublic\r\n\treturns (bool)\r\n\t{\r\n\t\t// Ensure the new owner address is not address(0)\r\n\t\trequire(_ownerToAdd != address(0), \"Invalid address specified (0x0)\");\r\n\t\t// Ensure that new owner address is not already in the owners list\r\n\t\trequire(!isOwner(_ownerToAdd), \"Address specified already in owners list.\");\r\n\t\t// Add new owner to additional owners mapping\r\n\t\tadditionalOwners[_ownerToAdd] = true;\r\n\t\temit OwnershipAdded(_ownerToAdd);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add a new owner address to additional owners mapping\r\n\t * @dev Only the master owner can add additional owner addresses\r\n\t */\r\n\tfunction removeOwner(address _ownerToRemove)\r\n\tonlyMaster\r\n\tpublic\r\n\treturns (bool)\r\n\t{\r\n\t\t// Ensure that the address to remove is not the master owner\r\n\t\trequire(_ownerToRemove != super.owner(), \"Permission denied [master].\");\r\n\t\t// Ensure that owner address to remove is actually an owner\r\n\t\trequire(isOwner(_ownerToRemove), \"Address specified not found in owners list.\");\r\n\t\t// Add remove ownership from address in the additional owners mapping\r\n\t\tadditionalOwners[_ownerToRemove] = false;\r\n\t\temit OwnershipRemoved(_ownerToRemove);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of this contract to another address\r\n\t * @dev Only the master owner can transfer ownership to another address\r\n\t * @dev Only existing owners can have ownership transferred to them\r\n\t */\r\n\tfunction transferOwnership(address _newOwnership) \r\n\tonlyMaster \r\n\tpublic \r\n\t{\r\n\t\t// Ensure the new ownership is not address(0)\r\n\t\trequire(_newOwnership != address(0), \"Invalid address specified (0x0)\");\r\n\t\t// Ensure the new ownership address is not the current ownership addressess\r\n\t\trequire(_newOwnership != owner(), \"Address specified must not match current owner address.\");\t\t\r\n\t\t// Ensure that the new ownership is promoted from existing owners\r\n\t\trequire(isOwner(_newOwnership), \"Master ownership can only be transferred to an existing owner address.\");\r\n\t\t// Call into the parent class and transfer ownership\r\n\t\tsuper.transferOwnership(_newOwnership);\r\n\t\t// If we get here, then add the new ownership address to the additional owners mapping\r\n\t\t// Note that the original master owner address was not removed and is still an owner until removed\r\n\t\tadditionalOwners[_newOwnership] = true;\r\n\t}\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(!has(role, account));\r\n\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    require(has(role, account));\r\n\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\ncontract PauserRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event PauserAdded(address indexed account);\r\n  event PauserRemoved(address indexed account);\r\n\r\n  Roles.Role private pausers;\r\n\r\n  constructor() internal {\r\n    _addPauser(msg.sender);\r\n  }\r\n\r\n  modifier onlyPauser() {\r\n    require(isPauser(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isPauser(address account) public view returns (bool) {\r\n    return pausers.has(account);\r\n  }\r\n\r\n  function addPauser(address account) public onlyPauser {\r\n    _addPauser(account);\r\n  }\r\n\r\n  function renouncePauser() public {\r\n    _removePauser(msg.sender);\r\n  }\r\n\r\n  function _addPauser(address account) internal {\r\n    pausers.add(account);\r\n    emit PauserAdded(account);\r\n  }\r\n\r\n  function _removePauser(address account) internal {\r\n    pausers.remove(account);\r\n    emit PauserRemoved(account);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n  event Paused(address account);\r\n  event Unpaused(address account);\r\n\r\n  bool private _paused;\r\n\r\n  constructor() internal {\r\n    _paused = false;\r\n  }\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyPauser whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyPauser whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(msg.sender);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(value <= _allowed[from][msg.sender]);\r\n\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].sub(subtractedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(value <= _balances[from]);\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    require(value <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    require(value <= _allowed[account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    // safeApprove should only be called when setting an initial allowance, \r\n    // or when resetting it to zero. To increase and decrease it, use \r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (token.allowance(msg.sender, spender) == 0));\r\n    require(token.approve(spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor() internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale is ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  // The token being sold\r\n  IERC20 private _token;\r\n\r\n  // Address where funds are collected\r\n  address private _wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 private _rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 private _weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokensPurchased(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param rate Number of token units a buyer gets per wei\r\n   * @dev The rate is the conversion between wei and the smallest and indivisible\r\n   * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\r\n   * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\r\n   * @param wallet Address where collected funds will be forwarded to\r\n   * @param token Address of the token being sold\r\n   */\r\n  constructor(uint256 rate, address wallet, IERC20 token) internal {\r\n    require(rate > 0);\r\n    require(wallet != address(0));\r\n    require(token != address(0));\r\n\r\n    _rate = rate;\r\n    _wallet = wallet;\r\n    _token = token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   * Note that other contracts will transfer fund with a base gas stipend\r\n   * of 2300, which is not enough to call buyTokens. Consider calling\r\n   * buyTokens directly when purchasing tokens from a contract.\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @return the token being sold.\r\n   */\r\n  function token() public view returns(IERC20) {\r\n    return _token;\r\n  }\r\n\r\n  /**\r\n   * @return the address where funds are collected.\r\n   */\r\n  function wallet() public view returns(address) {\r\n    return _wallet;\r\n  }\r\n\r\n  /**\r\n   * @return the number of token units a buyer gets per wei.\r\n   */\r\n  function rate() public view returns(uint256) {\r\n    return _rate;\r\n  }\r\n\r\n  /**\r\n   * @return the amount of wei raised.\r\n   */\r\n  function weiRaised() public view returns (uint256) {\r\n    return _weiRaised;\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * This function has a non-reentrancy guard, so it shouldn't be called by\r\n   * another `nonReentrant` function.\r\n   * @param beneficiary Recipient of the token purchase\r\n   */\r\n  function buyTokens(address beneficiary) public nonReentrant payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    _weiRaised = _weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(beneficiary, tokens);\r\n    emit TokensPurchased(\r\n      msg.sender,\r\n      beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method:\r\n   *   super._preValidatePurchase(beneficiary, weiAmount);\r\n   *   require(weiRaised().add(weiAmount) <= cap);\r\n   * @param beneficiary Address performing the token purchase\r\n   * @param weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address beneficiary,\r\n    uint256 weiAmount\r\n  )\r\n    internal\r\n    view\r\n  {\r\n    require(beneficiary != address(0));\r\n    require(weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param beneficiary Address performing the token purchase\r\n   * @param weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address beneficiary,\r\n    uint256 weiAmount\r\n  )\r\n    internal\r\n    view\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param beneficiary Address performing the token purchase\r\n   * @param tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address beneficiary,\r\n    uint256 tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _token.safeTransfer(beneficiary, tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send tokens.\r\n   * @param beneficiary Address receiving the tokens\r\n   * @param tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address beneficiary,\r\n    uint256 tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(beneficiary, tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param beneficiary Address receiving the tokens\r\n   * @param weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address beneficiary,\r\n    uint256 weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return weiAmount.mul(_rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    _wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 private _openingTime;\r\n  uint256 private _closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    require(isOpen());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param openingTime Crowdsale opening time\r\n   * @param closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 openingTime, uint256 closingTime) internal {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(openingTime >= block.timestamp);\r\n    require(closingTime > openingTime);\r\n\r\n    _openingTime = openingTime;\r\n    _closingTime = closingTime;\r\n  }\r\n\r\n  /**\r\n   * @return the crowdsale opening time.\r\n   */\r\n  function openingTime() public view returns(uint256) {\r\n    return _openingTime;\r\n  }\r\n\r\n  /**\r\n   * @return the crowdsale closing time.\r\n   */\r\n  function closingTime() public view returns(uint256) {\r\n    return _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @return true if the crowdsale is open, false otherwise.\r\n   */\r\n  function isOpen() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param beneficiary Token purchaser\r\n   * @param weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address beneficiary,\r\n    uint256 weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n    view\r\n  {\r\n    super._preValidatePurchase(beneficiary, weiAmount);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/SparkleBaseCrowdsale.sol\r\n\r\n/**\r\n * @dev SparkelBaseCrowdsale: Core crowdsale functionality\r\n */\r\ncontract SparkleBaseCrowdsale is MultiOwnable, Pausable, TimedCrowdsale {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t * @dev CrowdsaleStage enumeration indicating which operational stage this contract is running\r\n\t */\r\n\tenum CrowdsaleStage { \r\n\t\tpreICO, \r\n\t\tbonusICO, \r\n\t\tmainICO\r\n\t}\r\n\r\n \t/**\r\n \t * @dev Internal contract variable stored\r\n \t */\r\n\tERC20   public tokenAddress;\r\n\tuint256 public tokenRate;\r\n\tuint256 public tokenCap;\r\n\tuint256 public startTime;\r\n\tuint256 public endTime;\r\n\taddress public depositWallet;\r\n\tbool    public kycRequired;\t\r\n\tbool\tpublic refundRemainingOk;\r\n\r\n\tuint256 public tokensSold;\r\n\r\n\t/**\r\n\t * @dev Contribution structure representing a token purchase \r\n\t */\r\n\tstruct OrderBook {\r\n\t\tuint256 weiAmount;   // Amount of Wei that has been contributed towards tokens by this address\r\n\t\tuint256 pendingTokens; // Total pending tokens held by this address waiting for KYC verification, and user to claim their tokens(pending restrictions)\r\n\t\tbool    kycVerified;   // Has this address been kyc validated\r\n\t}\r\n\r\n\t// Contributions mapping to user addresses\r\n\tmapping(address => OrderBook) private orders;\r\n\r\n\t// Initialize the crowdsale stage to preICO (this stage will change)\r\n\tCrowdsaleStage public crowdsaleStage = CrowdsaleStage.preICO;\r\n\r\n\t/**\r\n\t * @dev Event signaling that a number of addresses have been approved for KYC\r\n\t */\r\n\tevent ApprovedKYCAddresses (address indexed _appovedByAddress, uint256 _numberOfApprovals);\r\n\r\n\t/**\r\n\t * @dev Event signaling that a number of addresses have been revoked from KYC\r\n\t */\r\n\tevent RevokedKYCAddresses (address indexed _revokedByAddress, uint256 _numberOfRevokals);\r\n\r\n\t/**\r\n\t * @dev Event signalling that tokens have been claimed from the crowdsale\r\n\t */\r\n\tevent TokensClaimed (address indexed _claimingAddress, uint256 _tokensClaimed);\r\n\r\n\t/**\r\n\t * @dev Event signaling that tokens were sold and how many were sold\r\n\t */\r\n\tevent TokensSold(address indexed _beneficiary, uint256 _tokensSold);\r\n\r\n\t/**\r\n\t * @dev Event signaling that toke burn approval has been changed\r\n\t */\r\n\tevent TokenRefundApprovalChanged(address indexed _approvingAddress, bool tokenBurnApproved);\r\n\r\n\t/**\r\n\t * @dev Event signaling that token burn approval has been changed\r\n\t */\r\n\tevent CrowdsaleStageChanged(address indexed _changingAddress, uint _newStageValue);\r\n\r\n\t/**\r\n\t * @dev Event signaling that crowdsale tokens have been burned\r\n\t */\r\n\tevent CrowdsaleTokensRefunded(address indexed _refundingToAddress, uint256 _numberOfTokensBurned);\r\n\r\n\t/**\r\n\t * @dev SparkleTokenCrowdsale Contract contructor\r\n\t */\r\n\tconstructor(ERC20 _tokenAddress, uint256 _tokenRate, uint256 _tokenCap, uint256 _startTime, uint256 _endTime, address _depositWallet, bool _kycRequired)\r\n\tpublic\r\n\tCrowdsale(_tokenRate, _depositWallet, _tokenAddress)\r\n\tTimedCrowdsale(_startTime, _endTime)\r\n\tMultiOwnable()\r\n\tPausable()\r\n\t{ \r\n\t\ttokenAddress      = _tokenAddress;\r\n\t\ttokenRate         = _tokenRate;\r\n\t\ttokenCap          = _tokenCap;\r\n\t\tstartTime         = _startTime;\r\n\t\tendTime           = _endTime;\r\n\t\tdepositWallet     = _depositWallet;\r\n\t\tkycRequired       = _kycRequired;\r\n\t\trefundRemainingOk = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev claimPendingTokens() provides users with a function to receive their purchase tokens\r\n\t * after their KYC Verification\r\n\t */\r\n\tfunction claimTokens()\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\t{\r\n\t\t// Ensure calling address is not address(0)\r\n\t\trequire(msg.sender != address(0), \"Invalid address specified: address(0)\");\r\n\t\t// Obtain a copy of the caller's order record\r\n\t\tOrderBook storage order = orders[msg.sender];\r\n\t\t// Ensure caller has been KYC Verified\r\n\t\trequire(order.kycVerified, \"Address attempting to claim tokens is not KYC Verified.\");\r\n\t\t// Ensure caller has pending tokens to claim\r\n\t\trequire(order.pendingTokens > 0, \"Address does not have any pending tokens to claim.\");\r\n\t\t// For security sake grab the pending token value\r\n\t\tuint256 localPendingTokens = order.pendingTokens;\r\n\t\t// zero out pendingTokens to prevent potential re-entrancy vulnverability\r\n\t\torder.pendingTokens = 0;\r\n\t\t// Deliver the callers tokens\r\n\t\t_deliverTokens(msg.sender, localPendingTokens);\r\n\t\t// Emit event\r\n\t\temit TokensClaimed(msg.sender, localPendingTokens);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev getExchangeRate() provides a public facing manner in which to \r\n\t * determine the current rate of exchange in the crowdsale\r\n\t * @param _weiAmount is the amount of wei to purchase tokens with\r\n\t * @return number of tokens the specified wei amount would purchase\r\n\t */\r\n\tfunction getExchangeRate(uint256 _weiAmount)\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\tif (crowdsaleStage == CrowdsaleStage.preICO) {\r\n\t\t\t// Ensure _weiAmount is > than current stage minimum\r\n\t\t\trequire(_weiAmount >= 1 ether, \"PreICO minimum ether required: 1 ETH.\");\r\n\t\t}\r\n\t\telse if (crowdsaleStage == CrowdsaleStage.bonusICO || crowdsaleStage == CrowdsaleStage.mainICO) {\r\n\t\t\t// Ensure _weiAmount is > than current stage minimum\r\n\t\t\trequire(_weiAmount >= 500 finney, \"bonusICO/mainICO minimum ether required: 0.5 ETH.\");\r\n\t\t}\r\n\r\n\t\t// Calculate the number of tokens this amount of wei is worth\r\n\t\tuint256 tokenAmount = _getTokenAmount(_weiAmount);\r\n\t\t// Ensure the number of tokens requests will not exceed available tokens\r\n\t\trequire(getRemainingTokens() >= tokenAmount, \"Specified wei value woudld exceed amount of tokens remaining.\");\r\n\t\t// Calculate and return the token amount this amount of wei is worth (includes bonus factor)\r\n\t\treturn tokenAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev getRemainingTokens() provides function to return the current remaining token count\r\n\t * @return number of tokens remaining in the crowdsale to be sold\r\n\t */\r\n\tfunction getRemainingTokens()\r\n\twhenNotPaused\r\n\tpublic\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\t// Return the balance of the contract (IE: tokenCap - tokensSold)\r\n\t\treturn tokenCap.sub(tokensSold);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev refundRemainingTokens provides functionn to refund remaining tokens to the specified address\r\n\t * @param _addressToRefund is the address in which the remaining tokens will be refunded to\r\n\t */\r\n\tfunction refundRemainingTokens(address _addressToRefund)\r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tpublic\r\n\t{\r\n\t\t// Ensure the specified address is not address(0)\r\n\t\trequire(_addressToRefund != address(0), \"Specified address is invalid [0x0]\");\r\n\t\t// Ensure the crowdsale has closed before burning tokens\r\n\t\trequire(hasClosed(), \"Crowdsale must be finished to burn tokens.\");\r\n\t\t// Ensure that step-1 of the burning process is satisfied (owner set to true)\r\n\t\trequire(refundRemainingOk, \"Crowdsale remaining token refund is disabled.\");\r\n\t\tuint256 tempBalance = token().balanceOf(this);\r\n\t\t// Transfer the remaining tokens to specified address\r\n\t\t_deliverTokens(_addressToRefund, tempBalance);\r\n\t\t// Emit event\r\n\t\temit CrowdsaleTokensRefunded(_addressToRefund, tempBalance);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev approveRemainingTokenRefund approves the function to withdraw any remaining tokens\r\n\t * after the crowdsale ends\r\n\t * @dev This was put in place as a two-step process to burn tokens so burning was secure\r\n\t */\r\n\tfunction approveRemainingTokenRefund()\r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tpublic\r\n\t{\r\n\t\t// Ensure calling address is not address(0)\r\n\t\trequire(msg.sender != address(0), \"Calling address invalid [0x0]\");\r\n\t\t// Ensure the crowdsale has closed before approving token burning\r\n\t\trequire(hasClosed(), \"Token burn approval can only be set after crowdsale closes\");\r\n\t\trefundRemainingOk = true;\r\n\t\temit TokenRefundApprovalChanged(msg.sender, refundRemainingOk);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev setStage() sets the current crowdsale stage to the specified value\r\n\t * @param _newStageValue is the new stage to be changed to\r\n\t */\r\n\tfunction changeCrowdsaleStage(uint _newStageValue)\r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\t{\r\n\t\t// Create temporary stage variable\r\n\t\tCrowdsaleStage _stage;\r\n\t\t// Determine if caller is trying to set: preICO\r\n\t\tif (uint(CrowdsaleStage.preICO) == _newStageValue) {\r\n\t\t\t// Set the internal stage to the new value\r\n\t\t\t_stage = CrowdsaleStage.preICO;\r\n\t\t}\r\n\t\t// Determine if caller is trying to set: bonusICO\r\n\t\telse if (uint(CrowdsaleStage.bonusICO) == _newStageValue) {\r\n\t\t\t// Set the internal stage to the new value\r\n\t\t\t_stage = CrowdsaleStage.bonusICO;\r\n\t\t}\r\n\t\t// Determine if caller is trying to set: mainICO\r\n\t\telse if (uint(CrowdsaleStage.mainICO) == _newStageValue) {\r\n\t\t\t// Set the internal stage to the new value\r\n\t\t\t_stage = CrowdsaleStage.mainICO;\r\n\t\t}\r\n\t\telse {\r\n\t\t\trevert(\"Invalid stage selected\");\r\n\t\t}\r\n\r\n\t\t// Update the internal crowdsale stage to the new stage\r\n\t\tcrowdsaleStage = _stage;\r\n\t\t// Emit event\r\n\t\temit CrowdsaleStageChanged(msg.sender, uint(_stage));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev isAddressKYCVerified() checks the KYV Verification status of the specified address\r\n\t * @param _addressToLookuo address to check status of KYC Verification\r\n\t * @return kyc status of the specified address \r\n\t */\r\n\tfunction isKYCVerified(address _addressToLookuo) \r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\tview\r\n\treturns (bool)\r\n\t{\r\n\t\t// Ensure _addressToLookuo is not address(0)\r\n\t\trequire(_addressToLookuo != address(0), \"Invalid address specified: address(0)\");\r\n\t\t// Obtain the addresses order record\r\n\t\tOrderBook storage order = orders[_addressToLookuo];\r\n\t\t// Return the JYC Verification status for the specified address\r\n\t\treturn order.kycVerified;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve in bulk the specified addfresses indicating they were KYC Verified\r\n\t * @param _addressesForApproval is a list of addresses that are to be KYC Verified\r\n\t */\r\n\tfunction bulkApproveKYCAddresses(address[] _addressesForApproval) \r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\t{\r\n\r\n\t\t// Ensure that there are any address(es) in the provided array\r\n\t\trequire(_addressesForApproval.length > 0, \"Specified address array is empty\");\r\n\t\t// Interate through all addresses provided\r\n\t\tfor (uint i = 0; i <_addressesForApproval.length; i++) {\r\n\t\t\t// Approve this address using the internal function\r\n\t\t\t_approveKYCAddress(_addressesForApproval[i]);\r\n\t\t}\r\n\r\n\t\t// Emit event indicating address(es) have been approved for KYC Verification\r\n\t\temit ApprovedKYCAddresses(msg.sender, _addressesForApproval.length);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Revoke in bulk the specified addfresses indicating they were denied KYC Verified\r\n\t * @param _addressesToRevoke is a list of addresses that are to be KYC Verified\r\n\t */\r\n\tfunction bulkRevokeKYCAddresses(address[] _addressesToRevoke) \r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\t{\r\n\t\t// Ensure that there are any address(es) in the provided array\r\n\t\trequire(_addressesToRevoke.length > 0, \"Specified address array is empty\");\r\n\t\t// Interate through all addresses provided\r\n\t\tfor (uint i = 0; i <_addressesToRevoke.length; i++) {\r\n\t\t\t// Approve this address using the internal function\r\n\t\t\t_revokeKYCAddress(_addressesToRevoke[i]);\r\n\t\t}\r\n\r\n\t\t// Emit event indicating address(es) have been revoked for KYC Verification\r\n\t\temit RevokedKYCAddresses(msg.sender, _addressesToRevoke.length);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev tokensPending() provides owners the function to retrieve an addresses pending\r\n\t * token amount\r\n\t * @param _addressToLookup is the address to return the pending token value for\r\n\t * @return the number of pending tokens waiting to be claimed from specified address\r\n\t */\r\n\tfunction tokensPending(address _addressToLookup)\r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\t// Ensure specified address is not address(0)\r\n\t\trequire(_addressToLookup != address(0), \"Specified address is invalid [0x0]\");\r\n\t\t// Obtain the order for specified address\r\n\t\tOrderBook storage order = orders[_addressToLookup];\r\n\t\t// Return the pendingTokens amount\r\n\t\treturn order.pendingTokens;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev contributionAmount() provides owners the function to retrieve an addresses total\r\n\t * contribution amount in eth\r\n\t * @param _addressToLookup is the address to return the contribution amount value for\r\n\t * @return the number of ether contribured to the crowdsale by specified address\r\n\t */\r\n\tfunction contributionAmount(address _addressToLookup)\r\n\tonlyOwner\r\n\twhenNotPaused\r\n\tonlyWhileOpen\r\n\tpublic\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\t// Ensure specified address is not address(0)\r\n\t\trequire(_addressToLookup != address(0), \"Specified address is Invalid [0x0]\");\r\n\t\t// Obtain the order for specified address\r\n\t\tOrderBook storage order = orders[_addressToLookup];\r\n\t\t// Return the contribution amount in wei\r\n\t\treturn order.weiAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev _approveKYCAddress provides the function to approve the specified address \r\n\t * indicating KYC Verified\r\n\t * @param _addressToApprove of the user that is being verified\r\n\t */\r\n\tfunction _approveKYCAddress(address _addressToApprove) \r\n\tonlyOwner\r\n\tinternal\r\n\t{\r\n\t\t// Ensure that _addressToApprove is not address(0)\r\n\t\trequire(_addressToApprove != address(0), \"Invalid address specified: address(0)\");\r\n\t\t// Get this addesses contribution record\r\n\t\tOrderBook storage order = orders[_addressToApprove];\r\n\t\t// Set the contribution record to indicate address has been kyc verified\r\n\t\torder.kycVerified = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev _revokeKYCAddress() provides the function to revoke previously\r\n\t * granted KYC verification in cases of fraud or false/invalid KYC data\r\n\t * @param _addressToRevoke is the address to remove KYC verification from\r\n\t */\r\n\tfunction _revokeKYCAddress(address _addressToRevoke)\r\n\tonlyOwner\r\n\tinternal\r\n\t{\r\n\t\t// Ensure address is not address(0)\r\n\t\trequire(_addressToRevoke != address(0), \"Invalid address specified: address(0)\");\r\n\t\t// Obtain a copy of this addresses contribution record\r\n\t\tOrderBook storage order = orders[_addressToRevoke];\r\n\t\t// Revoke this addresses KYC verification\r\n\t\torder.kycVerified = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev _rate() provides the function of calcualting the rate based on crowdsale stage\r\n\t * @param _weiAmount indicated the amount of ether intended to use for purchase\r\n\t * @return number of tokens worth based on specified Wei value\r\n\t */\r\n\tfunction _rate(uint _weiAmount)\r\n\tinternal\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\trequire(_weiAmount > 0, \"Specified wei amoount must be > 0\");\r\n\r\n\t\t// Determine if the current operation stage of the crowdsale is preICO\r\n\t\tif (crowdsaleStage == CrowdsaleStage.preICO)\r\n\t\t{\r\n\t\t\t// Determine if the purchase is >= 21 ether\r\n\t\t\tif (_weiAmount >= 21 ether) { // 20% bonus\r\n\t\t\t\treturn 480e8;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Determine if the purchase is >= 11 ether\r\n\t\t\tif (_weiAmount >= 11 ether) { // 15% bonus\r\n\t\t\t\treturn 460e8;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Determine if the purchase is >= 5 ether\r\n\t\t\tif (_weiAmount >= 5 ether) { // 10% bonus\r\n\t\t\t\treturn 440e8;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t// Determine if the current operation stage of the crowdsale is bonusICO\r\n\t\tif (crowdsaleStage == CrowdsaleStage.bonusICO)\r\n\t\t{\r\n\t\t\t// Determine if the purchase is >= 21 ether\r\n\t\t\tif (_weiAmount >= 21 ether) { // 10% bonus\r\n\t\t\t\treturn 440e8;\r\n\t\t\t}\r\n\t\t\telse if (_weiAmount >= 11 ether) { // 7% bonus\r\n\t\t\t\treturn 428e8;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif (_weiAmount >= 5 ether) { // 5% bonus\r\n\t\t\t\treturn 420e8;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Rate is either < bounus or is main sale so return base rate only\r\n\t\treturn rate();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs token to wei converstion calculations based on crowdsale specification\r\n\t * @param _weiAmount to spend\r\n\t * @return number of tokens purchasable for the specified _weiAmount at crowdsale stage rates\r\n\t */\r\n\tfunction _getTokenAmount(uint256 _weiAmount)\r\n\twhenNotPaused\r\n\tinternal\r\n\tview\r\n\treturns (uint256)\r\n\t{\r\n\t\t// Get the current rate set in the constructor and calculate token units per wei\r\n\t\tuint256 currentRate = _rate(_weiAmount);\r\n\t\t// Calculate the total number of tokens buyable at based rate (before adding bonus)\r\n\t\tuint256 sparkleToBuy = currentRate.mul(_weiAmount).div(10e17);\r\n\t\t// Return proposed token amount\r\n\t\treturn sparkleToBuy;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev _preValidatePurchase provides the functionality of pre validating a potential purchase\r\n\t * @param _beneficiary is the address that is currently purchasing tokens\r\n\t * @param _weiAmount is the number of tokens this address is attempting to purchase\r\n\t */\r\n\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount) \r\n\twhenNotPaused\r\n\tinternal\r\n\tview\r\n\t{\r\n\t\t// Call into the parent validation to ensure _beneficiary and _weiAmount are valid\r\n\t\tsuper._preValidatePurchase(_beneficiary, _weiAmount);\r\n\t\t// Calculate amount of tokens for the specified _weiAmount\r\n\t\tuint256 requestedTokens = getExchangeRate(_weiAmount);\r\n\t\t// Calculate the currently sold tokens\r\n\t\tuint256 tempTotalTokensSold = tokensSold;\r\n\t\t// Incrememt total tokens\t\t\r\n\t\ttempTotalTokensSold.add(requestedTokens);\r\n\t\t// Ensure total max token cap is > tempTotalTokensSold\r\n\t\trequire(tempTotalTokensSold <= tokenCap, \"Requested wei amount will exceed the max token cap and was not accepted.\");\r\n\t\t// Ensure that requested tokens will not go over the remaining token balance\r\n\t\trequire(requestedTokens <= getRemainingTokens(), \"Requested tokens would exceed tokens available and was not accepted.\");\r\n\t\t// Obtain the order record for _beneficiary if one exists\r\n\t\tOrderBook storage order = orders[_beneficiary];\r\n\t\t// Ensure this address has been kyc validated\r\n\t\trequire(order.kycVerified, \"Address attempting to purchase is not KYC Verified.\");\r\n\t\t// Update this addresses order to reflect the purchase and ether spent\r\n\t\torder.weiAmount = order.weiAmount.add(_weiAmount);\r\n\t\torder.pendingTokens = order.pendingTokens.add(requestedTokens);\r\n\t\t// increment totalTokens sold\r\n\t\ttokensSold = tokensSold.add(requestedTokens);\r\n\t\t// Emit event\r\n\t\temit TokensSold(_beneficiary, requestedTokens);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev _processPurchase() is overridden and will be called by OpenZep v2.0 internally\r\n\t * @param _beneficiary is the address that is currently purchasing tokens\r\n\t * @param _tokenAmount is the number of tokens this address is attempting to purchase\r\n\t */\r\n\tfunction _processPurchase(address _beneficiary, uint256 _tokenAmount)\r\n\twhenNotPaused\r\n\tinternal\r\n\t{\r\n\t\t// We do not call the base class _processPurchase() functions. This is needed here or the base\r\n\t\t// classes function will be called.\r\n\t}\r\n\r\n}\r\n\r\n\r\n// File: contracts/SparkleCrowdsale.sol\r\n\r\ncontract SparkleCrowdsale is SparkleBaseCrowdsale {\r\n\r\n  // Token contract address \r\n  address public initTokenAddress = 0x4b7aD3a56810032782Afce12d7d27122bDb96efF;\r\n  // Crowdsale specification\r\n  uint256 public initTokenRate     = 400e8;\r\n  uint256 public initTokenCap      = 19698000e8;\r\n  uint256 public initStartTime     = now;\r\n  uint256 public initEndTime       = now + 12 weeks; // Set this accordingly as it cannot be changed\r\n  address public initDepositWallet = 0x0926a84C83d7B88338588Dca2729b590D787FA34;\r\n  bool public initKYCRequired      = true;\r\n\r\n  constructor() \r\n\tSparkleBaseCrowdsale(ERC20(initTokenAddress), initTokenRate, initTokenCap, initStartTime, initEndTime, initDepositWallet, initKYCRequired)\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressToLookup\",\"type\":\"address\"}],\"name\":\"contributionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerToRemove\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ownerAddressToLookup\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressToLookuo\",\"type\":\"address\"}],\"name\":\"isKYCVerified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressToLookup\",\"type\":\"address\"}],\"name\":\"tokensPending\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStageValue\",\"type\":\"uint256\"}],\"name\":\"changeCrowdsaleStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerToAdd\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressesToRevoke\",\"type\":\"address[]\"}],\"name\":\"bulkRevokeKYCAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundRemainingOk\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initKYCRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initDepositWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToRefund\",\"type\":\"address\"}],\"name\":\"refundRemainingTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kycRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveRemainingTokenRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initTokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnership\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initTokenRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_masterAddressToLookup\",\"type\":\"address\"}],\"name\":\"isMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressesForApproval\",\"type\":\"address[]\"}],\"name\":\"bulkApproveKYCAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_appovedByAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numberOfApprovals\",\"type\":\"uint256\"}],\"name\":\"ApprovedKYCAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_revokedByAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numberOfRevokals\",\"type\":\"uint256\"}],\"name\":\"RevokedKYCAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokensClaimed\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokensSold\",\"type\":\"uint256\"}],\"name\":\"TokensSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_approvingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenBurnApproved\",\"type\":\"bool\"}],\"name\":\"TokenRefundApprovalChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_changingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newStageValue\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_refundingToAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numberOfTokensBurned\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleTokensRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"removedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SparkleCrowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://963159d4bf355a82b79143806a111b960c17df59d23a7080377003ebf4537f5b"}]}