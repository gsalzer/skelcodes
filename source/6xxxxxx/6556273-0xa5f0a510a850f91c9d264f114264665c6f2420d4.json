{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary Ball {\r\n    \r\n\r\n    \r\n    //uint256 public constant QUEUE_INT_SIZE = 100 ether;\r\n    \r\n    struct Data{\r\n        uint256 index;\r\n        address owner;\r\n        uint256 outCount;\r\n        uint createAt;\r\n    }\r\n    \r\n    struct Queue{\r\n        uint256 startIdx;\r\n        uint256 size ;\r\n        mapping(uint256 => Data) map;\r\n    }\r\n    \r\n    function lifo(Data[] storage ds,Data ind) internal  returns(Data  ans){\r\n        ans = ds[0];\r\n        for(uint256 i=0;i<ds.length-1;i++){\r\n            Data storage nd = ds[i+1];\r\n            ds[i] = nd;\r\n        }\r\n        ds[ds.length-1] = ind;\r\n    }\r\n    \r\n    function getByIndex(Data[] storage ds,uint256 idx) internal view returns(Data storage ) {\r\n        for(uint256 i=0;i<ds.length;i++){\r\n            Data storage d = ds[i];\r\n            if(idx ==d.index){\r\n                return d;\r\n            }\r\n        }       \r\n        revert(\"not find getByIndex Ball\");\r\n    }\r\n    \r\n    function isBrandNew(Data storage d) internal view returns(bool){\r\n        return d.owner == address(0);\r\n    }\r\n    \r\n    function replace(Data storage tar,Data  sor) internal {\r\n        tar.index = sor.index;\r\n        tar.owner = sor.owner;\r\n        tar.outCount = sor.outCount;\r\n        tar.createAt = sor.createAt;\r\n    }\r\n    \r\n    function removeByIndex(Data[] storage array,uint256 index) internal {\r\n        if (index >= array.length) return;\r\n\r\n        for (uint256 i = index; i<array.length-1; i++){\r\n            array[i] = array[i+1];\r\n        }\r\n        delete array[array.length-1];\r\n        array.length--;\r\n    }\r\n    \r\n    \r\n    function removeByOwner(Data[] storage ds,address owner,uint256 count) internal{\r\n        for(uint256 i=0;i<ds.length;i++){\r\n            if( ds[i].owner == owner ) {\r\n                removeByIndex(ds,i);\r\n                i--;\r\n                count--;\r\n            }\r\n            if(count ==0) return;\r\n        }\r\n        revert(\"removeByOwner count not = 0\");\r\n    }\r\n    \r\n    function countByOwner(Data[] storage ds,address owner) internal view returns(uint256 ans){\r\n        for(uint256 i=0;i<ds.length;i++){\r\n            if( ds[i].owner == owner ) {\r\n                ans++;\r\n            }\r\n        }        \r\n    }\r\n    \r\n    \r\n\r\n    function getEnd(Queue storage q)  internal view returns(uint256 ){\r\n            return q.startIdx + q.size;\r\n    }        \r\n    \r\n    function getWishEnd(Queue storage q,uint256 wishSize)  internal view returns(uint256 ){\r\n        if(q.size > wishSize){\r\n            return q.startIdx + wishSize;\r\n        }else{\r\n            return q.startIdx + q.size;\r\n        }\r\n    }    \r\n    \r\n\r\n\r\n\r\n    \r\n    function getRealIdx(Queue storage q,uint256 index) internal view  returns(uint256 ){\r\n        uint256 realIdx = q.startIdx + index;\r\n         require(getEnd(q)>realIdx,\"getEnd()>q.startIdx+idx\");\r\n        return realIdx;\r\n    }\r\n    \r\n    function get(Queue storage q,uint256 index) internal view returns(Data ){\r\n        return q.map[getRealIdx(q,index)];\r\n    }\r\n    \r\n    function offer(Queue storage q,Data b) internal {\r\n        uint256 lastIdx= q.size ++;\r\n        q.map[getRealIdx(q,lastIdx)] = b;\r\n    }\r\n    \r\n    function removeAtStart(Queue storage q,uint256 count)  internal{\r\n        require(q.size >= count ,\"getSize(q) >= count\");\r\n        for(uint256 i=q.startIdx;i<getWishEnd(q,count);i++){\r\n            delete q.map[i];\r\n        }\r\n        q.startIdx += count;\r\n        q.size -= count;\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n}\r\n\r\nlibrary CommUtils{\r\n\r\n    function removeByIdx(uint256[] array,uint256 idx) public pure returns(uint256[] memory){\r\n        uint256[] memory ans = copy(array,array.length-1);\r\n        while((idx+1) < array.length){\r\n            ans[idx] = array[idx+1];\r\n            idx++;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function copy(uint256[] array,uint256 len) public pure returns(uint256[] memory){\r\n        uint256[] memory ans = new uint256[](len);\r\n        len = len > array.length? array.length : len;\r\n        for(uint256 i =0;i<len;i++){\r\n            ans[i] = array[i];\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function getHash(uint256[] array) public pure returns(uint256) {\r\n        uint256 baseStep =100;\r\n        uint256 pow = 1;\r\n        uint256 ans = 0;\r\n        for(uint256 i=0;i<array.length;i++){\r\n            ans= ans+ uint256(array[i] *pow ) ;\r\n            pow= pow* baseStep;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function contains(address[] adrs,address adr)public pure returns(bool){\r\n        for(uint256 i=0;i<adrs.length;i++){\r\n            if(adrs[i] ==  adr) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    function random(uint256 max,uint256 mixed) public view returns(uint256){\r\n        uint256 lastBlockNumber = block.number - 1;\r\n        uint256 hashVal = uint256(blockhash(lastBlockNumber));\r\n        hashVal += 31*uint256(block.coinbase);\r\n        hashVal += 19*mixed;\r\n        hashVal += 17*uint256(block.difficulty);\r\n        hashVal += 13*uint256(block.gaslimit );\r\n        hashVal += 11*uint256(now );\r\n        hashVal += 7*uint256(block.timestamp );\r\n        hashVal += 3*uint256(tx.origin);\r\n        return uint256(hashVal % max);\r\n    } \r\n    \r\n    function getIdxArray(uint256 len) public pure returns(uint256[]){\r\n        uint256[] memory ans = new uint256[](len);\r\n        for(uint128 i=0;i<len;i++){\r\n            ans[i] = i;\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    function genRandomArray(uint256 digits,uint256 templateLen,uint256 base) public view returns(uint256[]) {\r\n        uint256[] memory ans = new uint256[](digits);\r\n        uint256[] memory idxs  = getIdxArray( templateLen);\r\n       for(uint256 i=0;i<digits;i++){\r\n            uint256  idx = random(idxs.length,i+base);\r\n            uint256 wordIdx = idxs[idx];\r\n            ans[i] = wordIdx;\r\n            idxs = removeByIdx(idxs,idx);\r\n           \r\n       }\r\n       return ans;\r\n    }\r\n   \r\n   \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subb(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    \r\n   /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function multiplies(uint256 a, uint256 b) \r\n        private \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n    \r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = multiplies(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n    \r\n    function pwrFloat(uint256 tar,uint256 numerator,uint256 denominator,uint256 pwrN) public pure returns(uint256) {\r\n        for(uint256 i=0;i<pwrN;i++){\r\n            tar = tar * numerator / denominator;\r\n        }\r\n        return tar ;\r\n        \r\n    }\r\n\r\n    \r\n    function mulRate(uint256 tar,uint256 rate) public pure returns (uint256){\r\n        return tar *rate / 100;\r\n    }  \r\n    \r\n    \r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }    \r\n    \r\n    \r\n}\r\n\r\n\r\ncontract Infinitestars {\r\n    \r\n    using Player for Player.Map;\r\n    using CommUtils for string;\r\n    using InfinitestarsData for InfinitestarsData.Data;\r\n    using Ball for Ball.Data[];\r\n    uint256 public constant WITHDRAWAL_AUTO_BUY_COUNT = 1;\r\n    uint256 public constant BALL_PRICE = 0.5 ether;\r\n    uint256 public constant REGESTER_FEE = 0.02 ether;\r\n    uint256 public constant REGISTER_FREE_COUNT = 100;\r\n    InfinitestarsData.Data data;\r\n    uint256 private regesterCount =0;\r\n    bool private gameEnabled = false;\r\n\r\n\r\n    function enableGame() public{\r\n        require(Player.isAdmin(msg.sender),\"it`s not admin\");\r\n        gameEnabled = true;\r\n    }\r\n    \r\n    modifier enabling(){\r\n        require(gameEnabled,\"game not start\");\r\n        _;\r\n    }\r\n\r\n    function buyBall(uint256 count) enabling public payable  {\r\n        uint256 sp =data.buyBall(count,msg.sender);\r\n        broadcastBuy(msg.sender,count,sp);\r\n    }\r\n    \r\n    function broadcastBuy(address adr,uint256 count,uint256 starsPickValue) private {\r\n        bytes32 b = data.players.getName(adr);\r\n        emit OnBuyed (adr,b,count,starsPickValue);\r\n    }\r\n    \r\n    function buyBallWithReferrer(uint256 count,string referrer) enabling public payable  {\r\n        uint256 sp =data.buyBallWithReferrer(count,msg.sender,referrer);\r\n        broadcastBuy(msg.sender,count,sp);\r\n    }    \r\n\r\n    function getInit()  public view returns(\r\n        bytes32, //0 your name\r\n        bytes32, //1  refername\r\n        uint256,  //2 currentIdx\r\n        uint256,    //3 shourt Prize\r\n        uint256,     //4 the player gains\r\n        uint256,     //5 refferSumReward\r\n        bool ,      //6 played\r\n        uint256 ,    //7 blance\r\n        uint256     //8  Your live ball\r\n    \r\n    ){\r\n       // (uint256 count,uint256 firstAt,uint256 lastAt, uint256 payOutCount,uint256 nextPayOutAt) = data.getOutInfoOfSender();\r\n        return (\r\n            data.players.getName(),\r\n            data.players.getReferrerName(msg.sender),\r\n            data.currentIdx,\r\n            data.shortPrize,\r\n            data.players.getAmmount(msg.sender),\r\n            data.referralbonusMap[msg.sender],\r\n            data.playedMap[msg.sender],\r\n            address(this).balance,\r\n            data.balls.countByOwner(msg.sender)\r\n        );\r\n    }\r\n    \r\n    \r\n    function getOutInfoOfSender()  public view returns(\r\n            uint256 , //your out ball\r\n            uint256 , //firstAt\r\n            uint256 ,  //lastAt      \r\n            uint256,   //  payOutCount,\r\n            uint256 ,   //   nextPayOutAt    \r\n            uint256     // payedCount\r\n        ){\r\n        return data.getOutInfoOfSender();\r\n    }      \r\n\r\n    \r\n    function outBall() enabling public {\r\n        data.toPayedBall();\r\n        data.toOutBall();\r\n    }\r\n    \r\n    function listLiveBall() public view returns(\r\n        uint256[] , //index;\r\n        address[] , //owner;\r\n        uint256[] , //outCount;\r\n        uint[]  //createAt;\r\n        ){\r\n        return listBall(data.balls);\r\n    }\r\n    \r\n    function listBall(Ball.Data[] list) private pure returns(\r\n        uint256[] indexs, //index;\r\n        address[] owners, //owner;\r\n        uint256[] outCounts, //outCount;\r\n        uint[] createAts //createAt;\r\n        ){\r\n        indexs = new uint256[](list.length);    \r\n        owners = new address[](list.length);    \r\n        outCounts = new uint256[](list.length);    \r\n        createAts = new uint[](list.length);    \r\n        for(uint256 i=0;i<list.length;i++){\r\n            indexs[i]=list[i].index;\r\n            owners[i]=list[i].owner;\r\n            outCounts[i]=list[i].outCount;\r\n            createAts[i]=list[i].createAt;\r\n        }\r\n        \r\n    }\r\n    \r\n  \r\n    \r\n    function registerName(string  name) enabling public payable {\r\n        require(msg.value >= REGESTER_FEE,\"fee not enough\");\r\n        require(data.playedMap[msg.sender] ,\"it`s not play\");\r\n        regesterCount++;\r\n        data.registerName(name);\r\n        if(REGISTER_FREE_COUNT>=regesterCount){\r\n            data.players.deposit(msg.sender,REGESTER_FEE);\r\n        }\r\n    }    \r\n    \r\n    function isEmptyName(string _n) public view returns(bool){\r\n        return data.players.isEmptyName(_n.nameFilter());\r\n    }    \r\n    \r\n    \r\n    function withdrawalBuy(uint256 ammount) enabling public payable{\r\n        \r\n        address self = msg.sender;\r\n        uint256 fee = CommUtils.mulRate(ammount,1);\r\n        uint256 gains = data.players.getAmmount(msg.sender);\r\n        uint256 autoPayA = WITHDRAWAL_AUTO_BUY_COUNT*BALL_PRICE;\r\n        ammount-= fee;\r\n        require(ammount<=gains ,\"getAmmount is too low \");\r\n        require(data.balls.countByOwner(self)>0 ,\"must has live ball \");\r\n        require(gains >= autoPayA,\"gains >= autoPayA\");\r\n        require(ammount>= autoPayA,\"ammount>= ammount\");\r\n        data.players.transferAuthor(fee);\r\n        ammount -= autoPayA;\r\n        data.buyBall(WITHDRAWAL_AUTO_BUY_COUNT,self);\r\n        uint256 contractBlc = address(this).balance;\r\n        bool b =false;\r\n        if(contractBlc >= ammount){\r\n            data.players.minus(self,ammount);\r\n            self.transfer(ammount);\r\n            b= true;\r\n        }else if(ammount>=BALL_PRICE){\r\n            uint256 mod = ammount % BALL_PRICE;\r\n            uint256 count = (ammount - mod) / BALL_PRICE;\r\n            data.buyBall(count,self);\r\n            data.players.deposit(msg.sender,mod);\r\n            b= true;\r\n        }        \r\n        emit OnWithdrawaled (self,ammount,b); \r\n    }\r\n    \r\n\r\n    event OnBuyed(\r\n        address buyer,\r\n        bytes32 buyerName,\r\n        uint256 count,\r\n        uint256 starsPickValue\r\n    );\r\n    \r\n    event OnWithdrawaled(\r\n        address who,\r\n        uint256 ammount,\r\n        bool ok\r\n    );\r\n    \r\n    \r\n\r\n}\r\n\r\n\r\n\r\nlibrary InfinitestarsData {\r\n    \r\n\r\n    using Ball for Ball.Data[];\r\n    using Ball for Ball.Queue;\r\n    using Ball for Ball.Data;\r\n    using Player for Player.Map;\r\n    using CommUtils for string;\r\n    \r\n    \r\n    uint256 public constant  LIVE_BALL_COUNT = 3;\r\n    uint256 public constant BALL_PRICE = 0.5 ether;\r\n    uint256 public constant FEE = BALL_PRICE /100;\r\n    uint256 public constant OUT_LIMT = 2;\r\n    uint256 public constant SHORT_PRIZE_PLUS = BALL_PRICE * 3 / 100;\r\n    uint256 public constant LEVEL_1_REWARD = BALL_PRICE * 10 /100;\r\n    uint256 public constant LEVEL_2_REWARD = BALL_PRICE * 3 /100;\r\n    uint256 public constant LEVEL_3_REWARD = BALL_PRICE * 2 /100;\r\n    uint256 public constant MAINTTAIN_FEE =  BALL_PRICE * 1 /100;\r\n    uint256 public constant OUT_TIME = 60*60*24*2;\r\n    uint256 public constant PAY_TIME = 60*60*24*1;\r\n    //uint256 public constant OUT_TIME = 60*8;\r\n    //uint256 public constant PAY_TIME = 60*4 ;\r\n    \r\n    uint256 public constant QUEUE_BATCH_SIZE = 30;\r\n    //uint256 public constant OUT_TIME = 60;\r\n    uint256 public constant PAY_PROFIT = 0.085 ether;\r\n    //uint256 public constant PAY_AMMOUNT = (BALL_PRICE* 40/100) - FEE;\r\n\r\n    \r\n    struct Data{\r\n        Ball.Data[] balls ;\r\n        Ball.Queue outingBalls ;\r\n        Ball.Queue payedQueue ;\r\n        Player.Map players;\r\n        uint256 shortPrize;\r\n        uint256 currentIdx;\r\n        mapping(address => bool) playedMap;\r\n        mapping(address => uint256) playBallCountMap;\r\n        mapping(address=> uint256 ) referralbonusMap;      \r\n    }\r\n\r\n\r\n    function getOutInfoOfSender(Data storage d) internal view returns(\r\n            uint256 count,\r\n            uint256 firstAt,\r\n            uint256 lastAt,\r\n            uint256 payOutCount,\r\n            uint256 nextPayOutAt,\r\n            uint256 payedCount\r\n        ){\r\n        // (uint256 stI , uint256 endI ) = d.outingBalls.getRange();    \r\n         for(uint256 i=d.outingBalls.startIdx;i<d.outingBalls.getEnd();i++){\r\n            Ball.Data storage ob = d.outingBalls.map[i];  \r\n            if(ob.owner == msg.sender){\r\n                if(firstAt==0  ||  ob.createAt<firstAt){\r\n                    firstAt = ob.createAt;\r\n                }\r\n                if(lastAt == 0 || ob.createAt > lastAt){\r\n                    lastAt = ob.createAt;\r\n                }\r\n                if( (now - ob.createAt) > PAY_TIME ){\r\n                    payOutCount ++;\r\n                }else{\r\n                   if(nextPayOutAt==0) nextPayOutAt = ob.createAt;\r\n                }\r\n                count++;\r\n            }\r\n        }\r\n         for( i=d.payedQueue.startIdx;i<d.payedQueue.getEnd();i++){\r\n            ob = d.payedQueue.map[i];  \r\n            if(ob.owner == msg.sender){\r\n                if(firstAt==0  ||  ob.createAt<firstAt){\r\n                    firstAt = ob.createAt;\r\n                }\r\n                if(lastAt == 0 || ob.createAt > lastAt){\r\n                    lastAt = ob.createAt;\r\n                }\r\n                payOutCount ++;\r\n                payedCount++;\r\n                count++;\r\n            }\r\n        }         \r\n         \r\n        firstAt = now - firstAt;\r\n        lastAt = now - lastAt;\r\n        nextPayOutAt = now - nextPayOutAt;\r\n    }\r\n\r\n    function buyBallWithReferrer(Data storage d,uint256 count,address owner,string referrer) internal returns (uint256) {\r\n        require(!d.playedMap[msg.sender] ,\"it`s not play game player can apply referrer\");\r\n        d.players.applyReferrer(referrer);\r\n        return buyBall(d,count,owner);\r\n    }\r\n    \r\n    function buyBall(Data storage d,uint256 count,address owner) internal returns (uint256) {\r\n        d.players.withdrawalFee(count *BALL_PRICE);\r\n        for(uint256 i=0;i<count;i++){\r\n            claimBall(d,owner);            \r\n        }\r\n        d.playedMap[owner] = true;\r\n        d.playBallCountMap[owner] += count;\r\n        d.players.transferAuthorAll();\r\n        toPayedBall(d);\r\n        toOutBall(d);\r\n        return drawShortPrize(d,count);\r\n    }\r\n    \r\n    // function reviveBall(Data storage d,uint256 count) internal {\r\n    //     d.outingBalls.removeByOwner(msg.sender,count);\r\n    //     buyBall(d,count,msg.sender);\r\n    // }\r\n    \r\n    function drawShortPrize(Data storage d,uint256 count) private returns (uint256 ans) {\r\n        uint256 threshold = count * 5 ;\r\n        uint256 value = CommUtils.random(1000,5);\r\n        if(threshold>value){\r\n            ans = d.shortPrize;\r\n            d.players.deposit(msg.sender,d.shortPrize);\r\n            d.shortPrize = 0;\r\n        }\r\n    }\r\n    \r\n    function claimBall(Data storage d,address _owner) private{\r\n        Ball.Data memory b = Ball.Data({\r\n            index : d.currentIdx++,\r\n            owner : _owner,\r\n            outCount : 0,\r\n            createAt : now\r\n        });\r\n        require(d.balls.length <= LIVE_BALL_COUNT ,\"live ball is over 3\");\r\n        if(d.balls.length <LIVE_BALL_COUNT){\r\n            d.balls[d.balls.length++] = b;\r\n        }else{\r\n            Ball.Data memory outb= lifo(d,b);\r\n            revive(d,outb);\r\n        }\r\n        distributeReward(d,_owner);\r\n        \r\n    }\r\n    \r\n    function distributeReward(Data storage d,address _owner) private {\r\n        d.players.depositAuthor(FEE);\r\n        d.players.depositAuthor(MAINTTAIN_FEE);\r\n        d.shortPrize += SHORT_PRIZE_PLUS;\r\n        address l1 = d.players.getReferrer(_owner);\r\n        if(l1 == address(0)){\r\n            d.players.depositAuthor(LEVEL_1_REWARD + LEVEL_2_REWARD + LEVEL_3_REWARD);\r\n            return ;\r\n        }\r\n        depositReferrer(d,l1,LEVEL_1_REWARD);\r\n        address l2 = d.players.getReferrer(l1);\r\n        if(l2 == address(0)){\r\n            d.players.depositAuthor( LEVEL_2_REWARD + LEVEL_3_REWARD);\r\n             return ;\r\n        }\r\n        depositReferrer(d,l2,LEVEL_2_REWARD);\r\n        address l3 = d.players.getReferrer(l2);\r\n        if(l3 == address(0)){\r\n            d.players.depositAuthor(  LEVEL_3_REWARD);\r\n            return;\r\n        }\r\n        depositReferrer(d,l3,LEVEL_3_REWARD);\r\n    }\r\n    \r\n    function depositReferrer(Data storage d,address a,uint256 v) private {\r\n        d.players.deposit(a,v);\r\n        d.referralbonusMap[a]+= v;\r\n    }\r\n    \r\n    function lifo(Data storage d,Ball.Data  inb) private returns(Ball.Data ans){\r\n        ans = d.balls.lifo(inb);\r\n        d.players.depositAuthor(FEE);\r\n        //d.players.deposit(ans.owner,PAY_AMMOUNT);\r\n    }\r\n    \r\n    \r\n    function revive(Data storage d,Ball.Data b) private{\r\n        require(b.outCount<=OUT_LIMT,\"outCount>OUT_LIMT\");\r\n         if(b.outCount==OUT_LIMT){\r\n            d.players.deposit(b.owner,PAY_PROFIT);\r\n            b.createAt = now;\r\n            //Ball.Data storage outP= d.outingBalls[d.outingBalls.length ++];\r\n            d.outingBalls.offer(b);\r\n            //outP.replace(b);\r\n        }else{\r\n            b.outCount ++;\r\n            b.index = d.currentIdx++;\r\n            Ball.Data memory newOut  = lifo(d,b);\r\n            revive(d,newOut);\r\n        }\r\n    }\r\n    \r\n    function registerName(Data storage d,string  name) internal  {\r\n        require(d.playedMap[msg.sender] ,\"it`s  play game player can registerName\");\r\n        require(msg.value >= 0.02 ether);\r\n        require(d.players.getName()==\"\");\r\n        d.players.registerName(name.nameFilter());\r\n    }    \r\n    \r\n    \r\n    function toOutBall(Data storage d) internal{\r\n        \r\n        uint256 end  = d.payedQueue.getWishEnd(QUEUE_BATCH_SIZE);\r\n        uint256 rmCount = 0;\r\n        for(uint256 i=d.payedQueue.startIdx;i<end;i++){\r\n            Ball.Data storage b = d.payedQueue.map[i];\r\n\r\n            if(now - b.createAt> OUT_TIME ){\r\n                address owner = b.owner;\r\n                d.playBallCountMap[owner]--;\r\n                rmCount++;\r\n                removePlayerBallEmpty(d,owner);\r\n            }\r\n        }\r\n        d.payedQueue.removeAtStart( rmCount);\r\n    }\r\n    \r\n    function toPayedBall(Data storage d) internal{\r\n        uint256 end = d.outingBalls.getWishEnd(QUEUE_BATCH_SIZE);\r\n        uint256 rmCount = 0;\r\n        for(uint256 i=d.outingBalls.startIdx;i<end;i++){\r\n            Ball.Data storage b = d.outingBalls.map[i];\r\n            if(now - b.createAt >= PAY_TIME ){\r\n                d.players.deposit(b.owner,BALL_PRICE);\r\n                rmCount++;\r\n                d.payedQueue.offer(b);\r\n            }\r\n        }   \r\n        d.outingBalls.removeAtStart(rmCount);\r\n    }\r\n    \r\n    function removePlayerBallEmpty(Data storage d,address addr) private{\r\n        uint256 allBallCount = d.playBallCountMap[addr] ;\r\n        if(allBallCount <= 0){\r\n            d.players.remove(addr);\r\n            delete d.playedMap[addr];\r\n        }\r\n    }\r\n    \r\n    \r\n}\r\n\r\nlibrary Player{\r\n\r\n    using CommUtils for string;\r\n\r\n    address public constant AUTHOR =  0x001C9b3392f473f8f13e9Eaf0619c405AF22FC26a7;\r\n    address public constant DIRECTOR = 0x43beFdf21996f323E3cE6552452F11Efb7Dc1e7D;\r\n    uint256 public constant AUTHOR_RATE = 8;\r\n    \r\n    struct Map{\r\n        mapping(address=>uint256) map;\r\n        mapping(address=>address) referrerMap;\r\n        mapping(address=>bytes32) addrNameMap;\r\n        mapping(bytes32=>address) nameAddrMap;\r\n    }\r\n    \r\n    function remove(Map storage ps,address adr) internal{\r\n        transferAuthor(ps,ps.map[adr]);\r\n        delete ps.map[adr];\r\n        bytes32 b = ps.addrNameMap[adr];\r\n        delete ps.nameAddrMap[b];\r\n        delete ps.addrNameMap[adr];\r\n    }\r\n    \r\n    function deposit(Map storage  ps,address adr,uint256 v) internal returns(uint256) {\r\n       ps.map[adr]+=v;\r\n        return v;\r\n    }\r\n\r\n    function isAdmin(address addr) internal pure returns (bool){\r\n        if(addr == AUTHOR) return true;\r\n        if(addr == DIRECTOR) return true;\r\n        if(addr == address(0x00e37c73dbe66e92149092a85be6c32e23251ed0af)) return true;\r\n        return false;\r\n    }\r\n\r\n    function depositAuthor(Map storage  ps,uint256 v) internal returns(uint256) {\r\n        uint256 devFee = CommUtils.mulRate(v,AUTHOR_RATE);\r\n        uint256 dFee =  v- devFee;\r\n        deposit(ps,AUTHOR,devFee);\r\n        deposit(ps,DIRECTOR,dFee);\r\n        return v;\r\n    }\r\n    \r\n    function transferAuthorAll(Map storage  ps) internal{\r\n        transferSafe(ps,AUTHOR, withdrawalAll(ps,AUTHOR));\r\n        transferSafe(ps,DIRECTOR, withdrawalAll(ps,DIRECTOR));\r\n    }\r\n    \r\n    function transferSafe(Map storage  ps,address addr,uint256 v) internal {\r\n        \r\n        if(address(this).balance>=v){\r\n            addr.transfer(v);\r\n        }else{\r\n            uint256 less = v - address(this).balance;\r\n            addr.transfer( address(this).balance);\r\n            deposit(ps,addr,less);\r\n        }\r\n    }\r\n    \r\n    //depositAuthor\r\n    function transferAuthor(Map storage  ps,uint256 v) internal returns(uint256) {\r\n        uint256 devFee = CommUtils.mulRate(v,AUTHOR_RATE);\r\n        uint256 dFee =  v- devFee;\r\n        transferSafe(ps,AUTHOR,devFee);\r\n        transferSafe(ps,DIRECTOR,dFee);\r\n        return v;\r\n    }\r\n\r\n    function minus(Map storage  ps,address adr,uint256 num) internal  {\r\n        uint256 sum = ps.map[adr];\r\n        if(sum==num){\r\n             withdrawalAll(ps,adr);\r\n        }else{\r\n            require(sum > num);\r\n            ps.map[adr] = sum-num;\r\n        }\r\n    }\r\n    \r\n    function minusAndTransfer(Map storage  ps,address adr,uint256 num) internal  {\r\n        minus(ps,adr,num);\r\n        transferSafe(ps,adr,num);\r\n    }    \r\n    \r\n    function withdrawalAll(Map storage  ps,address adr) public returns(uint256) {\r\n        uint256 sum = ps.map[adr];\r\n        delete ps.map[adr];\r\n        return sum;\r\n    }\r\n    \r\n    function getAmmount(Map storage ps,address adr) public view returns(uint256) {\r\n        return ps.map[adr];\r\n    }\r\n    \r\n    function registerName(Map storage ps,bytes32 _name)internal  {\r\n        require(ps.nameAddrMap[_name] == address(0) );\r\n        ps.nameAddrMap[_name] = msg.sender;\r\n        ps.addrNameMap[msg.sender] = _name;\r\n        depositAuthor(ps,msg.value);\r\n    }\r\n    \r\n    function isEmptyName(Map storage ps,bytes32 _name) public view returns(bool) {\r\n        return ps.nameAddrMap[_name] == address(0);\r\n    }\r\n    \r\n    function getByName(Map storage ps,bytes32 _name)public view returns(address) {\r\n        return ps.nameAddrMap[_name] ;\r\n    }\r\n    \r\n    function getName(Map storage ps) public view returns(bytes32){\r\n        return ps.addrNameMap[msg.sender];\r\n    }\r\n    \r\n    function getName(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getNameByAddr(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getReferrer(Map storage ps,address adr)public view returns(address){\r\n        address refA = ps.referrerMap[adr];\r\n        bytes32 b= ps.addrNameMap[refA];\r\n        return b.length == 0 ? getReferrer(ps,refA) : refA;\r\n    }\r\n    \r\n    function getReferrerName(Map storage ps,address adr)public view returns(bytes32){\r\n        return getNameByAddr(ps,getReferrer(ps,adr));\r\n    }\r\n    \r\n    function setReferrer(Map storage ps,address self,address referrer)internal {\r\n         ps.referrerMap[self] = referrer;\r\n    }\r\n    \r\n    function applyReferrer(Map storage ps,string referrer)internal {\r\n        bytes32 rbs = referrer.nameFilter();\r\n        address referrerAdr = getByName(ps,rbs);\r\n        if(referrerAdr != msg.sender){\r\n            setReferrer(ps,msg.sender,referrerAdr);\r\n        }\r\n    }    \r\n    \r\n    function withdrawalFee(Map storage ps,uint256 fee) public returns (uint256){\r\n        if(msg.value > 0){\r\n            require(msg.value >= fee,\"msg.value < fee\");\r\n            return fee;\r\n        }\r\n        require(getAmmount(ps,msg.sender)>=fee ,\"players.getAmmount(msg.sender)<fee\");\r\n        minus(ps,msg.sender,fee);\r\n        return fee;\r\n    }   \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_n\",\"type\":\"string\"}],\"name\":\"isEmptyName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"string\"}],\"name\":\"buyBallWithReferrer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REGISTER_FREE_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"outBall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInit\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"buyBall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOutInfoOfSender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_AUTO_BUY_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REGESTER_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALL_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listLiveBall\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ammount\",\"type\":\"uint256\"}],\"name\":\"withdrawalBuy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"starsPickValue\",\"type\":\"uint256\"}],\"name\":\"OnBuyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ammount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ok\",\"type\":\"bool\"}],\"name\":\"OnWithdrawaled\",\"type\":\"event\"}]","ContractName":"Infinitestars","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"CommUtils:67a48470867899e7a8f001cf05863184065224b2;Player:8b361ddbf6a6b4946376abcb4118f01429cc6b8e","SwarmSource":"bzzr://a9d324c50fc2f16704b4c60ac46c041c37235a9a9297c81498bd86d798ccbe61"}]}