{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/***\r\n *     ____ _  _    __ _ __ _  __   ___ __ _ __  _  _ ____ \r\n *    (___ ( \\/ )  (  / (  ( \\/  \\ / __(  / /  \\/ )( (_  _)\r\n *     / __/)  (    )  (/    (  O ( (__ )  (  O ) \\/ ( )(  \r\n *    (____(_/\\_)  (__\\_\\_)__)\\__/ \\___(__\\_\\__/\\____/(__) \r\n * \r\n *                         HAMSTER LEAGUE\r\n *                     \r\n *                     https://2Xknockout.me\r\n * \r\n * Community:\r\n * https://discord.gg/GKHnMBs\r\n * http://t.me/Knockout2x\r\n * \r\n */\r\n\r\ncontract XKnockoutHamster {\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  struct EntityStruct {\r\n    bool active;\r\n    bool vip;\r\n    uint listPointer;\r\n    uint256 date;\r\n    uint256 update;\r\n    uint256 exit;\r\n    uint256 profit;\r\n  }\r\n  \r\n  mapping(address => EntityStruct) public entityStructs;\r\n  address[] public entityList;\r\n  address[] public vipList;\r\n  address dev;\r\n  uint256 base = 100000000000000000; //base is 0.1 ETH\r\n  uint256 public startedAt = now; //every new deposit updates start timetoRegular\r\n  uint256 public timeRemaining = 24 hours; //every +100 users in queue half decrease timeRemaining\r\n  uint256 public devreward; //buy me a coffee\r\n  uint public round = 1; //when time is up, contract resets automatically to next round\r\n  uint public shift = 0; //regular queue shift\r\n  uint public joined = 0; //stats\r\n  uint public exited = 0; //stats\r\n  bool public timetoRegular = true; //flag to switch queue\r\n  \r\n  constructor() public {\r\n     dev = msg.sender;\r\n  }\r\n  \r\n  function() public payable {\r\n    if(checkRemaining()) { msg.sender.transfer(msg.value); \r\n    } else {\r\n        if(msg.value == base) {\r\n            addToList();\r\n        } else if(msg.value == base.div(10)) {\r\n            up();\r\n        } else {\r\n            revert(\"You should send 0.1 ETH to join the list or 0.01 ETH to up\");\r\n        }   \r\n    }\r\n  }\r\n  \r\n  function addToList() internal {\r\n      if(entityStructs[msg.sender].active) revert(\"You are already in the list\");\r\n      \r\n      newEntity(msg.sender, true);\r\n      joined++;\r\n\t  startedAt = now;\r\n      entityStructs[msg.sender].date = now;\r\n      entityStructs[msg.sender].profit = 0;\r\n      entityStructs[msg.sender].update = 0;\r\n      entityStructs[msg.sender].exit = 0;\r\n      entityStructs[msg.sender].active = true;\r\n      entityStructs[msg.sender].vip = false;\r\n    \r\n      if(timetoRegular) {\r\n        //Regular queue  \r\n        entityStructs[entityList[shift]].profit += base;\r\n          if(entityStructs[entityList[shift]].profit == 2*base) {\r\n              entityStructs[entityList[shift]].active = false;\r\n              entityStructs[entityList[shift]].exit = now;\r\n              entityList[shift].transfer( entityStructs[entityList[shift]].profit.mul(90).div(100) );\r\n              devreward += entityStructs[entityList[shift]].profit.mul(10).div(100);\r\n              exitREG();\r\n              exited++;\r\n              //Switch queue to vip\r\n              if(lastVIPkey() != 9999) {\r\n                  if(vipList[lastVIPkey()] != address(0)) timetoRegular = false;\r\n              }\r\n          }\r\n\r\n      } else if (!timetoRegular) {\r\n        //VIP queue\r\n        uint lastVIP = lastVIPkey();\r\n        entityStructs[vipList[lastVIP]].profit += base;\r\n          if(entityStructs[vipList[lastVIP]].profit == 2*base) {\r\n              entityStructs[vipList[lastVIP]].active = false;\r\n              entityStructs[vipList[lastVIP]].exit = now;\r\n              vipList[lastVIP].transfer( entityStructs[vipList[lastVIP]].profit.mul(90).div(100) );\r\n              devreward += entityStructs[vipList[lastVIP]].profit.mul(10).div(100);\r\n              exitVIP(vipList[lastVIP]);\r\n              exited++;\r\n              //Switch queue to regular\r\n              timetoRegular = true;\r\n          }     \r\n      }\r\n  }\r\n  \r\n  function up() internal {\r\n      if(joined.sub(exited) < 3) revert(\"You are too alone to up\");\r\n      if(!entityStructs[msg.sender].active) revert(\"You are not in the list\");\r\n      if(entityStructs[msg.sender].vip && (now.sub(entityStructs[msg.sender].update)) < 600) revert (\"Up allowed once per 10 min\");\r\n      \r\n      if(!entityStructs[msg.sender].vip) {\r\n          \r\n          /*\r\n           * When somebody UP first time, he gives an amazing chance to last one in the list\r\n           * shift to his place at regular queue\r\n           */\r\n           \r\n            uint rowToDelete = entityStructs[msg.sender].listPointer;\r\n            address keyToMove = entityList[entityList.length-1];\r\n            entityList[rowToDelete] = keyToMove;\r\n            entityStructs[keyToMove].listPointer = rowToDelete;\r\n            entityList.length--;\r\n           \r\n           //Add to VIP\r\n           entityStructs[msg.sender].update = now;\r\n           entityStructs[msg.sender].vip = true;\r\n           newVip(msg.sender, true);\r\n           \r\n           devreward += msg.value; //goes to marketing\r\n           \r\n      } else if (entityStructs[msg.sender].vip) {\r\n          \r\n          //User up again\r\n          entityStructs[msg.sender].update = now;\r\n          delete vipList[entityStructs[msg.sender].listPointer];\r\n          newVip(msg.sender, true);\r\n          devreward += msg.value; //goes to marketing\r\n      }\r\n  }\r\n\r\n  function newEntity(address entityAddress, bool entityData) internal returns(bool success) {\r\n    entityStructs[entityAddress].active = entityData;\r\n    entityStructs[entityAddress].listPointer = entityList.push(entityAddress) - 1;\r\n    return true;\r\n  }\r\n\r\n  function exitREG() internal returns(bool success) {\r\n    delete entityList[shift];\r\n    shift++;\r\n    return true;\r\n  }\r\n  \r\n  function getVipCount() public constant returns(uint entityCount) {\r\n    return vipList.length;\r\n  }\r\n\r\n  function newVip(address entityAddress, bool entityData) internal returns(bool success) {\r\n    entityStructs[entityAddress].vip = entityData;\r\n    entityStructs[entityAddress].listPointer = vipList.push(entityAddress) - 1;\r\n    return true;\r\n  }\r\n\r\n  function exitVIP(address entityAddress) internal returns(bool success) {\r\n    //Supa dupa method to deal with arrays ^_^ \r\n    uint rowToDelete = entityStructs[entityAddress].listPointer;\r\n    address keyToMove = vipList[vipList.length-1];\r\n    vipList[rowToDelete] = keyToMove;\r\n    entityStructs[keyToMove].listPointer = rowToDelete;\r\n    vipList.length--;\r\n    return true;\r\n  }\r\n  \r\n  function lastVIPkey() public constant returns(uint) {\r\n    //Dealing with arrays in Solidity is painful x_x\r\n    if(vipList.length == 0) return 9999;\r\n    uint limit = vipList.length-1;\r\n    for(uint l=limit; l >= 0; l--) {\r\n        if(vipList[l] != address(0)) {\r\n            return l;\r\n        } \r\n    }\r\n    return 9999;\r\n  }\r\n  \r\n  function lastREG() public view returns (address) {\r\n     return entityList[shift];\r\n  }\r\n  \r\n  function lastVIP() public view returns (address) {\r\n      //Dealing with arrays in Solidity is painful x_x\r\n      if(lastVIPkey() != 9999) {\r\n        return vipList[lastVIPkey()];\r\n      }\r\n      return address(0);\r\n  }\r\n  \r\n  function checkRemaining() public returns (bool) {\r\n      /* If time has come, reset the contract\r\n       * It's public because of possible gas issues, but nothing can happen\r\n       * while now < timeRemaining.add(startedAt)\r\n       */\r\n      if(now >= timeRemaining.add(startedAt)) {\r\n        //Killing VIP struct\r\n        if(vipList.length > 0) {\r\n            uint limit = vipList.length-1;\r\n            for(uint l=limit; l >= 0; l--) {\r\n                if(vipList[l] != address(0)) {\r\n                    entityStructs[vipList[l]].active = false;\r\n                    entityStructs[vipList[l]].vip = false;\r\n                    entityStructs[vipList[l]].date = 0;\r\n                } \r\n            }\r\n        }\r\n        //Killing Regular struct\r\n        if(shift < entityList.length-1) {\r\n            for(uint r = shift; r < entityList.length-1; r++) {\r\n                entityStructs[entityList[r]].active = false;\r\n                entityStructs[entityList[r]].date = 0;\r\n            }\r\n        }\r\n        //Buy me a coffee\r\n        rewardDev();\r\n        //If any ETH stored at contract, send it to latest VIP as a bonus\r\n        if(address(this).balance.sub(devreward) > 0) {\r\n            if(lastVIPkey() != 9999) {\r\n                vipList[lastVIPkey()].transfer(address(this).balance);\r\n            }\r\n        }\r\n        //Switch vars to initial state\r\n        vipList.length=0;\r\n        entityList.length=0;\r\n        shift = 0;\r\n        startedAt = now;\r\n        timeRemaining = 24 hours;\r\n        timetoRegular = true;\r\n        round++;\r\n        return true;\r\n      }\r\n      \r\n      //Decrease timeRemaining: every 100 users in queue divides it by half \r\n      uint range = joined.sub(exited).div(100);\r\n      if(range != 0) {\r\n        timeRemaining = timeRemaining.div(range.mul(2));  \r\n      } \r\n      return false;\r\n  }    \r\n  \r\n  function rewardDev() public {\r\n      //No one can modify devreward constant, it's safe from manipulations\r\n      dev.transfer(devreward);\r\n      devreward = 0;\r\n  }  \r\n  \r\n  function queueVIP() public view returns (address[]) {\r\n      //Return durty queue\r\n      return vipList;\r\n  }\r\n  \r\n  function queueREG() public view returns (address[]) {\r\n      //Return durty queue\r\n      return entityList;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n   /* \r\n    * Message to other devs:\r\n    * Dealing with arrays in Solidity is a pain. Here we realized some supa dupa methods\r\n    * and decreased gas limit up to 200k. \r\n    * Lame auditors who can't understand the code, ping me at Discord.\r\n    * IF YOU RIP THIS CODE YOU WILL DIE WITH CANCER\r\n    */\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getVipCount\",\"outputs\":[{\"name\":\"entityCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shift\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timetoRegular\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entityList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devreward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityStructs\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"listPointer\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"},{\"name\":\"update\",\"type\":\"uint256\"},{\"name\":\"exit\",\"type\":\"uint256\"},{\"name\":\"profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastREG\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rewardDev\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vipList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queueVIP\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joined\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queueREG\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastVIP\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastVIPkey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"XKnockoutHamster","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://daf47e41ff6603f0153b7fcec8faa73f6505eaa0ca1e962a26e1099c0986f740"}]}