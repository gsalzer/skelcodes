{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/* -Team- beta\r\n *                                ┌────────────────────┐\r\n *                                │ Setup Instructions │\r\n *                                └────────────────────┘\r\n * (Step 1) import this contracts interface into your contract\r\n * \r\n *    import \"./TeamInterface.sol\";\r\n *\r\n * (Step 2) set up the interface to point to the Team contract\r\n * \r\n *    TeamInterface constant Team = TeamInterface(0x464904238b5CdBdCE12722A7E6014EC1C0B66928);\r\n *\r\n *    modifier onlyAdmins() {require(Team.isAdmin(msg.sender) == true, \"onlyAdmins failed - msg.sender is not an admin\"); _;}\r\n *    modifier onlyDevs() {require(Team.isDev(msg.sender) == true, \"onlyDevs failed - msg.sender is not a dev\"); _;}\r\n *                                ┌────────────────────┐\r\n *                                │ Usage Instructions │\r\n *                                └────────────────────┘\r\n * use onlyAdmins() and onlyDevs() modifiers as you normally would on any function\r\n * you wish to restrict to admins/devs registered with this contract.\r\n * \r\n * to get required signatures for admins or devs\r\n *       uint256 x = Team.requiredSignatures();\r\n *       uint256 x = Team.requiredDevSignatures();\r\n * \r\n * to get admin count or dev count \r\n *       uint256 x = Team.adminCount();\r\n *       uint256 x = Team.devCount();\r\n * \r\n * to get the name of an admin (in bytes32 format)\r\n *       bytes32 x = Team.adminName(address);\r\n */\r\n\r\ncontract Team {\r\n    address private Team = 0x0;\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // SET UP MSFun (note, check signers by name is modified from MSFun sdk)\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    MSFun.Data private msData;\r\n    function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function checkData(bytes32 _whatFunction) onlyAdmins() public view returns(bytes32 message_data, uint256 signature_count) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n    function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(bytes32, bytes32, bytes32) {return(this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETUP\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    struct Admin {\r\n        bool isAdmin;\r\n        bool isDev;\r\n        bytes32 name;\r\n    }\r\n    mapping (address => Admin) admins_;\r\n    \r\n    uint256 adminCount_;\r\n    uint256 devCount_;\r\n    uint256 requiredSignatures_;\r\n    uint256 requiredDevSignatures_;\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // CONSTRUCTOR\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    constructor()\r\n        public\r\n    {\r\n\t\taddress deployer = 0x4a1061afb0af7d9f6c2d545ada068da68052c060;\r\n        \r\n\t\tadmins_[deployer] = Admin(true, true, \"deployer\");\r\n        \r\n        adminCount_ = 1;\r\n        devCount_ = 1;\r\n        requiredSignatures_ = 1;\r\n        requiredDevSignatures_ = 1;\r\n    }\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // FALLBACK, SETUP, AND FORWARD\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // there should never be a balance in this contract.  but if someone\r\n    // does stupidly send eth here for some reason.  we can forward it \r\n    // to team\r\n    function ()\r\n        public\r\n        payable\r\n    {\r\n        Team.transfer(address(this).balance);\r\n    }\r\n    \r\n    function setup(address _addr)\r\n        onlyDevs()\r\n        public\r\n    {\r\n        require( address(Team) == address(0) );\r\n        Team = _addr;\r\n    }    \r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MODIFIERS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    modifier onlyDevs()\r\n    {\r\n        require(admins_[msg.sender].isDev == true, \"onlyDevs failed - msg.sender is not a dev\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyAdmins()\r\n    {\r\n        require(admins_[msg.sender].isAdmin == true, \"onlyAdmins failed - msg.sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DEV ONLY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    /**\r\n    * @dev DEV - use this to add admins.  this is a dev only function.\r\n    * @param _who - address of the admin you wish to add\r\n    * @param _name - admins name\r\n    * @param _isDev - is this admin also a dev?\r\n    */\r\n    function addAdmin(address _who, bytes32 _name, bool _isDev)\r\n        public\r\n        onlyDevs()\r\n    {\r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"addAdmin\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"addAdmin\");\r\n            \r\n            // must check this so we dont mess up admin count by adding someone\r\n            // who is already an admin\r\n            if (admins_[_who].isAdmin == false) \r\n            { \r\n                \r\n                // set admins flag to true in admin mapping\r\n                admins_[_who].isAdmin = true;\r\n        \r\n                // adjust admin count and required signatures\r\n                adminCount_ += 1;\r\n                requiredSignatures_ += 1;\r\n            }\r\n            \r\n            // are we setting them as a dev?\r\n            // by putting this outside the above if statement, we can upgrade existing\r\n            // admins to devs.\r\n            if (_isDev == true) \r\n            {\r\n                // bestow the honored dev status\r\n                admins_[_who].isDev = _isDev;\r\n                \r\n                // increase dev count and required dev signatures\r\n                devCount_ += 1;\r\n                requiredDevSignatures_ += 1;\r\n            }\r\n        }\r\n        \r\n        // by putting this outside the above multisig, we can allow easy name changes\r\n        // without having to bother with multisig.  this will still create a proposal though\r\n        // so use the deleteAnyProposal to delete it if you want to\r\n        admins_[_who].name = _name;\r\n    }\r\n\r\n    /**\r\n    * @dev DEV - use this to remove admins. this is a dev only function.\r\n    * -requirements: never less than 1 admin\r\n    *                never less than 1 dev\r\n    *                never less admins than required signatures\r\n    *                never less devs than required dev signatures\r\n    * @param _who - address of the admin you wish to remove\r\n    */\r\n    function removeAdmin(address _who)\r\n        public\r\n        onlyDevs()\r\n    {\r\n        // we can put our requires outside the multisig, this will prevent\r\n        // creating a proposal that would never pass checks anyway.\r\n        require(adminCount_ > 1, \"removeAdmin failed - cannot have less than 2 admins\");\r\n        require(adminCount_ >= requiredSignatures_, \"removeAdmin failed - cannot have less admins than number of required signatures\");\r\n        if (admins_[_who].isDev == true)\r\n        {\r\n            require(devCount_ > 1, \"removeAdmin failed - cannot have less than 2 devs\");\r\n            require(devCount_ >= requiredDevSignatures_, \"removeAdmin failed - cannot have less devs than number of required dev signatures\");\r\n        }\r\n        \r\n        // checks passed\r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"removeAdmin\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"removeAdmin\");\r\n            \r\n            // must check this so we dont mess up admin count by removing someone\r\n            // who wasnt an admin to start with\r\n            if (admins_[_who].isAdmin == true) {  \r\n                \r\n                //set admins flag to false in admin mapping\r\n                admins_[_who].isAdmin = false;\r\n                \r\n                //adjust admin count and required signatures\r\n                adminCount_ -= 1;\r\n                if (requiredSignatures_ > 1) \r\n                {\r\n                    requiredSignatures_ -= 1;\r\n                }\r\n            }\r\n            \r\n            // were they also a dev?\r\n            if (admins_[_who].isDev == true) {\r\n                \r\n                //set dev flag to false\r\n                admins_[_who].isDev = false;\r\n                \r\n                //adjust dev count and required dev signatures\r\n                devCount_ -= 1;\r\n                if (requiredDevSignatures_ > 1) \r\n                {\r\n                    requiredDevSignatures_ -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev DEV - change the number of required signatures.  must be between\r\n    * 1 and the number of admins.  this is a dev only function\r\n    * @param _howMany - desired number of required signatures\r\n    */\r\n    function changeRequiredSignatures(uint256 _howMany)\r\n        public\r\n        onlyDevs()\r\n    {  \r\n        // make sure its between 1 and number of admins\r\n        require(_howMany > 0 && _howMany <= adminCount_, \"changeRequiredSignatures failed - must be between 1 and number of admins\");\r\n        \r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"changeRequiredSignatures\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"changeRequiredSignatures\");\r\n            \r\n            // store new setting.\r\n            requiredSignatures_ = _howMany;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev DEV - change the number of required dev signatures.  must be between\r\n    * 1 and the number of devs.  this is a dev only function\r\n    * @param _howMany - desired number of required dev signatures\r\n    */\r\n    function changeRequiredDevSignatures(uint256 _howMany)\r\n        public\r\n        onlyDevs()\r\n    {  \r\n        // make sure its between 1 and number of admins\r\n        require(_howMany > 0 && _howMany <= devCount_, \"changeRequiredDevSignatures failed - must be between 1 and number of devs\");\r\n        \r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"changeRequiredDevSignatures\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"changeRequiredDevSignatures\");\r\n            \r\n            // store new setting.\r\n            requiredDevSignatures_ = _howMany;\r\n        }\r\n    }\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // EXTERNAL FUNCTIONS \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function requiredSignatures() external view returns(uint256) {return(requiredSignatures_);}\r\n    function requiredDevSignatures() external view returns(uint256) {return(requiredDevSignatures_);}\r\n    function adminCount() external view returns(uint256) {return(adminCount_);}\r\n    function devCount() external view returns(uint256) {return(devCount_);}\r\n    function adminName(address _who) external view returns(bytes32) {return(admins_[_who].name);}\r\n    function isAdmin(address _who) external view returns(bool) {return(admins_[_who].isAdmin);}\r\n    function isDev(address _who) external view returns(bool) {return(admins_[_who].isDev);}\r\n}\r\n\r\nlibrary MSFun {\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // contact data setup\r\n    struct Data \r\n    {\r\n        mapping (bytes32 => ProposalData) proposal_;\r\n    }\r\n    struct ProposalData \r\n    {\r\n        // a hash of msg.data \r\n        bytes32 msgData;\r\n        // number of signers\r\n        uint256 count;\r\n        // tracking of wither admins have signed\r\n        mapping (address => bool) admin;\r\n        // list of admins who have signed\r\n        mapping (uint256 => address) log;\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MULTI SIG FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function multiSig(Data storage self, uint256 _requiredSignatures, bytes32 _whatFunction)\r\n        internal\r\n        returns(bool) \r\n    {\r\n        // our proposal key will be a hash of our function name + our contracts address \r\n        // by adding our contracts address to this, we prevent anyone trying to circumvent\r\n        // the proposal's security via external calls.\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        \r\n        // this is just done to make the code more readable.  grabs the signature count\r\n        uint256 _currentCount = self.proposal_[_whatProposal].count;\r\n        \r\n        // store the address of the person sending the function call.  we use msg.sender \r\n        // here as a layer of security.  in case someone imports our contract and tries to \r\n        // circumvent function arguments.  still though, our contract that imports this\r\n        // library and calls multisig, needs to use onlyAdmin modifiers or anyone who\r\n        // calls the function will be a signer. \r\n        address _whichAdmin = msg.sender;\r\n        \r\n        // prepare our msg data.  by storing this we are able to verify that all admins\r\n        // are approving the same argument input to be executed for the function.  we hash \r\n        // it and store in bytes32 so its size is known and comparable\r\n        bytes32 _msgData = keccak256(msg.data);\r\n        \r\n        // check to see if this is a new execution of this proposal or not\r\n        if (_currentCount == 0)\r\n        {\r\n            // if it is, lets record the original signers data\r\n            self.proposal_[_whatProposal].msgData = _msgData;\r\n            \r\n            // record original senders signature\r\n            self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n            \r\n            // update log (used to delete records later, and easy way to view signers)\r\n            // also useful if the calling function wants to give something to a \r\n            // specific signer.  \r\n            self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n            \r\n            // track number of signatures\r\n            self.proposal_[_whatProposal].count += 1;  \r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.  we put this here in case the required signatures\r\n            // is set to 1.\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }            \r\n        // if its not the first execution, lets make sure the msgData matches\r\n        } else if (self.proposal_[_whatProposal].msgData == _msgData) {\r\n            // msgData is a match\r\n            // make sure admin hasnt already signed\r\n            if (self.proposal_[_whatProposal].admin[_whichAdmin] == false) \r\n            {\r\n                // record their signature\r\n                self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n                \r\n                // update log (used to delete records later, and easy way to view signers)\r\n                self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n                \r\n                // track number of signatures\r\n                self.proposal_[_whatProposal].count += 1;  \r\n            }\r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.\r\n            // we put this here for a few reasons.  (1) in normal operation, if \r\n            // that last recorded signature got us to our required signatures.  we \r\n            // need to return bool of true.  (2) if we have a situation where the \r\n            // required number of signatures was adjusted to at or lower than our current \r\n            // signature count, by putting this here, an admin who has already signed,\r\n            // can call the function again to make it return a true bool.  but only if\r\n            // they submit the correct msg data\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    // deletes proposal signature data after successfully executing a multiSig function\r\n    function deleteProposal(Data storage self, bytes32 _whatFunction)\r\n        internal\r\n    {\r\n        //done for readability sake\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        address _whichAdmin;\r\n        \r\n        //delete the admins votes & log.   i know for loops are terrible.  but we have to do this \r\n        //for our data stored in mappings.  simply deleting the proposal itself wouldn't accomplish this.\r\n        for (uint256 i=0; i < self.proposal_[_whatProposal].count; i++) {\r\n            _whichAdmin = self.proposal_[_whatProposal].log[i];\r\n            delete self.proposal_[_whatProposal].admin[_whichAdmin];\r\n            delete self.proposal_[_whatProposal].log[i];\r\n        }\r\n        //delete the rest of the data in the record\r\n        delete self.proposal_[_whatProposal];\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // HELPER FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    function whatProposal(bytes32 _whatFunction)\r\n        private\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return(keccak256(abi.encodePacked(_whatFunction,this)));\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // VANITY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // returns a hashed version of msg.data sent by original signer for any given function\r\n    function checkMsgData (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (bytes32 msg_data)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].msgData);\r\n    }\r\n    \r\n    // returns number of signers for any given function\r\n    function checkCount (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (uint256 signature_count)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].count);\r\n    }\r\n    \r\n    // returns address of an admin who signed for any given function\r\n    function checkSigner (Data storage self, bytes32 _whatFunction, uint256 _signer)\r\n        internal\r\n        view\r\n        returns (address signer)\r\n    {\r\n        require(_signer > 0, \"MSFun checkSigner failed - 0 not allowed\");\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].log[_signer - 1]);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"isDev\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"}],\"name\":\"deleteAnyProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_howMany\",\"type\":\"uint256\"}],\"name\":\"changeRequiredDevSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_isDev\",\"type\":\"bool\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_howMany\",\"type\":\"uint256\"}],\"name\":\"changeRequiredSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"}],\"name\":\"checkData\",\"outputs\":[{\"name\":\"message_data\",\"type\":\"bytes32\"},{\"name\":\"signature_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"adminName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"},{\"name\":\"_signerA\",\"type\":\"uint256\"},{\"name\":\"_signerB\",\"type\":\"uint256\"},{\"name\":\"_signerC\",\"type\":\"uint256\"}],\"name\":\"checkSignersByName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredDevSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Team","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3cbd665c60419010baf935f9ec3005e9c0bf15a215d58597fe49ecef898bc6b7"}]}