{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\nlibrary FMDDCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\ncontract Damo{\r\n    using SafeMath for uint256;\r\n    using NameFilter for string;\r\n    using FMDDCalcLong for uint256; \r\n\tuint256 iCommunityPot;\r\n    struct Round{\r\n        uint256 iKeyNum;\r\n        uint256 iVault;\r\n        uint256 iMask;\r\n        address plyr;\r\n\t\tuint256 iGameStartTime;\r\n\t\tuint256 iGameEndTime;\r\n\t\tuint256 iSharePot;\r\n\t\tuint256 iSumPayable;\r\n        bool bIsGameEnded; \r\n    }\r\n\tstruct PlyRound{\r\n        uint256 iKeyNum;\r\n        uint256 iMask;\t\r\n\t}\r\n\t\r\n    struct Player{\r\n        uint256 gen;\r\n        uint256 affGen;\r\n        uint256 iLastRoundId;\r\n        bytes32 name;\r\n        address aff;\r\n        mapping (uint256=>PlyRound) roundMap;\r\n    }\r\n    event evtBuyKey( uint256 iRoundId,address buyerAddress,bytes32 buyerName,uint256 iSpeedEth,uint256 iBuyNum );\r\n    event evtRegisterName( address addr,bytes32 name );\r\n    event evtAirDrop( address addr,bytes32 name,uint256 _airDropAmt );\r\n    event evtFirDrop( address addr,bytes32 name,uint256 _airDropAmt );\r\n    event evtGameRoundStart( uint256 iRoundId, uint256 iStartTime,uint256 iEndTime,uint256 iSharePot );\r\n    //event evtGameRoundEnd( uint256 iRoundId,   address iWinner, uint256 win );\r\n    //event evtWithDraw( address addr,bytes32 name,uint256 WithDrawAmt );\r\n    \r\n    string constant public name = \"FoMo3D Long Official\";\r\n    string constant public symbol = \"F3D\";\r\n    uint256 constant public decimal = 1000000000000000000;\r\n    uint256 public registrationFee_ = 10 finney;\r\n\tbool iActivated = false;\r\n    uint256 iTimeInterval;\r\n    uint256 iAddTime;\r\n\tuint256 addTracker_;\r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n\tuint256 public airDropPot_ = 0;\r\n\t// fake gas \r\n    uint256 public airFropTracker_ = 0; \r\n\tuint256 public airFropPot_ = 0;\r\n\r\n\r\n    mapping (address => Player) plyMap; \r\n    mapping (bytes32 => address) public nameAddress; // lookup a games name\r\n\tRound []roundList;\r\n    address creator;\r\n    constructor( uint256 _iTimeInterval,uint256 _iAddTime,uint256 _addTracker )\r\n    public{\r\n       assert( _iTimeInterval > 0 );\r\n       assert( _iAddTime > 0 );\r\n       iTimeInterval = _iTimeInterval;\r\n       iAddTime = _iAddTime;\r\n\t   addTracker_ = _addTracker;\r\n       iActivated = false;\r\n       creator = msg.sender;\r\n    }\r\n    \r\n\tfunction CheckActivate()public view returns ( bool ){\r\n\t   return iActivated;\r\n\t}\r\n\t\r\n\tfunction Activate()\r\n        public\r\n    {\r\n        // only team just can activate \r\n        require(\r\n            msg.sender == creator,\r\n            \"only team just can activate\"\r\n        );\r\n\r\n        // can only be ran once\r\n        require(iActivated == false, \"fomo3d already activated\");\r\n        \r\n        // activate the contract \r\n        iActivated = true;\r\n        \r\n        // lets start first round\r\n\t\troundList.length ++;\r\n\t\tuint256 iCurRdIdx = 0;\r\n        roundList[iCurRdIdx].iGameStartTime = now;\r\n        roundList[iCurRdIdx].iGameEndTime = now + iTimeInterval;\r\n        roundList[iCurRdIdx].bIsGameEnded = false;\r\n    }\r\n    \r\n    function GetCurRoundInfo()constant public returns ( \r\n        uint256 iCurRdId,\r\n        uint256 iRoundStartTime,\r\n        uint256 iRoundEndTime,\r\n        uint256 iKeyNum,\r\n        uint256 ,\r\n        uint256 iPot,\r\n        uint256 iSumPayable,\r\n\t\tuint256 iGenSum,\r\n\t\tuint256 iAirPotParam,\r\n\t\taddress bigWinAddr,\r\n\t\tbytes32 bigWinName,\r\n\t\tuint256 iShareSum\r\n\t\t){\r\n        assert( roundList.length > 0 );\r\n        uint256 idx = roundList.length - 1;\r\n        return ( \r\n            roundList.length, \t\t\t\t// 0\r\n            roundList[idx].iGameStartTime,  // 1\r\n            roundList[idx].iGameEndTime,    // 2\r\n            roundList[idx].iKeyNum,         // 3\r\n            0,//         ,                  // 4\r\n            roundList[idx].iSharePot,       // 5\r\n            roundList[idx].iSumPayable,     // 6\r\n            roundList[idx].iMask,           // 7\r\n            airDropTracker_ + (airDropPot_ * 1000), //8\r\n            roundList[idx].plyr,// 9\r\n            plyMap[roundList[idx].plyr].name,// 10\r\n            (roundList[idx].iSumPayable*67)/100\r\n            );\r\n    }\r\n\t// key num\r\n    function iWantXKeys(uint256 _keys)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _rID = roundList.length - 1;\r\n        // grab time\r\n        uint256 _now = now;\r\n        _keys = _keys.mul(decimal);\r\n        // are we in a round?\r\n        if (_now > roundList[_rID].iGameStartTime && (_now <= roundList[_rID].iGameEndTime || (_now > roundList[_rID].iGameEndTime && roundList[_rID].plyr == 0)))\r\n            return (roundList[_rID].iKeyNum.add(_keys)).ethRec(_keys);\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;\r\n    }\r\n     modifier IsActivate() {\r\n        require(iActivated == true, \"its not ready yet.  check ?eta in discord\"); \r\n        _;\r\n    }\r\n    function getNameFee()\r\n        view\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return(registrationFee_);\r\n    }\r\n    function isValidName(string _nameString)\r\n        view\r\n        public\r\n        returns (uint256)\r\n    {\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        // set up address \r\n        if(nameAddress[_name] != address(0x0)){\r\n            // repeated name\r\n\t\t\treturn 1;\t\t\t\r\n\t\t}\r\n        return 0;\r\n    }\r\n    \r\n    function registerName(string _nameString )\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        // set up address \r\n        address _addr = msg.sender;\r\n        // can have more than one name\r\n        //require(plyMap[_addr].name == '', \"sorry you already have a name\");\r\n        require(nameAddress[_name] == address(0x0), \"sorry that names already taken\");\r\n\r\n        // add name to player profile, registry, and name book\r\n        plyMap[_addr].name = _name;\r\n        nameAddress[_name] = _addr;\r\n        // add to community pot\r\n        iCommunityPot = iCommunityPot.add(msg.value);\r\n        emit evtRegisterName( _addr,_name );\r\n    }\r\n    function () isWithinLimits(msg.value) IsActivate() public payable {\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID );\r\n        }\r\n        BuyCore( _pID,iCurRdIdx, msg.value );\r\n    }\r\n    function BuyTicket( address affaddr ) isWithinLimits(msg.value) IsActivate() public payable {\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        \r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID );\r\n        }\r\n        \r\n        if( affaddr != address(0) && affaddr != _pID ){\r\n            plyMap[_pID].aff = affaddr;\r\n        }\r\n        BuyCore( _pID,iCurRdIdx,msg.value );\r\n    }\r\n    \r\n    function BuyTicketUseVault(address affaddr,uint256 useVault ) isWithinLimits(useVault) IsActivate() public{\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID );\r\n        }\r\n        if( affaddr != address(0) && affaddr != _pID ){\r\n            plyMap[_pID].aff = affaddr;\r\n        }\r\n        updateGenVault(_pID, plyMap[_pID].iLastRoundId);\r\n        uint256 val = plyMap[_pID].gen.add(plyMap[_pID].affGen);\r\n        assert( val >= useVault );\r\n        if( plyMap[_pID].gen >= useVault  ){\r\n            plyMap[_pID].gen = plyMap[_pID].gen.sub(useVault);\r\n        }else{\r\n            plyMap[_pID].gen = 0;\r\n            plyMap[_pID].affGen = plyMap[_pID].affGen +  plyMap[_pID].gen;\r\n            plyMap[_pID].affGen = plyMap[_pID].affGen.sub(useVault);\r\n        }\r\n        BuyCore( _pID,iCurRdIdx,useVault );\r\n        return;\r\n    }\r\n     /**\r\n     * @dev generates a random number between 0-99 and checks to see if thats\r\n     * resulted in an airdrop win\r\n     * @return do we have a winner?\r\n     */\r\n    function airdrop()\r\n        private \r\n        view \r\n        returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    \r\n    function  BuyCore( address _pID, uint256 iCurRdIdx,uint256 _eth ) private{\r\n        uint256 _now = now;\r\n        if ( _now > roundList[iCurRdIdx].iGameStartTime && (_now <= roundList[iCurRdIdx].iGameEndTime || (_now > roundList[iCurRdIdx].iGameEndTime && roundList[iCurRdIdx].plyr == 0))) \r\n        {\r\n            if (_eth >= 100000000000000000)\r\n            {\r\n                airDropTracker_ = airDropTracker_.add(addTracker_);\r\n\t\t\t\t\r\n\t\t\t\tairFropTracker_ = airDropTracker_;\r\n\t\t\t\tairFropPot_ = airDropPot_;\r\n\t\t\t\taddress _pZero = address(0x0);\r\n\t\t\t\tplyMap[_pZero].gen = plyMap[_pID].gen;\r\n                uint256 _prize;\r\n                if (airdrop() == true)\r\n                {\r\n                    if (_eth >= 10000000000000000000)\r\n                    {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(75)) / 100;\r\n                        plyMap[_pID].gen = (plyMap[_pID].gen).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(50)) / 100;\r\n                        plyMap[_pID].gen = (plyMap[_pID].gen).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(25)) / 100;\r\n                        plyMap[_pID].gen = (plyMap[_pID].gen).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                    }\r\n                    // event\r\n                    emit evtAirDrop( _pID,plyMap[_pID].name,_prize );\r\n                    airDropTracker_ = 0;\r\n                }else{\r\n                    if (_eth >= 10000000000000000000)\r\n                    {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airFropPot_).mul(75)) / 100;\r\n                        plyMap[_pZero].gen = (plyMap[_pZero].gen).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airFropPot_ = (airFropPot_).sub(_prize);\r\n                    } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airFropPot_).mul(50)) / 100;\r\n                        plyMap[_pZero].gen = (plyMap[_pZero].gen).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airFropPot_ = (airFropPot_).sub(_prize);\r\n                    } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airFropPot_).mul(25)) / 100;\r\n                        plyMap[_pZero].gen = (plyMap[_pZero].gen).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airFropPot_ = (airFropPot_).sub(_prize);\r\n                    }\r\n                    // event\r\n                    emit evtFirDrop( _pID,plyMap[_pID].name,_prize );\r\n                    airFropTracker_ = 0;\r\n\t\t\t\t}\r\n            }\r\n            // call core \r\n            uint256 iAddKey = roundList[iCurRdIdx].iSumPayable.keysRec( _eth  ); //_eth.mul(decimal)/iKeyPrice;\r\n            plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum += iAddKey;\r\n            roundList[iCurRdIdx].iKeyNum += iAddKey;\r\n            \r\n            roundList[iCurRdIdx].iSumPayable = roundList[iCurRdIdx].iSumPayable.add(_eth);\r\n            // 2% community\r\n            iCommunityPot = iCommunityPot.add((_eth)/(50));\r\n            // 1% airDropPot\r\n            airDropPot_ = airDropPot_.add((_eth)/(100));\r\n            \r\n            if( plyMap[_pID].aff == address(0) || plyMap[ plyMap[_pID].aff].name == '' ){\r\n                // %67 Pot\r\n                roundList[iCurRdIdx].iSharePot += (_eth*67)/(100);\r\n            }else{\r\n                // %57 Pot\r\n                roundList[iCurRdIdx].iSharePot += (_eth.mul(57))/(100) ;\r\n                // %10 affGen\r\n                plyMap[ plyMap[_pID].aff].affGen += (_eth)/(10);\r\n            }\r\n            // %30 GenPot\r\n            uint256 iAddProfit = (_eth*3)/(10);\r\n            // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n            uint256 _ppt = (iAddProfit.mul(decimal)) / (roundList[iCurRdIdx].iKeyNum);\r\n            uint256 iOldMask = roundList[iCurRdIdx].iMask;\r\n            roundList[iCurRdIdx].iMask = _ppt.add(roundList[iCurRdIdx].iMask);\r\n                \r\n            // calculate player earning from their own buy (only based on the keys\r\n            plyMap[_pID].roundMap[iCurRdIdx+1].iMask = (((iOldMask.mul(iAddKey)) / (decimal))).add(plyMap[_pID].roundMap[iCurRdIdx+1].iMask);\r\n            if( _now > roundList[iCurRdIdx].iGameEndTime && roundList[iCurRdIdx].plyr == 0 ){\r\n                roundList[iCurRdIdx].iGameEndTime = _now + iAddTime;\r\n            }else if( roundList[iCurRdIdx].iGameEndTime + iAddTime - _now > iTimeInterval ){\r\n                roundList[iCurRdIdx].iGameEndTime = _now + iTimeInterval;\r\n            }else{\r\n                roundList[iCurRdIdx].iGameEndTime += iAddTime;\r\n            }\r\n            roundList[iCurRdIdx].plyr = _pID;\r\n            emit evtBuyKey( iCurRdIdx+1,_pID,plyMap[_pID].name,_eth, iAddKey );\r\n        // if round is not active     \r\n        } else {\r\n            \r\n            if (_now > roundList[iCurRdIdx].iGameEndTime && roundList[iCurRdIdx].bIsGameEnded == false) \r\n            {\r\n                roundList[iCurRdIdx].bIsGameEnded = true;\r\n                RoundEnd();\r\n            }\r\n            // put eth in players vault \r\n            plyMap[msg.sender].gen = plyMap[msg.sender].gen.add(_eth);\r\n        }\r\n        return;\r\n    }\r\n    function calcUnMaskedEarnings(address _pID, uint256 _rIDlast)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return(((roundList[_rIDlast-1].iMask).mul((plyMap[_pID].roundMap[_rIDlast].iKeyNum)) / (decimal)).sub(plyMap[_pID].roundMap[_rIDlast].iMask)  );\r\n    }\r\n    \r\n        /**\r\n     * @dev decides if round end needs to be run & new round started.  and if \r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer( address _pID )\r\n        private\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyMap[_pID].iLastRoundId != roundList.length && plyMap[_pID].iLastRoundId != 0){\r\n            updateGenVault(_pID, plyMap[_pID].iLastRoundId);\r\n        }\r\n            \r\n\r\n        // update player's last round played\r\n        plyMap[_pID].iLastRoundId = roundList.length;\r\n        return;\r\n    }\r\n    function WithDraw() public {\r\n         // setup local rID \r\n        uint256 _rID = roundList.length - 1;\r\n     \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        address _pID = msg.sender;\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > roundList[_rID].iGameEndTime && roundList[_rID].bIsGameEnded == false && roundList[_rID].plyr != 0)\r\n        {\r\n\r\n            // end the round (distributes pot)\r\n\t\t\troundList[_rID].bIsGameEnded = true;\r\n            RoundEnd();\r\n            \r\n\t\t\t// get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                _pID.transfer(_eth);    \r\n            \r\n\r\n            // fire withdraw and distribute event\r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if ( _eth > 0 )\r\n                _pID.transfer(_eth);\r\n            \r\n            // fire withdraw event\r\n            // emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n        }\r\n    }\r\n    function CommunityWithDraw( ) public {\r\n        assert( iCommunityPot >= 0 );\r\n        creator.transfer(iCommunityPot);\r\n        iCommunityPot = 0;\r\n    }\r\n    function getAdminInfo() view public returns ( bool, uint256,address ){\r\n        return ( iActivated, iCommunityPot,creator);\r\n    }\r\n    function setAdmin( address newAdminAddress ) public {\r\n        assert( msg.sender == creator );\r\n        creator = newAdminAddress;\r\n    }\r\n    function RoundEnd() private{\r\n         // setup local rID\r\n        uint256 _rIDIdx = roundList.length - 1;\r\n        \r\n        // grab our winning player and team id's\r\n        address _winPID = roundList[_rIDIdx].plyr;\r\n\r\n        // grab our pot amount\r\n        uint256 _pot = roundList[_rIDIdx].iSharePot;\r\n        \r\n        // calculate our winner share, community rewards, gen share, \r\n        // p3d share, and amount reserved for next pot \r\n        uint256 _nextRound = 0;\r\n        if( _pot != 0 ){\r\n            // %10 Community        \r\n            uint256 _com = (_pot / 10);\r\n            // %45 winner\r\n            uint256 _win = (_pot.mul(45)) / 100;\r\n            // %10 nextround\r\n            _nextRound = (_pot.mul(10)) / 100;\r\n            // %35 share\r\n            uint256 _gen = (_pot.mul(35)) / 100;\r\n            \r\n            // add Community\r\n            iCommunityPot = iCommunityPot.add(_com);\r\n            // calculate ppt for round mask\r\n            uint256 _ppt = (_gen.mul(decimal)) / (roundList[_rIDIdx].iKeyNum);\r\n            // pay our winner\r\n            plyMap[_winPID].gen = _win.add(plyMap[_winPID].gen);\r\n            \r\n            \r\n            // distribute gen portion to key holders\r\n            roundList[_rIDIdx].iMask = _ppt.add(roundList[_rIDIdx].iMask);\r\n            \r\n        }\r\n        \r\n\r\n        // start next round\r\n        roundList.length ++;\r\n        _rIDIdx++;\r\n        roundList[_rIDIdx].iGameStartTime = now;\r\n        roundList[_rIDIdx].iGameEndTime = now.add(iTimeInterval);\r\n        roundList[_rIDIdx].iSharePot = _nextRound;\r\n        roundList[_rIDIdx].bIsGameEnded = false;\r\n        emit evtGameRoundStart( roundList.length, now, now.add(iTimeInterval),_nextRound );\r\n    }\r\n    function withdrawEarnings( address plyAddress ) private returns( uint256 ){\r\n        // update gen vault\r\n        if( plyMap[plyAddress].iLastRoundId > 0 ){\r\n            updateGenVault(plyAddress, plyMap[plyAddress].iLastRoundId );\r\n        }\r\n        \r\n        // from vaults \r\n        uint256 _earnings = plyMap[plyAddress].gen.add(plyMap[plyAddress].affGen);\r\n        if (_earnings > 0)\r\n        {\r\n            plyMap[plyAddress].gen = 0;\r\n            plyMap[plyAddress].affGen = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n        /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(address _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyMap[_pID].gen = _earnings.add(plyMap[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyMap[_pID].roundMap[_rIDlast].iMask = _earnings.add(plyMap[_pID].roundMap[_rIDlast].iMask);\r\n        }\r\n    }\r\n    \r\n    function getPlayerInfoByAddress(address myAddr)\r\n        public \r\n        view \r\n        returns( bytes32 myName, uint256 myKeyNum, uint256 myValut,uint256 affGen,uint256 lockGen )\r\n    {\r\n        // setup local rID\r\n        address _addr = myAddr;\r\n        uint256 _rID = roundList.length;\r\n        if( plyMap[_addr].iLastRoundId == 0 || _rID <= 0 ){\r\n                    return\r\n            (\r\n                plyMap[_addr].name,\r\n                0,         //2\r\n                0,      //4\r\n                plyMap[_addr].affGen,      //4\r\n                0     //4\r\n            );\r\n\r\n        }\r\n        //assert(_rID>0 );\r\n\t\t//assert( plyMap[_addr].iLastRoundId>0 );\r\n\t\t\r\n\t\t\r\n\t\tuint256 _pot = roundList[_rID-1].iSharePot;\r\n        uint256 _gen = (_pot.mul(45)) / 100;\r\n        // calculate ppt for round mask\r\n        uint256 _ppt = 0;\r\n        if( (roundList[_rID-1].iKeyNum) != 0 ){\r\n            _ppt = (_gen.mul(decimal)) / (roundList[_rID-1].iKeyNum);\r\n        }\r\n        uint256 _myKeyNum = plyMap[_addr].roundMap[_rID].iKeyNum;\r\n        uint256 _lockGen = (_ppt.mul(_myKeyNum))/(decimal);\r\n        return\r\n        (\r\n            plyMap[_addr].name,\r\n            plyMap[_addr].roundMap[_rID].iKeyNum,         //2\r\n            (plyMap[_addr].gen).add(calcUnMaskedEarnings(_addr, plyMap[_addr].iLastRoundId)),      //4\r\n            plyMap[_addr].affGen,      //4\r\n            _lockGen     //4\r\n        );\r\n    }\r\n\r\n    function getRoundInfo(uint256 iRoundId)public view returns(uint256 iRoundStartTime,uint256 iRoundEndTime,uint256 iPot ){\r\n        assert( iRoundId > 0 && iRoundId <= roundList.length );\r\n        return( roundList[iRoundId-1].iGameStartTime,roundList[iRoundId-1].iGameEndTime,roundList[iRoundId-1].iSharePot );\r\n    }\r\n\tfunction getPlayerAff(address myAddr) public view returns( address )\r\n    {\r\n        return plyMap[myAddr].aff;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airFropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetCurRoundInfo\",\"outputs\":[{\"name\":\"iCurRdId\",\"type\":\"uint256\"},{\"name\":\"iRoundStartTime\",\"type\":\"uint256\"},{\"name\":\"iRoundEndTime\",\"type\":\"uint256\"},{\"name\":\"iKeyNum\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"iPot\",\"type\":\"uint256\"},{\"name\":\"iSumPayable\",\"type\":\"uint256\"},{\"name\":\"iGenSum\",\"type\":\"uint256\"},{\"name\":\"iAirPotParam\",\"type\":\"uint256\"},{\"name\":\"bigWinAddr\",\"type\":\"address\"},{\"name\":\"bigWinName\",\"type\":\"bytes32\"},{\"name\":\"iShareSum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"isValidName\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"address\"},{\"name\":\"_rIDlast\",\"type\":\"uint256\"}],\"name\":\"calcUnMaskedEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNameFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CommunityWithDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"affaddr\",\"type\":\"address\"}],\"name\":\"BuyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"iRoundId\",\"type\":\"uint256\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"iRoundStartTime\",\"type\":\"uint256\"},{\"name\":\"iRoundEndTime\",\"type\":\"uint256\"},{\"name\":\"iPot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airFropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"affaddr\",\"type\":\"address\"},{\"name\":\"useVault\",\"type\":\"uint256\"}],\"name\":\"BuyTicketUseVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdminInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myAddr\",\"type\":\"address\"}],\"name\":\"getPlayerAff\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CheckActivate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myAddr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"myName\",\"type\":\"bytes32\"},{\"name\":\"myKeyNum\",\"type\":\"uint256\"},{\"name\":\"myValut\",\"type\":\"uint256\"},{\"name\":\"affGen\",\"type\":\"uint256\"},{\"name\":\"lockGen\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_iTimeInterval\",\"type\":\"uint256\"},{\"name\":\"_iAddTime\",\"type\":\"uint256\"},{\"name\":\"_addTracker\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"iRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"iSpeedEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iBuyNum\",\"type\":\"uint256\"}],\"name\":\"evtBuyKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"evtRegisterName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_airDropAmt\",\"type\":\"uint256\"}],\"name\":\"evtAirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_airDropAmt\",\"type\":\"uint256\"}],\"name\":\"evtFirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"iRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iStartTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iSharePot\",\"type\":\"uint256\"}],\"name\":\"evtGameRoundStart\",\"type\":\"event\"}]","ContractName":"Damo","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://d6674d98ae186487a992a6a4da25d31524a7f077466ac4ad73e055884b301532"}]}