{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ninterface IOwnable {\r\n    /**\r\n    * @dev Returns owner\r\n    */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for security token proxy deployment\r\n */\r\ninterface ISTFactory {\r\n\r\n    /**\r\n     * @notice Deploys the token and adds default modules like permission manager and transfer manager.\r\n     * Future versions of the proxy can attach different modules or pass some other paramters.\r\n     * @param _name is the name of the Security token\r\n     * @param _symbol is the symbol of the Security Token\r\n     * @param _decimals is the number of decimals of the Security Token\r\n     * @param _tokenDetails is the off-chain data associated with the Security Token\r\n     * @param _issuer is the owner of the Security Token\r\n     * @param _divisible whether the token is divisible or not\r\n     * @param _polymathRegistry is the address of the Polymath Registry contract\r\n     */\r\n    function deployToken(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        string _tokenDetails,\r\n        address _issuer,\r\n        bool _divisible,\r\n        address _polymathRegistry\r\n    )\r\n        external\r\n        returns (address);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Security Token Registry contract\r\n */\r\ninterface ISecurityTokenRegistry {\r\n\r\n   /**\r\n     * @notice Creates a new Security Token and saves it to the registry\r\n     * @param _name Name of the token\r\n     * @param _ticker Ticker ticker of the security token\r\n     * @param _tokenDetails Off-chain details of the token\r\n     * @param _divisible Whether the token is divisible or not\r\n     */\r\n    function generateSecurityToken(string _name, string _ticker, string _tokenDetails, bool _divisible) external;\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _name Name of the token\r\n     * @param _ticker Ticker of the security token\r\n     * @param _owner Owner of the token\r\n     * @param _securityToken Address of the securityToken\r\n     * @param _tokenDetails Off-chain details of the token\r\n     * @param _deployedAt Timestamp at which security token comes deployed on the ethereum blockchain\r\n     */\r\n    function modifySecurityToken(\r\n        string _name,\r\n        string _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Registers the token ticker for its particular owner\r\n     * @notice once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner Address of the owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     */\r\n    function registerTicker(address _owner, string _ticker, string _tokenName) external;\r\n\r\n    /**\r\n    * @notice Changes the protocol version and the SecurityToken contract\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _STFactoryAddress Address of the proxy.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n    * @notice Check that Security Token is registered\r\n    * @param _securityToken Address of the Scurity token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n    /**\r\n     * @notice Get security token address by ticker name\r\n     * @param _ticker Symbol of the Scurity token\r\n     * @return address\r\n     */\r\n    function getSecurityTokenAddress(string _ticker) external view returns (address);\r\n\r\n     /**\r\n     * @notice Get security token data by its address\r\n     * @param _securityToken Address of the Scurity token.\r\n     * @return string Symbol of the Security Token.\r\n     * @return address Address of the issuer of Security Token.\r\n     * @return string Details of the Token.\r\n     * @return uint256 Timestamp at which Security Token get launched on Polymath platform.\r\n     */\r\n    function getSecurityTokenData(address _securityToken) external view returns (string, address, string, uint256);\r\n\r\n    /**\r\n     * @notice Get the current STFactory Address\r\n     */\r\n    function getSTFactoryAddress() external view returns(address);\r\n\r\n    /**\r\n     * @notice Get Protocol version\r\n     */\r\n    function getProtocolVersion() external view returns(uint8[]);\r\n\r\n    /**\r\n     * @notice Used to get the ticker list as per the owner\r\n     * @param _owner Address which owns the list of tickers\r\n     */\r\n    function getTickersByOwner(address _owner) external view returns(bytes32[]);\r\n\r\n    /**\r\n     * @notice Returns the list of tokens owned by the selected address\r\n     * @param _owner is the address which owns the list of tickers\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByOwner(address _owner) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice Returns the owner and timestamp for a given ticker\r\n     * @param _ticker ticker\r\n     * @return address\r\n     * @return uint256\r\n     * @return uint256\r\n     * @return string\r\n     * @return bool\r\n     */\r\n    function getTickerDetails(string _ticker) external view returns (address, uint256, uint256, string, bool);\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only polymath account has the ability\r\n     * to do so. Only allowed to modify the tickers which are not yet deployed\r\n     * @param _owner Owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     * @param _registrationDate Date on which ticker get registered\r\n     * @param _expiryDate Expiry date of the ticker\r\n     * @param _status Token deployed status\r\n     */\r\n    function modifyTicker(\r\n        address _owner,\r\n        string _ticker,\r\n        string _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        external;\r\n\r\n     /**\r\n     * @notice Removes the ticker details and associated ownership & security token mapping\r\n     * @param _ticker Token ticker\r\n     */\r\n    function removeTicker(string _ticker) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of the ticker\r\n     * @dev _newOwner Address whom ownership to transfer\r\n     * @dev _ticker Ticker\r\n     */\r\n    function transferTickerOwnership(address _newOwner, string _ticker) external;\r\n\r\n    /**\r\n     * @notice Changes the expiry time for the token ticker\r\n     * @param _newExpiry New time period for token ticker expiry\r\n     */\r\n    function changeExpiryLimit(uint256 _newExpiry) external;\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in POLY tokens\r\n    * @param _tickerRegFee Registration fee in POLY tokens (base 18 decimals)\r\n    */\r\n   function changeTickerRegistrationFee(uint256 _tickerRegFee) external;\r\n\r\n   /**\r\n    * @notice Sets the ticker registration fee in POLY tokens\r\n    * @param _stLaunchFee Registration fee in POLY tokens (base 18 decimals)\r\n    */\r\n   function changeSecurityLaunchFee(uint256 _stLaunchFee) external;\r\n\r\n    /**\r\n     * @notice Change the PolyToken address\r\n     * @param _newAddress Address of the polytoken\r\n     */\r\n    function updatePolyTokenAddress(address _newAddress) external;\r\n\r\n    /**\r\n     * @notice Gets the security token launch fee\r\n     * @return Fee amount\r\n     */\r\n    function getSecurityTokenLaunchFee() external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Gets the ticker registration fee\r\n     * @return Fee amount\r\n     */\r\n    function getTickerRegistrationFee() external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Gets the expiry limit\r\n     * @return Expiry limit\r\n     */\r\n    function getExpiryLimit() external view returns(uint256);\r\n\r\n    /**\r\n     * @notice Checks whether the registry is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() external view returns(bool);\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address);\r\n\r\n}\r\n\r\ncontract EternalStorage {\r\n\r\n    /// @notice Internal mappings used to store all kinds on data into the contract\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n    mapping(bytes32 => bytes32) internal bytes32Storage;\r\n\r\n    /// @notice Internal mappings used to store arrays of different data types\r\n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\r\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\r\n    mapping(bytes32 => address[]) internal addressArrayStorage;\r\n    mapping(bytes32 => string[]) internal stringArrayStorage;\r\n\r\n    //////////////////\r\n    //// set functions\r\n    //////////////////\r\n    /// @notice Set the key values using the Overloaded `set` functions\r\n    /// Ex- string version = \"0.0.1\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"version\"), \"0.0.1\");\r\n    /// same for the other variables as well some more example listed below\r\n    /// ex1 - address securityTokenAddress = 0x123; replace to\r\n    /// set(keccak256(abi.encodePacked(\"securityTokenAddress\"), 0x123);\r\n    /// ex2 - bytes32 tokenDetails = \"I am ST20\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"tokenDetails\"), \"I am ST20\");\r\n    /// ex3 - mapping(string => address) ownedToken;\r\n    /// set(keccak256(abi.encodePacked(\"ownedToken\", \"Chris\")), 0x123);\r\n    /// ex4 - mapping(string => uint) tokenIndex;\r\n    /// tokenIndex[\"TOKEN\"] = 1; replace to set(keccak256(abi.encodePacked(\"tokenIndex\", \"TOKEN\"), 1);\r\n    /// ex5 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// registeredSymbols[\"TOKEN\"].name = \"MyFristToken\"; replace to set(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"), \"MyFirstToken\");\r\n    /// More generalized- set(keccak256(abi.encodePacked(\"registeredSymbols_<struct variable>\", \"keyname\"), \"value\");\r\n\r\n    function set(bytes32 _key, uint256 _value) internal {\r\n        uintStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, address _value) internal {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bool _value) internal {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bytes32 _value) internal {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, string _value) internal {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    ////////////////////\r\n    /// get functions\r\n    ////////////////////\r\n    /// @notice Get function use to get the value of the singleton state variables\r\n    /// Ex1- string public version = \"0.0.1\";\r\n    /// string _version = getString(keccak256(abi.encodePacked(\"version\"));\r\n    /// Ex2 - assert(temp1 == temp2); replace to\r\n    /// assert(getUint(keccak256(abi.encodePacked(temp1)) == getUint(keccak256(abi.encodePacked(temp2));\r\n    /// Ex3 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// string _name = getString(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"));\r\n\r\n    function getBool(bytes32 _key) internal view returns (bool) {\r\n        return boolStorage[_key];\r\n    }\r\n\r\n    function getUint(bytes32 _key) internal view returns (uint256) {\r\n        return uintStorage[_key];\r\n    }\r\n\r\n    function getAddress(bytes32 _key) internal view returns (address) {\r\n        return addressStorage[_key];\r\n    }\r\n\r\n    function getString(bytes32 _key) internal view returns (string) {\r\n        return stringStorage[_key];\r\n    }\r\n\r\n    function getBytes32(bytes32 _key) internal view returns (bytes32) {\r\n        return bytes32Storage[_key];\r\n    }\r\n\r\n\r\n    ////////////////////////////\r\n    // deleteArray functions\r\n    ////////////////////////////\r\n    /// @notice Function used to delete the array element.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// For deleting the item from array developers needs to create a funtion for that similarly\r\n    /// in this case we have the helper function deleteArrayBytes32() which will do it for us\r\n    /// deleteArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1), 3); -- it will delete the index 3\r\n\r\n\r\n    //Deletes from mapping (bytes32 => array[]) at index _index\r\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\r\n        address[] storage array = addressArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\r\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\r\n        bytes32[] storage array = bytes32ArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => uint[]) at index _index\r\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\r\n        uint256[] storage array = uintArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => string[]) at index _index\r\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\r\n        string[] storage array = stringArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    ////////////////////////////\r\n    //// pushArray functions\r\n    ///////////////////////////\r\n    /// @notice Below are the helper functions to facilitate storing arrays of different data types.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByTicker;\r\n    /// tokensOwnedByTicker[owner] = tokensOwnedByTicker[owner].push(\"xyz\"); replace with\r\n    /// pushArray(keccak256(abi.encodePacked(\"tokensOwnedByTicker\", owner), \"xyz\");\r\n\r\n    /// @notice use to store the values for the array\r\n    /// @param _key bytes32 type\r\n    /// @param _value [uint256, string, bytes32, address] any of the data type in array\r\n    function pushArray(bytes32 _key, address _value) internal {\r\n        addressArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, string _value) internal {\r\n        stringArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, uint256 _value) internal {\r\n        uintArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    /////////////////////////\r\n    //// Set Array functions\r\n    ////////////////////////\r\n    /// @notice used to intialize the array\r\n    /// Ex1- mapping (address => address[]) public reputation;\r\n    /// reputation[0x1] = new address[](0); It can be replaced as\r\n    /// setArray(hash('reputation', 0x1), new address[](0)); \r\n    \r\n    function setArray(bytes32 _key, address[] _value) internal {\r\n        addressArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, uint256[] _value) internal {\r\n        uintArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, bytes32[] _value) internal {\r\n        bytes32ArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, string[] _value) internal {\r\n        stringArrayStorage[_key] = _value;\r\n    }\r\n\r\n    /////////////////////////\r\n    /// getArray functions\r\n    /////////////////////////\r\n    /// @notice Get functions to get the array of the required data type\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)); It return the bytes32 array\r\n    /// Ex2- uint256 _len =  tokensOwnedByOwner[0x1].length; replace with\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)).length;\r\n\r\n    function getArrayAddress(bytes32 _key) internal view returns(address[]) {\r\n        return addressArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayBytes32(bytes32 _key) internal view returns(bytes32[]) {\r\n        return bytes32ArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayString(bytes32 _key) internal view returns(string[]) {\r\n        return stringArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayUint(bytes32 _key) internal view returns(uint[]) {\r\n        return uintArrayStorage[_key];\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    /// setArrayIndexValue() functions\r\n    ///////////////////////////////////\r\n    /// @notice set the value of particular index of the address array\r\n    /// Ex1- mapping(bytes32 => address[]) moduleList;\r\n    /// general way is -- moduleList[moduleType][index] = temp; \r\n    /// It can be re-write as -- setArrayIndexValue(keccak256(abi.encodePacked('moduleList', moduleType)), index, temp); \r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\r\n        addressArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\r\n        uintArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string _value) internal {\r\n        stringArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n        /////////////////////////////\r\n        /// Public getters functions\r\n        /////////////////////////////\r\n\r\n    function getUintValues(bytes32 _variable) public view returns(uint256) {\r\n        return uintStorage[_variable];\r\n    }\r\n\r\n    function getBoolValues(bytes32 _variable) public view returns(bool) {\r\n        return boolStorage[_variable];\r\n    }\r\n\r\n    function getStringValues(bytes32 _variable) public view returns(string) {\r\n        return stringStorage[_variable];\r\n    }\r\n\r\n    function getAddressValues(bytes32 _variable) public view returns(address) {\r\n        return addressStorage[_variable];\r\n    }\r\n\r\n    function getBytes32Values(bytes32 _variable) public view returns(bytes32) {\r\n        return bytes32Storage[_variable];\r\n    }\r\n\r\n    function getBytesValues(bytes32 _variable) public view returns(bytes) {\r\n        return bytesStorage[_variable];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract for reusable code\r\n */\r\nlibrary Util {\r\n\r\n   /**\r\n    * @notice Changes a string to upper case\r\n    * @param _base String to change\r\n    */\r\n    function upper(string _base) internal pure returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            bytes1 b1 = _baseBytes[i];\r\n            if (b1 >= 0x61 && b1 <= 0x7A) {\r\n                b1 = bytes1(uint8(b1)-32);\r\n            }\r\n            _baseBytes[i] = b1;\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the string into bytes32\r\n     * @param _source String that need to convert into bytes32\r\n     */\r\n    /// Notice - Maximum Length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function stringToBytes32(string memory _source) internal pure returns (bytes32) {\r\n        return bytesToBytes32(bytes(_source), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes bytes into bytes32\r\n     * @param _b Bytes that need to convert into bytes32\r\n     * @param _offset Offset from which to begin conversion\r\n     */\r\n    /// Notice - Maximum length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function bytesToBytes32(bytes _b, uint _offset) internal pure returns (bytes32) {\r\n        bytes32 result;\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            result |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the bytes32 into string\r\n     * @param _source that need to convert into string\r\n     */\r\n    function bytes32ToString(bytes32 _source) internal pure returns (string result) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_source) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets function signature from _data\r\n     * @param _data Passed data\r\n     * @return bytes4 sig\r\n     */\r\n    function getSig(bytes _data) internal pure returns (bytes4 sig) {\r\n        uint len = _data.length < 4 ? _data.length : 4;\r\n        for (uint i = 0; i < len; i++) {\r\n            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nlibrary Encoder {\r\n\r\n    function getKey(string _key) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function getKey(string _key1, address _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, string _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, uint256 _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, bytes32 _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string _key1, bool _key2) internal pure returns (bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Helper library use to compare or validate the semantic versions\r\n */\r\n\r\nlibrary VersionUtils {\r\n\r\n    /**\r\n     * @notice This function is used to validate the version submitted\r\n     * @param _current Array holds the present version of ST\r\n     * @param _new Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function isValidVersion(uint8[] _current, uint8[] _new) internal pure returns(bool) {\r\n        bool[] memory _temp = new bool[](_current.length);\r\n        uint8 counter = 0;\r\n        for (uint8 i = 0; i < _current.length; i++) {\r\n            if (_current[i] < _new[i])\r\n                _temp[i] = true;\r\n            else\r\n                _temp[i] = false;\r\n        }\r\n\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (i == 0) {\r\n                if (_current[i] <= _new[i])\r\n                    if(_temp[0]) {\r\n                        counter = counter + 3;\r\n                        break;\r\n                    } else\r\n                        counter++;\r\n                else\r\n                    return false;\r\n            } else {\r\n                if (_temp[i-1])\r\n                    counter++;\r\n                else if (_current[i] <= _new[i])\r\n                    counter++;\r\n                else\r\n                    return false;\r\n            }\r\n        }\r\n        if (counter == _current.length)\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to compare the lower bound with the latest version\r\n     * @param _version1 Array holds the lower bound of the version\r\n     * @param _version2 Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function compareLowerBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\r\n        require(_version1.length == _version2.length, \"Input length mismatch\");\r\n        uint counter = 0;\r\n        for (uint8 j = 0; j < _version1.length; j++) {\r\n            if (_version1[j] == 0)\r\n                counter ++;\r\n        }\r\n        if (counter != _version1.length) {\r\n            counter = 0;\r\n            for (uint8 i = 0; i < _version1.length; i++) {\r\n                if (_version2[i] > _version1[i])\r\n                    return true;\r\n                else if (_version2[i] < _version1[i])\r\n                    return false;\r\n                else\r\n                    counter++;\r\n            }\r\n            if (counter == _version1.length - 1)\r\n                return true;\r\n            else\r\n                return false;\r\n        } else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to compare the upper bound with the latest version\r\n     * @param _version1 Array holds the upper bound of the version\r\n     * @param _version2 Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function compareUpperBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\r\n        require(_version1.length == _version2.length, \"Input length mismatch\");\r\n        uint counter = 0;\r\n        for (uint8 j = 0; j < _version1.length; j++) {\r\n            if (_version1[j] == 0)\r\n                counter ++;\r\n        }\r\n        if (counter != _version1.length) {\r\n            counter = 0;\r\n            for (uint8 i = 0; i < _version1.length; i++) {\r\n                if (_version1[i] > _version2[i])\r\n                    return true;\r\n                else if (_version1[i] < _version2[i])\r\n                    return false;\r\n                else\r\n                    counter++;\r\n            }\r\n            if (counter == _version1.length - 1)\r\n                return true;\r\n            else\r\n                return false;\r\n        } else\r\n            return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Used to pack the uint8[] array data into uint24 value\r\n     * @param _major Major version\r\n     * @param _minor Minor version\r\n     * @param _patch Patch version\r\n     */\r\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\r\n        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into uint8 array\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpack(uint24 _packedVersion) internal pure returns (uint8[]) {\r\n        uint8[] memory _unpackVersion = new uint8[](3);\r\n        _unpackVersion[0] = uint8(_packedVersion >> 16);\r\n        _unpackVersion[1] = uint8(_packedVersion >> 8);\r\n        _unpackVersion[2] = uint8(_packedVersion);\r\n        return _unpackVersion;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title Registry contract for issuers to register their tickers and security tokens\r\n */\r\ncontract SecurityTokenRegistry is ISecurityTokenRegistry, EternalStorage {\r\n\r\n    /**\r\n     * @notice state variables\r\n\r\n       address public polyToken;\r\n       uint256 public stLaunchFee;\r\n       uint256 public tickerRegFee;\r\n       uint256 public expiryLimit;\r\n       uint256 public latestProtocolVersion;\r\n       bool public paused;\r\n       address public owner;\r\n       address public polymathRegistry;\r\n\r\n       address[] public activeUsers;\r\n       mapping(address => bool) public seenUsers;\r\n\r\n       mapping(address => bytes32[]) userToTickers;\r\n       mapping(string => address) tickerToSecurityToken;\r\n       mapping(string => uint) tickerIndex;\r\n       mapping(string => TickerDetails) registeredTickers;\r\n       mapping(address => SecurityTokenData) securityTokens;\r\n       mapping(bytes32 => address) protocolVersionST;\r\n       mapping(uint256 => ProtocolVersion) versionData;\r\n\r\n       struct ProtocolVersion {\r\n           uint8 major;\r\n           uint8 minor;\r\n           uint8 patch;\r\n       }\r\n\r\n       struct TickerDetails {\r\n           address owner;\r\n           uint256 registrationDate;\r\n           uint256 expiryDate;\r\n           string tokenName;\r\n           bool status;\r\n       }\r\n\r\n       struct SecurityTokenData {\r\n           string ticker;\r\n           string tokenDetails;\r\n           uint256 deployedAt;\r\n       }\r\n\r\n     */\r\n\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 constant INITIALIZE = 0x9ef7257c3339b099aacf96e55122ee78fb65a36bd2a6c19249882be9c98633bf;\r\n    bytes32 constant POLYTOKEN = 0xacf8fbd51bb4b83ba426cdb12f63be74db97c412515797993d2a385542e311d7;\r\n    bytes32 constant STLAUNCHFEE = 0xd677304bb45536bb7fdfa6b9e47a3c58fe413f9e8f01474b0a4b9c6e0275baf2;\r\n    bytes32 constant TICKERREGFEE = 0x2fcc69711628630fb5a42566c68bd1092bc4aa26826736293969fddcd11cb2d2;\r\n    bytes32 constant EXPIRYLIMIT = 0x604268e9a73dfd777dcecb8a614493dd65c638bad2f5e7d709d378bd2fb0baee;\r\n    bytes32 constant PAUSED = 0xee35723ac350a69d2a92d3703f17439cbaadf2f093a21ba5bf5f1a53eb2a14d9;\r\n    bytes32 constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\r\n    bytes32 constant POLYMATHREGISTRY = 0x90eeab7c36075577c7cc5ff366e389fefa8a18289b949bab3529ab4471139d4d;\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(uint256 _timestammp);\r\n     // Emit when network becomes unpaused\r\n    event Unpause(uint256 _timestamp);\r\n    // Emit when the ticker is removed from the registry\r\n    event TickerRemoved(string _ticker, uint256 _removedAt, address _removedBy);\r\n    // Emit when the token ticker expiry is changed\r\n    event ChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\r\n     // Emit when changeSecurityLaunchFee is called\r\n    event ChangeSecurityLaunchFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when changeTickerRegistrationFee is called\r\n    event ChangeTickerRegistrationFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    // Emit when ownership of the ticker gets changed\r\n    event ChangeTickerOwnership(string _ticker, address indexed _oldOwner, address indexed _newOwner);\r\n    // Emit at the time of launching a new security token\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit after ticker registration\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        string _name,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n\r\n    /////////////////////////////\r\n    // Modifiers\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(),\"sender must be owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPausedOrOwner() {\r\n        if (msg.sender == owner())\r\n            _;\r\n        else {\r\n            require(!isPaused(), \"Already paused\");\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused and ignore is msg.sender is owner.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!isPaused(), \"Already paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(isPaused(), \"Should not be paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    // Initialization\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @notice Initializes instance of STR\r\n     * @param _polymathRegistry is the address of the Polymath Registry\r\n     * @param _STFactory is the address of the Proxy contract for Security Tokens\r\n     * @param _stLaunchFee is the fee in POLY required to launch a token\r\n     * @param _tickerRegFee is the fee in POLY required to register a ticker\r\n     * @param _polyToken is the address of the POLY ERC20 token\r\n     * @param _owner is the owner of the STR\r\n     */\r\n    function initialize(\r\n        address _polymathRegistry,\r\n        address _STFactory,\r\n        uint256 _stLaunchFee,\r\n        uint256 _tickerRegFee,\r\n        address _polyToken,\r\n        address _owner\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        require(!getBool(INITIALIZE),\"already initialized\");\r\n        require(\r\n            _STFactory != address(0) && _polyToken != address(0) && _owner != address(0) && _polymathRegistry != address(0),\r\n            \"Invalid address\"\r\n        );\r\n        require(_stLaunchFee != 0 && _tickerRegFee != 0, \"Fees should not be 0\");\r\n        set(POLYTOKEN, _polyToken);\r\n        set(STLAUNCHFEE, _stLaunchFee);\r\n        set(TICKERREGFEE, _tickerRegFee);\r\n        set(EXPIRYLIMIT, uint256(60 * 1 days));\r\n        set(PAUSED, false);\r\n        set(OWNER, _owner);\r\n        set(POLYMATHREGISTRY, _polymathRegistry);\r\n        _setProtocolVersion(_STFactory, uint8(2), uint8(0), uint8(0));\r\n        set(INITIALIZE, true);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Token Ticker Management\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @notice Registers the token ticker to the selected owner\r\n     * @notice Once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner is address of the owner of the token\r\n     * @param _ticker is unique token ticker\r\n     * @param _tokenName is the name of the token\r\n     */\r\n    function registerTicker(address _owner, string _ticker, string _tokenName) external whenNotPausedOrOwner {\r\n        require(_owner != address(0), \"Owner should not be 0x\");\r\n        require(bytes(_ticker).length > 0 && bytes(_ticker).length <= 10, \"Ticker length range (0,10]\");\r\n        // Attempt to charge the reg fee if it is > 0 POLY\r\n        uint256 tickerFee = getTickerRegistrationFee();\r\n        if (tickerFee > 0)\r\n            require(IERC20(getAddress(POLYTOKEN)).transferFrom(msg.sender, address(this), tickerFee), \"Insufficent allowance\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(_tickerAvailable(ticker), \"Ticker is reserved\");\r\n        // Check whether ticker was previously registered (and expired)\r\n        address previousOwner = _tickerOwner(ticker);\r\n        if (previousOwner != address(0)) {\r\n            _deleteTickerOwnership(previousOwner, ticker);\r\n        }\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        _addTicker(_owner, ticker, _tokenName, now, now.add(getExpiryLimit()), false, false, tickerFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Sets the details of the ticker\r\n     */\r\n    function _addTicker(\r\n        address _owner, \r\n        string _ticker, \r\n        string _tokenName, \r\n        uint256 _registrationDate, \r\n        uint256 _expiryDate, \r\n        bool _status, \r\n        bool _fromAdmin, \r\n        uint256 _fee\r\n        ) internal {\r\n        _setTickerOwnership(_owner, _ticker);\r\n        _storeTickerDetails(_ticker, _owner, _registrationDate, _expiryDate, _tokenName, _status);\r\n        emit RegisterTicker(_owner, _ticker, _tokenName, _registrationDate, _expiryDate, _fromAdmin, _fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only Polymath has the ability to do so.\r\n     * @notice Only allowed to modify the tickers which are not yet deployed.\r\n     * @param _owner is the owner of the token\r\n     * @param _ticker is the token ticker\r\n     * @param _tokenName is the name of the token\r\n     * @param _registrationDate is the date at which ticker is registered\r\n     * @param _expiryDate is the expiry date for the ticker\r\n     * @param _status is the token deployment status\r\n     */\r\n    function modifyTicker(\r\n        address _owner,\r\n        string _ticker,\r\n        string _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n        ) external onlyOwner {\r\n        require(bytes(_ticker).length > 0 && bytes(_ticker).length <= 10, \"Ticker length range (0,10]\");\r\n        require(_expiryDate != 0 && _registrationDate != 0, \"Dates should not be 0\");\r\n        require(_registrationDate <= _expiryDate, \"Registration date should < expiry date\");\r\n        require(_owner != address(0), \"Invalid address\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        _modifyTicker(_owner, ticker, _tokenName, _registrationDate, _expiryDate, _status);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal -- Modifies the ticker details.\r\n     */\r\n    function _modifyTicker(\r\n        address _owner,\r\n        string _ticker,\r\n        string _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n        ) internal {\r\n        address currentOwner = _tickerOwner(_ticker);\r\n        if (currentOwner != address(0)) {\r\n            _deleteTickerOwnership(currentOwner, _ticker);\r\n        }\r\n        if (_tickerStatus(_ticker) && !_status) {\r\n            set(Encoder.getKey(\"tickerToSecurityToken\", _ticker), address(0));\r\n        }\r\n        // If status is true, there must be a security token linked to the ticker already\r\n        if (_status) {\r\n            require(getAddress(Encoder.getKey(\"tickerToSecurityToken\", _ticker)) != address(0), \"Token not registered\");\r\n        }\r\n        _addTicker(_owner, _ticker, _tokenName, _registrationDate, _expiryDate, _status, true, uint256(0));\r\n    }\r\n\r\n    function _tickerOwner(string _ticker) internal view returns(address) {\r\n        return getAddress(Encoder.getKey(\"registeredTickers_owner\", _ticker));\r\n    }\r\n\r\n    /**\r\n     * @notice Removes the ticker details, associated ownership & security token mapping\r\n     * @param _ticker is the token ticker\r\n     */\r\n    function removeTicker(string _ticker) external onlyOwner {\r\n        string memory ticker = Util.upper(_ticker);\r\n        address owner = _tickerOwner(ticker);\r\n        require(owner != address(0), \"Ticker doesn't exist\");\r\n        _deleteTickerOwnership(owner, ticker);\r\n        set(Encoder.getKey(\"tickerToSecurityToken\", ticker), address(0));\r\n        _storeTickerDetails(ticker, address(0), 0, 0, \"\", false);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit TickerRemoved(ticker, now, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Checks if the entered ticker is registered and has not expired\r\n     * @param _ticker is the token ticker\r\n     * @return bool\r\n     */\r\n    function _tickerAvailable(string _ticker) internal view returns(bool) {\r\n        if (_tickerOwner(_ticker) != address(0)) {\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            if ((now > getUint(Encoder.getKey(\"registeredTickers_expiryDate\", _ticker))) && !_tickerStatus(_ticker)) {\r\n                return true;\r\n            } else\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _tickerStatus(string _ticker) internal view returns(bool) {\r\n        return getBool(Encoder.getKey(\"registeredTickers_status\", _ticker));\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Sets the ticker owner\r\n     * @param _owner is the address of the owner of the ticker\r\n     * @param _ticker is the ticker symbol\r\n     */\r\n    function _setTickerOwnership(address _owner, string _ticker) internal {\r\n        bytes32 _ownerKey = Encoder.getKey(\"userToTickers\", _owner);\r\n        uint256 length = uint256(getArrayBytes32(_ownerKey).length);\r\n        pushArray(_ownerKey, Util.stringToBytes32(_ticker));\r\n        set(Encoder.getKey(\"tickerIndex\", _ticker), length);\r\n        bytes32 seenKey = Encoder.getKey(\"seenUsers\", _owner);\r\n        if (!getBool(seenKey)) {\r\n            pushArray(Encoder.getKey(\"activeUsers\"), _owner);\r\n            set(seenKey, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Stores the ticker details\r\n     */\r\n    function _storeTickerDetails(\r\n        string _ticker,\r\n        address _owner,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        string _tokenName,\r\n        bool _status\r\n        ) internal {\r\n        bytes32 key = Encoder.getKey(\"registeredTickers_owner\", _ticker);\r\n        if (getAddress(key) != _owner)\r\n            set(key, _owner);\r\n        key = Encoder.getKey(\"registeredTickers_registrationDate\", _ticker);\r\n        if (getUint(key) != _registrationDate)\r\n            set(key, _registrationDate);\r\n        key = Encoder.getKey(\"registeredTickers_expiryDate\", _ticker);\r\n        if (getUint(key) != _expiryDate)\r\n            set(key, _expiryDate);\r\n        key = Encoder.getKey(\"registeredTickers_tokenName\", _ticker);\r\n        if (Encoder.getKey(getString(key)) != Encoder.getKey(_tokenName))\r\n            set(key, _tokenName);\r\n        key = Encoder.getKey(\"registeredTickers_status\", _ticker);\r\n        if (getBool(key) != _status)\r\n            set(key, _status);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers the ownership of the ticker\r\n     * @param _newOwner is the address of the new owner of the ticker\r\n     * @param _ticker is the ticker symbol\r\n     */\r\n    function transferTickerOwnership(address _newOwner, string _ticker) external whenNotPausedOrOwner {\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        bytes32 ownerKey = Encoder.getKey(\"registeredTickers_owner\", ticker);\r\n        require(getAddress(ownerKey) == msg.sender, \"Not authorised\");\r\n        if (_tickerStatus(ticker))\r\n            require(IOwnable(getAddress(Encoder.getKey(\"tickerToSecurityToken\", ticker))).owner() == _newOwner, \"New owner does not match token owner\");\r\n        _deleteTickerOwnership(msg.sender, ticker);\r\n        _setTickerOwnership(_newOwner, ticker);\r\n        set(ownerKey, _newOwner);\r\n        emit ChangeTickerOwnership(ticker, msg.sender, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Removes the owner of a ticker\r\n     */\r\n    function _deleteTickerOwnership(address _owner, string _ticker) internal {\r\n        uint256 index = uint256(getUint(Encoder.getKey(\"tickerIndex\", _ticker)));\r\n        bytes32 ownerKey = Encoder.getKey(\"userToTickers\", _owner);\r\n        bytes32[] memory tickers = getArrayBytes32(ownerKey);\r\n        assert(index < tickers.length);\r\n        assert(_tickerOwner(_ticker) == _owner);\r\n        deleteArrayBytes32(ownerKey, index);\r\n        if (getArrayBytes32(ownerKey).length > index) {\r\n            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];\r\n            set(Encoder.getKey(\"tickerIndex\", Util.bytes32ToString(switchedTicker)), index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the expiry time for the token ticker. Only available to Polymath.\r\n     * @param _newExpiry is the new expiry for newly generated tickers\r\n     */\r\n    function changeExpiryLimit(uint256 _newExpiry) external onlyOwner {\r\n        require(_newExpiry >= 1 days, \"Expiry should >= 1 day\");\r\n        emit ChangeExpiryLimit(getUint(EXPIRYLIMIT), _newExpiry);\r\n        set(EXPIRYLIMIT, _newExpiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the list of tickers owned by the selected address\r\n     * @param _owner is the address which owns the list of tickers\r\n     */\r\n    function getTickersByOwner(address _owner) external view returns(bytes32[]) {\r\n        uint counter = 0;\r\n        // accessing the data structure userTotickers[_owner].length\r\n        bytes32[] memory tickers = getArrayBytes32(Encoder.getKey(\"userToTickers\", _owner));\r\n        for (uint i = 0; i < tickers.length; i++) {\r\n            string memory ticker = Util.bytes32ToString(tickers[i]);\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            if (getUint(Encoder.getKey(\"registeredTickers_expiryDate\", ticker)) >= now || _tickerStatus(ticker)) {\r\n                counter ++;\r\n            }\r\n        }\r\n        bytes32[] memory tempList = new bytes32[](counter);\r\n        counter = 0;\r\n        for (i = 0; i < tickers.length; i++) {\r\n            ticker = Util.bytes32ToString(tickers[i]);\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            if (getUint(Encoder.getKey(\"registeredTickers_expiryDate\", ticker)) >= now || _tickerStatus(ticker)) {\r\n                tempList[counter] = tickers[i];\r\n                counter ++;\r\n            }\r\n        }\r\n        return tempList;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the list of tokens owned by the selected address\r\n     * @param _owner is the address which owns the list of tickers\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByOwner(address _owner) external view returns(address[]) {\r\n        // Loop over all active users, then all associated tickers of those users\r\n        // This ensures we find tokens, even if their owner has been modified\r\n        address[] memory activeUsers = getArrayAddress(Encoder.getKey(\"activeUsers\"));\r\n        bytes32[] memory tickers;\r\n        address token;\r\n        uint256 count = 0;\r\n        uint256 i = 0;\r\n        uint256 j = 0;\r\n        for (i = 0; i < activeUsers.length; i++) {\r\n            tickers = getArrayBytes32(Encoder.getKey(\"userToTickers\", activeUsers[i]));\r\n            for (j = 0; j < tickers.length; j++) {\r\n                token = getAddress(Encoder.getKey(\"tickerToSecurityToken\", Util.bytes32ToString(tickers[j])));\r\n                if (token != address(0)) {\r\n                    if (IOwnable(token).owner() == _owner) {\r\n                        count = count + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        uint256 index = 0;\r\n        address[] memory result = new address[](count);\r\n        for (i = 0; i < activeUsers.length; i++) {\r\n            tickers = getArrayBytes32(Encoder.getKey(\"userToTickers\", activeUsers[i]));\r\n            for (j = 0; j < tickers.length; j++) {\r\n                token = getAddress(Encoder.getKey(\"tickerToSecurityToken\", Util.bytes32ToString(tickers[j])));\r\n                if (token != address(0)) {\r\n                    if (IOwnable(token).owner() == _owner) {\r\n                        result[index] = token;\r\n                        index = index + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the owner and timestamp for a given ticker\r\n     * @param _ticker is the ticker symbol\r\n     * @return address\r\n     * @return uint256\r\n     * @return uint256\r\n     * @return string\r\n     * @return bool\r\n     */\r\n    function getTickerDetails(string _ticker) external view returns (address, uint256, uint256, string, bool) {\r\n        string memory ticker = Util.upper(_ticker);\r\n        bool tickerStatus = _tickerStatus(ticker);\r\n        uint256 expiryDate = getUint(Encoder.getKey(\"registeredTickers_expiryDate\", ticker));\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        if ((tickerStatus == true) || (expiryDate > now)) {\r\n            return\r\n            (\r\n                _tickerOwner(ticker),\r\n                getUint(Encoder.getKey(\"registeredTickers_registrationDate\", ticker)),\r\n                expiryDate,\r\n                getString(Encoder.getKey(\"registeredTickers_tokenName\", ticker)),\r\n                tickerStatus\r\n            );\r\n        } else\r\n            return (address(0), uint256(0), uint256(0), \"\", false);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Security Token Management\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and records it to the registry\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function generateSecurityToken(string _name, string _ticker, string _tokenDetails, bool _divisible) external whenNotPausedOrOwner {\r\n        require(bytes(_name).length > 0 && bytes(_ticker).length > 0, \"Ticker length > 0\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        bytes32 statusKey = Encoder.getKey(\"registeredTickers_status\", ticker);\r\n        require(!getBool(statusKey), \"Already deployed\");\r\n        set(statusKey, true);\r\n        require(_tickerOwner(ticker) == msg.sender, \"Not authorised\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(getUint(Encoder.getKey(\"registeredTickers_expiryDate\", ticker)) >= now, \"Ticker gets expired\");\r\n\r\n        uint256 launchFee = getSecurityTokenLaunchFee();\r\n        if (launchFee > 0)\r\n            require(IERC20(getAddress(POLYTOKEN)).transferFrom(msg.sender, address(this), launchFee), \"Insufficient allowance\");\r\n\r\n        address newSecurityTokenAddress = ISTFactory(getSTFactoryAddress()).deployToken(\r\n            _name,\r\n            ticker,\r\n            18,\r\n            _tokenDetails,\r\n            msg.sender,\r\n            _divisible,\r\n            getAddress(POLYMATHREGISTRY)\r\n        );\r\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        _storeSecurityTokenData(newSecurityTokenAddress, ticker, _tokenDetails, now);\r\n        set(Encoder.getKey(\"tickerToSecurityToken\", ticker), newSecurityTokenAddress);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit NewSecurityToken(ticker, _name, newSecurityTokenAddress, msg.sender, now, msg.sender, false, launchFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _owner is the owner of the token\r\n     * @param _securityToken is the address of the securityToken\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _deployedAt is the timestamp at which the security token is deployed\r\n     */\r\n    function modifySecurityToken(\r\n        string _name,\r\n        string _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(bytes(_name).length > 0 && bytes(_ticker).length > 0, \"String length > 0\");\r\n        require(bytes(_ticker).length <= 10, \"Ticker length range (0,10]\");\r\n        require(_deployedAt != 0 && _owner != address(0), \"0 value params not allowed\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(_securityToken != address(0), \"ST address is 0x\");\r\n        uint256 registrationTime = getUint(Encoder.getKey(\"registeredTickers_registrationDate\", ticker));\r\n        uint256 expiryTime = getUint(Encoder.getKey(\"registeredTickers_expiryDate\", ticker));\r\n        if (registrationTime == 0) {\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            registrationTime = now;\r\n            expiryTime = registrationTime.add(getExpiryLimit());\r\n        }\r\n        set(Encoder.getKey(\"tickerToSecurityToken\", ticker), _securityToken);\r\n        _modifyTicker(_owner, ticker, _name, registrationTime, expiryTime, true);\r\n        _storeSecurityTokenData(_securityToken, ticker, _tokenDetails, _deployedAt);\r\n        emit NewSecurityToken(ticker, _name, _securityToken, _owner, _deployedAt, msg.sender, true, getSecurityTokenLaunchFee());\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Stores the security token details\r\n     */\r\n    function _storeSecurityTokenData(address _securityToken, string _ticker, string _tokenDetails, uint256 _deployedAt) internal {\r\n        set(Encoder.getKey(\"securityTokens_ticker\", _securityToken), _ticker);\r\n        set(Encoder.getKey(\"securityTokens_tokenDetails\", _securityToken), _tokenDetails);\r\n        set(Encoder.getKey(\"securityTokens_deployedAt\", _securityToken), _deployedAt);\r\n    }\r\n\r\n    /**\r\n    * @notice Checks that Security Token is registered\r\n    * @param _securityToken is the address of the security token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) external view returns (bool) {\r\n        return (keccak256(bytes(getString(Encoder.getKey(\"securityTokens_ticker\", _securityToken)))) != keccak256(\"\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the security token address by ticker symbol\r\n     * @param _ticker is the ticker of the security token\r\n     * @return address\r\n     */\r\n    function getSecurityTokenAddress(string _ticker) external view returns (address) {\r\n        string memory ticker = Util.upper(_ticker);\r\n        return getAddress(Encoder.getKey(\"tickerToSecurityToken\", ticker));\r\n    }\r\n\r\n     /**\r\n     * @notice Returns the security token data by address\r\n     * @param _securityToken is the address of the security token.\r\n     * @return string is the ticker of the security Token.\r\n     * @return address is the issuer of the security Token.\r\n     * @return string is the details of the security token.\r\n     * @return uint256 is the timestamp at which security Token was deployed.\r\n     */\r\n    function getSecurityTokenData(address _securityToken) external view returns (string, address, string, uint256) {\r\n        return (\r\n            getString(Encoder.getKey(\"securityTokens_ticker\", _securityToken)),\r\n            IOwnable(_securityToken).owner(),\r\n            getString(Encoder.getKey(\"securityTokens_tokenDetails\", _securityToken)),\r\n            getUint(Encoder.getKey(\"securityTokens_deployedAt\", _securityToken))\r\n        );\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Ownership, lifecycle & Utility\r\n    /////////////////////////////\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid address\");\r\n        emit OwnershipTransferred(getAddress(OWNER), _newOwner);\r\n        set(OWNER, _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() external whenNotPaused onlyOwner {\r\n        set(PAUSED, true);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(now);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() external whenPaused onlyOwner {\r\n        set(PAUSED, false);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(now);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in POLY tokens. Only Polymath.\r\n    * @param _tickerRegFee is the registration fee in POLY tokens (base 18 decimals)\r\n    */\r\n    function changeTickerRegistrationFee(uint256 _tickerRegFee) external onlyOwner {\r\n        uint256 fee = getUint(TICKERREGFEE);\r\n        require(fee != _tickerRegFee, \"Fee not changed\");\r\n        emit ChangeTickerRegistrationFee(fee, _tickerRegFee);\r\n        set(TICKERREGFEE, _tickerRegFee);\r\n    }\r\n\r\n   /**\r\n    * @notice Sets the ticker registration fee in POLY tokens. Only Polymath.\r\n    * @param _stLaunchFee is the registration fee in POLY tokens (base 18 decimals)\r\n    */\r\n    function changeSecurityLaunchFee(uint256 _stLaunchFee) external onlyOwner {\r\n        uint256 fee = getUint(STLAUNCHFEE);\r\n        require(fee != _stLaunchFee, \"Fee not changed\");\r\n        emit ChangeSecurityLaunchFee(fee, _stLaunchFee);\r\n        set(STLAUNCHFEE, _stLaunchFee);\r\n    }\r\n\r\n    /**\r\n    * @notice Reclaims all ERC20Basic compatible tokens\r\n    * @param _tokenContract is the address of the token contract\r\n    */\r\n    function reclaimERC20(address _tokenContract) external onlyOwner {\r\n        require(_tokenContract != address(0), \"Invalid address\");\r\n        IERC20 token = IERC20(_tokenContract);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(owner(), balance), \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n    * @notice Changes the protocol version and the SecurityToken contract\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _STFactoryAddress is the address of the proxy.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {\r\n        require(_STFactoryAddress != address(0), \"0x address is not allowed\");\r\n        _setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);\r\n    }\r\n\r\n    /**\r\n    * @notice Internal - Changes the protocol version and the SecurityToken contract\r\n    */\r\n    function _setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal {\r\n        uint8[] memory _version = new uint8[](3);\r\n        _version[0] = _major;\r\n        _version[1] = _minor;\r\n        _version[2] = _patch;\r\n        uint24 _packedVersion = VersionUtils.pack(_major, _minor, _patch);\r\n        require(VersionUtils.isValidVersion(getProtocolVersion(), _version),\"In-valid version\");\r\n        set(Encoder.getKey(\"latestVersion\"), uint256(_packedVersion));\r\n        set(Encoder.getKey(\"protocolVersionST\", getUint(Encoder.getKey(\"latestVersion\"))), _STFactoryAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current STFactory Address\r\n     */\r\n    function getSTFactoryAddress() public view returns(address) {\r\n        return getAddress(Encoder.getKey(\"protocolVersionST\", getUint(Encoder.getKey(\"latestVersion\"))));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets Protocol version\r\n     */\r\n    function getProtocolVersion() public view returns(uint8[]) {\r\n        return VersionUtils.unpack(uint24(getUint(Encoder.getKey(\"latestVersion\"))));\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the PolyToken address. Only Polymath.\r\n     * @param _newAddress is the address of the polytoken.\r\n     */\r\n    function updatePolyTokenAddress(address _newAddress) external onlyOwner {\r\n        require(_newAddress != address(0), \"Invalid address\");\r\n        set(POLYTOKEN, _newAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the security token launch fee\r\n     * @return Fee amount\r\n     */\r\n    function getSecurityTokenLaunchFee() public view returns(uint256) {\r\n        return getUint(STLAUNCHFEE);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the ticker registration fee\r\n     * @return Fee amount\r\n     */\r\n    function getTickerRegistrationFee() public view returns(uint256) {\r\n        return getUint(TICKERREGFEE);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the expiry limit\r\n     * @return Expiry limit\r\n     */\r\n    function getExpiryLimit() public view returns(uint256) {\r\n        return getUint(EXPIRYLIMIT);\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the registry is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() public view returns(bool) {\r\n        return getBool(PAUSED);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() public view returns(address) {\r\n        return getAddress(OWNER);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getExpiryLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBoolValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExpiry\",\"type\":\"uint256\"}],\"name\":\"changeExpiryLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTickersByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getUintValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenName\",\"type\":\"string\"}],\"name\":\"registerTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProtocolVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTokensByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stLaunchFee\",\"type\":\"uint256\"}],\"name\":\"changeSecurityLaunchFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"getTickerDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_deployedAt\",\"type\":\"uint256\"}],\"name\":\"modifySecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getStringValues\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"}],\"name\":\"getSecurityTokenData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_registrationDate\",\"type\":\"uint256\"},{\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"modifyTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickerRegFee\",\"type\":\"uint256\"}],\"name\":\"changeTickerRegistrationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"removeTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytes32Values\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getAddressValues\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_divisible\",\"type\":\"bool\"}],\"name\":\"generateSecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytesValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecurityTokenLaunchFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"transferTickerOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_polymathRegistry\",\"type\":\"address\"},{\"name\":\"_STFactory\",\"type\":\"address\"},{\"name\":\"_stLaunchFee\",\"type\":\"uint256\"},{\"name\":\"_tickerRegFee\",\"type\":\"uint256\"},{\"name\":\"_polyToken\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"}],\"name\":\"isSecurityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_STFactoryAddress\",\"type\":\"address\"},{\"name\":\"_major\",\"type\":\"uint8\"},{\"name\":\"_minor\",\"type\":\"uint8\"},{\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"setProtocolVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTickerRegistrationFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updatePolyTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSTFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"getSecurityTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestammp\",\"type\":\"uint256\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_removedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_removedBy\",\"type\":\"address\"}],\"name\":\"TickerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldExpiry\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newExpiry\",\"type\":\"uint256\"}],\"name\":\"ChangeExpiryLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"ChangeSecurityLaunchFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"ChangeTickerRegistrationFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeTickerOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_securityTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_addedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_registrant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fromAdmin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_registrationFee\",\"type\":\"uint256\"}],\"name\":\"NewSecurityToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_registrationDate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fromAdmin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_registrationFee\",\"type\":\"uint256\"}],\"name\":\"RegisterTicker\",\"type\":\"event\"}]","ContractName":"SecurityTokenRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1661bc9c0b9d5e2e2f12f694801c7a699c05b20b3770fc53d81dcd1ae0818f8a"}]}