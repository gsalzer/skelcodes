{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Interface to be implemented by all checkpoint modules\r\n */\r\n/*solium-disable-next-line no-empty-blocks*/\r\ninterface ICheckpoint {\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module contract should implement\r\n */\r\ninterface IModule {\r\n\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() external pure returns (bytes4);\r\n\r\n    /**\r\n     * @notice Return the permission flags that are associated with a module\r\n     */\r\n    function getPermissions() external view returns(bytes32[]);\r\n\r\n    /**\r\n     * @notice Used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) external returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n\r\n    // Standard ERC20 interface\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //transfer, transferFrom must respect the result of verifyTransfer\r\n    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is the amount of tokens that will be minted to the investor\r\n     */\r\n    function mint(address _investor, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is The amount of tokens that will be minted to the investor\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken on behalf of someone else\r\n     * @param _from Address for whom to burn tokens\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnWithData(uint256 _value, bytes _data) external;\r\n\r\n    event Minted(address indexed _to, uint256 _value);\r\n    event Burnt(address indexed _burner, uint256 _value);\r\n\r\n    // Permissions this to a Permission module, which has a key of 1\r\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\r\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Module type\r\n     * @return uint256 Module index\r\n     * @return uint256 Name index\r\n\r\n     */\r\n    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8, uint256, uint256);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets length of investors array\r\n     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\r\n     * @return Length\r\n     */\r\n    function getInvestors() external view returns (address[]);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);\r\n    \r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Gets an investor at a particular index\r\n    * @param _index Index to return address from\r\n    * @return Investor address\r\n    */\r\n    function investors(uint256 _index) external view returns (address);\r\n\r\n   /**\r\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _tokenContract Address of the ERC20Basic compliance token\r\n    * @param _value Amount of POLY to withdraw\r\n    */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to approve more POLY to one of the modules\r\n    * @param _module Module address\r\n    * @param _budget New budget\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _budget) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n    * @notice Removes addresses with zero balances from the investors list\r\n    * @param _start Index in investors list at which to start removing zero balances\r\n    * @param _iters Max number of iterations of the for loop\r\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\r\n    */\r\n    function pruneInvestors(uint256 _start, uint256 _iters) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Ends token minting period permanently\r\n     */\r\n    function freezeMinting() external;\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target investors.\r\n     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\r\n     * @param _investors A list of addresses to whom the minted tokens will be delivered\r\n     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\r\n     * @return Success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced transfer\r\n     * @param _from address from which to take tokens\r\n     * @param _to address where to send tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a foced burn\r\n     * @param _from address from which to take tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n     function disableController() external;\r\n\r\n     /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n     function getVersion() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Gets the investor count\r\n     */\r\n     function getInvestorCount() external view returns(uint256);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\r\n\r\n     /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n     function granularity() external view returns(uint256);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Interface that any module contract should implement\r\n * @notice Contract is abstract\r\n */\r\ncontract Module is IModule {\r\n\r\n    address public factory;\r\n\r\n    address public securityToken;\r\n\r\n    bytes32 public constant FEE_ADMIN = \"FEE_ADMIN\";\r\n\r\n    IERC20 public polyToken;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public {\r\n        securityToken = _securityToken;\r\n        factory = msg.sender;\r\n        polyToken = IERC20(_polyAddress);\r\n    }\r\n\r\n    //Allows owner, factory or permissioned delegate\r\n    modifier withPerm(bytes32 _perm) {\r\n        bool isOwner = msg.sender == Ownable(securityToken).owner();\r\n        bool isFactory = msg.sender == factory;\r\n        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), \"Permission check failed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == Ownable(securityToken).owner(), \"Sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory {\r\n        require(msg.sender == factory, \"Sender is not factory\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOwner {\r\n        require(msg.sender == Ownable(factory).owner(), \"Sender is not factory owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOrOwner {\r\n        require((msg.sender == Ownable(securityToken).owner()) || (msg.sender == factory), \"Sender is not factory or owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {\r\n        require(polyToken.transferFrom(securityToken, Ownable(factory).owner(), _amount), \"Unable to take fee\");\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * DISCLAIMER: Under certain conditions, the function pushDividendPayment\r\n * may fail due to block gas limits.\r\n * If the total number of investors that ever held tokens is greater than ~15,000 then\r\n * the function may fail. If this happens investors can pull their dividends, or the Issuer\r\n * can use pushDividendPaymentToAddresses to provide an explict address list in batches\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Checkpoint module for issuing ether dividends\r\n * @dev abstract contract\r\n */\r\ncontract DividendCheckpoint is ICheckpoint, Module {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public EXCLUDED_ADDRESS_LIMIT = 50;\r\n    bytes32 public constant DISTRIBUTE = \"DISTRIBUTE\";\r\n    bytes32 public constant MANAGE = \"MANAGE\";\r\n    bytes32 public constant CHECKPOINT = \"CHECKPOINT\";\r\n\r\n    struct Dividend {\r\n        uint256 checkpointId;\r\n        uint256 created; // Time at which the dividend was created\r\n        uint256 maturity; // Time after which dividend can be claimed - set to 0 to bypass\r\n        uint256 expiry;  // Time until which dividend can be claimed - after this time any remaining amount can be withdrawn by issuer -\r\n                         // set to very high value to bypass\r\n        uint256 amount; // Dividend amount in WEI\r\n        uint256 claimedAmount; // Amount of dividend claimed so far\r\n        uint256 totalSupply; // Total supply at the associated checkpoint (avoids recalculating this)\r\n        bool reclaimed;  // True if expiry has passed and issuer has reclaimed remaining dividend\r\n        uint256 dividendWithheld;\r\n        uint256 dividendWithheldReclaimed;\r\n        mapping (address => bool) claimed; // List of addresses which have claimed dividend\r\n        mapping (address => bool) dividendExcluded; // List of addresses which cannot claim dividends\r\n        bytes32 name; // Name/title - used for identification\r\n    }\r\n\r\n    // List of all dividends\r\n    Dividend[] public dividends;\r\n\r\n    // List of addresses which cannot claim dividends\r\n    address[] public excluded;\r\n\r\n    // Mapping from address to withholding tax as a percentage * 10**16\r\n    mapping (address => uint256) public withholdingTax;\r\n\r\n    // Total amount of ETH withheld per investor\r\n    mapping (address => uint256) public investorWithheld;\r\n\r\n    event SetDefaultExcludedAddresses(address[] _excluded, uint256 _timestamp);\r\n    event SetWithholding(address[] _investors, uint256[] _withholding, uint256 _timestamp);\r\n    event SetWithholdingFixed(address[] _investors, uint256 _withholding, uint256 _timestamp);\r\n\r\n    modifier validDividendIndex(uint256 _dividendIndex) {\r\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\r\n        require(!dividends[_dividendIndex].reclaimed, \"Dividend reclaimed\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(now >= dividends[_dividendIndex].maturity, \"Dividend maturity in future\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(now < dividends[_dividendIndex].expiry, \"Dividend expiry in past\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Init function i.e generalise function to maintain the structure of the module contract\r\n    * @return bytes4\r\n    */\r\n    function getInitFunction() public pure returns (bytes4) {\r\n        return bytes4(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the default excluded addresses\r\n     * @return List of excluded addresses\r\n     */\r\n    function getDefaultExcluded() external view returns (address[]) {\r\n        return excluded;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a checkpoint on the security token\r\n     * @return Checkpoint ID\r\n     */\r\n    function createCheckpoint() public withPerm(CHECKPOINT) returns (uint256) {\r\n        return ISecurityToken(securityToken).createCheckpoint();\r\n    }\r\n\r\n    /**\r\n     * @notice Function to clear and set list of excluded addresses used for future dividends\r\n     * @param _excluded Addresses of investors\r\n     */\r\n    function setDefaultExcluded(address[] _excluded) public withPerm(MANAGE) {\r\n        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many excluded addresses\");\r\n        for (uint256 j = 0; j < _excluded.length; j++) {\r\n            require (_excluded[j] != address(0), \"Invalid address\");\r\n            for (uint256 i = j + 1; i < _excluded.length; i++) {\r\n                require (_excluded[j] != _excluded[i], \"Duplicate exclude address\");\r\n            }\r\n        }\r\n        excluded = _excluded;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit SetDefaultExcludedAddresses(excluded, now);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to set withholding tax rates for investors\r\n     * @param _investors Addresses of investors\r\n     * @param _withholding Withholding tax for individual investors (multiplied by 10**16)\r\n     */\r\n    function setWithholding(address[] _investors, uint256[] _withholding) public withPerm(MANAGE) {\r\n        require(_investors.length == _withholding.length, \"Mismatched input lengths\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit SetWithholding(_investors, _withholding, now);\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            require(_withholding[i] <= 10**18, \"Incorrect withholding tax\");\r\n            withholdingTax[_investors[i]] = _withholding[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Function to set withholding tax rates for investors\r\n     * @param _investors Addresses of investor\r\n     * @param _withholding Withholding tax for all investors (multiplied by 10**16)\r\n     */\r\n    function setWithholdingFixed(address[] _investors, uint256 _withholding) public withPerm(MANAGE) {\r\n        require(_withholding <= 10**18, \"Incorrect withholding tax\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit SetWithholdingFixed(_investors, _withholding, now);\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            withholdingTax[_investors[i]] = _withholding;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can push dividends to provided addresses\r\n     * @param _dividendIndex Dividend to push\r\n     * @param _payees Addresses to which to push the dividend\r\n     */\r\n    function pushDividendPaymentToAddresses(\r\n        uint256 _dividendIndex,\r\n        address[] _payees\r\n    )\r\n        public\r\n        withPerm(DISTRIBUTE)\r\n        validDividendIndex(_dividendIndex)\r\n    {\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        for (uint256 i = 0; i < _payees.length; i++) {\r\n            if ((!dividend.claimed[_payees[i]]) && (!dividend.dividendExcluded[_payees[i]])) {\r\n                _payDividend(_payees[i], dividend, _dividendIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can push dividends using the investor list from the security token\r\n     * @param _dividendIndex Dividend to push\r\n     * @param _start Index in investor list at which to start pushing dividends\r\n     * @param _iterations Number of addresses to push dividends for\r\n     */\r\n    function pushDividendPayment(\r\n        uint256 _dividendIndex,\r\n        uint256 _start,\r\n        uint256 _iterations\r\n    )\r\n        public\r\n        withPerm(DISTRIBUTE)\r\n        validDividendIndex(_dividendIndex)\r\n    {\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        address[] memory investors = ISecurityToken(securityToken).getInvestors();\r\n        uint256 numberInvestors = Math.min256(investors.length, _start.add(_iterations));\r\n        for (uint256 i = _start; i < numberInvestors; i++) {\r\n            address payee = investors[i];\r\n            if ((!dividend.claimed[payee]) && (!dividend.dividendExcluded[payee])) {\r\n                _payDividend(payee, dividend, _dividendIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Investors can pull their own dividends\r\n     * @param _dividendIndex Dividend to pull\r\n     */\r\n    function pullDividendPayment(uint256 _dividendIndex) public validDividendIndex(_dividendIndex)\r\n    {\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        require(!dividend.claimed[msg.sender], \"Dividend already claimed\");\r\n        require(!dividend.dividendExcluded[msg.sender], \"msg.sender excluded from Dividend\");\r\n        _payDividend(msg.sender, dividend, _dividendIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for paying dividends\r\n     * @param _payee Address of investor\r\n     * @param _dividend Storage with previously issued dividends\r\n     * @param _dividendIndex Dividend to pay\r\n     */\r\n    function _payDividend(address _payee, Dividend storage _dividend, uint256 _dividendIndex) internal;\r\n\r\n    /**\r\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\r\n     * @param _dividendIndex Dividend to reclaim\r\n     */\r\n    function reclaimDividend(uint256 _dividendIndex) external;\r\n\r\n    /**\r\n     * @notice Calculate amount of dividends claimable\r\n     * @param _dividendIndex Dividend to calculate\r\n     * @param _payee Affected investor address\r\n     * @return claim, withheld amounts\r\n     */\r\n    function calculateDividend(uint256 _dividendIndex, address _payee) public view returns(uint256, uint256) {\r\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        if (dividend.claimed[_payee] || dividend.dividendExcluded[_payee]) {\r\n            return (0, 0);\r\n        }\r\n        uint256 balance = ISecurityToken(securityToken).balanceOfAt(_payee, dividend.checkpointId);\r\n        uint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\r\n        uint256 withheld = claim.mul(withholdingTax[_payee]).div(uint256(10**18));\r\n        return (claim, withheld);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the index according to the checkpoint id\r\n     * @param _checkpointId Checkpoint id to query\r\n     * @return uint256[]\r\n     */\r\n    function getDividendIndex(uint256 _checkpointId) public view returns(uint256[]) {\r\n        uint256 counter = 0;\r\n        for(uint256 i = 0; i < dividends.length; i++) {\r\n            if (dividends[i].checkpointId == _checkpointId) {\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory index = new uint256[](counter);\r\n        counter = 0;\r\n        for(uint256 j = 0; j < dividends.length; j++) {\r\n            if (dividends[j].checkpointId == _checkpointId) {\r\n                index[counter] = j;\r\n                counter++;\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows issuer to withdraw withheld tax\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     */\r\n    function withdrawWithholding(uint256 _dividendIndex) external;\r\n\r\n    /**\r\n     * @notice Return the permissions flag that are associated with this module\r\n     * @return bytes32 array\r\n     */\r\n    function getPermissions() public view returns(bytes32[]) {\r\n        bytes32[] memory allPermissions = new bytes32[](2);\r\n        allPermissions[0] = DISTRIBUTE;\r\n        allPermissions[1] = MANAGE;\r\n        return allPermissions;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ninterface IOwnable {\r\n    /**\r\n    * @dev Returns owner\r\n    */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Checkpoint module for issuing ERC20 dividends\r\n */\r\ncontract ERC20DividendCheckpoint is DividendCheckpoint {\r\n    using SafeMath for uint256;\r\n\r\n    // Mapping to token address for each dividend\r\n    mapping (uint256 => address) public dividendTokens;\r\n    event ERC20DividendDeposited(\r\n        address indexed _depositor,\r\n        uint256 _checkpointId,\r\n        uint256 _created,\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address indexed _token,\r\n        uint256 _amount,\r\n        uint256 _totalSupply,\r\n        uint256 _dividendIndex,\r\n        bytes32 indexed _name\r\n    );\r\n    event ERC20DividendClaimed(\r\n        address indexed _payee,\r\n        uint256 _dividendIndex,\r\n        address indexed _token,\r\n        uint256 _amount,\r\n        uint256 _withheld\r\n    );\r\n    event ERC20DividendReclaimed(\r\n        address indexed _claimer,\r\n        uint256 _dividendIndex,\r\n        address indexed _token,\r\n        uint256 _claimedAmount\r\n    );\r\n    event ERC20DividendWithholdingWithdrawn(\r\n        address indexed _claimer,\r\n        uint256 _dividendIndex,\r\n        address indexed _token,\r\n        uint256 _withheldAmount\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public\r\n    Module(_securityToken, _polyAddress)\r\n    {\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend and checkpoint for the dividend\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividend(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        bytes32 _name\r\n    ) \r\n        external \r\n        withPerm(MANAGE)\r\n    {\r\n        createDividendWithExclusions(_maturity, _expiry, _token, _amount, excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _checkpointId Checkpoint id from which to create dividends\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividendWithCheckpoint(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _checkpointId,\r\n        bytes32 _name\r\n    )\r\n        external\r\n        withPerm(MANAGE)\r\n    {\r\n        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _token, _amount, _checkpointId, excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend and checkpoint for the dividend\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividendWithExclusions(\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        address[] _excluded,\r\n        bytes32 _name\r\n    )\r\n        public\r\n        withPerm(MANAGE)\r\n    {\r\n        uint256 checkpointId = ISecurityToken(securityToken).createCheckpoint();\r\n        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _token, _amount, checkpointId, _excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _checkpointId Checkpoint id from which to create dividends\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function createDividendWithCheckpointAndExclusions(\r\n        uint256 _maturity, \r\n        uint256 _expiry, \r\n        address _token, \r\n        uint256 _amount, \r\n        uint256 _checkpointId, \r\n        address[] _excluded,\r\n        bytes32 _name\r\n    ) \r\n        public\r\n        withPerm(MANAGE)      \r\n    {\r\n        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _token, _amount, _checkpointId, _excluded, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a dividend with a provided checkpoint\r\n     * @param _maturity Time from which dividend can be paid\r\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\r\n     * @param _token Address of ERC20 token in which dividend is to be denominated\r\n     * @param _amount Amount of specified token for dividend\r\n     * @param _checkpointId Checkpoint id from which to create dividends\r\n     * @param _excluded List of addresses to exclude\r\n     * @param _name Name/Title for identification\r\n     */\r\n    function _createDividendWithCheckpointAndExclusions(\r\n        uint256 _maturity, \r\n        uint256 _expiry, \r\n        address _token, \r\n        uint256 _amount, \r\n        uint256 _checkpointId, \r\n        address[] _excluded,\r\n        bytes32 _name\r\n    ) \r\n        internal  \r\n    {\r\n        ISecurityToken securityTokenInstance = ISecurityToken(securityToken);\r\n        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many addresses excluded\");\r\n        require(_expiry > _maturity, \"Expiry before maturity\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(_expiry > now, \"Expiry in past\");\r\n        require(_amount > 0, \"No dividend sent\");\r\n        require(_token != address(0), \"Invalid token\");\r\n        require(_checkpointId <= securityTokenInstance.currentCheckpointId(), \"Invalid checkpoint\");\r\n        require(IERC20(_token).transferFrom(msg.sender, address(this), _amount), \"insufficent allowance\");\r\n        require(_name[0] != 0);\r\n        uint256 dividendIndex = dividends.length;\r\n        uint256 currentSupply = securityTokenInstance.totalSupplyAt(_checkpointId);\r\n        uint256 excludedSupply = 0;\r\n        dividends.push(\r\n          Dividend(\r\n            _checkpointId,\r\n            now, /*solium-disable-line security/no-block-members*/\r\n            _maturity,\r\n            _expiry,\r\n            _amount,\r\n            0,\r\n            0,\r\n            false,\r\n            0,\r\n            0,\r\n            _name\r\n          )\r\n        );\r\n\r\n        for (uint256 j = 0; j < _excluded.length; j++) {\r\n            require (_excluded[j] != address(0), \"Invalid address\");\r\n            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], \"duped exclude address\");\r\n            excludedSupply = excludedSupply.add(securityTokenInstance.balanceOfAt(_excluded[j], _checkpointId));\r\n            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;\r\n        }\r\n\r\n        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);\r\n        dividendTokens[dividendIndex] = _token;\r\n        _emitERC20DividendDepositedEvent(_checkpointId, _maturity, _expiry, _token, _amount, currentSupply, dividendIndex, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Emits the ERC20DividendDeposited event. \r\n     * Seperated into a different function as a workaround for stack too deep error\r\n     */\r\n    function _emitERC20DividendDepositedEvent(\r\n        uint256 _checkpointId,\r\n        uint256 _maturity,\r\n        uint256 _expiry,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 currentSupply,\r\n        uint256 dividendIndex,\r\n        bytes32 _name\r\n    )\r\n        internal\r\n    {\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ERC20DividendDeposited(msg.sender, _checkpointId, now, _maturity, _expiry, _token, _amount, currentSupply, dividendIndex, _name);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function for paying dividends\r\n     * @param _payee Address of investor\r\n     * @param _dividend Storage with previously issued dividends\r\n     * @param _dividendIndex Dividend to pay\r\n     */\r\n    function _payDividend(address _payee, Dividend storage _dividend, uint256 _dividendIndex) internal {\r\n        (uint256 claim, uint256 withheld) = calculateDividend(_dividendIndex, _payee);\r\n        _dividend.claimed[_payee] = true;\r\n        _dividend.claimedAmount = claim.add(_dividend.claimedAmount);\r\n        uint256 claimAfterWithheld = claim.sub(withheld);\r\n        if (claimAfterWithheld > 0) {\r\n            require(IERC20(dividendTokens[_dividendIndex]).transfer(_payee, claimAfterWithheld), \"transfer failed\");\r\n            _dividend.dividendWithheld = _dividend.dividendWithheld.add(withheld);\r\n            investorWithheld[_payee] = investorWithheld[_payee].add(withheld);\r\n            emit ERC20DividendClaimed(_payee, _dividendIndex, dividendTokens[_dividendIndex], claim, withheld);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\r\n     * @param _dividendIndex Dividend to reclaim\r\n     */\r\n    function reclaimDividend(uint256 _dividendIndex) external withPerm(MANAGE) {\r\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(now >= dividends[_dividendIndex].expiry, \"Dividend expiry in future\");\r\n        require(!dividends[_dividendIndex].reclaimed, \"already claimed\");\r\n        dividends[_dividendIndex].reclaimed = true;\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        uint256 remainingAmount = dividend.amount.sub(dividend.claimedAmount);\r\n        address owner = IOwnable(securityToken).owner();\r\n        require(IERC20(dividendTokens[_dividendIndex]).transfer(owner, remainingAmount), \"transfer failed\");\r\n        emit ERC20DividendReclaimed(owner, _dividendIndex, dividendTokens[_dividendIndex], remainingAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows issuer to withdraw withheld tax\r\n     * @param _dividendIndex Dividend to withdraw from\r\n     */\r\n    function withdrawWithholding(uint256 _dividendIndex) external withPerm(MANAGE) {\r\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\r\n        Dividend storage dividend = dividends[_dividendIndex];\r\n        uint256 remainingWithheld = dividend.dividendWithheld.sub(dividend.dividendWithheldReclaimed);\r\n        dividend.dividendWithheldReclaimed = dividend.dividendWithheld;\r\n        address owner = IOwnable(securityToken).owner();\r\n        require(IERC20(dividendTokens[_dividendIndex]).transfer(owner, remainingWithheld), \"transfer failed\");\r\n        emit ERC20DividendWithholdingWithdrawn(owner, _dividendIndex, dividendTokens[_dividendIndex], remainingWithheld);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module factory contract should implement\r\n */\r\ninterface IModuleFactory {\r\n\r\n    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\r\n    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\r\n    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\r\n    event GenerateModuleFromFactory(\r\n        address _module,\r\n        bytes32 indexed _moduleName,\r\n        address indexed _moduleFactory,\r\n        address _creator,\r\n        uint256 _setupCost,\r\n        uint256 _timestamp\r\n    );\r\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    //Should create an instance of the Module, or throw\r\n    function deploy(bytes _data) external returns(address);\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[]);\r\n\r\n    /**\r\n     * @notice Get the name of the Module\r\n     */\r\n    function getName() external view returns(bytes32);\r\n\r\n    /**\r\n     * @notice Returns the instructions associated with the module\r\n     */\r\n    function getInstructions() external view returns (string);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns (bytes32[]);\r\n\r\n    /**\r\n     * @notice Used to change the setup fee\r\n     * @param _newSetupCost New setup fee\r\n     */\r\n    function changeFactorySetupFee(uint256 _newSetupCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the usage fee\r\n     * @param _newUsageCost New usage fee\r\n     */\r\n    function changeFactoryUsageFee(uint256 _newUsageCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the subscription fee\r\n     * @param _newSubscriptionCost New subscription fee\r\n     */\r\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) external;\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion New version array\r\n     */\r\n    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external;\r\n\r\n   /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function getSetupCost() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return Lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Used to get the upper bound\r\n     * @return Upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[]);\r\n\r\n}\r\n\r\n/**\r\n * @title Helper library use to compare or validate the semantic versions\r\n */\r\n\r\nlibrary VersionUtils {\r\n\r\n    /**\r\n     * @notice This function is used to validate the version submitted\r\n     * @param _current Array holds the present version of ST\r\n     * @param _new Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function isValidVersion(uint8[] _current, uint8[] _new) internal pure returns(bool) {\r\n        bool[] memory _temp = new bool[](_current.length);\r\n        uint8 counter = 0;\r\n        for (uint8 i = 0; i < _current.length; i++) {\r\n            if (_current[i] < _new[i])\r\n                _temp[i] = true;\r\n            else\r\n                _temp[i] = false;\r\n        }\r\n\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (i == 0) {\r\n                if (_current[i] <= _new[i])\r\n                    if(_temp[0]) {\r\n                        counter = counter + 3;\r\n                        break;\r\n                    } else\r\n                        counter++;\r\n                else\r\n                    return false;\r\n            } else {\r\n                if (_temp[i-1])\r\n                    counter++;\r\n                else if (_current[i] <= _new[i])\r\n                    counter++;\r\n                else\r\n                    return false;\r\n            }\r\n        }\r\n        if (counter == _current.length)\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to compare the lower bound with the latest version\r\n     * @param _version1 Array holds the lower bound of the version\r\n     * @param _version2 Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function compareLowerBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\r\n        require(_version1.length == _version2.length, \"Input length mismatch\");\r\n        uint counter = 0;\r\n        for (uint8 j = 0; j < _version1.length; j++) {\r\n            if (_version1[j] == 0)\r\n                counter ++;\r\n        }\r\n        if (counter != _version1.length) {\r\n            counter = 0;\r\n            for (uint8 i = 0; i < _version1.length; i++) {\r\n                if (_version2[i] > _version1[i])\r\n                    return true;\r\n                else if (_version2[i] < _version1[i])\r\n                    return false;\r\n                else\r\n                    counter++;\r\n            }\r\n            if (counter == _version1.length - 1)\r\n                return true;\r\n            else\r\n                return false;\r\n        } else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to compare the upper bound with the latest version\r\n     * @param _version1 Array holds the upper bound of the version\r\n     * @param _version2 Array holds the latest version of the ST\r\n     * @return bool\r\n     */\r\n    function compareUpperBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {\r\n        require(_version1.length == _version2.length, \"Input length mismatch\");\r\n        uint counter = 0;\r\n        for (uint8 j = 0; j < _version1.length; j++) {\r\n            if (_version1[j] == 0)\r\n                counter ++;\r\n        }\r\n        if (counter != _version1.length) {\r\n            counter = 0;\r\n            for (uint8 i = 0; i < _version1.length; i++) {\r\n                if (_version1[i] > _version2[i])\r\n                    return true;\r\n                else if (_version1[i] < _version2[i])\r\n                    return false;\r\n                else\r\n                    counter++;\r\n            }\r\n            if (counter == _version1.length - 1)\r\n                return true;\r\n            else\r\n                return false;\r\n        } else\r\n            return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Used to pack the uint8[] array data into uint24 value\r\n     * @param _major Major version\r\n     * @param _minor Minor version\r\n     * @param _patch Patch version\r\n     */\r\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\r\n        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into uint8 array\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpack(uint24 _packedVersion) internal pure returns (uint8[]) {\r\n        uint8[] memory _unpackVersion = new uint8[](3);\r\n        _unpackVersion[0] = uint8(_packedVersion >> 16);\r\n        _unpackVersion[1] = uint8(_packedVersion >> 8);\r\n        _unpackVersion[2] = uint8(_packedVersion);\r\n        return _unpackVersion;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that any module factory contract should implement\r\n * @notice Contract is abstract\r\n */\r\ncontract ModuleFactory is IModuleFactory, Ownable {\r\n\r\n    IERC20 public polyToken;\r\n    uint256 public usageCost;\r\n    uint256 public monthlySubscriptionCost;\r\n\r\n    uint256 public setupCost;\r\n    string public description;\r\n    string public version;\r\n    bytes32 public name;\r\n    string public title;\r\n\r\n    // @notice Allow only two variables to be stored\r\n    // 1. lowerBound \r\n    // 2. upperBound\r\n    // @dev (0.0.0 will act as the wildcard) \r\n    // @dev uint24 consists packed value of uint8 _major, uint8 _minor, uint8 _patch\r\n    mapping(string => uint24) compatibleSTVersionRange;\r\n\r\n    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);\r\n    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\r\n    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\r\n    event GenerateModuleFromFactory(\r\n        address _module,\r\n        bytes32 indexed _moduleName,\r\n        address indexed _moduleFactory,\r\n        address _creator,\r\n        uint256 _timestamp\r\n    );\r\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {\r\n        polyToken = IERC20(_polyAddress);\r\n        setupCost = _setupCost;\r\n        usageCost = _usageCost;\r\n        monthlySubscriptionCost = _subscriptionCost;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the fee of the setup cost\r\n     * @param _newSetupCost new setup cost\r\n     */\r\n    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {\r\n        emit ChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\r\n        setupCost = _newSetupCost;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the fee of the usage cost\r\n     * @param _newUsageCost new usage cost\r\n     */\r\n    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {\r\n        emit ChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\r\n        usageCost = _newUsageCost;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the fee of the subscription cost\r\n     * @param _newSubscriptionCost new subscription cost\r\n     */\r\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {\r\n        emit ChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\r\n        monthlySubscriptionCost = _newSubscriptionCost;\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the title of the ModuleFactory\r\n     * @param _newTitle New Title that will replace the old one.\r\n     */\r\n    function changeTitle(string _newTitle) public onlyOwner {\r\n        require(bytes(_newTitle).length > 0, \"Invalid title\");\r\n        title = _newTitle;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the description of the ModuleFactory\r\n     * @param _newDesc New description that will replace the old one.\r\n     */\r\n    function changeDescription(string _newDesc) public onlyOwner {\r\n        require(bytes(_newDesc).length > 0, \"Invalid description\");\r\n        description = _newDesc;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the name of the ModuleFactory\r\n     * @param _newName New name that will replace the old one.\r\n     */\r\n    function changeName(bytes32 _newName) public onlyOwner {\r\n        require(_newName != bytes32(0),\"Invalid name\");\r\n        name = _newName;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the version of the ModuleFactory\r\n     * @param _newVersion New name that will replace the old one.\r\n     */\r\n    function changeVersion(string _newVersion) public onlyOwner {\r\n        require(bytes(_newVersion).length > 0, \"Invalid version\");\r\n        version = _newVersion;\r\n    }\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion new version array\r\n     */\r\n    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external onlyOwner {\r\n        require(\r\n            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked(\"lowerBound\")) ||\r\n            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked(\"upperBound\")),\r\n            \"Must be a valid bound type\"\r\n        );\r\n        require(_newVersion.length == 3);\r\n        if (compatibleSTVersionRange[_boundType] != uint24(0)) { \r\n            uint8[] memory _currentVersion = VersionUtils.unpack(compatibleSTVersionRange[_boundType]);\r\n            require(VersionUtils.isValidVersion(_currentVersion, _newVersion), \"Failed because of in-valid version\");\r\n        }\r\n        compatibleSTVersionRange[_boundType] = VersionUtils.pack(_newVersion[0], _newVersion[1], _newVersion[2]);\r\n        emit ChangeSTVersionBound(_boundType, _newVersion[0], _newVersion[1], _newVersion[2]);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[]) {\r\n        return VersionUtils.unpack(compatibleSTVersionRange[\"lowerBound\"]);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to get the upper bound\r\n     * @return upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[]) {\r\n        return VersionUtils.unpack(compatibleSTVersionRange[\"upperBound\"]);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function getSetupCost() external view returns (uint256) {\r\n        return setupCost;\r\n    }\r\n\r\n   /**\r\n    * @notice Get the name of the Module\r\n    */\r\n    function getName() public view returns(bytes32) {\r\n        return name;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Factory for deploying ERC20DividendCheckpoint module\r\n */\r\ncontract ERC20DividendCheckpointFactory is ModuleFactory {\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _polyAddress Address of the polytoken\r\n     * @param _setupCost Setup cost of the module\r\n     * @param _usageCost Usage cost of the module\r\n     * @param _subscriptionCost Subscription cost of the module\r\n     */\r\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public\r\n    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)\r\n    {\r\n        version = \"1.0.0\";\r\n        name = \"ERC20DividendCheckpoint\";\r\n        title = \"ERC20 Dividend Checkpoint\";\r\n        description = \"Create ERC20 dividends for token holders at a specific checkpoint\";\r\n        compatibleSTVersionRange[\"lowerBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\r\n        compatibleSTVersionRange[\"upperBound\"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Used to launch the Module with the help of factory\r\n     * @return Address Contract address of the Module\r\n     */\r\n    function deploy(bytes /* _data */) external returns(address) {\r\n        if (setupCost > 0)\r\n            require(polyToken.transferFrom(msg.sender, owner, setupCost), \"insufficent allowance\");\r\n        address erc20DividendCheckpoint = new ERC20DividendCheckpoint(msg.sender, address(polyToken));\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit GenerateModuleFromFactory(erc20DividendCheckpoint, getName(), address(this), msg.sender, setupCost, now);\r\n        return erc20DividendCheckpoint;\r\n    }\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[]) {\r\n        uint8[] memory res = new uint8[](1);\r\n        res[0] = 4;\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the instructions associated with the module\r\n     */\r\n    function getInstructions() external view returns(string) {\r\n        return \"Create ERC20 dividend to be paid out to token holders based on their balances at dividend creation time\";\r\n    }\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns(bytes32[]) {\r\n        bytes32[] memory availableTags = new bytes32[](3);\r\n        availableTags[0] = \"ERC20\";\r\n        availableTags[1] = \"Dividend\";\r\n        availableTags[2] = \"Checkpoint\";\r\n        return availableTags;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monthlySubscriptionCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTitle\",\"type\":\"string\"}],\"name\":\"changeTitle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSubscriptionCost\",\"type\":\"uint256\"}],\"name\":\"changeFactorySubscriptionFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"title\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSetupCost\",\"type\":\"uint256\"}],\"name\":\"changeFactorySetupFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVersion\",\"type\":\"string\"}],\"name\":\"changeVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setupCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLowerSTVersionBounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newName\",\"type\":\"bytes32\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTags\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSetupCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newUsageCost\",\"type\":\"uint256\"}],\"name\":\"changeFactoryUsageFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usageCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstructions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDesc\",\"type\":\"string\"}],\"name\":\"changeDescription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpperSTVersionBounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_boundType\",\"type\":\"string\"},{\"name\":\"_newVersion\",\"type\":\"uint8[]\"}],\"name\":\"changeSTVersionBounds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_polyAddress\",\"type\":\"address\"},{\"name\":\"_setupCost\",\"type\":\"uint256\"},{\"name\":\"_usageCost\",\"type\":\"uint256\"},{\"name\":\"_subscriptionCost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldSetupCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newSetupCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_moduleFactory\",\"type\":\"address\"}],\"name\":\"ChangeFactorySetupFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldUsageCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newUsageCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_moduleFactory\",\"type\":\"address\"}],\"name\":\"ChangeFactoryUsageFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldSubscriptionCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newMonthlySubscriptionCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_moduleFactory\",\"type\":\"address\"}],\"name\":\"ChangeFactorySubscriptionFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_moduleName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"GenerateModuleFromFactory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_boundType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_major\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_minor\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"ChangeSTVersionBound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_moduleName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_moduleFactory\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_setupCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"GenerateModuleFromFactory\",\"type\":\"event\"}]","ContractName":"ERC20DividendCheckpointFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009992ec3cf6a55b00978cddf2b27bc6882d88d1ec000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://8d966a38f79987a8bb6bc7b6102d5075763a8a79b13ea684b7f90364595635e0"}]}