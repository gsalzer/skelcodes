{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract ERC721Basic {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\r\n}\r\n\r\ncontract ERC721Enumerable is ERC721Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\ncontract ERC721Metadata is ERC721Basic {\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {}\r\n\r\ncontract ERC721Receiver {\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        returns(bytes4);\r\n}\r\n\r\ncontract ERC721BasicToken is ERC721Basic, Upgradable {\r\n\r\n    using SafeMath256 for uint256;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    function _checkRights(bool _has) internal pure {\r\n        require(_has, \"no rights to manage\");\r\n    }\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    function _checkOwner(uint256 _tokenId, address _owner) internal view {\r\n        require(ownerOf(_tokenId) == _owner, \"not an owner\");\r\n    }\r\n\r\n    function _checkThatUserHasTokens(bool _has) internal pure {\r\n        require(_has, \"user has no tokens\");\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        _validateAddress(_owner);\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        _validateAddress(owner);\r\n        return owner;\r\n    }\r\n\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    function _approve(address _from, address _to, uint256 _tokenId) internal {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner, \"can't be approved to owner\");\r\n        _checkRights(_from == owner || isApprovedForAll(owner, _from));\r\n\r\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n            tokenApprovals[_tokenId] = _to;\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        _approve(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function remoteApprove(address _to, uint256 _tokenId) external onlyController {\r\n        _approve(tx.origin, _to, _tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        require(exists(_tokenId), \"token doesn't exist\");\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require(_to != msg.sender, \"wrong sender\");\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        _checkRights(isApprovedOrOwner(msg.sender, _tokenId));\r\n        _validateAddress(_from);\r\n        _validateAddress(_to);\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    ) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \"can't make safe transfer\");\r\n    }\r\n\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) public view returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        _validateAddress(_to);\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        _checkOwner(_tokenId, _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0), \"token already has an owner\");\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        _checkOwner(_tokenId, _from);\r\n        _checkThatUserHasTokens(ownedTokensCount[_from] > 0);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    function _isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    ) internal returns (bool) {\r\n        if (!_isContract(_to)) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n}\r\n\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = 0x80ac58cd;\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721TokenReceiver = 0xf0b9e5ba;\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata = 0x5b5e139f;\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Enumerable = 0x780e9d63;\r\n\r\n    string internal name_;\r\n    string internal symbol_;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping (address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) internal tokenURIs;\r\n\r\n    // The contract owner can change the base URL, in case it becomes necessary. It is needed for Metadata.\r\n    string public url;\r\n\r\n\r\n    constructor(string _name, string _symbol) public {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n    }\r\n\r\n    function name() public view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    function symbol() public view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    function _validateIndex(bool _isValid) internal pure {\r\n        require(_isValid, \"wrong index\");\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n        _validateIndex(_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns (uint256[]) {\r\n        return ownedTokens[_owner];\r\n    }\r\n\r\n    function getAllTokens() external view returns (uint256[]) {\r\n        return allTokens;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        _validateIndex(_index < totalSupply());\r\n        return allTokens[_index];\r\n    }\r\n\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        _checkThatUserHasTokens(ownedTokens[_from].length > 0);\r\n\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n\r\n        ownedTokens[_from].length--;\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        require(allTokens.length > 0, \"no tokens\");\r\n\r\n        super._burn(_owner, _tokenId);\r\n\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\r\n        return (\r\n            _interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n            _interfaceID == INTERFACE_SIGNATURE_ERC721 ||\r\n            _interfaceID == INTERFACE_SIGNATURE_ERC721TokenReceiver ||\r\n            _interfaceID == INTERFACE_SIGNATURE_ERC721Metadata ||\r\n            _interfaceID == INTERFACE_SIGNATURE_ERC721Enumerable\r\n        );\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        require(exists(_tokenId), \"token doesn't exist\");\r\n        return string(abi.encodePacked(url, _uint2str(_tokenId)));\r\n    }\r\n\r\n    function setUrl(string _url) external onlyOwner {\r\n        url = _url;\r\n    }\r\n\r\n    function _uint2str(uint _i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint i = _i;\r\n        uint j = _i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n\r\ncontract EggStorage is ERC721Token {\r\n    struct Egg {\r\n        uint256[2] parents;\r\n        uint8 dragonType; // used for genesis only\r\n    }\r\n\r\n    Egg[] eggs;\r\n\r\n    constructor(string _name, string _symbol) public ERC721Token(_name, _symbol) {\r\n        eggs.length = 1; // to avoid some issues with 0\r\n    }\r\n\r\n    function push(address _sender, uint256[2] _parents, uint8 _dragonType) public onlyController returns (uint256 id) {\r\n        Egg memory _egg = Egg(_parents, _dragonType);\r\n        id = eggs.push(_egg).sub(1);\r\n        _mint(_sender, id);\r\n    }\r\n\r\n    function get(uint256 _id) external view returns (uint256[2], uint8) {\r\n        return (eggs[_id].parents, eggs[_id].dragonType);\r\n    }\r\n\r\n    function remove(address _owner, uint256 _id) external onlyController {\r\n        delete eggs[_id];\r\n        _burn(_owner, _id);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setUrl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isApprovedOrOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"url\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_parents\",\"type\":\"uint256[2]\"},{\"name\":\"_dragonType\",\"type\":\"uint8\"}],\"name\":\"push\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"remoteApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"EggStorage","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000f447261676f6e657265756d20456767000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034547470000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://dce1a3e9506dff495db30d49398daa6b0619df832fa635d0b0beff4b4cc628c2"}]}