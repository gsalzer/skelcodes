{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  \r\n  // storage\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n    return Percent.percent(p.num, p.den);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n  \r\n  /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(owner, address(0));\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\ncontract FastLap is Ownable {\r\n    using Percent for Percent.percent;\r\n    using SafeMath for uint;\r\n    \r\n    //Address for advertising and admins expences\r\n    address constant public advertisingAddress = address(0xf86117De6539c6f48764b638412C99F3ADB19892); //рекламный\r\n    address constant public adminsAddress = address(0x33a6c786Cf6D69CC62c475B5d69947af08bB6210); //тех поддержка и автоматизация выплат\r\n    \r\n    //Percent for promo expences\r\n    Percent.percent private m_adminsPercent = Percent.percent(3, 100);       //   3/100  *100% = 3%\r\n    Percent.percent private m_advertisingPercent = Percent.percent(5, 100);// 5/100  *100% = 5%\r\n    //How many percent for your deposit to be multiplied\r\n    Percent.percent public MULTIPLIER = Percent.percent(120, 100); // 120/100 * 100% = 120%\r\n    \r\n    uint public amountRaised = 0;\r\n    //The deposit structure holds all the info about the deposit made\r\n    struct Deposit {\r\n        address depositor; //The depositor address\r\n        uint deposit;   //The deposit amount\r\n        uint expects;    //How much we should pay out (initially it is 120% of deposit)\r\n        uint paymentTime; //when payment\r\n    }\r\n\r\n    Deposit[] private Queue;  //The queue for new investments\r\n    // list of deposites for 1 user\r\n    mapping(address => uint[]) private depositors;\r\n    \r\n    uint public depositorsCount = 0;\r\n    \r\n    uint private currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\r\n    \r\n    uint public minBalanceForDistribution = 3 ether; //минимально необходимый баланс\r\n\r\n    //создаем депозит инвестора в основной очереди\r\n    function () public payable {\r\n        if(msg.value > 0){ //регистрация депозита\r\n            require(msg.value >= 0.1 ether, \"investment must be between 0.1 and 0.5 ether\"); //ограничение минимального депозита\r\n            require(msg.value <= 0.5 ether, \"investment must be between 0.1 and 0.5 ether\"); //ограничение максимального депозита\r\n\r\n            //к выплате 120% от депозита\r\n            uint expect = MULTIPLIER.mul(msg.value);\r\n            Queue.push(Deposit({depositor:msg.sender, deposit:msg.value, expects:expect, paymentTime:0}));\r\n            amountRaised += msg.value;\r\n            if (depositors[msg.sender].length == 0) depositorsCount += 1;\r\n            depositors[msg.sender].push(Queue.length - 1);\r\n            \r\n            advertisingAddress.send(m_advertisingPercent.mul(msg.value));\r\n            adminsAddress.send(m_adminsPercent.mul(msg.value));\r\n        } else { //выплаты инвесторам\r\n            uint money = address(this).balance;\r\n            require(money >= minBalanceForDistribution, \"Not enough funds to pay\");//на балансе недостаточно денег для выплат\r\n            uint QueueLen = Queue.length;\r\n            uint toSend = Queue[currentReceiverIndex].expects;\r\n            uint maxIterations = 25;//максимум 25 итераций\r\n            uint num = 0;\r\n            uint i = 0;\r\n            \r\n            while ((currentReceiverIndex < QueueLen) && (i < maxIterations) && (money >= toSend)) {\r\n                money = money.sub(toSend);\r\n                Queue[currentReceiverIndex].paymentTime = now;\r\n                num = currentReceiverIndex;\r\n                currentReceiverIndex += 1;\r\n                i +=1;\r\n                Queue[num].depositor.send(toSend);\r\n                toSend = Queue[currentReceiverIndex].expects;\r\n            }\r\n        }\r\n    }\r\n\r\n    //баланс контракта\r\n    function getNeedBalance() public view returns (uint) {\r\n        uint money = address(this).balance;\r\n        if (money >= minBalanceForDistribution){\r\n          return 0;  \r\n        } else {\r\n            return minBalanceForDistribution - money;\r\n        }\r\n    }\r\n    \r\n    //данные о депозите по порядковому номеру \r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect, uint paymentTime){\r\n        Deposit storage dep = Queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expects, dep.paymentTime);\r\n    }\r\n\r\n    //общее количество депозитов у кошелька depositor\r\n    function getUserDepositsCount(address depositor) public view returns (uint) {\r\n        return depositors[depositor].length;\r\n    }\r\n\r\n    //Все депозиты основной очереди кошелька depositor в виде массива\r\n    function getUserInfo(address depositor) public view returns (uint depCount, uint allDeps, uint payDepCount, uint allPay, uint lastPaymentTime) {\r\n        depCount = depositors[depositor].length;\r\n        allPay = 0;\r\n        allDeps = 0;\r\n        lastPaymentTime = 0;\r\n        payDepCount = 0;\r\n        uint num = 0;\r\n        \r\n        for(uint i=0; i<depCount; ++i){\r\n            num = depositors[depositor][i];\r\n            allDeps += Queue[num].deposit;\r\n            if (Queue[num].paymentTime > 0){\r\n                allPay += Queue[num].expects;\r\n                payDepCount += 1;\r\n                lastPaymentTime = Queue[num].paymentTime;\r\n            }\r\n        }\r\n        return (depCount, allDeps, payDepCount, allPay, lastPaymentTime);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBalanceForDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"name\":\"depCount\",\"type\":\"uint256\"},{\"name\":\"allDeps\",\"type\":\"uint256\"},{\"name\":\"payDepCount\",\"type\":\"uint256\"},{\"name\":\"allPay\",\"type\":\"uint256\"},{\"name\":\"lastPaymentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNeedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getUserDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FastLap","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b90fb7b72a26ea8c6aabaf6ed7a023ff02968a795f4fa5e18a3fbbe4a08ca615"}]}