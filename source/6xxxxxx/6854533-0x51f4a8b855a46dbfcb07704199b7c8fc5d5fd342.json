{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Casher\r\n{\r\n  struct casher\r\n  {\r\n     uint blockPaymentC;\r\n     uint blockPaymentI;\r\n     uint valueC;\r\n     uint valueI;\r\n  }\r\n\r\n  mapping (address => uint) private addrToIndex;\r\n  mapping (uint => casher) private indToCasher;\r\n  address private owner;\r\n  uint private currentIndex = 1;\r\n\r\n  modifier onlyOwner() \r\n  {\r\n      require(msg.sender == owner, \"access denied\");\r\n      _;\r\n  }\r\n\r\n   constructor() public \r\n   {\r\n      owner = msg.sender;\r\n   }\r\n\r\n   function insert(address addr, uint blkNum, uint value, bool isCashback) public onlyOwner returns (bool)\r\n   {\r\n      uint index = addrToIndex[addr];\r\n      if(index > 0)\r\n        return false;\r\n      addrToIndex[addr] = currentIndex;\r\n      if(isCashback)\r\n      {\r\n        indToCasher[currentIndex].valueC = value;\r\n        indToCasher[currentIndex].blockPaymentC = blkNum;\r\n      }\r\n      else\r\n      {\r\n        indToCasher[currentIndex].valueI = value;\r\n        indToCasher[currentIndex].blockPaymentI = blkNum;\r\n      }    \r\n      currentIndex++;\r\n      return true;\r\n   }\r\n\r\n   function addValue(address addr, uint blkNum, uint value, bool isCashback) public onlyOwner returns (bool)\r\n   {\r\n      uint index = addrToIndex[addr];\r\n      if(index == 0)\r\n        return false;\r\n      if(isCashback)\r\n      {\r\n        indToCasher[index].valueC += value;\r\n        indToCasher[index].blockPaymentC = blkNum;\r\n      }\r\n      else\r\n      {\r\n        indToCasher[index].valueI += value;\r\n      } \r\n      return true;\r\n   }\r\n\r\n   function getCasherIndex(address addr) public view onlyOwner returns (uint)\r\n   {\r\n      return addrToIndex[addr];\r\n   }\r\n\r\n  function getCasherBlockC(uint casherIndex) public view onlyOwner returns (uint)\r\n   {\r\n      return indToCasher[casherIndex].blockPaymentC;\r\n   }\r\n\r\n   function getCasherBlockI(uint casherIndex) public view onlyOwner returns (uint)\r\n   {\r\n      return indToCasher[casherIndex].blockPaymentI;\r\n   }\r\n\r\n   function getCasherValueC(uint casherIndex) public view onlyOwner returns (uint)\r\n   {\r\n      return indToCasher[casherIndex].valueC;\r\n   }\r\n\r\n   function getCasherValueI(uint casherIndex) public view onlyOwner returns (uint)\r\n   {\r\n      return indToCasher[casherIndex].valueI;\r\n   }\r\n\r\n   function setZeroCasherValueC(uint casherIndex) public onlyOwner\r\n   {\r\n      indToCasher[casherIndex].valueC = 0;\r\n   }\r\n\r\n   function setCasherBlockI(uint casherIndex, uint blkNum) public onlyOwner\r\n   {\r\n      indToCasher[casherIndex].blockPaymentI = blkNum;\r\n   }\r\n\r\n   function size() public view returns (uint) \r\n   {\r\n      return currentIndex;\r\n   }\r\n\r\n   function contains(address addr) public view returns (bool) \r\n   {\r\n     return addrToIndex[addr] > 0;\r\n   }\r\n}\r\n\r\nlibrary SafeMath \r\n{\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) \r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) \r\n    {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) \r\n  {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) \r\n  {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) \r\n  {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary Percent \r\n{\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent \r\n  {\r\n    uint num;\r\n    uint den;\r\n  }\r\n\r\n  function mul(percent storage p, uint a) internal view returns (uint) \r\n  {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) \r\n  {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) \r\n  {\r\n    uint b = mul(p, a);\r\n    if (b >= a) return 0;\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) \r\n  {\r\n    return a + mul(p, a);\r\n  }\r\n}\r\n\r\nlibrary ToAddress {\r\n  function toAddr(uint source) internal pure returns(address) {\r\n    return address(source);\r\n  }\r\n\r\n  function toAddr(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n}\r\n\r\ncontract CashBack \r\n{\r\n  using Percent for Percent.percent;\r\n  using SafeMath for uint;\r\n  using ToAddress for *;\r\n\r\n  Casher private cashers;\r\n\r\n  address public commissionAddr;\r\n  uint public txCount;\r\n  uint constant blockPeriod = 5900;\r\n  uint public volume;\r\n  uint public startBlock;\r\n  uint public constant minInvesment = 30 finney;\r\n\r\n  Percent.percent private m_sendPercent = Percent.percent(2, 100);\r\n\r\n  Percent.percent private m_payPercentC = Percent.percent(4, 100); \r\n  Percent.percent private m_payPercentI = Percent.percent(3, 100);\r\n\r\n  Percent.percent private m_commissionPercentC = Percent.percent(1, 100); \r\n  Percent.percent private m_commissionPercentI = Percent.percent(8, 100); \r\n\r\n  constructor() public \r\n  {\r\n    commissionAddr = 0xBC7e6445d8C099aD6b3eB2FAE695F309B8379f74;\r\n    newCycle();\r\n  }\r\n\r\n  function cashersNumber() public view returns(uint) \r\n  {\r\n    return cashers.size() - 1;\r\n  }\r\n\r\n  function balanceETH() public view returns(uint)\r\n   {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function() public payable \r\n  {\r\n    if (msg.value == 0) \r\n    {\r\n      getMyCash();\r\n      return;\r\n    }\r\n\r\n    address addr = msg.data.toAddr();\r\n    if ((addr != address(0)) && (addr != address(this)))\r\n    {\r\n      doCash(addr, true); \r\n    } \r\n    else\r\n    {\r\n      doCash(addr, false);\r\n    }\r\n    \r\n  }\r\n\r\n  function getMyCash() private \r\n  {\r\n    require(cashers.contains(msg.sender));\r\n    uint indexCasher = cashers.getCasherIndex(msg.sender);\r\n\r\n    //check cashback\r\n    uint indexBlock = cashers.getCasherBlockC(indexCasher);\r\n    uint value = cashers.getCasherValueC(indexCasher);\r\n\r\n    if((indexBlock + blockPeriod <= block.number) && (value > 0))\r\n    {\r\n      value = m_payPercentC.mul(value);\r\n  \r\n      if (address(this).balance < value) \r\n      {\r\n          newCycle();\r\n          return;\r\n      }\r\n\r\n      cashers.setZeroCasherValueC(indexCasher);\r\n      msg.sender.transfer(value);\r\n    }\r\n\r\n    //check dividents\r\n    indexBlock = cashers.getCasherBlockI(indexCasher);\r\n    value = cashers.getCasherValueI(indexCasher);\r\n    if((indexBlock + blockPeriod <= block.number) && (value > 0))\r\n    {\r\n      if(value < 1)\r\n        m_payPercentI = Percent.percent(3, 100);\r\n      if(value > 1 && value <= 2)\r\n        m_payPercentI = Percent.percent(4, 100);\r\n      if(value > 2)\r\n        m_payPercentI = Percent.percent(5, 100);\r\n      \r\n      uint times = block.number.sub(indexBlock).div(blockPeriod);\r\n      value = m_payPercentI.mul(value).mul(times);\r\n      \r\n      if (address(this).balance < value) \r\n      {\r\n          newCycle();\r\n          return;\r\n      }\r\n\r\n      cashers.setCasherBlockI(indexCasher, block.number);\r\n      msg.sender.transfer(value);\r\n    }\r\n  }\r\n\r\n  function doCash(address recipient, bool isCashBack) private \r\n  {\r\n    require(msg.value >= minInvesment, \"msg.value must be >= minInvesment\");\r\n    \r\n    if(isCashBack)\r\n    {\r\n      //statistic\r\n      volume += msg.value;\r\n      txCount++;\r\n\r\n      //commission\r\n      commissionAddr.transfer(m_commissionPercentC.mul(msg.value));\r\n\r\n      //retransfer\r\n      uint value = m_sendPercent.sub(msg.value);\r\n      recipient.transfer(value); \r\n    }\r\n    else\r\n    {\r\n      commissionAddr.transfer(m_commissionPercentI.mul(msg.value));\r\n    }\r\n      \r\n    //write to casher\r\n    if (cashers.contains(msg.sender)) \r\n    {\r\n      assert(cashers.addValue(msg.sender, block.number, msg.value, isCashBack));\r\n    }\r\n    else \r\n    {\r\n      assert(cashers.insert(msg.sender, block.number, msg.value, isCashBack));\r\n    }\r\n  }\r\n\r\n  function newCycle() private \r\n  {\r\n    cashers = new Casher();\r\n    txCount = 0;\r\n    volume = 0;\r\n    startBlock = block.number;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cashersNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"volume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CashBack","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8c403fba05654942038ae34c579e20c3efa9e98c441ce2f766e19ced013c2f76"}]}