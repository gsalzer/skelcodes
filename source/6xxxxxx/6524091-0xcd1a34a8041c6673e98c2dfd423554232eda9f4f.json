{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * TokenMinter.sol\r\n * MPS Token (Mt Pelerin Share) token minter.\r\n\r\n * More info about MPS : https://github.com/MtPelerin/MtPelerin-share-MPS\r\n\r\n * The unflattened code is available through this github tag:\r\n * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1\r\n\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n\r\n * @notice All matters regarding the intellectual property of this code \r\n * @notice or software are subject to Swiss Law without reference to its \r\n * @notice conflicts of law rules.\r\n\r\n * @notice License for each contract is available in the respective file\r\n * @notice or in the LICENSE.md file.\r\n * @notice https://github.com/MtPelerin/\r\n\r\n * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:\r\n * @notice https://github.com/OpenZeppelin/openzeppelin-solidity\r\n */\r\n\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/zeppelin/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/interface/IMintable.sol\r\n\r\n/**\r\n * @title Mintable interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract IMintable {\r\n  function mintingFinished() public view returns (bool);\r\n\r\n  function mint(address _to, uint256 _amount) public returns (bool);\r\n  function finishMinting() public returns (bool);\r\n \r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n}\r\n\r\n// File: contracts/interface/IMintableByLot.sol\r\n\r\n/**\r\n * @title MintableByLot interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract IMintableByLot is IMintable {\r\n  function minterLotId(address _minter) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interface/ISeizable.sol\r\n\r\n/**\r\n * @title ISeizable\r\n * @dev ISeizable interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract ISeizable {\r\n  function seize(address _account, uint256 _value) public;\r\n  event Seize(address account, uint256 amount);\r\n}\r\n\r\n// File: contracts/Authority.sol\r\n\r\n/**\r\n * @title Authority\r\n * @dev The Authority contract has an authority address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * Authority means to represent a legal entity that is entitled to specific rights\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * AU01: Message sender must be an authority\r\n */\r\ncontract Authority is Ownable {\r\n\r\n  address authority;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the authority.\r\n   */\r\n  modifier onlyAuthority {\r\n    require(msg.sender == authority, \"AU01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev return the address associated to the authority\r\n   */\r\n  function authorityAddress() public view returns (address) {\r\n    return authority;\r\n  }\r\n\r\n  /**\r\n   * @dev rdefines an authority\r\n   * @param _name the authority name\r\n   * @param _address the authority address.\r\n   */\r\n  function defineAuthority(string _name, address _address) public onlyOwner {\r\n    emit AuthorityDefined(_name, _address);\r\n    authority = _address;\r\n  }\r\n\r\n  event AuthorityDefined(\r\n    string name,\r\n    address _address\r\n  );\r\n}\r\n\r\n// File: contracts/token/component/SeizableToken.sol\r\n\r\n/**\r\n * @title SeizableToken\r\n * @dev BasicToken contract which allows owner to seize accounts\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * ST01: Owner cannot seize itself\r\n*/\r\ncontract SeizableToken is BasicToken, Authority, ISeizable {\r\n  using SafeMath for uint256;\r\n\r\n  // Although very unlikely, the value below may overflow.\r\n  // This contract and its children should expect it to happened and consider\r\n  // this value as only the first 256 bits of the complete value.\r\n  uint256 public allTimeSeized = 0; // overflow may happend\r\n\r\n  /**\r\n   * @dev called by the owner to seize value from the account\r\n   */\r\n  function seize(address _account, uint256 _value)\r\n    public onlyAuthority\r\n  {\r\n    require(_account != owner, \"ST01\");\r\n\r\n    balances[_account] = balances[_account].sub(_value);\r\n    balances[authority] = balances[authority].add(_value);\r\n\r\n    allTimeSeized += _value;\r\n    emit Seize(_account, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/zeppelin/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interface/IProvableOwnership.sol\r\n\r\n/**\r\n * @title IProvableOwnership\r\n * @dev IProvableOwnership interface which describe proof of ownership.\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IProvableOwnership {\r\n  function proofLength(address _holder) public view returns (uint256);\r\n  function proofAmount(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function proofDateFrom(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function proofDateTo(address _holder, uint256 _proofId)\r\n    public view returns (uint256);\r\n\r\n  function createProof(address _holder) public;\r\n  function checkProof(address _holder, uint256 _proofId, uint256 _at)\r\n    public view returns (uint256);\r\n\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n    ) public returns (bool);\r\n\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n    ) public returns (bool);\r\n\r\n  event ProofOfOwnership(address indexed holder, uint256 proofId);\r\n}\r\n\r\n// File: contracts/interface/IAuditableToken.sol\r\n\r\n/**\r\n * @title IAuditableToken\r\n * @dev IAuditableToken interface describing the audited data\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IAuditableToken {\r\n  function lastTransactionAt(address _address) public view returns (uint256);\r\n  function lastReceivedAt(address _address) public view returns (uint256);\r\n  function lastSentAt(address _address) public view returns (uint256);\r\n  function transactionCount(address _address) public view returns (uint256);\r\n  function receivedCount(address _address) public view returns (uint256);\r\n  function sentCount(address _address) public view returns (uint256);\r\n  function totalReceivedAmount(address _address) public view returns (uint256);\r\n  function totalSentAmount(address _address) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/token/component/AuditableToken.sol\r\n\r\n/**\r\n * @title AuditableToken\r\n * @dev AuditableToken contract\r\n * AuditableToken provides transaction data which can be used\r\n * in other smart contracts\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract AuditableToken is IAuditableToken, StandardToken {\r\n\r\n   // Although very unlikely, the following values below may overflow:\r\n   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount\r\n   // This contract and its children should expect it to happen and consider\r\n   // these values as only the first 256 bits of the complete value.\r\n  struct Audit {\r\n    uint256 createdAt;\r\n    uint256 lastReceivedAt;\r\n    uint256 lastSentAt;\r\n    uint256 receivedCount; // potential overflow\r\n    uint256 sentCount; // poential overflow\r\n    uint256 totalReceivedAmount; // potential overflow\r\n    uint256 totalSentAmount; // potential overflow\r\n  }\r\n  mapping(address => Audit) internal audits;\r\n\r\n  /**\r\n   * @dev Time of the creation of the audit struct\r\n   */\r\n  function auditCreatedAt(address _address) public view returns (uint256) {\r\n    return audits[_address].createdAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last transaction\r\n   */\r\n  function lastTransactionAt(address _address) public view returns (uint256) {\r\n    return ( audits[_address].lastReceivedAt > audits[_address].lastSentAt ) ?\r\n      audits[_address].lastReceivedAt : audits[_address].lastSentAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last received transaction\r\n   */\r\n  function lastReceivedAt(address _address) public view returns (uint256) {\r\n    return audits[_address].lastReceivedAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Time of the last sent transaction\r\n   */\r\n  function lastSentAt(address _address) public view returns (uint256) {\r\n    return audits[_address].lastSentAt;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of transactions\r\n   */\r\n  function transactionCount(address _address) public view returns (uint256) {\r\n    return audits[_address].receivedCount + audits[_address].sentCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of received transactions\r\n   */\r\n  function receivedCount(address _address) public view returns (uint256) {\r\n    return audits[_address].receivedCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Count of sent transactions\r\n   */\r\n  function sentCount(address _address) public view returns (uint256) {\r\n    return audits[_address].sentCount;\r\n  }\r\n\r\n  /**\r\n   * @dev All time received\r\n   */\r\n  function totalReceivedAmount(address _address)\r\n    public view returns (uint256)\r\n  {\r\n    return audits[_address].totalReceivedAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev All time sent\r\n   */\r\n  function totalSentAmount(address _address) public view returns (uint256) {\r\n    return audits[_address].totalSentAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    if (!super.transfer(_to, _value)) {\r\n      return false;\r\n    }\r\n    updateAudit(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool)\r\n  {\r\n    if (!super.transferFrom(_from, _to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    updateAudit(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n /**\r\n   * @dev currentTime()\r\n   */\r\n  function currentTime() internal view returns (uint256) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return now;\r\n  }\r\n\r\n  /**\r\n   * @dev Update audit data\r\n   */\r\n  function updateAudit(address _sender, address _receiver, uint256 _value)\r\n    private returns (uint256)\r\n  {\r\n    Audit storage senderAudit = audits[_sender];\r\n    senderAudit.lastSentAt = currentTime();\r\n    senderAudit.sentCount++;\r\n    senderAudit.totalSentAmount += _value;\r\n    if (senderAudit.createdAt == 0) {\r\n      senderAudit.createdAt = currentTime();\r\n    }\r\n\r\n    Audit storage receiverAudit = audits[_receiver];\r\n    receiverAudit.lastReceivedAt = currentTime();\r\n    receiverAudit.receivedCount++;\r\n    receiverAudit.totalReceivedAmount += _value;\r\n    if (receiverAudit.createdAt == 0) {\r\n      receiverAudit.createdAt = currentTime();\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/ProvableOwnershipToken.sol\r\n\r\n/**\r\n * @title ProvableOwnershipToken\r\n * @dev ProvableOwnershipToken is a StandardToken\r\n * with ability to record a proof of ownership\r\n *\r\n * When desired a proof of ownership can be generated.\r\n * The proof is stored within the contract.\r\n * A proofId is then returned.\r\n * The proof can later be used to retrieve the amount needed.\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {\r\n  struct Proof {\r\n    uint256 amount;\r\n    uint256 dateFrom;\r\n    uint256 dateTo;\r\n  }\r\n  mapping(address => mapping(uint256 => Proof)) internal proofs;\r\n  mapping(address => uint256) internal proofLengths;\r\n\r\n  /**\r\n   * @dev number of proof stored in the contract\r\n   */\r\n  function proofLength(address _holder) public view returns (uint256) {\r\n    return proofLengths[_holder];\r\n  }\r\n\r\n  /**\r\n   * @dev amount contains for the proofId reccord\r\n   */\r\n  function proofAmount(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].amount;\r\n  }\r\n\r\n  /**\r\n   * @dev date from which the proof is valid\r\n   */\r\n  function proofDateFrom(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].dateFrom;\r\n  }\r\n\r\n  /**\r\n   * @dev date until the proof is valid\r\n   */\r\n  function proofDateTo(address _holder, uint256 _proofId)\r\n    public view returns (uint256)\r\n  {\r\n    return proofs[_holder][_proofId].dateTo;\r\n  }\r\n\r\n  /**\r\n   * @dev called to challenge a proof at a point in the past\r\n   * Return the amount tokens owned by the proof owner at that time\r\n   */\r\n  function checkProof(address _holder, uint256 _proofId, uint256 _at)\r\n    public view returns (uint256)\r\n  {\r\n    if (_proofId < proofLengths[_holder]) {\r\n      Proof storage proof = proofs[_holder][_proofId];\r\n\r\n      if (proof.dateFrom <= _at && _at <= proof.dateTo) {\r\n        return proof.amount;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @dev called to create a proof of token ownership\r\n   */\r\n  function createProof(address _holder) public {\r\n    createProofInternal(\r\n      _holder,\r\n      balanceOf(_holder),\r\n      lastTransactionAt(_holder)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer function with also create a proof of ownership to any of the participants\r\n   * @param _proofSender if true a proof will be created for the sender\r\n   * @param _proofReceiver if true a proof will be created for the receiver\r\n   */\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofSender,\r\n    bool _proofReceiver\r\n  ) public returns (bool)\r\n  {\r\n    uint256 balanceBeforeFrom = balanceOf(msg.sender);\r\n    uint256 beforeFrom = lastTransactionAt(msg.sender);\r\n    uint256 balanceBeforeTo = balanceOf(_to);\r\n    uint256 beforeTo = lastTransactionAt(_to);\r\n\r\n    if (!super.transfer(_to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    transferPostProcessing(\r\n      msg.sender,\r\n      balanceBeforeFrom,\r\n      beforeFrom,\r\n      _proofSender\r\n    );\r\n    transferPostProcessing(\r\n      _to,\r\n      balanceBeforeTo,\r\n      beforeTo,\r\n      _proofReceiver\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev transfer function with also create a proof of ownership to any of the participants\r\n   * @param _proofSender if true a proof will be created for the sender\r\n   * @param _proofReceiver if true a proof will be created for the receiver\r\n   */\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to, \r\n    uint256 _value,\r\n    bool _proofSender, bool _proofReceiver)\r\n    public returns (bool)\r\n  {\r\n    uint256 balanceBeforeFrom = balanceOf(_from);\r\n    uint256 beforeFrom = lastTransactionAt(_from);\r\n    uint256 balanceBeforeTo = balanceOf(_to);\r\n    uint256 beforeTo = lastTransactionAt(_to);\r\n\r\n    if (!super.transferFrom(_from, _to, _value)) {\r\n      return false;\r\n    }\r\n\r\n    transferPostProcessing(\r\n      _from,\r\n      balanceBeforeFrom,\r\n      beforeFrom,\r\n      _proofSender\r\n    );\r\n    transferPostProcessing(\r\n      _to,\r\n      balanceBeforeTo,\r\n      beforeTo,\r\n      _proofReceiver\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev can be used to force create a proof (with a fake amount potentially !)\r\n   * Only usable by child contract internaly\r\n   */\r\n  function createProofInternal(\r\n    address _holder, uint256 _amount, uint256 _from) internal\r\n  {\r\n    uint proofId = proofLengths[_holder];\r\n    // solium-disable-next-line security/no-block-members\r\n    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());\r\n    proofLengths[_holder] = proofId+1;\r\n    emit ProofOfOwnership(_holder, proofId);\r\n  }\r\n\r\n  /**\r\n   * @dev private function updating contract state after a transfer operation\r\n   */\r\n  function transferPostProcessing(\r\n    address _holder,\r\n    uint256 _balanceBefore,\r\n    uint256 _before,\r\n    bool _proof) private\r\n  {\r\n    if (_proof) {\r\n      createProofInternal(_holder, _balanceBefore, _before);\r\n    }\r\n  }\r\n\r\n  event ProofOfOwnership(address indexed holder, uint256 proofId);\r\n}\r\n\r\n// File: contracts/interface/IClaimable.sol\r\n\r\n/**\r\n * @title IClaimable\r\n * @dev IClaimable interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ninterface IClaimable {\r\n  function hasClaimsSince(address _address, uint256 at)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IWithClaims.sol\r\n\r\n/**\r\n * @title IWithClaims\r\n * @dev IWithClaims interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IWithClaims {\r\n  function claimableLength() public view returns (uint256);\r\n  function claimable(uint256 _claimableId) public view returns (IClaimable);\r\n  function hasClaims(address _holder) public view returns (bool);\r\n  function defineClaimables(IClaimable[] _claimables) public;\r\n\r\n  event ClaimablesDefined(uint256 count);\r\n}\r\n\r\n// File: contracts/token/component/TokenWithClaims.sol\r\n\r\n/**\r\n * @title TokenWithClaims\r\n * @dev TokenWithClaims contract\r\n * TokenWithClaims is a token that will create a\r\n * proofOfOwnership during transfers if a claim can be made.\r\n * Holder may ask for the claim later using the proofOfOwnership\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * E01: Claimable address must be defined\r\n * E02: Claimables parameter must not be empty\r\n * E03: Claimable does not exist\r\n**/\r\ncontract TokenWithClaims is IWithClaims, ProvableOwnershipToken {\r\n\r\n  IClaimable[] claimables;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IClaimable[] _claimables) public {\r\n    claimables = _claimables;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of claimables\r\n   */\r\n  function claimableLength() public view returns (uint256) {\r\n    return claimables.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the Claimable associated to the specified claimableId\r\n   */\r\n  function claimable(uint256 _claimableId) public view returns (IClaimable) {\r\n    return claimables[_claimableId];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if there are any claims associated to this token\r\n   * to be made at this time for the _holder\r\n   */\r\n  function hasClaims(address _holder) public view returns (bool) {\r\n    uint256 lastTransaction = lastTransactionAt(_holder);\r\n    for (uint256 i = 0; i < claimables.length; i++) {\r\n      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @dev Override the transfer function with transferWithProofs\r\n   * A proof of ownership will be made if any claims can be made by the participants\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    bool proofFrom = hasClaims(msg.sender);\r\n    bool proofTo = hasClaims(_to);\r\n\r\n    return super.transferWithProofs(\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Override the transfer function with transferWithProofs\r\n   * A proof of ownership will be made if any claims can be made by the participants\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool)\r\n  {\r\n    bool proofFrom = hasClaims(_from);\r\n    bool proofTo = hasClaims(_to);\r\n\r\n    return super.transferFromWithProofs(\r\n      _from,\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer with proofs\r\n   */\r\n  function transferWithProofs(\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n  ) public returns (bool)\r\n  {\r\n    bool proofFrom = _proofFrom || hasClaims(msg.sender);\r\n    bool proofTo = _proofTo || hasClaims(_to);\r\n\r\n    return super.transferWithProofs(\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev transfer from with proofs\r\n   */\r\n  function transferFromWithProofs(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bool _proofFrom,\r\n    bool _proofTo\r\n  ) public returns (bool)\r\n  {\r\n    bool proofFrom = _proofFrom || hasClaims(_from);\r\n    bool proofTo = _proofTo || hasClaims(_to);\r\n\r\n    return super.transferFromWithProofs(\r\n      _from,\r\n      _to,\r\n      _value,\r\n      proofFrom,\r\n      proofTo\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev define claimables contract to this token\r\n   */\r\n  function defineClaimables(IClaimable[] _claimables) public onlyOwner {\r\n    claimables = _claimables;\r\n    emit ClaimablesDefined(claimables.length);\r\n  }\r\n}\r\n\r\n// File: contracts/interface/IRule.sol\r\n\r\n/**\r\n * @title IRule\r\n * @dev IRule interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ninterface IRule {\r\n  function isAddressValid(address _address) external view returns (bool);\r\n  function isTransferValid(address _from, address _to, uint256 _amount)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IWithRules.sol\r\n\r\n/**\r\n * @title IWithRules\r\n * @dev IWithRules interface\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n **/\r\ncontract IWithRules {\r\n  function ruleLength() public view returns (uint256);\r\n  function rule(uint256 _ruleId) public view returns (IRule);\r\n  function validateAddress(address _address) public view returns (bool);\r\n  function validateTransfer(address _from, address _to, uint256 _amount)\r\n    public view returns (bool);\r\n\r\n  function defineRules(IRule[] _rules) public;\r\n\r\n  event RulesDefined(uint256 count);\r\n}\r\n\r\n// File: contracts/rule/WithRules.sol\r\n\r\n/**\r\n * @title WithRules\r\n * @dev WithRules contract allows inheriting contract to use a set of validation rules\r\n * @dev contract owner may add or remove rules\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * WR01: The rules rejected this address\r\n * WR02: The rules rejected the transfer\r\n **/\r\ncontract WithRules is IWithRules, Ownable {\r\n\r\n  IRule[] internal rules;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IRule[] _rules) public {\r\n    rules = _rules;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of rules\r\n   */\r\n  function ruleLength() public view returns (uint256) {\r\n    return rules.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the Rule associated to the specified ruleId\r\n   */\r\n  function rule(uint256 _ruleId) public view returns (IRule) {\r\n    return rules[_ruleId];\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid for an address\r\n   */\r\n  function validateAddress(address _address) public view returns (bool) {\r\n    for (uint256 i = 0; i < rules.length; i++) {\r\n      if (!rules[i].isAddressValid(_address)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid\r\n   */\r\n  function validateTransfer(address _from, address _to, uint256 _amount)\r\n    public view returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < rules.length; i++) {\r\n      if (!rules[i].isTransferValid(_from, _to, _amount)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make functions callable\r\n   * only when participants follow rules\r\n   */\r\n  modifier whenAddressRulesAreValid(address _address) {\r\n    require(validateAddress(_address), \"WR01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make transfer functions callable\r\n   * only when participants follow rules\r\n   */\r\n  modifier whenTransferRulesAreValid(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount)\r\n  {\r\n    require(validateTransfer(_from, _to, _amount), \"WR02\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Define rules to the token\r\n   */\r\n  function defineRules(IRule[] _rules) public onlyOwner {\r\n    rules = _rules;\r\n    emit RulesDefined(rules.length);\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/TokenWithRules.sol\r\n\r\n/**\r\n * @title TokenWithRules\r\n * @dev TokenWithRules contract\r\n * TokenWithRules is a token that will apply\r\n * rules restricting transferability\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n **/\r\ncontract TokenWithRules is StandardToken, WithRules {\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  constructor(IRule[] _rules) public WithRules(_rules) { }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _to, uint256 _value)\r\n    public whenTransferRulesAreValid(msg.sender, _to, _value)\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public whenTransferRulesAreValid(_from, _to, _value)\r\n    whenAddressRulesAreValid(msg.sender)\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\n// File: contracts/token/BridgeToken.sol\r\n\r\n/**\r\n * @title BridgeToken\r\n * @dev BridgeToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {\r\n  string public name;\r\n  string public symbol;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string _name, string _symbol) \r\n    TokenWithRules(new IRule[](0))\r\n    TokenWithClaims(new IClaimable[](0)) public\r\n  {\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n}\r\n\r\n// File: contracts/token/component/MintableToken.sol\r\n\r\n/**\r\n * @title MintableToken\r\n * @dev MintableToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * MT01: Minting is already finished.\r\n*/\r\ncontract MintableToken is StandardToken, Ownable, IMintable {\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  function mintingFinished() public view returns (bool) {\r\n    return mintingFinished;\r\n  }\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished, \"MT01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  ) public canMint onlyOwner returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public canMint onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n}\r\n\r\n// File: contracts/token/MintableBridgeToken.sol\r\n\r\n/**\r\n * @title MintableBridgeToken\r\n * @dev MintableBridgeToken contract\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract MintableBridgeToken is BridgeToken, MintableToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string _name, string _symbol)\r\n    BridgeToken(_name, _symbol) public\r\n  {\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n}\r\n\r\n// File: contracts/interface/ISaleConfig.sol\r\n\r\n/**\r\n * @title ISaleConfig interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n */\r\ncontract ISaleConfig {\r\n\r\n  struct Tokensale {\r\n    uint256 lotId;\r\n    uint256 tokenPriceCHFCent;\r\n  }\r\n\r\n  function tokenSupply() public pure returns (uint256);\r\n  function tokensaleLotSupplies() public view returns (uint256[]);\r\n\r\n  function tokenizedSharePercent() public pure returns (uint256); \r\n  function tokenPriceCHF() public pure returns (uint256);\r\n\r\n  function minimalCHFInvestment() public pure returns (uint256);\r\n  function maximalCHFInvestment() public pure returns (uint256);\r\n\r\n  function tokensalesCount() public view returns (uint256);\r\n  function lotId(uint256 _tokensaleId) public view returns (uint256);\r\n  function tokenPriceCHFCent(uint256 _tokensaleId)\r\n    public view returns (uint256);\r\n}\r\n\r\n// File: contracts/tokensale/TokenMinter.sol\r\n\r\n/**\r\n * @title TokenMinter\r\n * @dev TokenMinter contract\r\n * The contract explicit the minting process of the Bridge Token\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\r\n *\r\n * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\r\n * @notice Please refer to the top of this file for the license.\r\n *\r\n * Error messages\r\n * TM01: Configuration must be defined\r\n * TM02: Final token owner must be defined\r\n * TM03: There should be at least one lot\r\n * TM04: Must have one vault per lot\r\n * TM05: Each vault must be defined\r\n * TM06: Token must be defined\r\n * TM07: Token has already been defined\r\n * TM08: Minter must be the token owner\r\n * TM09: There should be no token supply\r\n * TM10: Token minting must not be finished\r\n * TM11: Minters must match tokensale configuration\r\n * TM12: Tokensale configuration must match lot definition\r\n * TM13: Minter is not already configured for the lot\r\n * TM14: Token must be defined\r\n * TM15: Amount to mint must be greater than 0\r\n * TM16: Mintable supply must be greater than amount to mint\r\n * TM17: Can only finish minting for active minters\r\n * TM18: No active minters expected for the lot\r\n * TM19: There should be some remaining supply in the lot\r\n * TM20: Minting must be successfull\r\n * TM21: Token minting must not be finished\r\n * TM22: There should be some unfinished lot(s)\r\n * TM23: All minting must be processed\r\n * TM24: Token minting must not be finished\r\n * TM25: Finish minting must be successful\r\n * TM26: Token minting must be finished\r\n*/\r\ncontract TokenMinter is IMintableByLot, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  struct MintableLot {\r\n    uint256 mintableSupply;\r\n    address vault;\r\n    mapping(address => bool) minters;\r\n    uint8 activeMinters;\r\n  }\r\n\r\n  MintableLot[] private mintableLots;\r\n  mapping(address => uint256) public minterLotIds;\r\n\r\n  uint256 public totalMintableSupply;\r\n  address public finalTokenOwner;\r\n\r\n  uint8 public activeLots;\r\n\r\n  ISaleConfig public config;\r\n  MintableBridgeToken public token;\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(\r\n    ISaleConfig _config,\r\n    address _finalTokenOwner,\r\n    address[] _vaults) public\r\n  {\r\n    require(address(_config) != 0, \"TM01\");\r\n    require(_finalTokenOwner != 0, \"TM02\");\r\n\r\n    uint256[] memory lots = _config.tokensaleLotSupplies();\r\n    require(lots.length > 0, \"TM03\");\r\n    require(_vaults.length == lots.length, \"TM04\");\r\n\r\n    config = _config;\r\n    finalTokenOwner = _finalTokenOwner;\r\n\r\n    for (uint256 i = 0; i < lots.length; i++) {\r\n      require(_vaults[i] != 0, \"TM05\");\r\n      uint256 mintableSupply = lots[i];\r\n      mintableLots.push(MintableLot(mintableSupply, _vaults[i], 0));\r\n      totalMintableSupply = totalMintableSupply.add(mintableSupply);\r\n      activeLots++;\r\n      emit LotCreated(i+1, mintableSupply);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev minter lotId\r\n   */\r\n  function minterLotId(address _minter) public view returns (uint256) {\r\n    return minterLotIds[_minter];\r\n  }\r\n\r\n  /**\r\n   * @dev lot mintable supply\r\n   */\r\n  function lotMintableSupply(uint256 _lotId) public view returns (uint256) {\r\n    return mintableLots[_lotId].mintableSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev lot vault\r\n   */\r\n  function lotVault(uint256 _lotId) public view returns (address) {\r\n    return mintableLots[_lotId].vault;\r\n  }\r\n\r\n  /**\r\n   * @dev is lot minter\r\n   */\r\n  function isLotMinter(uint256 _lotId, address _minter)\r\n    public view returns (bool)\r\n  {\r\n    return mintableLots[_lotId].minters[_minter];\r\n  }\r\n\r\n  /**\r\n   * @dev lot active minters\r\n   */\r\n  function lotActiveMinters(uint256 _lotId) public view returns (uint256) {\r\n    return mintableLots[_lotId].activeMinters;\r\n  }\r\n\r\n  /**\r\n   * @dev implement IMintable interface\r\n   */\r\n  function mintingFinished() public view returns (bool) {\r\n    return token.mintingFinished();\r\n  }\r\n\r\n  /**\r\n   * @dev setup token and minters\r\n   **/\r\n  function setup(MintableBridgeToken _token, address[] _minters)\r\n    public onlyOwner\r\n  {\r\n    require(address(_token) != 0, \"TM06\");\r\n    require(address(token) == 0, \"TM07\");\r\n    // Ensure it has full ownership over the token to ensure\r\n    // that only this contract will be allowed to mint\r\n    require(_token.owner() == address(this), \"TM08\");\r\n    token = _token;\r\n    \r\n    // Ensure that the token has not been premint\r\n    require(token.totalSupply() == 0, \"TM09\");\r\n    require(!token.mintingFinished(), \"TM10\");\r\n    \r\n    require(_minters.length == config.tokensalesCount(), \"TM11\");\r\n    for (uint256 i = 0; i < _minters.length; i++) {\r\n      if (_minters[i] != address(0)) {\r\n        setupMinter(_minters[i], i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev setup minter\r\n   */\r\n  function setupMinter(address _minter, uint256 _tokensaleId)\r\n    public onlyOwner\r\n  {\r\n    uint256 lotId = config.lotId(_tokensaleId);\r\n    require(lotId < mintableLots.length, \"TM12\");\r\n    MintableLot storage lot = mintableLots[lotId];\r\n    require(!lot.minters[_minter], \"TM13\");\r\n    lot.minters[_minter] = true;\r\n    lot.activeMinters++;\r\n    minterLotIds[_minter] = lotId;\r\n    emit MinterAdded(lotId, _minter);\r\n  }\r\n\r\n  /**\r\n   * @dev mint the token from the corresponding lot\r\n   */\r\n  function mint(address _to, uint256 _amount)\r\n    public returns (bool)\r\n  {\r\n    require(address(token) != 0, \"TM14\");\r\n    require(_amount > 0, \"TM15\");\r\n    \r\n    uint256 lotId = minterLotIds[msg.sender];\r\n    MintableLot storage lot = mintableLots[lotId];\r\n\r\n    require(lot.mintableSupply >= _amount, \"TM16\");\r\n\r\n    lot.mintableSupply = lot.mintableSupply.sub(_amount);\r\n    totalMintableSupply = totalMintableSupply.sub(_amount);\r\n    return token.mint(_to, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev update this contract minting to finish\r\n   */\r\n  function finishMinting() public returns (bool) {\r\n    return finishMintingInternal(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev update this contract minting to finish\r\n   */\r\n  function finishMintingRestricted(address _minter)\r\n    public onlyOwner returns (bool)\r\n  {\r\n    return finishMintingInternal(_minter);\r\n  }\r\n\r\n  /**\r\n   * @dev update this contract minting to finish\r\n   */\r\n  function finishMintingInternal(address _minter)\r\n    public returns (bool)\r\n  {\r\n    uint256 lotId = minterLotIds[_minter];\r\n    MintableLot storage lot = mintableLots[lotId];\r\n    require(lot.minters[_minter], \"TM17\");\r\n\r\n    lot.minters[_minter] = false;\r\n    lot.activeMinters--;\r\n\r\n    if (lot.activeMinters == 0 && lot.mintableSupply == 0) {\r\n      finishLotMintingPrivate(lotId);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev mint remaining non distributed tokens for a lot\r\n   */\r\n  function mintRemainingLot(uint256 _lotId)\r\n    public returns (bool)\r\n  {\r\n    MintableLot storage lot = mintableLots[_lotId];\r\n    require(lot.activeMinters == 0, \"TM18\");\r\n    require(lot.mintableSupply > 0, \"TM19\");\r\n\r\n    require(token.mint(lot.vault, lot.mintableSupply), \"TM20\");\r\n    totalMintableSupply = totalMintableSupply.sub(lot.mintableSupply);\r\n    lot.mintableSupply = 0;\r\n \r\n    finishLotMintingPrivate(_lotId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev mint remaining non distributed tokens\r\n   * If some tokens remain unminted (unsold or rounding approximations)\r\n   * they must be minted before the minting can be finished\r\n   **/\r\n  function mintAllRemaining() public onlyOwner returns (bool) {\r\n    require(!token.mintingFinished(), \"TM21\");\r\n    require(activeLots > 0, \"TM22\");\r\n   \r\n    if (totalMintableSupply > 0) {\r\n      for (uint256 i = 0; i < mintableLots.length; i++) {\r\n        MintableLot storage lot = mintableLots[i];\r\n        if (lot.mintableSupply > 0) {\r\n          mintRemainingLot(i);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev finish token minting\r\n   */\r\n  function finishTokenMinting() public onlyOwner returns (bool) {\r\n    require(totalMintableSupply == 0, \"TM23\");\r\n    require(!token.mintingFinished(), \"TM24\");\r\n    require(token.finishMinting(), \"TM25\");\r\n    \r\n    require(token.mintingFinished(), \"TM26\");\r\n    token.transferOwnership(finalTokenOwner);\r\n    emit TokenReleased();\r\n  }\r\n\r\n  /**\r\n   * @dev finish lot minting\r\n   */\r\n  function finishLotMintingPrivate(uint256 _lotId) private {\r\n    activeLots--;\r\n    emit LotMinted(_lotId);\r\n  }\r\n\r\n  event LotCreated(uint256 lotId, uint256 tokenSupply);\r\n  event MinterAdded(uint256 lotId, address minter);\r\n  event LotMinted(uint256 lotId);\r\n  event TokenReleased();\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"finishMintingInternal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeLots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"},{\"name\":\"_tokensaleId\",\"type\":\"uint256\"}],\"name\":\"setupMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintAllRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"uint256\"}],\"name\":\"lotActiveMinters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMintableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"uint256\"}],\"name\":\"lotMintableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"uint256\"}],\"name\":\"lotVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"finishMintingRestricted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishTokenMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"uint256\"}],\"name\":\"mintRemainingLot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"minterLotId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_minters\",\"type\":\"address[]\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"uint256\"},{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"isLotMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minterLotIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_config\",\"type\":\"address\"},{\"name\":\"_finalTokenOwner\",\"type\":\"address\"},{\"name\":\"_vaults\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lotId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenSupply\",\"type\":\"uint256\"}],\"name\":\"LotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lotId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lotId\",\"type\":\"uint256\"}],\"name\":\"LotMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"}]","ContractName":"TokenMinter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096c68443bbe2e3f93ada8d146605fe1acc74844500000000000000000000000090813652358f99ca5ceeda3de8b3afe4ce8279b7000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000020000000000000000000000001e85c1d410d62b0b5765f0086b732d4948acf00800000000000000000000000009519a92007e055c8a727df194cd951da654b616","Library":"","SwarmSource":"bzzr://4e21cb6e184fc4b13111c50217c1877352b73505e0d02d210aa1435a88004151"}]}