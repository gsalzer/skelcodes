{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ninterface token { \r\n  function transfer(address, uint) external returns (bool);\r\n  function transferFrom(address, address, uint) external returns (bool); \r\n  function allowance(address, address) external constant returns (uint256);\r\n  function balanceOf(address) external constant returns (uint256);\r\n}\r\n\r\n/** LOGIC DESCRIPTION\r\n * 11% fees in and out for ETH\r\n * 11% fees in and out for NOVA\r\n *\r\n * ETH fees split: \r\n * 6% to nova holders\r\n * 4% to eth holders\r\n * 1% to fixed address\r\n * \r\n * NOVA fees split: \r\n * 6% to nova holders\r\n * 4% to eth holders\r\n * 1% airdrop to a random address based on their nova shares\r\n * rules: \r\n * - you need to have both nova and eth to get dividends\r\n */\r\n\r\ncontract NovaBox is Ownable {\r\n  \r\n  using SafeMath for uint;\r\n  token tokenReward;\r\n\r\n  \r\n  constructor() public {\r\n    tokenReward = token(0x72FBc0fc1446f5AcCC1B083F0852a7ef70a8ec9f);\r\n  }\r\n\r\n  event AirDrop(address to, uint amount, uint randomTicket);\r\n\r\n  // ether contributions\r\n  mapping (address => uint) public contributionsEth;\r\n  // token contributions\r\n  mapping (address => uint) public contributionsToken;\r\n\r\n  // investors list who have deposited BOTH ether and token\r\n  mapping (address => uint) public indexes;\r\n  mapping (uint => address) public addresses;\r\n  uint256 public lastIndex = 0;\r\n\r\n  function addToList(address sender) private {\r\n    // if the sender is not in the list\r\n    if (indexes[sender] == 0) {\r\n      // add the sender to the list\r\n      lastIndex++;\r\n      addresses[lastIndex] = sender;\r\n      indexes[sender] = lastIndex;\r\n    }\r\n  }\r\n  function removeFromList(address sender) private {\r\n    // if the sender is in temp eth list \r\n    if (indexes[sender] > 0) {\r\n      // remove the sender from temp eth list\r\n      addresses[indexes[sender]] = addresses[lastIndex];\r\n      indexes[addresses[lastIndex]] = indexes[sender];\r\n      indexes[sender] = 0;\r\n      delete addresses[lastIndex];\r\n      lastIndex--;\r\n    }\r\n  }\r\n\r\n  // desposit ether\r\n  function () payable public {\r\n    \r\n    uint weiAmount = msg.value;\r\n    address sender = msg.sender;\r\n\r\n    // number of ether sent must be greater than 0\r\n    require(weiAmount > 0);\r\n\r\n    uint _89percent = weiAmount.mul(89).div(100);\r\n    uint _6percent = weiAmount.mul(6).div(100);\r\n    uint _4percent = weiAmount.mul(4).div(100);\r\n    uint _1percent = weiAmount.mul(1).div(100);\r\n\r\n\r\n    \r\n\r\n\r\n    distributeEth(\r\n      _6percent, // to nova investors\r\n      _4percent  // to eth investors\r\n    ); \r\n    //1% goes to REX Investors\r\n    owner.transfer(_1percent);\r\n\r\n    contributionsEth[sender] = contributionsEth[sender].add(_89percent);\r\n\r\n    // if the sender has also deposited tokens, add sender to list\r\n    if (contributionsToken[sender]>0) addToList(sender);\r\n  }\r\n\r\n  // withdraw ether\r\n  function withdrawEth(uint amount) public {\r\n    address sender = msg.sender;\r\n    require(amount>0 && contributionsEth[sender] >= amount);\r\n\r\n    uint _89percent = amount.mul(89).div(100);\r\n    uint _6percent = amount.mul(6).div(100);\r\n    uint _4percent = amount.mul(4).div(100);\r\n    uint _1percent = amount.mul(1).div(100);\r\n\r\n    contributionsEth[sender] = contributionsEth[sender].sub(amount);\r\n\r\n    // if the sender has withdrawn all their eth\r\n      // remove the sender from list\r\n    if (contributionsEth[sender] == 0) removeFromList(sender);\r\n\r\n    sender.transfer(_89percent);\r\n    distributeEth(\r\n      _6percent, // to nova investors\r\n      _4percent  // to eth investors\r\n    );\r\n    owner.transfer(_1percent);\r\n  }\r\n\r\n  // deposit tokens\r\n  function depositTokens(address randomAddr, uint randomTicket) public {\r\n   \r\n\r\n    address sender = msg.sender;\r\n    uint amount = tokenReward.allowance(sender, address(this));\r\n    \r\n    // number of allowed tokens must be greater than 0\r\n    // if it is then transfer the allowed tokens from sender to the contract\r\n    // if not transferred then throw\r\n    require(amount>0 && tokenReward.transferFrom(sender, address(this), amount));\r\n\r\n\r\n    uint _89percent = amount.mul(89).div(100);\r\n    uint _6percent = amount.mul(6).div(100);\r\n    uint _4percent = amount.mul(4).div(100);\r\n    uint _1percent = amount.mul(1).div(100);\r\n    \r\n    \r\n\r\n    distributeTokens(\r\n      _6percent, // to nova investors\r\n      _4percent  // to eth investors\r\n      );\r\n    tokenReward.transfer(randomAddr, _1percent);\r\n    // 1% for Airdrop\r\n    emit AirDrop(randomAddr, _1percent, randomTicket);\r\n\r\n    contributionsToken[sender] = contributionsToken[sender].add(_89percent);\r\n    // if the sender has also contributed ether add sender to list\r\n    if (contributionsEth[sender]>0) addToList(sender);\r\n  }\r\n\r\n  // withdraw tokens\r\n  function withdrawTokens(uint amount, address randomAddr, uint randomTicket) public {\r\n    address sender = msg.sender;\r\n    // requested amount must be greater than 0 and \r\n    // the sender must have contributed tokens no less than `amount`\r\n    require(amount>0 && contributionsToken[sender]>=amount);\r\n\r\n    uint _89percent = amount.mul(89).div(100);\r\n    uint _6percent = amount.mul(6).div(100);\r\n    uint _4percent = amount.mul(4).div(100);\r\n    uint _1percent = amount.mul(1).div(100);\r\n\r\n    contributionsToken[sender] = contributionsToken[sender].sub(amount);\r\n\r\n    // if sender withdrawn all their tokens, remove them from list\r\n    if (contributionsToken[sender] == 0) removeFromList(sender);\r\n\r\n    tokenReward.transfer(sender, _89percent);\r\n    distributeTokens(\r\n      _6percent, // to nova investors\r\n      _4percent  // to eth investors\r\n    );\r\n    // airdropToRandom(_1percent);  \r\n    tokenReward.transfer(randomAddr, _1percent);\r\n    emit AirDrop(randomAddr, _1percent, randomTicket);\r\n  }\r\n\r\n  function distributeTokens(uint _6percent, uint _4percent) private {\r\n    uint totalTokens = getTotalTokens();\r\n    uint totalWei = getTotalWei();\r\n\r\n    // loop over investors (`holders`) list\r\n    for (uint i = 1; i <= lastIndex; i++) {\r\n\r\n      address holder = addresses[i];\r\n      // `holder` will get part of 6% fee based on their token shares\r\n      uint _rewardTokens = contributionsToken[holder].mul(_6percent).div(totalTokens);\r\n      // `holder` will get part of 4% fee based on their ether shares\r\n      uint _rewardWei = contributionsEth[holder].mul(_4percent).div(totalWei);\r\n      // Transfer tokens equal to the sum of the fee parts to `holder`\r\n      tokenReward.transfer(holder,_rewardTokens.add(_rewardWei));\r\n    }\r\n  }\r\n\r\n  function distributeEth(uint _6percent, uint _4percent) private {\r\n    uint totalTokens = getTotalTokens();\r\n    uint totalWei = getTotalWei();\r\n\r\n    // loop over investors (`holders`) list\r\n    for (uint i = 1; i <= lastIndex; i++) {\r\n      address holder = addresses[i];\r\n      // `holder` will get part of 6% fee based on their token shares\r\n      uint _rewardTokens = contributionsToken[holder].mul(_6percent).div(totalTokens);\r\n      // `holder` will get part of 4% fee based on their ether shares\r\n      uint _rewardWei = contributionsEth[holder].mul(_4percent).div(totalWei);\r\n      // Transfer ether equal to the sum of the fee parts to `holder`\r\n      holder.transfer(_rewardTokens.add(_rewardWei));\r\n    }\r\n  }\r\n\r\n\r\n  // get sum of tokens contributed by the ether investors\r\n  function getTotalTokens() public view returns (uint) {\r\n    uint result;\r\n    for (uint i = 1; i <= lastIndex; i++) {\r\n      result = result.add(contributionsToken[addresses[i]]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // get the sum of wei contributed by the token investors\r\n  function getTotalWei() public view returns (uint) {\r\n    uint result;\r\n    for (uint i = 1; i <= lastIndex; i++) {\r\n      result = result.add(contributionsEth[addresses[i]]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n\r\n  // get the list of investors\r\n  function getList() public view returns (address[], uint[]) {\r\n    address[] memory _addrs = new address[](lastIndex);\r\n    uint[] memory _contributions = new uint[](lastIndex);\r\n\r\n    for (uint i = 1; i <= lastIndex; i++) {\r\n      _addrs[i-1] = addresses[i];\r\n      _contributions[i-1] = contributionsToken[addresses[i]];\r\n    }\r\n    return (_addrs, _contributions);\r\n  }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTotalWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributionsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"randomAddr\",\"type\":\"address\"},{\"name\":\"randomTicket\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributionsEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"randomAddr\",\"type\":\"address\"},{\"name\":\"randomTicket\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"randomTicket\",\"type\":\"uint256\"}],\"name\":\"AirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NovaBox","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b45b160ff002892b3866a4d44ca0962358237a6147d3df743913bb3215e1cbe5"}]}