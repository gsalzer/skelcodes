{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract Project424_2 {\r\n  using SafeMath for uint256;\r\n\r\n  address constant MARKETING_ADDRESS = 0xcc1B012Dc66f51E6cE77122711A8F730eF5a97fa;\r\n  address constant TEAM_ADDRESS = 0x155a3c1Ab0Ac924cB3079804f3784d4d13cF3a45;\r\n  address constant REFUND_ADDRESS = 0x732445bfB4F9541ba4A295d31Fb830B2ffdA80F8;\r\n\r\n  uint256 constant ONE_HUNDREDS_PERCENTS = 10000;      // 100%\r\n  uint256 constant INCOME_MAX_PERCENT = 5000;          // 50%\r\n  uint256 constant MARKETING_FEE = 1000;               // 10%\r\n  uint256 constant WITHDRAWAL_PERCENT = 1500;          // 15%\r\n  uint256 constant TEAM_FEE = 300;                     // 3%\r\n  uint256 constant REFUND_FEE = 200;                   // 2%\r\n  uint256 constant INCOME_PERCENT = 150;               // 1.5%\r\n  uint256 constant BALANCE_WITHDRAWAL_PERCENT = 10;    // 0.1%\r\n  uint256 constant BALANCE_INCOME_PERCENT = 1;         // 0.01%\r\n\r\n  uint256 constant DAY = 86400;                        // 1 day\r\n\r\n  uint256 constant SPECIAL_NUMBER = 4240 szabo;        // 0.00424 eth\r\n  \r\n  event AddInvestor(address indexed investor, uint256 amount);\r\n\r\n  struct User {\r\n    uint256 firstTime;\r\n    uint256 deposit;\r\n  }\r\n  mapping(address => User) public users;\r\n\r\n  function () payable external {\r\n    User storage user = users[msg.sender];\r\n\r\n    // deposits\r\n    if ( msg.value != 0 && user.firstTime == 0 ) {\r\n      user.firstTime = now;\r\n      user.deposit = msg.value;\r\n      AddInvestor(msg.sender, msg.value);\r\n      \r\n      MARKETING_ADDRESS.send(msg.value.mul(MARKETING_FEE).div(ONE_HUNDREDS_PERCENTS));\r\n      TEAM_ADDRESS.send(msg.value.mul(TEAM_FEE).div(ONE_HUNDREDS_PERCENTS));\r\n      REFUND_ADDRESS.send(msg.value.mul(REFUND_FEE).div(ONE_HUNDREDS_PERCENTS));\r\n\r\n    } else if ( msg.value == SPECIAL_NUMBER && user.firstTime != 0 ) { // withdrawal\r\n      uint256 withdrawalSum = userWithdrawalSum(msg.sender).add(SPECIAL_NUMBER);\r\n\r\n      // check all funds\r\n      if (withdrawalSum >= address(this).balance) {\r\n        withdrawalSum = address(this).balance;\r\n      }\r\n\r\n      // deleting\r\n      user.firstTime = 0;\r\n      user.deposit = 0;\r\n\r\n      msg.sender.send(withdrawalSum);\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function userWithdrawalSum(address wallet) public view returns(uint256) {\r\n    User storage user = users[wallet];\r\n    uint256 daysDuration = getDays(wallet);\r\n    uint256 withdrawal = user.deposit;\r\n\r\n\r\n    (uint256 getBalanceWithdrawalPercent, uint256 getBalanceIncomePercent) = getBalancePercents();\r\n    uint currentDeposit = user.deposit;\r\n    \r\n    if (daysDuration == 0) {\r\n      return withdrawal.sub(withdrawal.mul(WITHDRAWAL_PERCENT.add(getBalanceWithdrawalPercent)).div(ONE_HUNDREDS_PERCENTS));\r\n    }\r\n\r\n    for (uint256 i = 0; i < daysDuration; i++) {\r\n      currentDeposit = currentDeposit.add(currentDeposit.mul(INCOME_PERCENT.add(getBalanceIncomePercent)).div(ONE_HUNDREDS_PERCENTS));\r\n\r\n      if (currentDeposit >= user.deposit.add(user.deposit.mul(INCOME_MAX_PERCENT).div(ONE_HUNDREDS_PERCENTS))) {\r\n        withdrawal = user.deposit.add(user.deposit.mul(INCOME_MAX_PERCENT).div(ONE_HUNDREDS_PERCENTS));\r\n\r\n        break;\r\n      } else {\r\n        withdrawal = currentDeposit.sub(currentDeposit.mul(WITHDRAWAL_PERCENT.add(getBalanceWithdrawalPercent)).div(ONE_HUNDREDS_PERCENTS));\r\n      }\r\n    }\r\n    \r\n    return withdrawal;\r\n  }\r\n  \r\n  function getDays(address wallet) public view returns(uint256) {\r\n    User storage user = users[wallet];\r\n    if (user.firstTime == 0) {\r\n        return 0;\r\n    } else {\r\n        return (now.sub(user.firstTime)).div(DAY);\r\n    }\r\n  }\r\n\r\n  function getBalancePercents() public view returns(uint256 withdrawalRate, uint256 incomeRate) {\r\n    if (address(this).balance >= 100 ether) {\r\n      if (address(this).balance >= 5000 ether) {\r\n        withdrawalRate = 500;\r\n        incomeRate = 50;\r\n      } else {\r\n        uint256 steps = (address(this).balance).div(100 ether);\r\n        uint256 withdrawalUtility = 0;\r\n        uint256 incomeUtility = 0;\r\n\r\n        for (uint i = 0; i < steps; i++) {\r\n          withdrawalUtility = withdrawalUtility.add(BALANCE_WITHDRAWAL_PERCENT);\r\n          incomeUtility = incomeUtility.add(BALANCE_INCOME_PERCENT);\r\n        }\r\n        \r\n        withdrawalRate = withdrawalUtility;\r\n        incomeRate = incomeUtility;\r\n      }\r\n    } else {\r\n      withdrawalRate = 0;\r\n      incomeRate = 0;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"userWithdrawalSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"firstTime\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalancePercents\",\"outputs\":[{\"name\":\"withdrawalRate\",\"type\":\"uint256\"},{\"name\":\"incomeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddInvestor\",\"type\":\"event\"}]","ContractName":"Project424_2","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f85b0ffd0d8f0f750a90c613c7a941d787f1352102ea35e77c1c0fa045a1bcf2"}]}