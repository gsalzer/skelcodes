{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ninterface HourglassInterface {\r\n    function() payable external;\r\n    function buy(address _investorAddress) payable external returns(uint256);\r\n    function reinvest() external;\r\n    function exit() payable external;\r\n    function withdraw() payable external;\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function totalEthereumBalance() external;\r\n    function totalSupply() external;\r\n    function myTokens() external returns(uint256);\r\n    function myDividends(bool _includeReferralBonus) external returns (uint256);\r\n    function balanceOf(address _investorAddress) external returns (uint256);\r\n    function dividendsOf(address _investorAddress) external returns (uint256);\r\n    function sellPrice() payable external returns (uint256);\r\n    function buyPrice() external;\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) external;\r\n    function calculateEthereumReceived(uint256 _tokensToSell) external returns(uint256);\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) external;\r\n}\r\n\r\ncontract MinerTokenDaily {\r\n    using SafeMath\r\n    for uint;\r\n    \r\n      /* Marketing private wallet*/\r\n    address constant _parojectMarketing = 0x3d3B4a38caD44c2B77DAAC1D746124D2e2b8a27C;\r\n    address constant _cmtfContractAddress = 0x0a97094c19295E320D5121d72139A150021a2702;\r\n    /* Interface to main CMT contract */    \r\n    HourglassInterface constant CMTContract = HourglassInterface(_cmtfContractAddress);\r\n    \r\n    /* % Fee that will be deducted from initial transfer and sent to CMT contract */\r\n    uint constant _masterTaxOnInvestment = 8;\r\n    \r\n    uint constant basePercent = 36;\r\n    uint constant lowPercent = 40;\r\n    uint constant averagePercent = 45;\r\n    uint constant highPercent = 50;\r\n    /* Balance switches for % */\r\n    uint constant phasePreperation = 1000 ether;\r\n    uint constant phaseEngineStart = 2000 ether;\r\n    uint constant phaseLiftoff = 5000 ether;\r\n    uint constant depositLimit = 50.01 ether;\r\n    uint constant payOutInterval = 1 minutes;\r\n    uint _bonuss = 0;\r\n    \r\n    mapping (address => uint256) public invested;\r\n    mapping (address => uint256) public withdraws;\r\n    mapping (address => uint256) public atBlock;\r\n    mapping (address => uint256) public refearned;\r\n\r\n    function () external payable {\r\n        require(msg.value < depositLimit);\r\n        address referrer = bytesToAddress(msg.data);\r\n        \r\n        if (referrer > 0x0 && referrer != msg.sender) {\r\n            if(balanceOf(referrer) > 0.1 ether){\r\n            _bonuss = msg.value.mul(10).div(100);\r\n\t\t\trewardReferral(referrer);\r\n\t\t\trefearned[referrer] += _bonuss;\r\n            }\r\n\t\t}\r\n\t\t\r\n        if (msg.value == 0) {\r\n            withdraw();\r\n            atBlock[msg.sender] = now;\r\n        } else {\r\n            startDivDistribution();\r\n            atBlock[msg.sender] = now;\r\n            invested[msg.sender]+=msg.value;\r\n        }\r\n    }\r\n    \r\n    function withdraw() internal {\r\n        uint payout = availablePayOut();\r\n        withdraws[msg.sender] += payout;\r\n        msg.sender.transfer(payout);\r\n    }\r\n    \r\n    function rewardReferral(address referrer) internal {\r\n        referrer.transfer(_bonuss);\r\n    }\r\n    \r\n    function availablePayOut() public view returns(uint){\r\n            uint percentRate = resolvePercentRate();\r\n            uint balanceTimer = now.sub(atBlock[msg.sender]).div(payOutInterval);\r\n            if(balanceTimer > 1440){\r\n               return invested[msg.sender].mul(percentRate).div(1000);\r\n            }\r\n            else{\r\n               return invested[msg.sender].mul(percentRate).div(1000).div(1440).mul(balanceTimer);\r\n            }\r\n    }\r\n    \r\n    function outStandingPayoutFor(address wallet) public view returns(uint){\r\n            uint percentRate = resolvePercentRate();\r\n            uint balanceTimer = now.sub(atBlock[wallet]).div(payOutInterval);\r\n            if(balanceTimer > 1440){\r\n               return invested[wallet].mul(percentRate).div(1000);\r\n            }\r\n            else{\r\n               return invested[wallet].mul(percentRate).div(1000).div(1440).mul(balanceTimer);\r\n            }\r\n    }\r\n    \r\n    function exit() payable public {\r\n        uint percentRate = resolvePercentRate();\r\n        uint payout = invested[msg.sender];\r\n\t\tif(now.sub(atBlock[msg.sender]).mul(percentRate).div(1000) < invested[msg.sender]/2){\r\n\t\t    atBlock[msg.sender] = 0;\r\n            invested[msg.sender] = 0;\r\n            uint payoutTotal = payout.div(2).sub(withdraws[msg.sender]);\r\n            withdraws[msg.sender] = 0;\r\n\t\t msg.sender.transfer(payoutTotal);\r\n\t\t}\r\n\t\telse{\r\n\t\t msg.sender.transfer(payout);\r\n\t\t}\r\n      \r\n    }\r\n    \r\n        /* Internal function to distribute masterx tax fee into dividends to all CMT holders */\r\n    function startDivDistribution() internal{\r\n            /*#######################################  !  IMPORTANT  !  ##############################################\r\n            ## Here we buy CMT tokens with 8% from deposit and we intentionally use marketing wallet as masternode  ##\r\n            ## that results into 33% from 8% goes to marketing & server running  purposes by our team but the rest  ##\r\n            ## of 8% is distributet to all holder with selling CMT tokens & then reinvesting again (LOGIC FROM CMT) ##\r\n            ## This kindof functionality allows us to decrease the % tax on deposit since 1% from deposit is much   ##\r\n            ## more than 33% from 8%.                                                                               ##\r\n            ########################################################################################################*/\r\n            CMTContract.buy.value(msg.value.mul(_masterTaxOnInvestment).div(100))(_parojectMarketing);\r\n            uint _cmtBalance = getFundCMTBalance();\r\n            CMTContract.sell(_cmtBalance);\r\n            CMTContract.reinvest();\r\n    }\r\n      \r\n    \r\n    function resolvePercentRate() public view returns(uint) {\r\n        uint balance = address(this).balance;\r\n        if (balance < phasePreperation) {\r\n            return (basePercent);\r\n        }\r\n        if (balance >= phasePreperation && balance < phaseEngineStart) {\r\n            return (lowPercent);\r\n        }\r\n        if (balance >= phaseEngineStart && balance < phaseLiftoff) {\r\n            return (averagePercent);\r\n        }\r\n        if (balance >= phaseLiftoff) {\r\n            return (highPercent);\r\n        }\r\n    }\r\n    \r\n        /* Returns contracts balance on CMT contract */\r\n    function getFundCMTBalance() internal returns (uint256){\r\n        return CMTContract.myTokens();\r\n    }\r\n    \r\n    function bytesToAddress(bytes bys) private pure returns (address addr) {\r\n\t\tassembly {\r\n\t\t\taddr := mload(add(bys, 20))\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction balanceOf(address _customerAddress) public view returns (uint256) {\r\n\t    return invested[_customerAddress];\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdraws\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refearned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"atBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availablePayOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolvePercentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"outStandingPayoutFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"MinerTokenDaily","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9acb2924f18f535d5482f09269f100d288cc5de0d98bb872a3aae472d993f397"}]}