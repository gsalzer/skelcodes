{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor () public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has an owner address[], and provides basic authorization control\r\n */\r\ncontract MultiOwnable is Ownable {\r\n\r\n  struct Types {\r\n    mapping (address => bool) access;\r\n  }\r\n  mapping (uint => Types) private multiOwnersTypes;\r\n\r\n  event AddOwner(uint _type, address addr);\r\n  event AddOwner(uint[] types, address addr);\r\n  event RemoveOwner(uint _type, address addr);\r\n\r\n  modifier onlyMultiOwnersType(uint _type) {\r\n    require(multiOwnersTypes[_type].access[msg.sender] || msg.sender == owner, \"403\");\r\n    _;\r\n  }\r\n\r\n  function onlyMultiOwnerType(uint _type, address _sender) public view returns(bool) {\r\n    if (multiOwnersTypes[_type].access[_sender] || _sender == owner) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function addMultiOwnerType(uint _type, address _owner) public onlyOwner returns(bool) {\r\n    require(_owner != address(0));\r\n    multiOwnersTypes[_type].access[_owner] = true;\r\n    emit AddOwner(_type, _owner);\r\n    return true;\r\n  }\r\n  \r\n  function addMultiOwnerTypes(uint[] types, address _owner) public onlyOwner returns(bool) {\r\n    require(_owner != address(0));\r\n    require(types.length > 0);\r\n    for (uint i = 0; i < types.length; i++) {\r\n      multiOwnersTypes[types[i]].access[_owner] = true;\r\n    }\r\n    emit AddOwner(types, _owner);\r\n    return true;\r\n  }\r\n\r\n  function removeMultiOwnerType(uint types, address _owner) public onlyOwner returns(bool) {\r\n    require(_owner != address(0));\r\n    multiOwnersTypes[types].access[_owner] = false;\r\n    emit RemoveOwner(types, _owner);\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract IBonus {\r\n  function getCurrentDayBonus(uint startSaleDate, bool saleState) public view returns(uint);\r\n  function _currentDay(uint startSaleDate, bool saleState) public view returns(uint);\r\n  function getBonusData() public view returns(string);\r\n  function getPreSaleBonusPercent() public view returns(uint);\r\n  function getMinReachUsdPayInCents() public view returns(uint);\r\n}\r\n\r\ncontract ICurrency {\r\n  function getUsdAbsRaisedInCents() external view returns(uint);\r\n  function getCoinRaisedBonusInWei() external view returns(uint);\r\n  function getCoinRaisedInWei() public view returns(uint);\r\n  function getUsdFromETH(uint ethWei) public view returns(uint);\r\n  function getTokenFromETH(uint ethWei) public view returns(uint);\r\n  function getCurrencyRate(string _ticker) public view returns(uint);\r\n  function addPay(string _ticker, uint value, uint usdAmount, uint coinRaised, uint coinRaisedBonus) public returns(bool);\r\n  function checkTickerExists(string ticker) public view returns(bool);\r\n  function getUsdFromCurrency(string ticker, uint value) public view returns(uint);\r\n  function getUsdFromCurrency(string ticker, uint value, uint usd) public view returns(uint);\r\n  function getUsdFromCurrency(bytes32 ticker, uint value) public view returns(uint);\r\n  function getUsdFromCurrency(bytes32 ticker, uint value, uint usd) public view returns(uint);\r\n  function getTokenWeiFromUSD(uint usdCents) public view returns(uint);\r\n  function editPay(bytes32 ticker, uint currencyValue, uint currencyUsdRaised, uint _usdAbsRaisedInCents, uint _coinRaisedInWei, uint _coinRaisedBonusInWei) public returns(bool);\r\n  function getCurrencyList(string ticker) public view returns(bool active, uint usd, uint devision, uint raised, uint usdRaised, uint usdRaisedExchangeRate, uint counter, uint lastUpdate);\r\n  function getCurrencyList(bytes32 ticker) public view returns(bool active, uint usd, uint devision, uint raised, uint usdRaised, uint usdRaisedExchangeRate, uint counter, uint lastUpdate);\r\n  function getTotalUsdRaisedInCents() public view returns(uint);\r\n  function getAllCurrencyTicker() public view returns(string);\r\n  function getCoinUSDRate() public view  returns(uint);\r\n  function addPreSaleBonus(uint bonusToken) public returns(bool);\r\n  function editPreSaleBonus(uint beforeBonus, uint afterBonus) public returns(bool);\r\n}\r\n\r\ncontract IStorage {\r\n  function processPreSaleBonus(uint minTotalUsdAmountInCents, uint bonusPercent, uint _start, uint _limit) external returns(uint);\r\n  function checkNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents) external view returns(bool);\r\n  function getCountNeedProcessPreSaleBonus(uint minTotalUsdAmountInCents, uint start, uint limit) external view returns(uint);\r\n  function reCountUserPreSaleBonus(uint uId, uint minTotalUsdAmountInCents, uint bonusPercent, uint maxPayTime) external returns(uint, uint);\r\n  function getContributorIndexes(uint index) external view returns(uint);\r\n  function checkNeedSendSHPC(bool proc) external view returns(bool);\r\n  function getCountNeedSendSHPC(uint start, uint limit) external view returns(uint);\r\n  function checkETHRefund(bool proc) external view returns(bool);\r\n  function getCountETHRefund(uint start, uint limit) external view returns(uint);\r\n  function addPayment(address _addr, string pType, uint _value, uint usdAmount, uint currencyUSD, uint tokenWithoutBonus, uint tokenBonus, uint bonusPercent, uint payId) public returns(bool);\r\n  function addPayment(uint uId, string pType, uint _value, uint usdAmount, uint currencyUSD, uint tokenWithoutBonus, uint tokenBonus, uint bonusPercent, uint payId) public returns(bool);\r\n  function checkUserIdExists(uint uId) public view returns(bool);\r\n  function getContributorAddressById(uint uId) public view returns(address);\r\n  function editPaymentByUserId(uint uId, uint payId, uint _payValue, uint _usdAmount, uint _currencyUSD, uint _totalToken, uint _tokenWithoutBonus, uint _tokenBonus, uint _bonusPercent) public returns(bool);\r\n  function getUserPaymentById(uint uId, uint payId) public view returns(uint time, bytes32 pType, uint currencyUSD, uint bonusPercent, uint payValue, uint totalToken, uint tokenBonus, uint tokenWithoutBonus, uint usdAbsRaisedInCents, bool refund);\r\n  function checkWalletExists(address addr) public view returns(bool result);\r\n  function checkReceivedCoins(address addr) public view returns(bool);\r\n  function getContributorId(address addr) public view returns(uint);\r\n  function getTotalCoin(address addr) public view returns(uint);\r\n  function setReceivedCoin(uint uId) public returns(bool);\r\n  function checkPreSaleReceivedBonus(address addr) public view returns(bool);\r\n  function checkRefund(address addr) public view returns(bool);\r\n  function setRefund(uint uId) public returns(bool);\r\n  function getEthPaymentContributor(address addr) public view returns(uint);\r\n  function refundPaymentByUserId(uint uId, uint payId) public returns(bool);\r\n  function changeSupportChangeMainWallet(bool support) public returns(bool);\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ShipCoin Crowdsale\r\n */\r\ncontract ShipCoinCrowdsale is MultiOwnable {\r\n  using SafeMath for uint256;\r\n\r\n  ERC20Basic public coinContract;\r\n  IStorage public storageContract;\r\n  ICurrency public currencyContract;\r\n  IBonus public bonusContract;\r\n\r\n  enum SaleState {NEW, PRESALE, CALCPSBONUS, SALE, END, REFUND}\r\n  uint256 private constant ONE_DAY = 86400;\r\n\r\n  SaleState public state;\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  // minimum goal USD\r\n  uint public softCapUSD = 500000000; // 5,000,000$ in cents\r\n  // maximum goal USD\r\n  uint public hardCapUSD = 6200000000; // 62,000,000$ in cents\r\n  // maximum available SHPC with a bonus\r\n  uint public maxDistributeCoin = 600000000 * 1 ether; //600,000,000 shpc (incl. bonus)\r\n  // minimal accept payment\r\n  uint public minimalContributionUSD = 100000; // 1000$ in cents\r\n\r\n  // start and end timestamps where investments are allowed in PreSale\r\n  uint public startPreSaleDate;\r\n  uint public endPreSaleDate;\r\n\r\n  uint public unfreezeRefundPreSale;\r\n  uint public unfreezeRefundAll;\r\n\r\n  // start and end timestamps where investments are allowed in sale\r\n  uint public startSaleDate;\r\n  uint public endSaleDate;\r\n\r\n  bool public softCapAchieved = false;\r\n\r\n  address public multiSig1;\r\n  address public multiSig2;\r\n\r\n  bool public multiSigReceivedSoftCap = false;\r\n\r\n\r\n  /* Events */\r\n  event ChangeState(uint blockNumber, SaleState state);\r\n  event ChangeMinContribUSD(uint oldAmount, uint newAmount);\r\n  event ChangeStorageContract(address oldAddress, address newAddress);\r\n  event ChangeCurrencyContract(address oldAddress, address newAddress);\r\n  event ChangeCoinContract(address oldAddress, address newAddress);\r\n  event ChangeBonusContract(address oldAddress, address newAddress);\r\n  event AddPay(address contributor);\r\n  event EditPay(address contributor);\r\n  event SoftCapAchieved(uint amount);\r\n  event ManualChangeStartPreSaleDate(uint oldDate, uint newDate);\r\n  event ManualChangeEndPreSaleDate(uint oldDate, uint newDate);\r\n  event ManualChangeStartSaleDate(uint oldDate, uint newDate);\r\n  event ManualEndSaleDate(uint oldDate, uint newDate);\r\n  event SendSHPCtoContributor(address contributor);\r\n  event SoftCapChanged();\r\n  event Refund(address contributor);\r\n  event RefundPay(address contributor);\r\n\r\n  struct PaymentInfo {\r\n    bytes32 pType;\r\n    uint currencyUSD;\r\n    uint bonusPercent;\r\n    uint payValue;\r\n    uint totalToken;\r\n    uint tokenBonus;\r\n    uint usdAbsRaisedInCents;\r\n    bool refund;\r\n  }\r\n\r\n  struct CurrencyInfo {\r\n    uint value;\r\n    uint usdRaised;\r\n    uint usdAbsRaisedInCents;\r\n    uint coinRaisedInWei;\r\n    uint coinRaisedBonusInWei;\r\n  }\r\n\r\n  struct EditPaymentInfo {\r\n    uint usdAmount;\r\n    uint currencyUSD;\r\n    uint bonusPercent;\r\n    uint totalToken;\r\n    uint tokenWithoutBonus;\r\n    uint tokenBonus;\r\n    CurrencyInfo currency;\r\n  }\r\n\r\n  function () external whenNotPaused payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Run after deploy. Initialize initial variables\r\n   * @param _coinAddress address coinContract\r\n   * @param _storageContract address storageContract\r\n   * @param _currencyContract address currencyContract\r\n   * @param _bonusContract address bonusContract\r\n   * @param _multiSig1 address multiSig where eth will be transferred\r\n   * @param _startPreSaleDate timestamp\r\n   * @param _endPreSaleDate timestamp\r\n   * @param _startSaleDate timestamp\r\n   * @param _endSaleDate timestamp\r\n   */\r\n  function init(\r\n    address _coinAddress,\r\n    address _storageContract,\r\n    address _currencyContract,\r\n    address _bonusContract,\r\n    address _multiSig1,\r\n    uint _startPreSaleDate,\r\n    uint _endPreSaleDate,\r\n    uint _startSaleDate,\r\n    uint _endSaleDate\r\n  )\r\n  public\r\n  onlyOwner\r\n  {\r\n    require(_coinAddress != address(0));\r\n    require(_storageContract != address(0));\r\n    require(_currencyContract != address(0));\r\n    require(_multiSig1 != address(0));\r\n    require(_bonusContract != address(0));\r\n    require(_startPreSaleDate > 0 && _startSaleDate > 0);\r\n    require(_startSaleDate > _endPreSaleDate);\r\n    require(_endSaleDate > _startSaleDate);\r\n    require(startSaleDate == 0);\r\n\r\n    coinContract = ERC20Basic(_coinAddress);\r\n    storageContract = IStorage(_storageContract);\r\n    currencyContract = ICurrency(_currencyContract);\r\n    bonusContract = IBonus(_bonusContract);\r\n\r\n    multiSig1 = _multiSig1;\r\n    multiSig2 = 0x231121dFCB61C929BCdc0D1E6fC760c84e9A02ad;\r\n\r\n    startPreSaleDate = _startPreSaleDate;\r\n    endPreSaleDate = _endPreSaleDate;\r\n    startSaleDate = _startSaleDate;\r\n    endSaleDate = _endSaleDate;\r\n\r\n    unfreezeRefundPreSale = _endSaleDate;\r\n    unfreezeRefundAll = _endSaleDate.add(ONE_DAY);\r\n\r\n    state = SaleState.NEW;\r\n  }\r\n\r\n  /**\r\n * @dev called by the owner to pause, triggers stopped state\r\n */\r\n  function pause() public onlyOwner {\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner {\r\n    paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the minimum amount in dollars indicated in cents to accept payment.\r\n   * @param minContribUsd in cents\r\n   */\r\n  function setMinimalContributionUSD(uint minContribUsd) public onlyOwner {\r\n    require(minContribUsd > 100); // > 1$\r\n    uint oldMinAmount = minimalContributionUSD;\r\n    minimalContributionUSD = minContribUsd;\r\n    emit ChangeMinContribUSD(oldMinAmount, minimalContributionUSD);\r\n  }\r\n\r\n  /**\r\n   * @dev Set the time when contributors can receive tokens\r\n   * @param _time timestamp\r\n   */\r\n  function setUnfreezeRefund(uint _time) public onlyOwner {\r\n    require(_time > startSaleDate);\r\n    unfreezeRefundPreSale = _time;\r\n    unfreezeRefundAll = _time.add(ONE_DAY);\r\n  }\r\n\r\n  /**\r\n   * @dev Change address ShipCoinStorage contracts.\r\n   * @param _storageContract address ShipCoinStorage contracts\r\n   */\r\n  function setStorageContract(address _storageContract) public onlyOwner {\r\n    require(_storageContract != address(0));\r\n    address oldStorageContract = storageContract;\r\n    storageContract = IStorage(_storageContract);\r\n    emit ChangeStorageContract(oldStorageContract, storageContract);\r\n  }\r\n\r\n  /**\r\n   * @dev Change address ShipCoin contracts.\r\n   * @param _coinContract address ShipCoin contracts\r\n   */\r\n  function setCoinContract(address _coinContract) public onlyOwner {\r\n    require(_coinContract != address(0));\r\n    address oldCoinContract = coinContract;\r\n    coinContract = ERC20Basic(_coinContract);\r\n    emit ChangeCoinContract(oldCoinContract, coinContract);\r\n  }\r\n\r\n  /**\r\n   * @dev Change address ShipCoinCurrency contracts.\r\n   * @param _currencyContract address ShipCoinCurrency contracts\r\n   */\r\n  function setCurrencyContract(address _currencyContract) public onlyOwner {\r\n    require(_currencyContract != address(0));\r\n    address oldCurContract = currencyContract;\r\n    currencyContract = ICurrency(_currencyContract);\r\n    emit ChangeCurrencyContract(oldCurContract, currencyContract);\r\n  }\r\n\r\n  /**\r\n   * @dev Change address ShipCoinBonusSystem contracts.\r\n   * @param _bonusContract address ShipCoinBonusSystem contracts\r\n   */\r\n  function setBonusContract(address _bonusContract) public onlyOwner {\r\n    require(_bonusContract != address(0));\r\n    address oldContract = _bonusContract;\r\n    bonusContract = IBonus(_bonusContract);\r\n    emit ChangeBonusContract(oldContract, bonusContract);\r\n  }\r\n\r\n  /**\r\n   * @dev Change address multiSig1.\r\n   * @param _address address multiSig1\r\n   */\r\n  function setMultisig(address _address) public onlyOwner {\r\n    require(_address != address(0));\r\n    multiSig1 = _address;\r\n  }\r\n\r\n  /**\r\n   * @dev Set softCapUSD\r\n   * @param _softCapUsdInCents uint softCapUSD > 100000\r\n   */\r\n  function setSoftCap(uint _softCapUsdInCents) public onlyOwner {\r\n    require(_softCapUsdInCents > 100000);\r\n    softCapUSD = _softCapUsdInCents;\r\n    emit SoftCapChanged();\r\n  }\r\n\r\n  /**\r\n   * @dev Change maximum number of tokens sold\r\n   * @param _maxCoin maxDistributeCoin\r\n   */\r\n  function changeMaxDistributeCoin(uint _maxCoin) public onlyOwner {\r\n    require(_maxCoin > 0 && _maxCoin >= currencyContract.getCoinRaisedInWei());\r\n    maxDistributeCoin = _maxCoin;\r\n  }\r\n\r\n  /**\r\n   * @dev Change status. Start presale.\r\n   */\r\n  function startPreSale() public onlyMultiOwnersType(1) {\r\n    require(block.timestamp <= endPreSaleDate);\r\n    require(state == SaleState.NEW);\r\n\r\n    state = SaleState.PRESALE;\r\n    emit ChangeState(block.number, state);\r\n  }\r\n\r\n  /**\r\n   * @dev Change status. Start calculate presale bonus.\r\n   */\r\n  function startCalculatePreSaleBonus() public onlyMultiOwnersType(5) {\r\n    require(state == SaleState.PRESALE);\r\n\r\n    state = SaleState.CALCPSBONUS;\r\n    emit ChangeState(block.number, state);\r\n  }\r\n\r\n  /**\r\n   * @dev Change status. Start sale.\r\n   */\r\n  function startSale() public onlyMultiOwnersType(2) {\r\n    require(block.timestamp <= endSaleDate);\r\n    require(state == SaleState.CALCPSBONUS);\r\n    //require(!storageContract.checkNeedProcessPreSaleBonus(getMinReachUsdPayInCents()));\r\n\r\n    state = SaleState.SALE;\r\n    emit ChangeState(block.number, state);\r\n  }\r\n\r\n  /**\r\n   * @dev Change status. Set end if sale it was successful.\r\n   */\r\n  function saleSetEnded() public onlyMultiOwnersType(3) {\r\n    require((state == SaleState.SALE) || (state == SaleState.PRESALE));\r\n    require(block.timestamp >= startSaleDate);\r\n    require(checkSoftCapAchieved());\r\n    state = SaleState.END;\r\n    storageContract.changeSupportChangeMainWallet(false);\r\n    emit ChangeState(block.number, state);\r\n  }\r\n\r\n  /**\r\n   * @dev Change status. Set refund when sale did not reach softcap.\r\n   */\r\n  function saleSetRefund() public onlyMultiOwnersType(4) {\r\n    require((state == SaleState.SALE) || (state == SaleState.PRESALE));\r\n    require(block.timestamp >= endSaleDate);\r\n    require(!checkSoftCapAchieved());\r\n    state = SaleState.REFUND;\r\n    emit ChangeState(block.number, state);\r\n  }\r\n\r\n  /**\r\n   * @dev Payable function. Processes contribution in ETH.\r\n   */\r\n  function buyTokens(address _beneficiary) public whenNotPaused payable {\r\n    require((state == SaleState.PRESALE && block.timestamp >= startPreSaleDate && block.timestamp <= endPreSaleDate) || (state == SaleState.SALE && block.timestamp >= startSaleDate && block.timestamp <= endSaleDate));\r\n    require(_beneficiary != address(0));\r\n    require(msg.value > 0);\r\n    uint usdAmount = currencyContract.getUsdFromETH(msg.value);\r\n\r\n    assert(usdAmount >= minimalContributionUSD);\r\n\r\n    uint bonusPercent = 0;\r\n\r\n    if (state == SaleState.SALE) {\r\n      bonusPercent = bonusContract.getCurrentDayBonus(startSaleDate, (state == SaleState.SALE));\r\n    }\r\n\r\n    (uint totalToken, uint tokenWithoutBonus, uint tokenBonus) = calcToken(usdAmount, bonusPercent);\r\n\r\n    assert((totalToken > 0 && totalToken <= calculateMaxCoinIssued()));\r\n\r\n    uint usdRate = currencyContract.getCurrencyRate(\"ETH\");\r\n\r\n    assert(storageContract.addPayment(_beneficiary, \"ETH\", msg.value, usdAmount, usdRate, tokenWithoutBonus, tokenBonus, bonusPercent, 0));\r\n    assert(currencyContract.addPay(\"ETH\", msg.value, usdAmount, totalToken, tokenBonus));\r\n\r\n    emit AddPay(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Manually add alternative contribution payment.\r\n   * @param ticker string\r\n   * @param value uint\r\n   * @param uId uint contributor identificator\r\n   * @param _pId uint payment identificator\r\n   * @param _currencyUSD uint current ticker rate (optional field)\r\n   */\r\n  function addPay(string ticker, uint value, uint uId, uint _pId, uint _currencyUSD) public onlyMultiOwnersType(6) {\r\n    require(value > 0);\r\n    require(storageContract.checkUserIdExists(uId));\r\n    require(_pId > 0);\r\n\r\n    string memory _ticker = ticker;\r\n    uint _value = value;\r\n    assert(currencyContract.checkTickerExists(_ticker));\r\n    uint usdAmount = currencyContract.getUsdFromCurrency(_ticker, _value, _currencyUSD);\r\n\r\n    assert(usdAmount > 0);\r\n\r\n    uint bonusPercent = 0;\r\n\r\n    if (state == SaleState.SALE) {\r\n      bonusPercent = bonusContract.getCurrentDayBonus(startSaleDate, (state == SaleState.SALE));\r\n    }\r\n\r\n    (uint totalToken, uint tokenWithoutBonus, uint tokenBonus) = calcToken(usdAmount, bonusPercent);\r\n\r\n    assert(tokenWithoutBonus > 0);\r\n\r\n    uint usdRate = _currencyUSD > 0 ? _currencyUSD : currencyContract.getCurrencyRate(_ticker);\r\n\r\n    uint pId = _pId;\r\n\r\n    assert(storageContract.addPayment(uId, _ticker, _value, usdAmount, usdRate, tokenWithoutBonus, tokenBonus, bonusPercent, pId));\r\n    assert(currencyContract.addPay(_ticker, _value, usdAmount, totalToken, tokenBonus));\r\n\r\n    emit AddPay(storageContract.getContributorAddressById(uId));\r\n  }\r\n\r\n  /**\r\n   * @dev Edit contribution payment.\r\n   * @param uId uint contributor identificator\r\n   * @param payId uint payment identificator\r\n   * @param value uint\r\n   * @param _currencyUSD uint current ticker rate (optional field)\r\n   * @param _bonusPercent uint current ticker rate (optional field)\r\n   */\r\n  function editPay(uint uId, uint payId, uint value, uint _currencyUSD, uint _bonusPercent) public onlyMultiOwnersType(7) {\r\n    require(value > 0);\r\n    require(storageContract.checkUserIdExists(uId));\r\n    require(payId > 0);\r\n    require((_bonusPercent == 0 || _bonusPercent <= getPreSaleBonusPercent()));\r\n\r\n    PaymentInfo memory payment = getPaymentInfo(uId, payId);\r\n    EditPaymentInfo memory paymentInfo = calcEditPaymentInfo(payment, value, _currencyUSD, _bonusPercent);\r\n\r\n    assert(paymentInfo.tokenWithoutBonus > 0);\r\n    assert(paymentInfo.currency.value > 0);\r\n    assert(paymentInfo.currency.usdRaised > 0);\r\n    assert(paymentInfo.currency.usdAbsRaisedInCents > 0);\r\n    assert(paymentInfo.currency.coinRaisedInWei > 0);\r\n\r\n    assert(currencyContract.editPay(payment.pType, paymentInfo.currency.value, paymentInfo.currency.usdRaised, paymentInfo.currency.usdAbsRaisedInCents, paymentInfo.currency.coinRaisedInWei, paymentInfo.currency.coinRaisedBonusInWei));\r\n    assert(storageContract.editPaymentByUserId(uId, payId, value, paymentInfo.usdAmount, paymentInfo.currencyUSD, paymentInfo.totalToken, paymentInfo.tokenWithoutBonus, paymentInfo.tokenBonus, paymentInfo.bonusPercent));\r\n\r\n    assert(reCountUserPreSaleBonus(uId));\r\n\r\n    emit EditPay(storageContract.getContributorAddressById(uId));\r\n  }\r\n\r\n  /**\r\n   * @dev Refund contribution payment.\r\n   * @param uId uint\r\n   * @param payId uint\r\n   */\r\n  function refundPay(uint uId, uint payId) public onlyMultiOwnersType(18) {\r\n    require(storageContract.checkUserIdExists(uId));\r\n    require(payId > 0);\r\n\r\n    (CurrencyInfo memory currencyInfo, bytes32 pType) = calcCurrency(getPaymentInfo(uId, payId), 0, 0, 0, 0);\r\n\r\n    assert(storageContract.refundPaymentByUserId(uId, payId));\r\n    assert(currencyContract.editPay(pType, currencyInfo.value, currencyInfo.usdRaised, currencyInfo.usdAbsRaisedInCents, currencyInfo.coinRaisedInWei, currencyInfo.coinRaisedBonusInWei));\r\n\r\n    assert(reCountUserPreSaleBonus(uId));\r\n\r\n    emit RefundPay(storageContract.getContributorAddressById(uId));\r\n  }\r\n\r\n  /**\r\n   * @dev Check if softCap is reached\r\n   */\r\n  function checkSoftCapAchieved() public view returns(bool) {\r\n    return softCapAchieved || getTotalUsdRaisedInCents() >= softCapUSD;\r\n  }\r\n\r\n  /**\r\n   * @dev Set softCapAchieved=true if softCap is reached\r\n   */\r\n  function activeSoftCapAchieved() public onlyMultiOwnersType(8) {\r\n    require(checkSoftCapAchieved());\r\n    require(getCoinBalance() >= maxDistributeCoin);\r\n    softCapAchieved = true;\r\n    emit SoftCapAchieved(getTotalUsdRaisedInCents());\r\n  }\r\n\r\n  /**\r\n   * @dev Send ETH from contract balance to multiSig.\r\n   */\r\n  function getEther() public onlyMultiOwnersType(9) {\r\n    require(getETHBalance() > 0);\r\n    require(softCapAchieved && (!multiSigReceivedSoftCap || (state == SaleState.END)));\r\n\r\n    uint sendEther = (address(this).balance / 2);\r\n    assert(sendEther > 0);\r\n\r\n    address(multiSig1).transfer(sendEther);\r\n    address(multiSig2).transfer(sendEther);\r\n    multiSigReceivedSoftCap = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Return maximum amount buy token.\r\n   */\r\n  function calculateMaxCoinIssued() public view returns (uint) {\r\n    return maxDistributeCoin - currencyContract.getCoinRaisedInWei();\r\n  }\r\n\r\n  /**\r\n   * @dev Return raised SHPC in wei.\r\n   */\r\n  function getCoinRaisedInWei() public view returns (uint) {\r\n    return currencyContract.getCoinRaisedInWei();\r\n  }\r\n\r\n  /**\r\n   * @dev Return raised usd in cents.\r\n   */\r\n  function getTotalUsdRaisedInCents() public view returns (uint) {\r\n    return currencyContract.getTotalUsdRaisedInCents();\r\n  }\r\n\r\n  /**\r\n   * @dev Return all currency rate in json.\r\n   */\r\n  function getAllCurrencyTicker() public view returns (string) {\r\n    return currencyContract.getAllCurrencyTicker();\r\n  }\r\n\r\n  /**\r\n   * @dev Return SHPC price in cents.\r\n   */\r\n  function getCoinUSDRate() public view returns (uint) {\r\n    return currencyContract.getCoinUSDRate();\r\n  }\r\n\r\n  /**\r\n   * @dev Retrun SHPC balance in contract.\r\n   */\r\n  function getCoinBalance() public view returns (uint) {\r\n    return coinContract.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n   * @dev Return balance ETH from contract.\r\n   */\r\n  function getETHBalance() public view returns (uint) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  /**\r\n   * @dev Processing of the data of the contributors. Bonus assignment for presale.\r\n   * @param start uint > 0\r\n   * @param limit uint > 0\r\n   */\r\n  function processSetPreSaleBonus(uint start, uint limit) public onlyMultiOwnersType(10) {\r\n    require(state == SaleState.CALCPSBONUS);\r\n    require(start >= 0 && limit > 0);\r\n    //require(storageContract.checkNeedProcessPreSaleBonus(getMinReachUsdPayInCents()));\r\n    uint bonusToken = storageContract.processPreSaleBonus(getMinReachUsdPayInCents(), getPreSaleBonusPercent(), start, limit);\r\n    if (bonusToken > 0) {\r\n      assert(currencyContract.addPreSaleBonus(bonusToken));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Processing of the data of the contributor by uId. Bonus assignment for presale.\r\n   * @param uId uint\r\n   */\r\n  function reCountUserPreSaleBonus(uint uId) public onlyMultiOwnersType(11) returns(bool) {\r\n    if (uint(state) > 1) { // > PRESALE\r\n      uint maxPayTime = 0;\r\n      if (state != SaleState.CALCPSBONUS) {\r\n        maxPayTime = startSaleDate;\r\n      }\r\n      (uint befTokenBonus, uint aftTokenBonus) = storageContract.reCountUserPreSaleBonus(uId, getMinReachUsdPayInCents(), getPreSaleBonusPercent(), maxPayTime);\r\n      assert(currencyContract.editPreSaleBonus(befTokenBonus, aftTokenBonus));\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Contributor get SHPC.\r\n   */\r\n  function getCoins() public {\r\n    return _getCoins(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Send contributors SHPC.\r\n   * @param start uint\r\n   * @param limit uint\r\n   */\r\n  function sendSHPCtoContributors(uint start, uint limit) public onlyMultiOwnersType(12) {\r\n    require(state == SaleState.END);\r\n    require(start >= 0 && limit > 0);\r\n    require(getCoinBalance() > 0);\r\n    //require(storageContract.checkNeedSendSHPC(state == SaleState.END));\r\n\r\n    for (uint i = start; i < limit; i++) {\r\n      uint uId = storageContract.getContributorIndexes(i);\r\n      if (uId > 0) {\r\n        address addr = storageContract.getContributorAddressById(uId);\r\n        uint coins = storageContract.getTotalCoin(addr);\r\n        if (!storageContract.checkReceivedCoins(addr) && storageContract.checkWalletExists(addr) && coins > 0 && ((storageContract.checkPreSaleReceivedBonus(addr) && block.timestamp >= unfreezeRefundPreSale) || (!storageContract.checkPreSaleReceivedBonus(addr) && block.timestamp >= unfreezeRefundAll))) {\r\n          if (coinContract.transfer(addr, coins)) {\r\n            storageContract.setReceivedCoin(uId);\r\n            emit SendSHPCtoContributor(addr);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Set startPreSaleDate\r\n   * @param date timestamp\r\n   */\r\n  function setStartPreSaleDate(uint date) public onlyMultiOwnersType(13) {\r\n    uint oldDate = startPreSaleDate;\r\n    startPreSaleDate = date;\r\n    emit ManualChangeStartPreSaleDate(oldDate, date);\r\n  }\r\n\r\n  /**\r\n   * @dev Set startPreSaleDate\r\n   * @param date timestamp\r\n   */\r\n  function setEndPreSaleDate(uint date) public onlyMultiOwnersType(14) {\r\n    uint oldDate = endPreSaleDate;\r\n    endPreSaleDate = date;\r\n    emit ManualChangeEndPreSaleDate(oldDate, date);\r\n  }\r\n\r\n  /**\r\n   * @dev Set startSaleDate\r\n   * @param date timestamp\r\n   */\r\n  function setStartSaleDate(uint date) public onlyMultiOwnersType(15) {\r\n    uint oldDate = startSaleDate;\r\n    startSaleDate = date;\r\n    emit ManualChangeStartSaleDate(oldDate, date);\r\n  }\r\n\r\n  /**\r\n   * @dev Set endSaleDate\r\n   * @param date timestamp\r\n   */\r\n  function setEndSaleDate(uint date) public onlyMultiOwnersType(16) {\r\n    uint oldDate = endSaleDate;\r\n    endSaleDate = date;\r\n    emit ManualEndSaleDate(oldDate, date);\r\n  }\r\n\r\n  /**\r\n   * @dev Return SHPC from contract. When sale ended end contributor got SHPC.\r\n   */\r\n  function getSHPCBack() public onlyMultiOwnersType(17) {\r\n    require(state == SaleState.END);\r\n    require(getCoinBalance() > 0);\r\n    //require(!storageContract.checkNeedSendSHPC(state == SaleState.END));\r\n    coinContract.transfer(msg.sender, getCoinBalance());\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Refund ETH contributor.\r\n   */\r\n  function refundETH() public {\r\n    return _refundETH(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Refund ETH contributors.\r\n   * @param start uint\r\n   * @param limit uint\r\n   */\r\n  function refundETHContributors(uint start, uint limit) public onlyMultiOwnersType(19) {\r\n    require(state == SaleState.REFUND);\r\n    require(start >= 0 && limit > 0);\r\n    require(getETHBalance() > 0);\r\n    //require(storageContract.checkETHRefund(state == SaleState.REFUND));\r\n\r\n    for (uint i = start; i < limit; i++) {\r\n      uint uId = storageContract.getContributorIndexes(i);\r\n      if (uId > 0) {\r\n        address addr = storageContract.getContributorAddressById(uId);\r\n        uint ethAmount = storageContract.getEthPaymentContributor(addr);\r\n\r\n        if (!storageContract.checkRefund(addr) && storageContract.checkWalletExists(addr) && ethAmount > 0) {\r\n          storageContract.setRefund(uId);\r\n          addr.transfer(ethAmount);\r\n          emit Refund(addr);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Return pre-sale bonus getPreSaleBonusPercent.\r\n   */\r\n  function getPreSaleBonusPercent() public view returns(uint) {\r\n    return bonusContract.getPreSaleBonusPercent();\r\n  }\r\n\r\n  /**\r\n   * @dev Return pre-sale minReachUsdPayInCents.\r\n   */\r\n  function getMinReachUsdPayInCents() public view returns(uint) {\r\n    return bonusContract.getMinReachUsdPayInCents();\r\n  }\r\n\r\n  /**\r\n   * @dev Return current sale day.\r\n   */\r\n  function _currentDay() public view returns(uint) {\r\n    return bonusContract._currentDay(startSaleDate, (state == SaleState.SALE));\r\n  }\r\n\r\n  /**\r\n   * @dev Return current sale day bonus percent.\r\n   */\r\n  function getCurrentDayBonus() public view returns(uint) {\r\n    return bonusContract.getCurrentDayBonus(startSaleDate, (state == SaleState.SALE));\r\n  }\r\n\r\n  /**\r\n   * @dev Return contributor payment info.\r\n   * @param uId uint\r\n   * @param pId uint\r\n   */\r\n  function getPaymentInfo(uint uId, uint pId) private view returns(PaymentInfo) {\r\n    (, bytes32 pType,\r\n    uint currencyUSD,\r\n    uint bonusPercent,\r\n    uint payValue,\r\n    uint totalToken,\r\n    uint tokenBonus,,\r\n    uint usdAbsRaisedInCents,\r\n    bool refund) = storageContract.getUserPaymentById(uId, pId);\r\n\r\n    return PaymentInfo(pType, currencyUSD, bonusPercent, payValue, totalToken, tokenBonus, usdAbsRaisedInCents, refund);\r\n  }\r\n\r\n  /**\r\n   * @dev Return recalculate payment data from old payment user.\r\n   */\r\n  function calcEditPaymentInfo(PaymentInfo payment, uint value, uint _currencyUSD, uint _bonusPercent) private view returns(EditPaymentInfo) {\r\n    (uint usdAmount, uint currencyUSD, uint bonusPercent) = getUsdAmountFromPayment(payment, value, _currencyUSD, _bonusPercent);\r\n    (uint totalToken, uint tokenWithoutBonus, uint tokenBonus) = calcToken(usdAmount, bonusPercent);\r\n    (CurrencyInfo memory currency,) = calcCurrency(payment, value, usdAmount, totalToken, tokenBonus);\r\n\r\n    return EditPaymentInfo(usdAmount, currencyUSD, bonusPercent, totalToken, tokenWithoutBonus, tokenBonus, currency);\r\n  }\r\n\r\n  /**\r\n   * @dev Return usd from payment amount.\r\n   */\r\n  function getUsdAmountFromPayment(PaymentInfo payment, uint value, uint _currencyUSD, uint _bonusPercent) private view returns(uint, uint, uint) {\r\n    _currencyUSD = _currencyUSD > 0 ? _currencyUSD : payment.currencyUSD;\r\n    _bonusPercent = _bonusPercent > 0 ? _bonusPercent : payment.bonusPercent;\r\n    uint usdAmount = currencyContract.getUsdFromCurrency(payment.pType, value, _currencyUSD);\r\n    return (usdAmount, _currencyUSD, _bonusPercent);\r\n  }\r\n\r\n  /**\r\n   * @dev Return payment SHPC data from usd amount and bonusPercent\r\n   */\r\n  function calcToken(uint usdAmount, uint _bonusPercent) private view returns(uint, uint, uint) {\r\n    uint tokenWithoutBonus = currencyContract.getTokenWeiFromUSD(usdAmount);\r\n    uint tokenBonus = _bonusPercent > 0 ? tokenWithoutBonus.mul(_bonusPercent).div(100) : 0;\r\n    uint totalToken = tokenBonus > 0 ? tokenWithoutBonus.add(tokenBonus) : tokenWithoutBonus;\r\n    return (totalToken, tokenWithoutBonus, tokenBonus);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate currency data when edit user payment data\r\n   */\r\n  function calcCurrency(PaymentInfo payment, uint value, uint usdAmount, uint totalToken, uint tokenBonus) private view returns(CurrencyInfo, bytes32) {\r\n    (,,, uint currencyValue, uint currencyUsdRaised,,,) = currencyContract.getCurrencyList(payment.pType);\r\n\r\n    uint usdAbsRaisedInCents = currencyContract.getUsdAbsRaisedInCents();\r\n    uint coinRaisedInWei = currencyContract.getCoinRaisedInWei();\r\n    uint coinRaisedBonusInWei = currencyContract.getCoinRaisedBonusInWei();\r\n\r\n    currencyValue -= payment.payValue;\r\n    currencyUsdRaised -= payment.usdAbsRaisedInCents;\r\n\r\n    usdAbsRaisedInCents -= payment.usdAbsRaisedInCents;\r\n    coinRaisedInWei -= payment.totalToken;\r\n    coinRaisedBonusInWei -= payment.tokenBonus;\r\n\r\n    currencyValue += value;\r\n    currencyUsdRaised += usdAmount;\r\n\r\n    usdAbsRaisedInCents += usdAmount;\r\n    coinRaisedInWei += totalToken;\r\n    coinRaisedBonusInWei += tokenBonus;\r\n\r\n    return (CurrencyInfo(currencyValue, currencyUsdRaised, usdAbsRaisedInCents, coinRaisedInWei, coinRaisedBonusInWei), payment.pType);\r\n  }\r\n\r\n  /**\r\n   * @dev Getting the SHPC from the contributor\r\n   */\r\n  function _getCoins(address addr) private {\r\n    require(state == SaleState.END);\r\n    require(storageContract.checkWalletExists(addr));\r\n    require(!storageContract.checkReceivedCoins(addr));\r\n    require((storageContract.checkPreSaleReceivedBonus(addr) && block.timestamp >= unfreezeRefundPreSale) || (!storageContract.checkPreSaleReceivedBonus(addr) && block.timestamp >= unfreezeRefundAll));\r\n    uint uId = storageContract.getContributorId(addr);\r\n    uint coins = storageContract.getTotalCoin(addr);\r\n    assert(uId > 0 && coins > 0);\r\n    if (coinContract.transfer(addr, coins)) {\r\n      storageContract.setReceivedCoin(uId);\r\n      emit SendSHPCtoContributor(addr);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Refund ETH contributor when sale not reach softcap.\r\n   */\r\n  function _refundETH(address addr) private {\r\n    require(state == SaleState.REFUND);\r\n    require(storageContract.checkWalletExists(addr));\r\n    require(!storageContract.checkRefund(addr));\r\n\r\n    uint uId = storageContract.getContributorId(addr);\r\n    uint ethAmount = storageContract.getEthPaymentContributor(addr);\r\n    assert(uId > 0 && ethAmount > 0 && getETHBalance() >= ethAmount);\r\n\r\n    storageContract.setRefund(uId);\r\n    addr.transfer(ethAmount);\r\n    emit Refund(addr);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"saleSetEnded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkSoftCapAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"processSetPreSaleBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"payId\",\"type\":\"uint256\"}],\"name\":\"refundPay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPreSaleBonusPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addMultiOwnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"refundETHContributors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activeSoftCapAchieved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"setEndPreSaleDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"sendSHPCtoContributors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoinUSDRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minContribUsd\",\"type\":\"uint256\"}],\"name\":\"setMinimalContributionUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPreSaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"setEndSaleDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoinBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCurrencyTicker\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"onlyMultiOwnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unfreezeRefundAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currencyContract\",\"type\":\"address\"}],\"name\":\"setCurrencyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"}],\"name\":\"reCountUserPreSaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSig1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getETHBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCalculatePreSaleBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateMaxCoinIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxCoin\",\"type\":\"uint256\"}],\"name\":\"changeMaxDistributeCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapAchieved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getSHPCBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unfreezeRefundPreSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDistributeCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSig2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"payId\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"_currencyUSD\",\"type\":\"uint256\"},{\"name\":\"_bonusPercent\",\"type\":\"uint256\"}],\"name\":\"editPay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ticker\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"uId\",\"type\":\"uint256\"},{\"name\":\"_pId\",\"type\":\"uint256\"},{\"name\":\"_currencyUSD\",\"type\":\"uint256\"}],\"name\":\"addPay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startSaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPreSaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"types\",\"type\":\"uint256[]\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addMultiOwnerTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"setStartSaleDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSigReceivedSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_softCapUsdInCents\",\"type\":\"uint256\"}],\"name\":\"setSoftCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinReachUsdPayInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalUsdRaisedInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endSaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"saleSetRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_storageContract\",\"type\":\"address\"}],\"name\":\"setStorageContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setUnfreezeRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_currentDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonusContract\",\"type\":\"address\"}],\"name\":\"setBonusContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"types\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeMultiOwnerType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coinAddress\",\"type\":\"address\"},{\"name\":\"_storageContract\",\"type\":\"address\"},{\"name\":\"_currencyContract\",\"type\":\"address\"},{\"name\":\"_bonusContract\",\"type\":\"address\"},{\"name\":\"_multiSig1\",\"type\":\"address\"},{\"name\":\"_startPreSaleDate\",\"type\":\"uint256\"},{\"name\":\"_endPreSaleDate\",\"type\":\"uint256\"},{\"name\":\"_startSaleDate\",\"type\":\"uint256\"},{\"name\":\"_endSaleDate\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoinRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"setStartPreSaleDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalContributionUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coinContract\",\"type\":\"address\"}],\"name\":\"setCoinContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDayBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"ChangeState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ChangeMinContribUSD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"ChangeStorageContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"ChangeCurrencyContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"ChangeCoinContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"ChangeBonusContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"AddPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"EditPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SoftCapAchieved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"ManualChangeStartPreSaleDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"ManualChangeEndPreSaleDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"ManualChangeStartSaleDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"ManualEndSaleDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"SendSHPCtoContributor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SoftCapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"RefundPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"types\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"RemoveOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ShipCoinCrowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5c0ef86dabf1708cfed9c0d39584e0d692a74cc5d6428bede8666fc9af63d0fb"}]}