{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        if (item.length == 0)\r\n            return RLPItem(0, 0);\r\n\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr);\r\n            memPtr = memPtr + dataLen;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Helpers\r\n    */\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) internal pure returns (uint) {\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n            count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 1;\r\n\r\n        else if (byte0 < STRING_LONG_START)\r\n            return byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n\r\n            /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            return byte0 - LIST_SHORT_START + 1;\r\n        }\r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1, \"Invalid RLPItem. Booleans are encoded in 1 byte\");\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix according to RLP spec\r\n        require(item.len == 21, \"Invalid RLPItem. Addresses are encoded in 20 bytes\");\r\n\r\n        uint memPtr = item.memPtr + 1; // skip the length prefix\r\n        uint addr;\r\n        assembly {\r\n            addr := div(mload(memPtr), exp(256, 12)) // right shift 12 bytes. we want the most significant 20 bytes\r\n        }\r\n\r\n        return address(addr);\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n        uint memPtr = item.memPtr + offset;\r\n\r\n        uint result;\r\n        assembly {\r\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary RLPWriter {\r\n    function toRlp(bytes memory _value) internal pure returns (bytes memory _bytes) {\r\n        uint _valuePtr;\r\n        uint _rplPtr;\r\n        uint _valueLength = _value.length;\r\n\r\n        assembly {\r\n            _valuePtr := add(_value, 0x20)\r\n            _bytes := mload(0x40)                   // Free memory ptr\r\n            _rplPtr := add(_bytes, 0x20)            // RLP first byte ptr\r\n        }\r\n\r\n        // [0x00, 0x7f]\r\n        if (_valueLength == 1 && _value[0] <= 0x7f) {\r\n            assembly {\r\n                mstore(_bytes, 1)                   // Bytes size is 1\r\n                mstore(_rplPtr, mload(_valuePtr))  // Set value as-is\r\n                mstore(0x40, add(_rplPtr, 1))       // Update free ptr\r\n            }\r\n            return;\r\n        }\r\n\r\n        // [0x80, 0xb7]\r\n        if (_valueLength <= 55) {\r\n            assembly {\r\n                mstore(_bytes, add(1, _valueLength))            // Bytes size\r\n                mstore8(_rplPtr, add(0x80, _valueLength))       // RLP small string size\r\n                mstore(0x40, add(add(_rplPtr, 1), _valueLength)) // Update free ptr\r\n            }\r\n\r\n            copy(_valuePtr, _rplPtr + 1, _valueLength);\r\n            return;\r\n        }\r\n\r\n        // [0xb8, 0xbf]\r\n        uint _lengthSize = uintMinimalSize(_valueLength);\r\n\r\n        assembly {\r\n            mstore(_bytes, add(add(1, _lengthSize), _valueLength))  // Bytes size\r\n            mstore8(_rplPtr, add(0xb7, _lengthSize))                // RLP long string \"size size\"\r\n            mstore(add(_rplPtr, 1), mul(_valueLength, exp(256, sub(32, _lengthSize)))) // Bitshift to store the length only _lengthSize bytes\r\n            mstore(0x40, add(add(add(_rplPtr, 1), _lengthSize), _valueLength))  // Update free ptr\r\n        }\r\n\r\n        copy(_valuePtr, _rplPtr + 1 + _lengthSize, _valueLength);\r\n        return;\r\n    }\r\n\r\n    function toRlp(uint _value) internal pure returns (bytes memory _bytes) {\r\n        uint _size = uintMinimalSize(_value);\r\n\r\n        bytes memory _valueBytes = new bytes(_size);\r\n\r\n        assembly {\r\n            mstore(add(_valueBytes, 0x20), mul(_value, exp(256, sub(32, _size))))\r\n        }\r\n\r\n        return toRlp(_valueBytes);\r\n    }\r\n\r\n    function toRlp(bytes[] memory _values) internal pure returns (bytes memory _bytes) {\r\n        uint _ptr;\r\n        uint _size;\r\n        uint i;\r\n\r\n        // compute data size\r\n        for(; i < _values.length; ++i)\r\n            _size += _values[i].length;\r\n\r\n        // create rlp header\r\n        assembly {\r\n            _bytes := mload(0x40)\r\n            _ptr := add(_bytes, 0x20)\r\n        }\r\n\r\n        if (_size <= 55) {\r\n            assembly {\r\n                mstore8(_ptr, add(0xc0, _size))\r\n                _ptr := add(_ptr, 1)\r\n            }\r\n        } else {\r\n            uint _size2 = uintMinimalSize(_size);\r\n\r\n            assembly {\r\n                mstore8(_ptr, add(0xf7, _size2))\r\n                _ptr := add(_ptr, 1)\r\n                mstore(_ptr, mul(_size, exp(256, sub(32, _size2))))\r\n                _ptr := add(_ptr, _size2)\r\n            }\r\n        }\r\n\r\n        // copy data\r\n        for(i = 0; i < _values.length; ++i) {\r\n            bytes memory _val = _values[i];\r\n            uint _valPtr;\r\n\r\n            assembly {\r\n                _valPtr := add(_val, 0x20)\r\n            }\r\n\r\n            copy(_valPtr, _ptr, _val.length);\r\n\r\n            _ptr += _val.length;\r\n        }\r\n\r\n        assembly {\r\n            mstore(0x40, _ptr)\r\n            mstore(_bytes, sub(sub(_ptr, _bytes), 0x20))\r\n        }\r\n    }\r\n\r\n    function uintMinimalSize(uint _value) internal pure returns (uint _size) {\r\n        for (; _value != 0; _size++)\r\n            _value /= 256;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // copy as many word sizes as possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += 32;\r\n            dest += 32;\r\n        }\r\n\r\n        // left over bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary AuctionityLibraryDecodeRawTx {\r\n\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using RLPReader for bytes;\r\n\r\n    function decodeRawTxGetBiddingInfo(bytes memory _signedRawTxBidding, uint8 _chainId) internal pure returns (bytes32 _hashRawTxTokenTransfer, address _auctionContractAddress, uint256 _bidAmount, address _signerBid) {\r\n\r\n        bytes memory _auctionBidlData;\r\n        RLPReader.RLPItem[] memory _signedRawTxBiddingRLPItem = _signedRawTxBidding.toRlpItem().toList();\r\n\r\n        _auctionContractAddress = _signedRawTxBiddingRLPItem[3].toAddress();\r\n        _auctionBidlData = _signedRawTxBiddingRLPItem[5].toBytes();\r\n\r\n        bytes4 _selector;\r\n        assembly { _selector := mload(add(_auctionBidlData,0x20))}\r\n\r\n        _signerBid = getSignerFromSignedRawTxRLPItemp(_signedRawTxBiddingRLPItem,_chainId);\r\n\r\n        // 0x1d03ae68 : bytes4(keccak256('bid(uint256,address,bytes32)'))\r\n        if(_selector == 0x1d03ae68 ) {\r\n\r\n            assembly {\r\n                _bidAmount := mload(add(_auctionBidlData,add(4,0x20)))\r\n                _hashRawTxTokenTransfer := mload(add(_auctionBidlData,add(68,0x20)))\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function decodeRawTxGetCreateAuctionInfo(bytes memory _signedRawTxCreateAuction, uint8 _chainId) internal pure returns (\r\n        bytes32 _tokenHash,\r\n        address _auctionFactoryContractAddress,\r\n        address _signerCreate,\r\n        address _tokenContractAddress,\r\n        uint256 _tokenId,\r\n        uint8 _rewardPercent\r\n    ) {\r\n\r\n        bytes memory _createAuctionlData;\r\n        RLPReader.RLPItem[] memory _signedRawTxCreateAuctionRLPItem = _signedRawTxCreateAuction.toRlpItem().toList();\r\n\r\n\r\n        _auctionFactoryContractAddress = _signedRawTxCreateAuctionRLPItem[3].toAddress();\r\n        _createAuctionlData = _signedRawTxCreateAuctionRLPItem[5].toBytes();\r\n\r\n\r\n        _signerCreate = getSignerFromSignedRawTxRLPItemp(_signedRawTxCreateAuctionRLPItem,_chainId);\r\n\r\n        bytes memory _signedRawTxTokenTransfer;\r\n\r\n        (_signedRawTxTokenTransfer, _tokenContractAddress,_tokenId,_rewardPercent) = decodeRawTxGetCreateAuctionInfoData( _createAuctionlData);\r\n\r\n\r\n\r\n        _tokenHash = keccak256(_signedRawTxTokenTransfer);\r\n\r\n    }\r\n\r\n    function decodeRawTxGetCreateAuctionInfoData(bytes memory _createAuctionlData) internal pure returns(\r\n        bytes memory _signedRawTxTokenTransfer,\r\n        address _tokenContractAddress,\r\n        uint256 _tokenId,\r\n        uint8 _rewardPercent\r\n    ) {\r\n        bytes4 _selector;\r\n        assembly { _selector := mload(add(_createAuctionlData,0x20))}\r\n\r\n        uint _positionOfSignedRawTxTokenTransfer;\r\n        uint _sizeOfSignedRawTxTokenTransfer;\r\n\r\n        // 0xffd6d828 : bytes4(keccak256('create(bytes,address,uint256,bytes,address,uint8)'))\r\n        if(_selector == 0xffd6d828) {\r\n\r\n            assembly {\r\n                _positionOfSignedRawTxTokenTransfer := mload(add(_createAuctionlData,add(4,0x20)))\r\n                _sizeOfSignedRawTxTokenTransfer := mload(add(_createAuctionlData,add(add(_positionOfSignedRawTxTokenTransfer,4),0x20)))\r\n\r\n            // tokenContractAddress : get 2th param\r\n                _tokenContractAddress := mload(add(_createAuctionlData,add(add(mul(1,32),4),0x20)))\r\n            // tockenId : get 3th param\r\n                _tokenId := mload(add(_createAuctionlData,add(add(mul(2,32),4),0x20)))\r\n            // rewardPercent : get 6th param\r\n                _rewardPercent := mload(add(_createAuctionlData,add(add(mul(5,32),4),0x20)))\r\n\r\n            }\r\n\r\n            _signedRawTxTokenTransfer = new bytes(_sizeOfSignedRawTxTokenTransfer);\r\n\r\n            for (uint i = 0; i < _sizeOfSignedRawTxTokenTransfer; i++) {\r\n                _signedRawTxTokenTransfer[i] = _createAuctionlData[i + _positionOfSignedRawTxTokenTransfer + 4 + 32 ];\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function ecrecoverSigner(\r\n        bytes32 _hashTx,\r\n        bytes _rsvTx,\r\n        uint offset\r\n    ) internal pure returns (address ecrecoverAddress){\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        bytes1 v;\r\n\r\n        assembly {\r\n            r := mload(add(_rsvTx,add(offset,0x20)))\r\n            s := mload(add(_rsvTx,add(offset,0x40)))\r\n            v := mload(add(_rsvTx,add(offset,0x60)))\r\n        }\r\n\r\n        ecrecoverAddress = ecrecover(\r\n            _hashTx,\r\n            uint8(v),\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n\r\n\r\n    function decodeRawTxGetWithdrawalInfo(bytes memory _signedRawTxWithdrawal, uint8 _chainId) internal pure returns (address withdrawalSigner, uint256 withdrawalAmount) {\r\n\r\n        bytes4 _selector;\r\n        bytes memory _withdrawalData;\r\n        RLPReader.RLPItem[] memory _signedRawTxWithdrawalRLPItem = _signedRawTxWithdrawal.toRlpItem().toList();\r\n\r\n        _withdrawalData = _signedRawTxWithdrawalRLPItem[5].toBytes();\r\n\r\n        assembly { _selector := mload(add(_withdrawalData,0x20))}\r\n\r\n        withdrawalSigner = getSignerFromSignedRawTxRLPItemp(_signedRawTxWithdrawalRLPItem,_chainId);\r\n\r\n        // 0x835fc6ca : bytes4(keccak256('withdrawal(uint256)'))\r\n        if(_selector == 0x835fc6ca ) {\r\n\r\n            assembly {\r\n                withdrawalAmount := mload(add(_withdrawalData,add(4,0x20)))\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function getSignerFromSignedRawTxRLPItemp(RLPReader.RLPItem[] memory _signedTxRLPItem, uint8 _chainId) internal pure returns (address ecrecoverAddress) {\r\n        bytes memory _rawTx;\r\n        bytes memory _rsvTx;\r\n\r\n        (_rawTx, _rsvTx ) = explodeSignedRawTxRLPItem(_signedTxRLPItem, _chainId);\r\n        return ecrecoverSigner(keccak256(_rawTx), _rsvTx,0);\r\n    }\r\n\r\n    function explodeSignedRawTxRLPItem(RLPReader.RLPItem[] memory _signedTxRLPItem, uint8 _chainId) internal pure returns (bytes memory _rawTx,bytes memory _rsvTx){\r\n\r\n        bytes[] memory _signedTxRLPItemRaw = new bytes[](9);\r\n\r\n        _signedTxRLPItemRaw[0] = RLPWriter.toRlp(_signedTxRLPItem[0].toBytes());\r\n        _signedTxRLPItemRaw[1] = RLPWriter.toRlp(_signedTxRLPItem[1].toBytes());\r\n        _signedTxRLPItemRaw[2] = RLPWriter.toRlp(_signedTxRLPItem[2].toBytes());\r\n        _signedTxRLPItemRaw[3] = RLPWriter.toRlp(_signedTxRLPItem[3].toBytes());\r\n        _signedTxRLPItemRaw[4] = RLPWriter.toRlp(_signedTxRLPItem[4].toBytes());\r\n        _signedTxRLPItemRaw[5] = RLPWriter.toRlp(_signedTxRLPItem[5].toBytes());\r\n\r\n        _signedTxRLPItemRaw[6] = RLPWriter.toRlp(_chainId);\r\n        _signedTxRLPItemRaw[7] = RLPWriter.toRlp(0);\r\n        _signedTxRLPItemRaw[8] = RLPWriter.toRlp(0);\r\n\r\n        _rawTx = RLPWriter.toRlp(_signedTxRLPItemRaw);\r\n\r\n        uint8 i;\r\n        _rsvTx = new bytes(65);\r\n\r\n        bytes32 tmp = bytes32(_signedTxRLPItem[7].toUint());\r\n        for (i = 0; i < 32; i++) {\r\n            _rsvTx[i] = tmp[i];\r\n        }\r\n\r\n        tmp = bytes32(_signedTxRLPItem[8].toUint());\r\n\r\n        for (i = 0; i < 32; i++) {\r\n            _rsvTx[i + 32] = tmp[i];\r\n        }\r\n\r\n        _rsvTx[64] = bytes1(_signedTxRLPItem[6].toUint() - uint(_chainId * 2) - 8);\r\n\r\n    }\r\n\r\n}\r\nlibrary AuctionityLibraryDeposit{\r\n\r\n    function sendTransfer(address _tokenContractAddress, bytes memory _transfer, uint _offset) internal returns (bool){\r\n\r\n        if(!isContract(_tokenContractAddress)){\r\n            return false;\r\n        }\r\n\r\n        uint8 _numberOfTransfer = uint8(_transfer[_offset]);\r\n\r\n        _offset += 1;\r\n\r\n        bool _success;\r\n        for (uint8 i = 0; i < _numberOfTransfer; i++){\r\n            (_offset,_success) = decodeTransferCall(_tokenContractAddress, _transfer,_offset);\r\n            \r\n            if(!_success) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function decodeTransferCall(address _tokenContractAddress, bytes memory _transfer, uint _offset) internal returns (uint, bool) {\r\n\r\n\r\n        bytes memory _sizeOfCallBytes;\r\n        bytes memory _callData;\r\n\r\n        uint _sizeOfCallUint;\r\n\r\n        if(_transfer[_offset] == 0xb8) {\r\n            _sizeOfCallBytes = new bytes(1);\r\n            _sizeOfCallBytes[0] = bytes1(_transfer[_offset + 1]);\r\n\r\n            _offset+=2;\r\n        }\r\n        if(_transfer[_offset] == 0xb9) {\r\n\r\n            _sizeOfCallBytes = new bytes(2);\r\n            _sizeOfCallBytes[0] = bytes1(_transfer[_offset + 1]);\r\n            _sizeOfCallBytes[1] = bytes1(_transfer[_offset + 2]);\r\n            _offset+=3;\r\n        }\r\n\r\n        _sizeOfCallUint = bytesToUint(_sizeOfCallBytes);\r\n\r\n        _callData = new bytes(_sizeOfCallUint);\r\n        for (uint j = 0; j < _sizeOfCallUint; j++) {\r\n            _callData[j] = _transfer[(j + _offset)];\r\n        }\r\n\r\n        _offset+=_sizeOfCallUint;\r\n\r\n        return (_offset, sendCallData(_tokenContractAddress, _sizeOfCallUint, _callData));\r\n\r\n\r\n    }\r\n\r\n    function sendCallData(address _tokenContractAddress, uint _sizeOfCallUint, bytes memory _callData) internal returns (bool) {\r\n\r\n        bool _success;\r\n        bytes4 sig;\r\n\r\n        assembly {\r\n\r\n            let _ptr := mload(0x40)\r\n            sig := mload(add(_callData,0x20))\r\n\r\n            mstore(_ptr,sig) //Place signature at begining of empty storage\r\n            for { let i := 0x04 } lt(i, _sizeOfCallUint) { i := add(i, 0x20) } {\r\n                mstore(add(_ptr,i),mload(add(_callData,add(0x20,i)))) //Add each param\r\n            }\r\n\r\n\r\n            _success := call(      //This is the critical change (Pop the top stack value)\r\n            sub (gas, 10000), // gas\r\n            _tokenContractAddress, //To addr\r\n            0,    //No value\r\n            _ptr,    //Inputs are stored at location _ptr\r\n            _sizeOfCallUint, //Inputs _size\r\n            _ptr,    //Store output over input (saves space)\r\n            0x20) //Outputs are 32 bytes long\r\n\r\n        }\r\n\r\n        return _success;\r\n    }\r\n\r\n    \r\n    function isContract(address _contractAddress) internal view returns (bool) {\r\n        uint _size;\r\n        assembly { _size := extcodesize(_contractAddress) }\r\n        return _size > 0;\r\n    }\r\n\r\n    function bytesToUint(bytes b) internal pure returns (uint256){\r\n        uint256 _number;\r\n        for(uint i=0;i<b.length;i++){\r\n            _number = _number + uint(b[i])*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return _number;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract AuctionityDepositEth {\r\n    using SafeMath for uint256;\r\n\r\n    string public version = \"deposit-eth-v1\";\r\n\r\n    address public owner;\r\n    address public oracle;\r\n    uint8 public ethereumChainId;\r\n    uint8 public auctionityChainId;\r\n    bool public migrationLock;\r\n    bool public maintenanceLock;\r\n\r\n    mapping (address => uint256) public depotEth;  // Depot for users (concatenate struct into uint256)\r\n\r\n    bytes32[] public withdrawalVoucherList;                     // List of withdrawal voucher\r\n    mapping (bytes32 => bool) public withdrawalVoucherSubmitted; // is withdrawal voucher is already submitted\r\n\r\n    bytes32[] public auctionEndVoucherList;                     // List of auction end voucher\r\n    mapping (bytes32 => bool) public auctionEndVoucherSubmitted; // is auction end voucher is already submitted\r\n\r\n    struct InfoFromCreateAuction {\r\n        address tokenContractAddress;\r\n        address auctionSeller;\r\n        uint256 tokenId;\r\n        uint8 rewardPercent;\r\n        bytes32 tokenHash;\r\n    }\r\n\r\n    struct InfoFromBidding {\r\n        address auctionContractAddress;\r\n        address signer;\r\n        uint256 amount;\r\n    }\r\n\r\n    // events\r\n    event LogDeposed(address user, uint256 amount);\r\n    event LogWithdrawalVoucherSubmitted(address user, uint256 amount, bytes32 withdrawalVoucherHash);\r\n\r\n    event LogAuctionEndVoucherSubmitted(\r\n        address indexed auctionContractAddress,\r\n        address tokenContractAddress,\r\n        uint256 tokenId,\r\n        address indexed seller,\r\n        address indexed winner,\r\n        uint256 amount\r\n    );\r\n    event LogSentEthToWinner(address auction, address user, uint256 amount);\r\n    event LogSentEthToAuctioneer(address auction, address user, uint256 amount);\r\n    event LogSentDepotEth(address user, uint256 amount);\r\n    event LogSentRewardsDepotEth(address[] user, uint256[] amount);\r\n\r\n    event LogError(string version,string error);\r\n    event LogErrorWithData(string version, string error, bytes32[] data);\r\n\r\n\r\n    constructor(uint8 _ethereumChainId, uint8 _auctionityChainId) public {\r\n        ethereumChainId = _ethereumChainId;\r\n        auctionityChainId = _auctionityChainId;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Modifier\r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"Sender must be owner\");\r\n        _;\r\n    }\r\n\r\n    modifier isOracle() {\r\n        require(msg.sender == oracle, \"Sender must be oracle\");\r\n        _;\r\n    }\r\n\r\n    function setOracle(address _oracle) public isOwner {\r\n        oracle = _oracle;\r\n    }\r\n\r\n    modifier migrationLockable() {\r\n        require(!migrationLock || msg.sender == owner, \"MIGRATION_LOCKED\");\r\n        _;\r\n    }\r\n\r\n    function setMigrationLock(bool _lock) public isOwner {\r\n        migrationLock = _lock;\r\n    }\r\n\r\n    modifier maintenanceLockable() {\r\n        require(!maintenanceLock || msg.sender == owner, \"MAINTENANCE_LOCKED\");\r\n        _;\r\n    } \r\n\r\n    function setMaintenanceLock(bool _lock) public isOwner {\r\n        maintenanceLock = _lock;\r\n    }\r\n\r\n    // add depot from user\r\n    function addDepotEth(address _user, uint256 _amount) private returns (bool) {\r\n        depotEth[_user] = depotEth[_user].add(_amount);\r\n        return true;\r\n    }\r\n\r\n    // sub depot from user\r\n    function subDepotEth(address _user, uint256 _amount) private returns (bool) {\r\n        if(depotEth[_user] < _amount){\r\n            return false;\r\n        }\r\n\r\n        depotEth[_user] = depotEth[_user].sub(_amount);\r\n        return true;\r\n    }\r\n\r\n    // get amount of user's deposit\r\n    function getDepotEth(address _user) public view returns(uint256 _amount) {\r\n        return depotEth[_user];\r\n    }\r\n\r\n    // fallback payable function , with revert if is deactivated\r\n    function() public payable {\r\n        return depositEth();\r\n    }\r\n\r\n    // payable deposit eth\r\n    function depositEth() public payable migrationLockable maintenanceLockable {\r\n        bytes32[] memory _errorData;\r\n        uint256 _amount = uint256(msg.value);\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n\r\n        if(!addDepotEth(msg.sender, _amount)) {\r\n            _errorData = new bytes32[](1);\r\n            _errorData[0] = bytes32(_amount);\r\n            emit LogErrorWithData(version, \"DEPOSED_ADD_DATA_FAILED\", _errorData);\r\n            return;\r\n        }\r\n\r\n        emit LogDeposed(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * withdraw\r\n     * @dev Param\r\n     *      bytes32 r ECDSA signature\r\n     *      bytes32 s ECDSA signature\r\n     *      uint8 v ECDSA signature\r\n     *      address user\r\n     *      uint256 amount\r\n     *      bytes32 key : anti replay\r\n     * @dev Log\r\n     *      LogWithdrawalVoucherSubmitted : successful\r\n     */\r\n    function withdrawalVoucher(\r\n        bytes memory _data,\r\n        bytes memory _signedRawTxWithdrawal\r\n    ) public maintenanceLockable {\r\n        bytes32 _withdrawalVoucherHash = keccak256(_signedRawTxWithdrawal);\r\n\r\n        // if withdrawal voucher is already submitted\r\n        if(withdrawalVoucherSubmitted[_withdrawalVoucherHash] == true) {\r\n            emit LogError(version, \"WITHDRAWAL_VOUCHER_ALREADY_SUBMITED\");\r\n            return;\r\n        }\r\n\r\n        address _withdrawalSigner;\r\n        uint _withdrawalAmount;\r\n\r\n        (_withdrawalSigner, _withdrawalAmount) = AuctionityLibraryDecodeRawTx.decodeRawTxGetWithdrawalInfo(_signedRawTxWithdrawal, auctionityChainId);\r\n        \r\n        if(_withdrawalAmount == uint256(0)) {\r\n            emit LogError(version,'WITHDRAWAL_VOUCHER_AMOUNT_INVALID');\r\n            return;\r\n        }\r\n\r\n        if(_withdrawalSigner == address(0)) {\r\n            emit LogError(version,'WITHDRAWAL_VOUCHER_SIGNER_INVALID');\r\n            return;\r\n        }\r\n\r\n        // if depot is smaller than amount\r\n        if(depotEth[_withdrawalSigner] < _withdrawalAmount) {\r\n            emit LogError(version,'WITHDRAWAL_VOUCHER_DEPOT_AMOUNT_TOO_LOW');\r\n            return;\r\n        }\r\n\r\n        if(!withdrawalVoucherOracleSignatureVerification(_data, _withdrawalSigner, _withdrawalAmount, _withdrawalVoucherHash)) {\r\n            emit LogError(version,'WITHDRAWAL_VOUCHER_ORACLE_INVALID_SIGNATURE');\r\n            return;\r\n        }\r\n\r\n        // send amount\r\n        if(!_withdrawalSigner.send(_withdrawalAmount)) {\r\n            emit LogError(version, \"WITHDRAWAL_VOUCHER_ETH_TRANSFER_FAILED\");\r\n            return;\r\n        }\r\n\r\n        subDepotEth(_withdrawalSigner,_withdrawalAmount);\r\n\r\n        withdrawalVoucherList.push(_withdrawalVoucherHash);\r\n        withdrawalVoucherSubmitted[_withdrawalVoucherHash] = true;\r\n\r\n        emit LogWithdrawalVoucherSubmitted(_withdrawalSigner,_withdrawalAmount, _withdrawalVoucherHash);\r\n    }\r\n\r\n    function withdrawalVoucherOracleSignatureVerification(\r\n        bytes memory _data,\r\n        address _withdrawalSigner,\r\n        uint256 _withdrawalAmount,\r\n        bytes32 _withdrawalVoucherHash\r\n    ) internal view returns (bool)\r\n    {\r\n\r\n        // if oracle is the signer of this auction end voucher\r\n        return oracle == AuctionityLibraryDecodeRawTx.ecrecoverSigner(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            address(this),\r\n                            _withdrawalSigner,\r\n                            _withdrawalAmount,\r\n                            _withdrawalVoucherHash\r\n                        )\r\n                    )\r\n                )\r\n            ),\r\n            _data,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * auctionEndVoucher\r\n     * @dev Param\r\n     *      bytes _data is a  concatenate of :\r\n     *            bytes64 biddingHashProof\r\n     *            bytes130 rsv ECDSA signature of oracle validation AEV\r\n     *            bytes transfer token\r\n     *      bytes _signedRawTxCreateAuction raw transaction with rsv of bidding transaction on auction smart contract\r\n     *      bytes _signedRawTxBidding raw transaction with rsv of bidding transaction on auction smart contract\r\n     *      bytes _send list of sending eth\r\n     * @dev Log\r\n     *      LogAuctionEndVoucherSubmitted : successful\r\n     */\r\n\r\n    function auctionEndVoucher(\r\n        bytes memory _data,\r\n        bytes memory _signedRawTxCreateAuction,\r\n        bytes memory _signedRawTxBidding,\r\n        bytes memory _send\r\n    ) public maintenanceLockable {\r\n        bytes32 _auctionEndVoucherHash = keccak256(_signedRawTxCreateAuction);\r\n        // if auction end voucher is already submitted\r\n        if(auctionEndVoucherSubmitted[_auctionEndVoucherHash] == true) {\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_ALREADY_SUBMITED\");\r\n            return;\r\n        }\r\n\r\n        InfoFromCreateAuction memory _infoFromCreateAuction = getInfoFromCreateAuction(_signedRawTxCreateAuction);\r\n\r\n        address _auctionContractAddress;\r\n        address _winnerSigner;\r\n        uint256 _winnerAmount;\r\n\r\n        InfoFromBidding memory _infoFromBidding;\r\n\r\n        if(_signedRawTxBidding.length > 1) {\r\n            _infoFromBidding = getInfoFromBidding(_signedRawTxBidding, _infoFromCreateAuction.tokenHash);\r\n\r\n            if(!verifyWinnerDepot(_infoFromBidding)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if(!auctionEndVoucherOracleSignatureVerification(\r\n            _data,\r\n            keccak256(_send),\r\n            _infoFromCreateAuction,\r\n            _infoFromBidding\r\n        )) {\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_ORACLE_INVALID_SIGNATURE\");\r\n            return;\r\n        }\r\n\r\n        if(!AuctionityLibraryDeposit.sendTransfer(_infoFromCreateAuction.tokenContractAddress, _data, 97)){\r\n            if(_data[97] > 0x01) {// if more than 1 transfer function to call\r\n                revert(\"More than one transfer function to call\");\r\n            } else {\r\n                emit LogError(version, \"AUCTION_END_VOUCHER_TRANSFER_FAILED\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        if(_signedRawTxBidding.length > 1) {\r\n            if(!sendExchange(_send, _infoFromCreateAuction, _infoFromBidding)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n\r\n        auctionEndVoucherList.push(_auctionEndVoucherHash);\r\n        auctionEndVoucherSubmitted[_auctionEndVoucherHash] = true;\r\n        emit LogAuctionEndVoucherSubmitted(\r\n            _infoFromBidding.auctionContractAddress,\r\n            _infoFromCreateAuction.tokenContractAddress,\r\n            _infoFromCreateAuction.tokenId,\r\n            _infoFromCreateAuction.auctionSeller,\r\n            _infoFromBidding.signer,\r\n            _infoFromBidding.amount\r\n        );\r\n    }\r\n\r\n    function getInfoFromCreateAuction(bytes _signedRawTxCreateAuction) internal view returns\r\n        (InfoFromCreateAuction memory _infoFromCreateAuction)\r\n    {\r\n        (\r\n            _infoFromCreateAuction.tokenHash,\r\n            ,\r\n            _infoFromCreateAuction.auctionSeller,\r\n            _infoFromCreateAuction.tokenContractAddress,\r\n            _infoFromCreateAuction.tokenId,\r\n            _infoFromCreateAuction.rewardPercent\r\n        ) = AuctionityLibraryDecodeRawTx.decodeRawTxGetCreateAuctionInfo(_signedRawTxCreateAuction,auctionityChainId);\r\n    }\r\n\r\n    function getInfoFromBidding(bytes _signedRawTxBidding, bytes32 _hashSignedRawTxTokenTransfer) internal returns (InfoFromBidding memory _infoFromBidding) {\r\n        bytes32 _hashRawTxTokenTransferFromBid;\r\n\r\n        (\r\n            _hashRawTxTokenTransferFromBid,\r\n            _infoFromBidding.auctionContractAddress,\r\n            _infoFromBidding.amount,\r\n            _infoFromBidding.signer\r\n        ) = AuctionityLibraryDecodeRawTx.decodeRawTxGetBiddingInfo(_signedRawTxBidding,auctionityChainId);\r\n\r\n        if(_hashRawTxTokenTransferFromBid != _hashSignedRawTxTokenTransfer) {\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_hashRawTxTokenTransfer_INVALID\");\r\n            return;\r\n        }\r\n\r\n        if(_infoFromBidding.amount == uint256(0)){\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_BIDDING_AMOUNT_INVALID\");\r\n            return;\r\n        }\r\n\r\n    }    \r\n\r\n    function verifyWinnerDepot(InfoFromBidding memory _infoFromBidding) internal returns(bool) {\r\n        // if depot is smaller than amount\r\n        if(depotEth[_infoFromBidding.signer] < _infoFromBidding.amount) {\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_DEPOT_AMOUNT_TOO_LOW\");\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function sendExchange(\r\n        bytes memory _send,\r\n        InfoFromCreateAuction memory _infoFromCreateAuction,\r\n        InfoFromBidding memory _infoFromBidding\r\n    ) internal returns(bool) {\r\n        if(!subDepotEth(_infoFromBidding.signer, _infoFromBidding.amount)){\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_DEPOT_AMOUNT_TOO_LOW\");\r\n            return false;\r\n        }\r\n\r\n        uint offset;\r\n        address _sendAddress;\r\n        uint256 _sendAmount;\r\n        bytes12 _sendAmountGwei;\r\n        uint256 _sentAmount;\r\n\r\n        assembly {\r\n            _sendAddress := mload(add(_send,add(offset,0x14)))\r\n            _sendAmount := mload(add(_send,add(add(offset,20),0x20)))\r\n        }\r\n\r\n        if(_sendAddress != _infoFromCreateAuction.auctionSeller){\r\n            emit LogError(version, \"AUCTION_END_VOUCHER_SEND_TO_SELLER_INVALID\");\r\n            return false;\r\n        }\r\n\r\n        _sentAmount += _sendAmount;\r\n        offset += 52;\r\n\r\n        if(!_sendAddress.send(_sendAmount)) {\r\n            revert(\"Failed to send funds\");\r\n        }\r\n\r\n        emit LogSentEthToWinner(_infoFromBidding.auctionContractAddress, _sendAddress, _sendAmount);\r\n\r\n        if(_infoFromCreateAuction.rewardPercent > 0) {\r\n            assembly {\r\n                _sendAddress := mload(add(_send,add(offset,0x14)))\r\n                _sendAmount := mload(add(_send,add(add(offset,20),0x20)))\r\n            }\r\n\r\n            _sentAmount += _sendAmount;\r\n            offset += 52;\r\n\r\n            if(!_sendAddress.send(_sendAmount)) {\r\n                revert(\"Failed to send funds\");\r\n            }\r\n\r\n            emit LogSentEthToAuctioneer(_infoFromBidding.auctionContractAddress, _sendAddress, _sendAmount);\r\n\r\n            bytes2 _numberOfSendDepositBytes2;\r\n            assembly {\r\n                _numberOfSendDepositBytes2 := mload(add(_send,add(offset,0x20)))\r\n            }\r\n\r\n            offset += 2;\r\n\r\n            address[] memory _rewardsAddress = new address[](uint16(_numberOfSendDepositBytes2));\r\n            uint256[] memory _rewardsAmount = new uint256[](uint16(_numberOfSendDepositBytes2));\r\n\r\n            for (uint16 i = 0; i < uint16(_numberOfSendDepositBytes2); i++){\r\n\r\n                assembly {\r\n                    _sendAddress := mload(add(_send,add(offset,0x14)))\r\n                    _sendAmountGwei := mload(add(_send,add(add(offset,20),0x20)))\r\n                }\r\n\r\n                _sendAmount = uint96(_sendAmountGwei) * 1000000000;\r\n                _sentAmount += _sendAmount;\r\n                offset += 32;\r\n\r\n                if(!addDepotEth(_sendAddress, _sendAmount)) {\r\n                    revert(\"Can't add deposit\");\r\n                }\r\n\r\n                _rewardsAddress[i] = _sendAddress;\r\n                _rewardsAmount[i] = uint256(_sendAmount);\r\n            }\r\n\r\n            emit LogSentRewardsDepotEth(_rewardsAddress, _rewardsAmount);\r\n        }\r\n\r\n        if(uint256(_infoFromBidding.amount) != _sentAmount) {\r\n            revert(\"Bidding amount is not equal to sent amount\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getTransferDataHash(bytes memory _data) internal returns (bytes32 _transferDataHash){\r\n        bytes memory _transferData = new bytes(_data.length - 97);\r\n\r\n        for (uint i = 0; i < (_data.length - 97); i++) {\r\n            _transferData[i] = _data[i + 97];\r\n        }\r\n        return keccak256(_transferData);\r\n\r\n    }\r\n\r\n    function auctionEndVoucherOracleSignatureVerification(\r\n        bytes memory _data,\r\n        bytes32 _sendDataHash,\r\n        InfoFromCreateAuction memory _infoFromCreateAuction,\r\n        InfoFromBidding memory _infoFromBidding\r\n    ) internal returns (bool) {\r\n        bytes32 _biddingHashProof;\r\n        assembly { _biddingHashProof := mload(add(_data,add(0,0x20))) }\r\n\r\n        bytes32 _transferDataHash = getTransferDataHash(_data);\r\n\r\n        // if oracle is the signer of this auction end voucher\r\n        return oracle == AuctionityLibraryDecodeRawTx.ecrecoverSigner(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            address(this),\r\n                            _infoFromCreateAuction.tokenContractAddress,\r\n                            _infoFromCreateAuction.tokenId,\r\n                            _infoFromCreateAuction.auctionSeller,\r\n                            _infoFromBidding.signer,\r\n                            _infoFromBidding.amount,\r\n                            _biddingHashProof,\r\n                            _infoFromCreateAuction.rewardPercent,\r\n                            _transferDataHash,\r\n                            _sendDataHash\r\n                        )\r\n                    )\r\n                )\r\n            ),\r\n            _data,\r\n            32\r\n        );\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ethereumChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionEndVoucherSubmitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDepotEth\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signedRawTxWithdrawal\",\"type\":\"bytes\"}],\"name\":\"withdrawalVoucher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depotEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maintenanceLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionEndVoucherList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signedRawTxCreateAuction\",\"type\":\"bytes\"},{\"name\":\"_signedRawTxBidding\",\"type\":\"bytes\"},{\"name\":\"_send\",\"type\":\"bytes\"}],\"name\":\"auctionEndVoucher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawalVoucherSubmitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionityChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawalVoucherList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"setMaintenanceLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"setMigrationLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethereumChainId\",\"type\":\"uint8\"},{\"name\":\"_auctionityChainId\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDeposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawalVoucherHash\",\"type\":\"bytes32\"}],\"name\":\"LogWithdrawalVoucherSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auctionContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAuctionEndVoucherSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSentEthToWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSentEthToAuctioneer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSentDepotEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"LogSentRewardsDepotEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"string\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32[]\"}],\"name\":\"LogErrorWithData\",\"type\":\"event\"}]","ContractName":"AuctionityDepositEth","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000003f","Library":"","SwarmSource":"bzzr://e28de8a167f93e67d9a086483d4ae23ee8f634de883d586e7db48b15e4a1cb33"}]}