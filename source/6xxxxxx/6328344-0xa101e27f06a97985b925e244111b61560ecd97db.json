{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title BITTOStandard\r\n * @dev the interface of BITTOStandard\r\n */\r\n \r\ncontract BITTOStandard {\r\n    uint256 public stakeStartTime;\r\n    uint256 public stakeMinAge;\r\n    uint256 public stakeMaxAge;\r\n    function mint() public returns (bool);\r\n    function coinAge() constant public returns (uint256);\r\n    function annualInterest() constant public returns (uint256);\r\n    event Mint(address indexed _address, uint _reward);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\naddress private _owner;\r\n\r\n\r\nevent OwnershipRenounced(address indexed previousOwner);\r\nevent OwnershipTransferred(\r\n  address indexed previousOwner,\r\n  address indexed newOwner\r\n);\r\n\r\n\r\n/**\r\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n  * account.\r\n  */\r\nconstructor() public {\r\n  _owner = msg.sender;\r\n}\r\n\r\n/**\r\n  * @return the address of the owner.\r\n  */\r\nfunction owner() public view returns(address) {\r\n  return _owner;\r\n}\r\n\r\n/**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\nmodifier onlyOwner() {\r\n  require(isOwner());\r\n  _;\r\n}\r\n\r\n/**\r\n  * @return true if `msg.sender` is the owner of the contract.\r\n  */\r\nfunction isOwner() public view returns(bool) {\r\n  return msg.sender == _owner;\r\n}\r\n\r\n/**\r\n  * @dev Allows the current owner to relinquish control of the contract.\r\n  * @notice Renouncing to ownership will leave the contract without an owner.\r\n  * It will not be possible to call the functions with the `onlyOwner`\r\n  * modifier anymore.\r\n  */\r\nfunction renounceOwnership() public onlyOwner {\r\n  emit OwnershipRenounced(_owner);\r\n  _owner = address(0);\r\n}\r\n\r\n/**\r\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\nfunction transferOwnership(address newOwner) public onlyOwner {\r\n  _transferOwnership(newOwner);\r\n}\r\n\r\n/**\r\n  * @dev Transfers control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\nfunction _transferOwnership(address newOwner) internal {\r\n  require(newOwner != address(0));\r\n  emit OwnershipTransferred(_owner, newOwner);\r\n  _owner = newOwner;\r\n}\r\n}\r\n\r\n\r\ncontract BITTO is IERC20, BITTOStandard, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"BITTO\";\r\n    string public symbol = \"BITTO\";\r\n    uint public decimals = 18;\r\n\r\n    uint public chainStartTime; //chain start time\r\n    uint public chainStartBlockNumber; //chain start block number\r\n    uint public stakeStartTime; //stake start time\r\n    uint public stakeMinAge = 10 days; // minimum age for coin age: 10D\r\n    uint public stakeMaxAge = 180 days; // stake age of full weight: 180D\r\n\r\n    uint public totalSupply;\r\n    uint public maxTotalSupply;\r\n    uint public totalInitialSupply;\r\n\r\n    uint constant MIN_STAKING = 5000;  // minium amount of token to stake\r\n    uint constant STAKE_START_TIME = 1537228800;  // 2018.9.18\r\n    uint constant STEP1_ENDTIME = 1552780800;  //  2019.3.17\r\n    uint constant STEP2_ENDTIME = 1568332800;  // 2019.9.13\r\n    uint constant STEP3_ENDTIME = 1583884800;  // 2020.3.11\r\n    uint constant STEP4_ENDTIME = 1599436800; // 2020.9.7\r\n    uint constant STEP5_ENDTIME = 1914969600; // 2030.9.7\r\n\r\n    struct Period {\r\n        uint start;\r\n        uint end;\r\n        uint interest;\r\n    }\r\n\r\n    mapping (uint => Period) periods;\r\n\r\n    mapping(address => bool) public noPOSRewards;\r\n\r\n    struct transferInStruct {\r\n        uint128 amount;\r\n        uint64 time;\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    mapping(address => transferInStruct[]) transferIns;\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Fix for the ERC20 short address attack.\r\n     */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    modifier canPoSMint() {\r\n        require(totalSupply < maxTotalSupply);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        // 5 mil is reserved for POS rewards\r\n        maxTotalSupply = 223 * 10**23; // 22.3 Mil.\r\n        totalInitialSupply = 173 * 10**23; // 17.3 Mil. 10 mil = crowdsale, 7.3 team account\r\n\r\n        chainStartTime = now;\r\n        chainStartBlockNumber = block.number;\r\n\r\n        balances[msg.sender] = totalInitialSupply;\r\n        totalSupply = totalInitialSupply;\r\n\r\n        // 4 periods for 2 years\r\n        stakeStartTime = 1537228800;\r\n        \r\n        periods[0] = Period(STAKE_START_TIME, STEP1_ENDTIME, 65 * 10 ** 18);\r\n        periods[1] = Period(STEP1_ENDTIME, STEP2_ENDTIME, 34 * 10 ** 18);\r\n        periods[2] = Period(STEP2_ENDTIME, STEP3_ENDTIME, 20 * 10 ** 18);\r\n        periods[3] = Period(STEP3_ENDTIME, STEP4_ENDTIME, 134 * 10 ** 16);\r\n        periods[4] = Period(STEP4_ENDTIME, STEP5_ENDTIME, 134 * 10 ** 16);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\r\n        if (msg.sender == _to)\r\n            return mint();\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        if (transferIns[msg.sender].length > 0)\r\n            delete transferIns[msg.sender];\r\n        uint64 _now = uint64(now);\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        if (transferIns[_from].length > 0)\r\n            delete transferIns[_from];\r\n        uint64 _now = uint64(now);\r\n        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));\r\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function mint() canPoSMint public returns (bool) {\r\n        // minimum stake of 5000 x is required to earn staking.\r\n        if (balances[msg.sender] < MIN_STAKING.mul(1 ether))\r\n            return false;\r\n        if (transferIns[msg.sender].length <= 0)\r\n            return false;\r\n\r\n        uint reward = getProofOfStakeReward(msg.sender);\r\n        if (reward <= 0)\r\n            return false;\r\n       \r\n        totalSupply = totalSupply.add(reward);\r\n        balances[msg.sender] = balances[msg.sender].add(reward);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        emit Transfer(address(0), msg.sender, reward);\r\n        emit Mint(msg.sender, reward);\r\n        return true;\r\n    }\r\n\r\n    function getBlockNumber() view public returns (uint blockNumber) {\r\n        blockNumber = block.number.sub(chainStartBlockNumber);\r\n    }\r\n\r\n    function coinAge() constant public returns (uint myCoinAge) {\r\n        uint _now = now;\r\n        myCoinAge = 0;\r\n        for (uint i=0; i < getPeriodNumber(_now) + 1; i ++) {\r\n            myCoinAge += getCoinAgeofPeriod(msg.sender, i, _now);\r\n        }\r\n    }\r\n\r\n    function annualInterest() constant public returns (uint interest) {        \r\n        uint _now = now;\r\n        interest = periods[getPeriodNumber(_now)].interest;\r\n    }\r\n\r\n    function getProofOfStakeReward(address _address) public view returns (uint totalReward) {\r\n        require((now >= stakeStartTime) && (stakeStartTime > 0));\r\n        require(!noPOSRewards[_address]);\r\n\r\n        uint _now = now;\r\n\r\n        totalReward = 0;\r\n        for (uint i=0; i < getPeriodNumber(_now) + 1; i ++) {\r\n            totalReward += (getCoinAgeofPeriod(_address, i, _now)).mul(periods[i].interest).div(100).div(365);\r\n        }\r\n    }\r\n\r\n    function getPeriodNumber(uint _now) public view returns (uint periodNumber) {\r\n        for (uint i = 4; i >= 0; i --) {\r\n            if( _now >= periods[i].start){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCoinAgeofPeriod(address _address, uint _pid, uint _now) public view returns (uint _coinAge) {        \r\n        if (transferIns[_address].length <= 0)\r\n            return 0;\r\n\r\n        if (_pid < 0 || _pid > 4)\r\n            return 0;\r\n\r\n        _coinAge = 0;\r\n        uint nCoinSeconds;\r\n        uint i;\r\n\r\n        if (periods[_pid].start < _now && \r\n            periods[_pid].end >= _now) {\r\n            // calculate the current period\r\n            for (i = 0; i < transferIns[_address].length; i ++) {\r\n                if (uint(periods[_pid].start) > uint(transferIns[_address][i].time) || \r\n                    uint(periods[_pid].end) <= uint(transferIns[_address][i].time))\r\n                    continue;\r\n                \r\n                nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\r\n                \r\n                if (nCoinSeconds < stakeMinAge)\r\n                    continue;\r\n\r\n                if ( nCoinSeconds > stakeMaxAge )\r\n                    nCoinSeconds = stakeMaxAge;    \r\n                \r\n                nCoinSeconds = nCoinSeconds.sub(stakeMinAge);\r\n                _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n            }\r\n\r\n        }else{\r\n            // calculate for the ended preriods which user did not claimed\r\n            for (i = 0; i < transferIns[_address].length; i++) {\r\n                if (uint(periods[_pid].start) > uint(transferIns[_address][i].time) || \r\n                    uint(periods[_pid].end) <= uint(transferIns[_address][i].time))\r\n                    continue;\r\n\r\n                nCoinSeconds = (uint(periods[_pid].end)).sub(uint(transferIns[_address][i].time));\r\n                \r\n                if (nCoinSeconds < stakeMinAge)\r\n                    continue;\r\n\r\n                if ( nCoinSeconds > stakeMaxAge )\r\n                    nCoinSeconds = stakeMaxAge;\r\n\r\n                nCoinSeconds = nCoinSeconds.sub(stakeMinAge);\r\n                _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\r\n            }\r\n        }\r\n\r\n        _coinAge = _coinAge.div(1 ether);\r\n    }\r\n\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Burn(burner, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Burns a specific amount of tokens.\r\n    * @param _value The amount of token to be burned.\r\n    */\r\n    function ownerBurnToken(uint _value) public onlyOwner {\r\n        require(_value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        delete transferIns[msg.sender];\r\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        totalSupply = totalSupply.sub(_value);\r\n        totalInitialSupply = totalInitialSupply.sub(_value);\r\n        maxTotalSupply = maxTotalSupply.sub(_value*10);\r\n\r\n        emit Burn(msg.sender, _value);\r\n    }\r\n\r\n    /* Batch token transfer. Used by contract creator to distribute initial tokens to holders */\r\n    function batchTransfer(address[] _recipients, uint[] _values) onlyOwner public returns (bool) {\r\n        require(_recipients.length > 0 && _recipients.length == _values.length);\r\n\r\n        uint total = 0;\r\n        for (uint i = 0; i < _values.length; i++) {\r\n            total = total.add(_values[i]);\r\n        }\r\n        require(total <= balances[msg.sender]);\r\n\r\n        uint64 _now = uint64(now);\r\n        for (uint j = 0; j < _recipients.length; j++) {\r\n            balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\r\n            transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\r\n            emit Transfer(msg.sender, _recipients[j], _values[j]);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(total);\r\n        if (transferIns[msg.sender].length > 0)\r\n            delete transferIns[msg.sender];\r\n        if (balances[msg.sender] > 0)\r\n            transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\r\n\r\n        return true;\r\n    }\r\n\r\n    function disablePOSReward(address _account, bool _enabled) onlyOwner public {\r\n        noPOSRewards[_account] = _enabled;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"getPeriodNumber\",\"outputs\":[{\"name\":\"periodNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getProofOfStakeReward\",\"outputs\":[{\"name\":\"totalReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"disablePOSReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinAge\",\"outputs\":[{\"name\":\"myCoinAge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chainStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ownerBurnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInitialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"annualInterest\",\"outputs\":[{\"name\":\"interest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_pid\",\"type\":\"uint256\"},{\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"getCoinAgeofPeriod\",\"outputs\":[{\"name\":\"_coinAge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"noPOSRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeMinAge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chainStartBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeMaxAge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BITTO","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://175caa9b4dcdd1e86d6089741e743863d918a67c8e40d8af4001ead8c8d35a57"}]}