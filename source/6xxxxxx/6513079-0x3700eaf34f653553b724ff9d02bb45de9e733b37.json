{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Smart contract - piggy bank.\r\n * Contributions are not limited.\r\n * If you withdraw your deposit quickly, you lose a commission of 10%\r\n * If you keep a deposit for a long time - you will receive income from the increase of the value of the token.\r\n * Tokens are fully compatible with the ERC20 standard.\r\n */ \r\n \r\n \r\n\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0,\"Math error\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a,\"Math error\");\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0,\"Math error\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implementation of the basic standard token.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal balances_;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed_;\r\n\r\n    uint256 private totalSupply_;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances_[_owner];\r\n    }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n      public\r\n      view\r\n      returns (uint256)\r\n    {\r\n        return allowed_[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances_[msg.sender],\"Invalid value\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[msg.sender] = balances_[msg.sender].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed_[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        require(_value <= balances_[_from],\"Value is more than balance\");\r\n        require(_value <= allowed_[_from][msg.sender],\"Value is more than alloved\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[_from] = balances_[_from].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        allowed_[msg.sender][_spender] = (allowed_[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        uint256 oldValue = allowed_[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed_[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param _account The account that will receive the created tokens.\r\n    * @param _amount The amount that will be created.\r\n    */\r\n    function _mint(address _account, uint256 _amount) internal returns (bool) {\r\n        require(_account != 0,\"Invalid address\");\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances_[_account] = balances_[_account].add(_amount);\r\n        emit Transfer(address(0), _account, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account.\r\n    * @param _account The account whose tokens will be burnt.\r\n    * @param _amount The amount that will be burnt.\r\n    */\r\n    function _burn(address _account, uint256 _amount) internal returns (bool) {\r\n        require(_account != 0,\"Invalid address\");\r\n        require(_amount <= balances_[_account],\"Amount is more than balance\");\r\n\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n        balances_[_account] = balances_[_account].sub(_amount);\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Contract Piggytoken\r\n * @dev ERC20 compatible token contract\r\n */\r\ncontract PiggyToken is ERC20 {\r\n    string public constant name = \"PiggyBank Token\";\r\n    string public constant symbol = \"Piggy\";\r\n    uint32 public constant decimals = 18;\r\n    uint256 public INITIAL_SUPPLY = 0; // no tokens on start\r\n    address public piggyBankAddress;\r\n    \r\n\r\n\r\n    constructor(address _piggyBankAddress) public {\r\n        piggyBankAddress = _piggyBankAddress;\r\n    }\r\n\r\n\r\n    modifier onlyPiggyBank() {\r\n        require(msg.sender == piggyBankAddress,\"Only PiggyBank contract can run this\");\r\n        _;\r\n    }\r\n    \r\n    modifier validDestination( address to ) {\r\n        require(to != address(0x0),\"Empty address\");\r\n        require(to != address(this),\"PiggyBank Token address\");\r\n        _;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transfer(address _to, uint256 _value) public validDestination(_to) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public validDestination(_to) returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Override for running only from PiggyBank contract\r\n     */\r\n    function mint(address _to, uint256 _value) public onlyPiggyBank returns (bool) {\r\n        return super._mint(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for running only from PiggyBank contract\r\n     */\r\n    function burn(address _to, uint256 _value) public onlyPiggyBank returns (bool) {\r\n        return super._burn(_to, _value);\r\n    }\r\n\r\n    function() external payable {\r\n        revert(\"The token contract don`t receive ether\");\r\n    }  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PiggyBank\r\n * @dev PiggyBank is a base contract for managing a token buying and selling\r\n */\r\ncontract PiggyBank {\r\n    using SafeMath for uint256;\r\n    address public owner;\r\n    address creator;\r\n\r\n\r\n\r\n    address myAddress = this;\r\n    PiggyToken public token = new PiggyToken(myAddress);\r\n\r\n\r\n    // How many token units a buyer gets per wei.\r\n    uint256 public rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 public weiRaised;\r\n\r\n    event Invest(\r\n        address indexed investor, \r\n        uint256 tokens,\r\n        uint256 weiAmount,\r\n        uint256 rate\r\n    );\r\n\r\n    event Withdraw(\r\n        address indexed to, \r\n        uint256 tokens,\r\n        uint256 weiAmount,\r\n        uint256 rate\r\n    );\r\n\r\n    event TokenPrice(\r\n        uint256 value\r\n    );\r\n\r\n    constructor() public {\r\n        owner = 0x0;\r\n        creator = msg.sender;\r\n        rate = 1 ether;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // External interface\r\n    // -----------------------------------------\r\n\r\n    /**\r\n    * @dev fallback function\r\n    */\r\n    function () external payable {\r\n        if (msg.value > 0) {\r\n            _buyTokens(msg.sender);\r\n        } else {\r\n            require(msg.data.length == 0,\"Only for simple payments\");\r\n            _takeProfit(msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev low level token purchase ***DO NOT OVERRIDE***\r\n    * @param _beneficiary Address performing the token purchase\r\n    */\r\n    function _buyTokens(address _beneficiary) internal {\r\n        uint256 weiAmount = msg.value.mul(9).div(10);\r\n        uint256 creatorBonus = msg.value.div(100);\r\n        require(_beneficiary != address(0),\"Invalid address\");\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n        uint256 creatorTokens = _getTokenAmount(creatorBonus);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        //rate = myAddress.balance.div(weiRaised);\r\n\r\n        _processPurchase(_beneficiary, tokens);\r\n        _processPurchase(creator, creatorTokens);\r\n        \r\n        emit Invest(_beneficiary, tokens, msg.value, rate);\r\n\r\n    }\r\n\r\n\r\n    // -----------------------------------------\r\n    // Internal interface (extensible)\r\n    // -----------------------------------------\r\n\r\n    function _takeProfit(address _beneficiary) internal {\r\n        uint256 tokens = token.balanceOf(_beneficiary);\r\n        uint256 weiAmount = tokens.mul(rate).div(1 ether);\r\n        token.burn(_beneficiary, tokens);\r\n        _beneficiary.transfer(weiAmount);\r\n        _updatePrice();\r\n        \r\n        emit Withdraw(_beneficiary, tokens, weiAmount, rate);\r\n    }\r\n\r\n\r\n    function _updatePrice() internal {\r\n        uint256 oldPrice = rate;\r\n        if (token.totalSupply()>0){\r\n            rate = myAddress.balance.mul(1 ether).div(token.totalSupply());\r\n            if (rate != oldPrice){\r\n                emit TokenPrice(rate);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev internal function\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _tokenAmount Number of tokens to be emitted\r\n    */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        token.mint(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _tokenAmount Number of tokens to be purchased\r\n    */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev this function is ether converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        uint256 resultAmount = _weiAmount;\r\n        return resultAmount.mul(1 ether).div(rate);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenPrice\",\"type\":\"event\"}]","ContractName":"PiggyBank","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e9682aa6760cdac57ff860d117d810af1cd8dcff736b346933ebcb0db6746038"}]}