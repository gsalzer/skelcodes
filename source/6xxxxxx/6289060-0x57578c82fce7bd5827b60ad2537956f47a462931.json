{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\ninterface ERC777i {\r\n  function operatorSend(address from, address to, uint256 amount, bytes userData, bytes operatorData) public;\r\n}\r\n\r\ncontract Spacedrop {\r\n  using SafeERC20 for ERC20;\r\n\r\n  mapping (bytes32 => bool) used;\r\n  event Sent(address indexed token, address indexed sender, address indexed recipient, uint256 tokensToTransfer, uint256 nonce, uint256 iface);\r\n\r\n  function validateAndRegisterClaim(address sender, bytes32 h, uint8 v, bytes32 r, bytes32 s) internal {\r\n    // signer must be sender\r\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    address signer = ecrecover(keccak256(prefix, h), v, r, s);\r\n    require(signer == sender && signer != address(0));\r\n\r\n    // check this claim hasn't been recorded already, then record it\r\n    require(!used[h]);\r\n    used[h] = true;\r\n  }\r\n\r\n  function claimTokensERC20(address token, address sender, address recipient, uint256 tokensToTransfer, uint256 nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n    bytes32 h = keccak256(token, sender, recipient, tokensToTransfer, nonce);\r\n    validateAndRegisterClaim(sender, h, v, r, s);\r\n    ERC20(token).safeTransferFrom(sender, recipient, tokensToTransfer);\r\n    Sent(token, sender, recipient, tokensToTransfer, nonce, 20);\r\n  }\r\n\r\n  function claimTokensERC777(address token, address sender, address recipient, uint256 tokensToTransfer, uint256 nonce, bytes userData, uint8 v, bytes32 r, bytes32 s) public {\r\n    bytes32 h = keccak256(token, sender, recipient, tokensToTransfer, nonce, userData);\r\n    validateAndRegisterClaim(sender, h, v, r, s);\r\n    ERC777i(token).operatorSend(sender, recipient, tokensToTransfer, userData, \"spacedrop\");\r\n    Sent(token, sender, recipient, tokensToTransfer, nonce, 777);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"tokensToTransfer\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"userData\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claimTokensERC777\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"tokensToTransfer\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claimTokensERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensToTransfer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iface\",\"type\":\"uint256\"}],\"name\":\"Sent\",\"type\":\"event\"}]","ContractName":"Spacedrop","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://848d68225bfdfee5fba4580b29e239050c0ff5b071b5b0a0f5bb9b7446b41905"}]}