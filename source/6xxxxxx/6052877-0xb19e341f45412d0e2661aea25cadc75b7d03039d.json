{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract IERC20 is ERC20 {\r\n\r\n    function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool);\r\n\r\n    function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Interface for the ST20 token standard\r\n */\r\ncontract IST20 is StandardToken, DetailedERC20 {\r\n\r\n    // off-chain hash\r\n    string public tokenDetails;\r\n\r\n    //transfer, transferFrom must respect use respect the result of verifyTransfer\r\n    function verifyTransfer(address _from, address _to, uint256 _amount) public returns (bool success);\r\n\r\n    /**\r\n     * @notice mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     */\r\n    function mint(address _investor, uint256 _amount) public returns (bool success);\r\n\r\n    /**\r\n     * @notice Burn function used to burn the securityToken\r\n     * @param _value No. of token that get burned\r\n     */\r\n    function burn(uint256 _value) public;\r\n\r\n    event Minted(address indexed to, uint256 amount);\r\n    event Burnt(address indexed _burner, uint256 _value);\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ncontract ISecurityToken is IST20, Ownable {\r\n\r\n    uint8 public constant PERMISSIONMANAGER_KEY = 1;\r\n    uint8 public constant TRANSFERMANAGER_KEY = 2;\r\n    uint8 public constant STO_KEY = 3;\r\n    uint8 public constant CHECKPOINT_KEY = 4;\r\n    uint256 public granularity;\r\n\r\n    // Value of current checkpoint\r\n    uint256 public currentCheckpointId;\r\n\r\n    // Total number of non-zero token holders\r\n    uint256 public investorCount;\r\n\r\n    // List of token holders\r\n    address[] public investors;\r\n\r\n    // Permissions this to a Permission module, which has a key of 1\r\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\r\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool);\r\n\r\n    /**\r\n     * @notice returns module list for a module type\r\n     * @param _moduleType is which type of module we are trying to remove\r\n     * @param _moduleIndex is the index of the module within the chosen type\r\n     */\r\n    function getModule(uint8 _moduleType, uint _moduleIndex) public view returns (bytes32, address);\r\n\r\n    /**\r\n     * @notice returns module list for a module name - will return first match\r\n     * @param _moduleType is which type of module we are trying to remove\r\n     * @param _name is the name of the module within the chosen type\r\n     */\r\n    function getModuleByName(uint8 _moduleType, bytes32 _name) public view returns (bytes32, address);\r\n\r\n    /**\r\n     * @notice Queries totalSupply as of a defined checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) public view returns(uint256);\r\n\r\n    /**\r\n     * @notice Queries balances as of a defined checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() public returns(uint256);\r\n\r\n    /**\r\n     * @notice gets length of investors array\r\n     * NB - this length may differ from investorCount if list has not been pruned of zero balance investors\r\n     * @return length\r\n     */\r\n    function getInvestorsLength() public view returns(uint256);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that any module factory contract should implement\r\n */\r\ncontract IModuleFactory is Ownable {\r\n\r\n    ERC20 public polyToken;\r\n    uint256 public setupCost;\r\n    uint256 public usageCost;\r\n    uint256 public monthlySubscriptionCost;\r\n\r\n    event LogChangeFactorySetupFee(uint256 _oldSetupcost, uint256 _newSetupCost, address _moduleFactory);\r\n    event LogChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\r\n    event LogChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\r\n    event LogGenerateModuleFromFactory(address _module, bytes32 indexed _moduleName, address indexed _moduleFactory, address _creator, uint256 _timestamp);\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {\r\n      polyToken = ERC20(_polyAddress);\r\n      setupCost = _setupCost;\r\n      usageCost = _usageCost;\r\n      monthlySubscriptionCost = _subscriptionCost;\r\n    }\r\n\r\n    //Should create an instance of the Module, or throw\r\n    function deploy(bytes _data) external returns(address);\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getType() public view returns(uint8);\r\n\r\n    /**\r\n     * @notice Get the name of the Module\r\n     */\r\n    function getName() public view returns(bytes32);\r\n\r\n    /**\r\n     * @notice Get the description of the Module\r\n     */\r\n    function getDescription() public view returns(string);\r\n\r\n    /**\r\n     * @notice Get the title of the Module\r\n     */\r\n    function getTitle() public view returns(string);\r\n\r\n    /**\r\n     * @notice Get the Instructions that helped to used the module\r\n     */\r\n    function getInstructions() public view returns (string);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() public view returns (bytes32[]);\r\n\r\n    //Pull function sig from _data\r\n    function getSig(bytes _data) internal pure returns (bytes4 sig) {\r\n        uint len = _data.length < 4 ? _data.length : 4;\r\n        for (uint i = 0; i < len; i++) {\r\n            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice used to change the fee of the setup cost\r\n     * @param _newSetupCost new setup cost\r\n     */\r\n    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {\r\n        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\r\n        setupCost = _newSetupCost;\r\n    }\r\n\r\n    /**\r\n     * @notice used to change the fee of the usage cost\r\n     * @param _newUsageCost new usage cost\r\n     */\r\n    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {\r\n        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\r\n        usageCost = _newUsageCost;\r\n    }\r\n\r\n    /**\r\n     * @notice used to change the fee of the subscription cost\r\n     * @param _newSubscriptionCost new subscription cost\r\n     */\r\n    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {\r\n        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\r\n        monthlySubscriptionCost = _newSubscriptionCost;\r\n        \r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that any module contract should implement\r\n */\r\ncontract IModule {\r\n\r\n    address public factory;\r\n\r\n    address public securityToken;\r\n\r\n    bytes32 public constant FEE_ADMIN = \"FEE_ADMIN\";\r\n\r\n    ERC20 public polyToken;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public {\r\n        securityToken = _securityToken;\r\n        factory = msg.sender;\r\n        polyToken = ERC20(_polyAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() public pure returns (bytes4);\r\n\r\n    //Allows owner, factory or permissioned delegate\r\n    modifier withPerm(bytes32 _perm) {\r\n        bool isOwner = msg.sender == ISecurityToken(securityToken).owner();\r\n        bool isFactory = msg.sender == factory;\r\n        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), \"Permission check failed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == ISecurityToken(securityToken).owner(), \"Sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory {\r\n        require(msg.sender == factory, \"Sender is not factory\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOwner {\r\n        require(msg.sender == IModuleFactory(factory).owner(), \"Sender is not factory owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the permissions flag that are associated with Module\r\n     */\r\n    function getPermissions() public view returns(bytes32[]);\r\n\r\n    /**\r\n     * @notice used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {\r\n        require(polyToken.transferFrom(address(this), IModuleFactory(factory).owner(), _amount), \"Unable to take fee\");\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface for the polymath module registry contract\r\n */\r\ncontract IModuleRegistry {\r\n\r\n    /**\r\n     * @notice Called by a security token to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     */\r\n    function useModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by moduleFactory owner to register new modules for SecurityToken to use\r\n     * @param _moduleFactory is the address of the module factory to be registered\r\n     */\r\n    function registerModule(address _moduleFactory) external returns(bool);\r\n\r\n    /**\r\n     * @notice Use to get all the tags releated to the functionality of the Module Factory.\r\n     * @param _moduleType Type of module\r\n     */\r\n    function getTagByModuleType(uint8 _moduleType) public view returns(bytes32[]);\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract to allow pausing and unpausing of certain functions\r\n */\r\ncontract Pausable {\r\n\r\n    event Pause(uint256 _timestammp);\r\n    event Unpause(uint256 _timestamp);\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n   /**\r\n    * @notice called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal {\r\n        require(!paused);\r\n        paused = true;\r\n        emit Pause(now);\r\n    }\r\n\r\n    /**\r\n    * @notice called by the owner to unpause, returns to normal state\r\n    */\r\n    function _unpause() internal {\r\n        require(paused);\r\n        paused = false;\r\n        emit Unpause(now);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all Transfer Manager modules\r\n */\r\ncontract ITransferManager is IModule, Pausable {\r\n\r\n    //If verifyTransfer returns:\r\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\r\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\r\n    //  VALID, then the transfer is valid for this TM\r\n    //  NA, then the result from this TM is ignored\r\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\r\n\r\n    function verifyTransfer(address _from, address _to, uint256 _amount, bool _isTransfer) public returns(Result);\r\n\r\n    function unpause() onlyOwner public {\r\n        super._unpause();\r\n    }\r\n\r\n    function pause() onlyOwner public {\r\n        super._pause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all permission manager modules\r\n */\r\ncontract IPermissionManager is IModule {\r\n\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool);\r\n\r\n    function changePermission(address _delegate, address _module, bytes32 _perm, bool _valid) public returns(bool);\r\n\r\n    function getDelegateDetails(address _delegate) public view returns(bytes32);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for the token burner contract\r\n */\r\ninterface ITokenBurner {\r\n\r\n    function burn(address _burner, uint256  _value ) external returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\r\n */\r\ncontract ReclaimTokens is Ownable {\r\n\r\n    /**\r\n    * @notice Reclaim all ERC20Basic compatible tokens\r\n    * @param _tokenContract The address of the token contract\r\n    */\r\n    function reclaimERC20(address _tokenContract) external onlyOwner {\r\n        require(_tokenContract != address(0));\r\n        ERC20Basic token = ERC20Basic(_tokenContract);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(owner, balance));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Core functionality for registry upgradability\r\n */\r\ncontract PolymathRegistry is ReclaimTokens {\r\n\r\n    mapping (bytes32 => address) public storedAddresses;\r\n\r\n    event LogChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\r\n\r\n    /**\r\n     * @notice Get the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @return address\r\n     */\r\n    function getAddress(string _nameKey) view public returns(address) {\r\n        bytes32 key = keccak256(bytes(_nameKey));\r\n        require(storedAddresses[key] != address(0), \"Invalid address key\");\r\n        return storedAddresses[key];\r\n    }\r\n\r\n    /**\r\n     * @notice change the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @param _newAddress is the new contract address\r\n     */\r\n    function changeAddress(string _nameKey, address _newAddress) public onlyOwner {\r\n        bytes32 key = keccak256(bytes(_nameKey));\r\n        emit LogChangeAddress(_nameKey, storedAddresses[key], _newAddress);\r\n        storedAddresses[key] = _newAddress;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract RegistryUpdater is Ownable {\r\n\r\n    address public polymathRegistry;\r\n    address public moduleRegistry;\r\n    address public securityTokenRegistry;\r\n    address public tickerRegistry;\r\n    address public polyToken;\r\n\r\n    constructor (address _polymathRegistry) public {\r\n        require(_polymathRegistry != address(0));\r\n        polymathRegistry = _polymathRegistry;\r\n    }\r\n\r\n    function updateFromRegistry() onlyOwner public {\r\n        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress(\"ModuleRegistry\");\r\n        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress(\"SecurityTokenRegistry\");\r\n        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress(\"TickerRegistry\");\r\n        polyToken = PolymathRegistry(polymathRegistry).getAddress(\"PolyToken\");\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @title Security Token contract\r\n* @notice SecurityToken is an ERC20 token with added capabilities:\r\n* @notice - Implements the ST-20 Interface\r\n* @notice - Transfers are restricted\r\n* @notice - Modules can be attached to it to control its behaviour\r\n* @notice - ST should not be deployed directly, but rather the SecurityTokenRegistry should be used\r\n*/\r\ncontract SecurityToken is ISecurityToken, ReentrancyGuard, RegistryUpdater {\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 public constant securityTokenVersion = \"0.0.1\";\r\n\r\n    // Reference to token burner contract\r\n    ITokenBurner public tokenBurner;\r\n\r\n    // Use to halt all the transactions\r\n    bool public freeze = false;\r\n\r\n    struct ModuleData {\r\n        bytes32 name;\r\n        address moduleAddress;\r\n    }\r\n\r\n    // Structures to maintain checkpoints of balances for governance / dividends\r\n    struct Checkpoint {\r\n        uint256 checkpointId;\r\n        uint256 value;\r\n    }\r\n\r\n    mapping (address => Checkpoint[]) public checkpointBalances;\r\n    Checkpoint[] public checkpointTotalSupply;\r\n\r\n    bool public finishedIssuerMinting = false;\r\n    bool public finishedSTOMinting = false;\r\n\r\n    mapping (bytes4 => bool) transferFunctions;\r\n\r\n    // Module list should be order agnostic!\r\n    mapping (uint8 => ModuleData[]) public modules;\r\n\r\n    uint8 public constant MAX_MODULES = 20;\r\n\r\n    mapping (address => bool) public investorListed;\r\n\r\n    // Emit at the time when module get added\r\n    event LogModuleAdded(\r\n        uint8 indexed _type,\r\n        bytes32 _name,\r\n        address _moduleFactory,\r\n        address _module,\r\n        uint256 _moduleCost,\r\n        uint256 _budget,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    // Emit when the token details get updated\r\n    event LogUpdateTokenDetails(string _oldDetails, string _newDetails);\r\n    // Emit when the granularity get changed\r\n    event LogGranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\r\n    // Emit when Module get removed from the securityToken\r\n    event LogModuleRemoved(uint8 indexed _type, address _module, uint256 _timestamp);\r\n    // Emit when the budget allocated to a module is changed\r\n    event LogModuleBudgetChanged(uint8 indexed _moduleType, address _module, uint256 _budget);\r\n    // Emit when all the transfers get freeze\r\n    event LogFreezeTransfers(bool _freeze, uint256 _timestamp);\r\n    // Emit when new checkpoint created\r\n    event LogCheckpointCreated(uint256 indexed _checkpointId, uint256 _timestamp);\r\n    // Emit when the minting get finished for the Issuer\r\n    event LogFinishMintingIssuer(uint256 _timestamp);\r\n    // Emit when the minting get finished for the STOs\r\n    event LogFinishMintingSTO(uint256 _timestamp);\r\n    // Change the STR address in the event of a upgrade\r\n    event LogChangeSTRAddress(address indexed _oldAddress, address indexed _newAddress);\r\n\r\n    // If _fallback is true, then for STO module type we only allow the module if it is set, if it is not set we only allow the owner\r\n    // for other _moduleType we allow both issuer and module.\r\n    modifier onlyModule(uint8 _moduleType, bool _fallback) {\r\n      //Loop over all modules of type _moduleType\r\n        bool isModuleType = false;\r\n        for (uint8 i = 0; i < modules[_moduleType].length; i++) {\r\n            isModuleType = isModuleType || (modules[_moduleType][i].moduleAddress == msg.sender);\r\n        }\r\n        if (_fallback && !isModuleType) {\r\n            if (_moduleType == STO_KEY)\r\n                require(modules[_moduleType].length == 0 && msg.sender == owner, \"Sender is not owner or STO module is attached\");\r\n            else\r\n                require(msg.sender == owner, \"Sender is not owner\");\r\n        } else {\r\n            require(isModuleType, \"Sender is not correct module type\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier checkGranularity(uint256 _amount) {\r\n        require(_amount % granularity == 0, \"Unable to modify token balances at this granularity\");\r\n        _;\r\n    }\r\n\r\n    // Checks whether the minting is allowed or not, check for the owner if owner is no the msg.sender then check\r\n    // for the finishedSTOMinting flag because only STOs and owner are allowed for minting\r\n    modifier isMintingAllowed() {\r\n        if (msg.sender == owner) {\r\n            require(!finishedIssuerMinting, \"Minting is finished for Issuer\");\r\n        } else {\r\n            require(!finishedSTOMinting, \"Minting is finished for STOs\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _name Name of the SecurityToken\r\n     * @param _symbol Symbol of the Token\r\n     * @param _decimals Decimals for the securityToken\r\n     * @param _granularity granular level of the token\r\n     * @param _tokenDetails Details of the token that are stored off-chain (IPFS hash)\r\n     * @param _polymathRegistry Contract address of the polymath registry\r\n     */\r\n    constructor (\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        uint256 _granularity,\r\n        string _tokenDetails,\r\n        address _polymathRegistry\r\n    )\r\n    public\r\n    DetailedERC20(_name, _symbol, _decimals)\r\n    RegistryUpdater(_polymathRegistry)\r\n    {\r\n        //When it is created, the owner is the STR\r\n        updateFromRegistry();\r\n        tokenDetails = _tokenDetails;\r\n        granularity = _granularity;\r\n        transferFunctions[bytes4(keccak256(\"transfer(address,uint256)\"))] = true;\r\n        transferFunctions[bytes4(keccak256(\"transferFrom(address,address,uint256)\"))] = true;\r\n        transferFunctions[bytes4(keccak256(\"mint(address,uint256)\"))] = true;\r\n        transferFunctions[bytes4(keccak256(\"burn(uint256)\"))] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Function used to attach the module in security token\r\n     * @param _moduleFactory Contract address of the module factory that needs to be attached\r\n     * @param _data Data used for the intialization of the module factory variables\r\n     * @param _maxCost Maximum cost of the Module factory\r\n     * @param _budget Budget of the Module factory\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external onlyOwner nonReentrant {\r\n        _addModule(_moduleFactory, _data, _maxCost, _budget);\r\n    }\r\n\r\n    /**\r\n    * @notice _addModule handles the attachment (or replacement) of modules for the ST\r\n    * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n    * @dev to control restrictions on transfers.\r\n    * @dev You are allowed to add a new moduleType if:\r\n    * @dev - there is no existing module of that type yet added\r\n    * @dev - the last member of the module list is replacable\r\n    * @param _moduleFactory is the address of the module factory to be added\r\n    * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n    * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n    */\r\n    function _addModule(address _moduleFactory, bytes _data, uint256 _maxCost, uint256 _budget) internal {\r\n        //Check that module exists in registry - will throw otherwise\r\n        IModuleRegistry(moduleRegistry).useModule(_moduleFactory);\r\n        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\r\n        uint8 moduleType = moduleFactory.getType();\r\n        require(modules[moduleType].length < MAX_MODULES, \"Limit of MAX MODULES is reached\");\r\n        uint256 moduleCost = moduleFactory.setupCost();\r\n        require(moduleCost <= _maxCost, \"Max Cost is always be greater than module cost\");\r\n        //Approve fee for module\r\n        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), \"Not able to approve the module cost\");\r\n        //Creates instance of module from factory\r\n        address module = moduleFactory.deploy(_data);\r\n        //Approve ongoing budget\r\n        require(ERC20(polyToken).approve(module, _budget), \"Not able to approve the budget\");\r\n        //Add to SecurityToken module map\r\n        bytes32 moduleName = moduleFactory.getName();\r\n        modules[moduleType].push(ModuleData(moduleName, module));\r\n        //Emit log event\r\n        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, now);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _moduleType is which type of module we are trying to remove\r\n    * @param _moduleIndex is the index of the module within the chosen type\r\n    */\r\n    function removeModule(uint8 _moduleType, uint8 _moduleIndex) external onlyOwner {\r\n        require(_moduleIndex < modules[_moduleType].length,\r\n        \"Module index doesn't exist as per the choosen module type\");\r\n        require(modules[_moduleType][_moduleIndex].moduleAddress != address(0),\r\n        \"Module contract address should not be 0x\");\r\n        //Take the last member of the list, and replace _moduleIndex with this, then shorten the list by one\r\n        emit LogModuleRemoved(_moduleType, modules[_moduleType][_moduleIndex].moduleAddress, now);\r\n        modules[_moduleType][_moduleIndex] = modules[_moduleType][modules[_moduleType].length - 1];\r\n        modules[_moduleType].length = modules[_moduleType].length - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _moduleType is which type of module we are trying to get\r\n     * @param _moduleIndex is the index of the module within the chosen type\r\n     * @return bytes32\r\n     * @return address\r\n     */\r\n    function getModule(uint8 _moduleType, uint _moduleIndex) public view returns (bytes32, address) {\r\n        if (modules[_moduleType].length > 0) {\r\n            return (\r\n                modules[_moduleType][_moduleIndex].name,\r\n                modules[_moduleType][_moduleIndex].moduleAddress\r\n            );\r\n        } else {\r\n            return (\"\", address(0));\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice returns module list for a module name - will return first match\r\n     * @param _moduleType is which type of module we are trying to get\r\n     * @param _name is the name of the module within the chosen type\r\n     * @return bytes32\r\n     * @return address\r\n     */\r\n    function getModuleByName(uint8 _moduleType, bytes32 _name) public view returns (bytes32, address) {\r\n        if (modules[_moduleType].length > 0) {\r\n            for (uint256 i = 0; i < modules[_moduleType].length; i++) {\r\n                if (modules[_moduleType][i].name == _name) {\r\n                  return (\r\n                      modules[_moduleType][i].name,\r\n                      modules[_moduleType][i].moduleAddress\r\n                  );\r\n                }\r\n            }\r\n            return (\"\", address(0));\r\n        } else {\r\n            return (\"\", address(0));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice allows the owner to withdraw unspent POLY stored by them on the ST.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _amount amount of POLY to withdraw\r\n    */\r\n    function withdrawPoly(uint256 _amount) public onlyOwner {\r\n        require(ERC20(polyToken).transfer(owner, _amount), \"In-sufficient balance\");\r\n    }\r\n\r\n    /**\r\n    * @notice allows owner to approve more POLY to one of the modules\r\n    * @param _moduleType module type\r\n    * @param _moduleIndex module index\r\n    * @param _budget new budget\r\n    */\r\n    function changeModuleBudget(uint8 _moduleType, uint8 _moduleIndex, uint256 _budget) public onlyOwner {\r\n        require(_moduleType != 0, \"Module type cannot be zero\");\r\n        require(_moduleIndex < modules[_moduleType].length, \"Incorrrect module index\");\r\n        uint256 _currentAllowance = IERC20(polyToken).allowance(address(this), modules[_moduleType][_moduleIndex].moduleAddress);\r\n        if (_budget < _currentAllowance) {\r\n            require(IERC20(polyToken).decreaseApproval(modules[_moduleType][_moduleIndex].moduleAddress, _currentAllowance.sub(_budget)), \"Insufficient balance to decreaseApproval\");\r\n        } else {\r\n            require(IERC20(polyToken).increaseApproval(modules[_moduleType][_moduleIndex].moduleAddress, _budget.sub(_currentAllowance)), \"Insufficient balance to increaseApproval\");\r\n        }\r\n        emit LogModuleBudgetChanged(_moduleType, modules[_moduleType][_moduleIndex].moduleAddress, _budget);\r\n    }\r\n\r\n    /**\r\n     * @notice change the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) public onlyOwner {\r\n        emit LogUpdateTokenDetails(tokenDetails, _newTokenDetails);\r\n        tokenDetails = _newTokenDetails;\r\n    }\r\n\r\n    /**\r\n    * @notice allows owner to change token granularity\r\n    * @param _granularity granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) public onlyOwner {\r\n        require(_granularity != 0, \"Granularity can not be 0\");\r\n        emit LogGranularityChanged(granularity, _granularity);\r\n        granularity = _granularity;\r\n    }\r\n\r\n    /**\r\n    * @notice keeps track of the number of non-zero token holders\r\n    * @param _from sender of transfer\r\n    * @param _to receiver of transfer\r\n    * @param _value value of transfer\r\n    */\r\n    function adjustInvestorCount(address _from, address _to, uint256 _value) internal {\r\n        if ((_value == 0) || (_from == _to)) {\r\n            return;\r\n        }\r\n        // Check whether receiver is a new token holder\r\n        if ((balanceOf(_to) == 0) && (_to != address(0))) {\r\n            investorCount = investorCount.add(1);\r\n        }\r\n        // Check whether sender is moving all of their tokens\r\n        if (_value == balanceOf(_from)) {\r\n            investorCount = investorCount.sub(1);\r\n        }\r\n        //Also adjust investor list\r\n        if (!investorListed[_to] && (_to != address(0))) {\r\n            investors.push(_to);\r\n            investorListed[_to] = true;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice removes addresses with zero balances from the investors list\r\n    * @param _start Index in investor list at which to start removing zero balances\r\n    * @param _iters Max number of iterations of the for loop\r\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\r\n    */\r\n    function pruneInvestors(uint256 _start, uint256 _iters) public onlyOwner {\r\n        for (uint256 i = _start; i < Math.min256(_start.add(_iters), investors.length); i++) {\r\n            if ((i < investors.length) && (balanceOf(investors[i]) == 0)) {\r\n                investorListed[investors[i]] = false;\r\n                investors[i] = investors[investors.length - 1];\r\n                investors.length--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice gets length of investors array\r\n     * NB - this length may differ from investorCount if list has not been pruned of zero balance investors\r\n     * @return length\r\n     */\r\n    function getInvestorsLength() public view returns(uint256) {\r\n        return investors.length;\r\n    }\r\n\r\n    /**\r\n     * @notice freeze all the transfers\r\n     */\r\n    function freezeTransfers() public onlyOwner {\r\n        require(!freeze);\r\n        freeze = true;\r\n        emit LogFreezeTransfers(freeze, now);\r\n    }\r\n\r\n    /**\r\n     * @notice un-freeze all the transfers\r\n     */\r\n    function unfreezeTransfers() public onlyOwner {\r\n        require(freeze);\r\n        freeze = false;\r\n        emit LogFreezeTransfers(freeze, now);\r\n    }\r\n\r\n    /**\r\n     * @notice adjust totalsupply at checkpoint after minting or burning tokens\r\n     */\r\n    function adjustTotalSupplyCheckpoints() internal {\r\n        adjustCheckpoints(checkpointTotalSupply, totalSupply());\r\n    }\r\n\r\n    /**\r\n     * @notice adjust token holder balance at checkpoint after a token transfer\r\n     * @param _investor address of the token holder affected\r\n     */\r\n    function adjustBalanceCheckpoints(address _investor) internal {\r\n        adjustCheckpoints(checkpointBalances[_investor], balanceOf(_investor));\r\n    }\r\n\r\n    /**\r\n     * @notice store the changes to the checkpoint objects\r\n     * @param _checkpoints the affected checkpoint object array\r\n     * @param _newValue the new value that needs to be stored\r\n     */\r\n    function adjustCheckpoints(Checkpoint[] storage _checkpoints, uint256 _newValue) internal {\r\n        //No checkpoints set yet\r\n        if (currentCheckpointId == 0) {\r\n            return;\r\n        }\r\n        //No previous checkpoint data - add current balance against checkpoint\r\n        if (_checkpoints.length == 0) {\r\n            _checkpoints.push(\r\n                Checkpoint({\r\n                    checkpointId: currentCheckpointId,\r\n                    value: _newValue\r\n                })\r\n            );\r\n            return;\r\n        }\r\n        //No new checkpoints since last update\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId == currentCheckpointId) {\r\n            return;\r\n        }\r\n        //New checkpoint, so record balance\r\n        _checkpoints.push(\r\n            Checkpoint({\r\n                checkpointId: currentCheckpointId,\r\n                value: _newValue\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded version of the transfer function\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @return bool success\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        adjustInvestorCount(msg.sender, _to, _value);\r\n        require(verifyTransfer(msg.sender, _to, _value), \"Transfer is not valid\");\r\n        adjustBalanceCheckpoints(msg.sender);\r\n        adjustBalanceCheckpoints(_to);\r\n        require(super.transfer(_to, _value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded version of the transferFrom function\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _value value of transfer\r\n     * @return bool success\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        adjustInvestorCount(_from, _to, _value);\r\n        require(verifyTransfer(_from, _to, _value), \"Transfer is not valid\");\r\n        adjustBalanceCheckpoints(_from);\r\n        adjustBalanceCheckpoints(_to);\r\n        require(super.transferFrom(_from, _to, _value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice validate transfer with TransferManager module if it exists\r\n     * @dev TransferManager module has a key of 2\r\n     * @param _from sender of transfer\r\n     * @param _to receiver of transfer\r\n     * @param _amount value of transfer\r\n     * @return bool\r\n     */\r\n    function verifyTransfer(address _from, address _to, uint256 _amount) public checkGranularity(_amount) returns (bool) {\r\n        if (!freeze) {\r\n            bool isTransfer = false;\r\n            if (transferFunctions[getSig(msg.data)]) {\r\n              isTransfer = true;\r\n            }\r\n            if (modules[TRANSFERMANAGER_KEY].length == 0) {\r\n                return true;\r\n            }\r\n            bool isInvalid = false;\r\n            bool isValid = false;\r\n            bool isForceValid = false;\r\n            for (uint8 i = 0; i < modules[TRANSFERMANAGER_KEY].length; i++) {\r\n                ITransferManager.Result valid = ITransferManager(modules[TRANSFERMANAGER_KEY][i].moduleAddress).verifyTransfer(_from, _to, _amount, isTransfer);\r\n                if (valid == ITransferManager.Result.INVALID) {\r\n                    isInvalid = true;\r\n                }\r\n                if (valid == ITransferManager.Result.VALID) {\r\n                    isValid = true;\r\n                }\r\n                if (valid == ITransferManager.Result.FORCE_VALID) {\r\n                    isForceValid = true;\r\n                }\r\n            }\r\n            return isForceValid ? true : (isInvalid ? false : isValid);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * @notice End token minting period permanently for Issuer\r\n     */\r\n    function finishMintingIssuer() public onlyOwner {\r\n        finishedIssuerMinting = true;\r\n        emit LogFinishMintingIssuer(now);\r\n    }\r\n\r\n    /**\r\n     * @notice End token minting period permanently for STOs\r\n     */\r\n    function finishMintingSTO() public onlyOwner {\r\n        finishedSTOMinting = true;\r\n        emit LogFinishMintingSTO(now);\r\n    }\r\n\r\n    /**\r\n     * @notice mints new tokens and assigns them to the target _investor.\r\n     * @dev Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address to whom the minted tokens will be dilivered\r\n     * @param _amount Number of tokens get minted\r\n     * @return success\r\n     */\r\n    function mint(address _investor, uint256 _amount) public onlyModule(STO_KEY, true) checkGranularity(_amount) isMintingAllowed() returns (bool success) {\r\n        require(_investor != address(0), \"Investor address should not be 0x\");\r\n        adjustInvestorCount(address(0), _investor, _amount);\r\n        require(verifyTransfer(address(0), _investor, _amount), \"Transfer is not valid\");\r\n        adjustBalanceCheckpoints(_investor);\r\n        adjustTotalSupplyCheckpoints();\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_investor] = balances[_investor].add(_amount);\r\n        emit Minted(_investor, _amount);\r\n        emit Transfer(address(0), _investor, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investors A list of addresses to whom the minted tokens will be dilivered\r\n     * @param _amounts A list of number of tokens get minted and transfer to corresponding address of the investor from _investor[] list\r\n     * @return success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _amounts) public onlyModule(STO_KEY, true) returns (bool success) {\r\n        require(_investors.length == _amounts.length, \"Mis-match in the length of the arrays\");\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            mint(_investors[i], _amounts[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool) {\r\n        if (modules[PERMISSIONMANAGER_KEY].length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (uint8 i = 0; i < modules[PERMISSIONMANAGER_KEY].length; i++) {\r\n            if (IPermissionManager(modules[PERMISSIONMANAGER_KEY][i].moduleAddress).checkPermission(_delegate, _module, _perm)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice used to set the token Burner address. It only be called by the owner\r\n     * @param _tokenBurner Address of the token burner contract\r\n     */\r\n    function setTokenBurner(address _tokenBurner) public onlyOwner {\r\n        tokenBurner = ITokenBurner(_tokenBurner);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn function used to burn the securityToken\r\n     * @param _value No. of token that get burned\r\n     */\r\n    function burn(uint256 _value) checkGranularity(_value) public {\r\n        adjustInvestorCount(msg.sender, address(0), _value);\r\n        require(tokenBurner != address(0), \"Token Burner contract address is not set yet\");\r\n        require(verifyTransfer(msg.sender, address(0), _value), \"Transfer is not valid\");\r\n        require(_value <= balances[msg.sender], \"Value should no be greater than the balance of msg.sender\");\r\n        adjustBalanceCheckpoints(msg.sender);\r\n        adjustTotalSupplyCheckpoints();\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        require(tokenBurner.burn(msg.sender, _value), \"Token burner process is not validated\");\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burnt(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Get function signature from _data\r\n     * @param _data passed data\r\n     * @return bytes4 sig\r\n     */\r\n    function getSig(bytes _data) internal pure returns (bytes4 sig) {\r\n        uint len = _data.length < 4 ? _data.length : 4;\r\n        for (uint i = 0; i < len; i++) {\r\n            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     * @return uint256\r\n     */\r\n    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns(uint256) {\r\n        require(currentCheckpointId < 2**256 - 1);\r\n        currentCheckpointId = currentCheckpointId + 1;\r\n        emit LogCheckpointCreated(currentCheckpointId, now);\r\n        return currentCheckpointId;\r\n    }\r\n\r\n    /**\r\n     * @notice Queries totalSupply as of a defined checkpoint\r\n     * @param _checkpointId Checkpoint ID to query\r\n     * @return uint256\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) public view returns(uint256) {\r\n        return getValueAt(checkpointTotalSupply, _checkpointId, totalSupply());\r\n    }\r\n\r\n    /**\r\n     * @notice Queries value at a defined checkpoint\r\n     * @param checkpoints is array of Checkpoint objects\r\n     * @param _checkpointId Checkpoint ID to query\r\n     * @param _currentValue Current value of checkpoint\r\n     * @return uint256\r\n     */\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint256 _checkpointId, uint256 _currentValue) internal view returns(uint256) {\r\n        require(_checkpointId <= currentCheckpointId);\r\n        //Checkpoint id 0 is when the token is first created - everyone has a zero balance\r\n        if (_checkpointId == 0) {\r\n          return 0;\r\n        }\r\n        if (checkpoints.length == 0) {\r\n            return _currentValue;\r\n        }\r\n        if (checkpoints[0].checkpointId >= _checkpointId) {\r\n            return checkpoints[0].value;\r\n        }\r\n        if (checkpoints[checkpoints.length - 1].checkpointId < _checkpointId) {\r\n            return _currentValue;\r\n        }\r\n        if (checkpoints[checkpoints.length - 1].checkpointId == _checkpointId) {\r\n            return checkpoints[checkpoints.length - 1].value;\r\n        }\r\n        uint256 min = 0;\r\n        uint256 max = checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint256 mid = (max + min) / 2;\r\n            if (checkpoints[mid].checkpointId == _checkpointId) {\r\n                max = mid;\r\n                break;\r\n            }\r\n            if (checkpoints[mid].checkpointId < _checkpointId) {\r\n                min = mid + 1;\r\n            } else {\r\n                max = mid;\r\n            }\r\n        }\r\n        return checkpoints[max].value;\r\n    }\r\n\r\n    /**\r\n     * @notice Queries balances as of a defined checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256) {\r\n        return getValueAt(checkpointBalances[_investor], _checkpointId, balanceOf(_investor));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for the polymath ticker registry contract\r\n */\r\ncontract ITickerRegistry {\r\n    /**\r\n    * @notice Check the validity of the symbol\r\n    * @param _symbol token symbol\r\n    * @param _owner address of the owner\r\n    * @param _tokenName Name of the token\r\n    * @return bool\r\n    */\r\n    function checkValidity(string _symbol, address _owner, string _tokenName) public returns(bool);\r\n\r\n    /**\r\n    * @notice Returns the owner and timestamp for a given symbol\r\n    * @param _symbol symbol\r\n    */\r\n    function getDetails(string _symbol) public view returns (address, uint256, string, bytes32, bool);\r\n\r\n    /**\r\n     * @notice Check the symbol is reserved or not\r\n     * @param _symbol Symbol of the token\r\n     * @return bool\r\n     */\r\n     function isReserved(string _symbol, address _owner, string _tokenName, bytes32 _swarmHash) public returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for security token proxy deployment\r\n */\r\ncontract ISTProxy {\r\n\r\n    /**\r\n     * @notice deploys the token and adds default modules like permission manager and transfer manager.\r\n     * Future versions of the proxy can attach different modules or pass some other paramters.\r\n     */\r\n    function deployToken(string _name, string _symbol, uint8 _decimals, string _tokenDetails, address _issuer, bool _divisible, address _polymathRegistry)\r\n        public returns (address);\r\n}\r\n\r\n/**\r\n * @title Interface for the polymath security token registry contract\r\n */\r\ncontract ISecurityTokenRegistry {\r\n\r\n    bytes32 public protocolVersion = \"0.0.1\";\r\n    mapping (bytes32 => address) public protocolVersionST;\r\n\r\n    struct SecurityTokenData {\r\n        string symbol;\r\n        string tokenDetails;\r\n    }\r\n\r\n    mapping(address => SecurityTokenData) securityTokens;\r\n    mapping(string => address) symbols;\r\n\r\n    /**\r\n     * @notice Creates a new Security Token and saves it to the registry\r\n     * @param _name Name of the token\r\n     * @param _symbol Ticker symbol of the security token\r\n     * @param _tokenDetails off-chain details of the token\r\n     */\r\n    function generateSecurityToken(string _name, string _symbol, string _tokenDetails, bool _divisible) public;\r\n\r\n    function setProtocolVersion(address _stVersionProxyAddress, bytes32 _version) public;\r\n\r\n    /**\r\n     * @notice Get security token address by ticker name\r\n     * @param _symbol Symbol of the Scurity token\r\n     * @return address _symbol\r\n     */\r\n    function getSecurityTokenAddress(string _symbol) public view returns (address);\r\n\r\n     /**\r\n     * @notice Get security token data by its address\r\n     * @param _securityToken Address of the Scurity token\r\n     * @return string, address, bytes32\r\n     */\r\n    function getSecurityTokenData(address _securityToken) public view returns (string, address, string);\r\n\r\n    /**\r\n    * @notice Check that Security Token is registered\r\n    * @param _securityToken Address of the Scurity token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) public view returns (bool);\r\n}\r\n\r\n/**\r\n * @title Utility contract for reusable code\r\n */\r\ncontract Util {\r\n\r\n   /**\r\n    * @notice changes a string to upper case\r\n    * @param _base string to change\r\n    */\r\n    function upper(string _base) internal pure returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            bytes1 b1 = _baseBytes[i];\r\n            if (b1 >= 0x61 && b1 <= 0x7A) {\r\n                b1 = bytes1(uint8(b1)-32);\r\n            }\r\n            _baseBytes[i] = b1;\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Registry contract for issuers to register their security tokens\r\n */\r\ncontract SecurityTokenRegistry is ISecurityTokenRegistry, Util, Pausable, RegistryUpdater, ReclaimTokens {\r\n\r\n    // Registration fee in POLY base 18 decimals\r\n    uint256 public registrationFee;\r\n    // Emit when changePolyRegisterationFee is called\r\n    event LogChangePolyRegisterationFee(uint256 _oldFee, uint256 _newFee);\r\n\r\n    // Emit at the time of launching of new security token\r\n    event LogNewSecurityToken(string _ticker, address indexed _securityTokenAddress, address indexed _owner);\r\n    event LogAddCustomSecurityToken(string _name, string _symbol, address _securityToken, uint256 _addedAt);\r\n\r\n    constructor (\r\n        address _polymathRegistry,\r\n        address _stVersionProxy,\r\n        uint256 _registrationFee\r\n    )\r\n    public\r\n    RegistryUpdater(_polymathRegistry)\r\n    {\r\n        registrationFee = _registrationFee;\r\n        // By default, the STR version is set to 0.0.1\r\n        setProtocolVersion(_stVersionProxy, \"0.0.1\");\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new Security Token and saves it to the registry\r\n     * @param _name Name of the token\r\n     * @param _symbol Ticker symbol of the security token\r\n     * @param _tokenDetails off-chain details of the token\r\n     * @param _divisible Set to true if token is divisible\r\n     */\r\n    function generateSecurityToken(string _name, string _symbol, string _tokenDetails, bool _divisible) public whenNotPaused {\r\n        require(bytes(_name).length > 0 && bytes(_symbol).length > 0, \"Name and Symbol string length should be greater than 0\");\r\n        require(ITickerRegistry(tickerRegistry).checkValidity(_symbol, msg.sender, _name), \"Trying to use non-valid symbol\");\r\n        if(registrationFee > 0)\r\n            require(ERC20(polyToken).transferFrom(msg.sender, this, registrationFee), \"Failed transferFrom because of sufficent Allowance is not provided\");\r\n        string memory symbol = upper(_symbol);\r\n        address newSecurityTokenAddress = ISTProxy(protocolVersionST[protocolVersion]).deployToken(\r\n            _name,\r\n            symbol,\r\n            18,\r\n            _tokenDetails,\r\n            msg.sender,\r\n            _divisible,\r\n            polymathRegistry\r\n        );\r\n\r\n        securityTokens[newSecurityTokenAddress] = SecurityTokenData(symbol, _tokenDetails);\r\n        symbols[symbol] = newSecurityTokenAddress;\r\n        emit LogNewSecurityToken(symbol, newSecurityTokenAddress, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new custom (Token should follow the ISecurityToken interface) Security Token and saves it to the registry\r\n     * @param _name Name of the token\r\n     * @param _symbol Ticker symbol of the security token\r\n     * @param _owner Owner of the token\r\n     * @param _securityToken Address of the securityToken\r\n     * @param _tokenDetails off-chain details of the token\r\n     * @param _swarmHash off-chain details about the issuer company\r\n     */\r\n    function addCustomSecurityToken(string _name, string _symbol, address _owner, address _securityToken, string _tokenDetails, bytes32 _swarmHash) public onlyOwner whenNotPaused {\r\n        require(bytes(_name).length > 0 && bytes(_symbol).length > 0, \"Name and Symbol string length should be greater than 0\");\r\n        string memory symbol = upper(_symbol);\r\n        require(_securityToken != address(0) && symbols[symbol] == address(0), \"Symbol is already at the polymath network or entered security token address is 0x\");\r\n        require(_owner != address(0));\r\n        require(!(ITickerRegistry(tickerRegistry).isReserved(symbol, _owner, _name, _swarmHash)), \"Trying to use non-valid symbol\");\r\n        symbols[symbol] = _securityToken;\r\n        securityTokens[_securityToken] = SecurityTokenData(symbol, _tokenDetails);\r\n        emit LogAddCustomSecurityToken(_name, symbol, _securityToken, now);\r\n    }\r\n\r\n    /**\r\n    * @notice Changes the protocol version and the SecurityToken contract\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    */\r\n    function setProtocolVersion(address _stVersionProxyAddress, bytes32 _version) public onlyOwner {\r\n        protocolVersion = _version;\r\n        protocolVersionST[_version] = _stVersionProxyAddress;\r\n    }\r\n\r\n    //////////////////////////////\r\n    ///////// Get Functions\r\n    //////////////////////////////\r\n    /**\r\n     * @notice Get security token address by ticker name\r\n     * @param _symbol Symbol of the Scurity token\r\n     * @return address\r\n     */\r\n    function getSecurityTokenAddress(string _symbol) public view returns (address) {\r\n        string memory __symbol = upper(_symbol);\r\n        return symbols[__symbol];\r\n    }\r\n\r\n     /**\r\n     * @notice Get security token data by its address\r\n     * @param _securityToken Address of the Scurity token\r\n     * @return string\r\n     * @return address\r\n     * @return string\r\n     */\r\n    function getSecurityTokenData(address _securityToken) public view returns (string, address, string) {\r\n        return (\r\n            securityTokens[_securityToken].symbol,\r\n            ISecurityToken(_securityToken).owner(),\r\n            securityTokens[_securityToken].tokenDetails\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Check that Security Token is registered\r\n    * @param _securityToken Address of the Scurity token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) public view returns (bool) {\r\n        return (keccak256(bytes(securityTokens[_securityToken].symbol)) != keccak256(\"\"));\r\n    }\r\n\r\n    /**\r\n     * @notice set the ticker registration fee in POLY tokens\r\n     * @param _registrationFee registration fee in POLY tokens (base 18 decimals)\r\n     */\r\n    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {\r\n        require(registrationFee != _registrationFee);\r\n        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);\r\n        registrationFee = _registrationFee;\r\n    }\r\n\r\n     /**\r\n     * @notice pause registration function\r\n     */\r\n    function unpause() public onlyOwner  {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @notice unpause registration function\r\n     */\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Proxy for deploying Security Token v1\r\n */\r\ncontract STVersionProxy001 is ISTProxy {\r\n\r\n    address public transferManagerFactory;\r\n\r\n    // Should be set to false when we have more TransferManager options\r\n    bool addTransferManager = true;\r\n\r\n    constructor (address _transferManagerFactory) public {\r\n        transferManagerFactory = _transferManagerFactory;\r\n    }\r\n\r\n    /**\r\n     * @notice deploys the token and adds default modules like permission manager and transfer manager.\r\n     * Future versions of the proxy can attach different modules or pass some other paramters.\r\n     */\r\n    function deployToken(string _name, string _symbol, uint8 _decimals, string _tokenDetails, address _issuer, bool _divisible, address _polymathRegistry)\r\n    public returns (address) {\r\n        address newSecurityTokenAddress = new SecurityToken(\r\n        _name,\r\n        _symbol,\r\n        _decimals,\r\n        _divisible ? 1 : uint256(10)**_decimals,\r\n        _tokenDetails,\r\n        _polymathRegistry\r\n        );\r\n\r\n        if (addTransferManager) {\r\n            SecurityToken(newSecurityTokenAddress).addModule(transferManagerFactory, \"\", 0, 0);\r\n        }\r\n\r\n        SecurityToken(newSecurityTokenAddress).transferOwnership(_issuer);\r\n\r\n        return newSecurityTokenAddress;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"transferManagerFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_issuer\",\"type\":\"address\"},{\"name\":\"_divisible\",\"type\":\"bool\"},{\"name\":\"_polymathRegistry\",\"type\":\"address\"}],\"name\":\"deployToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_transferManagerFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"STVersionProxy001","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000075dace99cf7876f9c56cb25e0fd52c5b3680b7ff","Library":"","SwarmSource":"bzzr://2d535a7c2bc8218d97b9656ef7475d3969b67473218d327fd560a8db945893be"}]}