{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/VoteProxyFactory.sol\r\npragma solidity ^0.4.24;\r\n\r\n////// lib/ds-token/lib/ds-stop/lib/ds-auth/src/auth.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/ds-chief/lib/ds-roles/src/roles.sol\r\n// roles.sol - roled based authentication\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\n/* import 'ds-auth/auth.sol'; */\r\n\r\ncontract DSRoles is DSAuth, DSAuthority\r\n{\r\n    mapping(address=>bool) _root_users;\r\n    mapping(address=>bytes32) _user_roles;\r\n    mapping(address=>mapping(bytes4=>bytes32)) _capability_roles;\r\n    mapping(address=>mapping(bytes4=>bool)) _public_capabilities;\r\n\r\n    function getUserRoles(address who)\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _user_roles[who];\r\n    }\r\n\r\n    function getCapabilityRoles(address code, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _capability_roles[code][sig];\r\n    }\r\n\r\n    function isUserRoot(address who)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _root_users[who];\r\n    }\r\n\r\n    function isCapabilityPublic(address code, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _public_capabilities[code][sig];\r\n    }\r\n\r\n    function hasUserRole(address who, uint8 role)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 roles = getUserRoles(who);\r\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\r\n        return bytes32(0) != roles & shifted;\r\n    }\r\n\r\n    function canCall(address caller, address code, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if( isUserRoot(caller) || isCapabilityPublic(code, sig) ) {\r\n            return true;\r\n        } else {\r\n            bytes32 has_roles = getUserRoles(caller);\r\n            bytes32 needs_one_of = getCapabilityRoles(code, sig);\r\n            return bytes32(0) != has_roles & needs_one_of;\r\n        }\r\n    }\r\n\r\n    function BITNOT(bytes32 input) internal pure returns (bytes32 output) {\r\n        return (input ^ bytes32(uint(-1)));\r\n    }\r\n\r\n    function setRootUser(address who, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        _root_users[who] = enabled;\r\n    }\r\n\r\n    function setUserRole(address who, uint8 role, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        bytes32 last_roles = _user_roles[who];\r\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\r\n        if( enabled ) {\r\n            _user_roles[who] = last_roles | shifted;\r\n        } else {\r\n            _user_roles[who] = last_roles & BITNOT(shifted);\r\n        }\r\n    }\r\n\r\n    function setPublicCapability(address code, bytes4 sig, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        _public_capabilities[code][sig] = enabled;\r\n    }\r\n\r\n    function setRoleCapability(uint8 role, address code, bytes4 sig, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        bytes32 last_roles = _capability_roles[code][sig];\r\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\r\n        if( enabled ) {\r\n            _capability_roles[code][sig] = last_roles | shifted;\r\n        } else {\r\n            _capability_roles[code][sig] = last_roles & BITNOT(shifted);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n////// lib/ds-token/lib/ds-math/src/math.sol\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/ds-token/lib/ds-stop/lib/ds-note/src/note.sol\r\n/// note.sol -- the `note' modifier, for logging calls as events\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n////// lib/ds-chief/lib/ds-thing/src/thing.sol\r\n// thing.sol - `auth` with handy mixins. your things should be DSThings\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\n/* import 'ds-auth/auth.sol'; */\r\n/* import 'ds-note/note.sol'; */\r\n/* import 'ds-math/math.sol'; */\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(abi.encodePacked(s)));\r\n    }\r\n\r\n}\r\n\r\n////// lib/ds-token/lib/ds-stop/src/stop.sol\r\n/// stop.sol -- mixin for enable/disable functionality\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\n/* import \"ds-auth/auth.sol\"; */\r\n/* import \"ds-note/note.sol\"; */\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n////// lib/ds-token/lib/erc20/src/erc20.sol\r\n/// erc20.sol -- API for the ERC20 token standard\r\n\r\n// See <https://github.com/ethereum/EIPs/issues/20>.\r\n\r\n// This file likely does not meet the threshold of originality\r\n// required for copyright to apply.  As a result, this is free and\r\n// unencumbered software belonging to the public domain.\r\n\r\n/* pragma solidity ^0.4.8; */\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}\r\n\r\n////// lib/ds-token/src/base.sol\r\n/// base.sol -- basic ERC20 implementation\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\n/* import \"erc20/erc20.sol\"; */\r\n/* import \"ds-math/math.sol\"; */\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    constructor(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n////// lib/ds-token/src/token.sol\r\n/// token.sol -- ERC20 implementation with minting and burning\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\n/* import \"ds-stop/stop.sol\"; */\r\n\r\n/* import \"./base.sol\"; */\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    bytes32  public  symbol;\r\n    uint256  public  decimals = 18; // standard token precision. override to customize\r\n\r\n    constructor(bytes32 symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n\r\n    // Optional token name\r\n    bytes32   public  name = \"\";\r\n\r\n    function setName(bytes32 name_) public auth {\r\n        name = name_;\r\n    }\r\n}\r\n\r\n////// lib/ds-chief/src/chief.sol\r\n// chief.sol - select an authority by consensus\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.23; */\r\n\r\n/* import 'ds-token/token.sol'; */\r\n/* import 'ds-roles/roles.sol'; */\r\n/* import 'ds-thing/thing.sol'; */\r\n\r\n// The right way to use this contract is probably to mix it with some kind\r\n// of `DSAuthority`, like with `ds-roles`.\r\n//   SEE DSChief\r\ncontract DSChiefApprovals is DSThing {\r\n    mapping(bytes32=>address[]) public slates;\r\n    mapping(address=>bytes32) public votes;\r\n    mapping(address=>uint256) public approvals;\r\n    mapping(address=>uint256) public deposits;\r\n    DSToken public GOV; // voting token that gets locked up\r\n    DSToken public IOU; // non-voting representation of a token, for e.g. secondary voting mechanisms\r\n    address public hat; // the chieftain's hat\r\n\r\n    uint256 public MAX_YAYS;\r\n\r\n    event Etch(bytes32 indexed slate);\r\n\r\n    // IOU constructed outside this contract reduces deployment costs significantly\r\n    // lock/free/vote are quite sensitive to token invariants. Caution is advised.\r\n    constructor(DSToken GOV_, DSToken IOU_, uint MAX_YAYS_) public\r\n    {\r\n        GOV = GOV_;\r\n        IOU = IOU_;\r\n        MAX_YAYS = MAX_YAYS_;\r\n    }\r\n\r\n    function lock(uint wad)\r\n        public\r\n        note\r\n    {\r\n        GOV.pull(msg.sender, wad);\r\n        IOU.mint(msg.sender, wad);\r\n        deposits[msg.sender] = add(deposits[msg.sender], wad);\r\n        addWeight(wad, votes[msg.sender]);\r\n    }\r\n\r\n    function free(uint wad)\r\n        public\r\n        note\r\n    {\r\n        deposits[msg.sender] = sub(deposits[msg.sender], wad);\r\n        subWeight(wad, votes[msg.sender]);\r\n        IOU.burn(msg.sender, wad);\r\n        GOV.push(msg.sender, wad);\r\n    }\r\n\r\n    function etch(address[] yays)\r\n        public\r\n        note\r\n        returns (bytes32 slate)\r\n    {\r\n        require( yays.length <= MAX_YAYS );\r\n        requireByteOrderedSet(yays);\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(yays));\r\n        slates[hash] = yays;\r\n        emit Etch(hash);\r\n        return hash;\r\n    }\r\n\r\n    function vote(address[] yays) public returns (bytes32)\r\n        // note  both sub-calls note\r\n    {\r\n        bytes32 slate = etch(yays);\r\n        vote(slate);\r\n        return slate;\r\n    }\r\n\r\n    function vote(bytes32 slate)\r\n        public\r\n        note\r\n    {\r\n        uint weight = deposits[msg.sender];\r\n        subWeight(weight, votes[msg.sender]);\r\n        votes[msg.sender] = slate;\r\n        addWeight(weight, votes[msg.sender]);\r\n    }\r\n\r\n    // like `drop`/`swap` except simply \"elect this address if it is higher than current hat\"\r\n    function lift(address whom)\r\n        public\r\n        note\r\n    {\r\n        require(approvals[whom] > approvals[hat]);\r\n        hat = whom;\r\n    }\r\n\r\n    function addWeight(uint weight, bytes32 slate)\r\n        internal\r\n    {\r\n        address[] storage yays = slates[slate];\r\n        for( uint i = 0; i < yays.length; i++) {\r\n            approvals[yays[i]] = add(approvals[yays[i]], weight);\r\n        }\r\n    }\r\n\r\n    function subWeight(uint weight, bytes32 slate)\r\n        internal\r\n    {\r\n        address[] storage yays = slates[slate];\r\n        for( uint i = 0; i < yays.length; i++) {\r\n            approvals[yays[i]] = sub(approvals[yays[i]], weight);\r\n        }\r\n    }\r\n\r\n    // Throws unless the array of addresses is a ordered set.\r\n    function requireByteOrderedSet(address[] yays)\r\n        internal\r\n        pure\r\n    {\r\n        if( yays.length == 0 || yays.length == 1 ) {\r\n            return;\r\n        }\r\n        for( uint i = 0; i < yays.length - 1; i++ ) {\r\n            // strict inequality ensures both ordering and uniqueness\r\n            require(uint(bytes32(yays[i])) < uint256(bytes32(yays[i+1])));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// `hat` address is unique root user (has every role) and the\r\n// unique owner of role 0 (typically 'sys' or 'internal')\r\ncontract DSChief is DSRoles, DSChiefApprovals {\r\n\r\n    constructor(DSToken GOV, DSToken IOU, uint MAX_YAYS)\r\n             DSChiefApprovals (GOV, IOU, MAX_YAYS)\r\n        public\r\n    {\r\n        authority = this;\r\n        owner = 0;\r\n    }\r\n\r\n    function setOwner(address owner_) public {\r\n        owner_;\r\n        revert();\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public {\r\n        authority_;\r\n        revert();\r\n    }\r\n\r\n    function isUserRoot(address who)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return (who == hat);\r\n    }\r\n    function setRootUser(address who, bool enabled) public {\r\n        who; enabled;\r\n        revert();\r\n    }\r\n}\r\n\r\ncontract DSChiefFab {\r\n    function newChief(DSToken gov, uint MAX_YAYS) public returns (DSChief chief) {\r\n        DSToken iou = new DSToken('IOU');\r\n        chief = new DSChief(gov, iou, MAX_YAYS);\r\n        iou.setOwner(chief);\r\n    }\r\n}\r\n\r\n////// src/VoteProxy.sol\r\n// VoteProxy - vote w/ a hot or cold wallet using a proxy identity\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import \"ds-token/token.sol\"; */\r\n/* import \"ds-chief/chief.sol\"; */\r\n\r\ncontract VoteProxy {\r\n    address public cold;\r\n    address public hot;\r\n    DSToken public gov;\r\n    DSToken public iou;\r\n    DSChief public chief;\r\n\r\n    constructor(DSChief _chief, address _cold, address _hot) public {\r\n        chief = _chief;\r\n        cold = _cold;\r\n        hot = _hot;\r\n        \r\n        gov = chief.GOV();\r\n        iou = chief.IOU();\r\n        gov.approve(chief, uint256(-1));\r\n        iou.approve(chief, uint256(-1));\r\n    }\r\n\r\n    modifier auth() {\r\n        require(msg.sender == hot || msg.sender == cold, \"Sender must be a Cold or Hot Wallet\");\r\n        _;\r\n    }\r\n    \r\n    function lock(uint256 wad) public auth {\r\n        gov.pull(cold, wad);   // mkr from cold\r\n        chief.lock(wad);       // mkr out, ious in\r\n    }\r\n\r\n    function free(uint256 wad) public auth {\r\n        chief.free(wad);       // ious out, mkr in\r\n        gov.push(cold, wad);   // mkr to cold\r\n    }\r\n\r\n    function freeAll() public auth {\r\n        chief.free(chief.deposits(this));            \r\n        gov.push(cold, gov.balanceOf(this)); \r\n    }\r\n\r\n    function vote(address[] yays) public auth returns (bytes32) {\r\n        return chief.vote(yays);\r\n    }\r\n\r\n    function vote(bytes32 slate) public auth {\r\n        chief.vote(slate);\r\n    }\r\n}\r\n\r\n////// src/VoteProxyFactory.sol\r\n// VoteProxyFactory - create and keep record of proxy identities\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import \"./VoteProxy.sol\"; */\r\n\r\ncontract VoteProxyFactory {\r\n    DSChief public chief;\r\n    mapping(address => VoteProxy) public hotMap;\r\n    mapping(address => VoteProxy) public coldMap;\r\n    mapping(address => address) public linkRequests;\r\n\r\n    event LinkRequested(address indexed cold, address indexed hot);\r\n    event LinkConfirmed(address indexed cold, address indexed hot, address indexed voteProxy);\r\n    \r\n    constructor(DSChief chief_) public { chief = chief_; }\r\n\r\n    function hasProxy(address guy) public view returns (bool) {\r\n        return (coldMap[guy] != address(0) || hotMap[guy] != address(0));\r\n    }\r\n\r\n    function initiateLink(address hot) public {\r\n        require(!hasProxy(msg.sender), \"Cold wallet is already linked to another Vote Proxy\");\r\n        require(!hasProxy(hot), \"Hot wallet is already linked to another Vote Proxy\");\r\n\r\n        linkRequests[msg.sender] = hot;\r\n        emit LinkRequested(msg.sender, hot);\r\n    }\r\n\r\n    function approveLink(address cold) public returns (VoteProxy voteProxy) {\r\n        require(linkRequests[cold] == msg.sender, \"Cold wallet must initiate a link first\");\r\n        require(!hasProxy(msg.sender), \"Hot wallet is already linked to another Vote Proxy\");\r\n\r\n        voteProxy = new VoteProxy(chief, cold, msg.sender);\r\n        hotMap[msg.sender] = voteProxy;\r\n        coldMap[cold] = voteProxy;\r\n        delete linkRequests[cold];\r\n        emit LinkConfirmed(cold, msg.sender, voteProxy);\r\n    }\r\n\r\n    function breakLink() public {\r\n        require(hasProxy(msg.sender), \"No VoteProxy found for this sender\");\r\n\r\n        VoteProxy voteProxy = coldMap[msg.sender] != address(0)\r\n            ? coldMap[msg.sender] : hotMap[msg.sender];\r\n        address cold = voteProxy.cold();\r\n        address hot = voteProxy.hot();\r\n        require(chief.IOU().balanceOf(voteProxy) == 0, \"VoteProxy still has funds attached to it\");\r\n\r\n        delete coldMap[cold];\r\n        delete hotMap[hot];\r\n    }\r\n\r\n    function linkSelf() public returns (VoteProxy voteProxy) {\r\n        initiateLink(msg.sender);\r\n        return approveLink(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"linkSelf\",\"outputs\":[{\"name\":\"voteProxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hot\",\"type\":\"address\"}],\"name\":\"initiateLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"hasProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hotMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"linkRequests\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"breakLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"coldMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cold\",\"type\":\"address\"}],\"name\":\"approveLink\",\"outputs\":[{\"name\":\"voteProxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chief\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"chief_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cold\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"hot\",\"type\":\"address\"}],\"name\":\"LinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cold\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"hot\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"voteProxy\",\"type\":\"address\"}],\"name\":\"LinkConfirmed\",\"type\":\"event\"}]","ContractName":"VoteProxyFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008e2a84d6ade1e7fffee039a35ef5f19f13057152","Library":"","SwarmSource":"bzzr://5eabd8f47fec7ec820d9f12f834c7db513ca9a1cb0a2d0cf099385b7d176fe5d"}]}