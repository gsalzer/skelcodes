{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n *\r\n * SmartLotto.in\r\n *\r\n * Fair lottery smart contract with random determination of winning tickets\r\n *\r\n *\r\n * 1 ticket is jackpot winning ticket and get 10% of the contract balance\r\n * 5 tickets are first prize winnings tickets and get 5% of the contract balance\r\n * 10% of all tickets are second prize winners and get 35% of the contract balance\r\n * all other tickets receive 50% refund of the ticket price\r\n *\r\n *\r\n * 5% for referral program - use Add Data field and fill it with ETH-address of your upline when you buy tickets\r\n *\r\n *\r\n * 1 ticket price is 0.1 ETH, you can buy 250 tickets per 1 transaction maximum (250 tickets = 25 ETH)\r\n * You can make more transactions and purhase more tickets to increase your winning chances\r\n *\r\n * Use 200000 of gas limit when you buy tickets, check current gas price on https://ethgasstation.info\r\n *\r\n * Good luck!\r\n *\r\n */\r\n\r\n\r\ncontract SmartLotto {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public TICKET_PRICE = 0.1 ether;        // price of 1 ticket is 0.1 ETH\r\n    uint256 constant public MAX_TICKETS_PER_TX = 250;        // max tickets amount per 1 transaction\r\n\r\n    uint256 constant public JACKPOT_WINNER = 1;              // jackpot go to 1 ticket winners\r\n    uint256 constant public FIRST_PRIZE_WINNERS = 5;         // first prize go to 5 tickets winners\r\n    uint256 constant public SECOND_PRIZE_WINNERS_PERC = 10;  // percent of the second prize ticket winners\r\n\r\n    uint256 constant public JACKPOT_PRIZE = 10;              // jackpot winner take 10% of balance\r\n    uint256 constant public FIRST_PRIZE_POOL = 5;            // first prize winners takes 5% of balance\r\n    uint256 constant public SECOND_PRIZE_POOL = 35;          // second prize winners takes 35% of balance\r\n\r\n    uint256 constant public REFERRAL_COMMISSION = 5;         // referral commission 5% from input\r\n    uint256 constant public MARKETING_COMMISSION = 10;       // marketing commission 10% from input\r\n    uint256 constant public WINNINGS_COMMISSION = 20;        // winnings commission 20% from winnings\r\n\r\n    uint256 constant public PERCENTS_DIVIDER = 100;          // percents divider, 100%\r\n\r\n    uint256 constant public CLOSE_TICKET_SALES = 1546297200; // 23:00:00 31th of December 2018 GMT\r\n    uint256 constant public LOTTERY_DRAW_START = 1546300800; // 00:00:00 1th of January 2019 GMT\r\n    uint256 constant public PAYMENTS_END_TIME = 1554076800;  // 00:00:00 1th of April 2019 GMT\r\n\r\n    uint256 public playersCount = 0;                         // participated players counter\r\n    uint256 public ticketsCount = 0;                         // buyed tickets counter\r\n\r\n    uint256 public jackpotPrize = 0;                         // jackpot win amount per ticket\r\n    uint256 public firstPrize = 0;                           // first prize win amount per ticket\r\n    uint256 public secondPrize = 0;                          // second prize win amount per ticket\r\n    uint256 public secondPrizeWonTickets = 0;                // second prize win tickets amount\r\n    uint256 public wonTicketsAmount = 0;                     // total amount of won tickets\r\n    uint256 public participantsMoneyPool = 0;                // money pool returned to participants\r\n    uint256 public participantsTicketPrize = 0;              // amount returned per 1 ticket\r\n\r\n    uint256 public ticketsCalculated = 0;                    // won tickets calculated counter\r\n\r\n    uint256 public salt = 0;                                 // salt for random generator\r\n\r\n    bool public calculationsDone;                            // flag true when all calculations finished\r\n\r\n    address constant public MARKETING_ADDRESS = 0xFD527958E10C546f8b484135CC51fa9f0d3A8C5f;\r\n    address constant public COMMISSION_ADDRESS = 0x53434676E12A4eE34a4eC7CaBEBE9320e8b836e1;\r\n\r\n\r\n    struct Player {\r\n        uint256 ticketsCount;\r\n        uint256[] ticketsPacksBuyed;\r\n        uint256 winnings;\r\n        uint256 wonTicketsCount;\r\n        uint256 payed;\r\n    }\r\n\r\n    struct TicketsBuy {\r\n        address player;\r\n        uint256 ticketsAmount;\r\n    }\r\n\r\n\tstruct TicketsWon {\r\n\t\tuint256 won;\r\n    }\r\n\r\n    mapping (address => Player) public players;\r\n    mapping (uint256 => TicketsBuy) public ticketsBuys;\r\n\tmapping (uint256 => TicketsWon) public ticketsWons;\r\n\r\n\r\n    function() public payable {\r\n        if (msg.value >= TICKET_PRICE) {\r\n            buyTickets();\r\n        } else {\r\n            if (!calculationsDone) {\r\n                makeCalculations(50);\r\n            } else {\r\n                payPlayers();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function buyTickets() private {\r\n        // require time now less than or equal to 23:00:00 31th of December 2018 GMT\r\n        require(now <= CLOSE_TICKET_SALES);\r\n\r\n        // save msg.value\r\n        uint256 msgValue = msg.value;\r\n\r\n        // load player msg.sender\r\n        Player storage player = players[msg.sender];\r\n\r\n        // if new player add to total players stats\r\n        if (player.ticketsCount == 0) {\r\n            playersCount++;\r\n        }\r\n\r\n        // count amount of tickets which can be bought\r\n        uint256 ticketsAmount = msgValue.div(TICKET_PRICE);\r\n\r\n        // if tickets more than MAX_TICKETS_PER_TX (250 tickets)\r\n        if (ticketsAmount > MAX_TICKETS_PER_TX) {\r\n            // use MAX_TICKETS_PER_TX (250 tickets)\r\n            ticketsAmount = MAX_TICKETS_PER_TX;\r\n        }\r\n\r\n\t\t// count overpayed amount by player\r\n\t\tuint256 overPayed = msgValue.sub(ticketsAmount.mul(TICKET_PRICE));\r\n\r\n\t\t// if player overpayed\r\n\t\tif (overPayed > 0) {\r\n\t\t\t// update msgValue for futher calculations\r\n\t\t\tmsgValue = msgValue.sub(overPayed);\r\n\r\n\t\t\t// send to player overpayed amount\r\n\t\t\tmsg.sender.transfer(overPayed);\r\n\t\t}\r\n\r\n        // add bought tickets pack to array with id of current tickets amount\r\n        player.ticketsPacksBuyed.push(ticketsCount);\r\n\r\n        // create new TicketsBuy record\r\n        // creating only one record per MAX_TICKETS_PER_TX (250 tickets)\r\n        // to avoid high gas usage when players buy tickets\r\n        ticketsBuys[ticketsCount] = TicketsBuy({\r\n            player : msg.sender,\r\n            ticketsAmount : ticketsAmount\r\n        });\r\n\r\n\t\t// add bought tickets to player stats\r\n        player.ticketsCount = player.ticketsCount.add(ticketsAmount);\r\n        // update bought tickets counter\r\n        ticketsCount = ticketsCount.add(ticketsAmount);\r\n\r\n        // try get ref address from tx data\r\n        address referrerAddress = bytesToAddress(msg.data);\r\n\r\n        // if ref address not 0 and not msg.sender\r\n        if (referrerAddress != address(0) && referrerAddress != msg.sender) {\r\n            // count ref amount\r\n            uint256 referralAmount = msgValue.mul(REFERRAL_COMMISSION).div(PERCENTS_DIVIDER);\r\n            // send ref amount\r\n            referrerAddress.send(referralAmount);\r\n        }\r\n\r\n        // count marketing amount\r\n        uint256 marketingAmount = msgValue.mul(MARKETING_COMMISSION).div(PERCENTS_DIVIDER);\r\n        // send marketing amount\r\n        MARKETING_ADDRESS.send(marketingAmount);\r\n    }\r\n\r\n    function makeCalculations(uint256 count) public {\r\n        // require calculations not done\r\n        require(!calculationsDone);\r\n        // require time now more than or equal to 00:00:00 1st of January 2019 GMT\r\n        require(now >= LOTTERY_DRAW_START);\r\n\r\n        // if salt not counted\r\n        if (salt == 0) {\r\n            // create random salt which depends on blockhash, count of tickets and count of players\r\n            salt = uint256(keccak256(abi.encodePacked(ticketsCount, uint256(blockhash(block.number-1)), playersCount)));\r\n\r\n            // get actual contract balance\r\n            uint256 contractBalance = address(this).balance;\r\n\r\n            // count and save jackpot win amount per ticket\r\n            jackpotPrize = contractBalance.mul(JACKPOT_PRIZE).div(PERCENTS_DIVIDER).div(JACKPOT_WINNER);\r\n            // count and save first prize win amount per ticket\r\n            firstPrize = contractBalance.mul(FIRST_PRIZE_POOL).div(PERCENTS_DIVIDER).div(FIRST_PRIZE_WINNERS);\r\n\r\n            // count and save second prize win tickets amount\r\n            secondPrizeWonTickets = ticketsCount.mul(SECOND_PRIZE_WINNERS_PERC).div(PERCENTS_DIVIDER);\r\n            // count and save second prize win amount per ticket\r\n            secondPrize = contractBalance.mul(SECOND_PRIZE_POOL).div(PERCENTS_DIVIDER).div(secondPrizeWonTickets);\r\n\r\n            // count and save how many tickets won\r\n            wonTicketsAmount = secondPrizeWonTickets.add(JACKPOT_WINNER).add(FIRST_PRIZE_WINNERS);\r\n\r\n            // count and save money pool returned to participants\r\n            participantsMoneyPool = contractBalance.mul(PERCENTS_DIVIDER.sub(JACKPOT_PRIZE).sub(FIRST_PRIZE_POOL).sub(SECOND_PRIZE_POOL)).div(PERCENTS_DIVIDER);\r\n            // count and save participants prize per ticket\r\n            participantsTicketPrize = participantsMoneyPool.div(ticketsCount.sub(wonTicketsAmount));\r\n\r\n            // proceed jackpot prize ticket winnings\r\n            calculateWonTickets(JACKPOT_WINNER, jackpotPrize);\r\n            // proceed first prize tickets winnings\r\n            calculateWonTickets(FIRST_PRIZE_WINNERS, firstPrize);\r\n\r\n            // update calculated tickets counter\r\n            ticketsCalculated = ticketsCalculated.add(JACKPOT_WINNER).add(FIRST_PRIZE_WINNERS);\r\n        // if salt already counted\r\n        } else {\r\n            // if calculations of second prize winners not yet finished\r\n            if (ticketsCalculated < wonTicketsAmount) {\r\n                // how many tickets not yet calculated\r\n                uint256 ticketsForCalculation = wonTicketsAmount.sub(ticketsCalculated);\r\n\r\n                // if count zero and tickets for calculations more than 50\r\n                // than calculate 50 tickets to avoid gas cost more than block limit\r\n                if (count == 0 && ticketsForCalculation > 50) {\r\n                    ticketsForCalculation = 50;\r\n                }\r\n\r\n                // if count more than zero and count less than amount of not calculated tickets\r\n                // than use count as amount of tickets for calculations\r\n                if (count > 0 && count <= ticketsForCalculation) {\r\n                    ticketsForCalculation = count;\r\n                }\r\n\r\n                // proceed second prize ticket winnings\r\n                calculateWonTickets(ticketsForCalculation, secondPrize);\r\n\r\n                // update calculated tickets counter\r\n                ticketsCalculated = ticketsCalculated.add(ticketsForCalculation);\r\n            }\r\n\r\n            // if calculations of second prize winners finished set calculations done\r\n            if (ticketsCalculated == wonTicketsAmount) {\r\n                calculationsDone = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateWonTickets(uint256 numbers, uint256 prize) private {\r\n        // for all numbers in var make calculations\r\n        for (uint256 n = 0; n < numbers; n++) {\r\n            // get random generated won ticket number\r\n            uint256 wonTicketNumber = random(n);\r\n\r\n\t\t\t// if ticket already won\r\n\t\t\tif (ticketsWons[wonTicketNumber].won == 1) {\r\n\t\t\t\t// than substract 1 ticket from calculated\r\n\t\t\t\tticketsCalculated = ticketsCalculated.sub(1);\r\n\t\t\t// ticket not won yet\r\n\t\t\t} else {\r\n\t\t\t\t// mark ticket as won\r\n\t\t\t\tticketsWons[wonTicketNumber].won = 1;\r\n\r\n\t\t\t\t// search player record to add ticket winnings\r\n\t\t\t\tfor (uint256 i = 0; i < MAX_TICKETS_PER_TX; i++) {\r\n\t\t\t\t\t// search max MAX_TICKETS_PER_TX (250 tickets)\r\n\t\t\t\t\tuint256 wonTicketIdSearch = wonTicketNumber - i;\r\n\r\n\t\t\t\t\t// if player record found\r\n\t\t\t\t\tif (ticketsBuys[wonTicketIdSearch].ticketsAmount > 0) {\r\n\t\t\t\t\t\t// read player from storage\r\n\t\t\t\t\t\tPlayer storage player = players[ticketsBuys[wonTicketIdSearch].player];\r\n\r\n\t\t\t\t\t\t// add ticket prize amount to player winnings\r\n\t\t\t\t\t\tplayer.winnings = player.winnings.add(prize);\r\n\t\t\t\t\t\t// update user won tickets counter\r\n\t\t\t\t\t\tplayer.wonTicketsCount++;\r\n\r\n\t\t\t\t\t\t// player found so stop searching\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n\r\n        // update salt and add numbers amount\r\n        salt = salt.add(numbers);\r\n    }\r\n\r\n    function payPlayers() private {\r\n        // require calculations are done\r\n        require(calculationsDone);\r\n\r\n        // pay players if time now less than 00:00:00 1st of April 2019 GMT\r\n        if (now <= PAYMENTS_END_TIME) {\r\n            // read player record\r\n            Player storage player = players[msg.sender];\r\n\r\n            // if player have won tickets and not yet payed\r\n            if (player.winnings > 0 && player.payed == 0) {\r\n                // count winnings commission from player won amount\r\n                uint256 winCommission = player.winnings.mul(WINNINGS_COMMISSION).div(PERCENTS_DIVIDER);\r\n\r\n                // count amount of not won tickets\r\n                uint256 notWonTickets = player.ticketsCount.sub(player.wonTicketsCount);\r\n                // count return amount for not won tickets\r\n                uint256 notWonAmount = notWonTickets.mul(participantsTicketPrize);\r\n\r\n                // update player payed winnings\r\n                player.payed = player.winnings.add(notWonAmount);\r\n\r\n                // send total winnings amount to player\r\n                msg.sender.transfer(player.winnings.sub(winCommission).add(notWonAmount).add(msg.value));\r\n\r\n                // send commission\r\n                COMMISSION_ADDRESS.send(winCommission);\r\n            }\r\n\r\n            // if player have not won tickets and not yet payed\r\n            if (player.winnings == 0 && player.payed == 0) {\r\n                // count return amount for not won tickets\r\n                uint256 returnAmount = player.ticketsCount.mul(participantsTicketPrize);\r\n\r\n                // update player payed winnings\r\n                player.payed = returnAmount;\r\n\r\n                // send total winnings amount to player\r\n                msg.sender.transfer(returnAmount.add(msg.value));\r\n            }\r\n        // if payment period already ended\r\n        } else {\r\n            // get actual contract balance\r\n            uint256 contractBalance = address(this).balance;\r\n\r\n            // actual contract balance more than zero\r\n            if (contractBalance > 0) {\r\n                // send contract balance to commission address\r\n                COMMISSION_ADDRESS.send(contractBalance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function random(uint256 nonce) private view returns (uint256) {\r\n        // random number generated from salt plus nonce divided by total amount of tickets\r\n        uint256 number = uint256(keccak256(abi.encodePacked(salt.add(nonce)))).mod(ticketsCount);\r\n        return number;\r\n    }\r\n\r\n    function playerBuyedTicketsPacks(address player) public view returns (uint256[]) {\r\n        return players[player].ticketsPacksBuyed;\r\n    }\r\n\r\n    function bytesToAddress(bytes data) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(data, 0x14))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondPrizeWonTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TICKET_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wonTicketsAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WINNINGS_COMMISSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculationsDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketsCalculated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SECOND_PRIZE_WINNERS_PERC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketsWons\",\"outputs\":[{\"name\":\"won\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_PRIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"makeCalculations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PAYMENTS_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantsTicketPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_PRIZE_WINNERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_COMMISSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TICKETS_PER_TX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketsBuys\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"ticketsAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOTTERY_DRAW_START\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_WINNER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRAL_COMMISSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLOSE_TICKET_SALES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"ticketsCount\",\"type\":\"uint256\"},{\"name\":\"winnings\",\"type\":\"uint256\"},{\"name\":\"wonTicketsCount\",\"type\":\"uint256\"},{\"name\":\"payed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_PRIZE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SECOND_PRIZE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"playerBuyedTicketsPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantsMoneyPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SmartLotto","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://96e736b35c7681698e9ee0aa47d90475967cbf846bbc2d170439e08ce1b3adb8"}]}