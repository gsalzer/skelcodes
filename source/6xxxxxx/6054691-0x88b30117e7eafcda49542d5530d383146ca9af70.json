{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/** title -Divies- v0.7.1\r\n \r\n *         ┌──────────────────────────────────────────────────────────────────────┐\r\n *         │ Divies!, is a contract that adds an external dividend system to BTB. │\r\n *         │ All eth sent to this contract, can be distributed to BTB holders.    │\r\n *         │ Uses msg.sender as masternode for initial buy order.                 │\r\n *         └──────────────────────────────────────────────────────────────────────┘\r\n *                                ┌────────────────────┐\r\n *                                │ Setup Instructions │\r\n *                                └────────────────────┘\r\n * (Step 1) import this contracts interface into your contract\r\n * \r\n *    import \"./DiviesInterface.sol\";\r\n * \r\n * (Step 2) set up the interface and point it to this contract\r\n * \r\n *    DiviesInterface private Divies = DiviesInterface(0xEDEaB579e57a7D66297D0a67302647bB109db7A8);\r\n *                                ┌────────────────────┐\r\n *                                │ Usage Instructions │\r\n *                                └────────────────────┘\r\n * call as follows anywhere in your code:\r\n *   \r\n *    Divies.deposit.value(amount)();\r\n *          ex:  Divies.deposit.value(232000000000000000000)();\r\n */\r\n\r\ninterface HourglassInterface {\r\n    function() payable external;\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function reinvest() external;\r\n    function withdraw() external;\r\n    function exit() external;\r\n    function dividendsOf(address _playerAddress) external view returns(uint256);\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function stakingRequirement() external view returns(uint256);\r\n}\r\n\r\ncontract Divies {\r\n    using SafeMath for uint256;\r\n    using UintCompressor for uint256;\r\n\r\n    HourglassInterface constant BTBcontract_ = HourglassInterface(0xEDEaB579e57a7D66297D0a67302647bB109db7A8);\r\n    \r\n    uint256 public pusherTracker_ = 100;\r\n    mapping (address => Pusher) public pushers_;\r\n    struct Pusher\r\n    {\r\n        uint256 tracker;\r\n        uint256 time;\r\n    }\r\n    uint256 public rateLimiter_;\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MODIFIERS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    modifier isHuman() {\r\n        require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // BALANCE\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function balances()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (address(this).balance);\r\n    }\r\n    \r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DEPOSIT\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function deposit()\r\n        external\r\n        payable\r\n    {\r\n        \r\n    }\r\n    \r\n    // used so the distribute function can call hourglass's withdraw\r\n    function() external payable {}\r\n    \r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // EVENTS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    event onDistribute(\r\n        address pusher,\r\n        uint256 startingBalance,\r\n        uint256 masternodePayout,\r\n        uint256 finalBalance,\r\n        uint256 compressedData\r\n    );\r\n    /* compression key\r\n    [0-14] - timestamp\r\n    [15-29] - caller pusher tracker \r\n    [30-44] - global pusher tracker \r\n    [45-46] - percent\r\n    [47] - greedy\r\n    */  \r\n    \r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DISTRIBUTE\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function distribute(uint256 _percent)\r\n        public\r\n        isHuman()\r\n    {\r\n        // make sure _percent is within boundaries\r\n        require(_percent > 0 && _percent < 100, \"please pick a percent between 1 and 99\");\r\n        \r\n        // data setup\r\n        address _pusher = msg.sender;\r\n        uint256 _bal = address(this).balance;\r\n        uint256 _mnPayout;\r\n        uint256 _compressedData;\r\n        \r\n        // limit pushers greed (use \"if\" instead of require for level 42 top kek)\r\n        if (\r\n            pushers_[_pusher].tracker <= pusherTracker_.sub(100) && // pusher is greedy: wait your turn\r\n            pushers_[_pusher].time.add(1 hours) < now               // pusher is greedy: its not even been 1 hour\r\n        )\r\n        {\r\n            // update pushers wait que \r\n            pushers_[_pusher].tracker = pusherTracker_;\r\n            pusherTracker_++;\r\n            \r\n            // setup mn payout for event\r\n            if (BTBcontract_.balanceOf(_pusher) >= BTBcontract_.stakingRequirement())\r\n                _mnPayout = (_bal / 10) / 3;\r\n            \r\n            // setup _stop.  this will be used to tell the loop to stop\r\n            uint256 _stop = (_bal.mul(100 - _percent)) / 100;\r\n            \r\n            // buy & sell    \r\n            BTBcontract_.buy.value(_bal)(_pusher);\r\n            BTBcontract_.sell(BTBcontract_.balanceOf(address(this)));\r\n            \r\n            // setup tracker.  this will be used to tell the loop to stop\r\n            uint256 _tracker = BTBcontract_.dividendsOf(address(this));\r\n    \r\n            // reinvest/sell loop\r\n            while (_tracker >= _stop) \r\n            {\r\n                // lets burn some tokens to distribute dividends to p3d holders\r\n                BTBcontract_.reinvest();\r\n                BTBcontract_.sell(BTBcontract_.balanceOf(address(this)));\r\n                \r\n                // update our tracker with estimates (yea. not perfect, but cheaper on gas)\r\n                _tracker = (_tracker.mul(81)) / 100;\r\n            }\r\n            \r\n            // withdraw\r\n            BTBcontract_.withdraw();\r\n        } else {\r\n            _compressedData = _compressedData.insert(1, 47, 47);\r\n        }\r\n        \r\n        // update pushers timestamp  (do outside of \"if\" for super saiyan level top kek)\r\n        pushers_[_pusher].time = now;\r\n    \r\n        // prep event compression data \r\n        _compressedData = _compressedData.insert(now, 0, 14);\r\n        _compressedData = _compressedData.insert(pushers_[_pusher].tracker, 15, 29);\r\n        _compressedData = _compressedData.insert(pusherTracker_, 30, 44);\r\n        _compressedData = _compressedData.insert(_percent, 45, 46);\r\n            \r\n        // fire event\r\n        emit onDistribute(_pusher, _bal, _mnPayout, address(this).balance, _compressedData);\r\n    }\r\n}\r\n\r\n/**\r\n* @title -UintCompressor- v0.1.9\r\n\r\n*/\r\n\r\nlibrary UintCompressor {\r\n    using SafeMath for *;\r\n    \r\n    function insert(uint256 _var, uint256 _include, uint256 _start, uint256 _end)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // check conditions \r\n        require(_end < 77 && _start < 77, \"start/end must be less than 77\");\r\n        require(_end >= _start, \"end must be >= start\");\r\n        \r\n        // format our start/end points\r\n        _end = exponent(_end).mul(10);\r\n        _start = exponent(_start);\r\n        \r\n        // check that the include data fits into its segment \r\n        require(_include < (_end / _start));\r\n        \r\n        // build middle\r\n        if (_include > 0)\r\n            _include = _include.mul(_start);\r\n        \r\n        return((_var.sub((_var / _start).mul(_start))).add(_include).add((_var / _end).mul(_end)));\r\n    }\r\n    \r\n    function extract(uint256 _input, uint256 _start, uint256 _end)\r\n\t    internal\r\n\t    pure\r\n\t    returns(uint256)\r\n    {\r\n        // check conditions\r\n        require(_end < 77 && _start < 77, \"start/end must be less than 77\");\r\n        require(_end >= _start, \"end must be >= start\");\r\n        \r\n        // format our start/end points\r\n        _end = exponent(_end).mul(10);\r\n        _start = exponent(_start);\r\n        \r\n        // return requested section\r\n        return((((_input / _start).mul(_start)).sub((_input / _end).mul(_end))) / _start);\r\n    }\r\n    \r\n    function exponent(uint256 _position)\r\n        private\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return((10).pwr(_position));\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pushers_\",\"outputs\":[{\"name\":\"tracker\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pusherTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateLimiter_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pusher\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startingBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"masternodePayout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"}],\"name\":\"onDistribute\",\"type\":\"event\"}]","ContractName":"Divies","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://58c8c98b040a48969996c8cc01e6b1585d2af0bffe96ff3e557d3a54ac2d56dd"}]}