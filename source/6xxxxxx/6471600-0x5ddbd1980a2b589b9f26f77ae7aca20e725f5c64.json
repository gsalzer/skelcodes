{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract RISK{\r\n\r\n    //global variables\r\n    uint16[19][3232] private adjacencies;\r\n    address private admin = msg.sender;\r\n    uint256 private seed = block.timestamp;\r\n    uint256 public roundID;\r\n    mapping(uint256=>RoundData) public Rounds;\r\n    bool public isactive;\r\n    mapping(address=>uint256) private playerlastroundwithdrawn;\r\n    \r\n    \r\n    //settings that are read at the beggining of a round, and admin can change them, taking effect at new round \r\n    uint16 public beginterritories = 5; //number of territories to claim at createnation\r\n    uint16 public maxroll= 6;\r\n    uint256 public trucetime=72 hours;\r\n    uint256 public price=30 finney;\r\n    uint256 public maxextensiontruce=50; //max number of territories owned during truce\r\n    \r\n    \r\n    //store names\r\n    mapping(bytes32=>address) public ownerXname; //get owner by name, anyone can own an arbitrary number of names\r\n    mapping(address=>bytes32) public nameXaddress;//get the current name in use by the address\r\n    mapping(bytes32=>uint256) public priceXname; //get the price of a name\r\n\r\n\r\n\r\n    /*_____       _     _ _      ______                _   _                 \r\n     |  __ \\     | |   | (_)    |  ____|              | | (_)                \r\n     | |__) |   _| |__ | |_  ___| |__ _   _ _ __   ___| |_ _  ___  _ __  ___ \r\n     |  ___/ | | | '_ \\| | |/ __|  __| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\r\n     | |   | |_| | |_) | | | (__| |  | |_| | | | | (__| |_| | (_) | | | \\__ \\\r\n     |_|    \\__,_|_.__/|_|_|\\___|_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/*/\r\n\r\n\r\n    function createnation(uint16[] territories,string _name,\r\n    uint256 RGB)\r\n    public\r\n    payable\r\n    {\r\n        RequireHuman();\r\n        require(isactive);\r\n        uint256 _rID = roundID;\r\n        uint16 _teamcnt =Rounds[_rID].teamcnt;\r\n        \r\n        \r\n        require(_teamcnt<255); //max 255 teams, with 0 being unclaimed territories\r\n        \r\n        \r\n        RGB=colorfilter(RGB);//format and check it's not one of the UI colors\r\n        require(!Rounds[_rID].iscolorregistered[RGB]); //color must be unique\r\n        \r\n        \r\n        bytes32 name=nameFilter(_name);\r\n        require(ownerXname[name]==msg.sender); //player must own this name\r\n        require(Rounds[_rID].isnameregistered[name]==false); //name must be unique to round\r\n\r\n\r\n        uint16 _beginterritories =  Rounds[roundID].beginterritories;\r\n        require(msg.value==Rounds[_rID].price);\r\n        require(territories.length==_beginterritories);//send only the exact ammount pls\r\n        require(Rounds[_rID].teamXaddr[msg.sender]==0); //one player can only play with one team\r\n        \r\n        uint i;\r\n        for (i =0 ; i<territories.length;i++){\r\n            require(territories[i]<uint16(2750)); //don't claim sea provinces\r\n            require(getownership(territories[i])==uint16(0)); //don't claim other players' lands\r\n        }\r\n\r\n        _teamcnt+=1; //increase the team counter\r\n\r\n        setownership(territories[0],_teamcnt);\r\n        for (i =1 ; i<territories.length;i++){ \r\n            require(hasteamadjacency(territories[i],_teamcnt)); //all territories should share borders\r\n            setownership(territories[i],_teamcnt);\r\n        }\r\n        \r\n\r\n        //starting a nation gives as many shares to the pot as the number of territories claimed\r\n        Rounds[_rID].validrollsXaddr[msg.sender]+=_beginterritories;\r\n        Rounds[_rID].validrollsXteam[_teamcnt]+=_beginterritories;\r\n        \r\n        \r\n        Rounds[_rID].teamXaddr[msg.sender]=_teamcnt; //map the players address to his team\r\n        Rounds[_rID].nationnameXteam[_teamcnt]=name;\r\n        Rounds[_rID].colorXteam[_teamcnt]=RGB;\r\n        Rounds[_rID].iscolorregistered[RGB]=true;\r\n        Rounds[_rID].teamcnt=_teamcnt;\r\n        Rounds[_rID].isnameregistered[name]=true;//don't allow countries with duplicate names\r\n        Rounds[_rID].pot+=msg.value;\r\n        \r\n        \r\n        //trigger event\r\n        emit oncreatenation(\r\n            nameXaddress[msg.sender],\r\n            name,\r\n            RGB,\r\n            _teamcnt,\r\n            territories,\r\n            msg.sender);\r\n    }\r\n    \r\n    \r\n    function roll(uint16[] territories,uint16 team) \r\n    payable\r\n    public\r\n    {\r\n        RequireHuman();\r\n        require(isactive);\r\n        \r\n        require(team!=0);\r\n        \r\n        uint256 _rID = roundID;\r\n        uint256 _now = block.timestamp;\r\n        uint256 _roundstart = Rounds[_rID].roundstart;\r\n        uint256 _trucetime = Rounds[_rID].trucetime;\r\n\r\n\r\n        if (Rounds[_rID].teamXaddr[msg.sender]==0){ //new player\r\n            Rounds[_rID].teamXaddr[msg.sender]=team;\r\n        }\r\n        else{\r\n            require(Rounds[_rID].teamXaddr[msg.sender]==team); //don't allow to switch teams   \r\n        }\r\n\r\n\r\n        //require(territories.length==maxroll); //should allow player to input fewer or extra territories, as a backup plan in case someone is includead earlier in the block or for endgame too\r\n        \r\n        \r\n        require(msg.value==Rounds[_rID].price ); \r\n        \r\n        uint16 _maxroll = Rounds[_rID].maxroll;\r\n        seed = uint256(keccak256(abi.encodePacked((seed^block.timestamp)))); //far from safe, but the advantadge to roll a 6 is not worth for a miner to cheat\r\n        uint256 rolled = (seed % _maxroll)+1; //dice roll from 1 to maxroll\r\n        uint256 validrolls=0; \r\n        uint16[] memory territoriesconquered = new uint16[](_maxroll);\r\n        \r\n        if  (_roundstart+_trucetime<_now){//check if the truce has ended\r\n            for (uint i = 0 ; i<territories.length;i++){\r\n                if (getownership(territories[i])==team){ //dont waste a roll for own provinces\r\n                    continue;\r\n                }\r\n                if (hasteamadjacency(territories[i],team)){//valid territory, is adjacent to own\r\n                    territoriesconquered[validrolls]=territories[i];\r\n                    setownership(territories[i],team); //invade it\r\n                    validrolls+=1;\r\n                    if (validrolls==rolled){//exit the loop when we reached our rolled\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else{//if truce\r\n            require(Rounds[_rID].validrollsXteam[team]<Rounds[_rID].maxextensiontruce); //limit number of territories during truce, don't allow to roll if 50 territories or more\r\n            for  (i = 0 ; i<territories.length;i++){\r\n                if (getownership(territories[i])!=0){ //only invade neutral provinces\r\n                    continue;\r\n                }\r\n                if (hasteamadjacency(territories[i],team)){//valid territory, is adjacent to own\r\n                    territoriesconquered[validrolls]=territories[i];\r\n                    setownership(territories[i],team); //invade it\r\n                    validrolls+=1;\r\n                    if (validrolls==rolled){//exit the loop when we reached our rolled\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Rounds[_rID].validrollsXaddr[msg.sender]+=validrolls;\r\n        Rounds[_rID].validrollsXteam[team]+=validrolls;\r\n        \r\n        uint256 refund;\r\n        if (validrolls<rolled){\r\n            refund = ((rolled-validrolls)*msg.value)/rolled;\r\n        }\r\n        Rounds[_rID].pot+=msg.value-refund;\r\n        if (refund>0){\r\n            msg.sender.transfer(refund);\r\n        }\r\n        \r\n        \r\n        //trigger event\r\n        emit onroll(\r\n            nameXaddress[msg.sender],\r\n            Rounds[_rID].nationnameXteam[team],\r\n            rolled,\r\n            team,\r\n            territoriesconquered,\r\n            msg.sender\r\n            );\r\n    }\r\n\r\n\r\n    function endround()\r\n    //call this in a separate function cause it can take quite a bit of gas, around 1Mio gas\r\n    public\r\n    {\r\n        RequireHuman();\r\n        require(isactive);\r\n        \r\n        uint256 _rID = roundID;\r\n        require(Rounds[_rID].teamcnt>0); // require at least one nation has been created\r\n\r\n        uint256 _pot = Rounds[_rID].pot;\r\n        uint256 fee =_pot/20; //5% admin fee\r\n        uint256 nextpot = _pot/20; //5% of current pot to next round\r\n        uint256 finalpot = _pot-fee-nextpot; //remaining pot to distribute \r\n        \r\n        \r\n        uint256 _roundstart=Rounds[_rID].roundstart;\r\n        uint256 _now=block.timestamp;\r\n        require(_roundstart+Rounds[_rID].trucetime<_now);//require that the truce has ended\r\n\r\n\r\n        uint256[] memory _owners_ = new uint256[](86);\r\n        for (uint16 i = 0;i<86;i++){ //memory copy of owners, saves around 400k gas by avoiding SSLOAD opcodes\r\n            _owners_[i]=Rounds[_rID].owners[i];\r\n        }\r\n\r\n        uint16 t;\r\n        uint16 team;\r\n        uint16 j;\r\n        for ( i = 1; i<uint16(2750);i++){ //loop until you find a nonzero team\r\n            t=getownership2(i,_owners_[i/32]);\r\n            if (t!=uint16(0)){\r\n                team=t;\r\n                j=i+1;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        for ( i = j; i<uint16(2750);i++){ //check that all nonzero territories belong to team\r\n            t=getownership2(i,_owners_[i/32]);\r\n            if(t>0){\r\n                if(t!=team){\r\n                    require(false);\r\n                }\r\n            }\r\n        }\r\n        Rounds[_rID].teampotshare[team]=finalpot; //entire pot to winner team\r\n        Rounds[_rID].winner=Rounds[_rID].nationnameXteam[team];\r\n        \r\n        \r\n        admin.transfer(fee);\r\n        \r\n        \r\n        //start next round\r\n        _rID+=1;\r\n        Rounds[_rID].trucetime =trucetime;\r\n        Rounds[_rID].roundstart =block.timestamp;\r\n        Rounds[_rID].beginterritories =beginterritories; \r\n        Rounds[_rID].maxroll = maxroll;\r\n        Rounds[_rID].pot = nextpot;\r\n        Rounds[_rID].price = price;\r\n        Rounds[_rID].maxextensiontruce = maxextensiontruce;\r\n        roundID=_rID;\r\n        \r\n        emit onendround();\r\n    }\r\n\r\n\r\n    function withdraw() \r\n    public\r\n    {\r\n        RequireHuman();\r\n        uint256 balance;\r\n        uint256 _roundID=roundID;\r\n        balance=getbalance(_roundID);\r\n        playerlastroundwithdrawn[msg.sender]=_roundID-1;\r\n        if (balance>0){\r\n            msg.sender.transfer(balance);\r\n        }\r\n    }\r\n    \r\n    \r\n    function buyname( string _name)\r\n    public\r\n    payable\r\n    {\r\n        RequireHuman();\r\n        \r\n        \r\n        bytes32 name=nameFilter(_name);\r\n        address prevowner=ownerXname[name];\r\n        require(prevowner!=msg.sender);\r\n        uint256 buyprice = 3*priceXname[name]/2; //require 1.5X what was paid to get the name\r\n        if (3 finney > buyprice){ //starting bids at 3mETH\r\n            buyprice = 3 finney;\r\n        }\r\n        require(msg.value>=buyprice);\r\n        \r\n        uint256 fee;\r\n        uint256 topot;\r\n        uint256 reimbursement;\r\n        \r\n        \r\n        if (prevowner==address(0)){ //if it's the first time the name is purchased, the payment goes to the pot\r\n            Rounds[roundID].pot+=msg.value ;   \r\n        }\r\n        else{\r\n            fee = buyprice/20; //5% fee on refund\r\n            topot = msg.value-buyprice;//anything over the buyprice goes to the pot\r\n            reimbursement=buyprice-fee; //ammount to pay back\r\n            if (topot>0){\r\n            Rounds[roundID].pot+=topot;\r\n            }\r\n        }\r\n        \r\n\r\n        nameXaddress[prevowner]=''; //change the name of the previous owner to empty\r\n        ownerXname[name]=msg.sender; //set new owner\r\n        priceXname[name]=msg.value; //new buyprice\r\n        bytes32 prevname = nameXaddress[msg.sender];\r\n        nameXaddress[msg.sender]=name; //set name bought as display name for buyer\r\n        \r\n        emit onbuyname(\r\n            name,\r\n            msg.value,\r\n            prevname,\r\n            msg.sender\r\n            );\r\n            \r\n        if (fee>0){\r\n        admin.transfer(fee);\r\n            \r\n        }\r\n        if (reimbursement>0){\r\n        prevowner.transfer(reimbursement);\r\n        }\r\n    }\r\n    \r\n    \r\n    function switchname(bytes32 name) //switch between owned names\r\n    public\r\n    {\r\n        require(ownerXname[name]==msg.sender);//check that sender is the owner of this name\r\n        nameXaddress[msg.sender]=name;//set it\r\n    }\r\n    \r\n    \r\n    function clearname() //empty name, use default random one on UI\r\n    public\r\n    {\r\n        bytes32 empty;\r\n        nameXaddress[msg.sender]=empty;\r\n    }\r\n    \r\n\r\n    /*_____      _            _       ______                _   _                 \r\n     |  __ \\    (_)          | |     |  ____|              | | (_)                \r\n     | |__) | __ ___   ____ _| |_ ___| |__ _   _ _ __   ___| |_ _  ___  _ __  ___ \r\n     |  ___/ '__| \\ \\ / / _` | __/ _ \\  __| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\r\n     | |   | |  | |\\ V / (_| | ||  __/ |  | |_| | | | | (__| |_| | (_) | | | \\__ \\\r\n     |_|   |_|  |_| \\_/ \\__,_|\\__\\___|_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/*/\r\n\r\n\r\n    function getownership(uint16 terr) \r\n    private \r\n    view\r\n    returns(uint16)\r\n    {//index is floor division, perform AND with a filter that's full of 0s except in the 8 bit range we want to access so it returns only that 8bit window\r\n        //shift it to the 8 rightmost bits and convert to int16\r\n        return(uint16((Rounds[roundID].owners[terr/32]&(255*2**(8*(uint256(terr%32)))))/(2**(uint256(terr)%32*8))));\r\n    }\r\n\r\n\r\n    function getownership2(uint16 terr,uint256 ownuint) //slightly modified version of getownership() to use in endround()\r\n    private \r\n    pure\r\n    returns(uint16)\r\n    {//index if floor division, perform AND with a filter that's full of 0s except in the 8 bit range we want to access so it returns only that 8bit window\r\n        //shift it right and convert to int16\r\n        return(uint16((ownuint&255*2**(8*(uint256(terr)%32)))/(2**(uint256(terr)%32*8))));\r\n    } \r\n\r\n\r\n    function setownership(uint16 terr, uint16 team)\r\n    private\r\n    { //index is floor division, perform AND with a filter that's full of 1s except in the 8bit range we want to access so that it removes the prev record\r\n        //perform OR with the team number shifted left into the position\r\n        Rounds[roundID].owners[terr/32]=(Rounds[roundID].owners[terr/32]&(115792089237316195423570985008687907853269984665640564039457584007913129639935-(255*(2**(8*(uint256(terr)%32))))))|(uint256(team)*2**((uint256(terr)%32)*8));\r\n    }\r\n\r\n\r\n    function areadjacent(uint16 terr1, uint16 terr2) \r\n    private\r\n    view\r\n    returns(bool)\r\n    {\r\n        for (uint i=0;i<19;i++){\r\n            if (adjacencies[terr1][i]==terr2){//are adjacent\r\n                return true;\r\n            }\r\n            if (adjacencies[terr1][i]==0){ //exit early if we get to the end of the valid adjacencies\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    } \r\n\r\n\r\n    function hasteamadjacency(uint16 terr,uint16 team) \r\n    private\r\n    view\r\n    returns(bool)\r\n    {\r\n        for (uint i = 0; i<adjacencies[terr].length;i++){\r\n            if (getownership(adjacencies[terr][i])==team){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \r\n    //block transactions from contracts\r\n    function RequireHuman()\r\n    private\r\n    view\r\n    {\r\n        uint256  size;\r\n        address addr = msg.sender;\r\n        \r\n        assembly {size := extcodesize(addr)}\r\n        require(size == 0 );\r\n    }\r\n\r\n   /*__      ___               ______                _   _                 \r\n     \\ \\    / (_)             |  ____|              | | (_)                \r\n      \\ \\  / / _  _____      _| |__ _   _ _ __   ___| |_ _  ___  _ __  ___ \r\n       \\ \\/ / | |/ _ \\ \\ /\\ / /  __| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\r\n        \\  /  | |  __/\\ V  V /| |  | |_| | | | | (__| |_| | (_) | | | \\__ \\\r\n         \\/   |_|\\___| \\_/\\_/ |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/ */\r\n\r\n    \r\n    function colorfilter(uint256 RGB)\r\n    public\r\n    pure\r\n    returns(uint256)\r\n    {\r\n        //rounds the R, G and B values down to the closest 32 mutiple, removes anything outside the range\r\n        //this is done to ensure all colors are different enough to avoid confusion\r\n        RGB=RGB&14737632;\r\n\r\n        //filter out game default colors\r\n        require(RGB!=12632256);\r\n        require(RGB!=14704640);\r\n        require(RGB!=14729344);\r\n        require(RGB!=8421504);\r\n        require(RGB!=224);\r\n        require(RGB!=8404992);\r\n\r\n\r\n        return(RGB);\r\n    }\r\n\r\n\r\n    function getbalance(uint rID)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint16 team;\r\n        uint256 balance;\r\n        for (uint i = playerlastroundwithdrawn[msg.sender]+1;i<rID;i++){\r\n            if (Rounds[i].validrollsXaddr[msg.sender]==0){ //skip if player didn't take part in the round\r\n                continue;\r\n            }\r\n            \r\n            team=Rounds[i].teamXaddr[msg.sender];\r\n            \r\n            balance += (Rounds[i].teampotshare[team]*Rounds[i].validrollsXaddr[msg.sender])/Rounds[i].validrollsXteam[team];\r\n        }\r\n        return balance;\r\n    }\r\n     \r\n     \r\n    function nameFilter(string _input) //Versioned from team JUST, no numbers, no caps, but caps are displayed after each space on the UI\r\n    public\r\n    pure\r\n    returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 64 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        \r\n        // check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) \r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20){\r\n                    \r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                }\r\n            }\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n    \r\n    \r\n    //retrieve arrays and mappings from inside the struct array\r\n    function readowners()\r\n    view\r\n    public\r\n    returns(uint256[101])\r\n    {\r\n        return(Rounds[roundID].owners);\r\n    }\r\n    \r\n    \r\n    function readownerXname(string name)\r\n    view\r\n    public\r\n    returns(address)\r\n    {\r\n        return(ownerXname[nameFilter(name)]);\r\n    }\r\n    \r\n    \r\n    function readisnameregistered(string name)\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return(Rounds[roundID].isnameregistered[nameFilter(name)]);\r\n    }\r\n    \r\n    \r\n    function readnameXaddress(address addr)\r\n    view\r\n    public\r\n    returns(bytes32)\r\n    {\r\n        return(nameXaddress[addr]);\r\n    }\r\n    \r\n    \r\n    function readpriceXname(string name)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return(priceXname[nameFilter(name)]*3/2);\r\n    }\r\n    \r\n    \r\n    function readteamXaddr(address adr)\r\n    view\r\n    public\r\n    returns(uint16){\r\n        return(Rounds[roundID].teamXaddr[adr]);\r\n    }\r\n    \r\n    \r\n    function readvalidrollsXteam(uint16 tim)\r\n    view\r\n    public\r\n    returns(uint256){\r\n        return(Rounds[roundID].validrollsXteam[tim]);\r\n    }\r\n    \r\n    \r\n    function readvalidrollsXaddr(address adr)\r\n    view\r\n    public\r\n    returns(uint256){\r\n        return(Rounds[roundID].validrollsXaddr[adr]);\r\n    }\r\n    \r\n    \r\n    function readnationnameXteam()\r\n    view\r\n    public\r\n    returns(bytes32[256]){\r\n        bytes32[256] memory temp;\r\n        for (uint16 i = 0; i<256; i++){\r\n            temp[i]=Rounds[roundID].nationnameXteam[i];\r\n        }\r\n        return(temp);\r\n    }\r\n    \r\n    \r\n    function readcolorXteam()\r\n    view\r\n    public\r\n    returns(uint256[256]){\r\n        uint256[256] memory temp;\r\n        for (uint16 i = 0; i<256; i++){\r\n            temp[i]=Rounds[roundID].colorXteam[i];\r\n        }\r\n        return(temp);\r\n    }\r\n    \r\n    \r\n    function readiscolorregistered(uint256 rgb)\r\n    view\r\n    public\r\n    returns(bool){\r\n        return(Rounds[roundID].iscolorregistered[colorfilter(rgb)]);\r\n    }\r\n    \r\n    \r\n    function readhistoricalrounds()\r\n    view\r\n    public\r\n    returns(bytes32[]){\r\n        bytes32[] memory asdfg=new bytes32[](2*roundID-2);\r\n        for (uint256 i = 1;i<roundID;i++){\r\n            asdfg[2*i]=Rounds[roundID].winner;\r\n            asdfg[2*i+1]=bytes32(Rounds[roundID].pot);\r\n        }\r\n        return asdfg;\r\n    }\r\n    \r\n\r\n     \r\n   /*_____             ______                _   _\r\n    |  __ \\           |  ____|              | | (_)                \r\n    | |  | | _____   _| |__ _   _ _ __   ___| |_ _  ___  _ __  ___ \r\n    | |  | |/ _ \\ \\ / /  __| | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\r\n    | |__| |  __/\\ V /| |  | |_| | | | | (__| |_| | (_) | | | \\__ \\\r\n    |_____/ \\___| \\_/ |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/ */\r\n   \r\n\r\n    //used to load the adjacencies file that's required to block invalid actions\r\n    function addadjacencies(uint16[] indexes,uint16[] numvals,uint16[] adjs)\r\n    public\r\n    {   \r\n        require(msg.sender==admin);\r\n        require(!isactive);\r\n        \r\n        uint cnt=0;\r\n        for (uint i = 0; i<indexes.length;i++){\r\n            for (uint j = 0;j<numvals[i];j++){\r\n                adjacencies[indexes[i]][j]=adjs[cnt];\r\n                cnt++;\r\n            }\r\n        }   \r\n    }\r\n\r\n\r\n    //blocks the add function so dev can't modify the adjacencies after they've been loaded, serves as activate function too\r\n    function finishedloading()\r\n    public\r\n    {\r\n        require(msg.sender==admin);\r\n        require(!isactive);\r\n        \r\n        isactive=true;\r\n        \r\n        //seed the first round\r\n        roundID=1;\r\n        uint256 _rID=roundID;\r\n        //Rounds[_rID].roundtime =roundtime;\r\n        Rounds[_rID].roundstart =block.timestamp;\r\n        Rounds[_rID].beginterritories =beginterritories; \r\n        Rounds[_rID].maxroll = maxroll;\r\n        Rounds[_rID].trucetime = trucetime;\r\n        Rounds[_rID].price = price;\r\n        Rounds[_rID].maxextensiontruce = maxextensiontruce;\r\n    }\r\n    \r\n    \r\n    //admin can change some settings to balance the game if required, they will get into effect at the beggining of a new round\r\n    function changesettings(/*uint256 _roundtime,*/ uint16 _beginterritories, uint16 _maxroll,uint256 _trucetime,uint256 _price,uint256 _maxextensiontruce)\r\n    public\r\n    {\r\n        require(msg.sender==admin);\r\n        //roundtime = _roundtime;\r\n        beginterritories = _beginterritories ;\r\n        maxroll = _maxroll;\r\n        trucetime = _trucetime;\r\n        price = _price;\r\n        maxextensiontruce = _maxextensiontruce;\r\n        \r\n    }\r\n\r\n\r\n    /* _____ _                   _       \r\n      / ____| |                 | |      \r\n     | (___ | |_ _ __ _   _  ___| |_ ___ \r\n      \\___ \\| __| '__| | | |/ __| __/ __|\r\n      ____) | |_| |  | |_| | (__| |_\\__ \\\r\n     |_____/ \\__|_|   \\__,_|\\___|\\__|___/*/\r\n\r\n     \r\n    struct RoundData{\r\n        \r\n        //tracks ownership of the territories\r\n        //encoded in 8bit such that 0=noncolonized and the remaining 255 values reference a team\r\n        //32 territories fit each entry, for a total of 3232, there are only 3231 territories \r\n        //the one that corresponds to the nonexisting ID=0 remains empty\r\n        uint256[101] owners;\r\n        \r\n        \r\n        mapping(address=>uint16) teamXaddr; //return team by address\r\n        //keep track of the rolls to split the pot\r\n        mapping(uint16=>uint256) validrollsXteam; // number of valid rolls by team\r\n        mapping(address=>uint256) validrollsXaddr; //valid rolls by address\r\n        mapping(uint16=>uint256) teampotshare; //money that each team gets at the end of the round is stored here\r\n        mapping(uint16=>bytes32) nationnameXteam;\r\n        uint256 pot;\r\n        \r\n        //1xRGB for map display color\r\n        mapping(uint16=>uint256) colorXteam;\r\n        //track which colors are registered\r\n        mapping(uint256=>bool) iscolorregistered;\r\n        \r\n        \r\n        mapping(bytes32=>bool) isnameregistered; //avoid duplicate nation names within a same round\r\n        \r\n        \r\n        //counter\r\n        uint16 teamcnt;\r\n        \r\n        \r\n        //timers\r\n        uint256 roundstart;\r\n        \r\n        \r\n        //these settings can be modified by admin to balance if required, will get into effect when a new round is started\r\n        uint16 beginterritories; //number of territories to claim at createnation\r\n        uint16 maxroll;// = 6;\r\n        uint256 trucetime;\r\n        uint256 price;\r\n        uint256 maxextensiontruce;\r\n        \r\n        bytes32 winner;\r\n    }\r\n\r\n\r\n    /*______               _       \r\n     |  ____|             | |      \r\n     | |____   _____ _ __ | |_ ___ \r\n     |  __\\ \\ / / _ \\ '_ \\| __/ __|\r\n     | |___\\ V /  __/ | | | |_\\__ \\\r\n     |______\\_/ \\___|_| |_|\\__|___/*/\r\n\r\n     \r\n     event oncreatenation(\r\n        bytes32 leadername,\r\n        bytes32 nationname,\r\n        uint256 color,\r\n        uint16 team,\r\n        uint16[] territories,\r\n        address addr\r\n     );\r\n\r\n     event onroll(\r\n        bytes32 playername,\r\n        bytes32 nationname,\r\n        uint256 rolled,\r\n        uint16 team,\r\n        uint16[] territories,\r\n        address addr\r\n     );\r\n     event onbuyname(\r\n        bytes32 newname,\r\n        uint256 price,\r\n        bytes32 prevname,\r\n        address addr\r\n     );\r\n     event onendround(\r\n     );\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"readpriceXname\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"readteamXaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"readnameXaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nameXaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ownerXname\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readnationnameXteam\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[256]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"switchname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"readvalidrollsXaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxextensiontruce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beginterritories\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endround\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_input\",\"type\":\"string\"}],\"name\":\"nameFilter\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readhistoricalrounds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beginterritories\",\"type\":\"uint16\"},{\"name\":\"_maxroll\",\"type\":\"uint16\"},{\"name\":\"_trucetime\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_maxextensiontruce\",\"type\":\"uint256\"}],\"name\":\"changesettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rID\",\"type\":\"uint256\"}],\"name\":\"getbalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readcolorXteam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[256]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"readisnameregistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"readownerXname\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"RGB\",\"type\":\"uint256\"}],\"name\":\"colorfilter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"territories\",\"type\":\"uint16[]\"},{\"name\":\"team\",\"type\":\"uint16\"}],\"name\":\"roll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"priceXname\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"territories\",\"type\":\"uint16[]\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"RGB\",\"type\":\"uint256\"}],\"name\":\"createnation\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tim\",\"type\":\"uint16\"}],\"name\":\"readvalidrollsXteam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rgb\",\"type\":\"uint256\"}],\"name\":\"readiscolorregistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"indexes\",\"type\":\"uint16[]\"},{\"name\":\"numvals\",\"type\":\"uint16[]\"},{\"name\":\"adjs\",\"type\":\"uint16[]\"}],\"name\":\"addadjacencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isactive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Rounds\",\"outputs\":[{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"teamcnt\",\"type\":\"uint16\"},{\"name\":\"roundstart\",\"type\":\"uint256\"},{\"name\":\"beginterritories\",\"type\":\"uint16\"},{\"name\":\"maxroll\",\"type\":\"uint16\"},{\"name\":\"trucetime\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"maxextensiontruce\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trucetime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishedloading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"buyname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readowners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[101]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"leadername\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"nationname\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"color\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"territories\",\"type\":\"uint16[]\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"oncreatenation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playername\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"nationname\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"rolled\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"territories\",\"type\":\"uint16[]\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"onroll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newname\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prevname\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"onbuyname\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onendround\",\"type\":\"event\"}]","ContractName":"RISK","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f923e702224e088c07ac94bd3182c6ac9bcac91f72de878d9a2c54760905192b"}]}