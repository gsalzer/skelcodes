{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n    function transfer(address receiver, uint amount) public;\r\n    function balanceOf(address receiver)public returns(uint);\r\n}\r\n\r\n///@title Axioms-Airdrops\r\n///@author  Lucasxhy & Kafcioo\r\ncontract Axioms {\r\n    Airdrop [] public airdrops;\r\n    address owner;\r\n    uint idCounter;\r\n    \r\n    ///@notice  Set the creator of the smart contract to be its sole owner\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    \r\n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\r\n    modifier minEth {\r\n        require(msg.value >= 2000); //Change this to amount of eth we want in GWEI!\r\n        _;\r\n    }\r\n    ///@notice  Modifier that only allows the owner to execute a function\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\r\n    struct Airdrop {\r\n        uint id;\r\n        uint tokenAmount;\r\n        string name;\r\n        uint countDown;\r\n        address distributor;\r\n        Token tokenSC;\r\n    }\r\n\r\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\r\n   function addNewAirdrop(\r\n   uint _tokenAmount,\r\n   string _name,\r\n   uint _countDown,\r\n   address  _smartContract\r\n   \r\n   )\r\n   public\r\n   minEth\r\n   payable\r\n   {\r\n       Token t = Token(_smartContract);\r\n       if(t.balanceOf(this)>=_tokenAmount)\r\n        uint lastIndex = airdrops.length++;\r\n        Airdrop storage airdrop = airdrops[lastIndex];\r\n        airdrop.id =idCounter;\r\n        airdrop.tokenAmount = _tokenAmount;\r\n        airdrop.name=_name;\r\n        airdrop.countDown=_countDown;\r\n        airdrop.distributor = msg.sender;\r\n        airdrop.tokenSC = Token(_smartContract);\r\n        idCounter = airdrop.id+1;\r\n   }\r\n\r\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\r\n    ///@param index  The airdrop to distribute based in the the array in which is saved\r\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\r\n    ///@param _vals  The set of values to be distributed to each address in array form\r\n    function distributeVariable(\r\n        uint index,\r\n        address[] _addrs,\r\n        uint[] _vals\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\r\n            Airdrop memory airdrop = airdrops[index];\r\n            for(uint i = 0; i < _addrs.length; ++i) {\r\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\r\n            }\r\n        } else revert(\"Airdrop was NOT added\");\r\n    }\r\n\r\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\r\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\r\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\r\n    function distributeFixed(\r\n        uint index,\r\n        address[] _addrs,\r\n        uint _amoutToEach\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\r\n            Airdrop memory airdrop = airdrops[index];\r\n            for(uint i = 0; i < _addrs.length; ++i) {\r\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\r\n            }\r\n        } else revert(\"Airdrop was NOT added\");\r\n    }\r\n    \r\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\r\n    ///@param index  The airdrop to distribute based in the the array in which is saved\r\n    ///@param _amount  The value to be distributed to each address in array form.\r\n    function withdrawTokens(\r\n        uint index,\r\n        uint _amount\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        Airdrop memory airdrop = airdrops[index];\r\n        airdrop.tokenSC.transfer(owner,_amount);\r\n    }\r\n    \r\n    ///@notice  Determines whether an aidrop is due to be distributed or not.\r\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\r\n   function timeGone(uint index) private view returns(bool){\r\n      Airdrop memory airdrop = airdrops[index];\r\n      uint timenow=now;\r\n      if ( airdrop.countDown <timenow){\r\n          return (true);\r\n      }else return (false);\r\n    }\r\n  \r\n    ///@notice  Get the balance of a specific token within the smart contracts\r\n   function getTokensBalance(uint index) private view returns(uint) {\r\n        Airdrop memory airdrop = airdrops[index];\r\n        Token t = Token(airdrop.tokenSC);\r\n        return (t.balanceOf(this));\r\n    }\r\n  \r\n  function withdrawLeftOverEth (\r\n      uint amount,\r\n      address receiver\r\n    )\r\n      public \r\n      onlyOwner\r\n   {\r\n      receiver.transfer(amount);\r\n   }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_amoutToEach\",\"type\":\"uint256\"}],\"name\":\"distributeFixed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdrops\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"countDown\",\"type\":\"uint256\"},{\"name\":\"distributor\",\"type\":\"address\"},{\"name\":\"tokenSC\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_vals\",\"type\":\"uint256[]\"}],\"name\":\"distributeVariable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_countDown\",\"type\":\"uint256\"},{\"name\":\"_smartContract\",\"type\":\"address\"}],\"name\":\"addNewAirdrop\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawLeftOverEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Axioms","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://71d3064aae537cf11033f467c250cdff237564891cf253fb45a5f2ce9c013427"}]}