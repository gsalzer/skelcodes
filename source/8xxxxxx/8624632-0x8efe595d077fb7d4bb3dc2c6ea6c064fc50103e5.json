{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\n\n\ninterface Allocator {\n    \n    function allocate()\n    external\n    view\n    returns (uint256);\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract RBACed {\n    using Roles for Roles.Role;\n\n    event RoleAdded(string _role);\n    event RoleAccessorAdded(string _role, address indexed _address);\n    event RoleAccessorRemoved(string _role, address indexed _address);\n\n    string constant public OWNER_ROLE = \"OWNER\";\n\n    string[] public roles;\n    mapping(bytes32 => uint256) roleIndexByName;\n    mapping(bytes32 => Roles.Role) private roleByName;\n\n    \n    constructor()\n    public\n    {\n        \n        _addRole(OWNER_ROLE);\n\n        \n        _addRoleAccessor(OWNER_ROLE, msg.sender);\n    }\n\n    modifier onlyRoleAccessor(string memory _role) {\n        require(isRoleAccessor(_role, msg.sender), \"RBACed: sender is not accessor of the role\");\n        _;\n    }\n\n    \n    \n    function rolesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return roles.length;\n    }\n\n    \n    \n    \n    function isRole(string memory _role)\n    public\n    view\n    returns (bool)\n    {\n        return 0 != roleIndexByName[_role2Key(_role)];\n    }\n\n    \n    \n    function addRole(string memory _role)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        _addRole(_role);\n\n        \n        emit RoleAdded(_role);\n    }\n\n    \n    \n    \n    \n    function isRoleAccessor(string memory _role, address _address)\n    public\n    view\n    returns (bool)\n    {\n        return roleByName[_role2Key(_role)].has(_address);\n    }\n\n    \n    \n    \n    function addRoleAccessor(string memory _role, address _address)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        _addRoleAccessor(_role, _address);\n\n        \n        emit RoleAccessorAdded(_role, _address);\n    }\n\n    \n    \n    \n    function removeRoleAccessor(string memory _role, address _address)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        roleByName[_role2Key(_role)].remove(_address);\n\n        \n        emit RoleAccessorRemoved(_role, _address);\n    }\n\n    function _addRole(string memory _role)\n    internal\n    {\n        if (0 == roleIndexByName[_role2Key(_role)]) {\n            roles.push(_role);\n            roleIndexByName[_role2Key(_role)] = roles.length;\n        }\n    }\n\n    function _addRoleAccessor(string memory _role, address _address)\n    internal\n    {\n        roleByName[_role2Key(_role)].add(_address);\n    }\n\n    function _role2Key(string memory _role)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_role));\n    }\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\ncontract BountyFund is RBACed {\n    using SafeMath for uint256;\n\n    event ResolutionEngineSet(address indexed _resolutionEngine);\n    event TokensDeposited(address indexed _wallet, uint256 _amount, uint256 _balance);\n    event TokensAllocated(address indexed _wallet, address indexed _allocator,\n        uint256 _amount, uint256 _balance);\n    event Withdrawn(address indexed _wallet, uint256 _amount);\n\n    ERC20 public token;\n\n    address public operator;\n    address public resolutionEngine;\n\n    \n    constructor(address _token, address _operator)\n    public\n    {\n        \n        token = ERC20(_token);\n\n        \n        operator = _operator;\n    }\n\n    modifier onlyResolutionEngine() {\n        require(msg.sender == resolutionEngine, \"BountyFund: sender is not the defined resolution engine\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"BountyFund: sender is not the defined operator\");\n        _;\n    }\n\n    \n    \n    \n    function setResolutionEngine(address _resolutionEngine)\n    public\n    {\n        require(address(0) != _resolutionEngine, \"BountyFund: resolution engine argument is zero address\");\n        require(address(0) == resolutionEngine, \"BountyFund: resolution engine has already been set\");\n\n        \n        resolutionEngine = _resolutionEngine;\n\n        \n        emit ResolutionEngineSet(_resolutionEngine);\n    }\n\n    \n    \n    \n    function depositTokens(uint256 _amount)\n    public\n    {\n        \n        token.transferFrom(msg.sender, address(this), _amount);\n\n        \n        emit TokensDeposited(msg.sender, _amount, token.balanceOf(address(this)));\n    }\n\n    \n    \n    function allocateTokens(address _allocator)\n    public\n    onlyResolutionEngine\n    returns (uint256)\n    {\n        \n        uint256 amount = Allocator(_allocator).allocate();\n\n        \n        token.transfer(msg.sender, amount);\n\n        \n        emit TokensAllocated(msg.sender, _allocator, amount, token.balanceOf(address(this)));\n\n        \n        return amount;\n    }\n\n    \n    \n    function withdraw(address _wallet)\n    public\n    onlyOperator\n    {\n        \n        uint256 amount = token.balanceOf(address(this));\n\n        \n        token.transfer(_wallet, amount);\n\n        \n        emit Withdrawn(_wallet, amount);\n    }\n}\n\nlibrary ConstantsLib {\n    \n    function PARTS_PER()\n    public\n    pure\n    returns (uint256)\n    {\n        return 1e18;\n    }\n}\n\ncontract FractionalBalanceAllocator is Allocator, RBACed {\n    using SafeMath for uint256;\n\n    event Frozen();\n    event FractionSet(uint256 _fraction);\n\n    uint256 public fraction;\n    bool public frozen;\n\n    constructor(uint256 _fraction)\n    public\n    {\n        \n        require(_fraction <= ConstantsLib.PARTS_PER(),\n            \"FractionalBalanceAllocator: fraction is greater than entirety\");\n\n        \n        fraction = _fraction;\n    }\n\n    modifier onlyNotFrozen() {\n        require(!frozen, \"FractionalBalanceAllocator: is frozen\");\n        _;\n    }\n\n    \n    \n    function freeze()\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        frozen = true;\n\n        \n        emit Frozen();\n    }\n\n    \n    \n    function setFraction(uint256 _fraction)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    onlyNotFrozen\n    {\n        \n        require(_fraction <= ConstantsLib.PARTS_PER(),\n            \"FractionalBalanceAllocator: fraction is greater than entirety\");\n\n        \n        fraction = _fraction;\n\n        \n        emit FractionSet(fraction);\n    }\n\n    \n    function allocate()\n    public\n    view\n    returns (uint256)\n    {\n        return BountyFund(msg.sender).token()\n        .balanceOf(address(msg.sender))\n        .mul(fraction)\n        .div(ConstantsLib.PARTS_PER());\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"setFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addRoleAccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeRoleAccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rolesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isRoleAccessor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fraction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"FractionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RoleAccessorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RoleAccessorRemoved\",\"type\":\"event\"}]","ContractName":"FractionalBalanceAllocator","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000b1a2bc2ec50000","Library":"ConstantsLib:005615cb698d8e8af5ede43cc5a9507285426ccb","LicenseType":"","SwarmSource":"bzzr://1dd8870381607186fd8bcd6f47de2bda15c5b35974febe4da950e189590853b1"}]}