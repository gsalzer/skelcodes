{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n              _.-+.\r\n         _.-\"\"     '.\r\n      :\"\"       o    '.\r\n      |\\       m       '.\r\n      | \\     o       _.+\r\n      |  '.  F    _.-\"  |\r\n      |    \\  _.-\"      |\r\n      |     +\"       e  |\r\n       \\    |      b    |\r\n        \\   |    u     .+\r\n         \\  |  C    .-'\r\n          \\ |    .-'\r\n           \\| .-'\r\n            +'\r\n            \r\nThis contract is an evolution of Fomo3D Long:\r\nhttps://etherscan.io/address/0xa62142888aba8370742be823c1782d17a0389da1#code\r\nhttps://fomo3d.hostedwiki.co/pages/FAQ\r\n\r\nModifications:\r\n- Replaced \"PlayerBook\" with FomoCube username contract\r\n- Removed staking requirement\r\n- Removed teams\r\n- Removed airdrops\r\n|\r\n--- New ETH distribution:\r\n// 50% for POLY holders, 20% for the jackpot\r\n// 15% for CUBE holders, 10% for referrer or CUBE holders\r\n// 5% for the developers <3\r\n|\r\n--- Replaced \"Pot\" system with a jackpot and \"increment\":\r\n|\r\n- The increment is the minimum purchase to become the leader (in POLY)\r\n|\r\n- The increment starts at 0 and increases by 100 for every ETH in the jackpot\r\n|\r\n- The jackpot is awarded to the leader when the timer runs out\r\n|\r\n- Each new leader increases the round timer by 30 minutes, and the maximum is 72 hours\r\n|\r\n- POLY follows the same price formula as \"Fomo3D Long\",\r\n- thus the cost of becoming the leader is affected by price and increment\r\n|\r\n- For example:\r\n~~ Jackpot of 10 ETH --> Becoming the leader costs 0.14 ETH\r\n~~ Jackpot of 50 ETH --> Becoming the leader costs 1.44 ETH\r\n~~ Jackpot of 100 ETH -> Becoming the leader costs 4.02 ETH\r\n|\r\n~~~\r\n  This system is designed to end the round before players lose interest.\r\n  The increasing cost of becoming the leader forces whales to fight for the jackpot -\r\n  - benefitting all previous buyers.\r\n~~~\r\n|\r\n>>> https://fomocube.io/\r\n\r\n */\r\n \r\n//==============================================================================\r\n//     _    _  _ _|_ _  .\r\n//    (/_\\/(/_| | | _\\  .\r\n//==============================================================================\r\ncontract PolyFomoEvents {\r\n    // fired at end of buy or reload\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 polyBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 cubeAmount,\r\n        uint256 genAmount,\r\n        uint256 potAmount\r\n    );\r\n    \r\n    // fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a withdraw forces end round to be ran\r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot\r\n    );\r\n    \r\n    // fired whenever a player tries a buy after round timer \r\n    // hit zero, and causes end round to be ran.\r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot\r\n    );\r\n    \r\n    // fired whenever a player tries a reload after round timer \r\n    // hit zero, and causes end round to be ran.\r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot\r\n    );\r\n    \r\n    // fired whenever an affiliate is paid\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n}\r\n\r\n//==============================================================================\r\n//   _ _  _ _|_ _ _  __|_   _ _ _|_    _   .\r\n//  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  .\r\n//====================================|=========================================\r\n\r\ncontract modularLong is PolyFomoEvents {}\r\n\r\ncontract PolyFomo is modularLong {\r\n    using SafeMath for *;\r\n    using PolygonCalcLong for uint256;\r\n    \r\n    address private comAddress_;\r\n    CubeInterface private cube;\r\n    UsernameInterface private username;\r\n    \r\n//==============================================================================\r\n//     _ _  _  |`. _     _ _ |_ | _  _  .\r\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n//=================_|===========================================================\r\n    string constant public name = \"PolyFomo\";\r\n    string constant public symbol = \"POLY\";\r\n    uint256 constant private rndExtra_ = 24 hours;              // Countdown before open\r\n    uint256 constant private rndInit_ = 1 hours;                // round timer starts at this\r\n    uint256 constant private rndInc_ = 30 minutes;              // every new leader adds 30 minutes to the timer\r\n    uint256 constant private rndMax_ = 72 hours;                // max length a round timer can be\r\n    \r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes)\r\n//=============================|================================================\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n    uint256 public pID_;  // total number of players\r\n//****************\r\n// PLAYER DATA \r\n//****************\r\n    mapping (address => uint256) public pIDxAddr_;                                               // (addr => pID) returns player id by address\r\n    mapping (uint256 => PolyFomoDatasets.Player) public plyr_;                                   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => PolyFomoDatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n\r\n//****************\r\n// ROUND DATA \r\n//****************\r\n    mapping (uint256 => PolyFomoDatasets.Round) public round_;              // (rID => data) round data\r\n    uint256 public rndEth_;\r\n//****************\r\n// TEAM FEE DATA \r\n//****************\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================\r\n    constructor(address usernameAddress, address cubeAddress, address comAddress)\r\n        public\r\n    {\r\n        username = UsernameInterface(usernameAddress);\r\n        cube = CubeInterface(cubeAddress);\r\n        comAddress_ = comAddress;\r\n        \r\n        // PURCHASES\r\n        // 50% for POLY holders, 20% for jackpot, 15% for CUBE holders, 10% for referral or CUBE holders, 5% dev fee\r\n        \r\n        // Open the gates\r\n        rID_ = 1;\r\n        round_[1].strt = cube.startTime() + rndExtra_;\r\n        round_[1].end = cube.startTime() + rndInit_ + rndExtra_;\r\n\t}\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n    \r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================\r\n    /**\r\n     * @dev emergency buy uses last stored affiliate ID\r\n     */\r\n    function()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        PolyFomoDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n            \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // buy core \r\n        buyCore(_pID, plyr_[_pID].laff, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev converts all incoming ethereum to poly.\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     */\r\n    \r\n    function buyXaddr(address _affCode)\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        PolyFomoDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            if (_affID == 0) {\r\n                _affID = registerReferrer(_affCode);\r\n            }\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // buy core \r\n        buyCore(_pID, _affID, _eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev essentially the same as buy, but instead of you sending ether \r\n     * from your wallet, it uses your unwithdrawn earnings.\r\n     * @param _affCode the ID/address/name of the player who gets the affiliate fee\r\n     * @param _eth amount of earnings to use (remainder returned to gen vault)\r\n     */\r\n    \r\n    function reLoadXaddr(address _affCode, uint256 _eth)\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        public\r\n    {\r\n        // set up our tx event data\r\n        PolyFomoDatasets.EventReturns memory _eventData_;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // set up new referrer if necessary\r\n            if (_affID == 0) {\r\n                _affID = registerReferrer(_affCode);\r\n            }\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // reload core\r\n        reLoadCore(_pID, _affID, _eth, _eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     */\r\n    function withdraw()\r\n        isHuman()\r\n        public\r\n    {\r\n        // setup local rID \r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // set up our tx event data\r\n            PolyFomoDatasets.EventReturns memory _eventData_;\r\n            \r\n            // end the round (distributes pot)\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            \r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);    \r\n            \r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n            \r\n            // fire withdraw and distribute event\r\n            emit PolyFomoEvents.onWithdrawAndDistribute\r\n            (\r\n                msg.sender, \r\n                username.getNameByAddress(plyr_[_pID].addr), \r\n                _eth, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot\r\n            );\r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            \r\n            // fire withdraw event\r\n            emit PolyFomoEvents.onWithdraw(_pID, msg.sender, username.getNameByAddress(plyr_[_pID].addr), _eth, _now);\r\n        }\r\n    }\r\n    \r\n//==============================================================================\r\n//     _  _ _|__|_ _  _ _  .\r\n//    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n//=====_|=======================================================================\r\n\r\n    /**\r\n     * @dev return minimum purchase in POLY for 1 timer increment\r\n     * @return minimum purchase in POLY for 1 timer increment (in wei format)\r\n     */\r\n\r\n    function getIncrementPrice()\r\n        public \r\n        view\r\n        returns(uint256)\r\n    {  \r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab pot\r\n        uint256 _pot = round_[_rID].pot;\r\n        \r\n        return (_pot / 1000000000000000000).mul(100000000000000000000);\r\n    }\r\n\r\n    /**\r\n     * @dev return the price buyer will pay for next 1 individual poly.\r\n     * @return price for next poly bought (in wei format)\r\n     */\r\n    function getBuyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {  \r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].poly.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    \r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node \r\n     * provider\r\n     * @return time left in seconds\r\n     */\r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].strt).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev returns player earnings per vaults \r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n     */\r\n    function getPlayerVaults(uint256 _pID)\r\n        public\r\n        view\r\n        returns(uint256 ,uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID)\r\n            {\r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add(round_[_rID].pot),\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return\r\n                (\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return\r\n            (\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n                plyr_[_pID].aff\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * solidity hates stack limits.  this lets us avoid that hate \r\n     */\r\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round_[_rID].mask.mul(plyrRnds_[_pID][_rID].poly) / 1000000000000000000;\r\n    }\r\n    \r\n    /**\r\n     * @dev returns all current round info needed for front end\r\n     * @return round id \r\n     * @return total poly for round \r\n     * @return time round ends\r\n     * @return time round started\r\n     * @return current pot \r\n     * @return current player in leads address \r\n     * @return current player in leads name\r\n     * @return eth spent in current round\r\n     */\r\n    function getCurrentRoundInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        return\r\n        (\r\n            _rID,                                                     //0\r\n            round_[_rID].poly,                                        //1\r\n            round_[_rID].end,                                         //2\r\n            round_[_rID].strt,                                        //3\r\n            round_[_rID].pot,                                         //4\r\n            plyr_[round_[_rID].plyr].addr,                            //5\r\n            username.getNameByAddress(plyr_[round_[_rID].plyr].addr), //6\r\n            rndEth_                                                   //7\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will \r\n     * use msg.sender \r\n     * @param _addr address of the player you want to lookup \r\n     * @return player ID \r\n     * @return player name\r\n     * @return poly owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault \r\n     * @return affiliate vault \r\n     * @return player round eth\r\n     */\r\n    function getPlayerInfoByAddress(address _addr)\r\n        public \r\n        view \r\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        return\r\n        (\r\n            _pID,                               //0\r\n            username.getNameByAddress(_addr),   //1\r\n            plyrRnds_[_pID][_rID].poly,         //2\r\n            plyr_[_pID].win,                    //3\r\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4\r\n            plyr_[_pID].aff,                    //5\r\n            plyrRnds_[_pID][_rID].eth           //6\r\n        );\r\n    }\r\n\r\n//==============================================================================\r\n//     _ _  _ _   | _  _ . _  .\r\n//    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine)\r\n//=====================_|=======================================================\r\n    /**\r\n     * @dev logic runs whenever a buy order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not\r\n     */\r\n    function buyCore(uint256 _pID, uint256 _affID, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        // if round is active\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // call core \r\n            core(_rID, _pID, msg.value, _affID, _eventData_);\r\n        \r\n        // if round is not active     \r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) \r\n            {\r\n                // end the round (distributes pot) & start new round\r\n                round_[_rID].ended = true;\r\n                _eventData_ = endRound(_eventData_);\r\n                \r\n                // build event data\r\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                \r\n                // fire buy and distribute event \r\n                emit PolyFomoEvents.onBuyAndDistribute\r\n                (\r\n                    msg.sender, \r\n                    username.getNameByAddress(plyr_[_pID].addr), \r\n                    msg.value, \r\n                    _eventData_.compressedData, \r\n                    _eventData_.compressedIDs, \r\n                    _eventData_.winnerAddr, \r\n                    _eventData_.winnerName, \r\n                    _eventData_.amountWon, \r\n                    _eventData_.newPot\r\n                );\r\n            }\r\n            \r\n            // put eth in players vault \r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev logic runs whenever a reload order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not \r\n     */\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // get earnings from all vaults and return unused to gen vault\r\n            // because we use a custom safemath library.  this will throw if player \r\n            // tried to spend more eth than they have.\r\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            \r\n            // call core \r\n            core(_rID, _pID, _eth, _affID, _eventData_);\r\n        \r\n        // if round is not active and end round needs to be ran   \r\n        } else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            // end the round (distributes pot) & start new round\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n                \r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                \r\n            // fire buy and distribute event \r\n            emit PolyFomoEvents.onReLoadAndDistribute\r\n            (\r\n                msg.sender, \r\n                username.getNameByAddress(plyr_[_pID].addr), \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev this is the core logic for any buy/reload that happens while a round \r\n     * is live.\r\n     */\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // if player is new to round\r\n        if (plyrRnds_[_pID][_rID].poly == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n        \r\n        // early round eth limiter \r\n        if (round_[_rID].eth < 30000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\r\n        {\r\n            uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\r\n            uint256 _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        \r\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\r\n        if (_eth > 1000000000) \r\n        {\r\n            \r\n            // mint the new poly\r\n            uint256 _poly = (round_[_rID].eth).polyRec(_eth);\r\n            \r\n            if (_poly >= getIncrementPrice())\r\n            {\r\n                updateTimer(_rID);\r\n\r\n                // set new leaders\r\n                if (round_[_rID].plyr != _pID)\r\n                    round_[_rID].plyr = _pID;  \r\n                \r\n                // set the new leader bool to true\r\n                _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            }\r\n            \r\n            // update player \r\n            plyrRnds_[_pID][_rID].poly = _poly.add(plyrRnds_[_pID][_rID].poly);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n            \r\n            // update round\r\n            round_[_rID].poly = _poly.add(round_[_rID].poly);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndEth_ = _eth.add(rndEth_);\r\n    \r\n            // distribute eth\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _poly, _eventData_);\r\n            \r\n            // call end tx function to fire end tx event.\r\n            endTx(_pID, _eth, _poly, _eventData_);\r\n        }\r\n    }\r\n//==============================================================================\r\n//     _ _ | _   | _ _|_ _  _ _  .\r\n//    (_(_||(_|_||(_| | (_)| _\\  .\r\n//==============================================================================\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].poly)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns the amount of poly you would get given an amount of eth. \r\n     * @param _rID round ID you want price for\r\n     * @param _eth amount of eth sent in \r\n     * @return poly received \r\n     */\r\n    function calcPolyReceived(uint256 _rID, uint256 _eth)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].eth).polyRec(_eth) );\r\n        else // rounds over.  need poly for new round\r\n            return ( (_eth).poly() );\r\n    }\r\n    \r\n    /** \r\n     * @dev returns current eth price for X poly.  \r\n     * @param _poly number of poly desired (in 18 decimal format)\r\n     * @return amount of eth needed to send\r\n     */\r\n    function iWantXPoly(uint256 _poly)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // are we in a round?\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].poly.add(_poly)).ethRec(_poly) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_poly).eth() );\r\n    }\r\n//==============================================================================\r\n//    _|_ _  _ | _  .\r\n//     | (_)(_)|_\\  .\r\n//==============================================================================\r\n        \r\n    /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID \r\n     */\r\n    function determinePID(PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (PolyFomoDatasets.EventReturns memory)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        if (_pID == 0)\r\n        {\r\n            pID_++;\r\n            pIDxAddr_[msg.sender] = pID_;\r\n            plyr_[pID_].addr = msg.sender;\r\n            \r\n            // set the new player bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 1;\r\n        }\r\n        \r\n        return (_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev registers a non-player referrer\r\n     * @return pID \r\n     */\r\n    function registerReferrer(address _affCode)\r\n        private\r\n        returns (uint256 affID)\r\n    {\r\n        pID_++;\r\n        pIDxAddr_[_affCode] = pID_;\r\n        plyr_[pID_].addr = _affCode;\r\n        \r\n        return pID_;\r\n    }\r\n    \r\n    /**\r\n     * @dev decides if round end needs to be run & new round started.  and if \r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer(uint256 _pID, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (PolyFomoDatasets.EventReturns memory)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n            \r\n        // set the joined round bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev ends the round. manages paying out winner/splitting up pot\r\n     */\r\n    function endRound(PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (PolyFomoDatasets.EventReturns memory)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab our winning player\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        \r\n        // Entire 20% of buys / pot value\r\n        uint256 _win = round_[_rID].pot;\r\n\r\n        // pay our winner\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        \r\n        // prepare event data\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = username.getNameByAddress(plyr_[_winPID].addr);\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.newPot = 0;\r\n        \r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndInit_);\r\n        round_[_rID].pot = 0;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev increment timer if poly requirement is met\r\n     */\r\n    function updateTimer(uint256 _rID)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // calculate time based on number of poly bought\r\n        uint256 _newTime;\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = rndInc_.add(_now);\r\n        else\r\n            _newTime = rndInc_.add(round_[_rID].end);\r\n        \r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n\r\n    /**\r\n     * @dev distributes eth based on fees to com, aff, and cube\r\n     */\r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(PolyFomoDatasets.EventReturns memory)\r\n    {       \r\n        uint256 _cube;\r\n    \r\n        // 5% for the developers :)\r\n        uint256 _com = _eth / 20;\r\n        comAddress_.transfer(_com);\r\n        \r\n        // 10% for aff or CUBE holders\r\n        uint256 _aff = _eth / 10;\r\n        \r\n        if (_affID != _pID && _affID != 0) {\r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit PolyFomoEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, username.getNameByAddress(plyr_[_affID].addr), _rID, _pID, _aff, now);\r\n        } else {\r\n            _cube = _aff;\r\n        }\r\n        \r\n        // 15% for CUBE holders\r\n        _cube = _cube.add((_eth.mul(15)) / (100));\r\n        if (_cube > 0)\r\n        {\r\n            // distribute to CUBE\r\n            cube.distribute.value(_cube)();\r\n            \r\n            // set up event data\r\n            _eventData_.cubeAmount = _cube.add(_eventData_.cubeAmount);\r\n        }\r\n        \r\n        return(_eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev distributes eth based on fees to gen and pot\r\n     */\r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _poly, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns(PolyFomoDatasets.EventReturns memory)\r\n    {\r\n        // 50% for POLY holders\r\n        uint256 _gen = (_eth.mul(50)) / 100;\r\n        \r\n        // update eth balance (eth = eth - (developers (5%) + aff share (10%)) + cube share (15%))\r\n        _eth = _eth.sub((_eth.mul(30)) / 100);\r\n        \r\n        // 20% for winner\r\n        uint256 _pot = _eth.sub(_gen);\r\n        \r\n        // distribute gen share (thats what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _poly);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        // add the 20% + dust\r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n        \r\n        // set up event data\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    /**\r\n     * @dev updates masks for round and player when poly are bought\r\n     * @return dust left over \r\n     */\r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _poly)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here.  is were going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n            \r\n            the player will have an additional mask that basically says \"based\r\n            on the rounds mask, my shares, and how much i've already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n        \r\n        // calc profit per poly & round mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].poly);\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n            \r\n        // calculate player earning from their own buy (only based on the poly\r\n        // they just bought).  & update player earnings mask\r\n        uint256 _pearn = (_ppt.mul(_poly)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_poly)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n        \r\n        // calculate & return dust\r\n        return(_gen.sub((_ppt.mul(round_[_rID].poly)) / (1000000000000000000)));\r\n    }\r\n    \r\n    /**\r\n     * @dev adds up unmasked earnings, & vault earnings, sets them all to 0\r\n     * @return earnings in wei format\r\n     */\r\n    function withdrawEarnings(uint256 _pID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        // from vaults \r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n    \r\n    /**\r\n     * @dev prepares compression data and fires event for buy or reload tx's\r\n     */\r\n    function endTx(uint256 _pID, uint256 _eth, uint256 _poly, PolyFomoDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n        \r\n        emit PolyFomoEvents.onEndTx\r\n        (\r\n            _eventData_.compressedData,\r\n            _eventData_.compressedIDs,\r\n            username.getNameByAddress(plyr_[_pID].addr),\r\n            msg.sender,\r\n            _eth,\r\n            _poly,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.winnerName,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.cubeAmount,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount\r\n        );\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary PolyFomoDatasets {\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 cubeAmount;         // amount distributed to cube\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 poly;   // poly\r\n        uint256 mask;   // player mask \r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 poly;   // poly\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  |  _      _ _ | _  .\r\n//  |<(/_\\/  (_(_||(_  .\r\n//=======/======================================================================\r\nlibrary PolygonCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of poly received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function polyRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(poly((_curEth).add(_newEth)).sub(poly(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X poly \r\n     * @param _curPoly current amount of poly that exist \r\n     * @param _sellPoly amount of poly you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curPoly, uint256 _sellPoly)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curPoly)).sub(eth(_curPoly.sub(_sellPoly))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many poly would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of poly that would exist\r\n     */\r\n    function poly(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of poly\r\n     * @param _poly number of poly \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _poly) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_poly.sq()).add(((149999843750000).mul(_poly.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n//==============================================================================\r\n//  . _ _|_ _  _ |` _  _ _  _  .\r\n//  || | | (/_| ~|~(_|(_(/__\\  .\r\n//==============================================================================\r\n\r\ninterface UsernameInterface {\r\n    function getNameByAddress(address _addr) external view returns (bytes32);\r\n}\r\n\r\ninterface CubeInterface {\r\n    function distribute() external payable;\r\n    function startTime() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXaddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"poly\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_poly\",\"type\":\"uint256\"}],\"name\":\"iWantXPoly\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcPolyReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"poly\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIncrementPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rndEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"usernameAddress\",\"type\":\"address\"},{\"name\":\"cubeAddress\",\"type\":\"address\"},{\"name\":\"comAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"polyBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cubeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"}]","ContractName":"PolyFomo","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000006f58215dadb1ed27446aa132b622ebdf5b4cca000000000000000000000000eb6aaeff15f1faa7acecb0627364294fb085fbab00000000000000000000000098a32ffc3c90d24236b32090498e1a241b3d257c","Library":"","LicenseType":"None","SwarmSource":"bzzr://e9550dab6466b194a0a4fdf7a799692a641fc77d80ccad32e7b8d50841029679"}]}