{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: contracts/extensions/BrokerExtension.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface Broker {\r\n    function owner() external returns (address);\r\n    function isAdmin(address _user) external returns(bool);\r\n    function markNonce(uint256 _nonce) external;\r\n}\r\n\r\ncontract BrokerExtension is ReentrancyGuard {\r\n    Broker public broker;\r\n\r\n    modifier onlyAdmin() {\r\n        require(broker.isAdmin(msg.sender), \"Invalid msg.sender\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(broker.owner() == msg.sender, \"Invalid msg.sender\");\r\n        _;\r\n    }\r\n\r\n    function initializeBroker(address _brokerAddress) external {\r\n        require(_brokerAddress != address(0), \"Invalid _brokerAddress\");\r\n        require(address(broker) == address(0), \"Broker already set\");\r\n        broker = Broker(_brokerAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/math/SafeMath.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface MarketDapp {\r\n    // Returns the address to approve tokens for\r\n    function tokenReceiver(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses) external view returns(address);\r\n    function trade(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses, address payable recipient) external payable;\r\n}\r\n\r\n/// @title Util functions for the BrokerV2 contract for Switcheo Exchange\r\n/// @author Switcheo Network\r\n/// @notice Functions were moved from the BrokerV2 contract into this contract\r\n/// so that the BrokerV2 contract would not exceed the maximum contract size of\r\n/// 24 KB.\r\nlibrary Utils {\r\n    using SafeMath for uint256;\r\n\r\n    // The constants for EIP-712 are precompiled to reduce contract size,\r\n    // the original values are left here for reference and verification.\r\n    //\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"EIP712Domain(\",\r\n    //         \"string name,\",\r\n    //         \"string version,\",\r\n    //         \"uint256 chainId,\",\r\n    //         \"address verifyingContract,\",\r\n    //         \"bytes32 salt\",\r\n    //     \")\"\r\n    // ));\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n    //\r\n    // bytes32 public constant CONTRACT_NAME = keccak256(\"Switcheo Exchange\");\r\n    // bytes32 public constant CONTRACT_VERSION = keccak256(\"2\");\r\n    // uint256 public constant CHAIN_ID = 3; // TODO: Update this before deploying\r\n    // address public constant VERIFYING_CONTRACT = address(1); // TODO: Update this before deploying\r\n    // bytes32 public constant SALT = keccak256(\"switcheo-eth-salt\");\r\n\r\n    // bytes32 public constant DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n    //     EIP712_DOMAIN_TYPEHASH,\r\n    //     CONTRACT_NAME,\r\n    //     CONTRACT_VERSION,\r\n    //     CHAIN_ID,\r\n    //     VERIFYING_CONTRACT,\r\n    //     SALT\r\n    // ));\r\n    bytes32 public constant DOMAIN_SEPARATOR = 0x14f697e312cdba1c10a1eb5c87d96fa22b63aef9dc39592568387471319ea630;\r\n\r\n    // bytes32 public constant OFFER_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Offer(\",\r\n    //         \"address maker,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant OFFER_TYPEHASH = 0xf845c83a8f7964bc8dd1a092d28b83573b35be97630a5b8a3b8ae2ae79cd9260;\r\n\r\n    // bytes32 public constant CANCEL_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Cancel(\",\r\n    //         \"bytes32 offerHash,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant CANCEL_TYPEHASH = 0x46f6d088b1f0ff5a05c3f232c4567f2df96958e05457e6c0e1221dcee7d69c18;\r\n\r\n    // bytes32 public constant FILL_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Fill(\",\r\n    //         \"address filler,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant FILL_TYPEHASH = 0x5f59dbc3412a4575afed909d028055a91a4250ce92235f6790c155a4b2669e99;\r\n\r\n    // The Ether token address is set as the constant 0x00 for backwards\r\n    // compatibility\r\n    address private constant ETHER_ADDR = address(0);\r\n\r\n    uint256 private constant mask8 = ~(~uint256(0) << 8);\r\n    uint256 private constant mask16 = ~(~uint256(0) << 16);\r\n    uint256 private constant mask24 = ~(~uint256(0) << 24);\r\n    uint256 private constant mask32 = ~(~uint256(0) << 32);\r\n    uint256 private constant mask40 = ~(~uint256(0) << 40);\r\n    uint256 private constant mask48 = ~(~uint256(0) << 48);\r\n    uint256 private constant mask56 = ~(~uint256(0) << 56);\r\n    uint256 private constant mask120 = ~(~uint256(0) << 120);\r\n    uint256 private constant mask128 = ~(~uint256(0) << 128);\r\n    uint256 private constant mask136 = ~(~uint256(0) << 136);\r\n    uint256 private constant mask144 = ~(~uint256(0) << 144);\r\n\r\n    event Trade(\r\n        address maker,\r\n        address taker,\r\n        address makerGiveAsset,\r\n        uint256 makerGiveAmount,\r\n        address fillerGiveAsset,\r\n        uint256 fillerGiveAmount\r\n    );\r\n\r\n    /// @dev Calculates the balance increments for a set of trades\r\n    /// @param _values The _values param from the trade method\r\n    /// @param _incrementsLength Should match the value of _addresses.length / 2\r\n    /// from the trade method\r\n    /// @return An array of increments\r\n    function calculateTradeIncrements(\r\n        uint256[] memory _values,\r\n        uint256 _incrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_incrementsLength);\r\n        _creditFillBalances(increments, _values);\r\n        _creditMakerBalances(increments, _values);\r\n        _creditMakerFeeBalances(increments, _values);\r\n        return increments;\r\n    }\r\n\r\n    /// @dev Calculates the balance decrements for a set of trades\r\n    /// @param _values The _values param from the trade method\r\n    /// @param _decrementsLength Should match the value of _addresses.length / 2\r\n    /// from the trade method\r\n    /// @return An array of decrements\r\n    function calculateTradeDecrements(\r\n        uint256[] memory _values,\r\n        uint256 _decrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory decrements = new uint256[](_decrementsLength);\r\n        _deductFillBalances(decrements, _values);\r\n        _deductMakerBalances(decrements, _values);\r\n        return decrements;\r\n    }\r\n\r\n    /// @dev Calculates the balance increments for a set of network trades\r\n    /// @param _values The _values param from the networkTrade method\r\n    /// @param _incrementsLength Should match the value of _addresses.length / 2\r\n    /// from the networkTrade method\r\n    /// @return An array of increments\r\n    function calculateNetworkTradeIncrements(\r\n        uint256[] memory _values,\r\n        uint256 _incrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_incrementsLength);\r\n        _creditMakerBalances(increments, _values);\r\n        _creditMakerFeeBalances(increments, _values);\r\n        return increments;\r\n    }\r\n\r\n    /// @dev Calculates the balance decrements for a set of network trades\r\n    /// @param _values The _values param from the trade method\r\n    /// @param _decrementsLength Should match the value of _addresses.length / 2\r\n    /// from the networkTrade method\r\n    /// @return An array of decrements\r\n    function calculateNetworkTradeDecrements(\r\n        uint256[] memory _values,\r\n        uint256 _decrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory decrements = new uint256[](_decrementsLength);\r\n        _deductMakerBalances(decrements, _values);\r\n        return decrements;\r\n    }\r\n\r\n    /// @dev Validates `BrokerV2.trade` parameters to ensure trade fairness,\r\n    /// see `BrokerV2.trade` for param details.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function validateTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        public\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateMatches(_values, _addresses);\r\n        _validateFillAmounts(_values);\r\n        _validateTradeData(_values, _addresses, _operator);\r\n\r\n        // validate signatures of all offers\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] & mask8 // numOffers\r\n        );\r\n\r\n        // validate signatures of all fills\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            FILL_TYPEHASH,\r\n            _values[0] & mask8, // numOffers\r\n            (_values[0] & mask8) + ((_values[0] & mask16) >> 8) // numOffers + numFills\r\n        );\r\n\r\n        _emitTradeEvents(_values, _addresses, new address[](0), false);\r\n\r\n        return _hashes;\r\n    }\r\n\r\n    /// @dev Validates `BrokerV2.networkTrade` parameters to ensure trade fairness,\r\n    /// see `BrokerV2.networkTrade` for param details.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _hashes Hashes from `networkTrade`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    /// @param _operator Address of the `BrokerV2.operator`\r\n    function validateNetworkTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateNetworkTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateNetworkMatches(_values, _addresses, _operator);\r\n        _validateTradeData(_values, _addresses, _operator);\r\n\r\n        // validate signatures of all offers\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] & mask8 // numOffers\r\n        );\r\n\r\n        return _hashes;\r\n    }\r\n\r\n    /// @dev Executes trades against external markets,\r\n    /// see `BrokerV2.networkTrade` for param details.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    /// @param _marketDapps See `BrokerV2.marketDapps`\r\n    function performNetworkTrades(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address[] memory _marketDapps\r\n    )\r\n        public\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\r\n        // i = 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            uint256[] memory data = new uint256[](9);\r\n            data[0] = _values[i]; // match data\r\n            data[1] = data[0] & mask8; // offerIndex\r\n            data[2] = (data[0] & mask24) >> 16; // operator.surplusAssetIndex\r\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\r\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\r\n            data[5] = ((data[3] & mask16) >> 8); // maker.offerAssetIndex\r\n            data[6] = ((data[3] & mask24) >> 16); // maker.wantAssetIndex\r\n            // amount of offerAssetId to take from the offer is equal to the match.takeAmount\r\n            data[7] = data[0] >> 128;\r\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\r\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & mask128);\r\n\r\n            address[] memory assetIds = new address[](3);\r\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\r\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\r\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\r\n\r\n            uint256[] memory dataValues = new uint256[](3);\r\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\r\n            dataValues[1] = data[8]; // the proportion of wantAmount to receive for the offer\r\n            dataValues[2] = data[0]; // match data\r\n\r\n            increments[data[2]] = _performNetworkTrade(\r\n                assetIds,\r\n                dataValues,\r\n                _marketDapps,\r\n                _addresses\r\n            );\r\n        }\r\n\r\n        _emitTradeEvents(_values, _addresses, _marketDapps, true);\r\n\r\n        return increments;\r\n    }\r\n\r\n    /// @dev Validates the signature of a cancel invocation\r\n    /// @param _values The _values param from the cancel method\r\n    /// @param _hashes The _hashes param from the cancel method\r\n    /// @param _addresses The _addresses param from the cancel method\r\n    function validateCancel(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        pure\r\n    {\r\n        bytes32 offerHash = hashOffer(_values, _addresses);\r\n\r\n        bytes32 cancelHash = keccak256(abi.encode(\r\n            CANCEL_TYPEHASH,\r\n            offerHash,\r\n            _addresses[4],\r\n            _values[1] >> 128\r\n        ));\r\n\r\n        validateSignature(\r\n            cancelHash,\r\n            _addresses[0], // maker\r\n            uint8((_values[2] & mask144) >> 136), // v\r\n            _hashes[0], // r\r\n            _hashes[1], // s\r\n            ((_values[2] & mask136) >> 128) != 0 // prefixedSignature\r\n        );\r\n    }\r\n\r\n    /// @dev Hashes an offer for the cancel method\r\n    /// @param _values The _values param from the cancel method\r\n    /// @param _addresses THe _addresses param from the cancel method\r\n    /// @return The hash of the offer\r\n    function hashOffer(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(\r\n            OFFER_TYPEHASH,\r\n            _addresses[0], // maker\r\n            _addresses[1], // offerAssetId\r\n            _values[0] & mask128, // offerAmount\r\n            _addresses[2], // wantAssetId\r\n            _values[0] >> 128, // wantAmount\r\n            _addresses[3], // feeAssetId\r\n            _values[1] & mask128, // feeAmount\r\n            _values[2] >> 144 // offerNonce\r\n        ));\r\n    }\r\n\r\n    /// @notice Approves a token transfer\r\n    /// @param _assetId The address of the token to approve\r\n    /// @param _spender The address of the spender to approve\r\n    /// @param _amount The number of tokens to approve\r\n    function approveTokenTransfer(\r\n        address _assetId,\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have an `approve` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"approve(address,uint256)\",\r\n            _spender,\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Transfers tokens into the contract\r\n    /// @param _user The address to transfer the tokens from\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    /// @param _expectedAmount The number of tokens expected to be received,\r\n    /// this may not match `_amount`, for example, tokens which have a\r\n    /// proportion burnt on transfer will have a different amount received.\r\n    function transferTokensIn(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _expectedAmount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        uint256 initialBalance = tokenBalance(_assetId);\r\n\r\n        // Some tokens have a `transferFrom` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"transferFrom(address,address,uint256)\",\r\n            _user,\r\n            address(this),\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n\r\n        uint256 finalBalance = tokenBalance(_assetId);\r\n        uint256 transferredAmount = finalBalance.sub(initialBalance);\r\n\r\n        require(transferredAmount == _expectedAmount, \"Invalid transfer\");\r\n    }\r\n\r\n    /// @notice Transfers tokens from the contract to a user\r\n    /// @param _receivingAddress The address to transfer the tokens to\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    function transferTokensOut(\r\n        address _receivingAddress,\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have a `transfer` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n                                   \"transfer(address,uint256)\",\r\n                                   _receivingAddress,\r\n                                   _amount\r\n                               );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract\r\n    /// @param _assetId The address of the token to query\r\n    function externalBalance(address _assetId) public view returns (uint256) {\r\n        if (_assetId == ETHER_ADDR) {\r\n            return address(this).balance;\r\n        }\r\n        return tokenBalance(_assetId);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract.\r\n    /// @dev This will not work for Ether tokens, use `externalBalance` for\r\n    /// Ether tokens.\r\n    /// @param _assetId The address of the token to query\r\n    function tokenBalance(address _assetId) public view returns (uint256) {\r\n        return ERC20(_assetId).balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Validates that the specified `_hash` was signed by the specified `_user`.\r\n    /// This method supports the EIP712 specification, the older Ethereum\r\n    /// signed message specification is also supported for backwards compatibility.\r\n    /// @param _hash The original hash that was signed by the user\r\n    /// @param _user The user who signed the hash\r\n    /// @param _v The `v` component of the `_user`'s signature\r\n    /// @param _r The `r` component of the `_user`'s signature\r\n    /// @param _s The `s` component of the `_user`'s signature\r\n    /// @param _prefixed If true, the signature will be verified\r\n    /// against the Ethereum signed message specification instead of the\r\n    /// EIP712 specification\r\n    function validateSignature(\r\n        bytes32 _hash,\r\n        address _user,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixed\r\n    )\r\n        public\r\n        pure\r\n    {\r\n        bytes32 eip712Hash = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            _hash\r\n        ));\r\n\r\n        if (_prefixed) {\r\n            bytes32 prefixedHash = keccak256(abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                eip712Hash\r\n            ));\r\n            require(_user == ecrecover(prefixedHash, _v, _r, _s), \"Invalid signature\");\r\n        } else {\r\n            require(_user == ecrecover(eip712Hash, _v, _r, _s), \"Invalid signature\");\r\n        }\r\n    }\r\n\r\n    /// @dev Ensures that `_address` is not the zero address\r\n    /// @param _address The address to check\r\n    function validateAddress(address _address) public pure {\r\n        require(_address != address(0), \"Invalid address\");\r\n    }\r\n\r\n    /// @dev Credit fillers for each fill.wantAmount,and credit the operator\r\n    /// for each fill.feeAmount. See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _creditFillBalances(\r\n        uint256[] memory _increments,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        // i + numFills * 2\r\n        uint256 end = i + ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        // loop fills\r\n        for(i; i < end; i += 2) {\r\n            uint256 fillerWantAssetIndex = (_values[i] & mask24) >> 16;\r\n            uint256 wantAmount = _values[i + 1] >> 128;\r\n\r\n            // credit fill.wantAmount to filler\r\n            _increments[fillerWantAssetIndex] = _increments[fillerWantAssetIndex].add(wantAmount);\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            uint256 operatorFeeAssetIndex = ((_values[i] & mask40) >> 32);\r\n            // credit fill.feeAmount to operator\r\n            _increments[operatorFeeAssetIndex] = _increments[operatorFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Credit makers for each amount received through a matched fill.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _creditMakerBalances(\r\n        uint256[] memory _increments,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            // match.offerIndex\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            // maker.wantAssetIndex\r\n            uint256 makerWantAssetIndex = (_values[1 + offerIndex * 2] & mask24) >> 16;\r\n\r\n            // match.takeAmount\r\n            uint256 amount = _values[i] >> 128;\r\n            // receiveAmount = match.takeAmount * offer.wantAmount / offer.offerAmount\r\n            amount = amount.mul(_values[2 + offerIndex * 2] >> 128)\r\n                           .div(_values[2 + offerIndex * 2] & mask128);\r\n\r\n            // credit maker for the amount received from the match\r\n            _increments[makerWantAssetIndex] = _increments[makerWantAssetIndex].add(amount);\r\n        }\r\n    }\r\n\r\n    /// @dev Credit the operator for each offer.feeAmount if the offer has not\r\n    /// been recorded through a previous `trade` call.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _creditMakerFeeBalances(\r\n        uint256[] memory _increments,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 i = 1;\r\n        // i + numOffers * 2\r\n        uint256 end = i + (_values[0] & mask8) * 2;\r\n\r\n        // loop offers\r\n        for(i; i < end; i += 2) {\r\n            bool nonceTaken = ((_values[i] & mask128) >> 120) == 1;\r\n            if (nonceTaken) { continue; }\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            uint256 operatorFeeAssetIndex = (_values[i] & mask40) >> 32;\r\n\r\n            // credit make.feeAmount to operator\r\n            _increments[operatorFeeAssetIndex] = _increments[operatorFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Deduct tokens from fillers for each fill.offerAmount\r\n    /// and each fill.feeAmount.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _deductFillBalances(\r\n        uint256[] memory _decrements,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        // i + numFills * 2\r\n        uint256 end = i + ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        // loop fills\r\n        for(i; i < end; i += 2) {\r\n            uint256 fillerOfferAssetIndex = (_values[i] & mask16) >> 8;\r\n            uint256 offerAmount = _values[i + 1] & mask128;\r\n\r\n            // deduct fill.offerAmount from filler\r\n            _decrements[fillerOfferAssetIndex] = _decrements[fillerOfferAssetIndex].add(offerAmount);\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            // deduct fill.feeAmount from filler\r\n            uint256 fillerFeeAssetIndex = (_values[i] & mask32) >> 24;\r\n            _decrements[fillerFeeAssetIndex] = _decrements[fillerFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Deduct tokens from makers for each offer.offerAmount\r\n    /// and each offer.feeAmount if the offer has not been recorded\r\n    /// through a previous `trade` call.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _deductMakerBalances(\r\n        uint256[] memory _decrements,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 i = 1;\r\n        // i + numOffers * 2\r\n        uint256 end = i + (_values[0] & mask8) * 2;\r\n\r\n        // loop offers\r\n        for(i; i < end; i += 2) {\r\n            bool nonceTaken = ((_values[i] & mask128) >> 120) == 1;\r\n            if (nonceTaken) { continue; }\r\n\r\n            uint256 makerOfferAssetIndex = (_values[i] & mask16) >> 8;\r\n            uint256 offerAmount = _values[i + 1] & mask128;\r\n\r\n            // deduct make.offerAmount from maker\r\n            _decrements[makerOfferAssetIndex] = _decrements[makerOfferAssetIndex].add(offerAmount);\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            // deduct make.feeAmount from maker\r\n            uint256 makerFeeAssetIndex = (_values[i] & mask32) >> 24;\r\n            _decrements[makerFeeAssetIndex] = _decrements[makerFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Emits trade events for easier tracking\r\n    /// @param _values The _values param from the trade / networkTrade method\r\n    /// @param _addresses The _addresses param from the trade / networkTrade method\r\n    /// @param _marketDapps The _marketDapps from BrokerV2\r\n    /// @param _forNetworkTrade Whether this is called from the networkTrade method\r\n    function _emitTradeEvents(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address[] memory _marketDapps,\r\n        bool _forNetworkTrade\r\n    )\r\n        private\r\n    {\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            uint256[] memory data = new uint256[](7);\r\n            data[0] = _values[i] & mask8; // match.offerIndex\r\n            data[1] = _values[1 + data[0] * 2] & mask8; // makerIndex\r\n            data[2] = (_values[1 + data[0] * 2] & mask16) >> 8; // makerOfferAssetIndex\r\n            data[3] = (_values[1 + data[0] * 2] & mask24) >> 16; // makerWantAssetIndex\r\n            data[4] = _values[i] >> 128; // match.takeAmount\r\n            // receiveAmount = match.takeAmount * offer.wantAmount / offer.offerAmount\r\n            data[5] = data[4].mul(_values[2 + data[0] * 2] >> 128)\r\n                             .div(_values[2 + data[0] * 2] & mask128);\r\n            // match.fillIndex for `trade`, marketDappIndex for `networkTrade`\r\n            data[6] = (_values[i] & mask16) >> 8;\r\n\r\n            address filler;\r\n            if (_forNetworkTrade) {\r\n                filler = _marketDapps[data[6]];\r\n            } else {\r\n                uint256 fillerIndex = (_values[1 + data[6] * 2] & mask8);\r\n                filler = _addresses[fillerIndex * 2];\r\n            }\r\n\r\n            emit Trade(\r\n                _addresses[data[1] * 2], // maker\r\n                filler,\r\n                _addresses[data[2] * 2 + 1], // makerGiveAsset\r\n                data[4], // makerGiveAmount\r\n                _addresses[data[3] * 2 + 1], // fillerGiveAsset\r\n                data[5] // fillerGiveAmount\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Executes a trade against an external market.\r\n    /// @dev The initial Ether or token balance is compared with the\r\n    /// balance after the trade to ensure that the appropriate amounts of\r\n    /// tokens were taken and an appropriate amount received.\r\n    /// The trade will fail if the number of tokens received is less than\r\n    /// expected. If the number of tokens received is more than expected than\r\n    /// the excess tokens are transferred to the `BrokerV2.operator`.\r\n    /// @param _assetIds[0] The offerAssetId of the offer\r\n    /// @param _assetIds[1] The wantAssetId of the offer\r\n    /// @param _assetIds[2] The surplusAssetId\r\n    /// @param _dataValues[0] The number of tokens offerred\r\n    /// @param _dataValues[1] The number of tokens expected to be received\r\n    /// @param _dataValues[2] Match data\r\n    /// @param _marketDapps See `BrokerV2.marketDapps`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    function _performNetworkTrade(\r\n        address[] memory _assetIds,\r\n        uint256[] memory _dataValues,\r\n        address[] memory _marketDapps,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 dappIndex = (_dataValues[2] & mask16) >> 8;\r\n        validateAddress(_marketDapps[dappIndex]);\r\n        MarketDapp marketDapp = MarketDapp(_marketDapps[dappIndex]);\r\n\r\n        uint256[] memory funds = new uint256[](6);\r\n        funds[0] = externalBalance(_assetIds[0]); // initialOfferTokenBalance\r\n        funds[1] = externalBalance(_assetIds[1]); // initialWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            funds[2] = externalBalance(_assetIds[2]); // initialSurplusTokenBalance\r\n        }\r\n\r\n        uint256 ethValue = 0;\r\n        address tokenReceiver;\r\n\r\n        if (_assetIds[0] == ETHER_ADDR) {\r\n            ethValue = _dataValues[0]; // offerAmount\r\n        } else {\r\n            tokenReceiver = marketDapp.tokenReceiver(_assetIds, _dataValues, _addresses);\r\n            approveTokenTransfer(\r\n                _assetIds[0], // offerAssetId\r\n                tokenReceiver,\r\n                _dataValues[0] // offerAmount\r\n            );\r\n        }\r\n\r\n        marketDapp.trade.value(ethValue)(\r\n            _assetIds,\r\n            _dataValues,\r\n            _addresses,\r\n            // use uint160 to cast `address` to `address payable`\r\n            address(uint160(address(this))) // destAddress\r\n        );\r\n\r\n        funds[3] = externalBalance(_assetIds[0]); // finalOfferTokenBalance\r\n        funds[4] = externalBalance(_assetIds[1]); // finalWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            funds[5] = externalBalance(_assetIds[2]); // finalSurplusTokenBalance\r\n        }\r\n\r\n        uint256 surplusAmount = 0;\r\n\r\n        // validate that the appropriate offerAmount was deducted\r\n        // surplusAssetId == offerAssetId\r\n        if (_assetIds[2] == _assetIds[0]) {\r\n            // surplusAmount = finalOfferTokenBalance - (initialOfferTokenBalance - offerAmount)\r\n            surplusAmount = funds[3].sub(funds[0].sub(_dataValues[0]));\r\n        } else {\r\n            // finalOfferTokenBalance == initialOfferTokenBalance - offerAmount\r\n            require(funds[3] == funds[0].sub(_dataValues[0]), \"Invalid offer asset balance\");\r\n        }\r\n\r\n        // validate that the appropriate wantAmount was credited\r\n        // surplusAssetId == wantAssetId\r\n        if (_assetIds[2] == _assetIds[1]) {\r\n            // surplusAmount = finalWantTokenBalance - (initialWantTokenBalance + wantAmount)\r\n            surplusAmount = funds[4].sub(funds[1].add(_dataValues[1]));\r\n        } else {\r\n            // finalWantTokenBalance == initialWantTokenBalance + wantAmount\r\n            require(funds[4] == funds[1].add(_dataValues[1]), \"Invalid want asset balance\");\r\n        }\r\n\r\n        // surplusAssetId != offerAssetId && surplusAssetId != wantAssetId\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            // surplusAmount = finalSurplusTokenBalance - initialSurplusTokenBalance\r\n            surplusAmount = funds[5].sub(funds[2]);\r\n        }\r\n\r\n        // set the approved token amount back to zero\r\n        if (_assetIds[0] != ETHER_ADDR) {\r\n            approveTokenTransfer(\r\n                _assetIds[0],\r\n                tokenReceiver,\r\n                0\r\n            );\r\n        }\r\n\r\n        return surplusAmount;\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the `trade` method.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    function _validateTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n        uint256 numFills = (_values[0] & mask16) >> 8;\r\n        uint256 numMatches = (_values[0] & mask24) >> 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] >> 24 == 0, \"Invalid trade input\");\r\n\r\n        // It is enforced by other checks that if a fill is present\r\n        // then it must be completely filled so there must be at least one offer\r\n        // and at least one match in this case.\r\n        // It is possible to have one offer with no matches and no fills\r\n        // but that is blocked by this check as there is no foreseeable use\r\n        // case for it.\r\n        require(\r\n            numOffers > 0 && numFills > 0 && numMatches > 0,\r\n            \"Invalid trade input\"\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 + numOffers * 2 + numFills * 2 + numMatches,\r\n            \"Invalid _values.length\"\r\n        );\r\n\r\n        require(\r\n            _hashes.length == (numOffers + numFills) * 2,\r\n            \"Invalid _hashes.length\"\r\n        );\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the `networkTrade` method.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _hashes Hashes from `networkTrade`\r\n    function _validateNetworkTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n        uint256 numFills = (_values[0] & mask16) >> 8;\r\n        uint256 numMatches = (_values[0] & mask24) >> 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] >> 24 == 0, \"Invalid networkTrade input\");\r\n\r\n        // Validate that numFills is zero because the offers\r\n        // should be filled against external orders\r\n        require(\r\n            numOffers > 0 && numMatches > 0 && numFills == 0,\r\n            \"Invalid networkTrade input\"\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 + numOffers * 2 + numMatches,\r\n            \"Invalid _values.length\"\r\n        );\r\n\r\n        require(\r\n            _hashes.length == numOffers * 2,\r\n            \"Invalid _hashes.length\"\r\n        );\r\n    }\r\n\r\n    /// @dev See the `BrokerV2.trade` method for an explanation of why offer\r\n    /// uniquness is required.\r\n    /// The set of offers in `_values` must be sorted such that offer nonces'\r\n    /// are arranged in a strictly ascending order.\r\n    /// This allows the validation of offer uniqueness to be done in O(N) time,\r\n    /// with N being the number of offers.\r\n    /// @param _values Values from `trade`\r\n    function _validateUniqueOffers(uint256[] memory _values) private pure {\r\n        uint256 numOffers = _values[0] & mask8;\r\n\r\n        uint256 prevNonce;\r\n\r\n        for(uint256 i = 0; i < numOffers; i++) {\r\n            uint256 nonce = (_values[i * 2 + 1] & mask120) >> 56;\r\n\r\n            if (i == 0) {\r\n                // Set the value of the first nonce\r\n                prevNonce = nonce;\r\n                continue;\r\n            }\r\n\r\n            require(nonce > prevNonce, \"Invalid offer nonces\");\r\n            prevNonce = nonce;\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. fillIndexes falls within the range of fills\r\n    /// 3. offer.offerAssetId == fill.wantAssetId\r\n    /// 4. offer.wantAssetId == fill.offerAssetId\r\n    /// 5. takeAmount > 0\r\n    /// 6. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n        uint256 numFills = (_values[0] & mask16) >> 8;\r\n\r\n        uint256 i = 1 + numOffers * 2 + numFills * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 fillIndex = (_values[i] & mask16) >> 8;\r\n\r\n            require(offerIndex < numOffers, \"Invalid match.offerIndex\");\r\n\r\n            require(fillIndex >= numOffers && fillIndex < numOffers + numFills, \"Invalid match.fillIndex\");\r\n\r\n            require(\r\n                _addresses[(_values[1 + offerIndex * 2] & mask8) * 2] !=\r\n                _addresses[(_values[1 + fillIndex * 2] & mask8) * 2],\r\n                \"offer.maker cannot be the same as fill.filler\"\r\n            );\r\n\r\n            uint256 makerOfferAssetIndex = (_values[1 + offerIndex * 2] & mask16) >> 8;\r\n            uint256 makerWantAssetIndex = (_values[1 + offerIndex * 2] & mask24) >> 16;\r\n            uint256 fillerOfferAssetIndex = (_values[1 + fillIndex * 2] & mask16) >> 8;\r\n            uint256 fillerWantAssetIndex = (_values[1 + fillIndex * 2] & mask24) >> 16;\r\n\r\n            require(\r\n                _addresses[makerOfferAssetIndex * 2 + 1] ==\r\n                _addresses[fillerWantAssetIndex * 2 + 1],\r\n                \"offer.offerAssetId does not match fill.wantAssetId\"\r\n            );\r\n\r\n            require(\r\n                _addresses[makerWantAssetIndex * 2 + 1] ==\r\n                _addresses[fillerOfferAssetIndex * 2 + 1],\r\n                \"offer.wantAssetId does not match fill.offerAssetId\"\r\n            );\r\n\r\n            // require that bits(16..128) are all zero for every match\r\n            require((_values[i] & mask128) >> 16 == uint256(0), \"Invalid match data\");\r\n\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            require(takeAmount > 0, \"Invalid match.takeAmount\");\r\n\r\n            uint256 offerDataB = _values[2 + offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB >> 128).mul(takeAmount).mod(offerDataB & mask128) == 0,\r\n                \"Invalid amounts\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. _addresses[surplusAssetIndexes * 2] matches the operator address\r\n    /// 3. takeAmount > 0\r\n    /// 4. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    /// @param _operator Address of the `BrokerV2.operator`\r\n    function _validateNetworkMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 surplusAssetIndex = (_values[i] & mask24) >> 16;\r\n\r\n            require(offerIndex < numOffers, \"Invalid match.offerIndex\");\r\n            require(_addresses[surplusAssetIndex * 2] == _operator, \"Invalid operator address\");\r\n\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            require(takeAmount > 0, \"Invalid match.takeAmount\");\r\n\r\n            uint256 offerDataB = _values[2 + offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB >> 128).mul(takeAmount).mod(offerDataB & mask128) == 0,\r\n                \"Invalid amounts\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that all fills will be completely filled by the specified\r\n    /// matches. See the `BrokerV2.trade` method for an explanation of why\r\n    /// fills must be completely filled.\r\n    /// @param _values Values from `trade`\r\n    function _validateFillAmounts(uint256[] memory _values) private pure {\r\n        // \"filled\" is used to store the sum of `takeAmount`s and `giveAmount`s.\r\n        // While a fill's `offerAmount` and `wantAmount` are combined to share\r\n        // a single uint256 value, each sum of `takeAmount`s and `giveAmount`s\r\n        // for a fill is tracked with an individual uint256 value.\r\n        // This is to prevent the verification from being vulnerable to overflow\r\n        // issues.\r\n        uint256[] memory filled = new uint256[](_values.length);\r\n\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 fillIndex = (_values[i] & mask16) >> 8;\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            uint256 wantAmount = _values[2 + offerIndex * 2] >> 128;\r\n            uint256 offerAmount = _values[2 + offerIndex * 2] & mask128;\r\n            // giveAmount = takeAmount * wantAmount / offerAmount\r\n            uint256 giveAmount = takeAmount.mul(wantAmount).div(offerAmount);\r\n\r\n            // (1 + fillIndex * 2) would give the index of the first part\r\n            // of the data for the fill at fillIndex within `_values`,\r\n            // and (2 + fillIndex * 2) would give the index of the second part\r\n            filled[1 + fillIndex * 2] = filled[1 + fillIndex * 2].add(giveAmount);\r\n            filled[2 + fillIndex * 2] = filled[2 + fillIndex * 2].add(takeAmount);\r\n        }\r\n\r\n        // numOffers\r\n        i = _values[0] & mask8;\r\n        // i + numFills\r\n        end = i + ((_values[0] & mask16) >> 8);\r\n\r\n        // loop fills\r\n        for(i; i < end; i++) {\r\n            require(\r\n                // fill.offerAmount == (sum of given amounts for fill)\r\n                _values[i * 2 + 2] & mask128 == filled[i * 2 + 1] &&\r\n                // fill.wantAmount == (sum of taken amounts for fill)\r\n                _values[i * 2 + 2] >> 128 == filled[i * 2 + 2],\r\n                \"Invalid fills\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates that for every offer / fill\r\n    /// 1. user address matches address referenced by user.offerAssetIndex\r\n    /// 2. user address matches address referenced by user.wantAssetIndex\r\n    /// 3. user address matches address referenced by user.feeAssetIndex\r\n    /// 4. offerAssetId != wantAssetId\r\n    /// 5. offerAmount > 0 && wantAmount > 0\r\n    /// 6. Specified `operator` address matches the expected `operator` address,\r\n    /// 7. Specified `operator.feeAssetId` matches the offer's feeAssetId\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateTradeData(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // numOffers + numFills\r\n        uint256 end = (_values[0] & mask8) +\r\n                      ((_values[0] & mask16) >> 8);\r\n\r\n        for (uint256 i = 0; i < end; i++) {\r\n            uint256 dataA = _values[i * 2 + 1];\r\n            uint256 dataB = _values[i * 2 + 2];\r\n\r\n            require(\r\n                // user address == user in user.offerAssetIndex pair\r\n                _addresses[(dataA & mask8) * 2] ==\r\n                _addresses[((dataA & mask16) >> 8) * 2],\r\n                \"Invalid user in user.offerAssetIndex\"\r\n            );\r\n\r\n            require(\r\n                // user address == user in user.wantAssetIndex pair\r\n                _addresses[(dataA & mask8) * 2] ==\r\n                _addresses[((dataA & mask24) >> 16) * 2],\r\n                \"Invalid user in user.wantAssetIndex\"\r\n            );\r\n\r\n            require(\r\n                // user address == user in user.feeAssetIndex pair\r\n                _addresses[(dataA & mask8) * 2] ==\r\n                _addresses[((dataA & mask32) >> 24) * 2],\r\n                \"Invalid user in user.feeAssetIndex\"\r\n            );\r\n\r\n            require(\r\n                // offerAssetId != wantAssetId\r\n                _addresses[((dataA & mask16) >> 8) * 2 + 1] !=\r\n                _addresses[((dataA & mask24) >> 16) * 2 + 1],\r\n                \"Invalid trade assets\"\r\n            );\r\n\r\n            require(\r\n                // offerAmount > 0 && wantAmount > 0\r\n                (dataB & mask128) > 0 && (dataB >> 128) > 0,\r\n                \"Invalid trade amounts\"\r\n            );\r\n\r\n            uint256 operatorFeeAssetIndex = ((dataA & mask40) >> 32) * 2;\r\n\r\n             require(\r\n                _addresses[operatorFeeAssetIndex] == _operator,\r\n                \"Invalid operator address\"\r\n            );\r\n\r\n             require(\r\n                _addresses[operatorFeeAssetIndex + 1] ==\r\n                _addresses[((dataA & mask32) >> 24) * 2 + 1],\r\n                \"Invalid operator fee asset ID\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates signatures for a set of offers or fills\r\n    /// Note that the r value of the offer / fill in _hashes will be\r\n    /// overwritten by the hash of that offer / fill\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    /// @param _typehash The typehash used to construct the signed hash\r\n    /// @param _i The starting index to verify\r\n    /// @param _end The ending index to verify\r\n    /// @return An array of hash keys if _i started as 0, because only\r\n    /// the hash keys of offers are needed\r\n    function _validateTradeSignatures(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        bytes32 _typehash,\r\n        uint256 _i,\r\n        uint256 _end\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        for (_i; _i < _end; _i++) {\r\n            uint256 dataA = _values[_i * 2 + 1];\r\n            uint256 dataB = _values[_i * 2 + 2];\r\n\r\n            bytes32 hashKey = keccak256(abi.encode(\r\n                _typehash,\r\n                _addresses[(dataA & mask8) * 2], // user\r\n                _addresses[((dataA & mask16) >> 8) * 2 + 1], // offerAssetId\r\n                dataB & mask128, // offerAmount\r\n                _addresses[((dataA & mask24) >> 16) * 2 + 1], // wantAssetId\r\n                dataB >> 128, // wantAmount\r\n                _addresses[((dataA & mask32) >> 24) * 2 + 1], // feeAssetId\r\n                dataA >> 128, // feeAmount\r\n                (dataA & mask120) >> 56 // nonce\r\n            ));\r\n\r\n            bool prefixedSignature = ((dataA & mask56) >> 48) != 0;\r\n\r\n            validateSignature(\r\n                hashKey,\r\n                _addresses[(dataA & mask8) * 2], // user\r\n                uint8((dataA & mask48) >> 40), // The `v` component of the user's signature\r\n                _hashes[_i * 2], // The `r` component of the user's signature\r\n                _hashes[_i * 2 + 1], // The `s` component of the user's signature\r\n                prefixedSignature\r\n            );\r\n\r\n            _hashes[_i * 2] = hashKey;\r\n        }\r\n    }\r\n\r\n    /// @dev Ensure that the address is a deployed contract\r\n    /// @param _contract The address to check\r\n    function _validateContractAddress(address _contract) private view {\r\n        assembly {\r\n            if iszero(extcodesize(_contract)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @dev A thin wrapper around the native `call` function, to\r\n    /// validate that the contract `call` must be successful.\r\n    /// See https://solidity.readthedocs.io/en/v0.5.1/050-breaking-changes.html\r\n    /// for details on constructing the `_payload`\r\n    /// @param _contract Address of the contract to call\r\n    /// @param _payload The data to call the contract with\r\n    /// @return The data returned from the contract call\r\n    function _callContract(\r\n        address _contract,\r\n        bytes memory _payload\r\n    )\r\n        private\r\n        returns (bytes memory)\r\n    {\r\n        bool success;\r\n        bytes memory returnData;\r\n\r\n        (success, returnData) = _contract.call(_payload);\r\n        require(success, \"Contract call failed\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    /// @dev Fix for ERC-20 tokens that do not have proper return type\r\n    /// See: https://github.com/ethereum/solidity/issues/4116\r\n    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\r\n    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\r\n    /// @param _data The data returned from a transfer call\r\n    function _validateContractCallResult(bytes memory _data) private pure {\r\n        require(\r\n            _data.length == 0 ||\r\n            (_data.length == 32 && _getUint256FromBytes(_data) != 0),\r\n            \"Invalid contract call result\"\r\n        );\r\n    }\r\n\r\n    /// @dev Converts data of type `bytes` into its corresponding `uint256` value\r\n    /// @param _data The data in bytes\r\n    /// @return The corresponding `uint256` value\r\n    function _getUint256FromBytes(\r\n        bytes memory _data\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 parsed;\r\n        assembly { parsed := mload(add(_data, 32)) }\r\n        return parsed;\r\n    }\r\n}\r\n\r\n// File: contracts/extensions/TokenList.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/// @title The TokenList extension for the BrokerV2 contract\r\n/// @author Switcheo Network\r\n/// @notice This contract maintains a list of whitelisted tokens.\r\n/// @dev Whitelisted tokens are permitted to call the `tokenFallback` and\r\n/// `tokensReceived` methods in the BrokerV2 contract.\r\ncontract TokenList is BrokerExtension {\r\n    // A record of whitelisted tokens: tokenAddress => isWhitelisted.\r\n    // This controls token permission to invoke `tokenFallback` and `tokensReceived` callbacks\r\n    // on this contract.\r\n    mapping(address => bool) public tokenWhitelist;\r\n\r\n    /// @notice Whitelists a token contract\r\n    /// @dev This enables the token contract to call `tokensReceived` or `tokenFallback`\r\n    /// on this contract.\r\n    /// This layer of management is to prevent misuse of `tokensReceived` and `tokenFallback`\r\n    /// methods by unvetted tokens.\r\n    /// @param _assetId The token address to whitelist\r\n    function whitelistToken(address _assetId) external onlyOwner nonReentrant {\r\n        Utils.validateAddress(_assetId);\r\n        require(!tokenWhitelist[_assetId], \"Token already whitelisted\");\r\n        tokenWhitelist[_assetId] = true;\r\n    }\r\n\r\n    /// @notice Removes a token contract from the token whitelist\r\n    /// @param _assetId The token address to remove from the token whitelist\r\n    function unwhitelistToken(address _assetId) external onlyOwner nonReentrant {\r\n        Utils.validateAddress(_assetId);\r\n        require(tokenWhitelist[_assetId], \"Token not whitelisted\");\r\n        delete tokenWhitelist[_assetId];\r\n    }\r\n\r\n    /// @notice Validates if a token has been whitelisted\r\n    /// @param _assetId The token address to validate\r\n    function validateToken(address _assetId) external view {\r\n        require(tokenWhitelist[_assetId], \"Invalid token\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"broker\",\"outputs\":[{\"internalType\":\"contract Broker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brokerAddress\",\"type\":\"address\"}],\"name\":\"initializeBroker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"}],\"name\":\"unwhitelistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"}],\"name\":\"validateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"}],\"name\":\"whitelistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenList","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"Utils:d6e266d0221a2e7909fb7f9fd45a84d217e909e7","LicenseType":"MIT","SwarmSource":"bzzr://d98a082a95aa47a26d5c01b47df6c9238ec05985b370f3c6aa6317ce0b31c80c"}]}