{"status":"1","message":"OK","result":[{"SourceCode":"{\"Migrations.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.6.0;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint256 public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"PhotochainMarketplace.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./PhotonTestToken.sol\\\";\\n\\n\\n/**\\n * @title PhotochainMarketplace\\n * @dev Marketplace to make and accept offers using PhotonToken\\n */\\ncontract PhotochainMarketplace is Ownable {\\n    /**\\n     * Event for offer creation logging\\n     * @param id Generated unique offer id\\n     * @param seller Addess of seller of the photo\\n     * @param licenseType Which license is applied on the offer\\n     * @param photoDigest 256-bit hash of the photo\\n     * @param price How many tokens to pay to accept the offer\\n     */\\n    event OfferAdded(\\n        bytes32 indexed id,\\n        address indexed seller,\\n        uint8 licenseType,\\n        bytes32 photoDigest,\\n        uint256 price\\n    );\\n\\n    /**\\n     * Event for offer acceptance logging\\n     * @param id Offer id to accept\\n     * @param licensee Address of the account that bought license\\n     */\\n    event OfferAccepted(bytes32 indexed id, address indexed licensee);\\n\\n    /**\\n     * Event for offer price change\\n     * @param id Offer id to update\\n     * @param oldPrice Previous price in tokens\\n     * @param newPrice New price in tokens\\n     */\\n    event OfferPriceChanged(bytes32 indexed id, uint256 oldPrice, uint256 newPrice);\\n\\n    /**\\n     * Event for offer cancellation\\n     * @param id Offer id to cancel\\n     */\\n    event OfferCancelled(bytes32 indexed id);\\n\\n    struct Offer {\\n        address seller;\\n        uint8 licenseType;\\n        bool isCancelled;\\n        bytes32 photoDigest;\\n        uint256 price;\\n    }\\n\\n    ERC20 public token;\\n\\n    // List of the offers\\n    mapping(bytes32 =\\u003e Offer) public offers;\\n\\n    // List of offer ids by seller\\n    mapping(address =\\u003e bytes32[]) public offersBySeller;\\n\\n    // List of offer ids by licensee\\n    mapping(address =\\u003e bytes32[]) public offersByLicensee;\\n\\n    modifier onlyValidAddress(address _addr) {\\n        require(_addr != address(0), \\\"Invalid address\\\");\\n        _;\\n    }\\n\\n    modifier onlyActiveOffer(bytes32 _id) {\\n        require(offers[_id].seller != address(0), \\\"Offer does not exists\\\");\\n        require(!offers[_id].isCancelled, \\\"Offer is cancelled\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @param _token Address of the PhotonToken contract\\n     */\\n    constructor(ERC20 _token) public onlyValidAddress(address(_token)) {\\n        token = _token;\\n    }\\n\\n    /**\\n       @dev Sets accounting token address\\n     * @param _token Address of the PhotonToken contract\\n     */\\n    function setToken(ERC20 _token)\\n        external\\n        onlyOwner\\n        onlyValidAddress(address(_token))\\n    {\\n        token = _token;\\n    }\\n\\n    /**\\n     * @dev Add an offer to the marketplace\\n     * @param _seller Address of the photo author\\n     * @param _licenseType License type for the offer\\n     * @param _photoDigest 256-bit hash of the photo\\n     * @param _price Price of the offer\\n     */\\n    function addOffer(\\n        address _seller,\\n        uint8 _licenseType,\\n        bytes32 _photoDigest,\\n        uint256 _price\\n    )\\n        external\\n        onlyOwner\\n        onlyValidAddress(_seller)\\n    {\\n        bytes32 _id = keccak256(\\n            abi.encodePacked(\\n                _seller,\\n                _licenseType,\\n                _photoDigest\\n            )\\n        );\\n        require(offers[_id].seller == address(0), \\\"Offer already exists\\\");\\n\\n        offersBySeller[_seller].push(_id);\\n        offers[_id] = Offer({\\n            seller: _seller,\\n            licenseType: _licenseType,\\n            isCancelled: false,\\n            photoDigest: _photoDigest,\\n            price: _price\\n        });\\n\\n        emit OfferAdded(_id, _seller, _licenseType, _photoDigest, _price);\\n    }\\n\\n    /**\\n     * @dev Accept an offer on the marketplace\\n     * @param _id Offer id\\n     * @param _licensee Address of the licensee that is buying the photo\\n     */\\n    function acceptOffer(bytes32 _id, address _licensee)\\n        external\\n        onlyOwner\\n        onlyValidAddress(_licensee)\\n        onlyActiveOffer(_id)\\n    {\\n        Offer storage offer = offers[_id];\\n\\n        if (offer.price \\u003e 0) {\\n            require(\\n                token.transferFrom(_licensee, address(this), offer.price),\\n                \\\"Token transfer to contract failed\\\"\\n            );\\n\\n            require(\\n                token.transfer(offer.seller, offer.price),\\n                \\\"Token transfer to seller failed\\\"\\n            );\\n        }\\n\\n        offersByLicensee[_licensee].push(_id);\\n\\n        emit OfferAccepted(_id, _licensee);\\n    }\\n\\n    /**\\n     * @dev Change price of the offer\\n     * @param _id Offer id\\n     * @param _price Price of the offer in tokens\\n     */\\n    function setOfferPrice(bytes32 _id, uint256 _price)\\n        external\\n        onlyOwner\\n        onlyActiveOffer(_id)\\n    {\\n        uint256 oldPrice = offers[_id].price;\\n\\n        offers[_id].price = _price;\\n\\n        emit OfferPriceChanged(_id, oldPrice, _price);\\n    }\\n\\n    /**\\n     * @dev Cancel offer\\n     * @param _id Offer id\\n     */\\n    function cancelOffer(bytes32 _id)\\n        external\\n        onlyOwner\\n        onlyActiveOffer(_id)\\n    {\\n        offers[_id].isCancelled = true;\\n\\n        emit OfferCancelled(_id);\\n    }\\n\\n    /**\\n     * @dev Get list of offers id from a seller\\n     * @param _seller The address of the seller to find its offers\\n     * @return Offer ids\\n     */\\n    function getOffers(address _seller) external view returns (bytes32[] memory) {\\n        return offersBySeller[_seller];\\n    }\\n\\n    /**\\n     * @dev Get the offer by id\\n     * @param _id The offer id\\n     * @return Offer details\\n     */\\n    function getOfferById(bytes32 _id)\\n        external\\n        view\\n        returns (\\n            address seller,\\n            uint8 licenseType,\\n            bool isCancelled,\\n            bytes32 photoDigest,\\n            uint256 price\\n        )\\n    {\\n        Offer storage offer = offers[_id];\\n\\n        seller = offer.seller;\\n        licenseType = offer.licenseType;\\n        isCancelled = offer.isCancelled;\\n        photoDigest = offer.photoDigest;\\n        price = offer.price;\\n    }\\n\\n    /**\\n     * @dev Get the list of the offers id by a licensee\\n     * @param _licensee Address of a licensee of offers\\n     */\\n    function getLicenses(address _licensee)\\n        external\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return offersByLicensee[_licensee];\\n    }\\n}\\n\"},\"PhotonTestToken.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2018-09-30\\n*/\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() public view returns (uint256);\\n    function balanceOf(address who) public view returns (uint256);\\n    function transfer(address to, uint256 value) public returns (bool);\\n    function allowance(address owner, address spender) public view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\\n    function approve(address spender, uint256 value) public returns (bool);\\n}\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n * @dev Based on https://github.com/OpenZeppelin/zeppelin-solidity\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * @dev Based on https://github.com/OpenZeppelin/zeppelin-solidity\\n */\\ncontract StandardToken is ERC20 {\\n    using SafeMath for uint256;\\n\\n    uint256 internal _totalSupply;\\n    mapping(address =\\u003e uint256) internal _balanceOf;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowance;\\n\\n    modifier onlyValidAddress(address addr) {\\n        require(addr != address(0), \\\"Address cannot be zero\\\");\\n        _;\\n    }\\n\\n    modifier onlySufficientBalance(address from, uint256 value) {\\n        require(value \\u003c= _balanceOf[from], \\\"Insufficient balance\\\");\\n        _;\\n    }\\n\\n    modifier onlySufficientAllowance(address owner, address spender, uint256 value) {\\n        require(value \\u003c= _allowance[owner][spender], \\\"Insufficient allowance\\\");\\n        _;\\n    }\\n\\n    /**\\n      * @dev Transfers token to the specified address\\n      * @param to The address to transfer to.\\n      * @param value The amount to be transferred.\\n      */\\n    function transfer(address to, uint256 value)\\n        public\\n        onlyValidAddress(to)\\n        onlySufficientBalance(msg.sender, value)\\n        returns (bool)\\n    {\\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(value);\\n        _balanceOf[to] = _balanceOf[to].add(value);\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from one address to another\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value)\\n        public\\n        onlyValidAddress(to)\\n        onlySufficientBalance(from, value)\\n        onlySufficientAllowance(from, msg.sender, value)\\n        returns (bool)\\n    {\\n        _balanceOf[from] = _balanceOf[from].sub(value);\\n        _balanceOf[to] = _balanceOf[to].add(value);\\n        _allowance[from][msg.sender] = _allowance[from][msg.sender].sub(value);\\n\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     *\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value)\\n        public\\n        onlyValidAddress(spender)\\n        returns (bool)\\n    {\\n        _allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increases the amount of tokens that an owner allowed to a spender.\\n     *\\n     * approve should be called when _allowance[spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        onlyValidAddress(spender)\\n        returns (bool)\\n    {\\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(addedValue);\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the amount of tokens that an owner allowed to a spender.\\n     *\\n     * approve should be called when _allowance[spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        onlyValidAddress(spender)\\n        onlySufficientAllowance(msg.sender, spender, subtractedValue)\\n        returns (bool)\\n    {\\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(subtractedValue);\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Gets total number of tokens in existence\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balanceOf[owner];\\n    }\\n\\n    /**\\n     * @dev Checks the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowance[owner][spender];\\n    }\\n}\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n * @dev Based on https://github.com/OpenZeppelin/zeppelin-soliditysettable\\n */\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Can only be called by the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyValidAddress(address addr) {\\n        require(addr != address(0), \\\"Address cannot be zero\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner)\\n        public\\n        onlyOwner\\n        onlyValidAddress(newOwner)\\n    {\\n        emit OwnershipTransferred(owner, newOwner);\\n\\n        owner = newOwner;\\n    }\\n}\\n\\n\\n/**\\n * @title Mintable token\\n * @dev Standard token with minting\\n * @dev Based on https://github.com/OpenZeppelin/zeppelin-solidity\\n */\\ncontract MintableToken is StandardToken, Ownable {\\n    bool public mintingFinished;\\n    uint256 public cap;\\n\\n    event Mint(address indexed to, uint256 amount);\\n    event MintFinished();\\n\\n    modifier onlyMinting() {\\n        require(!mintingFinished, \\\"Minting is already finished\\\");\\n        _;\\n    }\\n\\n    modifier onlyNotExceedingCap(uint256 amount) {\\n        require(_totalSupply.add(amount) \\u003c= cap, \\\"Total supply must not exceed cap\\\");\\n        _;\\n    }\\n\\n    constructor(uint256 _cap) public {\\n        cap = _cap;\\n    }\\n\\n    /**\\n     * @dev Creates new tokens for the given address\\n     * @param to The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address to, uint256 amount)\\n        public\\n        onlyOwner\\n        onlyMinting\\n        onlyValidAddress(to)\\n        onlyNotExceedingCap(amount)\\n        returns (bool)\\n    {\\n        mintImpl(to, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates new tokens for the given addresses\\n     * @param addresses The array of addresses that will receive the minted tokens.\\n     * @param amounts The array of amounts of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mintMany(address[] addresses, uint256[] amounts)\\n        public\\n        onlyOwner\\n        onlyMinting\\n        onlyNotExceedingCap(sum(amounts))\\n        returns (bool)\\n    {\\n        require(\\n            addresses.length == amounts.length,\\n            \\\"Addresses array must be the same size as amounts array\\\"\\n        );\\n\\n        for (uint256 i = 0; i \\u003c addresses.length; i++) {\\n            require(addresses[i] != address(0), \\\"Address cannot be zero\\\");\\n            mintImpl(addresses[i], amounts[i]);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Stops minting new tokens.\\n     * @return True if the operation was successful.\\n     */\\n    function finishMinting()\\n        public\\n        onlyOwner\\n        onlyMinting\\n        returns (bool)\\n    {\\n        mintingFinished = true;\\n\\n        emit MintFinished();\\n\\n        return true;\\n    }\\n\\n    function mintImpl(address to, uint256 amount) private {\\n        _totalSupply = _totalSupply.add(amount);\\n        _balanceOf[to] = _balanceOf[to].add(amount);\\n\\n        emit Mint(to, amount);\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function sum(uint256[] arr) private pure returns (uint256) {\\n        uint256 aggr = 0;\\n        for (uint256 i = 0; i \\u003c arr.length; i++) {\\n            aggr = aggr.add(arr[i]);\\n        }\\n        return aggr;\\n    }\\n}\\n\\n\\ncontract PhotonTestToken is MintableToken {\\n    string public name = \\\"PhotonTestToken\\\";\\n    string public symbol = \\\"PHT\\\";\\n    uint256 public decimals = 18;\\n    uint256 public cap = 120 * 10**6 * 10**decimals;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() public MintableToken(cap) {}\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licensee\",\"type\":\"address\"}],\"name\":\"getLicenses\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"getOffers\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"offers\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"licenseType\",\"type\":\"uint8\"},{\"name\":\"isCancelled\",\"type\":\"bool\"},{\"name\":\"photoDigest\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getOfferById\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"licenseType\",\"type\":\"uint8\"},{\"name\":\"isCancelled\",\"type\":\"bool\"},{\"name\":\"photoDigest\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setOfferPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offersBySeller\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_licenseType\",\"type\":\"uint8\"},{\"name\":\"_photoDigest\",\"type\":\"bytes32\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offersByLicensee\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_licensee\",\"type\":\"address\"}],\"name\":\"acceptOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"licenseType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"photoDigest\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"OfferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"licensee\",\"type\":\"address\"}],\"name\":\"OfferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"OfferPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PhotochainMarketplace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000088652845a5495983b70aebbf25102361552d5e54","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://1063abc26092b2aa3492b92f9e141b5fd4d7dee7eb53b9b2e7bc10d3208e0a67"}]}