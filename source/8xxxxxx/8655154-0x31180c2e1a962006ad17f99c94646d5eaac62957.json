{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract OtcInterface {\r\n    function getOffer(uint id) external view returns (uint, ERC20, uint, ERC20);\r\n    function getBestOffer(ERC20 sellGem, ERC20 buyGem) external view returns(uint);\r\n    function getWorseOffer(uint id) external view returns(uint);\r\n    function take(bytes32 id, uint128 maxTakeAmount) external;\r\n}\r\n\r\n\r\ncontract WethInterface is ERC20 {\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address payable destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        external\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[] memory) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[] memory) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                emit AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n\r\ncontract Eth2DaiReserve is KyberReserveInterface, Withdrawable {\r\n\r\n    uint constant POW_2_32 = 2 ** 32;\r\n    uint constant POW_2_96 = 2 ** 96;\r\n    uint constant BASIC_FACTOR_STEP = 100000;\r\n\r\n    // constants\r\n    uint constant internal MAX_QTY = (10**28); // 10B tokens\r\n    uint constant internal MAX_RATE = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint constant internal PRECISION = 10**18;\r\n    uint constant internal INVALID_ID = uint(-1);\r\n    uint constant internal COMMON_DECIMALS = 18;\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    // values\r\n    address public kyberNetwork;\r\n    bool public tradeEnabled;\r\n    uint public feeBps;\r\n\r\n    OtcInterface public otc = OtcInterface(0x39755357759cE0d7f32dC8dC45414CCa409AE24e);\r\n    WethInterface public wethToken = WethInterface(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    ERC20 public DAIToken = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n\r\n    mapping(address => bool) public isTokenListed;\r\n    // 96 bits: min token, 96 bits: max token, 32 bits: premiumBps, 32 bits: minSpreadBps;\r\n    mapping(address => uint) internalInventoryData;\r\n    // basicData contains compact data of min eth support, max traverse and max takes\r\n    // min eth support (first 192 bits) + max traverse (32 bits) + max takes (32 bits) = 256 bits\r\n    mapping(address => uint) tokenBasicData;\r\n    // factorData contains compact data of factors to compute max traverse, max takes, and min take order size\r\n    // 6 params, each 32 bits (6 * 32 = 192 bits)\r\n    mapping(address => uint) tokenFactorData;\r\n\r\n    struct BasicDataConfig {\r\n        uint minETHSupport;\r\n        uint maxTraverse;\r\n        uint maxTakes;\r\n    }\r\n\r\n    struct FactorDataConfig {\r\n        uint maxTraverseX;\r\n        uint maxTraverseY;\r\n        uint maxTakeX;\r\n        uint maxTakeY;\r\n        uint minOrderSizeX;\r\n        uint minOrderSizeY;\r\n    }\r\n\r\n    struct InternalInventoryData {\r\n        uint minTokenBal;\r\n        uint maxTokenBal;\r\n        uint premiumBps;\r\n        uint minSpreadBps;\r\n    }\r\n\r\n    struct OfferData {\r\n        uint payAmount;\r\n        uint buyAmount;\r\n        uint id;\r\n    }\r\n\r\n    constructor(address _kyberNetwork, uint _feeBps, address _admin) public {\r\n        require(_kyberNetwork != address(0), \"constructor: kyberNetwork's address is missing\");\r\n        require(_feeBps < 10000, \"constructor: fee >= 10000\");\r\n        require(_admin != address(0), \"constructor: admin is missing\");\r\n        require(getDecimals(wethToken) == COMMON_DECIMALS, \"constructor: wethToken's decimals is not COMMON_DECIMALS\");\r\n        require(wethToken.approve(address(otc), 2**255), \"constructor: failed to approve otc (wethToken)\");\r\n    \r\n        kyberNetwork = _kyberNetwork;\r\n        feeBps = _feeBps;\r\n        admin = _admin;\r\n        tradeEnabled = true;\r\n    }\r\n\r\n    function() external payable {\r\n    }\r\n\r\n    /**\r\n        Returns conversion rate of given pair and srcQty, use 1 as srcQty if srcQty = 0\r\n        Using eth amount to compute offer limit configurations\r\n        => need to check spread is ok for token -> eth\r\n        Last bit of the rate indicates whether to use internal inventory:\r\n          0 - use eth2dai\r\n          1 - use internal inventory\r\n    */\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint) public view returns(uint) {\r\n        if (!tradeEnabled) { return 0; }\r\n        // check if token's listed\r\n        ERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\r\n        if (!isTokenListed[address(token)]) { return 0; }\r\n        \r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(token);\r\n\r\n        // if token is src, need to check for valid spread, \r\n        if (token == src && !checkValidSpread(bid, ask, false, 0)) { return 0; }\r\n\r\n        uint destAmount;\r\n        OfferData[] memory offers;\r\n\r\n        // using 1 as default value if srcQty is 0\r\n        uint srcAmount = srcQty == 0 ? 1 : srcQty;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            (destAmount, offers) = findBestOffers(dest, wethToken, srcAmount, bid, ask);\r\n        } else {\r\n            (destAmount, offers) = findBestOffers(wethToken, src, srcAmount, bid, ask);\r\n        }\r\n\r\n        if (offers.length == 0 || destAmount == 0) { return 0; } // no offer or destAmount == 0, return 0 for rate\r\n\r\n        uint rate = calcRateFromQty(srcAmount, destAmount, COMMON_DECIMALS, COMMON_DECIMALS);\r\n\r\n        bool useInternalInventory;\r\n        uint premiumBps;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            (useInternalInventory, premiumBps) = shouldUseInternalInventory(dest,\r\n                                                                            destAmount,\r\n                                                                            srcAmount,\r\n                                                                            true,\r\n                                                                            bid,\r\n                                                                            ask\r\n                                                                            );\r\n        } else {\r\n            (useInternalInventory, premiumBps) = shouldUseInternalInventory(src,\r\n                                                                            srcAmount,\r\n                                                                            destAmount,\r\n                                                                            false,\r\n                                                                            bid,\r\n                                                                            ask\r\n                                                                            );\r\n        }\r\n\r\n        if (useInternalInventory) {\r\n            rate = valueAfterAddingPremium(rate, premiumBps);\r\n        } else {\r\n            rate = valueAfterReducingFee(rate);\r\n        }\r\n\r\n        return applyInternalInventoryHintToRate(rate, useInternalInventory);\r\n    }\r\n\r\n    event TradeExecute(\r\n        address indexed origin,\r\n        address src,\r\n        uint srcAmount,\r\n        address destToken,\r\n        uint destAmount,\r\n        address payable destAddress\r\n    );\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address payable destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(tradeEnabled, \"trade: tradeEnabled is false\");\r\n        require(msg.sender == kyberNetwork, \"trade: not call from kyberNetwork's contract\");\r\n        require(srcToken == ETH_TOKEN_ADDRESS || destToken == ETH_TOKEN_ADDRESS, \"trade: srcToken or destToken must be ETH\");\r\n\r\n        ERC20 token = srcToken == ETH_TOKEN_ADDRESS ? destToken : srcToken;\r\n        require(isTokenListed[address(token)], \"trade: token is not listed\");\r\n\r\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate), \"trade: doTrade returns false\");\r\n        return true;\r\n    }\r\n\r\n    /// @dev do a trade\r\n    /// @param srcToken Src token\r\n    /// @param srcAmount Amount of src token\r\n    /// @param destToken Destination token\r\n    /// @param destAddress Destination address to send tokens to\r\n    /// @return true iff trade is successful\r\n    function doTrade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address payable destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        // can skip validation if done at kyber network level\r\n        if (validate) {\r\n            require(conversionRate > 0, \"doTrade: conversionRate is 0\");\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount, \"doTrade: msg.value != srcAmount\");\r\n            else\r\n                require(msg.value == 0, \"doTrade: msg.value must be 0\");\r\n        }\r\n\r\n        uint userExpectedDestAmount = calcDstQty(srcAmount, COMMON_DECIMALS, COMMON_DECIMALS, conversionRate);\r\n        require(userExpectedDestAmount > 0, \"doTrade: userExpectedDestAmount == 0\"); // sanity check\r\n\r\n        uint actualDestAmount;\r\n\r\n        // using hint to check if we should use our internal inventory\r\n        bool useInternalInventory = conversionRate % 2 == 1;\r\n\r\n        if (useInternalInventory) {\r\n            // taking from internal inventory and return\r\n            if (srcToken == ETH_TOKEN_ADDRESS) {\r\n                // transfer back only requested dest amount.\r\n                require(destToken.transfer(destAddress, userExpectedDestAmount), \"doTrade: (useInternalInventory) can not transfer back token\");\r\n            } else {\r\n                // collect src token\r\n                require(srcToken.transferFrom(msg.sender, address(this), srcAmount), \"doTrade: (useInternalInventory) can not collect src token\");\r\n                // transfer back only requested dest amount.\r\n                destAddress.transfer(userExpectedDestAmount);\r\n            }\r\n\r\n            emit TradeExecute(msg.sender, address(srcToken), srcAmount, address(destToken), userExpectedDestAmount, destAddress);\r\n            return true;\r\n        }\r\n\r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(srcToken == ETH_TOKEN_ADDRESS ? destToken : srcToken);\r\n\r\n        // get offers to take\r\n        OfferData [] memory offers;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            (actualDestAmount, offers) = findBestOffers(destToken, wethToken, srcAmount, bid, ask);   \r\n        } else {\r\n            (actualDestAmount, offers) = findBestOffers(wethToken, srcToken, srcAmount, bid, ask);\r\n        }\r\n\r\n        require(actualDestAmount >= userExpectedDestAmount , \"doTrade: actualDestAmount is less than userExpectedDestAmount\");\r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            wethToken.deposit.value(msg.value)();\r\n            actualDestAmount = takeMatchingOrders(destToken, srcAmount, offers);\r\n            require(actualDestAmount >= userExpectedDestAmount, \"doTrade: actualDestAmount is less than userExpectedDestAmount, eth to token\");\r\n            // transfer back only requested dest amount\r\n            require(destToken.transfer(destAddress, userExpectedDestAmount), \"doTrade: can not transfer back requested token\");\r\n        } else {\r\n            // collect src tokens\r\n            require(srcToken.transferFrom(msg.sender, address(this), srcAmount), \"doTrade: can not collect src token\");\r\n            actualDestAmount = takeMatchingOrders(wethToken, srcAmount, offers);\r\n            require(actualDestAmount >= userExpectedDestAmount, \"doTrade: actualDestAmount is less than userExpectedDestAmount, token to eth\");\r\n            wethToken.withdraw(actualDestAmount);\r\n            // transfer back only requested dest amount.\r\n            destAddress.transfer(userExpectedDestAmount);\r\n        }\r\n\r\n        emit TradeExecute(msg.sender, address(srcToken), srcAmount, address(destToken), userExpectedDestAmount, destAddress);\r\n        return true;\r\n    }\r\n\r\n    function takeMatchingOrders(ERC20 destToken, uint srcAmount, OfferData[] memory offers) internal returns(uint actualDestAmount) {\r\n        require(destToken != ETH_TOKEN_ADDRESS, \"takeMatchingOrders: destToken is ETH\");\r\n\r\n        uint lastReserveBalance = destToken.balanceOf(address(this));\r\n        uint remainingSrcAmount = srcAmount;\r\n\r\n        for(uint i = 0; i < offers.length; i++) {\r\n            if (offers[i].id == 0 || remainingSrcAmount == 0) { break; }\r\n\r\n            uint payAmount = minOf(remainingSrcAmount, offers[i].payAmount);\r\n            uint buyAmount = payAmount * offers[i].buyAmount / offers[i].payAmount;\r\n\r\n            otc.take(bytes32(offers[i].id), uint128(buyAmount));\r\n            remainingSrcAmount -= payAmount;\r\n        }\r\n\r\n        // must use all amount\r\n        require(remainingSrcAmount == 0, \"takeMatchingOrders: did not take all src amount\");\r\n\r\n        uint newReserveBalance = destToken.balanceOf(address(this));\r\n\r\n        require(newReserveBalance > lastReserveBalance, \"takeMatchingOrders: newReserveBalance <= lastReserveBalance\");\r\n\r\n        actualDestAmount = newReserveBalance - lastReserveBalance;\r\n    }\r\n\r\n    function shouldUseInternalInventory(ERC20 token,\r\n                                        uint tokenVal,\r\n                                        uint ethVal,\r\n                                        bool ethToToken,\r\n                                        OfferData memory bid,\r\n                                        OfferData memory ask)\r\n        internal\r\n        view\r\n        returns(bool shouldUse, uint premiumBps)\r\n    {\r\n        require(tokenVal <= MAX_QTY, \"shouldUseInternalInventory: tokenVal > MAX_QTY\");\r\n\r\n        InternalInventoryData memory inventoryData = getInternalInventoryData(token);\r\n\r\n        shouldUse = false;\r\n        premiumBps = inventoryData.premiumBps;\r\n\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n\r\n        if (ethToToken) {\r\n            if (tokenBalance < tokenVal) { return (shouldUse, premiumBps); }\r\n            if (tokenVal - tokenVal < inventoryData.minTokenBal) { return (shouldUse, premiumBps); }\r\n        } else {\r\n            if (address(this).balance < ethVal) { return (shouldUse, premiumBps); }\r\n            if (tokenBalance + tokenVal > inventoryData.maxTokenBal) { return (shouldUse, premiumBps); }\r\n        }\r\n\r\n        if (!checkValidSpread(bid, ask, true, inventoryData.minSpreadBps)) {\r\n            return (shouldUse, premiumBps);\r\n        }\r\n\r\n        shouldUse = true;\r\n    }\r\n\r\n    function applyInternalInventoryHintToRate(\r\n        uint rate,\r\n        bool useInternalInventory\r\n    )\r\n        internal\r\n        pure\r\n        returns(uint)\r\n    {\r\n        return rate % 2 == (useInternalInventory ? 1 : 0)\r\n            ? rate\r\n            : rate - 1;\r\n    }\r\n\r\n    function valueAfterReducingFee(uint val) public view returns(uint) {\r\n        require(val <= MAX_QTY, \"valueAfterReducingFee: val > MAX_QTY\");\r\n        return ((10000 - feeBps) * val) / 10000;\r\n    }\r\n\r\n    function valueAfterAddingPremium(uint val, uint premium) public pure returns(uint) {\r\n        require(val <= MAX_QTY, \"valueAfterAddingPremium: val > MAX_QTY\");\r\n        return val * (10000 + premium) / 10000;\r\n    }\r\n\r\n    event TokenConfigDataSet(\r\n        ERC20 token, uint maxTraverse, uint traveseFactorX, uint traveseFactorY,\r\n        uint maxTake, uint takeFactorX, uint takeFactorY,\r\n        uint minSizeFactorX, uint minSizeFactorY, uint minETHSupport\r\n    );\r\n\r\n    function setTokenConfigData(\r\n        ERC20 token, uint maxTraverse, uint traveseFactorX, uint traveseFactorY,\r\n        uint maxTake, uint takeFactorX, uint takeFactorY,\r\n        uint minSizeFactorX, uint minSizeFactorY, uint minETHSupport) public {\r\n        address tokenAddr = address(token);\r\n        require(isTokenListed[tokenAddr]);\r\n        tokenBasicData[tokenAddr] = encodeTokenBasicData(minETHSupport, maxTraverse, maxTake);\r\n        tokenFactorData[tokenAddr] = encodeFactorData(\r\n            traveseFactorX,\r\n            traveseFactorY,\r\n            takeFactorX,\r\n            takeFactorY,\r\n            minSizeFactorX,\r\n            minSizeFactorY\r\n        );\r\n        emit TokenConfigDataSet(\r\n            token, maxTraverse, traveseFactorX, takeFactorY,\r\n            maxTake, takeFactorX, takeFactorY,\r\n            minSizeFactorX, minSizeFactorY, minETHSupport\r\n        );\r\n    }\r\n\r\n    event TradeEnabled(bool enable);\r\n\r\n    function enableTrade() public onlyAdmin returns(bool) {\r\n        tradeEnabled = true;\r\n        emit TradeEnabled(true);\r\n\r\n        return true;\r\n    }\r\n\r\n    function disableTrade() public onlyAlerter returns(bool) {\r\n        tradeEnabled = false;\r\n        emit TradeEnabled(false);\r\n\r\n        return true;\r\n    }\r\n\r\n    event KyberNetworkSet(address kyberNetwork);\r\n\r\n    function setKyberNetwork(address _kyberNetwork) public onlyAdmin {\r\n        require(_kyberNetwork != address(0), \"setKyberNetwork: kyberNetwork's address is missing\");\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        emit KyberNetworkSet(kyberNetwork);\r\n    }\r\n\r\n    event InternalInventoryDataSet(uint minToken, uint maxToken, uint pricePremiumBps, uint minSpreadBps);\r\n\r\n    function setInternalInventoryData(ERC20 token, uint minToken, uint maxToken, uint pricePremiumBps, uint minSpreadBps) public onlyAdmin {\r\n        require(isTokenListed[address(token)], \"setInternalInventoryData: token is not listed\");\r\n        require(minToken < POW_2_96, \"setInternalInventoryData: minToken > 2**96\");\r\n        require(maxToken < POW_2_96, \"setInternalInventoryData: maxToken > 2**96\");\r\n        require(pricePremiumBps < POW_2_32, \"setInternalInventoryData: pricePremiumBps > 2**32\");\r\n        require(minSpreadBps < POW_2_32, \"setInternalInventoryData: minSpreadBps > 2**32\");\r\n        // blocking too small minSpreadBps\r\n        require(2 * minSpreadBps >= (feeBps + pricePremiumBps), \"setInternalInventoryData: minSpreadBps should be >= (feeBps + pricePremiumBps)/2\");\r\n\r\n        internalInventoryData[address(token)] = encodeInternalInventoryData(minToken, maxToken, pricePremiumBps, minSpreadBps);\r\n\r\n        emit InternalInventoryDataSet(minToken, maxToken, pricePremiumBps, minSpreadBps);\r\n    }\r\n\r\n    event TokenListed(ERC20 token);\r\n\r\n    function listToken(ERC20 token) public onlyAdmin {\r\n        address tokenAddr = address(token);\r\n\r\n        require(tokenAddr != address(0), \"listToken: token's address is missing\");\r\n        require(!isTokenListed[tokenAddr], \"listToken: token's alr listed\");\r\n        require(getDecimals(token) == COMMON_DECIMALS, \"listToken: token's decimals is not COMMON_DECIMALS\");\r\n        require(token.approve(address(otc), 2**255), \"listToken: approve token otc failed\");\r\n\r\n        isTokenListed[tokenAddr] = true;\r\n\r\n        emit TokenListed(token);\r\n    }\r\n\r\n    event TokenDelisted(ERC20 token);\r\n\r\n    function delistToken(ERC20 token) public onlyAdmin {\r\n        address tokenAddr = address(token);\r\n\r\n        require(isTokenListed[tokenAddr], \"delistToken: token is not listed\");\r\n        require(token.approve(address(otc), 0), \"delistToken: reset approve token failed\");\r\n\r\n        delete isTokenListed[tokenAddr];\r\n        delete internalInventoryData[tokenAddr];\r\n        delete tokenFactorData[tokenAddr];\r\n        delete tokenBasicData[tokenAddr];\r\n\r\n        emit TokenDelisted(token);\r\n    }\r\n\r\n    event FeeBpsSet(uint feeBps);\r\n\r\n    function setFeeBps(uint _feeBps) public onlyAdmin {\r\n        require(_feeBps < 10000, \"setFeeBps: feeBps >= 10000\");\r\n\r\n        feeBps = _feeBps;\r\n        emit FeeBpsSet(feeBps);\r\n    }\r\n\r\n    function showBestOffers(ERC20 token, bool isEthToToken, uint srcAmountToken) public view\r\n        returns(uint destAmount, uint destAmountToken, uint [] memory offerIds) \r\n    {\r\n        OfferData [] memory offers;\r\n        ERC20 dstToken = isEthToToken ? token : wethToken;\r\n        ERC20 srcToken = isEthToToken ? wethToken : token;\r\n\r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(token);\r\n\r\n        (destAmount, offers) = findBestOffers(dstToken, srcToken, (srcAmountToken * 10 ** 18), bid, ask);\r\n        \r\n        destAmountToken = destAmount / 10 ** 18;\r\n        \r\n        uint i;\r\n        for (i; i < offers.length; i++) {\r\n            if (offers[i].id == 0) {\r\n                break;\r\n            }\r\n        }\r\n    \r\n        offerIds = new uint[](i);\r\n        for (i = 0; i < offerIds.length; i++) {\r\n            offerIds[i] = offers[i].id;\r\n        }\r\n    }    \r\n    \r\n    function findBestOffers(ERC20 dstToken, ERC20 srcToken, uint srcAmount, OfferData memory bid, OfferData memory ask)\r\n        internal view\r\n        returns(uint totalDestAmount, OfferData [] memory offers)\r\n    {\r\n        uint remainingSrcAmount = srcAmount;\r\n        uint maxOrdersToTake;\r\n        uint maxTraversedOrders;\r\n        uint minPayAmount;\r\n        uint numTakenOffer = 0;\r\n        totalDestAmount = 0;\r\n        ERC20 token = srcToken == wethToken ? dstToken : srcToken;\r\n\r\n        (maxOrdersToTake, maxTraversedOrders, minPayAmount) = calcOfferLimitsFromFactorData(\r\n            token,\r\n            (srcToken == wethToken),\r\n            bid,\r\n            ask,\r\n            srcAmount\r\n        );\r\n\r\n        offers = new OfferData[](maxTraversedOrders);\r\n\r\n        // return earlier, we don't want to take any orders\r\n        if (maxTraversedOrders == 0 || maxOrdersToTake == 0) {\r\n            return (totalDestAmount, offers);\r\n        }\r\n\r\n        // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n        // if we don't have first offer, try to get it\r\n        if ((srcToken == wethToken && bid.id == 0) || (dstToken == wethToken && ask.id == 0)) {\r\n            offers[0].id = otc.getBestOffer(dstToken, srcToken);\r\n            // assuming pay amount is taker pay amount. (in otc it is used differently)\r\n            (offers[0].buyAmount, , offers[0].payAmount, ) = otc.getOffer(offers[0].id);\r\n        } else {\r\n            offers[0] = srcToken == wethToken ? bid : ask;\r\n        }\r\n\r\n        // putting here so if src amount is 0, we won't revert and still consider the first order as rate\r\n        if (remainingSrcAmount == 0) { return (totalDestAmount, offers); }\r\n\r\n        uint thisOffer;\r\n\r\n        OfferData memory biggestSkippedOffer = OfferData(0, 0, 0);\r\n\r\n        for ( ;maxTraversedOrders > 0 ; --maxTraversedOrders) {\r\n            thisOffer = numTakenOffer;\r\n\r\n            // in case both biggestSkippedOffer & current offer have amount >= remainingSrcAmount\r\n            // biggestSkippedOffer should have better rate than current offer\r\n            if (biggestSkippedOffer.payAmount >= remainingSrcAmount) {\r\n                offers[numTakenOffer].id = biggestSkippedOffer.id;\r\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * biggestSkippedOffer.buyAmount / biggestSkippedOffer.payAmount;\r\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\r\n                totalDestAmount += offers[numTakenOffer].buyAmount;\r\n                ++numTakenOffer;\r\n                remainingSrcAmount = 0;\r\n                break;\r\n            } else if (offers[numTakenOffer].payAmount >= remainingSrcAmount) {\r\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * offers[numTakenOffer].buyAmount / offers[numTakenOffer].payAmount;\r\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\r\n                totalDestAmount += offers[numTakenOffer].buyAmount;\r\n                ++numTakenOffer;\r\n                remainingSrcAmount = 0;\r\n                break;\r\n            } else if ((maxOrdersToTake - numTakenOffer) > 1\r\n                        && offers[numTakenOffer].payAmount >= minPayAmount) {\r\n                totalDestAmount += offers[numTakenOffer].buyAmount;\r\n                remainingSrcAmount -= offers[numTakenOffer].payAmount;\r\n                ++numTakenOffer;\r\n            } else if (offers[numTakenOffer].payAmount > biggestSkippedOffer.payAmount) {\r\n                biggestSkippedOffer.payAmount = offers[numTakenOffer].payAmount;\r\n                biggestSkippedOffer.buyAmount = offers[numTakenOffer].buyAmount;\r\n                biggestSkippedOffer.id = offers[numTakenOffer].id;\r\n            }\r\n\r\n            offers[numTakenOffer].id = otc.getWorseOffer(offers[thisOffer].id);\r\n            (offers[numTakenOffer].buyAmount, , offers[numTakenOffer].payAmount, ) = otc.getOffer(offers[numTakenOffer].id);\r\n        }\r\n\r\n        if (remainingSrcAmount > 0) totalDestAmount = 0;\r\n        if (totalDestAmount == 0) offers = new OfferData[](0);\r\n    }\r\n\r\n    // just use for testing, give src/dest amount to compute rate should be a sell offer data\r\n    function calcOfferLimitsFromFactorDataPub(ERC20 token, bool isEthToToken, uint sellTokenSrcAmt, uint sellTokenDstAmt, uint srcAmount)\r\n        public view\r\n        returns(uint maxTakes, uint maxTraverse, uint minPayAmount)\r\n    {\r\n        (maxTakes, maxTraverse, minPayAmount) = calcOfferLimitsFromFactorData(\r\n            token,\r\n            isEthToToken,\r\n            OfferData(0, sellTokenDstAmt, sellTokenSrcAmt),\r\n            OfferData(0, sellTokenSrcAmt, sellTokenDstAmt),\r\n            srcAmount\r\n        );\r\n    }\r\n\r\n    // just use for testing, but with real data\r\n    function calcOfferLimitsFromFactorDataPub2(ERC20 token, bool isEthToToken, uint srcAmount)\r\n        public view\r\n        returns(uint maxTakes, uint maxTraverse, uint minPayAmount)\r\n    {\r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(token);\r\n        (maxTakes, maxTraverse, minPayAmount) = calcOfferLimitsFromFactorData(\r\n            token,\r\n            isEthToToken,\r\n            bid,\r\n            ask,\r\n            srcAmount\r\n        );\r\n    }\r\n\r\n    // returns max takes, max traveser, min order size to take using config factor data\r\n    function calcOfferLimitsFromFactorData(ERC20 token, bool isEthToToken, OfferData memory bid, OfferData memory ask, uint srcAmount)\r\n        internal view\r\n        returns(uint maxTakes, uint maxTraverse, uint minPayAmount)\r\n    {\r\n        if (!isEthToToken && (ask.id == 0 || bid.id == 0)) {\r\n            // need to compute equivalent eth amount but no ask and bid offers are available\r\n            maxTakes = 0;\r\n            maxTraverse = 0;\r\n            minPayAmount = 0;\r\n            return (maxTakes, maxTraverse, minPayAmount);\r\n        }\r\n\r\n        uint order0Pay = 0;\r\n        uint order0Buy = 0;\r\n\r\n        if (!isEthToToken) {\r\n            // only need to use median when token -> eth trade\r\n            // rate eth/dai: order0Buy / order0Pay\r\n            order0Pay = ask.payAmount;\r\n            // sell eth rate        : ask.buyAmount / ask.payAmount\r\n            // buy eth rate         : bid.payAmount / bid.buyAmount\r\n            // median rate (eth/dai): (ask.buyAmount / ask.payAmount + bid.payAmount / bid.buyAmount) / 2;\r\n            // take amt dai         : ask.payAmount\r\n            // -> amt eth           : ask.payAmount * (ask.buyAmount / ask.payAmount + bid.payAmount / bid.buyAmount) / 2;\r\n            order0Buy = (ask.buyAmount + ask.payAmount * bid.payAmount / bid.buyAmount) / 2;\r\n        }\r\n\r\n        uint ethOrderSize = isEthToToken ? srcAmount : srcAmount * order0Buy / order0Pay;\r\n\r\n        BasicDataConfig memory basicData = getTokenBasicData(token);\r\n\r\n        if (basicData.minETHSupport > ethOrderSize) {\r\n            maxTakes = 0;\r\n            maxTraverse = 0;\r\n            minPayAmount = 0;\r\n            return (maxTakes, maxTraverse, minPayAmount);\r\n        }\r\n\r\n        FactorDataConfig memory factorData = getFactorData(token);\r\n\r\n        maxTraverse = (factorData.maxTraverseX * ethOrderSize / PRECISION + factorData.maxTraverseY) / BASIC_FACTOR_STEP;\r\n        maxTraverse = minOf(maxTraverse, basicData.maxTraverse);\r\n\r\n        maxTakes = (factorData.maxTakeX * ethOrderSize / PRECISION + factorData.maxTakeY) / BASIC_FACTOR_STEP;\r\n        maxTakes = minOf(maxTakes, basicData.maxTakes);\r\n\r\n        uint minETHAmount = (factorData.minOrderSizeX * ethOrderSize + factorData.minOrderSizeY * PRECISION) / BASIC_FACTOR_STEP;\r\n\r\n        // translate min amount to pay token\r\n        minPayAmount = isEthToToken ? minETHAmount : minETHAmount * order0Pay / order0Buy;\r\n    }\r\n\r\n    function getFirstOffer(ERC20 offerSellGem, ERC20 offerBuyGem)\r\n        public view\r\n        returns(uint offerId, uint offerPayAmount, uint offerBuyAmount)\r\n    {\r\n        offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\r\n        (offerBuyAmount, ,offerPayAmount, ) = otc.getOffer(offerId);\r\n    }\r\n\r\n    function getNextBestOffer(\r\n        ERC20 offerSellGem,\r\n        ERC20 offerBuyGem,\r\n        uint payAmount,\r\n        uint prevOfferId\r\n    )\r\n        public\r\n        view\r\n        returns(\r\n            uint offerId,\r\n            uint offerPayAmount,\r\n            uint offerBuyAmount\r\n        )\r\n    {\r\n        if (prevOfferId == INVALID_ID) {\r\n            offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\r\n        } else {\r\n            offerId = otc.getWorseOffer(prevOfferId);\r\n        }\r\n\r\n        (offerBuyAmount, ,offerPayAmount, ) = otc.getOffer(offerId);\r\n\r\n        while (payAmount > offerPayAmount) {\r\n            offerId = otc.getWorseOffer(offerId); // next best offer\r\n            if (offerId == 0) {\r\n                offerId = 0;\r\n                offerPayAmount = 0;\r\n                offerBuyAmount = 0;\r\n                break;\r\n            }\r\n            (offerBuyAmount, ,offerPayAmount, ) = otc.getOffer(offerId);\r\n        }\r\n    }\r\n    \r\n    function getEthToDaiOrders(uint numOrders) public view\r\n        returns(uint [] memory ethPayAmtTokens, uint [] memory daiBuyAmtTokens, uint [] memory rateDaiDivEthx10, uint [] memory Ids,\r\n        uint totalBuyAmountDAIToken, uint totalPayAmountEthers, uint totalRateDaiDivEthx10) \r\n    {\r\n        uint offerId = INVALID_ID;\r\n        ethPayAmtTokens = new uint[](numOrders);\r\n        daiBuyAmtTokens = new uint[](numOrders);    \r\n        rateDaiDivEthx10 = new uint[](numOrders);\r\n        Ids = new uint[](numOrders);\r\n        \r\n        uint offerBuyAmt;\r\n        uint offerPayAmt;\r\n        \r\n        for (uint i = 0; i < numOrders; i++) {\r\n            \r\n            (offerId, offerPayAmt, offerBuyAmt) = getNextBestOffer(DAIToken, wethToken, 1, offerId);\r\n            \r\n            totalBuyAmountDAIToken += offerBuyAmt;\r\n            totalPayAmountEthers += offerPayAmt;\r\n            \r\n            ethPayAmtTokens[i] = offerPayAmt / 10 ** 18;\r\n            daiBuyAmtTokens[i] = offerBuyAmt / 10 ** 18;\r\n            rateDaiDivEthx10[i] = (offerBuyAmt * 10) / offerPayAmt;\r\n            Ids[i] = offerId;\r\n            \r\n            if(offerId == 0) break;\r\n        }\r\n        \r\n        totalRateDaiDivEthx10 = totalBuyAmountDAIToken * 10 / totalPayAmountEthers;\r\n        totalBuyAmountDAIToken /= 10 ** 18;\r\n        totalPayAmountEthers /= 10 ** 18;\r\n    }\r\n    \r\n    function getDaiToEthOrders(uint numOrders) public view\r\n        returns(uint [] memory daiPayAmtTokens, uint [] memory ethBuyAmtTokens, uint [] memory rateDaiDivEthx10, uint [] memory Ids,\r\n        uint totalPayAmountDAIToken, uint totalBuyAmountEthers, uint totalRateDaiDivEthx10)\r\n    {\r\n        uint offerId = INVALID_ID;\r\n        daiPayAmtTokens = new uint[](numOrders);\r\n        ethBuyAmtTokens = new uint[](numOrders);\r\n        rateDaiDivEthx10 = new uint[](numOrders);\r\n        Ids = new uint[](numOrders);\r\n        \r\n        uint offerBuyAmt;\r\n        uint offerPayAmt;\r\n\r\n        for (uint i = 0; i < numOrders; i++) {\r\n\r\n            (offerId, offerPayAmt, offerBuyAmt) = getNextBestOffer(wethToken, DAIToken, 1, offerId);\r\n            \r\n            totalPayAmountDAIToken += offerPayAmt;\r\n            totalBuyAmountEthers += offerBuyAmt;\r\n            \r\n            daiPayAmtTokens[i] = offerPayAmt / 10 ** 18;\r\n            ethBuyAmtTokens[i] = offerBuyAmt / 10 ** 18;\r\n            rateDaiDivEthx10[i] = (offerPayAmt * 10) / offerBuyAmt;\r\n            Ids[i] = offerId;\r\n            \r\n            if (offerId == 0) break;\r\n        }\r\n        \r\n        totalRateDaiDivEthx10 = totalPayAmountDAIToken * 10 / totalBuyAmountEthers;\r\n        totalPayAmountDAIToken /= 10 ** 18;\r\n        totalBuyAmountEthers /= 10 ** 18;\r\n    }\r\n\r\n    function getFirstBidAndAskOrdersPub(ERC20 token)\r\n        public view\r\n        returns(uint bidPayAmt, uint bidBuyAmt, uint askPayAmt, uint askBuyAmt)\r\n    {\r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(token);\r\n        bidPayAmt = bid.payAmount;\r\n        bidBuyAmt = bid.buyAmount;\r\n        askPayAmt = ask.payAmount;\r\n        askBuyAmt = ask.buyAmount;\r\n    }\r\n\r\n    // bid: buy WETH, ask: sell WETH (their base token is DAI)\r\n    function getFirstBidAndAskOrders(ERC20 token) internal view returns(OfferData memory bid, OfferData memory ask) {\r\n        // getting first bid offer (buy WETH)\r\n        (bid.id, bid.payAmount, bid.buyAmount) = getFirstOffer(token, wethToken);\r\n        // getting first ask offer (sell WETH)\r\n        (ask.id, ask.payAmount, ask.buyAmount) = getFirstOffer(wethToken, token);\r\n    }\r\n\r\n    // for testing only\r\n    function checkValidSpreadPub(ERC20 token, uint minSpreadBps) public view returns(bool) {\r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(token);\r\n        return checkValidSpread(bid, ask, true, minSpreadBps);\r\n    }\r\n    \r\n    function checkValidSpread(OfferData memory bid, OfferData memory ask, bool isCheckingMinSpread, uint minSpreadBps)\r\n        internal\r\n        pure\r\n        returns(bool)\r\n    {\r\n        // if no bid or ask order, consider as invalid spread?\r\n        if (bid.id == 0 || ask.id == 0 || bid.buyAmount > MAX_QTY || bid.payAmount > MAX_QTY || ask.buyAmount > MAX_QTY || ask.payAmount > MAX_QTY) {\r\n            return false;\r\n        }\r\n\r\n        // sell eth rate : ask.payAmount / ask.buyAmount\r\n        // buy eth rate  : bid.buyAmount / bid.payAmount\r\n        // sell > buy   -> ask.payAmount / ask.buyAmount > bid.buyAmount / bid.payAmount\r\n        //              -> ask.payAmount * bid.payA mount > ask.buyAmount * bid.buyAmount;\r\n        // slippage  : (sell - buy) / buy\r\n        //          -> (ask.payAmount / ask.buyAmount - bid.buyAmount / bid.payAmount) / (bid.buyAmount / bid.payAmount);\r\n\r\n        uint x1 = ask.payAmount * bid.payAmount;\r\n        uint x2 = ask.buyAmount * bid.buyAmount;\r\n\r\n        // must check sellRate > buyRate\r\n        if (x1 <= x2) { return false; }\r\n\r\n        // if no need to check for min spread, return true here\r\n        if (!isCheckingMinSpread) { return true; }\r\n\r\n        // spread should be bigger than minSpreadBps\r\n        if (10000 * (x1 - x2) <= x2 * minSpreadBps) { return false; }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getTokenBasicDataPub(ERC20 token)\r\n        public view\r\n        returns (uint minETHSupport, uint maxTraverse, uint maxTakes)\r\n    {\r\n        (minETHSupport, maxTraverse, maxTakes) = decodeTokenBasicData(tokenBasicData[address(token)]);\r\n    }\r\n\r\n    function getTokenBasicData(ERC20 token) \r\n        internal view \r\n        returns(BasicDataConfig memory data)\r\n    {\r\n        (data.minETHSupport, data.maxTraverse, data.maxTakes) = decodeTokenBasicData(tokenBasicData[address(token)]);\r\n    }\r\n\r\n    function getFactorDataPub(ERC20 token)\r\n        public view\r\n        returns (uint maxTraverseX, uint maxTraverseY, uint maxTakeX, uint maxTakeY, uint minOrderSizeX, uint minOrderSizeY)\r\n    {\r\n        (maxTraverseX, maxTraverseY, maxTakeX, maxTakeY, minOrderSizeX, minOrderSizeY) = decodeFactorData(tokenFactorData[address(token)]);\r\n    }\r\n\r\n    function getFactorData(ERC20 token) \r\n        internal view \r\n        returns(FactorDataConfig memory data)\r\n    {\r\n        (data.maxTraverseX, data.maxTraverseY, data.maxTakeX, data.maxTakeY, data.minOrderSizeX, data.minOrderSizeY) = decodeFactorData(tokenFactorData[address(token)]);\r\n    }\r\n\r\n    function getInternalInventoryDataPub(ERC20 token)\r\n        public view\r\n        returns(uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps)\r\n    {\r\n        (minTokenBal, maxTokenBal, premiumBps, minSpreadBps) = decodeInternalInventoryData(internalInventoryData[address(token)]);\r\n    }\r\n\r\n    function getInternalInventoryData(ERC20 token)\r\n        internal view\r\n        returns(InternalInventoryData memory data)\r\n    {\r\n        (uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps) = decodeInternalInventoryData(internalInventoryData[address(token)]);\r\n        data.minTokenBal = minTokenBal;\r\n        data.maxTokenBal = maxTokenBal;\r\n        data.premiumBps = premiumBps;\r\n        data.minSpreadBps = minSpreadBps;\r\n    }\r\n\r\n    function encodeInternalInventoryData(uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps)\r\n        public\r\n        pure\r\n        returns(uint data)\r\n    {\r\n        data = minSpreadBps & (POW_2_32 - 1);\r\n        data |= (premiumBps & (POW_2_32 - 1)) * POW_2_32;\r\n        data |= (maxTokenBal & (POW_2_96 - 1)) * POW_2_32 * POW_2_32;\r\n        data |= (minTokenBal & (POW_2_96 - 1)) * POW_2_96 * POW_2_32 * POW_2_32;\r\n    }\r\n\r\n    function decodeInternalInventoryData(uint data)\r\n        public\r\n        pure\r\n        returns(uint minTokenBal, uint maxTokenBal, uint premiumBps, uint minSpreadBps)\r\n    {\r\n        minSpreadBps = data & (POW_2_32 - 1);\r\n        premiumBps = (data / POW_2_32) & (POW_2_32 - 1);\r\n        maxTokenBal = (data / (POW_2_32 * POW_2_32)) & (POW_2_96 - 1);\r\n        minTokenBal = (data / (POW_2_96 * POW_2_32 * POW_2_32)) & (POW_2_96 - 1);\r\n    }\r\n\r\n    function encodeTokenBasicData(uint ethSize, uint maxTraverse, uint maxTakes) \r\n        public\r\n        pure\r\n        returns(uint data)\r\n    {\r\n        data = maxTakes & (POW_2_32 - 1);\r\n        data |= (maxTraverse & (POW_2_32 - 1)) * POW_2_32;\r\n        data |= (ethSize & (POW_2_96 * POW_2_96 - 1)) * POW_2_32 * POW_2_32;\r\n    }\r\n\r\n    function decodeTokenBasicData(uint data) \r\n        public\r\n        pure\r\n        returns(uint ethSize, uint maxTraverse, uint maxTakes)\r\n    {\r\n        maxTakes = data & (POW_2_32 - 1);\r\n        maxTraverse = (data / POW_2_32) & (POW_2_32 - 1);\r\n        ethSize = (data / (POW_2_32 * POW_2_32)) & (POW_2_96 * POW_2_96 - 1);\r\n    }\r\n\r\n    function encodeFactorData(uint traverseX, uint traverseY, uint takeX, uint takeY, uint minSizeX, uint minSizeY)\r\n        public\r\n        pure\r\n        returns(uint data)\r\n    {\r\n        data = (minSizeY & (POW_2_32 - 1));\r\n        data |= (minSizeX & (POW_2_32 - 1)) * POW_2_32;\r\n        data |= (takeY & (POW_2_32 - 1)) * POW_2_32 * POW_2_32;\r\n        data |= (takeX & (POW_2_32 - 1)) * POW_2_96;\r\n        data |= (traverseY & (POW_2_32 - 1)) * POW_2_96 * POW_2_32;\r\n        data |= (traverseX & (POW_2_32 - 1)) * POW_2_96 * POW_2_32 * POW_2_32;\r\n    }\r\n\r\n    function decodeFactorData(uint data)\r\n        public\r\n        pure\r\n        returns(uint traverseX, uint traverseY, uint takeX, uint takeY, uint minSizeX, uint minSizeY)\r\n    {\r\n        minSizeY = data & (POW_2_32 - 1);\r\n        minSizeX = (data / POW_2_32) & (POW_2_32 - 1);\r\n        takeY = (data / (POW_2_32 * POW_2_32)) & (POW_2_32 - 1);\r\n        takeX = (data / POW_2_96) & (POW_2_32 - 1);\r\n        traverseY = (data / (POW_2_96 * POW_2_32)) & (POW_2_32 - 1);\r\n        traverseX = (data / (POW_2_96 * POW_2_32 * POW_2_32)) & (POW_2_32 - 1);\r\n    }\r\n\r\n    function minOf(uint x, uint y) internal pure returns(uint) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY, \"calcRateFromQty: srcAmount is bigger than MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"calcRateFromQty: destAmount is bigger than MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= COMMON_DECIMALS, \"calcRateFromQty: dstDecimals - srcDecimals > COMMON_DECIMALS\");\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= COMMON_DECIMALS, \"calcRateFromQty: srcDecimals - dstDecimals > COMMON_DECIMALS\");\r\n            return (destAmount * PRECISION * (10 ** (COMMON_DECIMALS - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY, \"calcDstQty: srcQty is bigger than MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"calcDstQty: rate is bigger than MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= COMMON_DECIMALS, \"calcDstQty: dstDecimals - srcDecimals > COMMON_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= COMMON_DECIMALS, \"calcDstQty: srcDecimals - dstDecimals > COMMON_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n    \r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) { return COMMON_DECIMALS; }\r\n        return token.decimals();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"enableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numOrders\",\"type\":\"uint256\"}],\"name\":\"getEthToDaiOrders\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ethPayAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"daiBuyAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rateDaiDivEthx10\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalBuyAmountDAIToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayAmountEthers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRateDaiDivEthx10\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmountToken\",\"type\":\"uint256\"}],\"name\":\"showBestOffers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"}],\"name\":\"valueAfterAddingPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"listToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAIToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traveseFactorX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traveseFactorY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeFactorX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeFactorY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeFactorX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeFactorY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minETHSupport\",\"type\":\"uint256\"}],\"name\":\"setTokenConfigData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"offerSellGem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"offerBuyGem\",\"type\":\"address\"}],\"name\":\"getFirstOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerBuyAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"otc\",\"outputs\":[{\"internalType\":\"contract OtcInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"sellTokenSrcAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTokenDstAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"calcOfferLimitsFromFactorDataPub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPayAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"decodeTokenBasicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethToken\",\"outputs\":[{\"internalType\":\"contract WethInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"}],\"name\":\"setKyberNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"decodeInternalInventoryData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premiumBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSpreadBps\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"validate\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"valueAfterReducingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"}],\"name\":\"setFeeBps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"calcOfferLimitsFromFactorDataPub2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPayAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"offerSellGem\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"offerBuyGem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevOfferId\",\"type\":\"uint256\"}],\"name\":\"getNextBestOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerBuyAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"}],\"name\":\"encodeTokenBasicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePremiumBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSpreadBps\",\"type\":\"uint256\"}],\"name\":\"setInternalInventoryData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getInternalInventoryDataPub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premiumBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSpreadBps\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"delistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFactorDataPub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTraverseX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverseY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTakeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTakeY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOrderSizeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOrderSizeY\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSpreadBps\",\"type\":\"uint256\"}],\"name\":\"checkValidSpreadPub\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premiumBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSpreadBps\",\"type\":\"uint256\"}],\"name\":\"encodeInternalInventoryData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenBasicDataPub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minETHSupport\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"traverseX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traverseY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeY\",\"type\":\"uint256\"}],\"name\":\"encodeFactorData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTokenListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"decodeFactorData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"traverseX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"traverseY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeY\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getFirstBidAndAskOrdersPub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bidPayAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidBuyAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askPayAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askBuyAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numOrders\",\"type\":\"uint256\"}],\"name\":\"getDaiToEthOrders\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"daiPayAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethBuyAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rateDaiDivEthx10\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalPayAmountDAIToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBuyAmountEthers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRateDaiDivEthx10\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"}],\"name\":\"TradeExecute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"traveseFactorX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"traveseFactorY\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takeFactorX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takeFactorY\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSizeFactorX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSizeFactorY\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minETHSupport\",\"type\":\"uint256\"}],\"name\":\"TokenConfigDataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"TradeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"kyberNetwork\",\"type\":\"address\"}],\"name\":\"KyberNetworkSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePremiumBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSpreadBps\",\"type\":\"uint256\"}],\"name\":\"InternalInventoryDataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"}],\"name\":\"FeeBpsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"Eth2DaiReserve","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b540000000000000000000000000000000000000000000000000000000000000019000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b54","Library":"","LicenseType":"None","SwarmSource":"bzzr://ceb2a74211d8595e34cf392138b3b0fbdbc0a81b2af174a075dbc6960de754b5"}]}