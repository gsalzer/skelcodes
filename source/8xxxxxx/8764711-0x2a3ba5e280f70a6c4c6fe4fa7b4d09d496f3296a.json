{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/RTokenStructs.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\ncontract RTokenStructs {\r\n    /**\r\n     * @notice Global stats\r\n     */\r\n    struct GlobalStats {\r\n        /// @notice Total redeemable tokens supply\r\n        uint256 totalSupply;\r\n        /// @notice Total saving assets in redeemable amount\r\n        uint256 totalSavingsAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Account stats\r\n     */\r\n    struct AccountStats {\r\n        /// @notice Cumulative interest generated for the account\r\n        uint256 cumulativeInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice Hat stats\r\n     */\r\n    struct HatStats {\r\n        /// @notice Number of addresses has the hat\r\n        uint256 useCount;\r\n        /// @notice Total net loans distributed through the hat\r\n        uint256 totalLoans;\r\n        /// @notice Total net savings distributed through the hat\r\n        uint256 totalSavings;\r\n    }\r\n\r\n    /**\r\n     * @notice Hat stats stored\r\n     */\r\n    struct HatStatsStored {\r\n        /// @notice Number of addresses has the hat\r\n        uint256 useCount;\r\n        /// @notice Total net loans distributed through the hat\r\n        uint256 totalLoans;\r\n        /// @notice Total net savings distributed through the hat\r\n        uint256 totalInternalSavings;\r\n    }\r\n\r\n    /**\r\n     * @notice Hat structure describes who are the recipients of the interest\r\n     *\r\n     * To be a valid hat structure:\r\n     *   - at least one recipient\r\n     *   - recipients.length == proportions.length\r\n     *   - each value in proportions should be greater than 0\r\n     */\r\n    struct Hat {\r\n        address[] recipients;\r\n        uint32[] proportions;\r\n    }\r\n\r\n    /// @dev Account structure\r\n    struct Account {\r\n        uint256 hatID;\r\n        uint256 rAmount;\r\n        uint256 rInterest;\r\n        mapping(address => uint256) lRecipients;\r\n        uint256 lDebt;\r\n        uint256 sInternalAmount;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IAllocationStrategy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n * @notice Allocation strategy for assets.\r\n *         - It invests the underlying assets into some yield generating contracts,\r\n *           usually lending contracts, in return it gets new assets aka. saving assets.\r\n *         - Sainv assets can be redeemed back to the underlying assets plus interest any time.\r\n */\r\ninterface IAllocationStrategy {\r\n\r\n    /**\r\n     * @notice Underlying asset for the strategy\r\n     * @return address Underlying asset address\r\n     */\r\n    function underlying() external view returns (address);\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the saving assets\r\n     * @return uint256 Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Applies accrued interest to all savings\r\n      * @dev This should calculates interest accrued from the last checkpointed\r\n      *      block up to the current block and writes new checkpoint to storage.\r\n      * @return bool success(true) or failure(false)\r\n      */\r\n    function accrueInterest() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies underlying assets into the market and receives saving assets in exchange\r\n     * @dev Interst shall be accrued\r\n     * @param investAmount The amount of the underlying asset to supply\r\n     * @return uint256 Amount of saving assets created\r\n     */\r\n    function investUnderlying(uint256 investAmount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Sender redeems saving assets in exchange for a specified amount of underlying asset\r\n     * @dev Interst shall be accrued\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint256 Amount of saving assets burned\r\n     */\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/IRToken.sol\r\n\r\npragma solidity ^0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice RToken interface a ERC20 interface and one can mint new tokens by\r\n *      trasfering underlying token into the contract, configure _hats_ for\r\n *      addresses and pay earned interest in new _rTokens_.\r\n */\r\ncontract IRToken is RTokenStructs, IERC20 {\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // For external transactions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function mint(uint256 mintAmount) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a selected hat for the account.\r\n     * @param hatID The id of the selected Hat\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a new hat for the account.\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function mintWithNewHat(\r\n        uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves all tokens from the caller's account to `dst`.\r\n     * @param dst The destination address.\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function transferAll(address dst) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves all tokens from `src` account to `dst`.\r\n     * @param src The source address which approved the msg.sender to spend\r\n     * @param dst The destination address.\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function transferAllFrom(address src, address dst) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeem(uint256 redeemTokens) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems all rTokens in exchange for the underlying asset\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeemAll() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems all rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function redeemAndTransferAll(address redeemTo) external returns (bool);\r\n\r\n    /**\r\n     * @notice Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @param doChangeHat Should the hat of the `msg.sender` be switched to the new one\r\n     * @return uint256 ID of the newly creatd Hat.\r\n     */\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat\r\n    ) external returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Change the hat for `msg.sender`\r\n     * @param hatID The id of the Hat\r\n     * @return bool true=success, otherwise a failure\r\n     */\r\n    function changeHat(uint256 hatID) external returns (bool);\r\n\r\n    /**\r\n     * @notice pay interest to the owner\r\n     * @param owner Account owner address\r\n     * @return bool true=success, otherwise a failure\r\n     *\r\n     * Anyone can trigger the interest distribution on behalf of the recipient,\r\n     * due to the fact that the recipient can be a contract code that has not\r\n     * implemented the interaction with the rToken contract internally`.\r\n     *\r\n     * A interest lock-up period may apply, in order to mitigate the \"hat\r\n     * inheritance scam\".\r\n     */\r\n    function payInterest(address owner) external returns (bool);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Essential info views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the maximum hatID in the system\r\n     */\r\n    function getMaximumHatID() external view returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Get the hatID of the owner and the hat structure\r\n     * @param owner Account owner address\r\n     * @return hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient's relative proportions\r\n     */\r\n    function getHatByAddress(address owner)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 hatID,\r\n            address[] memory recipients,\r\n            uint32[] memory proportions\r\n        );\r\n\r\n    /**\r\n     * @notice Get the hat structure\r\n     * @param hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient's relative proportions\r\n     */\r\n    function getHatByID(uint256 hatID)\r\n        external\r\n        view\r\n        returns (address[] memory recipients, uint32[] memory proportions);\r\n\r\n    /**\r\n     * @notice Amount of saving assets given to the recipient along with the\r\n     *         loans.\r\n     * @param owner Account owner address\r\n     */\r\n    function receivedSavingsOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Amount of token loaned to the recipient along with the savings\r\n     *         assets.\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function receivedLoanOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Get the current interest balance of the owner.\r\n               It is equivalent of: receivedSavings - receivedLoan - freeBalance\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function interestPayableOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // statistics views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the current saving strategy contract\r\n     * @return Saving strategy address\r\n     */\r\n    function getCurrentSavingStrategy() external view returns (address);\r\n\r\n    /**\r\n    * @notice Get saving asset balance for specific saving strategy\r\n    * @return rAmount Balance in redeemable amount\r\n    * @return sAmount Balance in native amount of the strategy\r\n    */\r\n    function getSavingAssetBalance()\r\n        external\r\n        view\r\n        returns (uint256 rAmount, uint256 sAmount);\r\n\r\n    /**\r\n    * @notice Get global stats\r\n    * @return global stats\r\n    */\r\n    function getGlobalStats() external view returns (GlobalStats memory);\r\n\r\n    /**\r\n    * @notice Get account stats\r\n    * @param owner Account owner address\r\n    * @return account stats\r\n    */\r\n    function getAccountStats(address owner)\r\n        external\r\n        view\r\n        returns (AccountStats memory);\r\n\r\n    /**\r\n    * @notice Get hat stats\r\n    * @param hatID Hat ID\r\n    * @return hat stats\r\n    */\r\n    function getHatStats(uint256 hatID)\r\n        external\r\n        view\r\n        returns (HatStats memory);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // admin functions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Change allocation strategy for the contract instance\r\n     * @param allocationStrategy Allocation strategy instance\r\n     */\r\n    function changeAllocationStrategy(IAllocationStrategy allocationStrategy)\r\n        external;\r\n\r\n    /**\r\n     * @notice Change hat for the contract address\r\n     * @param contractAddress contract address\r\n     * @param hatID Hat ID\r\n     */\r\n    function changeHatFor(address contractAddress, uint256 hatID)\r\n        external;\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Events\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address indexed minter, uint256 mintAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(\r\n        address indexed redeemer,\r\n        address indexed redeemTo,\r\n        uint256 redeemAmount\r\n    );\r\n\r\n    /**\r\n     * @notice Event emitted when loans get transferred\r\n     */\r\n    event LoansTransferred(\r\n        address indexed owner,\r\n        address indexed recipient,\r\n        uint256 indexed hatId,\r\n        bool isDistribution,\r\n        uint256 redeemableAmount,\r\n        uint256 savingsAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when interest paid\r\n     */\r\n    event InterestPaid(address indexed recipient, uint256 amount);\r\n\r\n    /**\r\n     * @notice A new hat is created\r\n     */\r\n    event HatCreated(uint256 indexed hatID);\r\n\r\n    /**\r\n     * @notice Hat is changed for the account\r\n     */\r\n    event HatChanged(address indexed account, uint256 indexed oldHatID, uint256 indexed newHatID);\r\n}\r\n\r\n// File: contracts/RTokenStorage.sol\r\n\r\npragma solidity ^0.5.8;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ncontract RTokenStorage is RTokenStructs, IERC20 {\r\n    /* WARNING: NEVER RE-ORDER VARIABLES! Always double-check that new variables are added APPEND-ONLY. Re-ordering variables can permanently BREAK the deployed proxy contract.*/\r\n    address public _owner;\r\n    bool public initialized;\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 public _guardCounter;\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint256 public decimals;\r\n    /**\r\n     * @notice Total number of tokens in circulation\r\n     */\r\n    uint256 public totalSupply;\r\n    /// @dev Current saving strategy\r\n    IAllocationStrategy public ias;\r\n    /// @dev Underlying token\r\n    IERC20 public token;\r\n    /// @dev Saving assets original amount\r\n    /// This amount is in the same unit used in allocation strategy\r\n    uint256 public savingAssetOrignalAmount;\r\n    /// @dev Saving asset original to internal amount conversion rate.\r\n    ///      - It has 18 decimals\r\n    ///      - It starts with value 1.\r\n    ///      - Each strategy switching results a new conversion rate\r\n    ///\r\n    /// NOTE:\r\n    /// The reason there is an exchange rate is that, each time the allocation\r\n    /// strategy is switched, the unit of the original amount gets changed, it\r\n    /// is impossible to change all the internal savings accounting entries for\r\n    /// all accounts, hence instead a conversaion rate is used to simplify\r\n    /// the process.\r\n    uint256 public savingAssetConversionRate;\r\n    /// @dev Approved token transfer amounts on behalf of others\r\n    mapping(address => mapping(address => uint256)) public transferAllowances;\r\n    /// @dev Hat list\r\n    Hat[] internal hats;\r\n    /// @dev Account mapping\r\n    mapping(address => Account) public accounts;\r\n    /// @dev AccountStats mapping\r\n    mapping(address => AccountStats) public accountStats;\r\n    /// @dev HatStats mapping\r\n    mapping(uint256 => HatStatsStored) public hatStats;\r\n}\r\n\r\n// File: contracts/Proxiable.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\ncontract Proxiable {\r\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\r\n\r\n    function updateCodeAddress(address newAddress) internal {\r\n        require(\r\n            bytes32(\r\n                    0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\r\n                ) ==\r\n                Proxiable(newAddress).proxiableUUID(),\r\n            'Not compatible'\r\n        );\r\n        assembly {\r\n            // solium-disable-line\r\n            sstore(\r\n                0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7,\r\n                newAddress\r\n            )\r\n        }\r\n    }\r\n    function proxiableUUID() public pure returns (bytes32) {\r\n        return\r\n            0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n    }\r\n}\r\n\r\n// File: contracts/LibraryLock.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract LibraryLock is RTokenStorage {\r\n    // Ensures no one can manipulate the Logic Contract once it is deployed.\r\n    // PARITY WALLET HACK PREVENTION\r\n\r\n    modifier delegatedOnly() {\r\n        require(\r\n            initialized == true,\r\n            \"The library is locked. No direct 'call' is allowed.\"\r\n        );\r\n        _;\r\n    }\r\n    function initialize() internal {\r\n        initialized = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract Ownable is RTokenStorage {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            'Ownable: new owner is the zero address'\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract ReentrancyGuard is RTokenStorage {\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(\r\n            localCounter == _guardCounter,\r\n            'ReentrancyGuard: reentrant call'\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/RToken.sol\r\n\r\npragma solidity ^0.5.8;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice RToken an ERC20 token that is 1:1 redeemable to its underlying ERC20 token.\r\n */\r\ncontract RToken is\r\n    RTokenStructs,\r\n    RTokenStorage,\r\n    IRToken,\r\n    Ownable,\r\n    Proxiable,\r\n    LibraryLock,\r\n    ReentrancyGuard\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SELF_HAT_ID = uint256(int256(-1));\r\n    uint32 public constant PROPORTION_BASE = 0xFFFFFFFF;\r\n    uint256 public constant MAX_NUM_HAT_RECIPIENTS = 50;\r\n\r\n    /**\r\n     * @notice Create rToken linked with cToken at `cToken_`\r\n     */\r\n    function initialize(\r\n        IAllocationStrategy allocationStrategy,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        uint256 decimals_) external {\r\n        require(!initialized, 'The library has already been initialized.');\r\n        initialize();\r\n        _owner = msg.sender;\r\n        _guardCounter = 1;\r\n        name = name_; \r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n        savingAssetConversionRate = 10**18;\r\n        ias = allocationStrategy;\r\n        token = IERC20(ias.underlying());\r\n\r\n        // special hat aka. zero hat : hatID = 0\r\n        hats.push(Hat(new address[](0), new uint32[](0)));\r\n\r\n        // everyone is using it by default!\r\n        hatStats[0].useCount = uint256(int256(-1));\r\n    }\r\n\r\n    //\r\n    // ERC20 Interface\r\n    //\r\n\r\n    /**\r\n     * @notice Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accounts[owner].rAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `amount` tokens from the caller's account to `dst`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     * May also emit `InterestPaid` event.\r\n     */\r\n    function transfer(address dst, uint256 amount)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        return transferInternal(msg.sender, msg.sender, dst, amount);\r\n    }\r\n\r\n    /// @dev IRToken.transferAll implementation\r\n    function transferAll(address dst) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        return transferInternal(src, src, dst, accounts[src].rAmount);\r\n    }\r\n\r\n    /// @dev IRToken.transferAllFrom implementation\r\n    function transferAllFrom(address src, address dst)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        payInterestInternal(src);\r\n        payInterestInternal(dst);\r\n        return transferInternal(msg.sender, src, dst, accounts[src].rAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        return transferInternal(msg.sender, src, dst, amount);\r\n    }\r\n\r\n    //\r\n    // rToken interface\r\n    //\r\n\r\n    /// @dev IRToken.mint implementation\r\n    function mint(uint256 mintAmount) external nonReentrant returns (bool) {\r\n        mintInternal(mintAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.mintWithSelectedHat implementation\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        require(hatID == SELF_HAT_ID || hatID < hats.length, 'Invalid hat ID');\r\n        changeHatInternal(msg.sender, hatID);\r\n        mintInternal(mintAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.mintWithNewHat implementation\r\n     */\r\n    function mintWithNewHat(\r\n        uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions\r\n    ) external nonReentrant returns (bool) {\r\n        uint256 hatID = createHatInternal(recipients, proportions);\r\n        changeHatInternal(msg.sender, hatID);\r\n\r\n        mintInternal(mintAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.redeem implementation\r\n     *      It withdraws equal amount of initially supplied underlying assets\r\n     */\r\n    function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(src, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAll implementation\r\n    function redeemAll() external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(src, accounts[src].rAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAndTransfer implementation\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(redeemTo, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAndTransferAll implementation\r\n    function redeemAndTransferAll(address redeemTo)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(redeemTo, accounts[src].rAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.createHat implementation\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat\r\n    ) external nonReentrant returns (uint256 hatID) {\r\n        hatID = createHatInternal(recipients, proportions);\r\n        if (doChangeHat) {\r\n            changeHatInternal(msg.sender, hatID);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.changeHat implementation\r\n    function changeHat(uint256 hatID) external nonReentrant returns (bool) {\r\n        changeHatInternal(msg.sender, hatID);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.getMaximumHatID implementation\r\n    function getMaximumHatID() external view returns (uint256 hatID) {\r\n        return hats.length - 1;\r\n    }\r\n\r\n    /// @dev IRToken.getHatByAddress implementation\r\n    function getHatByAddress(address owner)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 hatID,\r\n            address[] memory recipients,\r\n            uint32[] memory proportions\r\n        )\r\n    {\r\n        hatID = accounts[owner].hatID;\r\n        if (hatID != 0 && hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.getHatByID implementation\r\n    function getHatByID(uint256 hatID)\r\n        external\r\n        view\r\n        returns (address[] memory recipients, uint32[] memory proportions)\r\n    {\r\n        if (hatID != 0 && hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.receivedSavingsOf implementation\r\n    function receivedSavingsOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        uint256 rGross = account\r\n            .sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate); // the 1e18 decimals should be cancelled out\r\n        return rGross;\r\n    }\r\n\r\n    /// @dev IRToken.receivedLoanOf implementation\r\n    function receivedLoanOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        return account.lDebt;\r\n    }\r\n\r\n    /// @dev IRToken.interestPayableOf implementation\r\n    function interestPayableOf(address owner)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Account storage account = accounts[owner];\r\n        return getInterestPayableOf(account);\r\n    }\r\n\r\n    /// @dev IRToken.payInterest implementation\r\n    function payInterest(address owner) external nonReentrant returns (bool) {\r\n        payInterestInternal(owner);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation!1\r\n    function getGlobalStats() external view returns (GlobalStats memory) {\r\n        uint256 totalSavingsAmount;\r\n        totalSavingsAmount += savingAssetOrignalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(10**18);\r\n        return\r\n            GlobalStats({\r\n                totalSupply: totalSupply,\r\n                totalSavingsAmount: totalSavingsAmount\r\n            });\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation\r\n    function getAccountStats(address owner)\r\n        external\r\n        view\r\n        returns (AccountStats memory)\r\n    {\r\n        AccountStats storage stats = accountStats[owner];\r\n        return stats;\r\n    }\r\n\r\n    /// @dev IRToken.getHatStats implementation\r\n    function getHatStats(uint256 hatID)\r\n        external\r\n        view\r\n        returns (HatStats memory stats) {\r\n        HatStatsStored storage statsStored = hatStats[hatID];\r\n        stats.useCount = statsStored.useCount;\r\n        stats.totalLoans = statsStored.totalLoans;\r\n        stats.totalSavings = statsStored.totalInternalSavings\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate);\r\n        return stats;\r\n    }\r\n\r\n    /// @dev IRToken.getCurrentSavingStrategy implementation\r\n    function getCurrentSavingStrategy() external view returns (address) {\r\n        return address(ias);\r\n    }\r\n\r\n    /// @dev IRToken.getSavingAssetBalance implementation\r\n    function getSavingAssetBalance()\r\n        external\r\n        view\r\n        returns (uint256 rAmount, uint256 sAmount)\r\n    {\r\n        sAmount = savingAssetOrignalAmount;\r\n        rAmount = sAmount.mul(ias.exchangeRateStored()).div(10**18);\r\n    }\r\n\r\n    /// @dev IRToken.changeAllocationStrategy implementation\r\n    function changeAllocationStrategy(IAllocationStrategy allocationStrategy)\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        require(\r\n            allocationStrategy.underlying() == address(token),\r\n            'New strategy should have the same underlying asset'\r\n        );\r\n        IAllocationStrategy oldIas = ias;\r\n        ias = allocationStrategy;\r\n        // redeem everything from the old strategy\r\n        uint256 sOriginalBurned = oldIas.redeemUnderlying(totalSupply);\r\n        // invest everything into the new strategy\r\n        token.transferFrom(msg.sender, address(this), totalSupply);\r\n        token.approve(address(ias), totalSupply);\r\n        uint256 sOriginalCreated = ias.investUnderlying(totalSupply);\r\n        // calculate new saving asset conversion rate\r\n        // if new original saving asset is 2x in amount\r\n        // then the conversion of internal amount should be also 2x\r\n        savingAssetConversionRate = sOriginalCreated.mul(10**18).div(\r\n            sOriginalBurned\r\n        );\r\n    }\r\n\r\n    /// @dev IRToken.changeHatFor implementation\r\n    function changeHatFor(address contractAddress, uint256 hatID) external onlyOwner {\r\n        require(_isContract(contractAddress), \"Admin can only change hat for contract address\");\r\n        changeHatInternal(contractAddress, hatID);\r\n    }\r\n\r\n    /// @dev Update the rToken logic contract code\r\n    function updateCode(address newCode) external onlyOwner delegatedOnly {\r\n        updateCodeAddress(newCode);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `tokens` tokens from `src` to `dst` by `spender`\r\n            Called by both `transfer` and `transferFrom` internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferInternal(\r\n        address spender,\r\n        address src,\r\n        address dst,\r\n        uint256 tokens\r\n    ) internal returns (bool) {\r\n        require(src != dst, 'src should not equal dst');\r\n\r\n        // pay the interest before doing the transfer\r\n        payInterestInternal(src);\r\n\r\n        require(\r\n            accounts[src].rAmount >= tokens,\r\n            'Not enough balance to transfer'\r\n        );\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint256 startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint256(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n        require(\r\n            startingAllowance >= tokens,\r\n            'Not enough allowance for transfer'\r\n        );\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        uint256 allowanceNew = startingAllowance.sub(tokens);\r\n        uint256 srcTokensNew = accounts[src].rAmount.sub(tokens);\r\n        uint256 dstTokensNew = accounts[dst].rAmount.add(tokens);\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // check if src & dst have the same hat\r\n        bool sameHat = accounts[src].hatID == accounts[dst].hatID && accounts[src].hatID != 0;\r\n\r\n        // apply hat inheritance rule\r\n        if ((accounts[src].hatID != 0 &&\r\n            accounts[dst].hatID == 0 &&\r\n            accounts[src].hatID != SELF_HAT_ID)) {\r\n            changeHatInternal(dst, accounts[src].hatID);\r\n        }\r\n\r\n        accounts[src].rAmount = srcTokensNew;\r\n        accounts[dst].rAmount = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != uint256(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        // lRecipients adjustments\r\n        if (!sameHat) {\r\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(\r\n                src,\r\n                tokens\r\n            );\r\n            distributeLoans(dst, tokens, sInternalAmountCollected);\r\n        } else {\r\n            // apply same hat optimization\r\n            sameHatTransfer(src, dst, tokens);\r\n        }\r\n\r\n        // rInterest adjustment for src\r\n        //\r\n        // rInterest should be the portion that is from interest payment, by\r\n        // definition it should not be larger than rAmount.\r\n        // It could happen because of rounding errors.\r\n        if (accounts[src].rInterest > accounts[src].rAmount) {\r\n            accounts[src].rInterest = accounts[src].rAmount;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sender supplies assets into the market and receives rTokens in exchange\r\n     * @dev Invest into underlying assets immediately\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     */\r\n    function mintInternal(uint256 mintAmount) internal {\r\n        require(\r\n            token.allowance(msg.sender, address(this)) >= mintAmount,\r\n            'Not enough allowance'\r\n        );\r\n\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        // create saving assets\r\n        token.transferFrom(msg.sender, address(this), mintAmount);\r\n        token.approve(address(ias), mintAmount);\r\n        uint256 sOriginalCreated = ias.investUnderlying(mintAmount);\r\n\r\n        // update global and account r balances\r\n        totalSupply = totalSupply.add(mintAmount);\r\n        account.rAmount = account.rAmount.add(mintAmount);\r\n\r\n        // update global stats\r\n        savingAssetOrignalAmount += sOriginalCreated;\r\n\r\n        // distribute saving assets as loans to recipients\r\n        uint256 sInternalCreated = sOriginalCreated\r\n            .mul(savingAssetConversionRate)\r\n            .div(10**18);\r\n        distributeLoans(msg.sender, mintAmount, sInternalCreated);\r\n\r\n        emit Mint(msg.sender, mintAmount);\r\n        emit Transfer(address(this), msg.sender, mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @dev Withdraw equal amount of initially supplied underlying assets\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemAmount The number of rTokens to redeem into underlying\r\n     */\r\n    function redeemInternal(address redeemTo, uint256 redeemAmount) internal {\r\n        Account storage account = accounts[msg.sender];\r\n        require(redeemAmount > 0, 'Redeem amount cannot be zero');\r\n        require(\r\n            redeemAmount <= account.rAmount,\r\n            'Not enough balance to redeem'\r\n        );\r\n\r\n        uint256 sOriginalBurned = redeemAndRecollectLoans(\r\n            msg.sender,\r\n            redeemAmount\r\n        );\r\n\r\n        // update Account r balances and global statistics\r\n        account.rAmount = account.rAmount.sub(redeemAmount);\r\n        if (account.rInterest > account.rAmount) {\r\n            account.rInterest = account.rAmount;\r\n        }\r\n        totalSupply = totalSupply.sub(redeemAmount);\r\n\r\n        // update global stats\r\n        if (savingAssetOrignalAmount > sOriginalBurned) {\r\n            savingAssetOrignalAmount -= sOriginalBurned;\r\n        } else {\r\n            savingAssetOrignalAmount = 0;\r\n        }\r\n\r\n        // transfer the token back\r\n        token.transfer(redeemTo, redeemAmount);\r\n\r\n        emit Transfer(msg.sender, address(this), redeemAmount);\r\n        emit Redeem(msg.sender, redeemTo, redeemAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n*    * @param proportions Relative proportions of benefits received by the recipients\r\n     */\r\n    function createHatInternal(\r\n        address[] memory recipients,\r\n        uint32[] memory proportions\r\n    ) internal returns (uint256 hatID) {\r\n        uint256 i;\r\n\r\n        require(recipients.length > 0, 'Invalid hat: at least one recipient');\r\n        require(recipients.length <= MAX_NUM_HAT_RECIPIENTS, \"Invalild hat: maximum number of recipients reached\");\r\n        require(\r\n            recipients.length == proportions.length,\r\n            'Invalid hat: length not matching'\r\n        );\r\n\r\n        // normalize the proportions\r\n        uint256 totalProportions = 0;\r\n        for (i = 0; i < recipients.length; ++i) {\r\n            require(\r\n                proportions[i] > 0,\r\n                'Invalid hat: proportion should be larger than 0'\r\n            );\r\n            totalProportions += uint256(proportions[i]);\r\n        }\r\n        for (i = 0; i < proportions.length; ++i) {\r\n            proportions[i] = uint32(\r\n                (uint256(proportions[i]) * uint256(PROPORTION_BASE)) /\r\n                    totalProportions\r\n            );\r\n        }\r\n\r\n        hatID = hats.push(Hat(recipients, proportions)) - 1;\r\n        emit HatCreated(hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Change the hat for `owner`\r\n     * @param owner Account owner\r\n     * @param hatID The id of the Hat\r\n     */\r\n    function changeHatInternal(address owner, uint256 hatID) internal {\r\n        Account storage account = accounts[owner];\r\n        uint256 oldHatID = account.hatID;\r\n        HatStatsStored storage oldHatStats = hatStats[oldHatID];\r\n        HatStatsStored storage newHatStats = hatStats[hatID];\r\n        if (account.rAmount > 0) {\r\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(\r\n                owner,\r\n                account.rAmount\r\n            );\r\n            account.hatID = hatID;\r\n            distributeLoans(owner, account.rAmount, sInternalAmountCollected);\r\n        } else {\r\n            account.hatID = hatID;\r\n        }\r\n        oldHatStats.useCount -= 1;\r\n        newHatStats.useCount += 1;\r\n        emit HatChanged(owner, oldHatID, hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Get interest payable of the account\r\n     */\r\n    function getInterestPayableOf(Account storage account)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 rGross = account\r\n            .sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate); // the 1e18 decimals should be cancelled out\r\n        if (rGross > (account.lDebt + account.rInterest)) {\r\n            return rGross - account.lDebt - account.rInterest;\r\n        } else {\r\n            // no interest accumulated yet or even negative interest rate!?\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the incoming tokens to the recipients as loans.\r\n     *      The tokens are immediately invested into the saving strategy and\r\n     *      add to the sAmount of the recipient account.\r\n     *      Recipient also inherits the owner's hat if it does already have one.\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount being loaned to the recipients\r\n     * @param sInternalAmount Amount of saving assets (internal amount) being given to the recipients\r\n     */\r\n    function distributeLoans(\r\n        address owner,\r\n        uint256 rAmount,\r\n        uint256 sInternalAmount\r\n    ) internal {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\r\n            ? 0\r\n            : account.hatID];\r\n        uint256 i;\r\n        if (hat.recipients.length > 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            for (i = 0; i < hat.proportions.length; ++i) {\r\n                address recipientAddress = hat.recipients[i];\r\n                Account storage recipientAccount = accounts[recipientAddress];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                // calculate the loan amount of the recipient\r\n                uint256 lDebtRecipient = isLastRecipient\r\n                    ? rLeft\r\n                    : (rAmount * hat.proportions[i]) / PROPORTION_BASE;\r\n                // distribute the loan to the recipient\r\n                account.lRecipients[recipientAddress] = account.lRecipients[recipientAddress]\r\n                    .add(lDebtRecipient);\r\n                recipientAccount.lDebt = recipientAccount.lDebt\r\n                    .add(lDebtRecipient);\r\n                // remaining value adjustments\r\n                rLeft = gentleSub(rLeft, lDebtRecipient);\r\n\r\n                // calculate the savings holdings of the recipient\r\n                uint256 sInternalAmountRecipient = isLastRecipient\r\n                    ? sInternalLeft\r\n                    : (sInternalAmount * hat.proportions[i]) / PROPORTION_BASE;\r\n                recipientAccount.sInternalAmount = recipientAccount.sInternalAmount\r\n                    .add(sInternalAmountRecipient);\r\n                // remaining value adjustments\r\n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\r\n\r\n                _updateLoanStats(owner, recipientAddress, account.hatID, true, lDebtRecipient, sInternalAmountRecipient);\r\n            }\r\n        } else {\r\n            // Account uses the zero/self hat, give all interest to the owner\r\n            account.lDebt = account.lDebt.add(rAmount);\r\n            account.sInternalAmount = account.sInternalAmount\r\n                .add(sInternalAmount);\r\n\r\n            _updateLoanStats(owner, owner, account.hatID, true, rAmount, sInternalAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      without actually redeeming the saving assets\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by giving back estimated amount of saving assets\r\n     * @return Estimated amount of saving assets (internal) needs to recollected\r\n     */\r\n    function estimateAndRecollectLoans(address owner, uint256 rAmount)\r\n        internal\r\n        returns (uint256 sInternalAmount)\r\n    {\r\n        // accrue interest so estimate is up to date\r\n        ias.accrueInterest();\r\n        sInternalAmount = rAmount.mul(savingAssetConversionRate).div(\r\n            ias.exchangeRateStored()\r\n        ); // the 1e18 decimals should be cancelled out\r\n        recollectLoans(owner, rAmount, sInternalAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      by redeeming the saving assets in `rAmount`\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by redeeming equivalent value of the saving assets\r\n     * @return Amount of saving assets redeemed for rAmount of tokens.\r\n     */\r\n    function redeemAndRecollectLoans(address owner, uint256 rAmount)\r\n        internal\r\n        returns (uint256 sOriginalBurned)\r\n    {\r\n        sOriginalBurned = ias.redeemUnderlying(rAmount);\r\n        uint256 sInternalBurned = sOriginalBurned\r\n            .mul(savingAssetConversionRate)\r\n            .div(10**18);\r\n        recollectLoans(owner, rAmount, sInternalBurned);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loan from the recipients\r\n     * @param owner   Owner address\r\n     * @param rAmount rToken amount being written of from the recipients\r\n     * @param sInternalAmount Amount of sasving assets (internal amount) recollected from the recipients\r\n     */\r\n    function recollectLoans(\r\n        address owner,\r\n        uint256 rAmount,\r\n        uint256 sInternalAmount\r\n    ) internal {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID\r\n            ? 0\r\n            : account.hatID];\r\n        if (hat.recipients.length > 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            uint256 i;\r\n            for (i = 0; i < hat.proportions.length; ++i) {\r\n                address recipientAddress = hat.recipients[i];\r\n                Account storage recipientAccount = accounts[recipientAddress];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                // calulate loans to be collected from the recipient\r\n                uint256 lDebtRecipient = isLastRecipient\r\n                    ? rLeft\r\n                    : (rAmount * hat.proportions[i]) / PROPORTION_BASE;\r\n                recipientAccount.lDebt = gentleSub(\r\n                    recipientAccount.lDebt,\r\n                    lDebtRecipient);\r\n                account.lRecipients[recipientAddress] = gentleSub(\r\n                    account.lRecipients[recipientAddress],\r\n                    lDebtRecipient);\r\n                // loans leftover adjustments\r\n                rLeft = gentleSub(rLeft, lDebtRecipient);\r\n\r\n                // calculate savings to be collected from the recipient\r\n                uint256 sInternalAmountRecipient = isLastRecipient\r\n                    ? sInternalLeft\r\n                    : (sInternalAmount * hat.proportions[i]) / PROPORTION_BASE;\r\n                recipientAccount.sInternalAmount = gentleSub(\r\n                    recipientAccount.sInternalAmount,\r\n                    sInternalAmountRecipient);\r\n                // savings leftover adjustments\r\n                sInternalLeft = gentleSub(sInternalLeft, sInternalAmountRecipient);\r\n\r\n                _updateLoanStats(owner, recipientAddress, account.hatID, false, lDebtRecipient, sInternalAmountRecipient);\r\n            }\r\n        } else {\r\n            // Account uses the zero hat, recollect interests from the owner\r\n            account.lDebt = gentleSub(account.lDebt, rAmount);\r\n            account.sInternalAmount = gentleSub(account.sInternalAmount, sInternalAmount);\r\n\r\n            _updateLoanStats(owner, owner, account.hatID, false, rAmount, sInternalAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Optimized recollect and distribute loan for the same hat\r\n     * @param src Source address\r\n     * @param dst Destination address\r\n     * @param rAmount rToken amount being written of from the recipients\r\n     */\r\n    function sameHatTransfer(\r\n        address src,\r\n        address dst,\r\n        uint256 rAmount) internal {\r\n        // accrue interest so estimate is up to date\r\n        ias.accrueInterest();\r\n\r\n        Account storage srcAccount = accounts[src];\r\n        Account storage dstAccount = accounts[dst];\r\n\r\n        uint256 sInternalAmount = rAmount\r\n            .mul(savingAssetConversionRate)\r\n            .div(ias.exchangeRateStored()); // the 1e18 decimals should be cancelled out\r\n\r\n        srcAccount.lDebt = gentleSub(srcAccount.lDebt, rAmount);\r\n        srcAccount.sInternalAmount = gentleSub(srcAccount.sInternalAmount, sInternalAmount);\r\n\r\n        dstAccount.lDebt = dstAccount.lDebt.add(rAmount);\r\n        dstAccount.sInternalAmount = dstAccount.sInternalAmount.add(sInternalAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev pay interest to the owner\r\n     * @param owner Account owner address\r\n     */\r\n    function payInterestInternal(address owner) internal {\r\n        Account storage account = accounts[owner];\r\n        AccountStats storage stats = accountStats[owner];\r\n\r\n        ias.accrueInterest();\r\n        uint256 interestAmount = getInterestPayableOf(account);\r\n\r\n        if (interestAmount > 0) {\r\n            stats.cumulativeInterest = stats\r\n                .cumulativeInterest\r\n                .add(interestAmount);\r\n            account.rInterest = account.rInterest.add(interestAmount);\r\n            account.rAmount = account.rAmount.add(interestAmount);\r\n            totalSupply = totalSupply.add(interestAmount);\r\n            emit InterestPaid(owner, interestAmount);\r\n            emit Transfer(address(this), owner, interestAmount);\r\n        }\r\n    }\r\n\r\n    function _updateLoanStats(\r\n        address owner,\r\n        address recipient,\r\n        uint256 hatID,\r\n        bool isDistribution,\r\n        uint256 redeemableAmount,\r\n        uint256 internalSavingsAmount) private {\r\n        HatStatsStored storage hatStats = hatStats[hatID];\r\n\r\n        emit LoansTransferred(owner, recipient, hatID,\r\n            true,\r\n            redeemableAmount,\r\n            internalSavingsAmount\r\n                .mul(ias.exchangeRateStored())\r\n                .div(savingAssetConversionRate));\r\n\r\n        if (isDistribution) {\r\n            hatStats.totalLoans = hatStats.totalLoans.add(redeemableAmount);\r\n            hatStats.totalInternalSavings = hatStats.totalInternalSavings\r\n                .add(internalSavingsAmount);\r\n        } else {\r\n            hatStats.totalLoans = gentleSub(hatStats.totalLoans, redeemableAmount);\r\n            hatStats.totalInternalSavings = gentleSub(\r\n                hatStats.totalInternalSavings,\r\n                internalSavingsAmount);\r\n        }\r\n    }\r\n\r\n    function _isContract(address addr) private view returns (bool) {\r\n      uint size;\r\n      assembly { size := extcodesize(addr) }\r\n      return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Gently subtract b from a without revert\r\n     *\r\n     * Due to the use of integeral arithmatic, imprecision may cause a tiny\r\n     * amount to be off when substracting the otherwise precise proportions.\r\n     */\r\n    function gentleSub(uint256 a, uint256 b) private pure returns (uint256) {\r\n        if (a < b) return 0;\r\n        else return a - b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"}],\"name\":\"redeemAndTransferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getHatByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedLoanOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatByID\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPORTION_BASE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccountStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.AccountStats\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"mintWithSelectedHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaximumHatID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"updateCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHatFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"useCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavings\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.HatStats\",\"name\":\"stats\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ias\",\"outputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"},{\"internalType\":\"bool\",\"name\":\"doChangeHat\",\"type\":\"bool\"}],\"name\":\"createHat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sInternalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAllowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavingsAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RTokenStructs.GlobalStats\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savingAssetOrignalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"interestPayableOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"name\":\"mintWithNewHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_guardCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELF_HAT_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentSavingStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savingAssetConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"payInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemAndTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"name\":\"changeAllocationStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSavingAssetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NUM_HAT_RECIPIENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hatStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"useCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInternalSavings\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedSavingsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDistribution\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemableAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savingsAmount\",\"type\":\"uint256\"}],\"name\":\"LoansTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InterestPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"HatCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldHatID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newHatID\",\"type\":\"uint256\"}],\"name\":\"HatChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RToken","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://41b2db4a30bf3813803b8a88c863f7d45dcb8a1ed9f72f347f40544dfff8c47c"}]}