{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/// @title ERC-20 interface\r\n/// @dev Full ERC-20 interface is described at https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md.\r\ninterface ERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\n/// @title ERC-677 (excluding ERC-20) interface\r\n/// @dev Full ERC-677 interface is discussed at https://github.com/ethereum/EIPs/issues/677.\r\ninterface ERC677 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n\r\n    function transferAndCall(address to, uint256 value, bytes data) external returns (bool);\r\n}\r\n\r\n\r\n/// @title ERC-677 mint/burn/claim extension interface\r\n/// @dev Extension of ERC-677 interface for allowing using a token in Token Bridge.\r\ninterface ERC677Bridgeable {\r\n\r\n    event Mint(address indexed receiver, uint256 value);\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    function mint(address receiver, uint256 value) external returns (bool);\r\n    function burn(uint256 value) external;\r\n    function claimTokens(address token, address to) external;\r\n}\r\n\r\n\r\n/// @title SafeMath\r\n/// @dev Math operations with safety checks that throw on error.\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/// @title SafeOwnable\r\n/// @dev The SafeOwnable contract has an owner address, and provides basic authorization control\r\n/// functions, this simplifies the implementation of \"user permissions\".\r\ncontract SafeOwnable {\r\n\r\n    // EVENTS\r\n\r\n    event OwnershipProposed(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @dev The SafeOwnable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /// @dev Allows the current owner to propose control of the contract to a new owner.\r\n    /// @param newOwner The address to propose ownership to.\r\n    function proposeOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0) && newOwner != _owner);\r\n        _ownerCandidate = newOwner;\r\n        emit OwnershipProposed(_owner, _ownerCandidate);\r\n    }\r\n\r\n    /// @dev Allows the current owner candidate to accept proposed ownership and set actual owner of a contract.\r\n    function acceptOwnership() public onlyOwnerCandidate {\r\n        emit OwnershipTransferred(_owner, _ownerCandidate);\r\n        _owner = _ownerCandidate;\r\n        _ownerCandidate = address(0);\r\n    }\r\n\r\n    /// @dev Returns the address of the owner.\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /// @dev Returns the address of the owner candidate.\r\n    function ownerCandidate() public view returns (address) {\r\n        return _ownerCandidate;\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner candidate.\r\n    modifier onlyOwnerCandidate() {\r\n        require(msg.sender == _ownerCandidate);\r\n        _;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    address internal _owner;\r\n    address internal _ownerCandidate;\r\n}\r\n\r\n\r\n/// @title Standard ERC-20 token\r\n/// @dev Implementation of the basic ERC-20 token.\r\ncontract TokenERC20 is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    /// @dev Transfers tokens to a specified address.\r\n    /// @param to The address to transfer tokens to.\r\n    /// @param value The amount of tokens to be transferred.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers tokens from one address to another.\r\n    /// @param from The address to transfer tokens from.\r\n    /// @param to The address to transfer tokens to.\r\n    /// @param value The amount of tokens to be transferred.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _decreaseAllowance(from, msg.sender, value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Approves a specified address to spend a specified amount of tokens on behalf of msg.sender.\r\n    /// Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    /// and the new allowance by an unfortunate transaction ordering. One possible solution to mitigate this\r\n    /// rare condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    /// @param spender Address which will be allowed to spend the tokens.\r\n    /// @param value Amount of tokens to allow to be spent.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Increases the amount of tokens that an owner allowed to spent by the spender.\r\n    /// Method approve() should be called when _allowances[spender] == 0. To decrement allowance\r\n    /// is better to use this function to avoid 2 calls (and wait until the first transaction is mined).\r\n    /// @param spender The address which will spend the tokens.\r\n    /// @param value The amount of tokens to increase the allowance by.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function increaseAllowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _increaseAllowance(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Decreases the amount of tokens that an owner allowed to spent by the spender.\r\n    /// Method approve() should be called when _allowances[spender] == 0. To decrement allowance\r\n    /// is better to use this function to avoid 2 calls (and wait until the first transaction is mined).\r\n    /// @param spender The address which will spend the tokens.\r\n    /// @param value The amount of tokens to decrease the allowance by.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function decreaseAllowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _decreaseAllowance(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns total amount of tokens in existence.\r\n    /// @return A uint256 representing the amount of tokens in existence.\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev Gets the balance of a specified address.\r\n    /// @param owner The address to query the balance of.\r\n    /// @return A uint256 representing the amount of tokens owned by the specified address.\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to spend by the spender.\r\n    /// @param owner The address which owns the tokens.\r\n    /// @param spender The address which will spend the tokens.\r\n    /// @return A uint256 representing the amount of tokens still available to spend by the spender.\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    /// @dev Transfers tokens from one address to another address.\r\n    /// @param from The address to transfer from.\r\n    /// @param to The address to transfer to.\r\n    /// @param value The amount to be transferred.\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n        require(value <= _balances[from]);\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /// @dev Increases the amount of tokens that an owner allowed to spent by the spender.\r\n    /// Method approve() should be called when _allowances[spender] == 0. To decrement allowance\r\n    /// is better to use this function to avoid 2 calls (and wait until the first transaction is mined).\r\n    /// @param owner The address which owns the tokens.\r\n    /// @param spender The address which will spend the tokens.\r\n    /// @param value The amount of tokens to increase the allowance by.\r\n    function _increaseAllowance(address owner, address spender, uint256 value) internal {\r\n        require(value > 0);\r\n        _allowances[owner][spender] = _allowances[owner][spender].add(value);\r\n        emit Approval(owner, spender, _allowances[owner][spender]);\r\n    }\r\n\r\n    /// @dev Decreases the amount of tokens that an owner allowed to spent by the spender.\r\n    /// Method approve() should be called when _allowances[spender] == 0. To decrement allowance\r\n    /// is better to use this function to avoid 2 calls (and wait until the first transaction is mined).\r\n    /// @param owner The address which owns the tokens.\r\n    /// @param spender The address which will spend the tokens.\r\n    /// @param value The amount of tokens to decrease the allowance by.\r\n    function _decreaseAllowance(address owner, address spender, uint256 value) internal {\r\n        require(value > 0 && value <= _allowances[owner][spender]);\r\n        _allowances[owner][spender] = _allowances[owner][spender].sub(value);\r\n        emit Approval(owner, spender, _allowances[owner][spender]);\r\n    }\r\n\r\n    /// @dev Internal function that mints specified amount of tokens and assigns it to an address.\r\n    /// This encapsulates the modification of balances such that the proper events are emitted.\r\n    /// @param receiver The address that will receive the minted tokens.\r\n    /// @param value The amount of tokens that will be minted.\r\n    function _mint(address receiver, uint256 value) internal {\r\n        require(receiver != address(0));\r\n        require(value > 0);\r\n        _balances[receiver] = _balances[receiver].add(value);\r\n        _totalSupply = _totalSupply.add(value);\r\n        //_totalMinted = _totalMinted.add(value);\r\n        emit Transfer(address(0), receiver, value);\r\n    }\r\n\r\n    /// @dev Internal function that burns specified amount of tokens of a given address.\r\n    /// @param burner The address from which tokens will be burnt.\r\n    /// @param value The amount of tokens that will be burnt.\r\n    function _burn(address burner, uint256 value) internal {\r\n        require(burner != address(0));\r\n        require(value > 0 && value <= _balances[burner]);\r\n        _balances[burner] = _balances[burner].sub(value);\r\n        _totalSupply = _totalSupply.sub(value);\r\n        emit Transfer(burner, address(0), value);\r\n    }\r\n\r\n    /// @dev Internal function that burns specified amount of tokens of a given address,\r\n    /// deducting from the sender's allowance for said account. Uses the internal burn function.\r\n    /// @param burner The address from which tokens will be burnt.\r\n    /// @param value The amount of tokens that will be burnt.\r\n    function _burnFrom(address burner, uint256 value) internal {\r\n        _decreaseAllowance(burner, msg.sender, value);\r\n        _burn(burner, value);\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    uint256 internal _totalSupply;\r\n    mapping (address => uint256) internal _balances;\r\n    mapping (address => mapping(address => uint256)) internal _allowances;\r\n}\r\n\r\n\r\n/// @title Probe Token contract (PR).\r\ncontract ProbeToken is SafeOwnable, TokenERC20, ERC677, ERC677Bridgeable {\r\n\r\n    // EVENTS\r\n\r\n    event ControlByOwnerRevoked();\r\n    event MintableChanged(bool mintable);\r\n    event TransferableChanged(bool transferable);\r\n    event ContractFallbackCallFailed(address from, address to, uint256 value);\r\n    event BridgeContractChanged(address indexed previousBridgeContract, address indexed newBridgeContract);\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    function _destroy() public onlyOwner {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    constructor() public {\r\n        _totalSupply = PPR_INITIAL_SUPPLY;\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    /// @dev Transfers tokens to a specified address with additional data if the recipient is a contact.\r\n    /// @param to The address to transfer tokens to.\r\n    /// @param value The amount of tokens to be transferred.\r\n    /// @param data The extra data to be passed to the receiving contract.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function transferAndCall(address to, uint256 value, bytes data) external canTransfer returns (bool) {\r\n        require(to != address(this));\r\n        require(super.transfer(to, value));\r\n        emit Transfer(msg.sender, to, value, data);\r\n        if (isContract(to)) {\r\n            require(contractFallback(msg.sender, to, value, data));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers tokens to a specified address.\r\n    /// @param to The address to transfer tokens to.\r\n    /// @param value The amount of tokens to be transferred.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function transfer(address to, uint256 value) public canTransfer returns (bool) {\r\n        require(super.transfer(to, value));\r\n        if (isContract(to) && !contractFallback(msg.sender, to, value, new bytes(0))) {\r\n            if (to == _bridgeContract) {\r\n                revert();\r\n            }\r\n            emit ContractFallbackCallFailed(msg.sender, to, value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers tokens from one address to another.\r\n    /// @param from The address to transfer tokens from.\r\n    /// @param to The address to transfer tokens to.\r\n    /// @param value The amount of tokens to be transferred.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function transferFrom(address from, address to, uint256 value) public canTransfer returns (bool) {\r\n        require(super.transferFrom(from, to, value));\r\n        if (isContract(to) && !contractFallback(from, to, value, new bytes(0))) {\r\n            if (to == _bridgeContract) {\r\n                revert();\r\n            }\r\n            emit ContractFallbackCallFailed(from, to, value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers tokens to a specified addresses (optimized version for initial sending tokens).\r\n    /// @param recipients Addresses to transfer tokens to.\r\n    /// @param values Amounts of tokens to be transferred.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function airdrop(address[] recipients, uint256[] values) public canTransfer returns (bool) {\r\n        require(recipients.length == values.length);\r\n        uint256 senderBalance = _balances[msg.sender];\r\n        for (uint256 i = 0; i < values.length; i++) {\r\n            uint256 value = values[i];\r\n            address to = recipients[i];\r\n            require(senderBalance >= value);\r\n            if (msg.sender != recipients[i]) {\r\n                senderBalance = senderBalance - value;\r\n                _balances[to] += value;\r\n            }\r\n            emit Transfer(msg.sender, to, value);\r\n        }\r\n        _balances[msg.sender] = senderBalance;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Mints specified amount of tokens and assigns it to a specified address.\r\n    /// @param receiver The address that will receive the minted tokens.\r\n    /// @param value The amount of tokens that will be minted.\r\n    function mint(address receiver, uint256 value) public canMint returns (bool) {\r\n        _mint(receiver, value);\r\n        _totalMinted = _totalMinted.add(value);\r\n        emit Mint(receiver, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Burns specified amount of tokens of the sender.\r\n    /// @param value The amount of token to be burnt.\r\n    function burn(uint256 value) public canBurn {\r\n        _burn(msg.sender, value);\r\n        _totalBurnt = _totalBurnt.add(value);\r\n        emit Burn(msg.sender, value);\r\n    }\r\n\r\n    /// @dev Burns specified amount of tokens of the specified account.\r\n    /// @param burner The address from which tokens will be burnt.\r\n    /// @param value The amount of token to be burnt.\r\n    function burnByOwner(address burner, uint256 value) public canBurnByOwner {\r\n        _burn(burner, value);\r\n        _totalBurnt = _totalBurnt.add(value);\r\n        emit Burn(burner, value);\r\n    }\r\n\r\n    /// @dev Transfers funds stored on the token contract to specified recipient (required by token bridge).\r\n    function claimTokens(address token, address to) public onlyOwnerOrBridgeContract {\r\n        require(to != address(0));\r\n        if (token == address(0)) {\r\n            to.transfer(address(this).balance);\r\n        } else {\r\n            ERC20 erc20 = ERC20(token);\r\n            uint256 balance = erc20.balanceOf(address(this));\r\n            require(erc20.transfer(to, balance));\r\n        }\r\n    }\r\n\r\n    /// @dev Revokes control by owner so it is not possible to burn tokens from any account by contract owner.\r\n    function revokeControlByOwner() public onlyOwner {\r\n        require(_controllable);\r\n        _controllable = false;\r\n        emit ControlByOwnerRevoked();\r\n    }\r\n\r\n    /// @dev Changes ability to mint tokens by permissioned accounts.\r\n    function setMintable(bool mintable) public onlyOwner {\r\n        require(_mintable != mintable);\r\n        _mintable = mintable;\r\n        emit MintableChanged(_mintable);\r\n    }\r\n\r\n    /// @dev Changes ability to transfer tokens by token holders.\r\n    function setTransferable(bool transferable) public onlyOwner {\r\n        require(_transferable != transferable);\r\n        _transferable = transferable;\r\n        emit TransferableChanged(_transferable);\r\n    }\r\n\r\n    /// @dev Changes address of token bridge contract.\r\n    function setBridgeContract(address bridgeContract) public onlyOwner {\r\n        require(_controllable);\r\n        require(bridgeContract != address(0) && bridgeContract != _bridgeContract && isContract(bridgeContract));\r\n        emit BridgeContractChanged(_bridgeContract, bridgeContract);\r\n        _bridgeContract = bridgeContract;\r\n    }\r\n\r\n    /// @dev Turn off renounceOwnership() method from Ownable contract.\r\n    function renounceOwnership() public pure {\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns a boolean flag representing ability to burn tokens from any account by contract owner.\r\n    /// @return A boolean that indicates if tokens can be burnt from any account by contract owner.\r\n    function controllableByOwner() public view returns (bool) {\r\n        return _controllable;\r\n    }\r\n\r\n    /// @dev Returns a boolean flag representing token mint ability.\r\n    /// @return A boolean that indicates if tokens can be mintable by permissioned accounts.\r\n    function mintable() public view returns (bool) {\r\n        return _mintable;\r\n    }\r\n\r\n    /// @dev Returns a boolean flag representing token transfer ability.\r\n    /// @return A boolean that indicates if tokens can be transferred by token holders.\r\n    function transferable() public view returns (bool) {\r\n        return _transferable;\r\n    }\r\n\r\n    /// @dev Returns an address of token bridge contract.\r\n    /// @return An address of token bridge contract.\r\n    function bridgeContract() public view returns (address) {\r\n        return _bridgeContract;\r\n    }\r\n\r\n    /// @dev Returns total amount of minted tokens.\r\n    /// @return A uint256 representing the amount of tokens were mint during token lifetime.\r\n    function totalMinted() public view returns (uint256) {\r\n        return _totalMinted;\r\n    }\r\n\r\n    /// @dev Returns total amount of burnt tokens.\r\n    /// @return A uint256 representing the amount of tokens were burnt during token lifetime.\r\n    function totalBurnt() public view returns (uint256) {\r\n        return _totalBurnt;\r\n    }\r\n\r\n    /// @dev Returns version of token interfaces (required by token bridge).\r\n    function getTokenInterfacesVersion() public pure returns (uint64, uint64, uint64) {\r\n        uint64 major = 2;\r\n        uint64 minor = 0;\r\n        uint64 patch = 0;\r\n        return (major, minor, patch);\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n    /// @dev Calls method onTokenTransfer() on specified contract address `receiver`.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function contractFallback(address from, address receiver, uint256 value, bytes data) private returns (bool) {\r\n        return receiver.call(abi.encodeWithSignature(\"onTokenTransfer(address,uint256,bytes)\", from, value, data));\r\n    }\r\n\r\n    /// @dev Determines if specified address is contract address.\r\n    /// @return A boolean that indicates if specified address is contract address.\r\n    function isContract(address account) private view returns (bool) {\r\n        uint256 codeSize;\r\n        assembly { codeSize := extcodesize(account) }\r\n        return codeSize > 0;\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyOwnerOrBridgeContract() {\r\n        require(msg.sender == _owner || msg.sender == _bridgeContract);\r\n        _;\r\n    }\r\n\r\n    modifier canMint() {\r\n        require(_mintable);\r\n        require(msg.sender == _owner || msg.sender == _bridgeContract);\r\n        _;\r\n    }\r\n\r\n    modifier canBurn() {\r\n        require(msg.sender == _owner || msg.sender == _bridgeContract);\r\n        _;\r\n    }\r\n\r\n    modifier canBurnByOwner() {\r\n        require(msg.sender == _owner && _controllable);\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer() {\r\n        require(_transferable || msg.sender == _owner);\r\n        _;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Standard fields used to describe the token\r\n    string public constant name = \"Probe Token\";\r\n    string public constant symbol = \"PT\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // At the start of the token existence it is fully controllable by owner\r\n    bool private _controllable = true;\r\n\r\n    // At the start of the token existence it is mintable\r\n    bool private _mintable = true;\r\n\r\n    // At the start of the token existence it is not transferable\r\n    bool private _transferable = false;\r\n\r\n    // Address of token bridge contract\r\n    address private _bridgeContract;\r\n\r\n    // Total amount of tokens minted during token lifetime\r\n    uint256 private _totalMinted;\r\n    // Total amount of tokens burnt during token lifetime\r\n    uint256 private _totalBurnt;\r\n\r\n    // Amount of initially supplied tokens is constant and equals to 1,000,000,000 PPR\r\n    uint256 private constant PPR_INITIAL_SUPPLY = 10**27;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bridgeContract\",\"type\":\"address\"}],\"name\":\"setBridgeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"burner\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mintable\",\"type\":\"bool\"}],\"name\":\"setMintable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipients\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenInterfacesVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBurnt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transferable\",\"type\":\"bool\"}],\"name\":\"setTransferable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllableByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revokeControlByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ControlByOwnerRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mintable\",\"type\":\"bool\"}],\"name\":\"MintableChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transferable\",\"type\":\"bool\"}],\"name\":\"TransferableChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ContractFallbackCallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBridgeContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBridgeContract\",\"type\":\"address\"}],\"name\":\"BridgeContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ProbeToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://189437307a0e4dbfea7473c28ab4b5b6d8a3b8768b667bcfb2278478e962a321"}]}