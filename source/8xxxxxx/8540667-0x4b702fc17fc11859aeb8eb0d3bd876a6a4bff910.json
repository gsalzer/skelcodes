{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\ncontract IOwned {\r\n\tfunction owner() public pure returns (address) {}\r\n}\r\n\r\ncontract IERC20Token {\r\n\tfunction decimals() public pure returns (uint8) {}\r\n\tfunction totalSupply() public pure returns (uint256) {}\r\n}\r\n\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n}\r\n\r\ncontract IFormula {\r\n\tfunction calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);\r\n\tfunction calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);\r\n}\r\n\r\ncontract IConverter {\r\n\tfunction getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\r\n\tfunction convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n\tfunction conversionFee() public pure returns (uint32) {}\r\n\tfunction connectors(address _address) public pure returns (uint256, uint32, bool, bool, bool) { _address; }\r\n\tfunction getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n\tfunction claimTokens(address _from, uint256 _amount) public;\r\n}\r\n\r\ncontract IContractRegistry {\r\n\tfunction getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\ncontract IGasPriceLimit {\r\n\tfunction gasPrice() public view returns (uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\tfunction add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n\t\tuint256 z = _x + _y;\r\n\t\trequire(z >= _x);\r\n\t\treturn z;\r\n\t}\r\n\r\n\tfunction sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n\t\trequire(_x >= _y);\r\n\t\treturn _x - _y;\r\n\t}\r\n\r\n\tfunction mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n\t\t// gas optimization\r\n\t\tif (_x == 0)\r\n\t\t\treturn 0;\r\n\r\n\t\tuint256 z = _x * _y;\r\n\t\trequire(z / _x == _y);\r\n\t\treturn z;\r\n\t}\r\n\r\n\tfunction div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n\t\trequire(_y > 0);\r\n\t\tuint256 c = _x / _y;\r\n\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract BancorPrice {\r\n\tusing SafeMath for uint256;\r\n\r\n\tIContractRegistry private registry = IContractRegistry(0xD1997064F0fEF8748C1de9B5ba53468C548738B3);\r\n\r\n\tbytes32 private constant BANCOR_FORMULA = \"BancorFormula\";\r\n\tbytes32 private constant BANCOR_GAS_PRICE_LIMIT = \"BancorGasPriceLimit\";\r\n\r\n\tuint64 private constant MAX_CONVERSION_FEE = 1000000;\r\n\r\n\t// function getOutputAmountAndGas(IERC20Token[] calldata _path, uint256 _amount) internal view returns (uint256, uint256) {\r\n\t// \tuint256 amount = getOutputAmount(_path, _amount);\r\n\t// \tuint256 gasPrice = getGasPrice();\r\n\t// \treturn (amount, gasPrice);\r\n\t// }\r\n\r\n\t// function getInputAmountAndGas(IERC20Token[] calldata _path, uint256 _amount) internal view returns (uint256, uint256) {\r\n\t// \tuint256 amount = getInputAmount(_path, _amount);\r\n\t// \tuint256 gasPrice = getGasPrice();\r\n\t// \treturn (amount, gasPrice);\r\n\t// }\r\n\r\n\tfunction getOutputAmount(IERC20Token[] memory _path, uint256 _amount) internal view returns (uint256) {\r\n\t\tuint256 amount = _amount;\r\n\t\tuint256 supply;\r\n\t\tIERC20Token fromToken = _path[0];\r\n\t\tIFormula formula = IFormula(registry.getAddress(BANCOR_FORMULA));\r\n\t\tISmartToken prevSmartToken;\r\n\t\t// iterate over the conversion path\r\n\t\tfor (uint256 i = 1; i < _path.length; i += 2) {\r\n\t\t\tISmartToken smartToken = ISmartToken(address(_path[i]));\r\n\t\t\tIERC20Token toToken = _path[i + 1];\r\n\t\t\tIConverter converter = IConverter(smartToken.owner());\r\n\r\n\t\t\tif (toToken == smartToken) { // buy the smart token\r\n\t\t\t\t// check if the current smart token supply was changed in the previous iteration\r\n\t\t\t\tsupply = smartToken == prevSmartToken ? supply : smartToken.totalSupply();\r\n\r\n\t\t\t\t// validate input\r\n\t\t\t\trequire(getConnectorSaleEnabled(converter, fromToken));\r\n\r\n\t\t\t\t// calculate the amount & the conversion fee\r\n\t\t\t\tuint256 balance = converter.getConnectorBalance(fromToken);\r\n\t\t\t\tuint32 weight = getConnectorWeight(converter, fromToken);\r\n\t\t\t\tamount = formula.calculatePurchaseReturn(supply, balance, weight, amount);\r\n\t\t\t\tuint256 fee = amount * converter.conversionFee() / MAX_CONVERSION_FEE;\r\n\t\t\t\tamount -= fee;\r\n\r\n\t\t\t\t// update the smart token supply for the next iteration\r\n\t\t\t\tsupply = smartToken.totalSupply() + amount;\r\n\t\t\t}\r\n\t\t\telse if (fromToken == smartToken) { // sell the smart token\r\n\t\t\t\t// check if the current smart token supply was changed in the previous iteration\r\n\t\t\t\tsupply = smartToken == prevSmartToken ? supply : smartToken.totalSupply();\r\n\r\n\t\t\t\t// calculate the amount & the conversion fee\r\n\t\t\t\tuint256 balance = converter.getConnectorBalance(toToken);\r\n\t\t\t\tuint32 weight = getConnectorWeight(converter, toToken);\r\n\t\t\t\tamount = formula.calculateSaleReturn(supply, balance, weight, amount);\r\n\t\t\t\tuint256 fee = amount * converter.conversionFee() / MAX_CONVERSION_FEE;\r\n\t\t\t\tamount -= fee;\r\n\r\n\t\t\t\t// update the smart token supply for the next iteration\r\n\t\t\t\tsupply = smartToken.totalSupply() - amount;\r\n\t\t\t}\r\n\t\t\telse { // cross connector conversion\r\n\t\t\t\tamount = converter.getReturn(fromToken, toToken, amount);\r\n\t\t\t}\r\n\r\n\t\t\tprevSmartToken = smartToken;\r\n\t\t\tfromToken = toToken;\r\n\t\t}\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction getInputAmount(IERC20Token[] memory _path, uint256 _amount) internal view returns (uint256) {\r\n\t\tIERC20Token fromToken = _path[0];\r\n\t\tuint256 initialAmount = getMultiplier(fromToken);\r\n\t\tuint256 initialReturn = getOutputAmount(_path, initialAmount);\r\n\t\tuint256 initialCost = _amount * initialAmount / initialReturn;\r\n\t\tuint256 finalReturn = getOutputAmount(_path, initialCost);\r\n\t\treturn _amount * initialCost / finalReturn;\r\n\t}\r\n\r\n\tfunction getGasPrice() internal view returns (uint256) {\r\n\t\tIGasPriceLimit limit = IGasPriceLimit(registry.getAddress(BANCOR_GAS_PRICE_LIMIT));\r\n\t\tuint256 gasPrice = limit.gasPrice();\r\n\t\treturn gasPrice;\r\n\t}\r\n\r\n\tfunction getConnectorSaleEnabled(IConverter _converter, IERC20Token _connector) private pure returns (bool) {\r\n\t\tuint256 virtualBalance;\r\n\t\tuint32 weight;\r\n\t\tbool isVirtualBalanceEnabled;\r\n\t\tbool isSaleEnabled;\r\n\t\tbool isSet;\r\n\t\t(virtualBalance, weight, isVirtualBalanceEnabled, isSaleEnabled, isSet) = _converter.connectors(address(_connector));\r\n\t\treturn isSaleEnabled;\r\n\t}\r\n\r\n\tfunction getConnectorWeight(IConverter _converter, IERC20Token _connector) private pure returns (uint32) {\r\n\t\tuint256 virtualBalance;\r\n\t\tuint32 weight;\r\n\t\tbool isVirtualBalanceEnabled;\r\n\t\tbool isSaleEnabled;\r\n\t\tbool isSet;\r\n\t\t(virtualBalance, weight, isVirtualBalanceEnabled, isSaleEnabled, isSet) = _converter.connectors(address(_connector));\r\n\t\treturn weight;\r\n\t}\r\n\r\n\tfunction getMultiplier(IERC20Token _token) private pure returns(uint256) {\r\n\t\treturn 10 ** getDecimals(_token);\r\n\t}\r\n\t\r\n\tfunction getDecimals(IERC20Token _token) private pure returns(uint256) {\r\n\t\tif (address(_token) == 0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A) { // DGD\r\n\t\t\treturn 9;\r\n\t    }\r\n\t    if (address(_token) == 0xbdEB4b83251Fb146687fa19D1C660F99411eefe3) { // SVD\r\n\t    \treturn 18;\r\n\t    }\r\n\t    return _token.decimals();\r\n\t}\r\n}\r\n\r\ncontract BancorMultiPrice is BancorPrice {\r\n\tfunction getOutputAmountsAndGas(IERC20Token[] calldata _path, uint256 _amount) external view returns (uint256[100] memory _amounts, uint256 _gasPrice) {\r\n\t\tfor (uint256 i = 0; i < 100; i++) {\r\n\t\t\t_amounts[i] = getOutputAmount(_path, (i + 1) * _amount / 100);\r\n\t\t}\r\n\t\t_gasPrice = getGasPrice();\r\n\t}\r\n\r\n\tfunction getInputAmountsAndGas(IERC20Token[] calldata _path, uint256 _amount) external view returns (uint256[100] memory _amounts, uint256 _gasPrice) {\r\n\t\tfor (uint256 i = 0; i < 100; i++) {\r\n\t\t\t_amounts[i] = getInputAmount(_path, (i + 1) * _amount / 100);\r\n\t\t}\r\n\t\t_gasPrice = getGasPrice();\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20Token[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getInputAmountsAndGas\",\"outputs\":[{\"internalType\":\"uint256[100]\",\"name\":\"_amounts\",\"type\":\"uint256[100]\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20Token[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOutputAmountsAndGas\",\"outputs\":[{\"internalType\":\"uint256[100]\",\"name\":\"_amounts\",\"type\":\"uint256[100]\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BancorMultiPrice","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://b0350a6748dd037f48fc53e2830f8b8ab375ae774dbd20b5f4907a2f15cfab7d"}]}