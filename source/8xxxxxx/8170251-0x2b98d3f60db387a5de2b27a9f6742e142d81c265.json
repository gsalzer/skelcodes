{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.26;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n/**\r\n * @title ERC20\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint256 public totalSupply;\r\n\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @dev ERC20 Token Escrow legible as Bill of Sale with Arbitration logic.\r\n * @author R. Ross Campbell\r\n */\r\ncontract BillofSaleERC20 {\r\n    using SafeMath for uint256;\r\n    \r\n    string public descr;\r\n    uint256 public price;\r\n    address public tokenContract;\r\n    address public buyer;\r\n    address public seller;\r\n    address public arbiter;\r\n    uint256 public createdAt;\r\n    \r\n    uint256 private buyerAward;\r\n    uint256 private sellerAward;\r\n    uint256 private arbiterFee;\r\n    \r\n    enum State { Created, Confirmed, Disputed, Resolved }\r\n    State public state;\r\n    \r\n    event Confirmed(address indexed this, address indexed seller);\r\n    event Disputed();\r\n    event Resolved(address indexed this, address indexed buyer, address indexed seller);\r\n/**\r\n * @dev Sets the BOS transaction values for `descr`, `price`, 'tokenContract', `buyer`, `seller`, 'arbiter', 'arbiterFee'. All seven of\r\n * these values are immutable: they can only be set once during construction and reflect essential deal terms.\r\n */    \r\n   constructor(\r\n        string memory _descr,\r\n        uint256 _price,\r\n        address _tokenContract,\r\n        address _buyer,\r\n        address _seller,\r\n        address _arbiter,\r\n        uint256 _arbiterFee)\r\n        public {\r\n                descr = _descr;\r\n                price = _price;\r\n                tokenContract = _tokenContract;\r\n                buyer = _buyer;\r\n                seller = _seller;\r\n                arbiter = _arbiter;\r\n                arbiterFee = _arbiterFee;\r\n                createdAt = now;\r\n                require(price > arbiterFee, \"arbiter fee cannot exceed price\");\r\n               }\r\n                /**\r\n                 * @dev Throws if called by any account other than buyer.\r\n                 */\r\n                  modifier onlyBuyer() {\r\n                        require(msg.sender == buyer);\r\n                         _;\r\n                        }\r\n                /**\r\n                 * @dev Throws if called by any account other than buyer or seller.\r\n                 */\r\n                  modifier onlyBuyerOrSeller() {\r\n                        require(\r\n                        msg.sender == buyer ||\r\n                        msg.sender == seller);\r\n                         _;\r\n                        }\r\n                /**\r\n                 * @dev Throws if called by any account other than arbiter.\r\n                 */\r\n                  modifier onlyArbiter() {\r\n                        require(msg.sender == arbiter);\r\n                         _;\r\n                        }\r\n                /**\r\n                 * @dev Throws if contract called in State other than one associated for function.\r\n                 */\r\n                  modifier inState(State _state) {\r\n                        require(state == _state);\r\n                         _;\r\n                        }\r\n        /** \r\n         * @dev Buyer confirms receipt from seller;\r\n         * token 'price' is transferred to seller.\r\n         * (presuming buyer deposits to BOS escrow to motivate seller delivery)\r\n         */\r\n           function confirmReceipt() public onlyBuyer inState(State.Created) {\r\n                state = State.Confirmed;\r\n                ERC20 token = ERC20(tokenContract);\r\n                uint256 tokenBalance = token.balanceOf(this);\r\n                token.transfer(seller, tokenBalance);\r\n                emit Confirmed(address(this), seller);\r\n                }\r\n        /**\r\n         * @dev Buyer or seller can initiate dispute related to BOS transaction,\r\n         * placing 'price' transfer and split of value into arbiter control.\r\n         * For example, buyer might refuse or unduly delay to confirm receipt after seller delivery, \r\n         * or, on other hand,\r\n         * despite buyer's disatisfaction with seller delivery, \r\n         * seller might demand buyer confirm receipt and release 'price'.\r\n         */\r\n           function initiateDispute() public onlyBuyerOrSeller inState(State.Created) {\r\n                state = State.Disputed;\r\n                emit Disputed();\r\n                }\r\n        /**\r\n         * @dev Arbiter can resolve dispute and claim token reward by entering in split of 'price' value,\r\n         * minus 'arbiter fee' set at construction.\r\n         */\r\n           function resolveDispute(uint256 _buyerAward, uint256 _sellerAward) public onlyArbiter inState(State.Disputed) {\r\n                state = State.Resolved;\r\n                ERC20 token = ERC20(tokenContract);\r\n                buyerAward = _buyerAward;\r\n                sellerAward = _sellerAward;\r\n                token.transfer(buyer, buyerAward);\r\n                token.transfer(seller, sellerAward);\r\n                token.transfer(arbiter, arbiterFee);\r\n                emit Resolved(address(this), buyer, seller);\r\n                }\r\n}\r\n\r\ncontract BillofSaleERC20Factory {\r\n\r\n  // index of created contracts\r\n\r\n  mapping (address => bool) public validContracts; \r\n  address[] public contracts;\r\n\r\n  // useful to know the row count in contracts index\r\n\r\n  function getContractCount() \r\n    public\r\n    view\r\n    returns(uint contractCount)\r\n  {\r\n    return contracts.length;\r\n  }\r\n\r\n  // get all contracts\r\n\r\n  function getDeployedContracts() public view returns (address[] memory)\r\n  {\r\n    return contracts;\r\n  }\r\n\r\n  // deploy a new contract\r\n\r\n  function newBillofSaleERC20(\r\n      string memory _descr, \r\n      uint256 _price,\r\n      address _tokenContract,\r\n      address _buyer,\r\n      address _seller, \r\n      address _arbiter,\r\n      uint256 _arbiterFee)\r\n          public\r\n          returns(address)\r\n   {\r\n    BillofSaleERC20 c = new BillofSaleERC20(\r\n        _descr, \r\n        _price,\r\n        _tokenContract,\r\n        _buyer, \r\n        _seller,\r\n        _arbiter,\r\n        _arbiterFee);\r\n            validContracts[c] = true;\r\n            contracts.push(c);\r\n            return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_descr\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_arbiterFee\",\"type\":\"uint256\"}],\"name\":\"newBillofSaleERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"validContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractCount\",\"outputs\":[{\"name\":\"contractCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeployedContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BillofSaleERC20Factory","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2a8120a07c3f454cdc67417598dccb809d285552b22b983a35e9ec553420940b"}]}