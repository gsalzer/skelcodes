{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\ncontract MarginSwap {\r\n  uint256 _code;\r\n  uint256 _owner;\r\n  uint256 _parent_address;\r\n  uint256 _run_state;\r\n  uint256 _comptroller_address;\r\n  uint256[2**160] _compound_lookup;\r\n  event Trade(\r\n    address indexed trade_contract,\r\n    address from_asset,\r\n    address to_asset,\r\n    uint256 input,\r\n    uint256 output,\r\n    uint256 input_fee\r\n  );\r\n  \r\n  function () external payable  {}\r\n  \r\n  function setComptrollerAddress(address comptroller) external  {\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(_comptroller_address_slot, comptroller)\r\n    }\r\n  }\r\n  \r\n  function comptrollerAddress() public view \r\n  returns (address comptroller) {\r\n    assembly {\r\n      comptroller := sload(_comptroller_address_slot)\r\n      if iszero(comptroller) {\r\n        comptroller := 0x3d9819210a31b4961b30ef54be2aed79b9c9cd3b\r\n      }\r\n    }\r\n  }\r\n  \r\n  function lookupUnderlying(address cToken) public view \r\n  returns (address result) {\r\n    assembly {\r\n      result := sload(add(_compound_lookup_slot, cToken))\r\n    }\r\n  }\r\n  \r\n  function enterMarkets(address[] calldata cTokens) external  {\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 0)\r\n        revert(63, 1)\r\n      }\r\n      if xor(0x20, calldataload(4)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let array_length := calldataload(0x24)\r\n      let array_start := 0x44\r\n      if xor(add(0x44, mul(0x20, array_length)), calldatasize) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        let call_input := mload(0x40)\r\n        let call_input_size := calldatasize\r\n        calldatacopy(call_input, 0, call_input_size)\r\n        let comptroller_address := sload(_comptroller_address_slot)\r\n        if iszero(comptroller_address) {\r\n          comptroller_address := 0x3d9819210a31b4961b30ef54be2aed79b9c9cd3b\r\n        }\r\n        let res := call(gas, comptroller_address, 0, call_input, call_input_size, call_input, sub(call_input_size, 4))\r\n        if iszero(res) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n        if xor(0x20, mload(call_input)) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        if xor(array_length, mload(add(call_input, 0x20))) {\r\n          mstore(32, 5)\r\n          revert(63, 1)\r\n        }\r\n        let has_error := 0\r\n        for {\r\n          let i := 0\r\n        } lt(i, array_length) {\r\n          i := add(i, 1)\r\n        } {\r\n          let value := mload(add(add(call_input, 0x40), mul(i, 0x20)))\r\n          has_error := or(has_error, value)\r\n        }\r\n        if has_error {\r\n          mstore(32, 6)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let array_end := add(array_start, mul(array_length, 0x20))\r\n      for {\r\n        let i := array_start\r\n      } lt(i, array_end) {\r\n        i := add(i, 0x20)\r\n      } {\r\n        let cToken_addr := calldataload(i)\r\n        let mem_ptr := mload(0x40)\r\n        let m_out := add(mem_ptr, 4)\r\n        {\r\n          mstore(m_out, 0)\r\n          if xor(cToken_addr, 0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5) {\r\n            mstore(mem_ptr, /* fn_hash(\"underlying()\") */ 0x6f307dc300000000000000000000000000000000000000000000000000000000)\r\n            let res := staticcall(gas, cToken_addr, mem_ptr, 4, m_out, 32)\r\n            if iszero(res) {\r\n              mstore(32, 7)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n        }\r\n        let underlying_addr := mload(m_out)\r\n        sstore(add(_compound_lookup_slot, underlying_addr), cToken_addr)\r\n        if underlying_addr {\r\n          mstore(mem_ptr, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(mem_ptr, 4), cToken_addr)\r\n          mstore(add(mem_ptr, 0x24), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n          let mem_out := add(mem_ptr, 0x44)\r\n          mstore(mem_out, 0)\r\n          let res := call(gas, underlying_addr, 0, mem_ptr, 0x44, mem_out, 0x20)\r\n          if or(iszero(res), iszero(mload(mem_out))) {\r\n            mstore(32, 8)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function depositEth() external payable  {\r\n    deposit(address(0x0), msg.value);\r\n  }\r\n  \r\n  function deposit(address asset_address, uint256 amount) public payable  {\r\n    \r\n    uint256[4] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      if and(iszero(asset_address), iszero(eq(amount, callvalue))) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      if asset_address {\r\n        if callvalue {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n        mstore(m_in, /* fn_hash(\"transferFrom(address,address,uint256)\") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), caller)\r\n        mstore(add(m_in, 0x24), address)\r\n        mstore(add(m_in, 0x44), amount)\r\n        mstore(m_out, 0)\r\n        let res := call(gas, asset_address, 0, m_in, 0x64, m_out, 0x20)\r\n        if or(iszero(res), iszero(mload(m_out))) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n    }\r\n    depositToCompound(asset_address, amount);\r\n  }\r\n  \r\n  function depositToCompound(address asset_address, uint256 amount) internal  {\r\n    \r\n    uint256[2] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      let c_address := sload(add(_compound_lookup_slot, asset_address))\r\n      if iszero(c_address) {\r\n        mstore(32, 100)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        mstore(m_in, /* fn_hash(\"borrowBalanceCurrent(address)\") */ 0x17bfdfbc00000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), address)\r\n        let res := call(gas, c_address, 0, m_in, 36, m_out, 32)\r\n        if iszero(res) {\r\n          mstore(32, 101)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let borrow_amount := mload(m_out)\r\n        let to_repay := borrow_amount\r\n        if lt(amount, to_repay) {\r\n          to_repay := amount\r\n        }\r\n        if to_repay {\r\n          mstore(m_in, /* fn_hash(\"repayBorrow()\") */ 0x4e4d9fea00000000000000000000000000000000000000000000000000000000)\r\n          let m_in_size := 4\r\n          let wei_to_send := to_repay\r\n          if asset_address {\r\n            mstore(m_in, /* fn_hash(\"repayBorrow(uint256)\") */ 0x0e75270200000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(m_in, 4), to_repay)\r\n            m_in_size := 36\r\n            wei_to_send := 0\r\n          }\r\n          let res := call(gas, c_address, wei_to_send, m_in, m_in_size, m_out, 32)\r\n          if iszero(res) {\r\n            mstore(32, 102)\r\n            revert(63, 1)\r\n          }\r\n          switch returndatasize\r\n            case 0 {\r\n              if asset_address {\r\n                mstore(32, 103)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            case 32 {\r\n              if mload(m_out) {\r\n                mstore(32, 104)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            default {\r\n              mstore(32, 105)\r\n              revert(63, 1)\r\n            }\r\n          amount := sub(amount, to_repay)\r\n        }\r\n      }\r\n      {\r\n        if amount {\r\n          mstore(m_in, /* fn_hash(\"mint()\") */ 0x1249c58b00000000000000000000000000000000000000000000000000000000)\r\n          let m_in_size := 4\r\n          let wei_to_send := amount\r\n          if asset_address {\r\n            mstore(m_in, /* fn_hash(\"mint(uint256)\") */ 0xa0712d6800000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(m_in, 4), amount)\r\n            m_in_size := 0x24\r\n            wei_to_send := 0\r\n          }\r\n          let res := call(gas, c_address, wei_to_send, m_in, m_in_size, m_out, 32)\r\n          if iszero(res) {\r\n            mstore(32, 106)\r\n            revert(63, 1)\r\n          }\r\n          switch returndatasize\r\n            case 0 {\r\n              if asset_address {\r\n                mstore(32, 107)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            case 32 {\r\n              if mload(m_out) {\r\n                mstore(32, 108)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            default {\r\n              mstore(32, 109)\r\n              revert(63, 1)\r\n            }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function withdraw(address asset, uint256 amount, address destination) external  {\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n    }\r\n    _withdraw(asset, amount, destination);\r\n  }\r\n  \r\n  function _withdraw(address asset, uint256 amount, address destination) internal  {\r\n    \r\n    uint256[2] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      let c_address := sload(add(_compound_lookup_slot, asset))\r\n      if iszero(c_address) {\r\n        mstore(32, 200)\r\n        revert(63, 1)\r\n      }\r\n      let remaining := amount\r\n      {\r\n        mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 0x04), address)\r\n        let res := call(gas, c_address, 0, m_in, 0x24, m_out, 0x20)\r\n        if iszero(res) {\r\n          mstore(32, 201)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let c_balance := mload(m_out)\r\n        if c_balance {\r\n          {\r\n            mstore(m_in, /* fn_hash(\"exchangeRateCurrent()\") */ 0xbd6d894d00000000000000000000000000000000000000000000000000000000)\r\n            let res := call(gas, c_address, 0, m_in, 0x04, m_out, 0x20)\r\n            if iszero(res) {\r\n              mstore(32, 202)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          let rate := mload(m_out)\r\n          if iszero(rate) {\r\n            mstore(32, 203)\r\n            revert(63, 1)\r\n          }\r\n          let c_redeem := div(add(sub(rate, 1), mul(remaining, 1000000000000000000)), rate)\r\n          if gt(c_redeem, c_balance) {\r\n            c_redeem := c_balance\r\n          }\r\n          if c_redeem {\r\n            mstore(m_in, /* fn_hash(\"redeem(uint256)\") */ 0xdb006a7500000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(m_in, 4), c_redeem)\r\n            let res := call(gas, c_address, 0, m_in, 0x24, m_out, 0x20)\r\n            if iszero(res) {\r\n              mstore(32, 204)\r\n              revert(63, 1)\r\n            }\r\n            if mload(m_out) {\r\n              mstore(32, 205)\r\n              revert(63, 1)\r\n            }\r\n            let t_redeem := div(mul(c_redeem, rate), 1000000000000000000)\r\n            remaining := sub(remaining, t_redeem)\r\n          }\r\n        }\r\n      }\r\n      {\r\n        if remaining {\r\n          mstore(m_in, /* fn_hash(\"borrow(uint256)\") */ 0xc5ebeaec00000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), remaining)\r\n          let res := call(gas, c_address, 0, m_in, 0x24, m_out, 0x20)\r\n          if or(iszero(res), mload(m_out)) {\r\n            mstore(32, 204)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n      {\r\n        let m_in_size := 0\r\n        let wei_to_send := amount\r\n        let dest := destination\r\n        if asset {\r\n          mstore(m_in, /* fn_hash(\"transfer(address,uint256)\") */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), destination)\r\n          mstore(add(m_in, 0x24), amount)\r\n          dest := asset\r\n          m_in_size := 0x44\r\n          wei_to_send := 0\r\n        }\r\n        let res := call(gas, dest, wei_to_send, m_in, m_in_size, m_out, 32)\r\n        if iszero(res) {\r\n          mstore(32, 205)\r\n          revert(63, 1)\r\n        }\r\n        if asset {\r\n          if iszero(mload(m_out)) {\r\n            mstore(32, 206)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function transferOut(address asset, uint256 amount, address destination) external  {\r\n    \r\n    uint256[3] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let m_in_size := 0\r\n      let wei_to_send := amount\r\n      let dest := destination\r\n      if asset {\r\n        mstore(m_in, /* fn_hash(\"transfer(address,uint256)\") */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 4), destination)\r\n        mstore(add(m_in, 0x24), amount)\r\n        dest := asset\r\n        m_in_size := 0x44\r\n        wei_to_send := 0\r\n      }\r\n      let res := call(gas, dest, wei_to_send, m_in, m_in_size, m_out, 32)\r\n      if iszero(res) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      if asset {\r\n        if iszero(mload(m_out)) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function trade(address input_asset,\r\n                 uint256 input_amount,\r\n                 address output_asset,\r\n                 uint256 min_output_amount,\r\n                 address trade_contract,\r\n                 bytes memory trade_data) public  {\r\n    \r\n    uint256[3] memory m_in;\r\n    \r\n    uint256[1] memory m_out;\r\n    uint256 output_amount;\r\n    assembly {\r\n      if xor(caller, sload(_owner_slot)) {\r\n        mstore(32, 0)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        if xor(sload(_run_state_slot), 1) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n        sstore(_run_state_slot, 2)\r\n      }\r\n      let capital_source := sload(_parent_address_slot)\r\n      {\r\n        mstore(m_in, /* fn_hash(\"getCapital(address,uint256)\") */ 0x0a681c5900000000000000000000000000000000000000000000000000000000)\r\n        mstore(add(m_in, 0x04), input_asset)\r\n        mstore(add(m_in, 0x24), input_amount)\r\n        let res := call(gas, capital_source, 0, m_in, 0x44, 0, 0)\r\n        if iszero(res) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if input_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), trade_contract)\r\n          mstore(add(m_in, 0x24), input_amount)\r\n          mstore(m_out, 0)\r\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\r\n          if or(iszero(res), iszero(mload(m_out))) {\r\n            mstore(32, 4)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n      let before_balance := balance(address)\r\n      if output_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), address)\r\n          mstore(m_out, 0)\r\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\r\n          if iszero(res) {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n        before_balance := mload(m_out)\r\n      }\r\n      {\r\n        if iszero(extcodesize(trade_contract)) {\r\n          mstore(32, 5)\r\n          revert(63, 1)\r\n        }\r\n        let wei_to_send := input_amount\r\n        if input_asset {\r\n          wei_to_send := 0\r\n        }\r\n        let res := call(gas, trade_contract, wei_to_send, add(trade_data, 0x20), mload(trade_data), 0, 0)\r\n        if iszero(res) {\r\n          mstore(32, 7)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if input_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), trade_contract)\r\n          mstore(add(m_in, 0x24), 0)\r\n          mstore(m_out, 0)\r\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\r\n          if or(iszero(res), iszero(mload(m_out))) {\r\n            mstore(32, 8)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n      }\r\n      let after_balance := balance(address)\r\n      if output_asset {\r\n        {\r\n          mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(m_in, 4), address)\r\n          mstore(m_out, 0)\r\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\r\n          if iszero(res) {\r\n            mstore(32, 9)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n        after_balance := mload(m_out)\r\n      }\r\n      if lt(after_balance, before_balance) {\r\n        mstore(32, 10)\r\n        revert(63, 1)\r\n      }\r\n      output_amount := sub(after_balance, before_balance)\r\n      if lt(output_amount, min_output_amount) {\r\n        mstore(32, 11)\r\n        revert(63, 1)\r\n      }\r\n    }\r\n    depositToCompound(output_asset, output_amount);\r\n    uint256 fee;\r\n    uint256 return_amount;\r\n    assembly {\r\n      fee := div(input_amount, 200)\r\n      return_amount := add(fee, input_amount)\r\n    }\r\n    _withdraw(input_asset, return_amount, address(_parent_address));\r\n    assembly {\r\n      sstore(_run_state_slot, 1)\r\n      \r\n      /* Log event: Trade */\r\n      mstore(m_in, input_asset)\r\n      mstore(add(m_in, 32), output_asset)\r\n      mstore(add(m_in, 64), input_amount)\r\n      mstore(add(m_in, 96), output_amount)\r\n      mstore(add(m_in, 128), fee)\r\n      log2(m_in, 160, /* Trade */ 0x4a2af5744adbfadba82ab831aea212bad92f5a70fef2079562044f423e999851, trade_contract)\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"transferOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset_address\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"lookupUnderlying\",\"outputs\":[{\"name\":\"result\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"input_asset\",\"type\":\"address\"},{\"name\":\"input_amount\",\"type\":\"uint256\"},{\"name\":\"output_asset\",\"type\":\"address\"},{\"name\":\"min_output_amount\",\"type\":\"uint256\"},{\"name\":\"trade_contract\",\"type\":\"address\"},{\"name\":\"trade_data\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comptrollerAddress\",\"outputs\":[{\"name\":\"comptroller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"comptroller\",\"type\":\"address\"}],\"name\":\"setComptrollerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cTokens\",\"type\":\"address[]\"}],\"name\":\"enterMarkets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trade_contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"output\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"input_fee\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"}]","ContractName":"MarginSwap","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://dc54144d981350a2e3cb9e1e40f23d67a410f5550e3fb3760c66861da40b4d8e"}]}