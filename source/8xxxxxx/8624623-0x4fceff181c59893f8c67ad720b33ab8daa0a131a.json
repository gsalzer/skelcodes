{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\n\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract RBACed {\n    using Roles for Roles.Role;\n\n    event RoleAdded(string _role);\n    event RoleAccessorAdded(string _role, address indexed _address);\n    event RoleAccessorRemoved(string _role, address indexed _address);\n\n    string constant public OWNER_ROLE = \"OWNER\";\n\n    string[] public roles;\n    mapping(bytes32 => uint256) roleIndexByName;\n    mapping(bytes32 => Roles.Role) private roleByName;\n\n    \n    constructor()\n    public\n    {\n        \n        _addRole(OWNER_ROLE);\n\n        \n        _addRoleAccessor(OWNER_ROLE, msg.sender);\n    }\n\n    modifier onlyRoleAccessor(string memory _role) {\n        require(isRoleAccessor(_role, msg.sender), \"RBACed: sender is not accessor of the role\");\n        _;\n    }\n\n    \n    \n    function rolesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return roles.length;\n    }\n\n    \n    \n    \n    function isRole(string memory _role)\n    public\n    view\n    returns (bool)\n    {\n        return 0 != roleIndexByName[_role2Key(_role)];\n    }\n\n    \n    \n    function addRole(string memory _role)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        _addRole(_role);\n\n        \n        emit RoleAdded(_role);\n    }\n\n    \n    \n    \n    \n    function isRoleAccessor(string memory _role, address _address)\n    public\n    view\n    returns (bool)\n    {\n        return roleByName[_role2Key(_role)].has(_address);\n    }\n\n    \n    \n    \n    function addRoleAccessor(string memory _role, address _address)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        _addRoleAccessor(_role, _address);\n\n        \n        emit RoleAccessorAdded(_role, _address);\n    }\n\n    \n    \n    \n    function removeRoleAccessor(string memory _role, address _address)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        roleByName[_role2Key(_role)].remove(_address);\n\n        \n        emit RoleAccessorRemoved(_role, _address);\n    }\n\n    function _addRole(string memory _role)\n    internal\n    {\n        if (0 == roleIndexByName[_role2Key(_role)]) {\n            roles.push(_role);\n            roleIndexByName[_role2Key(_role)] = roles.length;\n        }\n    }\n\n    function _addRoleAccessor(string memory _role, address _address)\n    internal\n    {\n        roleByName[_role2Key(_role)].add(_address);\n    }\n\n    function _role2Key(string memory _role)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_role));\n    }\n}\n\ncontract Resolvable {\n    \n    function resolveIfCriteriaMet()\n    public;\n\n    \n    \n    function resolutionCriteriaMet()\n    public\n    view\n    returns (bool);\n\n    \n    \n    \n    function resolutionDeltaAmount(bool _status)\n    public\n    view\n    returns (uint256);\n}\n\ncontract Able {\n    event Disabled(string _name);\n    event Enabled(string _name);\n\n    mapping(string => bool) private _disabled;\n\n    \n    \n    function enable(string memory _name)\n    public\n    {\n        \n        require(_disabled[_name], \"Able: name is enabled\");\n\n        \n        _disabled[_name] = false;\n\n        \n        emit Enabled(_name);\n    }\n\n    \n    \n    function disable(string memory _name)\n    public\n    {\n        \n        require(!_disabled[_name], \"Able: name is disabled\");\n\n        \n        _disabled[_name] = true;\n\n        \n        emit Disabled(_name);\n    }\n\n    \n    \n    function enabled(string memory _name)\n    public\n    view\n    returns (bool)\n    {\n        return !_disabled[_name];\n    }\n\n    \n    \n    function disabled(string memory _name)\n    public\n    view\n    returns (bool)\n    {\n        return _disabled[_name];\n    }\n\n    modifier onlyEnabled(string memory _name) {\n        require(enabled(_name), \"Able: name is disabled\");\n        _;\n    }\n\n    modifier onlyDisabled(string memory _name) {\n        require(disabled(_name), \"Able: name is enabled\");\n        _;\n    }\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\nlibrary VerificationPhaseLib {\n    using SafeMath for uint256;\n\n    enum State {Unopened, Opened, Closed}\n    enum Status {Null, True, False}\n\n    struct VerificationPhase {\n        State state;\n        Status result;\n\n        uint256 stakedAmount;\n        mapping(bool => uint256) stakedAmountByStatus;\n        mapping(address => mapping(bool => uint256)) stakedAmountByWalletStatus;\n        mapping(uint256 => mapping(bool => uint256)) stakedAmountByBlockStatus;\n\n        mapping(address => bool) stakedByWallet;\n        uint256 stakingWallets;\n\n        uint256 bountyAmount;\n        bool bountyAwarded;\n\n        uint256 startBlock;\n        uint256 endBlock;\n\n        uint256[] uintCriteria;\n    }\n\n    function open(VerificationPhase storage _phase, uint256 _bountyAmount) internal {\n        _phase.state = State.Opened;\n        _phase.bountyAmount = _bountyAmount;\n        _phase.startBlock = block.number;\n    }\n\n    function close(VerificationPhase storage _phase) internal {\n        _phase.state = State.Closed;\n        _phase.endBlock = block.number;\n        if (_phase.stakedAmountByStatus[true] > _phase.stakedAmountByStatus[false])\n            _phase.result = Status.True;\n        else if (_phase.stakedAmountByStatus[true] < _phase.stakedAmountByStatus[false])\n            _phase.result = Status.False;\n    }\n\n    function stake(VerificationPhase storage _phase, address _wallet,\n        bool _status, uint256 _amount) internal {\n        _phase.stakedAmount = _phase.stakedAmount.add(_amount);\n        _phase.stakedAmountByStatus[_status] = _phase.stakedAmountByStatus[_status].add(_amount);\n        _phase.stakedAmountByWalletStatus[_wallet][_status] =\n        _phase.stakedAmountByWalletStatus[_wallet][_status].add(_amount);\n        _phase.stakedAmountByBlockStatus[block.number][_status] =\n        _phase.stakedAmountByBlockStatus[block.number][_status].add(_amount);\n\n        if (!_phase.stakedByWallet[_wallet]) {\n            _phase.stakedByWallet[_wallet] = true;\n            _phase.stakingWallets = _phase.stakingWallets.add(1);\n        }\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\ninterface Allocator {\n    \n    function allocate()\n    external\n    view\n    returns (uint256);\n}\n\ncontract BountyFund is RBACed {\n    using SafeMath for uint256;\n\n    event ResolutionEngineSet(address indexed _resolutionEngine);\n    event TokensDeposited(address indexed _wallet, uint256 _amount, uint256 _balance);\n    event TokensAllocated(address indexed _wallet, address indexed _allocator,\n        uint256 _amount, uint256 _balance);\n    event Withdrawn(address indexed _wallet, uint256 _amount);\n\n    ERC20 public token;\n\n    address public operator;\n    address public resolutionEngine;\n\n    \n    constructor(address _token, address _operator)\n    public\n    {\n        \n        token = ERC20(_token);\n\n        \n        operator = _operator;\n    }\n\n    modifier onlyResolutionEngine() {\n        require(msg.sender == resolutionEngine, \"BountyFund: sender is not the defined resolution engine\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"BountyFund: sender is not the defined operator\");\n        _;\n    }\n\n    \n    \n    \n    function setResolutionEngine(address _resolutionEngine)\n    public\n    {\n        require(address(0) != _resolutionEngine, \"BountyFund: resolution engine argument is zero address\");\n        require(address(0) == resolutionEngine, \"BountyFund: resolution engine has already been set\");\n\n        \n        resolutionEngine = _resolutionEngine;\n\n        \n        emit ResolutionEngineSet(_resolutionEngine);\n    }\n\n    \n    \n    \n    function depositTokens(uint256 _amount)\n    public\n    {\n        \n        token.transferFrom(msg.sender, address(this), _amount);\n\n        \n        emit TokensDeposited(msg.sender, _amount, token.balanceOf(address(this)));\n    }\n\n    \n    \n    function allocateTokens(address _allocator)\n    public\n    onlyResolutionEngine\n    returns (uint256)\n    {\n        \n        uint256 amount = Allocator(_allocator).allocate();\n\n        \n        token.transfer(msg.sender, amount);\n\n        \n        emit TokensAllocated(msg.sender, _allocator, amount, token.balanceOf(address(this)));\n\n        \n        return amount;\n    }\n\n    \n    \n    function withdraw(address _wallet)\n    public\n    onlyOperator\n    {\n        \n        uint256 amount = token.balanceOf(address(this));\n\n        \n        token.transfer(_wallet, amount);\n\n        \n        emit Withdrawn(_wallet, amount);\n    }\n}\n\ncontract ResolutionEngine is Resolvable, RBACed, Able {\n    using SafeMath for uint256;\n    using VerificationPhaseLib for VerificationPhaseLib.VerificationPhase;\n\n    event Frozen();\n    event BountyAllocatorSet(address indexed _bountyAllocator);\n    event Staked(address indexed _wallet, uint256 indexed _verificationPhaseNumber, bool _status,\n        uint256 _amount);\n    event BountyWithdrawn(address indexed _wallet, uint256 _bountyAmount);\n    event VerificationPhaseOpened(uint256 indexed _verificationPhaseNumber, uint256 _bountyAmount);\n    event VerificationPhaseClosed(uint256 indexed _verificationPhaseNumber);\n    event PayoutStaged(address indexed _wallet, uint256 indexed _firstVerificationPhaseNumber,\n        uint256 indexed _lastVerificationPhaseNumber, uint256 _payout);\n    event StakeStaged(address indexed _wallet, uint _amount);\n    event Staged(address indexed _wallet, uint _amount);\n    event Withdrawn(address indexed _wallet, uint _amount);\n\n    string constant public STAKE_ACTION = \"STAKE\";\n    string constant public RESOLVE_ACTION = \"RESOLVE\";\n\n    address public oracle;\n    address public operator;\n    address public bountyAllocator;\n\n    BountyFund public bountyFund;\n\n    ERC20 public token;\n\n    bool public frozen;\n\n    uint256 public verificationPhaseNumber;\n\n    mapping(uint256 => VerificationPhaseLib.VerificationPhase) public verificationPhaseByPhaseNumber;\n\n    mapping(address => mapping(bool => uint256)) public stakedAmountByWalletStatus;\n    mapping(uint256 => mapping(bool => uint256)) public stakedAmountByBlockStatus;\n\n    VerificationPhaseLib.Status public verificationStatus;\n\n    mapping(address => mapping(uint256 => bool)) public payoutStagedByWalletPhase;\n    mapping(address => uint256) public stagedAmountByWallet;\n\n    \n    constructor(address _oracle, address _operator, address _bountyFund)\n    public\n    {\n        \n        oracle = _oracle;\n        operator = _operator;\n\n        \n        bountyFund = BountyFund(_bountyFund);\n        bountyFund.setResolutionEngine(address(this));\n\n        \n        token = ERC20(bountyFund.token());\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle, \"ResolutionEngine: sender is not the defined oracle\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"ResolutionEngine: sender is not the defined operator\");\n        _;\n    }\n\n    modifier onlyNotFrozen() {\n        require(!frozen, \"ResolutionEngine: is frozen\");\n        _;\n    }\n\n    \n    \n    function freeze()\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        frozen = true;\n\n        \n        emit Frozen();\n    }\n\n    \n    \n    function setBountyAllocator(address _bountyAllocator)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        bountyAllocator = _bountyAllocator;\n\n        \n        emit BountyAllocatorSet(bountyAllocator);\n    }\n\n    \n    function initialize()\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        require(0 == verificationPhaseNumber, \"ResolutionEngine: already initialized\");\n\n        \n        _openVerificationPhase();\n    }\n\n    \n    \n    function disable(string memory _action)\n    public\n    onlyOperator\n    {\n        \n        super.disable(_action);\n    }\n\n    \n    \n    function enable(string memory _action)\n    public\n    onlyOperator\n    {\n        \n        super.enable(_action);\n    }\n\n    \n    \n    \n    \n    \n    function stake(address _wallet, bool _status, uint256 _amount)\n    public\n    onlyOracle\n    onlyEnabled(STAKE_ACTION)\n    {\n        \n        stakedAmountByWalletStatus[_wallet][_status] = stakedAmountByWalletStatus[_wallet][_status].add(_amount);\n        stakedAmountByBlockStatus[block.number][_status] = stakedAmountByBlockStatus[block.number][_status]\n        .add(_amount);\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].stake(_wallet, _status, _amount);\n\n        \n        emit Staked(_wallet, verificationPhaseNumber, _status, _amount);\n    }\n\n    \n    \n    \n    function resolveIfCriteriaMet()\n    public\n    onlyOracle\n    onlyEnabled(RESOLVE_ACTION)\n    {\n        \n        if (resolutionCriteriaMet()) {\n            \n            _closeVerificationPhase();\n\n            \n            _openVerificationPhase();\n        }\n    }\n\n    \n    \n    \n    function metricsByVerificationPhaseNumber(uint256 _verificationPhaseNumber)\n    public\n    view\n    returns (VerificationPhaseLib.State state, uint256 trueStakeAmount, uint256 falseStakeAmount,\n        uint256 stakeAmount, uint256 numberOfWallets, uint256 bountyAmount, bool bountyAwarded,\n        uint256 startBlock, uint256 endBlock, uint256 numberOfBlocks)\n    {\n        state = verificationPhaseByPhaseNumber[_verificationPhaseNumber].state;\n        trueStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmountByStatus[true];\n        falseStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmountByStatus[false];\n        stakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmount;\n        numberOfWallets = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakingWallets;\n        bountyAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAmount;\n        bountyAwarded = verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAwarded;\n        startBlock = verificationPhaseByPhaseNumber[_verificationPhaseNumber].startBlock;\n        endBlock = verificationPhaseByPhaseNumber[_verificationPhaseNumber].endBlock;\n        numberOfBlocks = (startBlock > 0 && endBlock == 0 ? block.number : endBlock).sub(startBlock);\n    }\n\n    \n    \n    \n    \n    \n    function metricsByVerificationPhaseNumberAndWallet(uint256 _verificationPhaseNumber, address _wallet)\n    public\n    view\n    returns (uint256 trueStakeAmount, uint256 falseStakeAmount, uint256 stakeAmount)\n    {\n        trueStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][true];\n        falseStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][false];\n        stakeAmount = trueStakeAmount.add(falseStakeAmount);\n    }\n\n    \n    \n    \n    function metricsByWallet(address _wallet)\n    public\n    view\n    returns (uint256 trueStakeAmount, uint256 falseStakeAmount, uint256 stakeAmount)\n    {\n        trueStakeAmount = stakedAmountByWalletStatus[_wallet][true];\n        falseStakeAmount = stakedAmountByWalletStatus[_wallet][false];\n        stakeAmount = trueStakeAmount.add(falseStakeAmount);\n    }\n\n    \n    \n    \n    \n    function metricsByBlockNumber(uint256 _blockNumber)\n    public\n    view\n    returns (uint256 trueStakeAmount, uint256 falseStakeAmount, uint256 stakeAmount)\n    {\n        trueStakeAmount = stakedAmountByBlockStatus[_blockNumber][true];\n        falseStakeAmount = stakedAmountByBlockStatus[_blockNumber][false];\n        stakeAmount = trueStakeAmount.add(falseStakeAmount);\n    }\n\n    \n    \n    \n    \n    \n    function calculatePayout(address _wallet, uint256 _firstVerificationPhaseNumber,\n        uint256 _lastVerificationPhaseNumber)\n    public\n    view\n    returns (uint256)\n    {\n        \n        uint256 payout = 0;\n        for (uint256 i = _firstVerificationPhaseNumber; i <= _lastVerificationPhaseNumber; i++)\n            payout = payout.add(_calculatePayout(_wallet, i));\n\n        \n        return payout;\n    }\n\n    \n    \n    \n    \n    \n    function stagePayout(address _wallet, uint256 _firstVerificationPhaseNumber,\n        uint256 _lastVerificationPhaseNumber)\n    public\n    onlyOracle\n    {\n        \n        uint256 amount = 0;\n        for (uint256 i = _firstVerificationPhaseNumber; i <= _lastVerificationPhaseNumber; i++)\n            amount = amount.add(_stagePayout(_wallet, i));\n\n        \n        emit PayoutStaged(_wallet, _firstVerificationPhaseNumber, _lastVerificationPhaseNumber, amount);\n    }\n\n    \n    \n    \n    function stageStake(address _wallet)\n    public\n    onlyOracle\n    onlyDisabled(RESOLVE_ACTION)\n    {\n        \n        uint256 amount = verificationPhaseByPhaseNumber[verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][true].add(\n            verificationPhaseByPhaseNumber[verificationPhaseNumber]\n            .stakedAmountByWalletStatus[_wallet][false]\n        );\n\n        \n        require(0 < amount, \"ResolutionEngine: stake is zero\");\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByWalletStatus[_wallet][true] = 0;\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByWalletStatus[_wallet][false] = 0;\n\n        \n        _stage(_wallet, amount);\n\n        \n        emit StakeStaged(_wallet, amount);\n    }\n\n    \n    \n    \n    \n    function stage(address _wallet, uint256 _amount)\n    public\n    onlyOracle\n    {\n        \n        _stage(_wallet, _amount);\n\n        \n        emit Staged(_wallet, _amount);\n    }\n\n    \n    \n    \n    \n    function withdraw(address _wallet, uint256 _amount)\n    public\n    onlyOracle\n    {\n        \n        require(_amount <= stagedAmountByWallet[_wallet], \"ResolutionEngine: amount is greater than staged amount\");\n\n        \n        stagedAmountByWallet[_wallet] = stagedAmountByWallet[_wallet].sub(_amount);\n\n        \n        token.transfer(_wallet, _amount);\n\n        \n        emit Withdrawn(_wallet, _amount);\n    }\n\n    \n    \n    function withdrawBounty(address _wallet)\n    public\n    onlyOperator\n    onlyDisabled(RESOLVE_ACTION)\n    {\n        \n        require(0 < verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount,\n            \"ResolutionEngine: bounty is zero\");\n\n        \n        uint256 amount = verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount;\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount = 0;\n\n        \n        token.transfer(_wallet, amount);\n\n        \n        emit BountyWithdrawn(_wallet, amount);\n    }\n\n    \n    function _openVerificationPhase()\n    internal\n    {\n        \n        require(\n            verificationPhaseByPhaseNumber[verificationPhaseNumber.add(1)].state == VerificationPhaseLib.State.Unopened,\n            \"ResolutionEngine: verification phase is not in unopened state\"\n        );\n\n        \n        verificationPhaseNumber = verificationPhaseNumber.add(1);\n\n        \n        uint256 bountyAmount = bountyFund.allocateTokens(bountyAllocator);\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].open(bountyAmount);\n\n        \n        _addVerificationCriteria();\n\n        \n        emit VerificationPhaseOpened(verificationPhaseNumber, bountyAmount);\n    }\n\n    \n    function _addVerificationCriteria() internal;\n\n    \n    function _closeVerificationPhase()\n    internal\n    {\n        \n        require(verificationPhaseByPhaseNumber[verificationPhaseNumber].state == VerificationPhaseLib.State.Opened,\n            \"ResolutionEngine: verification phase is not in opened state\");\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].close();\n\n        \n        if (verificationPhaseByPhaseNumber[verificationPhaseNumber].result != verificationStatus) {\n            \n            verificationStatus = verificationPhaseByPhaseNumber[verificationPhaseNumber].result;\n\n            \n            verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAwarded = true;\n        }\n\n        \n        emit VerificationPhaseClosed(verificationPhaseNumber);\n    }\n\n    \n    function _calculatePayout(address _wallet, uint256 _verificationPhaseNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        \n        if (VerificationPhaseLib.Status.Null == verificationPhaseByPhaseNumber[_verificationPhaseNumber].result)\n            return 0;\n\n        \n        bool status =\n        verificationPhaseByPhaseNumber[_verificationPhaseNumber].result == VerificationPhaseLib.Status.True;\n\n        \n        uint256 lot = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmountByStatus[!status];\n\n        \n        if (verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAwarded)\n            lot = lot.add(verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAmount);\n\n        \n        uint256 walletStatusAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][status];\n        uint256 statusAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByStatus[status];\n\n        \n        \n        return lot.mul(walletStatusAmount).div(statusAmount).add(walletStatusAmount);\n    }\n\n    \n    function _stagePayout(address _wallet, uint256 _verificationPhaseNumber)\n    internal\n    returns (uint256)\n    {\n        \n        if (VerificationPhaseLib.State.Closed != verificationPhaseByPhaseNumber[_verificationPhaseNumber].state)\n            return 0;\n\n        \n        if (payoutStagedByWalletPhase[_wallet][_verificationPhaseNumber])\n            return 0;\n\n        \n        payoutStagedByWalletPhase[_wallet][_verificationPhaseNumber] = true;\n\n        \n        uint256 payout = _calculatePayout(_wallet, _verificationPhaseNumber);\n\n        \n        _stage(_wallet, payout);\n\n        \n        return payout;\n    }\n\n    \n    function _stage(address _wallet, uint256 _amount)\n    internal\n    {\n        stagedAmountByWallet[_wallet] = stagedAmountByWallet[_wallet].add(_amount);\n    }\n}\n\ncontract Operator is RBACed {\n    using SafeMath for uint256;\n\n    bool public frozen;\n\n    uint256 public minimumTimeout;\n    mapping(address => uint256) public disablementTimeoutByResolutionEngine;\n\n    event Frozen();\n    event DisablementTimerStarted(address indexed _resolutionEngine, uint256 _timeout);\n    event DisablementTimerStopped(address indexed _resolutionEngine);\n    event Disabled(address indexed _resolutionEngine);\n    event AllocatedBountyWithdrawn(address indexed _resolutionEngine);\n    event UnallocatedBountyWithdrawn(address indexed _bountyFund);\n    event MinimumTimeoutSet(uint256 minimumTimeout);\n\n    \n    constructor(uint256 _minimumTimeout)\n    public\n    {\n        minimumTimeout = _minimumTimeout;\n    }\n\n    modifier onlyNotFrozen() {\n        require(!frozen, \"Operator: is frozen\");\n        _;\n    }\n\n    \n    \n    function freeze()\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        frozen = true;\n\n        \n        emit Frozen();\n    }\n\n    \n    \n    \n    \n    function startDisablementTimer(address _resolutionEngine, uint256 _timeout)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        require(_timeout >= minimumTimeout, \"Operator: timeout is smaller than the set minimum\");\n\n        \n        disablementTimeoutByResolutionEngine[_resolutionEngine] = block.timestamp.add(_timeout);\n\n        \n        ResolutionEngine resolutionEngine = ResolutionEngine(_resolutionEngine);\n\n        \n        resolutionEngine.disable(resolutionEngine.STAKE_ACTION());\n\n        \n        emit DisablementTimerStarted(\n            _resolutionEngine, disablementTimeoutByResolutionEngine[_resolutionEngine]\n        );\n    }\n\n    \n    \n    function stopDisablementTimer(address _resolutionEngine)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        ResolutionEngine resolutionEngine = ResolutionEngine(_resolutionEngine);\n\n        \n        require(!resolutionEngine.disabled(resolutionEngine.RESOLVE_ACTION()),\n            \"Operator: resolution engine has already been disabled\");\n\n        \n        disablementTimeoutByResolutionEngine[_resolutionEngine] = 0;\n\n        \n        resolutionEngine.enable(resolutionEngine.STAKE_ACTION());\n\n        \n        emit DisablementTimerStopped(_resolutionEngine);\n    }\n\n    \n    \n    \n    function isDisablementTimerExpired(address _resolutionEngine)\n    public\n    view\n    returns (bool)\n    {\n        return block.timestamp >= disablementTimeoutByResolutionEngine[_resolutionEngine];\n    }\n\n    \n    \n    function disable(address _resolutionEngine)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        require(\n            isDisablementTimerExpired(_resolutionEngine),\n            \"Operator: disablement timer is not expired\"\n        );\n\n        \n        ResolutionEngine resolutionEngine = ResolutionEngine(_resolutionEngine);\n\n        \n        resolutionEngine.disable(resolutionEngine.RESOLVE_ACTION());\n\n        \n        emit Disabled(_resolutionEngine);\n    }\n\n    \n    \n    \n    function withdrawAllocatedBounty(address _resolutionEngine, address _wallet)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        ResolutionEngine resolutionEngine = ResolutionEngine(_resolutionEngine);\n\n        \n        resolutionEngine.withdrawBounty(_wallet);\n\n        \n        emit AllocatedBountyWithdrawn(_resolutionEngine);\n    }\n\n    \n    \n    \n    function withdrawUnallocatedBounty(address _bountyFund, address _wallet)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        BountyFund bountyFund = BountyFund(_bountyFund);\n\n        \n        ResolutionEngine resolutionEngine = ResolutionEngine(bountyFund.resolutionEngine());\n\n        \n        require(resolutionEngine.disabled(resolutionEngine.RESOLVE_ACTION()),\n            \"Operator: resolution engine's resolve action not disabled\");\n\n        \n        bountyFund.withdraw(_wallet);\n\n        \n        emit UnallocatedBountyWithdrawn(_bountyFund);\n    }\n\n    \n    \n    \n    function setMinimumTimeout(uint256 _minimumTimeout)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    onlyNotFrozen\n    {\n        \n        minimumTimeout = _minimumTimeout;\n\n        \n        emit MinimumTimeoutSet(minimumTimeout);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"disablementTimeoutByResolutionEngine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bountyFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"withdrawUnallocatedBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumTimeout\",\"type\":\"uint256\"}],\"name\":\"setMinimumTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addRoleAccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeRoleAccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"}],\"name\":\"isDisablementTimerExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"startDisablementTimer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"}],\"name\":\"stopDisablementTimer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"withdrawAllocatedBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rolesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"}],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isRoleAccessor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumTimeout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"DisablementTimerStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"}],\"name\":\"DisablementTimerStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"}],\"name\":\"Disabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_resolutionEngine\",\"type\":\"address\"}],\"name\":\"AllocatedBountyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_bountyFund\",\"type\":\"address\"}],\"name\":\"UnallocatedBountyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumTimeout\",\"type\":\"uint256\"}],\"name\":\"MinimumTimeoutSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RoleAccessorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RoleAccessorRemoved\",\"type\":\"event\"}]","ContractName":"Operator","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000278d00","Library":"","LicenseType":"","SwarmSource":"bzzr://3c9bf993f7f65957328db1c5a4e547fc68437107cd0f9ba21b855e554611a07b"}]}