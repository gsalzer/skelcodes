{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n $$$$$$\\  $$$$$$\\  \r\n \\_$$  _|$$  __$$\\ \r\n   $$ |  $$ /  $$ |\r\n   $$ |  $$ |  $$ |\r\n   $$ |  $$ |  $$ |\r\n   $$ |  $$ |  $$ |\r\n $$$$$$\\  $$$$$$  |\r\n \\______| \\______/ \r\n\r\n*/\r\npragma solidity ^0.5.10;\r\n\r\nlibrary Util {\r\n    struct User {\r\n        bool isExist;\r\n        uint256 id;\r\n        uint256 origRefID;\r\n        uint256 referrerID;\r\n        address[] referral;\r\n        uint256[] expiring;\r\n    }\r\n\r\n}\r\n\r\ncontract IOCrypto {\r\n    /////////////////////\r\n    // Events\r\n    /////////////////////\r\n    event registered(address indexed user, address indexed referrer);\r\n    event levelBought(address indexed user, uint256 level);\r\n    event receivedEther(address indexed user, address indexed referral, uint256 level);\r\n    event lostEther(address indexed user, address indexed referral, uint256 level);\r\n\r\n    /////////////////////\r\n    // Storage variables\r\n    /////////////////////\r\n    address public wallet;\r\n\r\n    uint256 constant MAX_REFERRERS = 2;\r\n    uint256 LEVEL_PERIOD = 365 days;\r\n\r\n    /////////////////////\r\n    // User structure and mappings\r\n    /////////////////////\r\n\r\n    mapping(address => Util.User) public users;\r\n    mapping(uint256 => address) public userList;\r\n    uint256 public userIDCounter = 0;\r\n\r\n    /////////////////////\r\n    // Code\r\n    /////////////////////\r\n    constructor() public {\r\n        wallet = 0x387db6A5a4854610faB136A40B9Fb5E4675d2A16;\r\n\r\n        Util.User memory user;\r\n        userIDCounter++;\r\n\r\n        user = Util.User({\r\n            isExist : true,\r\n            id : userIDCounter,\r\n            origRefID: 0,\r\n            referrerID : 0,\r\n            referral : new address[](0),\r\n            expiring : new uint256[](9)\r\n            });\r\n\r\n        user.expiring[1] = 101010101010;\r\n        user.expiring[2] = 101010101010;\r\n        user.expiring[3] = 101010101010;\r\n        user.expiring[4] = 101010101010;\r\n        user.expiring[5] = 101010101010;\r\n        user.expiring[6] = 101010101010;\r\n        user.expiring[7] = 101010101010;\r\n        user.expiring[8] = 101010101010;\r\n\r\n        userList[userIDCounter] = wallet;\r\n        users[wallet] = user;\r\n    }\r\n\r\n    function() external payable {\r\n        uint256 level = getLevel(msg.value);\r\n\r\n        if (users[msg.sender].isExist) {\r\n            buy(level);\r\n        } else if (level == 1) {\r\n            uint256 referrerID = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if (users[referrer].isExist) {\r\n                referrerID = users[referrer].id;\r\n            } else {\r\n                revert('01 wrong referrer');\r\n            }\r\n\r\n            register(referrerID);\r\n        } else {\r\n            revert(\"02 buy level 1 for 0.1 ETH\");\r\n        }\r\n    }\r\n\r\n    function register(uint256 referrerID) public payable {\r\n        require(!users[msg.sender].isExist, '03 user exist');\r\n        require(referrerID > 0 && referrerID <= userIDCounter, '0x04 wrong referrer ID');\r\n        require(getLevel(msg.value) == 1, '05 wrong value');\r\n\r\n        uint origRefID = referrerID;\r\n        if (users[userList[referrerID]].referral.length >= MAX_REFERRERS)\r\n        {\r\n            referrerID = users[findReferrer(userList[referrerID])].id;\r\n        }\r\n\r\n        Util.User memory user;\r\n        userIDCounter++;\r\n\r\n        user = Util.User({\r\n            isExist : true,\r\n            id : userIDCounter,\r\n            origRefID : origRefID,\r\n            referrerID : referrerID,\r\n            referral : new address[](0),\r\n            expiring : new uint256[](9)\r\n            });\r\n\r\n        user.expiring[1] = now + LEVEL_PERIOD;\r\n        user.expiring[2] = 0;\r\n        user.expiring[3] = 0;\r\n        user.expiring[4] = 0;\r\n        user.expiring[5] = 0;\r\n        user.expiring[6] = 0;\r\n        user.expiring[7] = 0;\r\n        user.expiring[8] = 0;\r\n\r\n        userList[userIDCounter] = msg.sender;\r\n        users[msg.sender] = user;\r\n\r\n        users[userList[referrerID]].referral.push(msg.sender);\r\n\r\n        payForLevel(msg.sender, 1);\r\n\r\n        emit registered(msg.sender, userList[referrerID]);\r\n    }\r\n\r\n    function buy(uint256 level) public payable {\r\n        require(users[msg.sender].isExist, '06 user not exist');\r\n\r\n        require(level > 0 && level <= 8, '07 wrong level');\r\n\r\n        require(getLevel(msg.value) == level, '08 wrong value');\r\n\r\n        for (uint256 l = level - 1; l > 0; l--) {\r\n             require(users[msg.sender].expiring[l] >= now, '09 buy level');\r\n        }\r\n\r\n        if (users[msg.sender].expiring[level] == 0) {\r\n            users[msg.sender].expiring[level] = now + LEVEL_PERIOD;\r\n        } else {\r\n            users[msg.sender].expiring[level] += LEVEL_PERIOD;\r\n        }\r\n\r\n        payForLevel(msg.sender, level);\r\n        emit levelBought(msg.sender, level);\r\n    }\r\n\r\n    function payForLevel(address user, uint256 level) internal {\r\n        address referrer;\r\n        uint256 above = level > 4 ? level - 4 : level;\r\n        if (1 < level && level < 4) {\r\n            checkCanBuy(user, level);\r\n        }\r\n        if (above == 1) {\r\n            referrer = userList[users[user].referrerID];\r\n        } else if (above == 2) {\r\n            referrer = userList[users[user].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n        } else if (above == 3) {\r\n            referrer = userList[users[user].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n        } else if (above == 4) {\r\n            referrer = userList[users[user].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n            referrer = userList[users[referrer].referrerID];\r\n        }\r\n\r\n        if (!users[referrer].isExist) {\r\n            referrer = userList[1];\r\n        }\r\n\r\n        if (users[referrer].expiring[level] >= now) {\r\n            bool result;\r\n            result = address(uint160(referrer)).send(msg.value);\r\n            emit receivedEther(referrer, msg.sender, level);\r\n        } else {\r\n            emit lostEther(referrer, msg.sender, level);\r\n            payForLevel(referrer, level);\r\n        }\r\n    }\r\n\r\n    function checkCanBuy(address user, uint256 level) private view {\r\n        if (level == 1) return;\r\n        address[] memory referral = users[user].referral;\r\n        require(referral.length == MAX_REFERRERS, '10 not enough referrals');\r\n\r\n        if (level == 2) return;\r\n        checkCanBuy(referral[0], level - 1);\r\n        checkCanBuy(referral[1], level - 1);\r\n    }\r\n\r\n    function findReferrer(address user) public view returns (address) {\r\n        address[] memory referral = users[user].referral;\r\n        if (referral.length < MAX_REFERRERS) {\r\n            return user;\r\n        }\r\n\r\n        address[] memory referrals = new address[](1024);\r\n        referrals[0] = referral[0];\r\n        referrals[1] = referral[1];\r\n\r\n        address freeReferrer;\r\n        bool hasFreeReferrer = false;\r\n\r\n        for (uint256 i = 0; i < 1024; i++) {\r\n            referral = users[referrals[i]].referral;\r\n            if (referral.length == MAX_REFERRERS) {\r\n                if (i < 512) {\r\n                    uint256 pos = (i + 1) * 2;\r\n                    referrals[pos] = referral[0];\r\n                    referrals[pos + 1] = referral[1];\r\n                }\r\n            } else {\r\n                hasFreeReferrer = true;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n        require(hasFreeReferrer, '11 no free referrer');\r\n        return freeReferrer;\r\n    }\r\n\r\n    function getLevel(uint256 price) public pure returns (uint8) {\r\n        if (price == 0.1 ether) {\r\n            return 1;\r\n        } else if (price == 0.15 ether) {\r\n            return 2;\r\n        } else if (price == 0.35 ether) {\r\n            return 3;\r\n        } else if (price == 2 ether) {\r\n            return 4;\r\n        } else if (price == 5 ether) {\r\n            return 5;\r\n        } else if (price == 9 ether) {\r\n            return 6;\r\n        } else if (price == 35 ether) {\r\n            return 7;\r\n        } else if (price == 100 ether) {\r\n            return 8;\r\n        } else {\r\n            revert('12 wrong value');\r\n        }\r\n    }\r\n\r\n    function viewReferral(address user) public view returns (address[] memory) {\r\n        return users[user].referral;\r\n    }\r\n\r\n    function viewLevelExpired(address user, uint256 level) public view returns (uint256) {\r\n        return users[user].expiring[level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"viewLevelExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"isExist\",\"type\":\"bool\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"origRefID\",\"type\":\"uint256\"},{\"name\":\"referrerID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userIDCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"findReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"viewReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerID\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"levelBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"receivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"lostEther\",\"type\":\"event\"}]","ContractName":"IOCrypto","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://409f02e762c3139880d0df8021bbd2b1cf88e06571e70cc6525f201905ec39eb"}]}