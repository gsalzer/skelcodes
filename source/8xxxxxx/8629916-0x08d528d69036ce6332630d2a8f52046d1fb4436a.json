{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/IIvoCrowdsale.sol\r\n\r\n/**\r\n * @title Interface of IVO Crowdale\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IIvoCrowdsale {\r\n    /**\r\n     * @return The starting time of the crowdsale.\r\n     */\r\n    function startingTime() public view returns(uint256);\r\n}\r\n\r\n// File: contracts/vault/IVault.sol\r\n\r\n/*\r\n * @title Interface for basic vaults\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IVault {\r\n    /**\r\n     * @notice Adding beneficiary to the vault\r\n     * @param beneficiary The account that receives token\r\n     * @param value The amount of token allocated\r\n     */\r\n    function receiveFor(address beneficiary, uint256 value) public;\r\n\r\n    /**\r\n     * @notice Update the releaseTime for vaults\r\n     * @param roundEndTime The new releaseTime\r\n     */\r\n    function updateReleaseTime(uint256 roundEndTime) public;\r\n}\r\n\r\n// File: contracts/property/CounterGuard.sol\r\n\r\n/**\r\n * @title modifier contract that guards certain properties only triggered once\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract CounterGuard {\r\n    /**\r\n     * @notice Controle if a boolean attribute (false by default) was updated to true.\r\n     * @dev This attribute is designed specifically for recording an action.\r\n     * @param criterion The boolean attribute that records if an action has taken place\r\n     */\r\n    modifier onlyOnce(bool criterion) {\r\n        require(criterion == false, \"Already been set\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/property/Reclaimable.sol\r\n\r\n/**\r\n * @title Reclaimable\r\n * @dev This contract gives owner right to recover any ERC20 tokens accidentally sent to \r\n * the token contract. The recovered token will be sent to the owner of token. \r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract Reclaimable is Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /**\r\n     * @notice Let the owner to retrieve other tokens accidentally sent to this contract.\r\n     * @dev This function is suitable when no token of any kind shall be stored under\r\n     * the address of the inherited contract.\r\n     * @param tokenToBeRecovered address of the token to be recovered.\r\n     */\r\n    function reclaimToken(IERC20 tokenToBeRecovered) external onlyOwner {\r\n        uint256 balance = tokenToBeRecovered.balanceOf(address(this));\r\n        tokenToBeRecovered.safeTransfer(owner(), balance);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conforms\r\n * the base architecture for crowdsales. It is *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // The token being sold\r\n    IERC20 private _token;\r\n\r\n    // Address where funds are collected\r\n    address payable private _wallet;\r\n\r\n    // How many token units a buyer gets per wei.\r\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n    // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\r\n    // 1 wei will give you 1 unit, or 0.001 TOK.\r\n    uint256 private _rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 private _weiRaised;\r\n\r\n    /**\r\n     * Event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * @param rate Number of token units a buyer gets per wei\r\n     * @dev The rate is the conversion between wei and the smallest and indivisible\r\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\r\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\r\n     * @param wallet Address where collected funds will be forwarded to\r\n     * @param token Address of the token being sold\r\n     */\r\n    constructor (uint256 rate, address payable wallet, IERC20 token) public {\r\n        require(rate > 0, \"Crowdsale: rate is 0\");\r\n        require(wallet != address(0), \"Crowdsale: wallet is the zero address\");\r\n        require(address(token) != address(0), \"Crowdsale: token is the zero address\");\r\n\r\n        _rate = rate;\r\n        _wallet = wallet;\r\n        _token = token;\r\n    }\r\n\r\n    /**\r\n     * @dev fallback function ***DO NOT OVERRIDE***\r\n     * Note that other contracts will transfer funds with a base gas stipend\r\n     * of 2300, which is not enough to call buyTokens. Consider calling\r\n     * buyTokens directly when purchasing tokens from a contract.\r\n     */\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @return the token being sold.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    /**\r\n     * @return the address where funds are collected.\r\n     */\r\n    function wallet() public view returns (address payable) {\r\n        return _wallet;\r\n    }\r\n\r\n    /**\r\n     * @return the number of token units a buyer gets per wei.\r\n     */\r\n    function rate() public view returns (uint256) {\r\n        return _rate;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of wei raised.\r\n     */\r\n    function weiRaised() public view returns (uint256) {\r\n        return _weiRaised;\r\n    }\r\n\r\n    /**\r\n     * @dev low level token purchase ***DO NOT OVERRIDE***\r\n     * This function has a non-reentrancy guard, so it shouldn't be called by\r\n     * another `nonReentrant` function.\r\n     * @param beneficiary Recipient of the token purchase\r\n     */\r\n    function buyTokens(address beneficiary) public nonReentrant payable {\r\n        uint256 weiAmount = msg.value;\r\n        _preValidatePurchase(beneficiary, weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n        // update state\r\n        _weiRaised = _weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(beneficiary, tokens);\r\n        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n        _updatePurchasingState(beneficiary, weiAmount);\r\n\r\n        _forwardFunds();\r\n        _postValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\r\n     * Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n     * Example from CappedCrowdsale.sol's _preValidatePurchase method:\r\n     *     super._preValidatePurchase(beneficiary, weiAmount);\r\n     *     require(weiRaised().add(weiAmount) <= cap);\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\r\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\r\n    }\r\n\r\n    /**\r\n     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid\r\n     * conditions are not met.\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends\r\n     * its tokens.\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param tokenAmount Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\r\n        _token.safeTransfer(beneficiary, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send\r\n     * tokens.\r\n     * @param beneficiary Address receiving the tokens\r\n     * @param tokenAmount Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\r\n        _deliverTokens(beneficiary, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for extensions that require an internal state to check for validity (current user contributions,\r\n     * etc.)\r\n     * @param beneficiary Address receiving the tokens\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @dev Override to extend the way in which ether is converted to tokens.\r\n     * @param weiAmount Value in wei to be converted into tokens\r\n     * @return Number of tokens that can be purchased with the specified _weiAmount\r\n     */\r\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\r\n        return weiAmount.mul(_rate);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines how ETH is stored/forwarded on purchases.\r\n     */\r\n    function _forwardFunds() internal {\r\n        _wallet.transfer(msg.value);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/membership/ManagerRole.sol\r\n\r\n/**\r\n * @title Manager Role\r\n * @dev This contract is developed based on the Manager contract of OpenZeppelin.\r\n * The key difference is the management of the manager roles is restricted to one owner\r\n * account. At least one manager should exist in any situation.\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ManagerRole is Ownable {\r\n    using Roles for Roles.Role;\r\n    using SafeMath for uint256;\r\n\r\n    event ManagerAdded(address indexed account);\r\n    event ManagerRemoved(address indexed account);\r\n\r\n    Roles.Role private managers;\r\n    uint256 private _numManager;\r\n\r\n    constructor() internal {\r\n        _addManager(msg.sender);\r\n        _numManager = 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager can take action\r\n     */\r\n    modifier onlyManager() {\r\n        require(isManager(msg.sender), \"The account is not a manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This function allows to add managers in batch with control of the number of \r\n     * interations\r\n     * @param accounts The accounts to be added in batch\r\n     */\r\n    // solhint-disable-next-line\r\n    function addManagers(address[] calldata accounts) external onlyOwner {\r\n        uint256 length = accounts.length;\r\n        require(length <= 256, \"too many accounts\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _addManager(accounts[i]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Add an account to the list of managers,\r\n     * @param account The account address whose manager role needs to be removed.\r\n     */\r\n    function removeManager(address account) external onlyOwner {\r\n        _removeManager(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an account is a manager\r\n     * @param account The account to be checked if it has a manager role\r\n     * @return true if the account is a manager. Otherwise, false\r\n     */\r\n    function isManager(address account) public view returns (bool) {\r\n        return managers.has(account);\r\n    }\r\n\r\n    /**\r\n     *@notice Get the number of the current managers\r\n     */\r\n    function numManager() public view returns (uint256) {\r\n        return _numManager;\r\n    }\r\n\r\n    /**\r\n     * @notice Add an account to the list of managers,\r\n     * @param account The account that needs to tbe added as a manager\r\n     */\r\n    function addManager(address account) public onlyOwner {\r\n        require(account != address(0), \"account is zero\");\r\n        _addManager(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Renounce the manager role\r\n     * @dev This function was not explicitly required in the specs. There should be at\r\n     * least one manager at any time. Therefore, at least two when one manage renounces\r\n     * themselves.\r\n     */\r\n    function renounceManager() public {\r\n        require(_numManager >= 2, \"Managers are fewer than 2\");\r\n        _removeManager(msg.sender);\r\n    }\r\n\r\n    /** OVERRIDE \r\n    * @notice Allows the current owner to relinquish control of the contract.\r\n    * @dev Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        revert(\"Cannot renounce ownership\");\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to be called when adding a manager\r\n     * @param account The address of the manager-to-be\r\n     */\r\n    function _addManager(address account) internal {\r\n        _numManager = _numManager.add(1);\r\n        managers.add(account);\r\n        emit ManagerAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to remove one account from the manager list\r\n     * @param account The address of the to-be-removed manager\r\n     */\r\n    function _removeManager(address account) internal {\r\n        _numManager = _numManager.sub(1);\r\n        managers.remove(account);\r\n        emit ManagerRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/membership/PausableManager.sol\r\n\r\n/**\r\n * @title Pausable Manager Role\r\n * @dev This manager can also pause a contract. This contract is developed based on the \r\n * Pause contract of OpenZeppelin.\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract PausableManager is ManagerRole {\r\n\r\n    event BePaused(address manager);\r\n    event BeUnpaused(address manager);\r\n\r\n    bool private _paused;   // If the crowdsale contract is paused, controled by the manager...\r\n\r\n    constructor() internal {\r\n        _paused = false;\r\n    }\r\n\r\n   /**\r\n    * @notice Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(_paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if the contract is paused, false otherwise.\r\n    */\r\n    function paused() public view returns(bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n    * @notice called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyManager whenNotPaused {\r\n        _paused = true;\r\n        emit BePaused(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyManager whenPaused {\r\n        _paused = false;\r\n        emit BeUnpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/property/ValidAddress.sol\r\n\r\n/**\r\n * @title modifier contract that checks if the address is valid\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ValidAddress {\r\n    /**\r\n     * @notice Check if the address is not zero\r\n     */\r\n    modifier onlyValidAddress(address _address) {\r\n        require(_address != address(0), \"Not a valid address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the address is not the sender's address\r\n    */\r\n    modifier isSenderNot(address _address) {\r\n        require(_address != msg.sender, \"Address is the same as the sender\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the address is the sender's address\r\n    */\r\n    modifier isSender(address _address) {\r\n        require(_address == msg.sender, \"Address is different from the sender\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/membership/Whitelist.sol\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The WhitelistCrowdsale was not included in OZ's release at the moment of the \r\n * development of this contract. Therefore, we've developed the Whitelist contract and\r\n * the WhitelistCrowdsale contract.\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract Whitelist is ValidAddress, PausableManager {\r\n    \r\n    bool private _isWhitelisting;\r\n    mapping (address => bool) private _isWhitelisted;\r\n\r\n    event AddedWhitelisted(address indexed account);\r\n    event RemovedWhitelisted(address indexed account);\r\n\r\n    /**\r\n     * @notice Adding account control, only whitelisted accounts could do certain actions.\r\n     * @dev Whitelisting is enabled by default, There is not even the opportunity to \r\n     * disable it.\r\n     */\r\n    constructor() internal {\r\n        _isWhitelisting = true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Add an account to the whitelist, calling the corresponding internal function\r\n     * @param account The address of the investor\r\n     */\r\n    function addWhitelisted(address account) external onlyManager {\r\n        _addWhitelisted(account);\r\n    }\r\n    \r\n    /**\r\n     * @notice This function allows to whitelist investors in batch \r\n     * with control of number of interations\r\n     * @param accounts The accounts to be whitelisted in batch\r\n     */\r\n    // solhint-disable-next-line \r\n    function addWhitelisteds(address[] calldata accounts) external onlyManager {\r\n        uint256 length = accounts.length;\r\n        require(length <= 256, \"too long\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _addWhitelisted(accounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove an account from the whitelist, calling the corresponding internal \r\n     * function\r\n     * @param account The address of the investor that needs to be removed\r\n     */\r\n    function removeWhitelisted(address account) \r\n        external \r\n        onlyManager  \r\n    {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    /**\r\n     * @notice This function allows to whitelist investors in batch \r\n     * with control of number of interations\r\n     * @param accounts The accounts to be whitelisted in batch\r\n     */\r\n    // solhint-disable-next-line \r\n    function removeWhitelisteds(address[] calldata accounts) \r\n        external \r\n        onlyManager  \r\n    {\r\n        uint256 length = accounts.length;\r\n        require(length <= 256, \"too long\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _removeWhitelisted(accounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an account is whitelisted or not\r\n     * @param account The account to be checked\r\n     * @return true if the account is whitelisted. Otherwise, false.\r\n     */\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _isWhitelisted[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add an investor to the whitelist\r\n     * @param account The address of the investor that has successfully passed KYC\r\n     */\r\n    function _addWhitelisted(address account) \r\n        internal\r\n        onlyValidAddress(account)\r\n    {\r\n        require(_isWhitelisted[account] == false, \"account already whitelisted\");\r\n        _isWhitelisted[account] = true;\r\n        emit AddedWhitelisted(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove an investor from the whitelist\r\n     * @param account The address of the investor that needs to be removed\r\n     */\r\n    function _removeWhitelisted(address account) \r\n        internal \r\n        onlyValidAddress(account)\r\n    {\r\n        require(_isWhitelisted[account] == true, \"account was not whitelisted\");\r\n        _isWhitelisted[account] = false;\r\n        emit RemovedWhitelisted(account);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/WhitelistCrowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale with whitelists\r\n * @dev The WhitelistCrowdsale was not included in OZ's release at the moment of the \r\n * development of this contract. Therefore, we've developed the Whitelist contract and\r\n * the WhitelistCrowdsale contract.\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistCrowdsale\r\n * @dev Crowdsale in which only whitelisted users can contribute.\r\n */\r\ncontract WhitelistCrowdsale is Whitelist, Crowdsale {\r\n    /**\r\n    * @notice Extend parent behavior requiring beneficiary to be whitelisted. \r\n    * @dev Note that no restriction is imposed on the account sending the transaction.\r\n    * @param _beneficiary Token beneficiary\r\n    * @param _weiAmount Amount of wei contributed\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) \r\n        internal \r\n        view \r\n    {\r\n        require(isWhitelisted(_beneficiary), \"beneficiary is not whitelisted\");\r\n        super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/NonEthPurchasableCrowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale that allows to be purchased with fiat\r\n * @dev Functionalities in this contract could also be pausable, besides managerOnly\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract NonEthPurchasableCrowdsale is Crowdsale {\r\n    event NonEthTokenPurchased(address indexed beneficiary, uint256 tokenAmount);\r\n\r\n    /**\r\n     * @notice Allows onlyManager to mint token for beneficiary.\r\n     * @param beneficiary Recipient of the token purchase\r\n     * @param tokenAmount Amount of token purchased\r\n     */\r\n    function nonEthPurchase(address beneficiary, uint256 tokenAmount) \r\n        public \r\n    {\r\n        _preValidatePurchase(beneficiary, tokenAmount);\r\n        _processPurchase(beneficiary, tokenAmount);\r\n        emit NonEthTokenPurchased(beneficiary, tokenAmount);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/UpdatableRateCrowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale with updatable exchange rate\r\n * @dev Functionalities in this contract could also be pausable, besides managerOnly\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n// @TODO change the pausable manager to other role or the role to be created ->\r\n// whitelisted admin\r\ncontract UpdatableRateCrowdsale is PausableManager, Crowdsale {\r\n    using SafeMath for uint256;\r\n    \r\n    /*** PRE-DEPLOYMENT CONFIGURED CONSTANTS */\r\n    // 1 IVO = 0.3213 USD\r\n    uint256 private constant TOKEN_PRICE_USD = 3213;\r\n    uint256 private constant TOKEN_PRICE_BASE = 10000;\r\n    uint256 private constant FIAT_RATE_BASE = 100;\r\n\r\n    // This vairable is not goint to override the _rate vairable in OZ's _rate vairable\r\n    // because of the scope/visibility, however, we could override the getter function\r\n    uint256 private _rate;\r\n    // USD to ETH rate, as shown on CoinMarketCap.com\r\n    // _rate = _fiatRate / ((1 - discount) * (TOKEN_PRICE_USD / TOKEN_PRICE_BASE))\r\n    // e.g. If 1 ETH = 110.24 USD, _fiatRate is 11024.\r\n    uint256 private _fiatRate; \r\n\r\n    /**\r\n   * Event for fiat to ETH rate update\r\n   * @param value the fiatrate\r\n   * @param timestamp blocktime of the update\r\n   */\r\n    event UpdatedFiatRate (uint256 value, uint256 timestamp);\r\n\r\n    /**\r\n     * @param initialFiatRate The fiat rate (ETH/USD) when crowdsale starts\r\n     * @dev 2 decimals. e.g. If 1 ETH = 110.24 USD, _fiatRate is 11024.\r\n     */\r\n    constructor (uint256 initialFiatRate) internal {\r\n        require(initialFiatRate > 0, \"fiat rate is not positive\");\r\n        _updateRate(initialFiatRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow manager to update the exchange rate when necessary.\r\n     */\r\n    function updateRate(uint256 newFiatRate) external onlyManager {\r\n        _updateRate(newFiatRate);\r\n    }\r\n\r\n    /** OVERRIDE\r\n    * @return the number of token units a buyer gets per wei.\r\n    */\r\n    function rate() public view returns (uint256) {\r\n        return _rate;\r\n    }\r\n\r\n    /**\r\n     * @return the ETH price (in USD) currently used in the crowdsale\r\n     */\r\n    function fiatRate() public view returns (uint256) {\r\n        return _fiatRate;\r\n    }\r\n\r\n    /**\r\n    * @notice Calculate the amount of token to be sold based on the amount of wei\r\n    * @dev To be overriden to extend the way in which ether is converted to tokens.\r\n    * @param weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\r\n        return weiAmount.mul(_rate);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the exchange rate when the fiat rate is changed\r\n     * @dev Since we round the _rate now into an integer. There is a loss in purchase\r\n     * E.g. When ETH is at 110.24$, one could have 343.106 IVO with 1 ETH of net \r\n     * contribution (after deducting the KYC/AML fee) in mainsale. However, only 343 IVO \r\n     * will be issued, due to the rounding, resulting in a loss of 0.35 $/ETH purchase.\r\n     */\r\n    function _updateRate(uint256 newFiatRate) internal {\r\n        _fiatRate = newFiatRate;\r\n        _rate = _fiatRate.mul(TOKEN_PRICE_BASE).div(TOKEN_PRICE_USD * FIAT_RATE_BASE);\r\n        emit UpdatedFiatRate(_fiatRate, block.timestamp);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/CappedMultiRoundCrowdsale.sol\r\n\r\n/**\r\n * @title Multi-round with cap Crowdsale\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CappedMultiRoundCrowdsale is UpdatableRateCrowdsale {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /*** PRE-DEPLOYMENT CONFIGURED CONSTANTS */\r\n    uint256 private constant ROUNDS = 3;\r\n    uint256 private constant CAP_ROUND_ONE = 22500000 ether;\r\n    uint256 private constant CAP_ROUND_TWO = 37500000 ether;\r\n    uint256 private constant CAP_ROUND_THREE = 52500000 ether;\r\n    uint256 private constant HARD_CAP = 52500000 ether;\r\n    uint256 private constant PRICE_PERCENTAGE_ROUND_ONE = 80;\r\n    uint256 private constant PRICE_PERCENTAGE_ROUND_TWO = 90;\r\n    uint256 private constant PRICE_PERCENTAGE_ROUND_THREE = 100;\r\n    uint256 private constant PRICE_PERCENTAGE_BASE = 100;\r\n\r\n    uint256 private _currentRoundCap;\r\n    uint256 private _mintedByCrowdsale;\r\n    uint256 private _currentRound;\r\n    uint256[ROUNDS] private _capOfRound;\r\n    uint256[ROUNDS] private _pricePercentagePerRound;\r\n    address private privateVaultAddress;\r\n    address private presaleVaultAddress;\r\n    address private reserveVaultAddress;\r\n\r\n    /**\r\n     * Event for multi-round logging\r\n     * @param roundNumber number of the current rounnd, starting from 0\r\n     * @param timestamp blocktime of the start of the next block\r\n     */\r\n    event RoundStarted(uint256 indexed roundNumber, uint256 timestamp);\r\n\r\n    /**\r\n     * Constructor for the capped multi-round crowdsale\r\n     * @param startingTime Time when the first round starts\r\n     */\r\n    /* solhint-disable */\r\n    constructor (uint256 startingTime) internal {\r\n        // update the private variable as the round number and the discount percentage is not changed.\r\n        _pricePercentagePerRound[0] = PRICE_PERCENTAGE_ROUND_ONE;\r\n        _pricePercentagePerRound[1] = PRICE_PERCENTAGE_ROUND_TWO;\r\n        _pricePercentagePerRound[2] = PRICE_PERCENTAGE_ROUND_THREE;\r\n        // update the milestones\r\n        _capOfRound[0] = CAP_ROUND_ONE;\r\n        _capOfRound[1] = CAP_ROUND_TWO;\r\n        _capOfRound[2] = CAP_ROUND_THREE;\r\n        // initiallization\r\n        _currentRound;\r\n        _currentRoundCap = _capOfRound[_currentRound];\r\n        emit RoundStarted(_currentRound, startingTime);\r\n    }\r\n    /* solhint-enable */\r\n    \r\n    /**\r\n    * @notice Modifier to be executed when multi-round is still going on\r\n    */\r\n    modifier stillInRounds() {\r\n        require(_currentRound < ROUNDS, \"Not in rounds\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check vault addresses are correcly settled.\r\n     */\r\n     /* solhint-disable */\r\n    modifier vaultAddressesSet() {\r\n        require(privateVaultAddress != address(0) && presaleVaultAddress != address(0) && reserveVaultAddress != address(0), \"Vaults are not set\");\r\n        _;\r\n    }\r\n    /* solhint-enable */\r\n\r\n    /**\r\n    * @return the cap of the crowdsale.\r\n    */\r\n    function hardCap() public pure returns(uint256) {\r\n        return HARD_CAP;\r\n    }\r\n\r\n    /**\r\n    * @return the cap of the current round of crowdsale.\r\n    */\r\n    function currentRoundCap() public view returns(uint256) {\r\n        return _currentRoundCap;\r\n    }\r\n    \r\n    /**\r\n    * @return the amount of token issued by the crowdsale.\r\n    */\r\n    function mintedByCrowdsale() public view returns(uint256) {\r\n        return _mintedByCrowdsale;\r\n    }\r\n\r\n    /**\r\n    * @return the total round of crowdsales.\r\n    */\r\n    function rounds() public pure returns(uint256) {\r\n        return ROUNDS;\r\n    }\r\n\r\n    /**\r\n    * @return the index of current round.\r\n    */\r\n    function currentRound() public view returns(uint256) {\r\n        return _currentRound;\r\n    }\r\n\r\n    /**\r\n    * @return the cap of one round (relative value)\r\n    */\r\n    function capOfRound(uint256 index) public view returns(uint256) {\r\n        return _capOfRound[index];\r\n    }\r\n\r\n    /**\r\n    * @return the discounted price of the current round\r\n    */\r\n    function pricePercentagePerRound(uint256 index) public view returns(uint256) {\r\n        return _pricePercentagePerRound[index];\r\n    }\r\n    \r\n    /**\r\n    * @notice Checks whether the cap has been reached.\r\n    * @dev These two following functions should not be held because the state should be \r\n    * reverted, if the condition is met, therefore no more tokens that exceeds the cap\r\n    * shall be minted.\r\n    * @return Whether the cap was reached\r\n    */\r\n    function hardCapReached() public view returns (bool) {\r\n        return _mintedByCrowdsale >= HARD_CAP;\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the cap has been reached.\r\n    * @return Whether the cap was reached\r\n    */\r\n    function currentRoundCapReached() public view returns (bool) {\r\n        return _mintedByCrowdsale >= _currentRoundCap;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows manager to manually close the round\r\n     */\r\n    function closeCurrentRound() public onlyManager stillInRounds {\r\n        _capOfRound[_currentRound] = _mintedByCrowdsale;\r\n        _updateRoundCaps(_currentRound);\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring the crowdsale is in a valid round\r\n    * @param beneficiary Token purchaser\r\n    * @param weiAmount Amount of wei contributed\r\n    */\r\n    function _preValidatePurchase(\r\n        address beneficiary,\r\n        uint256 weiAmount\r\n    )\r\n        internal\r\n        view\r\n        stillInRounds\r\n    {\r\n        super._preValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n\r\n    /**\r\n    * @notice Extend parent behavior requiring purchase to respect the max \r\n    * token cap for crowdsale.\r\n    * @dev If the transaction is about to exceed the hardcap, the crowdsale contract\r\n    * will revert the entire transaction, because the contract will not refund any part\r\n    * of msg.value\r\n    * @param beneficiary Token purchaser\r\n    * @param tokenAmount Amount of tokens purchased\r\n    */\r\n    function _processPurchase(\r\n        address beneficiary,\r\n        uint256 tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        // Check if the hard cap (in IVO) is reached\r\n        // This requirement is actually controlled when calculating the tokenAmount\r\n        // inside _dealWithBigTokenPurchase(). So comment the following ou at the moment\r\n        // require(_mintedByCrowdsale.add(tokenAmount) <= HARD_CAP, \"Too many tokens that exceeds the cap\");\r\n        // After calculating the generated amount, now update the current round.\r\n        // The following block is to process a purchase with amouts that exceeds the current cap.\r\n        uint256 finalAmount = _mintedByCrowdsale.add(tokenAmount);\r\n        uint256 totalMintedAmount = _mintedByCrowdsale;\r\n\r\n        for (uint256 i = _currentRound; i < ROUNDS; i = i.add(1)) {\r\n            if (finalAmount > _capOfRound[i]) {\r\n                sendToCorrectAddress(beneficiary, _capOfRound[i].sub(totalMintedAmount), _currentRound);\r\n                // the rest needs to be dealt in the next round.\r\n                totalMintedAmount = _capOfRound[i];\r\n                _updateRoundCaps(_currentRound);\r\n            } else {\r\n                _mintedByCrowdsale = finalAmount;\r\n                sendToCorrectAddress(beneficiary, finalAmount.sub(totalMintedAmount), _currentRound);\r\n                if (finalAmount == _capOfRound[i]) {\r\n                    _updateRoundCaps(_currentRound);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Override to extend the way in which ether is converted to tokens.\r\n    * It tokens \"discount\" into consideration as well as multi-rounds.\r\n    * @param weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 weiAmount)\r\n        internal view returns (uint256)\r\n    {\r\n        // Here we need to check if all tokens are sold in the same round.\r\n        uint256 tokenAmountBeforeDiscount = super._getTokenAmount(weiAmount);\r\n        uint256 tokenAmountForThisRound;\r\n        uint256 tokenAmountForNextRound;\r\n        uint256 tokenAmount;\r\n        for (uint256 round = _currentRound; round < ROUNDS; round = round.add(1)) {\r\n            (tokenAmountForThisRound, tokenAmountForNextRound) = \r\n            _dealWithBigTokenPurchase(tokenAmountBeforeDiscount, round);\r\n            tokenAmount = tokenAmount.add(tokenAmountForThisRound);\r\n            if (tokenAmountForNextRound == 0) {\r\n                break;\r\n            } else {\r\n                tokenAmountBeforeDiscount = tokenAmountForNextRound;\r\n            }\r\n        }\r\n        // After three rounds of calculation, there should be no more token to be \r\n        // purchased in the \"next\" round. Otherwise, it reaches the hardcap.\r\n        require(tokenAmountForNextRound == 0, \"there is still tokens for the next round...\");\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set up addresses for vaults. Should only be called once during.\r\n     * @param privateVault The vault address for private sale\r\n     * @param presaleVault The vault address for presale.\r\n     * @param reserveVault The vault address for reserve.\r\n     */\r\n    function _setVaults(\r\n        IVault privateVault,\r\n        IVault presaleVault,\r\n        IVault reserveVault\r\n    )\r\n        internal\r\n    {\r\n        require(address(privateVault) != address(0), \"Not valid address: privateVault\");\r\n        require(address(presaleVault) != address(0), \"Not valid address: presaleVault\");\r\n        require(address(reserveVault) != address(0), \"Not valid address: reserveVault\");\r\n        privateVaultAddress = address(privateVault);\r\n        presaleVaultAddress = address(presaleVault);\r\n        reserveVaultAddress = address(reserveVault);\r\n    }\r\n\r\n    /**\r\n     * @dev When a big token purchase happens, it automatically jumps to the next round if\r\n     * the cap of the current round reaches. \r\n     * @param tokenAmount The amount of tokens that is converted from wei according to the\r\n     * updatable fiat rate. This amount has not yet taken the discount rate into account.\r\n     * @return The amount of token sold in this round\r\n     * @return The amount of token ready to be sold in the next round.\r\n     */\r\n    function _dealWithBigTokenPurchase(uint256 tokenAmount, uint256 round) \r\n        private\r\n        view \r\n        stillInRounds \r\n        returns (uint256, uint256) \r\n    {\r\n        // Get the maximum \"tokenAmount\" that can be issued in the current around with the\r\n        // corresponding discount.\r\n        // maxAmount = (absolut cap of the current round - already issued) * discount\r\n        uint256 maxTokenAmountOfCurrentRound = (_capOfRound[round]\r\n                                                .sub(_mintedByCrowdsale))\r\n                                                .mul(_pricePercentagePerRound[round])\r\n                                                .div(PRICE_PERCENTAGE_BASE);\r\n        if (tokenAmount < maxTokenAmountOfCurrentRound) {\r\n            // this purchase will be settled entirely in the current round\r\n            return (tokenAmount.mul(PRICE_PERCENTAGE_BASE).div(_pricePercentagePerRound[round]), 0);\r\n        } else {\r\n            // need to consider cascading to the next round\r\n            uint256 tokenAmountOfNextRound = tokenAmount.sub(maxTokenAmountOfCurrentRound);\r\n            return (maxTokenAmountOfCurrentRound, tokenAmountOfNextRound);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev this function delivers token according to the information of the current round...\r\n     * @param beneficiary The address of the account that should receive tokens in reality\r\n     * @param tokenAmountToBeSent The amount of token sent to the destination addression.\r\n     * @param roundNumber Round number where tokens shall be purchased...\r\n     */\r\n    function sendToCorrectAddress(\r\n        address beneficiary, \r\n        uint256 tokenAmountToBeSent,\r\n        uint256 roundNumber\r\n    )\r\n        private \r\n        vaultAddressesSet\r\n    {\r\n        if (roundNumber == 2) {\r\n            // then tokens could be minted directly to holder's account\r\n            // the amount shall be the \r\n            super._processPurchase(beneficiary, tokenAmountToBeSent);\r\n        } else if (roundNumber == 0) {\r\n            // tokens should be minted to the private sale vault...\r\n            super._processPurchase(privateVaultAddress, tokenAmountToBeSent);\r\n            // update the balance of the corresponding vault\r\n            IVault(privateVaultAddress).receiveFor(beneficiary, tokenAmountToBeSent);\r\n        } else {\r\n            // _currentRound == 1, tokens should be minted to the presale vault\r\n            super._processPurchase(presaleVaultAddress, tokenAmountToBeSent);\r\n            // update the balance of the corresponding vault\r\n            IVault(presaleVaultAddress).receiveFor(beneficiary, tokenAmountToBeSent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Eachtime, when a manager closes a round or a round_cap is reached, it needs\r\n     * to update the info of the _currentRound, _currentRoundCap, _hardCap and _capPerRound[];\r\n     * @param round currentRound number\r\n     * @dev This function should only be triggered when there is a need of updating all\r\n     * the params. The capPerRound shall be updated with the current mintedValue.\r\n     */\r\n    function _updateRoundCaps(uint256 round) private {\r\n        if (round == 0) {\r\n            // update the releasing time of private sale vault\r\n            IVault(privateVaultAddress).updateReleaseTime(block.timestamp);\r\n            _currentRound = 1;\r\n            _currentRoundCap = _capOfRound[1];\r\n        } else if (round == 1) {\r\n            // update the releasing time of presale vault\r\n            IVault(presaleVaultAddress).updateReleaseTime(block.timestamp);\r\n            _currentRound = 2;\r\n            _currentRoundCap = _capOfRound[2];\r\n        } else {\r\n            // when _currentRound == 2\r\n            IVault(reserveVaultAddress).updateReleaseTime(block.timestamp);\r\n            // finalize the crowdsale\r\n            _currentRound = 3;\r\n            _currentRoundCap = _capOfRound[2];\r\n        }\r\n        emit RoundStarted(_currentRound, block.timestamp);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/PausableCrowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale with check on pausible\r\n * @dev Functionalities in this contract could also be pausable, besides managerOnly\r\n * This contract is similar to OpenZeppelin's PausableCrowdsale, yet with different \r\n * contract inherited\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract PausableCrowdsale is PausableManager, Crowdsale {\r\n\r\n    /**\r\n     * @notice Validation of an incoming purchase.\r\n     * @dev Use require statements to revert state when conditions are not met. Adding\r\n     * the validation that the crowdsale must not be paused.\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(\r\n        address _beneficiary, \r\n        uint256 _weiAmount\r\n    )\r\n        internal \r\n        view \r\n        whenNotPaused \r\n    {\r\n        return super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/crowdsale/StartingTimedCrowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale with a limited opening time\r\n * @dev This contract is developed based on OpenZeppelin's TimedCrowdsale contract \r\n * but removing the endTime. As the function `hasEnded()` is public accessible and \r\n * necessary to return true when the crowdsale is ready to be finalized, yet no direct\r\n * link exists between the time and the end, here we take OZ's originalCrowdsale contract\r\n * and tweak according to the need.\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract StartingTimedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private _startingTime;\r\n\r\n    /**\r\n    * @notice Reverts if not in crowdsale time range.\r\n    */\r\n    modifier onlyWhileOpen {\r\n        require(isStarted(), \"Not yet started\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Constructor, takes crowdsale opening and closing times.\r\n    * @param startingTime Crowdsale opening time\r\n    */\r\n    constructor(uint256 startingTime) internal {\r\n        // solium-disable-next-line security/no-block-members\r\n        require(startingTime >= block.timestamp, \"Starting time is in the past\");\r\n\r\n        _startingTime = startingTime;\r\n    }\r\n\r\n    /**\r\n    * @return the crowdsale opening time.\r\n    */\r\n    function startingTime() public view returns(uint256) {\r\n        return _startingTime;\r\n    }\r\n\r\n    /**\r\n    * @return true if the crowdsale is open, false otherwise.\r\n    */\r\n    function isStarted() public view returns (bool) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp >= _startingTime;\r\n    }\r\n\r\n    /**\r\n    * @notice Extend parent behavior requiring to be within contributing period\r\n    * @param beneficiary Token purchaser\r\n    * @param weiAmount Amount of wei contributed\r\n    */\r\n    function _preValidatePurchase(\r\n        address beneficiary,\r\n        uint256 weiAmount\r\n    )\r\n        internal\r\n        onlyWhileOpen\r\n        view\r\n    {\r\n        super._preValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/FinalizableCrowdsale.sol\r\n\r\n/**\r\n * @title Finalizable crowdsale\r\n * @dev This contract is developed based on OpenZeppelin's FinalizableCrowdsale contract \r\n * with a different inherited contract. \r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @notice Extension of Crowdsale with a one-off finalization action, where one\r\n * can do extra work after finishing.\r\n * @dev Slightly different from OZ;s contract, due to the inherited \"TimedCrowdsale\" \r\n * contract\r\n */\r\ncontract FinalizableCrowdsale is StartingTimedCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    bool private _finalized;\r\n\r\n    event CrowdsaleFinalized(address indexed account);\r\n\r\n    constructor () internal {\r\n        _finalized = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the crowdsale is finalized, false otherwise.\r\n     */\r\n    function finalized() public view returns (bool) {\r\n        return _finalized;\r\n    }\r\n\r\n    /**\r\n     * @notice Must be called after crowdsale ends, to do some extra finalization\r\n     * work. Calls the contract's finalization function.\r\n     * @dev The requirement of endingTimeis removed\r\n     */\r\n    function finalize() public {\r\n        require(!_finalized, \"already finalized\");\r\n\r\n        _finalized = true;\r\n\r\n        emit CrowdsaleFinalized(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\r\n * which have permission to mint (create) new tokens as they see fit.\r\n *\r\n * At construction, the deployer of the contract is the only minter.\r\n */\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n    /**\r\n     * @dev See `ERC20._mint`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the `MinterRole`.\r\n     */\r\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title MintedCrowdsale\r\n * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.\r\n * Token ownership should be transferred to MintedCrowdsale for minting.\r\n */\r\ncontract MintedCrowdsale is Crowdsale {\r\n    /**\r\n     * @dev Overrides delivery by minting tokens upon purchase.\r\n     * @param beneficiary Token purchaser\r\n     * @param tokenAmount Number of tokens to be minted\r\n     */\r\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\r\n        // Potentially dangerous assumption about the type of the token.\r\n        require(\r\n            ERC20Mintable(address(token())).mint(beneficiary, tokenAmount),\r\n                \"MintedCrowdsale: minting failed\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/IvoCrowdsale.sol\r\n\r\n/**\r\n * @title INVAO Crowdsale\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_5\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IvoCrowdsale is IIvoCrowdsale, CounterGuard, Reclaimable, MintedCrowdsale, \r\n    NonEthPurchasableCrowdsale, CappedMultiRoundCrowdsale, WhitelistCrowdsale, \r\n    PausableCrowdsale, FinalizableCrowdsale {\r\n    /*** PRE-DEPLOYMENT CONFIGURED CONSTANTS */\r\n    uint256 private constant ROUNDS = 3;\r\n    uint256 private constant KYC_AML_RATE_DEDUCTED = 965;\r\n    uint256 private constant KYC_AML_FEE_BASE = 1000;\r\n    bool private _setRole;\r\n\r\n    /**\r\n     * @param startingTime The starting time of the crowdsale\r\n     * @param rate Token per wei. This rate is going to be overriden, hence not important.\r\n     * @param initialFiatRate USD per ETH. (As the number on CoinMarketCap.com)\r\n     * Value written in cent.\r\n     * @param wallet The address of the team which receives investors ETH payment.\r\n     * @param token The address of the token.\r\n     */\r\n    /* solhint-disable */\r\n    constructor(\r\n        uint256 startingTime,\r\n        uint256 rate,\r\n        uint256 initialFiatRate,\r\n        address payable wallet, \r\n        IERC20 token\r\n    ) \r\n        public\r\n        Crowdsale(rate, wallet, token)\r\n        UpdatableRateCrowdsale(initialFiatRate)\r\n        CappedMultiRoundCrowdsale(startingTime)\r\n        StartingTimedCrowdsale(startingTime) {}\r\n    /* solhint-enable */\r\n    \r\n    /**\r\n     * @notice Batch minting tokens for investors paid with non-ETH\r\n     * @param beneficiaries Recipients of the token purchase\r\n     * @param amounts Amounts of token purchased\r\n     */\r\n    function nonEthPurchases(\r\n        address[] calldata beneficiaries, \r\n        uint256[] calldata amounts\r\n    ) \r\n        external\r\n        onlyManager \r\n    {\r\n        uint256 length = amounts.length;\r\n        require(beneficiaries.length == length, \"length !=\");\r\n        require(length <= 256, \"To long, please consider shorten the array\");\r\n        for (uint256 i = 0; i < length; i++) {\r\n            super.nonEthPurchase(beneficiaries[i], amounts[i]);\r\n        }\r\n    }\r\n    \r\n    /** OVERRIDE\r\n     * @notice Allows onlyManager to mint token for beneficiaries.\r\n     * @param beneficiary Recipient of the token purchase\r\n     * @param tokenAmount Amount of token purchased\r\n     */\r\n    function nonEthPurchase(address beneficiary, uint256 tokenAmount) \r\n        public \r\n        onlyManager \r\n    {\r\n        super.nonEthPurchase(beneficiary, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows manager to manually close the round\r\n     */\r\n    function closeCurrentRound() public onlyWhileOpen {\r\n        super.closeCurrentRound();\r\n    }\r\n\r\n    /**\r\n     * @notice setup roles and contract addresses for the crowdsale contract\r\n     * @dev This function can only be called once by the owner.\r\n     * @param newOwner The address of the new owner/manager.\r\n     * @param privateVault The address of private sale vault\r\n     * @param presaleVault The address of presale vault.\r\n     * @param reserveVault The address of reverve vault.\r\n     */\r\n    function roleSetup(\r\n        address newOwner,\r\n        IVault privateVault,\r\n        IVault presaleVault,\r\n        IVault reserveVault\r\n    )\r\n        public\r\n        onlyOwner\r\n        onlyOnce(_setRole)\r\n    {\r\n        _setVaults(privateVault, presaleVault, reserveVault);\r\n        addManager(newOwner);\r\n        _removeManager(msg.sender);\r\n        transferOwnership(newOwner);\r\n        _setRole = true;\r\n    }\r\n\r\n     /** OVERRIDE\r\n     * @notice Specify the actions in the finalization of the crowdsale. \r\n     * Add the manager as a token minter and renounce itself the minter role\r\n     * role of the token contract. \r\n     */\r\n    function finalize() public onlyManager {\r\n        require(this.currentRound() == ROUNDS, \"Multi-rounds has not yet completed\");\r\n        super.finalize();\r\n        PausableManager(address(token())).unpause();\r\n        ERC20Mintable(address(token())).addMinter(msg.sender);\r\n        ERC20Mintable(address(token())).renounceMinter();\r\n    }\r\n\r\n    /*** INTERNAL/PRIVATE ***/    \r\n    /** OVERRIDE\r\n    * @notice Calculate the usable wei after taking out the KYC/AML fee, i.e. 96.5 %\r\n    * @dev Override to extend the way in which ether is converted to tokens.\r\n    * @param weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased after deducting the AML/KYC fee.\r\n    */\r\n    function _getTokenAmount(uint256 weiAmount)\r\n        internal\r\n        view \r\n        returns (uint256)\r\n    {\r\n        uint256 availableWei = weiAmount.mul(KYC_AML_RATE_DEDUCTED).div(KYC_AML_FEE_BASE);\r\n        return super._getTokenAmount(availableWei);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"nonEthPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fiatRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenToBeRecovered\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"contract IVault\",\"name\":\"privateVault\",\"type\":\"address\"},{\"internalType\":\"contract IVault\",\"name\":\"presaleVault\",\"type\":\"address\"},{\"internalType\":\"contract IVault\",\"name\":\"reserveVault\",\"type\":\"address\"}],\"name\":\"roleSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundCapReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeWhitelisteds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addWhitelisteds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numManager\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"nonEthPurchases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pricePercentagePerRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"capOfRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFiatRate\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addManagers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCurrentRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintedByCrowdsale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialFiatRate\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"CrowdsaleFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatedFiatRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"NonEthTokenPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"BePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"BeUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IvoCrowdsale","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005d8e07d0000000000000000000000000000000000000000000000000000000000000020500000000000000000000000000000000000000000000000000000000000040ef00000000000000000000000007e4420484a7a0e35d524a6bd122b11287c3a98d000000000000000000000000e03df9fda489a405f5db8a919adbc9a1b931a19f","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://8d3362b9ceed40fb0e11cd37980ca5eb8cb5bb12a42b5766a402ecef86ccfe2e"}]}