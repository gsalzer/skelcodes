{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Interface.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\n// https://github.com/ethereum/EIPs/issues/20\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function decimals() external view returns(uint digits);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"PermissionGroups.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ncontract PermissionGroups {\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    mapping(address=\\u003ebool) internal operators;\\n    mapping(address=\\u003ebool) internal alerters;\\n    address[] internal operatorsGroup;\\n    address[] internal alertersGroup;\\n    uint constant internal MAX_GROUP_SIZE = 50;\\n\\n    constructor(address _admin) public {\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin);\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender]);\\n        _;\\n    }\\n\\n    modifier onlyAlerter() {\\n        require(alerters[msg.sender]);\\n        _;\\n    }\\n\\n    function getOperators () external view returns(address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function getAlerters () external view returns(address[] memory) {\\n        return alertersGroup;\\n    }\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(pendingAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    event AdminClaimed( address newAdmin, address previousAdmin);\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender);\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    event AlerterAdded (address newAlerter, bool isAdd);\\n\\n    function addAlerter(address newAlerter) public onlyAdmin {\\n        require(!alerters[newAlerter]); // prevent duplicates.\\n        require(alertersGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit AlerterAdded(newAlerter, true);\\n        alerters[newAlerter] = true;\\n        alertersGroup.push(newAlerter);\\n    }\\n\\n    function removeAlerter (address alerter) public onlyAdmin {\\n        require(alerters[alerter]);\\n        alerters[alerter] = false;\\n\\n        for (uint i = 0; i \\u003c alertersGroup.length; ++i) {\\n            if (alertersGroup[i] == alerter) {\\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\\n                alertersGroup.length--;\\n                emit AlerterAdded(alerter, false);\\n                break;\\n            }\\n        }\\n    }\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator]); // prevent duplicates.\\n        require(operatorsGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator (address operator) public onlyAdmin {\\n        require(operators[operator]);\\n        operators[operator] = false;\\n\\n        for (uint i = 0; i \\u003c operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.length -= 1;\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"},\"PTConversionRates.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./ERC20Interface.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./PermissionGroups.sol\\\";\\n\\n\\ninterface KyberProxy {\\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\\n        external view\\n        returns(uint expectedRate, uint slippageRate);\\n}\\n\\n\\ninterface MedianizerInterface {\\n    function peek() external view returns (bytes32, bool);\\n}\\n\\n\\n/*\\nPT = Promotion Token, used by KyberSwap for promotional purposes\\n1 PT token should convert to slightly more than 1 DAI.\\n*/\\ncontract PTToDaiConversionRate is Utils, PermissionGroups {\\n    KyberProxy public kyberProxy = KyberProxy(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\\n    MedianizerInterface public medianizer = MedianizerInterface(0x729D19f657BD0614b4985Cf1D82531c67569197B);\\n    ERC20 public constant ETH_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    ERC20 public daiAddress = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\\n    uint public constant MAX_REASONABLE_BPS = 200; //2%\\n\\n    constructor(address _admin) public PermissionGroups (_admin) {}\\n\\n    function setKyberContract(KyberProxy _kyberProxy) public onlyAdmin {\\n        require(address(_kyberProxy) != address(0), \\\"kyberProxy address is null\\\");\\n        kyberProxy = _kyberProxy;\\n    }\\n\\n    function setMedianizer(MedianizerInterface _medianizer) public onlyAdmin {\\n        require(address(_medianizer) != address(0), \\\"medianizer address is null\\\");\\n        medianizer = _medianizer;\\n    }\\n\\n    function setDAIAddress(ERC20 _daiAddress) public onlyAdmin {\\n        require(address(_daiAddress) != address(0), \\\"dai token address is null\\\");\\n        daiAddress = _daiAddress;\\n    }\\n\\n    function recordImbalance(\\n        ERC20 token,\\n        int buyAmount,\\n        uint rateUpdateBlock,\\n        uint currentBlock\\n    )\\n        public\\n    {\\n      //do nothing\\n    }\\n\\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\\n        if(address(token) != address(daiAddress)) return 0;\\n        if(buy) return 0;\\n\\n        uint buyRate;\\n        uint sellRate;\\n        uint rateDiffInBps;\\n        uint querySrcAmount = (10**17 * qty) / 10**18; //qty of 0.X ETH -\\u003e for X PT tokens (in precision)\\n\\n        (buyRate,) = kyberProxy.getExpectedRate(\\n            ETH_ADDRESS,\\n            daiAddress,\\n            querySrcAmount\\n            );\\n\\n        uint queryDestAmount = calcDstQty(querySrcAmount, 18, 18, buyRate);\\n        (sellRate, ) = kyberProxy.getExpectedRate(\\n            daiAddress,\\n            ETH_ADDRESS,\\n            queryDestAmount\\n            );\\n\\n        //check no arbitrage\\n        require((buyRate * sellRate) \\u003c= (PRECISION ** 2), \\\"internal arbitrage is present\\\");\\n\\n        //fetch value from Maker\\u0027s Medianizer\\n        (bytes32 usdPerEthInWei, bool valid) = medianizer.peek();\\n        require(valid, \\\"medianizer rate not valid\\\");\\n\\n        uint usdPerEthInPrecision = uint(usdPerEthInWei);\\n\\n        //compare rates, that they are within reasonable spread\\n        if (usdPerEthInPrecision \\u003e= buyRate) {\\n            rateDiffInBps = (usdPerEthInPrecision - buyRate) * 10000 / usdPerEthInPrecision;\\n        } else {\\n            rateDiffInBps = (buyRate - usdPerEthInPrecision) * 10000 / buyRate;\\n        }\\n        require(rateDiffInBps \\u003c= MAX_REASONABLE_BPS, \\\"medianizer and kyber rates differ greatly\\\");\\n\\n        /*\\n        buyRate = ETH -\\u003e DAI rate. We want to return a rate such that 1 PT token ~= 1.005 DAI\\n        Hence, sellRate = 1/buyRate * 1.005\\n        */\\n        return 1005 * (PRECISION * PRECISION / buyRate) / 1000;\\n    }\\n}\\n\"},\"Utils.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\nimport \\\"./ERC20Interface.sol\\\";\\n\\n\\n/// @title Kyber constants contract\\ncontract Utils {\\n\\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\\n    uint  constant internal PRECISION = (10**18);\\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\\n    uint  constant internal MAX_DECIMALS = 18;\\n    uint  constant internal ETH_DECIMALS = 18;\\n    mapping(address=\\u003euint) internal decimals;\\n\\n    function setDecimals(ERC20 token) internal {\\n        if (token == ETH_TOKEN_ADDRESS) decimals[address(token)] = ETH_DECIMALS;\\n        else decimals[address(token)] = token.decimals();\\n    }\\n\\n    function getDecimals(ERC20 token) internal view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\\n        uint tokenDecimals = decimals[address(token)];\\n        // technically, there might be token with decimals 0\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        if(tokenDecimals == 0) return token.decimals();\\n\\n        return tokenDecimals;\\n    }\\n\\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(srcQty \\u003c= MAX_QTY);\\n        require(rate \\u003c= MAX_RATE);\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\\n        }\\n    }\\n\\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(dstQty \\u003c= MAX_QTY);\\n        require(rate \\u003c= MAX_RATE);\\n\\n        //source quantity is rounded up. to avoid dest quantity being too low.\\n        uint numerator;\\n        uint denominator;\\n        if (srcDecimals \\u003e= dstDecimals) {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\\n            denominator = rate;\\n        } else {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            numerator = (PRECISION * dstQty);\\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\\n        }\\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"medianizer\",\"outputs\":[{\"internalType\":\"contract MedianizerInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_daiAddress\",\"type\":\"address\"}],\"name\":\"setDAIAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiAddress\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract KyberProxy\",\"name\":\"_kyberProxy\",\"type\":\"address\"}],\"name\":\"setKyberContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REASONABLE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"buyAmount\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"rateUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBlock\",\"type\":\"uint256\"}],\"name\":\"recordImbalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract MedianizerInterface\",\"name\":\"_medianizer\",\"type\":\"address\"}],\"name\":\"setMedianizer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberProxy\",\"outputs\":[{\"internalType\":\"contract KyberProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"PTToDaiConversionRate","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000010534d4e612071e6b6480c498dd8bdb8f51b9ed7","Library":"","LicenseType":"None","SwarmSource":"bzzr://2fbf2a09eb6540c234af994aac6d11ec940973f4c242a1ec7957c1ea4b4bd16d"}]}