{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ScdMcdMigrationLike {\r\n    function daiJoin() public view returns (JoinLike);\r\n    function wethJoin() public view returns (JoinLike);\r\n    function tub() public view returns (SaiTubLike);\r\n    function migrate(bytes32) public returns (uint);\r\n    function swapSaiToDai(uint) public;\r\n    function swapDaiToSai(uint) public;\r\n}\r\n\r\ncontract GemLike {\r\n    function allowance(address, address) public returns (uint);\r\n    function approve(address, uint) public;\r\n    function transfer(address, uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n}\r\n\r\ncontract ValueLike {\r\n    function peek() public returns (uint, bool);\r\n}\r\n\r\ncontract SaiTubLike {\r\n    function skr() public view returns (GemLike);\r\n    function gem() public view returns (GemLike);\r\n    function gov() public view returns (GemLike);\r\n    function sai() public view returns (GemLike);\r\n    function pep() public view returns (ValueLike);\r\n    function vox() public view returns (VoxLike);\r\n    function bid(uint) public view returns (uint);\r\n    function ink(bytes32) public view returns (uint);\r\n    function tag() public view returns (uint);\r\n    function tab(bytes32) public returns (uint);\r\n    function rap(bytes32) public returns (uint);\r\n    function draw(bytes32, uint) public;\r\n    function shut(bytes32) public;\r\n    function exit(uint) public;\r\n    function give(bytes32, address) public;\r\n}\r\n\r\ncontract VoxLike {\r\n    function par() public returns (uint);\r\n}\r\n\r\ncontract JoinLike {\r\n    function ilk() public returns (bytes32);\r\n    function gem() public returns (GemLike);\r\n    function dai() public returns (GemLike);\r\n    function join(address, uint) public;\r\n    function exit(address, uint) public;\r\n}\r\n\r\ncontract JugLike {\r\n    function drip(bytes32) public;\r\n}\r\n\r\ncontract OtcLike {\r\n    function getPayAmount(address, address, uint) public view returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public;\r\n}\r\n\r\n// This contract is intended to be executed via the Profile proxy of a user (DSProxy) which owns the SCD CDP\r\ncontract MigrationProxyActions is DSMath {\r\n    function swapSaiToDai(\r\n        address scdMcdMigration,            // Migration contract address\r\n        uint wad                            // Amount to swap\r\n    ) external {\r\n        GemLike sai = ScdMcdMigrationLike(scdMcdMigration).tub().sai();\r\n        GemLike dai = ScdMcdMigrationLike(scdMcdMigration).daiJoin().dai();\r\n        sai.transferFrom(msg.sender, address(this), wad);\r\n        if (sai.allowance(address(this), scdMcdMigration) < wad) {\r\n            sai.approve(scdMcdMigration, wad);\r\n        }\r\n        ScdMcdMigrationLike(scdMcdMigration).swapSaiToDai(wad);\r\n        dai.transfer(msg.sender, wad);\r\n    }\r\n\r\n    function swapDaiToSai(\r\n        address scdMcdMigration,            // Migration contract address\r\n        uint wad                            // Amount to swap\r\n    ) external {\r\n        GemLike sai = ScdMcdMigrationLike(scdMcdMigration).tub().sai();\r\n        GemLike dai = ScdMcdMigrationLike(scdMcdMigration).daiJoin().dai();\r\n        dai.transferFrom(msg.sender, address(this), wad);\r\n        if (dai.allowance(address(this), scdMcdMigration) < wad) {\r\n            dai.approve(scdMcdMigration, wad);\r\n        }\r\n        ScdMcdMigrationLike(scdMcdMigration).swapDaiToSai(wad);\r\n        sai.transfer(msg.sender, wad);\r\n    }\r\n\r\n    function migrate(\r\n        address scdMcdMigration,            // Migration contract address\r\n        address jug,                        // Jug address to update fee status\r\n        bytes32 cup                         // SCD CDP Id to migrate\r\n    ) external returns (uint cdp) {\r\n        SaiTubLike tub = ScdMcdMigrationLike(scdMcdMigration).tub();\r\n        // Get necessary MKR fee and move it to the migration contract\r\n        (uint val, bool ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            // Calculate necessary value of MKR to pay the govFee\r\n            uint govFee = wdiv(tub.rap(cup), val);\r\n\r\n            // Get MKR from the user's wallet and transfer to Migration contract\r\n            tub.gov().transferFrom(msg.sender, address(scdMcdMigration), govFee);\r\n        }\r\n        // Transfer ownership of SCD CDP to the migration contract\r\n        tub.give(cup, address(scdMcdMigration));\r\n        // Update stability fee rate\r\n        JugLike(jug).drip(ScdMcdMigrationLike(scdMcdMigration).wethJoin().ilk());\r\n        // Execute migrate function\r\n        cdp = ScdMcdMigrationLike(scdMcdMigration).migrate(cup);\r\n    }\r\n\r\n    function migratePayFeeWithGem(\r\n        address scdMcdMigration,            // Migration contract address\r\n        address jug,                        // Jug address to update fee status\r\n        bytes32 cup,                        // SCD CDP Id to migrate\r\n        address otc,                        // Otc address\r\n        address payGem,                     // Token address to be used for purchasing govFee MKR\r\n        uint maxPayAmt                      // Max amount of payGem to sell for govFee MKR needed\r\n    ) external returns (uint cdp) {\r\n        SaiTubLike tub = ScdMcdMigrationLike(scdMcdMigration).tub();\r\n        // Get necessary MKR fee and move it to the migration contract\r\n        (uint val, bool ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            // Calculate necessary value of MKR to pay the govFee\r\n            uint govFee = wdiv(tub.rap(cup), val);\r\n\r\n            // Calculate how much payGem is needed for getting govFee value\r\n            uint payAmt = OtcLike(otc).getPayAmount(payGem, address(tub.gov()), govFee);\r\n            // Fails if exceeds maximum\r\n            require(maxPayAmt >= payAmt, \"maxPayAmt-exceeded\");\r\n            // Set allowance, if necessary\r\n            if (GemLike(payGem).allowance(address(this), otc) < payAmt) {\r\n                GemLike(payGem).approve(otc, payAmt);\r\n            }\r\n            // Get payAmt of payGem from user's wallet\r\n            require(GemLike(payGem).transferFrom(msg.sender, address(this), payAmt), \"transfer-failed\");\r\n            // Trade it for govFee amount of MKR\r\n            OtcLike(otc).buyAllAmount(address(tub.gov()), govFee, payGem, payAmt);\r\n            // Transfer govFee amount of MKR to Migration contract\r\n            tub.gov().transfer(address(scdMcdMigration), govFee);\r\n        }\r\n        // Transfer ownership of SCD CDP to the migration contract\r\n        tub.give(cup, address(scdMcdMigration));\r\n        // Update stability fee rate\r\n        JugLike(jug).drip(ScdMcdMigrationLike(scdMcdMigration).wethJoin().ilk());\r\n        // Execute migrate function\r\n        cdp = ScdMcdMigrationLike(scdMcdMigration).migrate(cup);\r\n    }\r\n\r\n    function _getRatio(\r\n        SaiTubLike tub,\r\n        bytes32 cup\r\n    ) internal returns (uint ratio) {\r\n        ratio = rdiv(\r\n                        rmul(tub.tag(), tub.ink(cup)),\r\n                        rmul(tub.vox().par(), tub.tab(cup))\r\n                    );\r\n    }\r\n\r\n    function migratePayFeeWithDebt(\r\n        address scdMcdMigration,            // Migration contract address\r\n        address jug,                        // Jug address to update fee status\r\n        bytes32 cup,                        // SCD CDP Id to migrate\r\n        address otc,                        // Otc address\r\n        uint maxPayAmt,                     // Max amount of SAI to generate to sell for govFee MKR needed\r\n        uint minRatio                       // Min collateralization ratio after generating new debt (e.g. 180% = 1.8 RAY)\r\n    ) external returns (uint cdp) {\r\n        SaiTubLike tub = ScdMcdMigrationLike(scdMcdMigration).tub();\r\n        // Get necessary MKR fee and move it to the migration contract\r\n        (uint val, bool ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            // Calculate necessary value of MKR to pay the govFee\r\n            uint govFee = wdiv(tub.rap(cup), val) + 1; // 1 extra wei MKR to avoid any possible rounding issue after drawing new SAI\r\n\r\n            // Calculate how much SAI is needed for getting govFee value\r\n            uint payAmt = OtcLike(otc).getPayAmount(address(tub.sai()), address(tub.gov()), govFee);\r\n            // Fails if exceeds maximum\r\n            require(maxPayAmt >= payAmt, \"maxPayAmt-exceeded\");\r\n            // Get payAmt of SAI from user's CDP\r\n            tub.draw(cup, payAmt);\r\n\r\n            require(_getRatio(tub, cup) > minRatio, \"minRatio-failed\");\r\n\r\n            // Set allowance, if necessary\r\n            if (GemLike(address(tub.sai())).allowance(address(this), otc) < payAmt) {\r\n                GemLike(address(tub.sai())).approve(otc, payAmt);\r\n            }\r\n            // Trade it for govFee amount of MKR\r\n            OtcLike(otc).buyAllAmount(address(tub.gov()), govFee, address(tub.sai()), payAmt);\r\n            // Transfer real needed govFee amount of MKR to Migration contract (it might leave some MKR dust in the proxy contract)\r\n            govFee = wdiv(tub.rap(cup), val);\r\n            tub.gov().transfer(address(scdMcdMigration), govFee);\r\n        }\r\n        // Transfer ownership of SCD CDP to the migration contract\r\n        tub.give(cup, address(scdMcdMigration));\r\n        // Update stability fee rate\r\n        JugLike(jug).drip(ScdMcdMigrationLike(scdMcdMigration).wethJoin().ilk());\r\n        // Execute migrate function\r\n        cdp = ScdMcdMigrationLike(scdMcdMigration).migrate(cup);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cup\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"otc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPayAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatio\",\"type\":\"uint256\"}],\"name\":\"migratePayFeeWithDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cup\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"otc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payGem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"migratePayFeeWithGem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"swapDaiToSai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"swapSaiToDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MigrationProxyActions","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://f824a958baf85d3781f552f3818450f2c85d24ddded11c063c7c5cda4c2ffe18"}]}