{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract.\r\n    */\r\n    constructor(address _owner) public {\r\n        owner = _owner == address(0) ? msg.sender : _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev confirm ownership by a new owner\r\n    */\r\n    function confirmOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title IERC20Token - ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\r\n    function approve(address _spender, uint256 _value)  public returns (bool success);\r\n    function allowance(address _owner, address _spender)  public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    /**\r\n    * @dev constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Token - ERC20 base implementation\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Token is IERC20Token, SafeMath {\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/**\r\n * @title ITokenEventListener\r\n * @dev Interface which should be implemented by token listener\r\n */\r\ninterface ITokenEventListener {\r\n    /**\r\n     * @dev Function is called after token transfer/transferFrom\r\n     * @param _from Sender address\r\n     * @param _to Receiver address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function onTokenTransfer(address _from, address _to, uint256 _value) external;\r\n}\r\n\r\n/**\r\n * @title ManagedToken\r\n * @dev ERC20 compatible token with issue and destroy facilities\r\n * @dev All transfers can be monitored by token event listener\r\n */\r\ncontract ManagedToken is ERC20Token, Ownable {\r\n    uint256 public totalIssue;                                                  //Total token issue\r\n    bool public allowTransfers = false;                                         //Default not transfer\r\n    bool public issuanceFinished = false;                                       //Finished issuance\r\n\r\n    ITokenEventListener public eventListener;                                   //Listen events\r\n\r\n    event AllowTransfersChanged(bool _newState);                                //Event:\r\n    event Issue(address indexed _to, uint256 _value);                           //Event: Issue\r\n    event Destroy(address indexed _from, uint256 _value);                       //Event:\r\n    event IssuanceFinished(bool _issuanceFinished);                             //Event: Finished issuance\r\n\r\n    //Modifier: Allow all transfer if not any condition\r\n    modifier transfersAllowed() {\r\n        require(allowTransfers);\r\n        _;\r\n    }\r\n\r\n    //Modifier: Allow continue to issue\r\n    modifier canIssue() {\r\n        require(!issuanceFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev ManagedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owner Owner of contract(address can be 0x0)\r\n     */\r\n    constructor(address _listener, address _owner) public Ownable(_owner) {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/disable token transfers. Can be called only by owners\r\n     * @param _allowTransfers True - allow False - disable\r\n     */\r\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\r\n        allowTransfers = _allowTransfers;\r\n\r\n        //Call event\r\n        emit AllowTransfersChanged(_allowTransfers);\r\n    }\r\n\r\n    /**\r\n     * @dev Set/remove token event listener\r\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\r\n     */\r\n    function setListener(address _listener) public onlyOwner {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        } else {\r\n            delete eventListener;\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transfer(_to, _value);\r\n        /* if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\r\n        } */\r\n        return success;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n\r\n        //If has Listenser and transfer success\r\n        /* if(hasListener() && success) {\r\n            //Call event listener\r\n            eventListener.onTokenTransfer(_from, _to, _value);\r\n        } */\r\n        return success;\r\n    }\r\n\r\n    function hasListener() internal view returns(bool) {\r\n        if(eventListener == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Issue tokens to specified wallet\r\n     * @param _to Wallet address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n        totalIssue = safeAdd(totalIssue, _value);\r\n        require(totalSupply >= totalIssue, \"Total issue is not greater total of supply\");\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        //Call event\r\n        emit Issue(_to, _value);\r\n        emit Transfer(address(0), _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy tokens on specified address (Called byallowance owner or token holder)\r\n     * @dev Fund contract address must be in the list of owners to burn token during refund\r\n     * @param _from Wallet address\r\n     * @param _value Amount of tokens to destroy\r\n     */\r\n    function destroy(address _from, uint256 _value) external onlyOwner {\r\n        require(balances[_from] >= _value, \"Value of destroy is not greater balance of address wallet\");\r\n\r\n        totalIssue = safeSub(totalIssue, _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n\r\n        emit Transfer(_from, address(0), _value);\r\n        //Call event\r\n        emit Destroy(_from, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Finish token issuance\r\n     * @return True if success\r\n     */\r\n    function setAllowIssuance(bool _issuanceFinished) public onlyOwner returns (bool) {\r\n        issuanceFinished = _issuanceFinished;\r\n        //Call event\r\n        emit IssuanceFinished(_issuanceFinished);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title LockTransfer\r\n * @dev Limit transfers for certain period of time\r\n */\r\ncontract LockTransfer is ManagedToken {\r\n    bool public isLimitTimeTransfer = false;                        //Enable/Disable limit transfer for certain period of time\r\n    uint256 public limitTimeTransferEndDate;                        //End of time for limit transfer\r\n\r\n    event TransfersEnabled();\r\n\r\n    /**\r\n     * @dev LockTransfer constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owner Owner\r\n     */\r\n    constructor(\r\n        address _listener,\r\n        address _owner\r\n    ) public ManagedToken(_listener, _owner)\r\n    {\r\n    }   \r\n\r\n    /**\r\n     * @dev Check if transfer is available at now\r\n     */\r\n    modifier checkLimitTimeTransfer()  {\r\n        if(isLimitTimeTransfer){\r\n            if(now > limitTimeTransferEndDate){\r\n                isLimitTimeTransfer = false;\r\n            }else{\r\n                require(false, \"Transfer is locking.\");\r\n            }\r\n        }\r\n        _;\r\n    }     \r\n\r\n    /**\r\n     * @dev Enable/Disable transfer limit manually. Can be called only by owner\r\n     */\r\n    function setAllowLimitTimeTransfer(bool _isLimitTimeTransfer) public onlyOwner {\r\n        isLimitTimeTransfer = _isLimitTimeTransfer;\r\n    }\r\n\r\n    function setLimitTimeTransferEndDate(uint256 _limitTimeTransferEndDateSecond) public onlyOwner {\r\n        isLimitTimeTransfer = true;\r\n        limitTimeTransferEndDate = _limitTimeTransferEndDateSecond + now;\r\n    }\r\n}\r\n\r\n/**\r\n * @title TransferLimitedToken\r\n * @dev Token with ability to limit transfers within wallets included in limitedWallets list for certain period of time\r\n */\r\ncontract TransferLimitedToken is LockTransfer {\r\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\r\n\r\n    mapping(address => bool) public limitedWallets;\r\n    address public limitedWalletsManager;\r\n\r\n    bool public isLimitEnabled = false;                             //Enable or Disable limit with limited Wallets\r\n    bool public isLimitWithTime = false;                            //Enable or Disable limited wallets with time\r\n    uint256 public limitEndDate;                                    //End of time for limited wallets\r\n\r\n    event TransfersEnabled();\r\n\r\n    /**\r\n     * @dev TransferLimitedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owner Owners list\r\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\r\n     */\r\n    constructor(\r\n        address _listener,\r\n        address _owner,\r\n        address _limitedWalletsManager\r\n    ) public LockTransfer(_listener, _owner)\r\n    {\r\n        limitedWalletsManager = _limitedWalletsManager;\r\n    }   \r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == limitedWalletsManager || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /** uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\r\n     * @dev Check if transfer between addresses is available\r\n     * @param _from From address\r\n     * @param _to To address\r\n     */\r\n    modifier canTransfer(address _from, address _to)  {\r\n        if(isLimitEnabled){\r\n            if(limitedWallets[_from] || limitedWallets[_to]){\r\n                if(isLimitWithTime){\r\n                    if(now > limitEndDate){\r\n                        isLimitEnabled = false;                        \r\n                    }else{\r\n                        require(false, \"Wallet is limited in period time.\");\r\n                    }\r\n                }else{\r\n                    require(false, \"Wallet is limited.\");\r\n                }\r\n            }\r\n        }\r\n        _;\r\n    }     \r\n\r\n    /**\r\n      Begin: Set params by manager\r\n      _limitEndDateSecond is total of seconds for limit\r\n    */\r\n    function setLimitEndDate(uint256 _limitEndDateSecond) external onlyManager {\r\n        isLimitEnabled = true;\r\n        limitEndDate = now + _limitEndDateSecond;\r\n    }\r\n\r\n    function setLimitInAYear() external onlyManager {\r\n        isLimitEnabled = true;\r\n        limitEndDate = now + LIMIT_TRANSFERS_PERIOD;\r\n    }\r\n\r\n    function changeLimitedWalletsManager(address _limitedWalletsManager) external onlyOwner{\r\n        limitedWalletsManager = _limitedWalletsManager;\r\n    }\r\n     /**\r\n      End: Set params by manager\r\n    */\r\n\r\n    /**\r\n     * @dev Add address to limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function addLimitedWalletAddress(address _wallet) public onlyManager {\r\n        limitedWallets[_wallet] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Del address from limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\r\n        limitedWallets[_wallet] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/Disable transfer limit manually. Can be called only by manager\r\n     */\r\n    function setAllowLimitedWallet(bool _isLimitEnabled) public onlyManager {\r\n        isLimitEnabled = _isLimitEnabled;\r\n    }\r\n\r\n    /**\r\n     * @dev Set time period for transfer limit manually. Can be called only by manager\r\n     */\r\n    function setAllowLimitedWalletWithTime(bool _isLimitWithTime) public onlyManager {\r\n        isLimitWithTime = _isLimitWithTime;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) checkLimitTimeTransfer  returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) checkLimitTimeTransfer returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) checkLimitTimeTransfer returns (bool) {\r\n        return super.approve(_spender,_value);\r\n    }    \r\n}\r\n\r\n\r\n/**\r\n * Char Token Contract\r\n * @title Char\r\n */\r\ncontract Char is TransferLimitedToken {\r\n    bool public isLock = false;                                                 //Lock system\r\n    uint256 public lockTotal;                                                   //Total token is lock\r\n    uint256 public unlockTotal;                                                 //Total token is unlock\r\n    uint256 public lockEndTime;                                                 //Time end of lock\r\n\r\n    uint256 public LOCK_WITH_FOUR_WEEKS = 28 days;\r\n    uint256 public LOCK_WITH_EIGHT_WEEKS = 56 days;\r\n    uint256 public LOCK_WITH_TWELVE_WEEKS = 84 days;\r\n    uint256 public LOCK_WITH_ONE_YEAR = 365 days;\r\n\r\n    /**\r\n     * @dev Char constructor\r\n     */\r\n    constructor() public TransferLimitedToken(msg.sender, msg.sender, msg.sender) {\r\n        name = \"Char\";\r\n        symbol = \"Char\";\r\n        decimals = 18;\r\n        totalIssue = 0;\r\n        totalSupply = 5000000000 ether;                                         //The maximum number of tokens is unchanged and totals will decrease after issue\r\n        lockTotal = 0 ether;                                                    //Total tokens to lock\r\n        unlockTotal = 5000000000 ether;                                         //Total tokens to lock\r\n    }\r\n\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n        totalIssue = safeAdd(totalIssue, _value);\r\n        require(totalSupply >= totalIssue, \"Total issue is not greater total of supply\");\r\n\r\n        if(isLock){\r\n            if(now > lockEndTime){\r\n                isLock = false;\r\n            }else{\r\n                require(totalIssue <= unlockTotal, \"totalIssue is required less than value of unlockTotal.\");            \r\n            }\r\n        }\r\n        \r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        //Call event\r\n        emit Issue(_to, _value);\r\n        emit Transfer(address(0), _to, _value);\r\n    }\r\n\r\n    function setLock(bool _isLock) external onlyOwner {\r\n        isLock = _isLock;\r\n    }\r\n\r\n    /**\r\n        Set total of token to lock for certain period of tim\r\n     */\r\n    function setLockTotal(uint256 _lockTotal) external onlyOwner {\r\n        lockTotal = _lockTotal;\r\n        unlockTotal = safeSub(totalSupply, lockTotal);\r\n    }\r\n\r\n    /**\r\n        Set time to end lock token\r\n     */\r\n    function setLockEndTime(uint256 _lockEndTimeSecond) external onlyOwner {\r\n        isLock = true;\r\n        lockEndTime = _lockEndTimeSecond + now;\r\n    }\r\n\r\n    /**\r\n        Set lock a part of token in four weeks \r\n    */\r\n    function setLockFourWeeks() external onlyOwner {\r\n        isLock = true;\r\n        lockEndTime = LOCK_WITH_FOUR_WEEKS + now;\r\n    }\r\n\r\n    /**\r\n        Set lock a part of token in eight weeks\r\n     */\r\n    function setLockEightWeeks() external onlyOwner {\r\n        isLock = true;\r\n        lockEndTime = LOCK_WITH_EIGHT_WEEKS + now;\r\n    }\r\n\r\n    /**\r\n        Set lock a part of token in twelve weeks\r\n     */\r\n    function setLockTwelveWeeks() external onlyOwner {\r\n        isLock = true;\r\n        lockEndTime = LOCK_WITH_TWELVE_WEEKS + now;\r\n    }\r\n\r\n    /**\r\n        Set lock a part of token in a year\r\n     */\r\n    function setLockAYear() external onlyOwner {\r\n        isLock = true;\r\n        lockEndTime = LOCK_WITH_ONE_YEAR + now;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"setLockAYear\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limitEndDateSecond\",\"type\":\"uint256\"}],\"name\":\"setLimitEndDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_WITH_EIGHT_WEEKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockEndTimeSecond\",\"type\":\"uint256\"}],\"name\":\"setLockEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_WITH_ONE_YEAR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitedWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLockTwelveWeeks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitedWalletsManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isLock\",\"type\":\"bool\"}],\"name\":\"setLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIMIT_TRANSFERS_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLockFourWeeks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limitTimeTransferEndDateSecond\",\"type\":\"uint256\"}],\"name\":\"setLimitTimeTransferEndDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isLimitTimeTransfer\",\"type\":\"bool\"}],\"name\":\"setAllowLimitTimeTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"delLimitedWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLimitTimeTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isLimitEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowLimitedWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isLimitWithTime\",\"type\":\"bool\"}],\"name\":\"setAllowLimitedWalletWithTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_WITH_TWELVE_WEEKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_listener\",\"type\":\"address\"}],\"name\":\"setListener\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLimitWithTime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockTotal\",\"type\":\"uint256\"}],\"name\":\"setLockTotal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuanceFinished\",\"type\":\"bool\"}],\"name\":\"setAllowIssuance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitTimeTransferEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limitedWalletsManager\",\"type\":\"address\"}],\"name\":\"changeLimitedWalletsManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_WITH_FOUR_WEEKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLockEightWeeks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventListener\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLimitEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowTransfers\",\"type\":\"bool\"}],\"name\":\"setAllowTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLimitInAYear\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addLimitedWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TransfersEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"AllowTransfersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Issue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_issuanceFinished\",\"type\":\"bool\"}],\"name\":\"IssuanceFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Char","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://23a25d14bc2b0147fcaa300bdc6f028255f6dae773fe13704fb8ade5b914a9bc"}]}