{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract ParameterStore {\r\n    // EVENTS\r\n    event ProposalCreated(\r\n        uint256 proposalID,\r\n        address indexed proposer,\r\n        uint256 requestID,\r\n        string key,\r\n        bytes32 value,\r\n        bytes metadataHash\r\n    );\r\n    event Initialized();\r\n    event ParameterSet(string name, bytes32 key, bytes32 value);\r\n    event ProposalAccepted(uint256 proposalID, string key, bytes32 value);\r\n\r\n\r\n    // STATE\r\n    using SafeMath for uint256;\r\n\r\n    address owner;\r\n    bool public initialized;\r\n    mapping(bytes32 => bytes32) public params;\r\n\r\n    // A proposal to change a value\r\n    struct Proposal {\r\n        address gatekeeper;\r\n        uint256 requestID;\r\n        string key;\r\n        bytes32 value;\r\n        bytes metadataHash;\r\n        bool executed;\r\n    }\r\n\r\n    // All submitted proposals\r\n    Proposal[] public proposals;\r\n\r\n    // IMPLEMENTATION\r\n    /**\r\n     @dev Initialize a ParameterStore with a set of names and associated values.\r\n     @param _names Names of parameters\r\n     @param _values abi-encoded values to assign them\r\n    */\r\n    constructor(string[] memory _names, bytes32[] memory _values) public {\r\n        owner = msg.sender;\r\n        require(_names.length == _values.length, \"All inputs must have the same length\");\r\n\r\n        for (uint i = 0; i < _names.length; i++) {\r\n            string memory name = _names[i];\r\n            set(name, _values[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Initialize the contract, preventing any more changes not made through slate governance\r\n     */\r\n    function init() public {\r\n        require(msg.sender == owner, \"Only the owner can initialize the ParameterStore\");\r\n        require(initialized == false, \"Contract has already been initialized\");\r\n\r\n        initialized = true;\r\n\r\n        // Do not allow initialization unless the gatekeeperAddress is set\r\n        // Check after setting initialized so we can use the getter\r\n        require(getAsAddress(\"gatekeeperAddress\") != address(0), \"Missing gatekeeper\");\r\n\r\n        emit Initialized();\r\n    }\r\n\r\n    // GETTERS\r\n\r\n    /**\r\n     @dev Get the parameter value associated with the given name.\r\n     @param _name The name of the parameter to get the value for\r\n    */\r\n    function get(string memory _name) public view returns (bytes32 value) {\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n        return params[keccak256(abi.encodePacked(_name))];\r\n    }\r\n\r\n    /**\r\n     @dev Get the parameter value and cast to `uint256`\r\n     @param _name The name of the parameter to get the value for\r\n    */\r\n    function getAsUint(string memory _name) public view returns(uint256) {\r\n        bytes32 value = get(_name);\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     @dev Get the parameter value and cast to `address`\r\n     @param _name The name of the parameter to get the value for\r\n    */\r\n    function getAsAddress(string memory _name) public view returns (address) {\r\n        bytes32 value = get(_name);\r\n        return address(uint256(value));\r\n    }\r\n\r\n    // SETTERS\r\n    /**\r\n     @dev Assign the parameter with the given key to the given value.\r\n     @param _name The name of the parameter to be set\r\n     @param _value The abi-encoded value to assign the parameter\r\n    */\r\n    function set(string memory _name, bytes32 _value) private {\r\n        bytes32 key = keccak256(abi.encodePacked(_name));\r\n        params[key] = _value;\r\n        emit ParameterSet(_name, key, _value);\r\n    }\r\n\r\n    /**\r\n     @dev Set a parameter before the ParameterStore has been initialized\r\n     @param _name The name of the parameter to set\r\n     @param _value The abi-encoded value to assign the parameter\r\n    */\r\n    function setInitialValue(string memory _name, bytes32 _value) public {\r\n        require(msg.sender == owner, \"Only the owner can set initial values\");\r\n        require(initialized == false, \"Cannot set values after initialization\");\r\n\r\n        set(_name, _value);\r\n    }\r\n\r\n    function _createProposal(Gatekeeper gatekeeper, string memory key, bytes32 value, bytes memory metadataHash) internal returns(uint256) {\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n\r\n        Proposal memory p = Proposal({\r\n            gatekeeper: address(gatekeeper),\r\n            requestID: 0,\r\n            key: key,\r\n            value: value,\r\n            metadataHash: metadataHash,\r\n            executed: false\r\n        });\r\n\r\n        // Request permission from the Gatekeeper and store the proposal data for later.\r\n        // If the request is approved, a user can execute the proposal by providing the\r\n        // proposalID.\r\n        uint requestID = gatekeeper.requestPermission(metadataHash);\r\n        p.requestID = requestID;\r\n        uint proposalID = proposalCount();\r\n        proposals.push(p);\r\n\r\n        emit ProposalCreated(proposalID, msg.sender, requestID, key, value, metadataHash);\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     @dev Create a proposal to set a value.\r\n     @param key The key to set\r\n     @param value The value to set\r\n     @param metadataHash A reference to metadata describing the proposal\r\n     */\r\n    function createProposal(string calldata key, bytes32 value, bytes calldata metadataHash) external returns(uint256) {\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n\r\n        Gatekeeper gatekeeper = _gatekeeper();\r\n        return _createProposal(gatekeeper, key, value, metadataHash);\r\n    }\r\n\r\n    /**\r\n     @dev Create multiple proposals to set values.\r\n     @param keys The keys to set\r\n     @param values The values to set for the keys\r\n     @param metadataHashes Metadata hashes describing the proposals\r\n    */\r\n    function createManyProposals(\r\n        string[] calldata keys,\r\n        bytes32[] calldata values,\r\n        bytes[] calldata metadataHashes\r\n    ) external {\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n        require(\r\n            keys.length == values.length && values.length == metadataHashes.length,\r\n            \"All inputs must have the same length\"\r\n        );\r\n\r\n        Gatekeeper gatekeeper = _gatekeeper();\r\n        for (uint i = 0; i < keys.length; i++) {\r\n            string memory key = keys[i];\r\n            bytes32 value = values[i];\r\n            bytes memory metadataHash = metadataHashes[i];\r\n            _createProposal(gatekeeper, key, value, metadataHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Execute a proposal to set a parameter. The proposal must have been included in an\r\n     accepted governance slate.\r\n     @param proposalID The proposal\r\n     */\r\n    function setValue(uint256 proposalID) public returns(bool) {\r\n        require(proposalID < proposalCount(), \"Invalid proposalID\");\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n\r\n        Proposal memory p = proposals[proposalID];\r\n        Gatekeeper gatekeeper = Gatekeeper(p.gatekeeper);\r\n\r\n        require(gatekeeper.hasPermission(p.requestID), \"Proposal has not been approved\");\r\n        require(p.executed == false, \"Proposal already executed\");\r\n\r\n        proposals[proposalID].executed = true;\r\n\r\n        set(p.key, p.value);\r\n\r\n        emit ProposalAccepted(proposalID, p.key, p.value);\r\n        return true;\r\n    }\r\n\r\n    function proposalCount() public view returns(uint256) {\r\n        return proposals.length;\r\n    }\r\n\r\n    function _gatekeeper() private view returns(Gatekeeper) {\r\n        address gatekeeperAddress = getAsAddress(\"gatekeeperAddress\");\r\n        require(gatekeeperAddress != address(0), \"Missing gatekeeper\");\r\n        return Gatekeeper(gatekeeperAddress);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Donation receiver interface\r\n * @dev Contracts (like the TokenCapacitor) that can receive donations\r\n */\r\ninterface IDonationReceiver {\r\n    event Donation(address indexed payer, address indexed donor, uint numTokens, bytes metadataHash);\r\n\r\n    function donate(address donor, uint tokens, bytes calldata metadataHash) external returns(bool);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Gatekeeper {\r\n    // EVENTS\r\n    event PermissionRequested(\r\n        uint256 indexed epochNumber,\r\n        address indexed resource,\r\n        uint requestID,\r\n        bytes metadataHash\r\n    );\r\n    event SlateCreated(uint slateID, address indexed recommender, uint[] requestIDs, bytes metadataHash);\r\n    event SlateStaked(uint slateID, address indexed staker, uint numTokens);\r\n    event VotingTokensDeposited(address indexed voter, uint numTokens);\r\n    event VotingTokensWithdrawn(address indexed voter, uint numTokens);\r\n    event VotingRightsDelegated(address indexed voter, address delegate);\r\n    event BallotCommitted(\r\n        uint indexed epochNumber,\r\n        address indexed committer,\r\n        address indexed voter,\r\n        uint numTokens,\r\n        bytes32 commitHash\r\n    );\r\n    event BallotRevealed(uint indexed epochNumber, address indexed voter, uint numTokens);\r\n    event ContestAutomaticallyFinalized(\r\n        uint256 indexed epochNumber,\r\n        address indexed resource,\r\n        uint256 winningSlate\r\n    );\r\n    event ContestFinalizedWithoutWinner(uint indexed epochNumber, address indexed resource);\r\n    event VoteFinalized(\r\n        uint indexed epochNumber,\r\n        address indexed resource,\r\n        uint winningSlate,\r\n        uint winnerVotes,\r\n        uint totalVotes\r\n    );\r\n    event VoteFailed(\r\n        uint indexed epochNumber,\r\n        address indexed resource,\r\n        uint leadingSlate,\r\n        uint leaderVotes,\r\n        uint runnerUpSlate,\r\n        uint runnerUpVotes,\r\n        uint totalVotes\r\n    );\r\n    event RunoffFinalized(\r\n        uint indexed epochNumber,\r\n        address indexed resource,\r\n        uint winningSlate,\r\n        uint winnerVotes,\r\n        uint losingSlate,\r\n        uint loserVotes\r\n    );\r\n    event StakeWithdrawn(uint slateID, address indexed staker, uint numTokens);\r\n\r\n    // STATE\r\n    using SafeMath for uint256;\r\n\r\n    uint constant ONE_WEEK = 604800;\r\n\r\n    // The timestamp of the start of the first epoch\r\n    uint public startTime;\r\n    uint public constant EPOCH_LENGTH = ONE_WEEK * 13;\r\n    uint public constant SLATE_SUBMISSION_PERIOD_START = ONE_WEEK;\r\n    uint public constant COMMIT_PERIOD_START = ONE_WEEK * 11;\r\n    uint public constant REVEAL_PERIOD_START = ONE_WEEK * 12;\r\n\r\n    // Parameters\r\n    ParameterStore public parameters;\r\n\r\n    // Associated token\r\n    IERC20 public token;\r\n\r\n    // Requests\r\n    struct Request {\r\n        bytes metadataHash;\r\n        // The resource (contract) the permission is being requested for\r\n        address resource;\r\n        bool approved;\r\n        uint expirationTime;\r\n        uint epochNumber;\r\n    }\r\n\r\n    // The requests made to the Gatekeeper.\r\n    Request[] public requests;\r\n\r\n    // Voting\r\n    enum SlateStatus {\r\n        Unstaked,\r\n        Staked,\r\n        Accepted\r\n    }\r\n\r\n    struct Slate {\r\n        address recommender;\r\n        bytes metadataHash;\r\n        mapping(uint => bool) requestIncluded;\r\n        uint[] requests;\r\n        SlateStatus status;\r\n        // Staking info\r\n        address staker;\r\n        uint stake;\r\n        // Ballot info\r\n        uint256 epochNumber;\r\n        address resource;\r\n    }\r\n\r\n    // The slates created by the Gatekeeper.\r\n    Slate[] public slates;\r\n\r\n    // The number of tokens each account has available for voting\r\n    mapping(address => uint) public voteTokenBalance;\r\n\r\n    // The delegated account for each voting account\r\n    mapping(address => address) public delegate;\r\n\r\n    // The data committed when voting\r\n    struct VoteCommitment {\r\n        bytes32 commitHash;\r\n        uint numTokens;\r\n        bool committed;\r\n        bool revealed;\r\n    }\r\n\r\n    // The votes for a slate in a contest\r\n    struct SlateVotes {\r\n        uint firstChoiceVotes;\r\n        // slateID -> count\r\n        mapping(uint => uint) secondChoiceVotes;\r\n        uint totalSecondChoiceVotes;\r\n    }\r\n\r\n    enum ContestStatus {\r\n        Empty,\r\n        NoContest,\r\n        Active,\r\n        Finalized\r\n    }\r\n\r\n    struct Contest {\r\n        ContestStatus status;\r\n\r\n        // slateIDs\r\n        uint[] slates;\r\n        uint[] stakedSlates;\r\n        uint256 lastStaked;\r\n\r\n        // slateID -> tally\r\n        mapping(uint => SlateVotes) votes;\r\n        uint256 stakesDonated;\r\n\r\n        // Intermediate results\r\n        uint voteLeader;\r\n        uint voteRunnerUp;\r\n        uint256 leaderVotes;\r\n        uint256 runnerUpVotes;\r\n        uint256 totalVotes;\r\n\r\n        // Final results\r\n        uint winner;\r\n    }\r\n\r\n    // The current incumbent for a resource\r\n    mapping(address => address) public incumbent;\r\n\r\n    // A group of Contests in an epoch\r\n    struct Ballot {\r\n        // resource -> Contest\r\n        mapping(address => Contest) contests;\r\n        // NOTE: keep to avoid error about \"internal or recursive type\"\r\n        bool created;\r\n\r\n        // commitments for each voter\r\n        mapping(address => VoteCommitment) commitments;\r\n    }\r\n\r\n    // All the ballots created so far\r\n    // epoch number -> Ballot\r\n    mapping(uint => Ballot) public ballots;\r\n\r\n\r\n    // IMPLEMENTATION\r\n    /**\r\n     @dev Initialize a Gatekeeper contract.\r\n     @param _startTime The start time of the first batch\r\n     @param _parameters The parameter store to use\r\n    */\r\n    constructor(uint _startTime, ParameterStore _parameters, IERC20 _token) public {\r\n        require(address(_parameters) != address(0), \"Parameter store address cannot be zero\");\r\n        parameters = _parameters;\r\n\r\n        require(address(_token) != address(0), \"Token address cannot be zero\");\r\n        token = _token;\r\n\r\n        startTime = _startTime;\r\n    }\r\n\r\n    // TIMING\r\n    /**\r\n    * @dev Get the number of the current epoch.\r\n    */\r\n    function currentEpochNumber() public view returns(uint) {\r\n        uint elapsed = now.sub(startTime);\r\n        uint epoch = elapsed.div(EPOCH_LENGTH);\r\n\r\n        return epoch;\r\n    }\r\n\r\n    /**\r\n    * @dev Get the start of the given epoch.\r\n    */\r\n    function epochStart(uint256 epoch) public view returns(uint) {\r\n        return startTime.add(EPOCH_LENGTH.mul(epoch));\r\n    }\r\n\r\n\r\n    // SLATE GOVERNANCE\r\n    /**\r\n    * @dev Create a new slate with the associated requestIds and metadata hash.\r\n    * @param resource The resource to submit the slate for\r\n    * @param requestIDs A list of request IDs to include in the slate\r\n    * @param metadataHash A reference to metadata about the slate\r\n    */\r\n    function recommendSlate(\r\n        address resource,\r\n        uint[] memory requestIDs,\r\n        bytes memory metadataHash\r\n    )\r\n        public returns(uint)\r\n    {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        require(slateSubmissionPeriodActive(resource), \"Submission period not active\");\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n\r\n        uint256 epochNumber = currentEpochNumber();\r\n\r\n        // create slate\r\n        Slate memory s = Slate({\r\n            recommender: msg.sender,\r\n            metadataHash: metadataHash,\r\n            requests: requestIDs,\r\n            status: SlateStatus.Unstaked,\r\n            staker: address(0),\r\n            stake: 0,\r\n            epochNumber: epochNumber,\r\n            resource: resource\r\n        });\r\n\r\n        // Record slate and return its ID\r\n        uint slateID = slateCount();\r\n        slates.push(s);\r\n\r\n        // Set up the requests\r\n        for (uint i = 0; i < requestIDs.length; i++) {\r\n            uint requestID = requestIDs[i];\r\n            require(requestID < requestCount(), \"Invalid requestID\");\r\n\r\n            Request memory r = requests[requestID];\r\n            // Every request's resource must match the one passed in\r\n            require(r.resource == resource, \"Resource does not match\");\r\n\r\n            // Requests must be current\r\n            require(r.epochNumber == epochNumber, \"Invalid epoch\");\r\n\r\n            // Requests cannot be duplicated\r\n            require(slates[slateID].requestIncluded[requestID] == false, \"Duplicate requests are not allowed\");\r\n            slates[slateID].requestIncluded[requestID] = true;\r\n        }\r\n\r\n        // Assign the slate to the appropriate contest\r\n        ballots[epochNumber].contests[resource].slates.push(slateID);\r\n\r\n        emit SlateCreated(slateID, msg.sender, requestIDs, metadataHash);\r\n        return slateID;\r\n    }\r\n\r\n    /**\r\n    @dev Get a list of the requests associated with a slate\r\n    @param slateID The slate\r\n     */\r\n    function slateRequests(uint slateID) public view returns(uint[] memory) {\r\n        return slates[slateID].requests;\r\n    }\r\n\r\n    /**\r\n    @dev Stake tokens on the given slate to include it for consideration in votes. If the slate\r\n    loses in a contest, the amount staked will go to the winner. If it wins, it will be returned.\r\n    @param slateID The slate to stake on\r\n     */\r\n    function stakeTokens(uint slateID) public returns(bool) {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        require(slateID < slateCount(), \"No slate exists with that slateID\");\r\n        require(slates[slateID].status == SlateStatus.Unstaked, \"Slate has already been staked\");\r\n\r\n        address staker = msg.sender;\r\n\r\n        // Staker must have enough tokens\r\n        uint stakeAmount = parameters.getAsUint(\"slateStakeAmount\");\r\n        require(token.balanceOf(staker) >= stakeAmount, \"Insufficient token balance\");\r\n\r\n        Slate storage slate = slates[slateID];\r\n\r\n        // Submission period must be active\r\n        require(slateSubmissionPeriodActive(slate.resource), \"Submission period not active\");\r\n        uint256 epochNumber = currentEpochNumber();\r\n        assert(slate.epochNumber == epochNumber);\r\n\r\n        // Transfer tokens and update the slate's staking info\r\n        // Must successfully transfer tokens from staker to this contract\r\n        slate.staker = staker;\r\n        slate.stake = stakeAmount;\r\n        slate.status = SlateStatus.Staked;\r\n        require(token.transferFrom(staker, address(this), stakeAmount), \"Failed to transfer tokens\");\r\n\r\n        // Associate the slate with a contest and update the contest status\r\n        // A vote can only happen if there is more than one associated slate\r\n        Contest storage contest = ballots[slate.epochNumber].contests[slate.resource];\r\n        contest.stakedSlates.push(slateID);\r\n        // offset from the start of the epoch, for easier calculations\r\n        contest.lastStaked = now.sub(epochStart(epochNumber));\r\n\r\n        uint256 numSlates = contest.stakedSlates.length;\r\n        if (numSlates == 1) {\r\n            contest.status = ContestStatus.NoContest;\r\n        } else {\r\n            contest.status = ContestStatus.Active;\r\n        }\r\n\r\n        emit SlateStaked(slateID, staker, stakeAmount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    @dev Withdraw tokens previously staked on a slate that was accepted through slate governance.\r\n    @param slateID The slate to withdraw the stake from\r\n     */\r\n    function withdrawStake(uint slateID) public returns(bool) {\r\n        require(slateID < slateCount(), \"No slate exists with that slateID\");\r\n\r\n        // get slate\r\n        Slate memory slate = slates[slateID];\r\n\r\n        require(slate.status == SlateStatus.Accepted, \"Slate has not been accepted\");\r\n        require(msg.sender == slate.staker, \"Only the original staker can withdraw this stake\");\r\n        require(slate.stake > 0, \"Stake has already been withdrawn\");\r\n\r\n        // Update slate and transfer tokens\r\n        slates[slateID].stake = 0;\r\n        require(token.transfer(slate.staker, slate.stake), \"Failed to transfer tokens\");\r\n\r\n        emit StakeWithdrawn(slateID, slate.staker, slate.stake);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     @dev Deposit `numToken` tokens into the Gatekeeper to use in voting\r\n     Assumes that `msg.sender` has approved the Gatekeeper to spend on their behalf\r\n     @param numTokens The number of tokens to devote to voting\r\n     */\r\n    function depositVoteTokens(uint numTokens) public returns(bool) {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        address voter = msg.sender;\r\n\r\n        // Voter must have enough tokens\r\n        require(token.balanceOf(msg.sender) >= numTokens, \"Insufficient token balance\");\r\n\r\n        // Transfer tokens to increase the voter's balance by `numTokens`\r\n        uint originalBalance = voteTokenBalance[voter];\r\n        voteTokenBalance[voter] = originalBalance.add(numTokens);\r\n\r\n        // Must successfully transfer tokens from voter to this contract\r\n        require(token.transferFrom(voter, address(this), numTokens), \"Failed to transfer tokens\");\r\n\r\n        emit VotingTokensDeposited(voter, numTokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @dev Withdraw `numTokens` vote tokens to the caller and decrease voting power\r\n    @param numTokens The number of tokens to withdraw\r\n     */\r\n    function withdrawVoteTokens(uint numTokens) public returns(bool) {\r\n        require(commitPeriodActive() == false, \"Tokens locked during voting\");\r\n\r\n        address voter = msg.sender;\r\n\r\n        uint votingRights = voteTokenBalance[voter];\r\n        require(votingRights >= numTokens, \"Insufficient vote token balance\");\r\n\r\n        // Transfer tokens to decrease the voter's balance by `numTokens`\r\n        voteTokenBalance[voter] = votingRights.sub(numTokens);\r\n\r\n        require(token.transfer(voter, numTokens), \"Failed to transfer tokens\");\r\n\r\n        emit VotingTokensWithdrawn(voter, numTokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Set a delegate account that can vote on behalf of the voter\r\n     @param _delegate The account being delegated to\r\n     */\r\n    function delegateVotingRights(address _delegate) public returns(bool) {\r\n        address voter = msg.sender;\r\n        require(voter != _delegate, \"Delegate and voter cannot be equal\");\r\n\r\n        delegate[voter] = _delegate;\r\n\r\n        emit VotingRightsDelegated(voter, _delegate);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     @dev Submit a commitment for the current ballot\r\n     @param voter The voter to commit for\r\n     @param commitHash The hash representing the voter's vote choices\r\n     @param numTokens The number of vote tokens to use\r\n     */\r\n    function commitBallot(address voter, bytes32 commitHash, uint numTokens) public {\r\n        uint epochNumber = currentEpochNumber();\r\n\r\n        require(commitPeriodActive(), \"Commit period not active\");\r\n\r\n        require(didCommit(epochNumber, voter) == false, \"Voter has already committed for this ballot\");\r\n        require(commitHash != 0, \"Cannot commit zero hash\");\r\n\r\n        address committer = msg.sender;\r\n\r\n        // Must be a delegate if not the voter\r\n        if (committer != voter) {\r\n            require(committer == delegate[voter], \"Not a delegate\");\r\n            require(voteTokenBalance[voter] >= numTokens, \"Insufficient tokens\");\r\n        } else {\r\n            // If the voter doesn't have enough tokens for voting, deposit more\r\n            if (voteTokenBalance[voter] < numTokens) {\r\n                uint remainder = numTokens.sub(voteTokenBalance[voter]);\r\n                depositVoteTokens(remainder);\r\n            }\r\n        }\r\n\r\n        assert(voteTokenBalance[voter] >= numTokens);\r\n\r\n        // Set the voter's commitment for the current ballot\r\n        Ballot storage ballot = ballots[epochNumber];\r\n        VoteCommitment memory commitment = VoteCommitment({\r\n            commitHash: commitHash,\r\n            numTokens: numTokens,\r\n            committed: true,\r\n            revealed: false\r\n        });\r\n\r\n        ballot.commitments[voter] = commitment;\r\n\r\n        emit BallotCommitted(epochNumber, committer, voter, numTokens, commitHash);\r\n    }\r\n\r\n    /**\r\n     @dev Return true if the voter has committed for the given epoch\r\n     @param epochNumber The epoch to check\r\n     @param voter The voter's address\r\n     */\r\n    function didCommit(uint epochNumber, address voter) public view returns(bool) {\r\n        return ballots[epochNumber].commitments[voter].committed;\r\n    }\r\n\r\n    /**\r\n     @dev Get the commit hash for a given voter and epoch. Revert if voter has not committed yet.\r\n     @param epochNumber The epoch to check\r\n     @param voter The voter's address\r\n     */\r\n    function getCommitHash(uint epochNumber, address voter) public view returns(bytes32) {\r\n        VoteCommitment memory v = ballots[epochNumber].commitments[voter];\r\n        require(v.committed, \"Voter has not committed for this ballot\");\r\n\r\n        return v.commitHash;\r\n    }\r\n\r\n    /**\r\n     @dev Reveal a given voter's choices for the current ballot and record their choices\r\n     @param voter The voter's address\r\n     @param resources The contests to vote on\r\n     @param firstChoices The corresponding first choices\r\n     @param secondChoices The corresponding second choices\r\n     @param salt The salt used to generate the original commitment\r\n     */\r\n    function revealBallot(\r\n        uint256 epochNumber,\r\n        address voter,\r\n        address[] memory resources,\r\n        uint[] memory firstChoices,\r\n        uint[] memory secondChoices,\r\n        uint salt\r\n    ) public {\r\n        uint256 epochTime = now.sub(epochStart(epochNumber));\r\n        require(\r\n            (REVEAL_PERIOD_START <= epochTime) && (epochTime < EPOCH_LENGTH),\r\n            \"Reveal period not active\"\r\n        );\r\n\r\n        require(voter != address(0), \"Voter address cannot be zero\");\r\n        require(resources.length == firstChoices.length, \"All inputs must have the same length\");\r\n        require(firstChoices.length == secondChoices.length, \"All inputs must have the same length\");\r\n\r\n        require(didCommit(epochNumber, voter), \"Voter has not committed\");\r\n        require(didReveal(epochNumber, voter) == false, \"Voter has already revealed\");\r\n\r\n\r\n        // calculate the hash\r\n        bytes memory buf;\r\n        uint votes = resources.length;\r\n        for (uint i = 0; i < votes; i++) {\r\n            buf = abi.encodePacked(\r\n                buf,\r\n                resources[i],\r\n                firstChoices[i],\r\n                secondChoices[i]\r\n            );\r\n        }\r\n        buf = abi.encodePacked(buf, salt);\r\n        bytes32 hashed = keccak256(buf);\r\n\r\n        Ballot storage ballot = ballots[epochNumber];\r\n\r\n        // compare to the stored data\r\n        VoteCommitment memory v = ballot.commitments[voter];\r\n        require(hashed == v.commitHash, \"Submitted ballot does not match commitment\");\r\n\r\n        // Update tally for each contest\r\n        for (uint i = 0; i < votes; i++) {\r\n            address resource = resources[i];\r\n\r\n            // get the contest for the current resource\r\n            Contest storage contest = ballot.contests[resource];\r\n\r\n            // Increment totals for first and second choice slates\r\n            uint firstChoice = firstChoices[i];\r\n            uint secondChoice = secondChoices[i];\r\n\r\n            // Update first choice standings\r\n            if (slates[firstChoice].status == SlateStatus.Staked) {\r\n                SlateVotes storage firstChoiceSlate = contest.votes[firstChoice];\r\n                contest.totalVotes = contest.totalVotes.add(v.numTokens);\r\n                uint256 newCount = firstChoiceSlate.firstChoiceVotes.add(v.numTokens);\r\n\r\n                // Update first choice standings\r\n                if (firstChoice == contest.voteLeader) {\r\n                    // Leader is still the leader\r\n                    contest.leaderVotes = newCount;\r\n                } else if (newCount > contest.leaderVotes) {\r\n                    // This slate is now the leader, and the previous leader is now the runner-up\r\n                    contest.voteRunnerUp = contest.voteLeader;\r\n                    contest.runnerUpVotes = contest.leaderVotes;\r\n\r\n                    contest.voteLeader = firstChoice;\r\n                    contest.leaderVotes = newCount;\r\n                } else if (newCount > contest.runnerUpVotes) {\r\n                    // This slate overtook the previous runner-up\r\n                    contest.voteRunnerUp = firstChoice;\r\n                    contest.runnerUpVotes = newCount;\r\n                }\r\n\r\n                firstChoiceSlate.firstChoiceVotes = newCount;\r\n\r\n                // Update second choice standings\r\n                if (slates[secondChoice].status == SlateStatus.Staked) {\r\n                    SlateVotes storage secondChoiceSlate = contest.votes[secondChoice];\r\n                    secondChoiceSlate.totalSecondChoiceVotes = secondChoiceSlate.totalSecondChoiceVotes.add(v.numTokens);\r\n                    firstChoiceSlate.secondChoiceVotes[secondChoice] = firstChoiceSlate.secondChoiceVotes[secondChoice].add(v.numTokens);\r\n                }\r\n            }\r\n        }\r\n\r\n        // update state\r\n        ballot.commitments[voter].revealed = true;\r\n\r\n        emit BallotRevealed(epochNumber, voter, v.numTokens);\r\n    }\r\n\r\n    /**\r\n    @dev Reveal ballots for multiple voters\r\n     */\r\n    function revealManyBallots(\r\n        uint256 epochNumber,\r\n        address[] memory _voters,\r\n        bytes[] memory _ballots,\r\n        uint[] memory _salts\r\n    ) public {\r\n        uint numBallots = _voters.length;\r\n        require(\r\n            _salts.length == _voters.length && _ballots.length == _voters.length,\r\n            \"Inputs must have the same length\"\r\n        );\r\n\r\n        for (uint i = 0; i < numBallots; i++) {\r\n            // extract resources, firstChoices, secondChoices from the ballot\r\n            (\r\n                address[] memory resources,\r\n                uint[] memory firstChoices,\r\n                uint[] memory secondChoices\r\n            ) = abi.decode(_ballots[i], (address[], uint[], uint[]));\r\n\r\n            revealBallot(epochNumber, _voters[i], resources, firstChoices, secondChoices, _salts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Get the number of first-choice votes cast for the given slate and resource\r\n     @param epochNumber The epoch\r\n     @param resource The resource\r\n     @param slateID The slate\r\n     */\r\n    function getFirstChoiceVotes(uint epochNumber, address resource, uint slateID) public view returns(uint) {\r\n        SlateVotes storage v = ballots[epochNumber].contests[resource].votes[slateID];\r\n        return v.firstChoiceVotes;\r\n    }\r\n\r\n    /**\r\n     @dev Get the number of second-choice votes cast for the given slate and resource\r\n     @param epochNumber The epoch\r\n     @param resource The resource\r\n     @param slateID The slate\r\n     */\r\n    function getSecondChoiceVotes(uint epochNumber, address resource, uint slateID) public view returns(uint) {\r\n        // for each option that isn't this one, get the second choice votes\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n        uint numSlates = contest.stakedSlates.length;\r\n        uint votes = 0;\r\n        for (uint i = 0; i < numSlates; i++) {\r\n            uint otherSlateID = contest.stakedSlates[i];\r\n            if (otherSlateID != slateID) {\r\n                SlateVotes storage v = contest.votes[otherSlateID];\r\n                // get second-choice votes for the target slate\r\n                votes = votes.add(v.secondChoiceVotes[slateID]);\r\n            }\r\n        }\r\n        return votes;\r\n    }\r\n\r\n    /**\r\n     @dev Return true if the voter has revealed for the given epoch\r\n     @param epochNumber The epoch\r\n     @param voter The voter's address\r\n     */\r\n    function didReveal(uint epochNumber, address voter) public view returns(bool) {\r\n        return ballots[epochNumber].commitments[voter].revealed;\r\n    }\r\n\r\n    /**\r\n     @dev Finalize contest, triggering a vote count if necessary, and update the status of the\r\n     contest.\r\n\r\n     If there is a single slate, it automatically wins. Otherwise, count votes.\r\n     Count the first choice votes for each slate. If a slate has more than 50% of the votes,\r\n     then it wins and the vote is finalized. Otherwise, wait for a runoff. If no\r\n     votes are counted, finalize without a winner.\r\n\r\n     @param epochNumber The epoch\r\n     @param resource The resource to finalize for\r\n     */\r\n    function finalizeContest(uint epochNumber, address resource) public {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n\r\n        // Finalization must be after the vote period (i.e when the given epoch is over)\r\n        require(currentEpochNumber() > epochNumber, \"Contest epoch still active\");\r\n\r\n        // Make sure the ballot has a contest for this resource\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n        require(contest.status == ContestStatus.Active || contest.status == ContestStatus.NoContest,\r\n            \"Either no contest is in progress for this resource, or it has been finalized\");\r\n\r\n        // A single staked slate in the contest automatically wins\r\n        if (contest.status == ContestStatus.NoContest) {\r\n            uint256 winningSlate = contest.stakedSlates[0];\r\n            assert(slates[winningSlate].status == SlateStatus.Staked);\r\n\r\n            contest.winner = winningSlate;\r\n            contest.status = ContestStatus.Finalized;\r\n\r\n            acceptSlate(winningSlate);\r\n            emit ContestAutomaticallyFinalized(epochNumber, resource, winningSlate);\r\n            return;\r\n        }\r\n\r\n        // no votes\r\n        if (contest.totalVotes > 0) {\r\n            uint256 winnerVotes = contest.leaderVotes;\r\n\r\n            // If the winner has more than 50%, we are done\r\n            // Otherwise, trigger a runoff\r\n            if (winnerVotes.mul(2) > contest.totalVotes) {\r\n                contest.winner = contest.voteLeader;\r\n                acceptSlate(contest.winner);\r\n\r\n                contest.status = ContestStatus.Finalized;\r\n                emit VoteFinalized(epochNumber, resource, contest.winner, winnerVotes, contest.totalVotes);\r\n            } else {\r\n                emit VoteFailed(epochNumber, resource, contest.voteLeader, winnerVotes, contest.voteRunnerUp, contest.runnerUpVotes, contest.totalVotes);\r\n                _finalizeRunoff(epochNumber, resource);\r\n            }\r\n        } else {\r\n            // no one voted\r\n            contest.status = ContestStatus.Finalized;\r\n            emit ContestFinalizedWithoutWinner(epochNumber, resource);\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Return the status of the specified contest\r\n     */\r\n    function contestStatus(uint epochNumber, address resource) public view returns(ContestStatus) {\r\n        return ballots[epochNumber].contests[resource].status;\r\n    }\r\n\r\n    /**\r\n     @dev Return the IDs of the slates (staked and unstaked) associated with the contest\r\n     */\r\n    function contestSlates(uint epochNumber, address resource) public view returns(uint[] memory) {\r\n        return ballots[epochNumber].contests[resource].slates;\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Get the details of the specified contest\r\n     */\r\n    function contestDetails(uint256 epochNumber, address resource) external view\r\n        returns(\r\n            ContestStatus status,\r\n            uint256[] memory allSlates,\r\n            uint256[] memory stakedSlates,\r\n            uint256 lastStaked,\r\n            uint256 voteWinner,\r\n            uint256 voteRunnerUp,\r\n            uint256 winner\r\n        ) {\r\n        Contest memory c =  ballots[epochNumber].contests[resource];\r\n\r\n        status = c.status;\r\n        allSlates = c.slates;\r\n        stakedSlates = c.stakedSlates;\r\n        lastStaked = c.lastStaked;\r\n        voteWinner = c.voteLeader;\r\n        voteRunnerUp = c.voteRunnerUp;\r\n        winner = c.winner;\r\n    }\r\n\r\n    /**\r\n     @dev Trigger a runoff and update the status of the contest\r\n\r\n     Revert if a runoff is not pending.\r\n     Eliminate all slates but the top two from the initial vote. Re-count, including the\r\n     second-choice votes for the top two slates. The slate with the most votes wins. In case\r\n     of a tie, the earliest slate submitted (slate with the lowest ID) wins.\r\n\r\n     @param epochNumber The epoch\r\n     @param resource The resource to count votes for\r\n     */\r\n    function _finalizeRunoff(uint epochNumber, address resource) internal {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n\r\n        uint voteLeader = contest.voteLeader;\r\n        uint voteRunnerUp = contest.voteRunnerUp;\r\n\r\n        // Get the number of second-choice votes for the top two choices, subtracting\r\n        // any second choice votes where the first choice was for one of the top two\r\n        SlateVotes storage leader = contest.votes[voteLeader];\r\n        SlateVotes storage runnerUp = contest.votes[voteRunnerUp];\r\n\r\n        uint256 secondChoiceVotesForLeader = leader.totalSecondChoiceVotes\r\n            .sub(runnerUp.secondChoiceVotes[voteLeader]).sub(leader.secondChoiceVotes[voteLeader]);\r\n\r\n        uint256 secondChoiceVotesForRunnerUp = runnerUp.totalSecondChoiceVotes\r\n            .sub(leader.secondChoiceVotes[voteRunnerUp]).sub(runnerUp.secondChoiceVotes[voteRunnerUp]);\r\n\r\n        uint256 leaderTotal = contest.leaderVotes.add(secondChoiceVotesForLeader);\r\n        uint256 runnerUpTotal = contest.runnerUpVotes.add(secondChoiceVotesForRunnerUp);\r\n\r\n\r\n        // Tally for the runoff\r\n        uint runoffWinner = 0;\r\n        uint runoffWinnerVotes = 0;\r\n        uint runoffLoser = 0;\r\n        uint runoffLoserVotes = 0;\r\n\r\n        // Original winner has more votes, or it's tied and the original winner has a smaller ID\r\n        if ((leaderTotal > runnerUpTotal) ||\r\n           ((leaderTotal == runnerUpTotal) &&\r\n            (voteLeader < voteRunnerUp)\r\n            )) {\r\n            runoffWinner = voteLeader;\r\n            runoffWinnerVotes = leaderTotal;\r\n            runoffLoser = voteRunnerUp;\r\n            runoffLoserVotes = runnerUpTotal;\r\n        } else {\r\n            runoffWinner = voteRunnerUp;\r\n            runoffWinnerVotes = runnerUpTotal;\r\n            runoffLoser = voteLeader;\r\n            runoffLoserVotes = leaderTotal;\r\n        }\r\n\r\n        // Update state\r\n        contest.winner = runoffWinner;\r\n        contest.status = ContestStatus.Finalized;\r\n        acceptSlate(runoffWinner);\r\n\r\n        emit RunoffFinalized(epochNumber, resource, runoffWinner, runoffWinnerVotes, runoffLoser, runoffLoserVotes);\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Send tokens of the rejected slates to the token capacitor.\r\n     @param epochNumber The epoch\r\n     @param resource The resource\r\n     */\r\n    function donateChallengerStakes(uint256 epochNumber, address resource, uint256 startIndex, uint256 count) public {\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n        require(contest.status == ContestStatus.Finalized, \"Contest is not finalized\");\r\n\r\n        uint256 numSlates = contest.stakedSlates.length;\r\n        require(contest.stakesDonated != numSlates, \"All stakes donated\");\r\n\r\n        // If there are still stakes to be donated, continue\r\n        require(startIndex == contest.stakesDonated, \"Invalid start index\");\r\n\r\n        uint256 endIndex = startIndex.add(count);\r\n        require(endIndex <= numSlates, \"Invalid end index\");\r\n\r\n        address stakeDonationAddress = parameters.getAsAddress(\"stakeDonationAddress\");\r\n        IDonationReceiver donationReceiver = IDonationReceiver(stakeDonationAddress);\r\n        bytes memory stakeDonationHash = \"Qmepxeh4KVkyHYgt3vTjmodB5RKZgUEmdohBZ37oKXCUCm\";\r\n\r\n        for (uint256 i = startIndex; i < endIndex; i++) {\r\n            uint256 slateID = contest.stakedSlates[i];\r\n            Slate storage slate = slates[slateID];\r\n            if (slate.status != SlateStatus.Accepted) {\r\n                uint256 donationAmount = slate.stake;\r\n                slate.stake = 0;\r\n\r\n                // Only donate for non-zero amounts\r\n                if (donationAmount > 0) {\r\n                    require(\r\n                        token.approve(address(donationReceiver), donationAmount),\r\n                        \"Failed to approve Gatekeeper to spend tokens\"\r\n                    );\r\n                    donationReceiver.donate(address(this), donationAmount, stakeDonationHash);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update state\r\n        contest.stakesDonated = endIndex;\r\n    }\r\n\r\n    /**\r\n     @dev Return the ID of the winning slate for the given epoch and resource\r\n     Revert if the vote has not been finalized yet.\r\n     @param epochNumber The epoch\r\n     @param resource The resource of interest\r\n     */\r\n    function getWinningSlate(uint epochNumber, address resource) public view returns(uint) {\r\n        Contest storage c = ballots[epochNumber].contests[resource];\r\n        require(c.status == ContestStatus.Finalized, \"Vote is not finalized yet\");\r\n\r\n        return c.winner;\r\n    }\r\n\r\n\r\n    // ACCESS CONTROL\r\n    /**\r\n    @dev Request permission to perform the action described in the metadataHash\r\n    @param metadataHash A reference to metadata about the action\r\n    */\r\n    function requestPermission(bytes memory metadataHash) public returns(uint) {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n        address resource = msg.sender;\r\n        uint256 epochNumber = currentEpochNumber();\r\n\r\n        require(slateSubmissionPeriodActive(resource), \"Submission period not active\");\r\n\r\n        // If the request is created in epoch n, expire at the start of epoch n + 2\r\n        uint256 expirationTime = epochStart(epochNumber.add(2));\r\n\r\n        // Create new request\r\n        Request memory r = Request({\r\n            metadataHash: metadataHash,\r\n            resource: resource,\r\n            approved: false,\r\n            expirationTime: expirationTime,\r\n            epochNumber: epochNumber\r\n        });\r\n\r\n        // Record request and return its ID\r\n        uint requestID = requestCount();\r\n        requests.push(r);\r\n\r\n        emit PermissionRequested(epochNumber, resource, requestID, metadataHash);\r\n        return requestID;\r\n    }\r\n\r\n    /**\r\n    @dev Update a slate and its associated requests\r\n    @param slateID The slate to update\r\n     */\r\n    function acceptSlate(uint slateID) private {\r\n        // Mark the slate as accepted\r\n        Slate storage s = slates[slateID];\r\n        s.status = SlateStatus.Accepted;\r\n\r\n        // Record the incumbent\r\n        if (incumbent[s.resource] != s.recommender) {\r\n            incumbent[s.resource] = s.recommender;\r\n        }\r\n\r\n        // mark all of its requests as approved\r\n        uint[] memory requestIDs = s.requests;\r\n        for (uint i = 0; i < requestIDs.length; i++) {\r\n            uint requestID = requestIDs[i];\r\n            requests[requestID].approved = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev Return true if the requestID has been approved via slate governance and has not expired\r\n    @param requestID The ID of the request to check\r\n     */\r\n    function hasPermission(uint requestID) public view returns(bool) {\r\n        return requests[requestID].approved && now < requests[requestID].expirationTime;\r\n    }\r\n\r\n\r\n    // MISCELLANEOUS GETTERS\r\n    function slateCount() public view returns(uint256) {\r\n        return slates.length;\r\n    }\r\n\r\n    function requestCount() public view returns (uint256) {\r\n        return requests.length;\r\n    }\r\n\r\n    /**\r\n    @dev Return the slate submission deadline for the given resource\r\n    @param epochNumber The epoch\r\n    @param resource The resource\r\n     */\r\n    function slateSubmissionDeadline(uint256 epochNumber, address resource) public view returns(uint256) {\r\n        Contest memory contest = ballots[epochNumber].contests[resource];\r\n        uint256 offset = (contest.lastStaked.add(COMMIT_PERIOD_START)).div(2);\r\n\r\n        return epochStart(epochNumber).add(offset);\r\n    }\r\n\r\n    /**\r\n    @dev Return true if the slate submission period is active for the given resource and the\r\n     current epoch.\r\n     */\r\n    function slateSubmissionPeriodActive(address resource) public view returns(bool) {\r\n        uint256 epochNumber = currentEpochNumber();\r\n        uint256 start = epochStart(epochNumber).add(SLATE_SUBMISSION_PERIOD_START);\r\n        uint256 end = slateSubmissionDeadline(epochNumber, resource);\r\n\r\n        return (start <= now) && (now < end);\r\n    }\r\n\r\n    /**\r\n    @dev Return true if the commit period is active for the current epoch\r\n     */\r\n    function commitPeriodActive() private view returns(bool) {\r\n        uint256 epochTime = now.sub(epochStart(currentEpochNumber()));\r\n        return (COMMIT_PERIOD_START <= epochTime) && (epochTime < REVEAL_PERIOD_START);\r\n    }\r\n\r\n    /**\r\n    @dev Return true if this is the Gatekeeper currently pointed to by the ParameterStore\r\n     */\r\n    function isCurrentGatekeeper() public view returns(bool) {\r\n        return parameters.getAsAddress(\"gatekeeperAddress\") == address(this);\r\n    }\r\n}\r\n\r\n\r\ncontract TokenCapacitor is IDonationReceiver {\r\n    // EVENTS\r\n    event ProposalCreated(\r\n        uint256 proposalID,\r\n        address indexed proposer,\r\n        uint requestID,\r\n        address indexed recipient,\r\n        uint tokens,\r\n        bytes metadataHash\r\n    );\r\n    event TokensWithdrawn(uint proposalID, address indexed to, uint numTokens);\r\n    event BalancesUpdated(\r\n        uint unlockedBalance,\r\n        uint lastLockedBalance,\r\n        uint lastLockedTime,\r\n        uint totalBalance\r\n    );\r\n\r\n    // STATE\r\n    using SafeMath for uint;\r\n\r\n    // The address of the associated ParameterStore contract\r\n    ParameterStore public parameters;\r\n\r\n    // The address of the associated token\r\n    IERC20 public token;\r\n\r\n    struct Proposal {\r\n        address gatekeeper;\r\n        uint256 requestID;\r\n        uint tokens;\r\n        address to;\r\n        bytes metadataHash;\r\n        bool withdrawn;\r\n    }\r\n\r\n    // The proposals created for the TokenCapacitor.\r\n    Proposal[] public proposals;\r\n\r\n    // Token decay table\r\n    uint256 public constant SCALE = 10 ** 12;\r\n    uint256[12] decayMultipliers;\r\n    uint256 constant MAX_UPDATE_DAYS = 4095; // 2^12 - 1\r\n    uint256 constant ONE_DAY_SECONDS = 86400;\r\n\r\n    // Balances\r\n    // Tokens available for withdrawal\r\n    uint256 public unlockedBalance;\r\n\r\n    // The number of tokens locked as of the last update\r\n    uint256 public lastLockedBalance;\r\n\r\n    // The last time tokens were locked\r\n    uint256 public lastLockedTime;\r\n\r\n    // The total number of tokens released in the lifetime of the TokenCapacitor\r\n    uint256 public lifetimeReleasedTokens;\r\n\r\n    // IMPLEMENTATION\r\n    constructor(ParameterStore _parameters, IERC20 _token, Gatekeeper _currentGatekeeper, uint256 initialUnlockedBalance) public {\r\n        require(address(_parameters) != address(0), \"Parameter store address cannot be zero\");\r\n        parameters = _parameters;\r\n\r\n        require(address(_token) != address(0), \"Token address cannot be zero\");\r\n        token = _token;\r\n\r\n        require(address(_currentGatekeeper) != address(0), \"Gatekeeper address cannot be zero\");\r\n\r\n        // initialize multipliers\r\n        decayMultipliers[0] = 999524050675;\r\n        decayMultipliers[1] = 999048327879;\r\n        decayMultipliers[2] = 998097561438;\r\n        decayMultipliers[3] = 996198742149;\r\n        decayMultipliers[4] = 992411933860;\r\n        decayMultipliers[5] = 984881446469;\r\n        decayMultipliers[6] = 969991463599;\r\n        decayMultipliers[7] = 940883439455;\r\n        decayMultipliers[8] = 885261646641;\r\n        decayMultipliers[9] = 783688183013;\r\n        decayMultipliers[10] = 614167168195;\r\n        decayMultipliers[11] = 377201310488;\r\n\r\n        unlockedBalance = initialUnlockedBalance;\r\n\r\n        // initialize update time at an even number of days relative to gatekeeper start\r\n        lastLockedTime = _currentGatekeeper.startTime();\r\n        lastLockedTime = lastLockedTime.add(_adjustedElapsedTime(now));\r\n    }\r\n\r\n    function _gatekeeper() private view returns(Gatekeeper) {\r\n        return Gatekeeper(parameters.getAsAddress(\"gatekeeperAddress\"));\r\n    }\r\n\r\n    function _createProposal(Gatekeeper gatekeeper, address to, uint tokens, bytes memory metadataHash) internal returns(uint256) {\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n\r\n        Proposal memory p = Proposal({\r\n            gatekeeper: address(gatekeeper),\r\n            requestID: 0,\r\n            tokens: tokens,\r\n            to: to,\r\n            metadataHash: metadataHash,\r\n            withdrawn: false\r\n        });\r\n\r\n        // Request permission from the Gatekeeper and store the proposal data for later.\r\n        // If the request is approved, a user can execute the proposal by providing the\r\n        // proposalID.\r\n        uint requestID = gatekeeper.requestPermission(metadataHash);\r\n        p.requestID = requestID;\r\n        uint proposalID = proposalCount();\r\n        proposals.push(p);\r\n\r\n        emit ProposalCreated(proposalID, msg.sender, requestID, to, tokens, metadataHash);\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     @dev Create a proposal to send tokens to a beneficiary.\r\n     @param to The account to send the tokens to\r\n     @param tokens The number of tokens to send\r\n     @param metadataHash A reference to metadata describing the proposal\r\n    */\r\n    function createProposal(address to, uint tokens, bytes calldata metadataHash) external returns(uint) {\r\n        Gatekeeper gatekeeper = _gatekeeper();\r\n        return _createProposal(gatekeeper, to, tokens, metadataHash);\r\n    }\r\n\r\n    /**\r\n     @dev Create multiple proposals to send tokens to beneficiaries.\r\n     @param beneficiaries The accounts to send tokens to\r\n     @param tokenAmounts The number of tokens to send to each beneficiary\r\n     @param metadataHashes Metadata hashes describing the proposals\r\n    */\r\n    function createManyProposals(\r\n        address[] calldata beneficiaries,\r\n        uint[] calldata tokenAmounts,\r\n        bytes[] calldata metadataHashes\r\n    ) external {\r\n        require(\r\n            beneficiaries.length == tokenAmounts.length && tokenAmounts.length == metadataHashes.length,\r\n            \"All inputs must have the same length\"\r\n        );\r\n\r\n        Gatekeeper gatekeeper = _gatekeeper();\r\n        for (uint i = 0; i < beneficiaries.length; i++) {\r\n            address to = beneficiaries[i];\r\n            uint tokens = tokenAmounts[i];\r\n            bytes memory metadataHash = metadataHashes[i];\r\n            _createProposal(gatekeeper, to, tokens, metadataHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev Withdraw tokens associated with a proposal and send them to the named beneficiary. The\r\n    proposal must have been included in an accepted grant slate.\r\n    @param proposalID The proposal\r\n    */\r\n    function withdrawTokens(uint proposalID) public returns(bool) {\r\n        require(proposalID < proposalCount(), \"Invalid proposalID\");\r\n\r\n        Proposal memory p = proposals[proposalID];\r\n        Gatekeeper gatekeeper = Gatekeeper(p.gatekeeper);\r\n\r\n        require(gatekeeper.hasPermission(p.requestID), \"Proposal has not been approved\");\r\n        require(p.withdrawn == false, \"Tokens have already been withdrawn for this proposal\");\r\n\r\n        proposals[proposalID].withdrawn = true;\r\n\r\n        // Accounting\r\n        updateBalances();\r\n        // Withdrawn tokens come out of the unlocked balance\r\n        require(unlockedBalance >= p.tokens, \"Insufficient unlocked tokens\");\r\n        unlockedBalance = unlockedBalance.sub(p.tokens);\r\n\r\n        lifetimeReleasedTokens = lifetimeReleasedTokens.add(p.tokens);\r\n\r\n        require(token.transfer(p.to, p.tokens), \"Failed to transfer tokens\");\r\n        emit TokensWithdrawn(proposalID, p.to, p.tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @dev Donate tokens on behalf of the given donor.\r\n    Donor of `address(0)` indicates an unspecified donor.\r\n    @param donor The account on behalf of which this donation is being made\r\n    @param tokens The number of tokens to donate\r\n    @param metadataHash A reference to metadata describing the donation\r\n     */\r\n    function donate(address donor, uint tokens, bytes memory metadataHash) public returns(bool) {\r\n        require(tokens > 0, \"Cannot donate zero tokens\");\r\n\r\n        address payer = msg.sender;\r\n\r\n        // Donations go into the locked balance\r\n        updateBalances();\r\n        lastLockedBalance = lastLockedBalance.add(tokens);\r\n\r\n        // transfer tokens from payer\r\n        require(token.transferFrom(payer, address(this), tokens), \"Failed to transfer tokens\");\r\n\r\n        emit Donation(payer, donor, tokens, metadataHash);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Number of tokens that will be unlocked by the given (future) time, not counting\r\n     donations or withdrawals\r\n     @param time The time to project for. Must after the lastLockedTime.\r\n     */\r\n    function projectedUnlockedBalance(uint256 time) public view returns(uint256) {\r\n        uint256 futureUnlocked = lastLockedBalance.sub(projectedLockedBalance(time));\r\n        return unlockedBalance.add(futureUnlocked);\r\n    }\r\n\r\n    /**\r\n     @dev Number of tokens that will be locked by the given (future) time, not counting\r\n     donations or withdrawals\r\n     @param time The time to project for. Must be after the lastLockedTime.\r\n     */\r\n    function projectedLockedBalance(uint256 time) public view returns(uint256) {\r\n        require(time >= lastLockedTime, \"Time cannot be before last locked\");\r\n        uint256 elapsedTime = time.sub(lastLockedTime);\r\n\r\n        // Based on the elapsed time (in days), calculate the decay factor\r\n        uint256 decayFactor = calculateDecay(elapsedTime.div(ONE_DAY_SECONDS));\r\n\r\n        return lastLockedBalance.mul(decayFactor).div(SCALE);\r\n    }\r\n\r\n    /**\r\n     @dev Return a scaled decay multiplier. Multiply by the balance, then divide by the scale.\r\n     */\r\n    function calculateDecay(uint256 _days) public view returns(uint256) {\r\n        require(_days <= MAX_UPDATE_DAYS, \"Time interval too large\");\r\n\r\n        uint256 decay = SCALE;\r\n        uint256 d = _days;\r\n\r\n        for (uint256 i = 0; i < decayMultipliers.length; i++) {\r\n           uint256 remainder = d % 2;\r\n           uint256 quotient = d >> 1;\r\n\r\n           if (remainder == 1) {\r\n                uint256 multiplier = decayMultipliers[i];\r\n                decay = decay.mul(multiplier).div(SCALE);\r\n           } else if (quotient == 0) {\r\n               // Exit early if both quotient and remainder are zero\r\n               break;\r\n           }\r\n\r\n           d = quotient;\r\n        }\r\n\r\n        return decay;\r\n    }\r\n\r\n    /**\r\n     @dev Update the locked and unlocked balances according to the release rate, taking into account\r\n     any donations or withdrawals since the last update. At each step, start decaying anew from the\r\n     lastLockedBalance, as if it were the initial balance.\r\n     @param time The time to update until. Must be less than 4096 days from the lastLockedTime, and\r\n     cannot be in the future.\r\n     */\r\n    function _updateBalancesUntil(uint256 time) internal {\r\n        require(time <= now, \"No future updates\");\r\n\r\n        uint256 totalBalance = token.balanceOf(address(this));\r\n\r\n        uint256 elapsedTime = _adjustedElapsedTime(time);\r\n        assert(elapsedTime % ONE_DAY_SECONDS == 0);\r\n\r\n        // This is the actual time we are updating until\r\n        uint256 nextLockedTime = lastLockedTime.add(elapsedTime);\r\n\r\n        // Sweep the released tokens from locked into unlocked\r\n        // Locked balance is based on the decay since the last update\r\n        uint256 newLockedBalance = projectedLockedBalance(nextLockedTime);\r\n        assert(newLockedBalance <= lastLockedBalance);\r\n\r\n        // Calculate the number of tokens unlocked since the last update\r\n        unlockedBalance = lastLockedBalance.sub(newLockedBalance).add(unlockedBalance);\r\n\r\n        // Lock any tokens not currently unlocked\r\n        lastLockedBalance = totalBalance.sub(unlockedBalance);\r\n\r\n        lastLockedTime = nextLockedTime;\r\n        emit BalancesUpdated(unlockedBalance, lastLockedBalance, nextLockedTime, totalBalance);\r\n    }\r\n\r\n    /**\r\n     @dev Update the locked and unlocked balances up until `now`. If necessary, update in intervals\r\n     of 4095 days.\r\n     */\r\n    function updateBalances() public {\r\n        uint256 timeLeft = now.sub(lastLockedTime);\r\n        uint256 daysLeft = timeLeft.div(ONE_DAY_SECONDS);\r\n\r\n        // Catch up in intervals of 4095 days\r\n        if (daysLeft > MAX_UPDATE_DAYS) {\r\n            uint256 chunks = daysLeft.div(MAX_UPDATE_DAYS);\r\n            uint256 chunkDuration = MAX_UPDATE_DAYS.mul(ONE_DAY_SECONDS);\r\n\r\n            for (uint256 i = 0; i < chunks; i++) {\r\n                _updateBalancesUntil(lastLockedTime.add(chunkDuration));\r\n            }\r\n        }\r\n\r\n        // Process the rest of the time left\r\n        _updateBalancesUntil(now);\r\n    }\r\n\r\n    function proposalCount() public view returns(uint256) {\r\n        return proposals.length;\r\n    }\r\n\r\n    /**\r\n     @dev Get the amount of time elapsed since the last update, adjusted down to the nearest day.\r\n     @param time The time to calculate for. Must be after the lastLockedTime.\r\n     */\r\n    function _adjustedElapsedTime(uint256 time) private view returns(uint256) {\r\n        uint256 elapsedTime = time.sub(lastLockedTime);\r\n        return elapsedTime.sub(elapsedTime.mod(ONE_DAY_SECONDS));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gatekeeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"calculateDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"metadataHashes\",\"type\":\"bytes[]\"}],\"name\":\"createManyProposals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"projectedUnlockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"donor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"donate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"createProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"contract ParameterStore\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastLockedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lifetimeReleasedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastLockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"projectedLockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ParameterStore\",\"name\":\"_parameters\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract Gatekeeper\",\"name\":\"_currentGatekeeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialUnlockedBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastLockedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastLockedTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"BalancesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"Donation\",\"type\":\"event\"}]","ContractName":"TokenCapacitor","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006a43334331dc689318af551b0cfd624a8b11a70b000000000000000000000000d56dac73a4d6766464b38ec6d91eb45ce7457c4400000000000000000000000021c3fac9b5bf2738909c32ce8e086c2a5e6f5711000000000000000000000000000000000000000000005a2c1810d0d716033640","Library":"","SwarmSource":"bzzr://a8190f9e5ca5912f0fed81aa1076398369fe605be4a758964c1f5395c88e489a"}]}