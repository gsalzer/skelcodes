{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Modifiable {\n    \n    \n    \n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\ncontract SelfDestructible {\n    \n    \n    \n    bool public selfDestructionDisabled;\n\n    \n    \n    \n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address);\n\n    \n    \n    function disableSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        selfDestructionDisabled = true;\n\n        \n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    \n    function triggerSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        require(!selfDestructionDisabled);\n\n        \n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        \n        selfdestruct(msg.sender);\n    }\n}\n\ncontract Ownable is Modifiable, SelfDestructible {\n    \n    \n    \n    address public deployer;\n    address public operator;\n\n    \n    \n    \n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    \n    \n    \n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    \n    \n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            \n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            \n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    \n    \n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            \n            address oldOperator = operator;\n            operator = newOperator;\n\n            \n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    \n    \n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    \n    \n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    \n    \n    \n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    \n    \n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\ncontract Servable is Ownable {\n    \n    \n    \n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    \n    \n    \n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    \n    \n    \n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    \n    \n    \n    \n    \n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        \n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    \n    \n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        \n        emit RegisterServiceEvent(service);\n    }\n\n    \n    \n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        \n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    \n    \n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        \n        emit DeregisterServiceEvent(service);\n    }\n\n    \n    \n    \n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        \n        emit EnableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        \n        emit DisableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    \n    \n    \n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    \n    \n    \n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    \n    \n    \n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    \n    \n    \n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    \n    \n    \n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    \n    \n    \n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        \n        require(b != - 1 || a != INT256_MIN);\n        \n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    \n    \n    \n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    \n    \n    \n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary BlockNumbUintsLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        uint256 value;\n    }\n\n    struct BlockNumbUints {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbUintsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbUintsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary BlockNumbIntsLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        int256 value;\n    }\n\n    struct BlockNumbInts {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbIntsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbIntsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary ConstantsLib {\n    \n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\nlibrary BlockNumbDisdIntsLib {\n    using SafeMathIntLib for int256;\n\n    \n    \n    \n    struct Discount {\n        int256 tier;\n        int256 value;\n    }\n\n    struct Entry {\n        uint256 blockNumber;\n        int256 nominal;\n        Discount[] discounts;\n    }\n\n    struct BlockNumbDisdInts {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentNominalValue(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return nominalValueAt(self, block.number);\n    }\n\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        return discountedValueAt(self, block.number, tier);\n    }\n\n    function currentEntry(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).nominal;\n    }\n\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        Entry memory entry = entryAt(self, _blockNumber);\n        if (0 < entry.discounts.length) {\n            uint256 index = indexByTier(entry.discounts, tier);\n            if (0 < index)\n                return entry.nominal.mul(\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\n                ).div(\n                    ConstantsLib.PARTS_PER()\n                );\n            else\n                return entry.nominal;\n        } else\n            return entry.nominal;\n    }\n\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbDisdIntsLib.sol:101]\"\n        );\n\n        self.entries.length++;\n        Entry storage entry = self.entries[self.entries.length - 1];\n\n        entry.blockNumber = blockNumber;\n        entry.nominal = nominal;\n    }\n\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    internal\n    {\n        require(discountTiers.length == discountValues.length, \"Parameter array lengths mismatch [BlockNumbDisdIntsLib.sol:118]\");\n\n        addNominalEntry(self, blockNumber, nominal);\n\n        Entry storage entry = self.entries[self.entries.length - 1];\n        for (uint256 i = 0; i < discountTiers.length; i++)\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\n    }\n\n    function count(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbDisdIntsLib.sol:148]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    \n    function indexByTier(Discount[] memory discounts, int256 tier)\n    internal\n    pure\n    returns (uint256)\n    {\n        require(0 < discounts.length, \"No discounts found [BlockNumbDisdIntsLib.sol:161]\");\n        for (uint256 i = discounts.length; i > 0; i--)\n            if (tier >= discounts[i - 1].tier)\n                return i;\n        return 0;\n    }\n}\n\nlibrary MonetaryTypesLib {\n    \n    \n    \n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\nlibrary BlockNumbReferenceCurrenciesLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Currency currency;\n    }\n\n    struct BlockNumbReferenceCurrencies {\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\n    }\n\n    \n    \n    \n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return currencyAt(self, referenceCurrency, block.number);\n    }\n\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, referenceCurrency, block.number);\n    }\n\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\n    }\n\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\n        MonetaryTypesLib.Currency memory referenceCurrency, MonetaryTypesLib.Currency memory currency)\n    internal\n    {\n        require(\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\n        blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber,\n            \"Later entry found for currency [BlockNumbReferenceCurrenciesLib.sol:67]\"\n        );\n\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\n    }\n\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\n    }\n\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\n    }\n\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length, \"No entries found for currency [BlockNumbReferenceCurrenciesLib.sol:97]\");\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary BlockNumbFiguresLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Figure value;\n    }\n\n    struct BlockNumbFigures {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbFigures storage self)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure memory value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbFiguresLib.sol:65]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbFigures storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbFiguresLib.sol:95]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\ncontract Configuration is Modifiable, Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\n\n    \n    \n    \n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\n\n    \n    \n    \n    enum OperationalMode {Normal, Exit}\n\n    \n    \n    \n    OperationalMode public operationalMode = OperationalMode.Normal;\n\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\n\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\n\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\n\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\n\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\n\n    uint256 public earliestSettlementBlockNumber;\n    bool public earliestSettlementBlockNumberUpdateDisabled;\n\n    \n    \n    \n    event SetOperationalModeExitEvent();\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] discountTiers, int256[] discountValues);\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId);\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\n        uint256 stakeCurrencyId);\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\n    }\n\n    \n    \n    \n    \n    \n    function setOperationalModeExit()\n    public\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\n    {\n        operationalMode = OperationalMode.Exit;\n        emit SetOperationalModeExitEvent();\n    }\n\n    \n    function isOperationalModeNormal()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Normal == operationalMode;\n    }\n\n    \n    function isOperationalModeExit()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Exit == operationalMode;\n    }\n\n    \n    \n    function updateDelayBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.currentValue();\n    }\n\n    \n    \n    function updateDelayBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.count();\n    }\n\n    \n    \n    \n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\n    }\n\n    \n    \n    function confirmationBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.currentValue();\n    }\n\n    \n    \n    function confirmationBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.count();\n    }\n\n    \n    \n    \n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\n    }\n\n    \n    function tradeMakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    function tradeTakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    function paymentFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function paymentFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    \n    \n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    \n    \n    \n    \n    \n    \n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\n                blockNumber, discountTier\n            );\n        else\n            return paymentFee(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }\n\n    \n    function tradeMakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function tradeMakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    function tradeTakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function tradeTakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    function paymentMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function paymentMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    \n    \n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    \n    \n    \n    \n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\n        else\n            return paymentMinimumFee(blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\n    }\n\n    \n    \n    \n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n\n    \n    \n    \n    \n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address ct, uint256 id)\n    {\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\n        );\n        ct = _feeCurrency.ct;\n        id = _feeCurrency.id;\n    }\n\n    \n    \n    \n    \n    \n    \n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        feeCurrencyByCurrencyBlockNumber.addEntry(\n            fromBlockNumber,\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\n        );\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\n            feeCurrencyCt, feeCurrencyId);\n    }\n\n    \n    \n    function walletLockTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return walletLockTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function cancelOrderChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function settlementChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function fraudStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function walletSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function operatorSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function operatorSettlementStake()\n    public\n    view\n    returns (int256 amount, address currencyCt, uint256 currencyId)\n    {\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\n        amount = stake.amount;\n        currencyCt = stake.currency.ct;\n        currencyId = stake.currency.id;\n    }\n\n    \n    \n    \n    \n    \n    \n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\n    }\n\n    \n    \n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\n    public\n    onlyOperator\n    {\n        require(!earliestSettlementBlockNumberUpdateDisabled, \"Earliest settlement block number update disabled [Configuration.sol:715]\");\n\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\n    }\n\n    \n    \n    function disableEarliestSettlementBlockNumberUpdate()\n    public\n    onlyOperator\n    {\n        earliestSettlementBlockNumberUpdateDisabled = true;\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\n    }\n\n    \n    \n    \n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\n        require(\n            0 == updateDelayBlocksByBlockNumber.count() ||\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue(),\n            \"Block number not sufficiently delayed [Configuration.sol:735]\"\n        );\n        _;\n    }\n}\n\ncontract Configurable is Ownable {\n    \n    \n    \n    Configuration public configuration;\n\n    \n    \n    \n    event SetConfigurationEvent(Configuration oldConfiguration, Configuration newConfiguration);\n\n    \n    \n    \n    \n    \n    function setConfiguration(Configuration newConfiguration)\n    public\n    onlyDeployer\n    notNullAddress(address(newConfiguration))\n    notSameAddresses(address(newConfiguration), address(configuration))\n    {\n        \n        Configuration oldConfiguration = configuration;\n        configuration = newConfiguration;\n\n        \n        emit SetConfigurationEvent(oldConfiguration, newConfiguration);\n    }\n\n    \n    \n    \n    modifier configurationInitialized() {\n        require(address(configuration) != address(0), \"Configuration not initialized [Configurable.sol:52]\");\n        _;\n    }\n}\n\ncontract ConfigurableOperational is Configurable {\n    \n    \n    \n    modifier onlyOperationalModeNormal() {\n        require(configuration.isOperationalModeNormal(), \"Operational mode is not normal [ConfigurableOperational.sol:22]\");\n        _;\n    }\n}\n\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        \n        uint256 c = a / b;\n        \n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary NahmiiTypesLib {\n    \n    \n    \n    enum ChallengePhase {Dispute, Closed}\n\n    \n    \n    \n    struct OriginFigure {\n        uint256 originId;\n        MonetaryTypesLib.Figure figure;\n    }\n\n    struct IntendedConjugateCurrency {\n        MonetaryTypesLib.Currency intended;\n        MonetaryTypesLib.Currency conjugate;\n    }\n\n    struct SingleFigureTotalOriginFigures {\n        MonetaryTypesLib.Figure single;\n        OriginFigure[] total;\n    }\n\n    struct TotalOriginFigures {\n        OriginFigure[] total;\n    }\n\n    struct CurrentPreviousInt256 {\n        int256 current;\n        int256 previous;\n    }\n\n    struct SingleTotalInt256 {\n        int256 single;\n        int256 total;\n    }\n\n    struct IntendedConjugateCurrentPreviousInt256 {\n        CurrentPreviousInt256 intended;\n        CurrentPreviousInt256 conjugate;\n    }\n\n    struct IntendedConjugateSingleTotalInt256 {\n        SingleTotalInt256 intended;\n        SingleTotalInt256 conjugate;\n    }\n\n    struct WalletOperatorHashes {\n        bytes32 wallet;\n        bytes32 operator;\n    }\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    struct Seal {\n        bytes32 hash;\n        Signature signature;\n    }\n\n    struct WalletOperatorSeal {\n        Seal wallet;\n        Seal operator;\n    }\n}\n\nlibrary PaymentTypesLib {\n    \n    \n    \n    enum PaymentPartyRole {Sender, Recipient}\n\n    \n    \n    \n    struct PaymentSenderParty {\n        uint256 nonce;\n        address wallet;\n\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\n\n        string data;\n    }\n\n    struct PaymentRecipientParty {\n        uint256 nonce;\n        address wallet;\n\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.TotalOriginFigures fees;\n    }\n\n    struct Operator {\n        uint256 id;\n        string data;\n    }\n\n    struct Payment {\n        int256 amount;\n        MonetaryTypesLib.Currency currency;\n\n        PaymentSenderParty sender;\n        PaymentRecipientParty recipient;\n\n        \n        NahmiiTypesLib.SingleTotalInt256 transfers;\n\n        NahmiiTypesLib.WalletOperatorSeal seals;\n        uint256 blockNumber;\n\n        Operator operator;\n    }\n\n    \n    \n    \n    function PAYMENT_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"payment\";\n    }\n}\n\ncontract PaymentHasher is Ownable {\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }\n\n    function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }\n\n    function hashPaymentAmountCurrency(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                payment.amount,\n                payment.currency.ct,\n                payment.currency.id\n            ));\n    }\n\n    function hashPaymentSenderPartyAsWallet(\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                paymentSenderParty.wallet,\n                paymentSenderParty.data\n            ));\n    }\n\n    function hashPaymentSenderPartyAsOperator(\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 rootHash = hashUint256(paymentSenderParty.nonce);\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentSenderParty.balances);\n        bytes32 singleFeeHash = hashFigure(paymentSenderParty.fees.single);\n        bytes32 totalFeesHash = hashOriginFigures(paymentSenderParty.fees.total);\n\n        return keccak256(abi.encodePacked(\n                rootHash, balancesHash, singleFeeHash, totalFeesHash\n            ));\n    }\n\n    function hashPaymentRecipientPartyAsOperator(\n        PaymentTypesLib.PaymentRecipientParty memory paymentRecipientParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 rootHash = hashUint256(paymentRecipientParty.nonce);\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentRecipientParty.balances);\n        bytes32 totalFeesHash = hashOriginFigures(paymentRecipientParty.fees.total);\n\n        return keccak256(abi.encodePacked(\n                rootHash, balancesHash, totalFeesHash\n            ));\n    }\n\n    function hashCurrentPreviousInt256(\n        NahmiiTypesLib.CurrentPreviousInt256 memory currentPreviousInt256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                currentPreviousInt256.current,\n                currentPreviousInt256.previous\n            ));\n    }\n\n    function hashSingleTotalInt256(\n        NahmiiTypesLib.SingleTotalInt256 memory singleTotalInt256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                singleTotalInt256.single,\n                singleTotalInt256.total\n            ));\n    }\n\n    function hashFigure(MonetaryTypesLib.Figure memory figure)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                figure.amount,\n                figure.currency.ct,\n                figure.currency.id\n            ));\n    }\n\n    function hashOriginFigures(NahmiiTypesLib.OriginFigure[] memory originFigures)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 hash;\n        for (uint256 i = 0; i < originFigures.length; i++) {\n            hash = keccak256(abi.encodePacked(\n                    hash,\n                    originFigures[i].originId,\n                    originFigures[i].figure.amount,\n                    originFigures[i].figure.currency.ct,\n                    originFigures[i].figure.currency.id\n                )\n            );\n        }\n        return hash;\n    }\n\n    function hashUint256(uint256 _uint256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_uint256));\n    }\n\n    function hashString(string memory _string)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    function hashAddress(address _address)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_address));\n    }\n\n    function hashSignature(NahmiiTypesLib.Signature memory signature)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                signature.v,\n                signature.r,\n                signature.s\n            ));\n    }\n}\n\ncontract PaymentHashable is Ownable {\n    \n    \n    \n    PaymentHasher public paymentHasher;\n\n    \n    \n    \n    event SetPaymentHasherEvent(PaymentHasher oldPaymentHasher, PaymentHasher newPaymentHasher);\n\n    \n    \n    \n    \n    \n    function setPaymentHasher(PaymentHasher newPaymentHasher)\n    public\n    onlyDeployer\n    notNullAddress(address(newPaymentHasher))\n    notSameAddresses(address(newPaymentHasher), address(paymentHasher))\n    {\n        \n        PaymentHasher oldPaymentHasher = paymentHasher;\n        paymentHasher = newPaymentHasher;\n\n        \n        emit SetPaymentHasherEvent(oldPaymentHasher, newPaymentHasher);\n    }\n\n    \n    \n    \n    modifier paymentHasherInitialized() {\n        require(address(paymentHasher) != address(0), \"Payment hasher not initialized [PaymentHashable.sol:52]\");\n        _;\n    }\n}\n\ncontract SignerManager is Ownable {\n    using SafeMathUintLib for uint256;\n    \n    \n    \n    \n    mapping(address => uint256) public signerIndicesMap; \n    address[] public signers;\n\n    \n    \n    \n    event RegisterSignerEvent(address signer);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        registerSigner(deployer);\n    }\n\n    \n    \n    \n    \n    \n    \n    function isSigner(address _address)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < signerIndicesMap[_address];\n    }\n\n    \n    \n    function signersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return signers.length;\n    }\n\n    \n    \n    \n    function signerIndex(address _address)\n    public\n    view\n    returns (uint256)\n    {\n        require(isSigner(_address), \"Address not signer [SignerManager.sol:71]\");\n        return signerIndicesMap[_address] - 1;\n    }\n\n    \n    \n    function registerSigner(address newSigner)\n    public\n    onlyOperator\n    notNullOrThisAddress(newSigner)\n    {\n        if (0 == signerIndicesMap[newSigner]) {\n            \n            signers.push(newSigner);\n            signerIndicesMap[newSigner] = signers.length;\n\n            \n            emit RegisterSignerEvent(newSigner);\n        }\n    }\n\n    \n    \n    \n    \n    function signersByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(0 < signers.length, \"No signers found [SignerManager.sol:101]\");\n        require(low <= up, \"Bounds parameters mismatch [SignerManager.sol:102]\");\n\n        up = up.clampMax(signers.length - 1);\n        address[] memory _signers = new address[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _signers[i - low] = signers[i];\n\n        return _signers;\n    }\n}\n\ncontract SignerManageable is Ownable {\n    \n    \n    \n    SignerManager public signerManager;\n\n    \n    \n    \n    event SetSignerManagerEvent(address oldSignerManager, address newSignerManager);\n\n    \n    \n    \n    constructor(address manager) public notNullAddress(manager) {\n        signerManager = SignerManager(manager);\n    }\n\n    \n    \n    \n    \n    \n    function setSignerManager(address newSignerManager)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newSignerManager)\n    {\n        if (newSignerManager != address(signerManager)) {\n            \n            address oldSignerManager = address(signerManager);\n            signerManager = SignerManager(newSignerManager);\n\n            \n            emit SetSignerManagerEvent(oldSignerManager, newSignerManager);\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    function ethrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n    public\n    pure\n    returns (address)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n        return ecrecover(prefixedHash, v, r, s);\n    }\n\n    \n    \n    \n    \n    \n    \n    function isSignedByRegisteredSigner(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n    public\n    view\n    returns (bool)\n    {\n        return signerManager.isSigner(ethrecover(hash, v, r, s));\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function isSignedBy(bytes32 hash, uint8 v, bytes32 r, bytes32 s, address signer)\n    public\n    pure\n    returns (bool)\n    {\n        return signer == ethrecover(hash, v, r, s);\n    }\n\n    \n    \n    modifier signerManagerInitialized() {\n        require(address(signerManager) != address(0), \"Signer manager not initialized [SignerManageable.sol:105]\");\n        _;\n    }\n}\n\ncontract Validator is Ownable, SignerManageable, Configurable, PaymentHashable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    constructor(address deployer, address signerManager) Ownable(deployer) SignerManageable(signerManager) public {\n    }\n\n    \n    \n    \n    function isGenuineOperatorSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature)\n    public\n    view\n    returns (bool)\n    {\n        return isSignedByRegisteredSigner(hash, signature.v, signature.r, signature.s);\n    }\n\n    function isGenuineWalletSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return isSignedBy(hash, signature.v, signature.r, signature.s, wallet);\n    }\n\n    function isGenuinePaymentWalletHash(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return paymentHasher.hashPaymentAsWallet(payment) == payment.seals.wallet.hash;\n    }\n\n    function isGenuinePaymentOperatorHash(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return paymentHasher.hashPaymentAsOperator(payment) == payment.seals.operator.hash;\n    }\n\n    function isGenuinePaymentWalletSeal(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletHash(payment)\n        && isGenuineWalletSignature(payment.seals.wallet.hash, payment.seals.wallet.signature, payment.sender.wallet);\n    }\n\n    function isGenuinePaymentOperatorSeal(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentOperatorHash(payment)\n        && isGenuineOperatorSignature(payment.seals.operator.hash, payment.seals.operator.signature);\n    }\n\n    function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }\n\n    \n    function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }\n\n    \n    function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }\n\n    \n    function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }\n\n    \n    function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }\n\n    \n    function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }\n\n    \n    function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }\n\n    function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }\n\n    function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }\n\n    function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }\n\n    function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }\n\n    function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }\n\n    function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }\n\n    function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }\n\n    function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }\n\n    \n    \n    \n    function getProtocolFigureByCurrency(NahmiiTypesLib.OriginFigure[] memory originFigures, MonetaryTypesLib.Currency memory currency)\n    private\n    pure\n    returns (MonetaryTypesLib.Figure memory) {\n        for (uint256 i = 0; i < originFigures.length; i++)\n            if (originFigures[i].figure.currency.ct == currency.ct && originFigures[i].figure.currency.id == currency.id\n            && originFigures[i].originId == 0)\n                return originFigures[i].figure;\n        return MonetaryTypesLib.Figure(0, currency);\n    }\n}\n\nlibrary TradeTypesLib {\n    \n    \n    \n    enum CurrencyRole {Intended, Conjugate}\n    enum LiquidityRole {Maker, Taker}\n    enum Intention {Buy, Sell}\n    enum TradePartyRole {Buyer, Seller}\n\n    \n    \n    \n    struct OrderPlacement {\n        Intention intention;\n\n        int256 amount;\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\n        int256 rate;\n\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\n    }\n\n    struct Order {\n        uint256 nonce;\n        address wallet;\n\n        OrderPlacement placement;\n\n        NahmiiTypesLib.WalletOperatorSeal seals;\n        uint256 blockNumber;\n        uint256 operatorId;\n    }\n\n    struct TradeOrder {\n        int256 amount;\n        NahmiiTypesLib.WalletOperatorHashes hashes;\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\n    }\n\n    struct TradeParty {\n        uint256 nonce;\n        address wallet;\n\n        uint256 rollingVolume;\n\n        LiquidityRole liquidityRole;\n\n        TradeOrder order;\n\n        NahmiiTypesLib.IntendedConjugateCurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\n    }\n\n    struct Trade {\n        uint256 nonce;\n\n        int256 amount;\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\n        int256 rate;\n\n        TradeParty buyer;\n        TradeParty seller;\n\n        \n        \n        NahmiiTypesLib.IntendedConjugateSingleTotalInt256 transfers;\n\n        NahmiiTypesLib.Seal seal;\n        uint256 blockNumber;\n        uint256 operatorId;\n    }\n\n    \n    \n    \n    function TRADE_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"trade\";\n    }\n\n    function ORDER_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"order\";\n    }\n}\n\ncontract Validatable is Ownable {\n    \n    \n    \n    Validator public validator;\n\n    \n    \n    \n    event SetValidatorEvent(Validator oldValidator, Validator newValidator);\n\n    \n    \n    \n    \n    \n    function setValidator(Validator newValidator)\n    public\n    onlyDeployer\n    notNullAddress(address(newValidator))\n    notSameAddresses(address(newValidator), address(validator))\n    {\n        \n        Validator oldValidator = validator;\n        validator = newValidator;\n\n        \n        emit SetValidatorEvent(oldValidator, newValidator);\n    }\n\n    \n    \n    \n    modifier validatorInitialized() {\n        require(address(validator) != address(0), \"Validator not initialized [Validatable.sol:55]\");\n        _;\n    }\n\n    modifier onlyOperatorSealedPayment(PaymentTypesLib.Payment memory payment) {\n        require(validator.isGenuinePaymentOperatorSeal(payment), \"Payment operator seal not genuine [Validatable.sol:60]\");\n        _;\n    }\n\n    modifier onlySealedPayment(PaymentTypesLib.Payment memory payment) {\n        require(validator.isGenuinePaymentSeals(payment), \"Payment seals not genuine [Validatable.sol:65]\");\n        _;\n    }\n\n    modifier onlyPaymentParty(PaymentTypesLib.Payment memory payment, address wallet) {\n        require(validator.isPaymentParty(payment, wallet), \"Wallet not payment party [Validatable.sol:70]\");\n        _;\n    }\n\n    modifier onlyPaymentSender(PaymentTypesLib.Payment memory payment, address wallet) {\n        require(validator.isPaymentSender(payment, wallet), \"Wallet not payment sender [Validatable.sol:75]\");\n        _;\n    }\n}\n\ncontract AuthorizableServable is Servable {\n    \n    \n    \n    bool public initialServiceAuthorizationDisabled;\n\n    mapping(address => bool) public initialServiceAuthorizedMap;\n    mapping(address => mapping(address => bool)) public initialServiceWalletUnauthorizedMap;\n\n    mapping(address => mapping(address => bool)) public serviceWalletAuthorizedMap;\n\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletAuthorizedMap;\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletTouchedMap;\n    mapping(address => mapping(address => bytes32[])) public serviceWalletActionList;\n\n    \n    \n    \n    event AuthorizeInitialServiceEvent(address wallet, address service);\n    event AuthorizeRegisteredServiceEvent(address wallet, address service);\n    event AuthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\n    event UnauthorizeRegisteredServiceEvent(address wallet, address service);\n    event UnauthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\n\n    \n    \n    \n    \n    \n    \n    function authorizeInitialService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(!initialServiceAuthorizationDisabled);\n        require(msg.sender != service);\n\n        \n        require(registeredServicesMap[service].registered);\n\n        \n        initialServiceAuthorizedMap[service] = true;\n\n        \n        emit AuthorizeInitialServiceEvent(msg.sender, service);\n    }\n\n    \n    \n    function disableInitialServiceAuthorization()\n    public\n    onlyDeployer\n    {\n        initialServiceAuthorizationDisabled = true;\n    }\n\n    \n    \n    \n    function authorizeRegisteredService(address service)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        \n        require(registeredServicesMap[service].registered);\n\n        \n        require(!initialServiceAuthorizedMap[service]);\n\n        \n        serviceWalletAuthorizedMap[service][msg.sender] = true;\n\n        \n        emit AuthorizeRegisteredServiceEvent(msg.sender, service);\n    }\n\n    \n    \n    \n    function unauthorizeRegisteredService(address service)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        \n        require(registeredServicesMap[service].registered);\n\n        \n        if (initialServiceAuthorizedMap[service])\n            initialServiceWalletUnauthorizedMap[service][msg.sender] = true;\n\n        \n        else {\n            serviceWalletAuthorizedMap[service][msg.sender] = false;\n            for (uint256 i = 0; i < serviceWalletActionList[service][msg.sender].length; i++)\n                serviceActionWalletAuthorizedMap[service][serviceWalletActionList[service][msg.sender][i]][msg.sender] = true;\n        }\n\n        \n        emit UnauthorizeRegisteredServiceEvent(msg.sender, service);\n    }\n\n    \n    \n    \n    \n    function isAuthorizedRegisteredService(address service, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredActiveService(service) &&\n        (isInitialServiceAuthorizedForWallet(service, wallet) || serviceWalletAuthorizedMap[service][wallet]);\n    }\n\n    \n    \n    \n    \n    function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        \n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        \n        require(!initialServiceAuthorizedMap[service]);\n\n        \n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        \n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }\n\n    \n    \n    \n    \n    function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        \n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        \n        require(!initialServiceAuthorizedMap[service]);\n\n        \n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        \n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }\n\n    \n    \n    \n    \n    \n    function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }\n\n    function isInitialServiceAuthorizedForWallet(address service, address wallet)\n    private\n    view\n    returns (bool)\n    {\n        return initialServiceAuthorizedMap[service] ? !initialServiceWalletUnauthorizedMap[service][wallet] : false;\n    }\n\n    \n    \n    \n    modifier onlyAuthorizedService(address wallet) {\n        require(isAuthorizedRegisteredService(msg.sender, wallet));\n        _;\n    }\n\n    modifier onlyAuthorizedServiceAction(string memory action, address wallet) {\n        require(isAuthorizedRegisteredServiceAction(msg.sender, action, wallet));\n        _;\n    }\n}\n\ncontract WalletLocker is Ownable, Configurable, AuthorizableServable {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    struct FungibleLock {\n        address locker;\n        address currencyCt;\n        uint256 currencyId;\n        int256 amount;\n        uint256 visibleTime;\n        uint256 unlockTime;\n    }\n\n    struct NonFungibleLock {\n        address locker;\n        address currencyCt;\n        uint256 currencyId;\n        int256[] ids;\n        uint256 visibleTime;\n        uint256 unlockTime;\n    }\n\n    \n    \n    \n    mapping(address => FungibleLock[]) public walletFungibleLocks;\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerFungibleLockIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyFungibleLockCount;\n\n    mapping(address => NonFungibleLock[]) public walletNonFungibleLocks;\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerNonFungibleLockIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyNonFungibleLockCount;\n\n    \n    \n    \n    event LockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\n    event LockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\n    event UnlockFungibleEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event UnlockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event UnlockNonFungibleEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\n        uint256 currencyId);\n    event UnlockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\n        uint256 currencyId);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n    }\n\n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    function lockFungibleByProxy(address lockedWallet, address lockerWallet, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        require(lockedWallet != lockerWallet);\n\n        \n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        \n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        \n        if (0 == lockIndex) {\n            lockIndex = ++(walletFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        \n        walletFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].amount = amount;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        \n        emit LockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        require(lockedWallet != lockerWallet);\n\n        \n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        \n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        \n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        \n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        \n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        require(\n            block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\n        );\n\n        \n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockFungibleEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        require(\n            block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\n        );\n\n        \n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockNonFungibleEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockNonFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    function fungibleLocksCount(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletFungibleLocks[wallet].length;\n    }\n\n    \n    \n    \n    function nonFungibleLocksCount(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletNonFungibleLocks[wallet].length;\n    }\n\n    \n    \n    \n    \n    \n    \n    function lockedAmount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return 0;\n\n        return walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\n    }\n\n    \n    \n    \n    \n    \n    \n    function lockedIdsCount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return 0;\n\n        return walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function lockedIdsByIndices(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId,\n        uint256 low, uint256 up)\n    public\n    view\n    returns (int256[] memory)\n    {\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return new int256[](0);\n\n        NonFungibleLock storage lock = walletNonFungibleLocks[lockedWallet][lockIndex - 1];\n\n        if (0 == lock.ids.length)\n            return new int256[](0);\n\n        up = up.clampMax(lock.ids.length - 1);\n        int256[] memory _ids = new int256[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _ids[i - low] = lock.ids[i];\n\n        return _ids;\n    }\n\n    \n    \n    \n    function isLocked(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < walletFungibleLocks[wallet].length ||\n        0 < walletNonFungibleLocks[wallet].length;\n    }\n\n    \n    \n    \n    \n    \n    function isLocked(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < walletCurrencyFungibleLockCount[wallet][currencyCt][currencyId] ||\n        0 < walletCurrencyNonFungibleLockCount[wallet][currencyCt][currencyId];\n    }\n\n    \n    \n    \n    \n    function isLocked(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] ||\n        0 < lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n    }\n\n    \n    \n    \n    \n    function _unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\n    private\n    returns (int256)\n    {\n        int256 amount = walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\n\n        if (lockIndex < walletFungibleLocks[lockedWallet].length) {\n            walletFungibleLocks[lockedWallet][lockIndex - 1] =\n            walletFungibleLocks[lockedWallet][walletFungibleLocks[lockedWallet].length - 1];\n\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\n        }\n        walletFungibleLocks[lockedWallet].length--;\n\n        lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\n\n        walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\n\n        return amount;\n    }\n\n    function _unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\n    private\n    returns (int256[] memory)\n    {\n        int256[] memory ids = walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids;\n\n        if (lockIndex < walletNonFungibleLocks[lockedWallet].length) {\n            walletNonFungibleLocks[lockedWallet][lockIndex - 1] =\n            walletNonFungibleLocks[lockedWallet][walletNonFungibleLocks[lockedWallet].length - 1];\n\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\n        }\n        walletNonFungibleLocks[lockedWallet].length--;\n\n        lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\n\n        walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\n\n        return ids;\n    }\n}\n\ncontract WalletLockable is Ownable {\n    \n    \n    \n    WalletLocker public walletLocker;\n    bool public walletLockerFrozen;\n\n    \n    \n    \n    event SetWalletLockerEvent(WalletLocker oldWalletLocker, WalletLocker newWalletLocker);\n    event FreezeWalletLockerEvent();\n\n    \n    \n    \n    \n    \n    function setWalletLocker(WalletLocker newWalletLocker)\n    public\n    onlyDeployer\n    notNullAddress(address(newWalletLocker))\n    notSameAddresses(address(newWalletLocker), address(walletLocker))\n    {\n        \n        require(!walletLockerFrozen, \"Wallet locker frozen [WalletLockable.sol:43]\");\n\n        \n        WalletLocker oldWalletLocker = walletLocker;\n        walletLocker = newWalletLocker;\n\n        \n        emit SetWalletLockerEvent(oldWalletLocker, newWalletLocker);\n    }\n\n    \n    \n    function freezeWalletLocker()\n    public\n    onlyDeployer\n    {\n        walletLockerFrozen = true;\n\n        \n        emit FreezeWalletLockerEvent();\n    }\n\n    \n    \n    \n    modifier walletLockerInitialized() {\n        require(address(walletLocker) != address(0), \"Wallet locker not initialized [WalletLockable.sol:69]\");\n        _;\n    }\n}\n\nlibrary CurrenciesLib {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    struct Currencies {\n        MonetaryTypesLib.Currency[] currencies;\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\n    }\n\n    \n    \n    \n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\n        }\n    }\n\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\n        if (0 < index)\n            removeByIndex(self, index - 1);\n    }\n\n    function removeByIndex(Currencies storage self, uint256 index)\n    internal\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\n\n        address currencyCt = self.currencies[index].ct;\n        uint256 currencyId = self.currencies[index].id;\n\n        if (index < self.currencies.length - 1) {\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\n        }\n        self.currencies.length--;\n        self.indexByCurrency[currencyCt][currencyId] = 0;\n    }\n\n    function count(Currencies storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencies.length;\n    }\n\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndex(Currencies storage self, uint256 index)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency memory)\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\n        return self.currencies[index];\n    }\n\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\n\n        up = up.clampMax(self.currencies.length - 1);\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _currencies[i - low] = self.currencies[i];\n\n        return _currencies;\n    }\n}\n\nlibrary FungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    struct Record {\n        int256 amount;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    \n    \n    \n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256)\n    {\n        return self.amountByCurrency[currencyCt][currencyId];\n    }\n\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return amount;\n    }\n\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function setByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function addByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function subByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub(_from, amount, currencyCt, currencyId);\n        add(_to, amount, currencyCt, currencyId);\n    }\n\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub_nn(_from, amount, currencyCt, currencyId);\n        add_nn(_to, amount, currencyCt, currencyId);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.amount, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.amount, record.blockNumber);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\nlibrary NonFungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    struct Record {\n        int256[] ids;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256[])) idsByCurrency;\n        mapping(address => mapping(uint256 => mapping(int256 => uint256))) idIndexById;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    \n    \n    \n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256[] memory)\n    {\n        return self.idsByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndices(Balance storage self, address currencyCt, uint256 currencyId, uint256 indexLow, uint256 indexUp)\n    internal\n    view\n    returns (int256[] memory)\n    {\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length)\n            return new int256[](0);\n\n        indexUp = indexUp.clampMax(self.idsByCurrency[currencyCt][currencyId].length - 1);\n\n        int256[] memory idsByCurrency = new int256[](indexUp - indexLow + 1);\n        for (uint256 i = indexLow; i < indexUp; i++)\n            idsByCurrency[i - indexLow] = self.idsByCurrency[currencyCt][currencyId][i];\n\n        return idsByCurrency;\n    }\n\n    function idsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.idsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function hasId(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 < self.idIndexById[currencyCt][currencyId][id];\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (new int256[](0), 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (new int256[](0), 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.ids, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (new int256[](0), 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.ids, record.blockNumber);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function set(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    {\n        int256[] memory ids = new int256[](1);\n        ids[0] = id;\n        set(self, ids, currencyCt, currencyId);\n    }\n\n    function set(Balance storage self, int256[] memory ids, address currencyCt, uint256 currencyId)\n    internal\n    {\n        uint256 i;\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\n\n        self.idsByCurrency[currencyCt][currencyId] = ids;\n\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n    }\n\n    function reset(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        for (uint256 i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\n\n        self.idsByCurrency[currencyCt][currencyId].length = 0;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        if (0 < self.idIndexById[currencyCt][currencyId][id])\n            return false;\n\n        self.idsByCurrency[currencyCt][currencyId].push(id);\n\n        self.idIndexById[currencyCt][currencyId][id] = self.idsByCurrency[currencyCt][currencyId].length;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n\n        return true;\n    }\n\n    function sub(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        uint256 index = self.idIndexById[currencyCt][currencyId][id];\n\n        if (0 == index)\n            return false;\n\n        if (index < self.idsByCurrency[currencyCt][currencyId].length) {\n            self.idsByCurrency[currencyCt][currencyId][index - 1] = self.idsByCurrency[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId].length - 1];\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][index - 1]] = index;\n        }\n        self.idsByCurrency[currencyCt][currencyId].length--;\n        self.idIndexById[currencyCt][currencyId][id] = 0;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n\n        return true;\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 id,\n        address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        return sub(_from, id, currencyCt, currencyId) && add(_to, id, currencyCt, currencyId);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateInUseCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\ncontract BalanceTracker is Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using NonFungibleBalanceLib for NonFungibleBalanceLib.Balance;\n\n    \n    \n    \n    string constant public DEPOSITED_BALANCE_TYPE = \"deposited\";\n    string constant public SETTLED_BALANCE_TYPE = \"settled\";\n    string constant public STAGED_BALANCE_TYPE = \"staged\";\n\n    \n    \n    \n    struct Wallet {\n        mapping(bytes32 => FungibleBalanceLib.Balance) fungibleBalanceByType;\n        mapping(bytes32 => NonFungibleBalanceLib.Balance) nonFungibleBalanceByType;\n    }\n\n    \n    \n    \n    bytes32 public depositedBalanceType;\n    bytes32 public settledBalanceType;\n    bytes32 public stagedBalanceType;\n\n    bytes32[] public _allBalanceTypes;\n    bytes32[] public _activeBalanceTypes;\n\n    bytes32[] public trackedBalanceTypes;\n    mapping(bytes32 => bool) public trackedBalanceTypeMap;\n\n    mapping(address => Wallet) private walletMap;\n\n    address[] public trackedWallets;\n    mapping(address => uint256) public trackedWalletIndexByWallet;\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n        depositedBalanceType = keccak256(abi.encodePacked(DEPOSITED_BALANCE_TYPE));\n        settledBalanceType = keccak256(abi.encodePacked(SETTLED_BALANCE_TYPE));\n        stagedBalanceType = keccak256(abi.encodePacked(STAGED_BALANCE_TYPE));\n\n        _allBalanceTypes.push(settledBalanceType);\n        _allBalanceTypes.push(depositedBalanceType);\n        _allBalanceTypes.push(stagedBalanceType);\n\n        _activeBalanceTypes.push(settledBalanceType);\n        _activeBalanceTypes.push(depositedBalanceType);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function get(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function getByIndices(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 indexLow, uint256 indexUp)\n    public\n    view\n    returns (int256[] memory)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].getByIndices(\n            currencyCt, currencyId, indexLow, indexUp\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function getAll(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256[] memory)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].get(\n            currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function idsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].idsCount(\n            currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function hasId(address wallet, bytes32 _type, int256 id, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].hasId(\n            id, currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function set(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId, bool fungible)\n    public\n    onlyActiveService\n    {\n        \n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].set(\n                value, currencyCt, currencyId\n            );\n\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].set(\n                value, currencyCt, currencyId\n            );\n\n        \n        _updateTrackedBalanceTypes(_type);\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        \n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n        \n        _updateTrackedBalanceTypes(_type);\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function add(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\n        bool fungible)\n    public\n    onlyActiveService\n    {\n        \n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].add(\n                value, currencyCt, currencyId\n            );\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].add(\n                value, currencyCt, currencyId\n            );\n\n        \n        _updateTrackedBalanceTypes(_type);\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function sub(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\n        bool fungible)\n    public\n    onlyActiveService\n    {\n        \n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].sub(\n                value, currencyCt, currencyId\n            );\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].sub(\n                value, currencyCt, currencyId\n            );\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    function hasInUseCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId)\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function hasEverUsedCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId)\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function fungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function fungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function fungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 _blockNumber)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    \n    function lastFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function nonFungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function nonFungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 index)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function nonFungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 _blockNumber)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    \n    function lastNonFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\n    }\n\n    \n    \n    function trackedBalanceTypesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return trackedBalanceTypes.length;\n    }\n\n    \n    \n    function trackedWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return trackedWallets.length;\n    }\n\n    \n    \n    function allBalanceTypes()\n    public\n    view\n    returns (bytes32[] memory)\n    {\n        return _allBalanceTypes;\n    }\n\n    \n    \n    function activeBalanceTypes()\n    public\n    view\n    returns (bytes32[] memory)\n    {\n        return _activeBalanceTypes;\n    }\n\n    \n    \n    \n    \n    function trackedWalletsByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(0 < trackedWallets.length, \"No tracked wallets found [BalanceTracker.sol:473]\");\n        require(low <= up, \"Bounds parameters mismatch [BalanceTracker.sol:474]\");\n\n        up = up.clampMax(trackedWallets.length - 1);\n        address[] memory _trackedWallets = new address[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _trackedWallets[i - low] = trackedWallets[i];\n\n        return _trackedWallets;\n    }\n\n    \n    \n    \n    function _updateTrackedBalanceTypes(bytes32 _type)\n    private\n    {\n        if (!trackedBalanceTypeMap[_type]) {\n            trackedBalanceTypeMap[_type] = true;\n            trackedBalanceTypes.push(_type);\n        }\n    }\n\n    function _updateTrackedWallets(address wallet)\n    private\n    {\n        if (0 == trackedWalletIndexByWallet[wallet]) {\n            trackedWallets.push(wallet);\n            trackedWalletIndexByWallet[wallet] = trackedWallets.length;\n        }\n    }\n}\n\ncontract BalanceTrackable is Ownable {\n    \n    \n    \n    BalanceTracker public balanceTracker;\n    bool public balanceTrackerFrozen;\n\n    \n    \n    \n    event SetBalanceTrackerEvent(BalanceTracker oldBalanceTracker, BalanceTracker newBalanceTracker);\n    event FreezeBalanceTrackerEvent();\n\n    \n    \n    \n    \n    \n    function setBalanceTracker(BalanceTracker newBalanceTracker)\n    public\n    onlyDeployer\n    notNullAddress(address(newBalanceTracker))\n    notSameAddresses(address(newBalanceTracker), address(balanceTracker))\n    {\n        \n        require(!balanceTrackerFrozen, \"Balance tracker frozen [BalanceTrackable.sol:43]\");\n\n        \n        BalanceTracker oldBalanceTracker = balanceTracker;\n        balanceTracker = newBalanceTracker;\n\n        \n        emit SetBalanceTrackerEvent(oldBalanceTracker, newBalanceTracker);\n    }\n\n    \n    \n    function freezeBalanceTracker()\n    public\n    onlyDeployer\n    {\n        balanceTrackerFrozen = true;\n\n        \n        emit FreezeBalanceTrackerEvent();\n    }\n\n    \n    \n    \n    modifier balanceTrackerInitialized() {\n        require(address(balanceTracker) != address(0), \"Balance tracker not initialized [BalanceTrackable.sol:69]\");\n        _;\n    }\n}\n\ncontract Beneficiary {\n    \n    \n    \n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public;\n}\n\ncontract AccrualBeneficiary is Beneficiary {\n    \n    \n    \n    event CloseAccrualPeriodEvent();\n\n    \n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\ncontract TransferController {\n    \n    \n    \n    event CurrencyTransferred(address from, address to, uint256 value,\n        address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    function isFungible()\n    public\n    view\n    returns (bool);\n\n    function standard()\n    public\n    view\n    returns (string memory);\n\n    \n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n\n    function getReceiveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\n    }\n\n    function getApproveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\n    }\n\n    function getDispatchSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\n    }\n}\n\ncontract TransferControllerManager is Ownable {\n    \n    \n    \n    struct CurrencyInfo {\n        bytes32 standard;\n        bool blacklisted;\n    }\n\n    \n    \n    \n    mapping(bytes32 => address) public registeredTransferControllers;\n    mapping(address => CurrencyInfo) public registeredCurrencies;\n\n    \n    \n    \n    event RegisterTransferControllerEvent(string standard, address controller);\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\n\n    event RegisterCurrencyEvent(address currencyCt, string standard);\n    event DeregisterCurrencyEvent(address currencyCt);\n    event BlacklistCurrencyEvent(address currencyCt);\n    event WhitelistCurrencyEvent(address currencyCt);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    function registerTransferController(string calldata standard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        registeredTransferControllers[standardHash] = controller;\n\n        \n        emit RegisterTransferControllerEvent(standard, controller);\n    }\n\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\n\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\n\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\n        registeredTransferControllers[oldStandardHash] = address(0);\n\n        \n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\n    }\n\n    function registerCurrency(address currencyCt, string calldata standard)\n    external\n    onlyOperator\n    notNullAddress(currencyCt)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\n\n        registeredCurrencies[currencyCt].standard = standardHash;\n\n        \n        emit RegisterCurrencyEvent(currencyCt, standard);\n    }\n\n    function deregisterCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\n\n        registeredCurrencies[currencyCt].standard = bytes32(0);\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit DeregisterCurrencyEvent(currencyCt);\n    }\n\n    function blacklistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\n\n        registeredCurrencies[currencyCt].blacklisted = true;\n\n        \n        emit BlacklistCurrencyEvent(currencyCt);\n    }\n\n    function whitelistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\n\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit WhitelistCurrencyEvent(currencyCt);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    public\n    view\n    returns (TransferController)\n    {\n        if (bytes(standard).length > 0) {\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\n            return TransferController(registeredTransferControllers[standardHash]);\n        }\n\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\n        return TransferController(controllerAddress);\n    }\n}\n\ncontract TransferControllerManageable is Ownable {\n    \n    \n    \n    TransferControllerManager public transferControllerManager;\n\n    \n    \n    \n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\n        TransferControllerManager newTransferControllerManager);\n\n    \n    \n    \n    \n    \n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransferControllerManager))\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\n    {\n        \n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\n        transferControllerManager = newTransferControllerManager;\n\n        \n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    internal\n    view\n    returns (TransferController)\n    {\n        return transferControllerManager.transferController(currencyCt, standard);\n    }\n\n    \n    \n    \n    modifier transferControllerManagerInitialized() {\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\n        _;\n    }\n}\n\nlibrary TxHistoryLib {\n    \n    \n    \n    struct AssetEntry {\n        int256 amount;\n        uint256 blockNumber;\n        address currencyCt;      \n        uint256 currencyId;\n    }\n\n    struct TxHistory {\n        AssetEntry[] deposits;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\n\n        AssetEntry[] withdrawals;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\n    }\n\n    \n    \n    \n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.deposits.push(deposit);\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\n    }\n\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.withdrawals.push(withdrawal);\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\n    }\n\n    \n\n    function deposit(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\n\n        amount = self.deposits[index].amount;\n        blockNumber = self.deposits[index].blockNumber;\n        currencyCt = self.deposits[index].currencyCt;\n        currencyId = self.deposits[index].currencyId;\n    }\n\n    function depositsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.deposits.length;\n    }\n\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\n\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyDeposits[currencyCt][currencyId].length;\n    }\n\n    \n\n    function withdrawal(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\n\n        amount = self.withdrawals[index].amount;\n        blockNumber = self.withdrawals[index].blockNumber;\n        currencyCt = self.withdrawals[index].currencyCt;\n        currencyId = self.withdrawals[index].currencyId;\n    }\n\n    function withdrawalsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.withdrawals.length;\n    }\n\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\n\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\n    }\n}\n\ncontract SecurityBond is Ownable, Configurable, AccrualBeneficiary, Servable, TransferControllerManageable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    string constant public REWARD_ACTION = \"reward\";\n    string constant public DEPRIVE_ACTION = \"deprive\";\n\n    \n    \n    \n    struct FractionalReward {\n        uint256 fraction;\n        uint256 nonce;\n        uint256 unlockTime;\n    }\n\n    struct AbsoluteReward {\n        int256 amount;\n        uint256 nonce;\n        uint256 unlockTime;\n    }\n\n    \n    \n    \n    FungibleBalanceLib.Balance private deposited;\n    TxHistoryLib.TxHistory private txHistory;\n    CurrenciesLib.Currencies private inUseCurrencies;\n\n    mapping(address => FractionalReward) public fractionalRewardByWallet;\n\n    mapping(address => mapping(address => mapping(uint256 => AbsoluteReward))) public absoluteRewardByWallet;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public claimNonceByWalletCurrency;\n\n    mapping(address => FungibleBalanceLib.Balance) private stagedByWallet;\n\n    mapping(address => uint256) public nonceByWallet;\n\n    \n    \n    \n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event RewardFractionalEvent(address wallet, uint256 fraction, uint256 unlockTimeoutInSeconds);\n    event RewardAbsoluteEvent(address wallet, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 unlockTimeoutInSeconds);\n    event DepriveFractionalEvent(address wallet);\n    event DepriveAbsoluteEvent(address wallet, address currencyCt, uint256 currencyId);\n    event ClaimAndTransferToBeneficiaryEvent(address from, Beneficiary beneficiary, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, string standard);\n    event ClaimAndStageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address from, int256 amount, address currencyCt, uint256 currencyId, string standard);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) Servable() public {\n    }\n\n    \n    \n    \n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        deposited.add(amount, address(0), 0);\n        txHistory.addDeposit(amount, address(0), 0);\n\n        \n        inUseCurrencies.add(address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:145]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [SecurityBond.sol:154]\");\n\n        \n        deposited.add(amount, currencyCt, currencyId);\n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        inUseCurrencies.add(currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    \n    \n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    \n    \n    \n    \n    function depositedBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return deposited.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function depositedFractionalBalance(address currencyCt, uint256 currencyId, uint256 fraction)\n    public\n    view\n    returns (int256)\n    {\n        return deposited.get(currencyCt, currencyId)\n        .mul(SafeMathIntLib.toInt256(fraction))\n        .div(ConstantsLib.PARTS_PER());\n    }\n\n    \n    \n    \n    \n    function stagedBalance(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return stagedByWallet[wallet].get(currencyCt, currencyId);\n    }\n\n    \n    \n    function inUseCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return inUseCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function inUseCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return inUseCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    \n    \n    \n    \n    function rewardFractional(address wallet, uint256 fraction, uint256 unlockTimeoutInSeconds)\n    public\n    notNullAddress(wallet)\n    onlyEnabledServiceAction(REWARD_ACTION)\n    {\n        \n        fractionalRewardByWallet[wallet].fraction = fraction.clampMax(uint256(ConstantsLib.PARTS_PER()));\n        fractionalRewardByWallet[wallet].nonce = ++nonceByWallet[wallet];\n        fractionalRewardByWallet[wallet].unlockTime = block.timestamp.add(unlockTimeoutInSeconds);\n\n        \n        emit RewardFractionalEvent(wallet, fraction, unlockTimeoutInSeconds);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function rewardAbsolute(address wallet, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 unlockTimeoutInSeconds)\n    public\n    notNullAddress(wallet)\n    onlyEnabledServiceAction(REWARD_ACTION)\n    {\n        \n        absoluteRewardByWallet[wallet][currencyCt][currencyId].amount = amount;\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce = ++nonceByWallet[wallet];\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime = block.timestamp.add(unlockTimeoutInSeconds);\n\n        \n        emit RewardAbsoluteEvent(wallet, amount, currencyCt, currencyId, unlockTimeoutInSeconds);\n    }\n\n    \n    \n    function depriveFractional(address wallet)\n    public\n    onlyEnabledServiceAction(DEPRIVE_ACTION)\n    {\n        \n        fractionalRewardByWallet[wallet].fraction = 0;\n        fractionalRewardByWallet[wallet].nonce = ++nonceByWallet[wallet];\n        fractionalRewardByWallet[wallet].unlockTime = 0;\n\n        \n        emit DepriveFractionalEvent(wallet);\n    }\n\n    \n    \n    \n    \n    function depriveAbsolute(address wallet, address currencyCt, uint256 currencyId)\n    public\n    onlyEnabledServiceAction(DEPRIVE_ACTION)\n    {\n        \n        absoluteRewardByWallet[wallet][currencyCt][currencyId].amount = 0;\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce = ++nonceByWallet[wallet];\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime = 0;\n\n        \n        emit DepriveAbsoluteEvent(wallet, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function claimAndTransferToBeneficiary(Beneficiary beneficiary, string memory balanceType, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        \n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        \n        deposited.sub(claimedAmount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            beneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Approval by controller failed [SecurityBond.sol:350]\");\n            beneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n        }\n\n        \n        emit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function claimAndStage(address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        \n        deposited.sub(claimedAmount, currencyCt, currencyId);\n\n        \n        stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\n\n        \n        emit ClaimAndStageEvent(msg.sender, claimedAmount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n        \n        amount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n        \n        stagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n        }\n\n        \n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function _claim(address wallet, address currencyCt, uint256 currencyId)\n    private\n    returns (int256)\n    {\n        \n        uint256 claimNonce = fractionalRewardByWallet[wallet].nonce.clampMin(\n            absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce\n        );\n\n        \n        require(\n            claimNonce > claimNonceByWalletCurrency[wallet][currencyCt][currencyId],\n            \"Claim nonce not strictly greater than previously claimed nonce [SecurityBond.sol:425]\"\n        );\n\n        \n        int256 claimAmount = _fractionalRewardAmountByWalletCurrency(wallet, currencyCt, currencyId).add(\n            _absoluteRewardAmountByWalletCurrency(wallet, currencyCt, currencyId)\n        ).clampMax(\n            deposited.get(currencyCt, currencyId)\n        );\n\n        \n        require(claimAmount.isNonZeroPositiveInt256(), \"Claim amount not strictly positive [SecurityBond.sol:438]\");\n\n        \n        claimNonceByWalletCurrency[wallet][currencyCt][currencyId] = claimNonce;\n\n        return claimAmount;\n    }\n\n    function _fractionalRewardAmountByWalletCurrency(address wallet, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        if (\n            claimNonceByWalletCurrency[wallet][currencyCt][currencyId] < fractionalRewardByWallet[wallet].nonce &&\n            block.timestamp >= fractionalRewardByWallet[wallet].unlockTime\n        )\n            return deposited.get(currencyCt, currencyId)\n            .mul(SafeMathIntLib.toInt256(fractionalRewardByWallet[wallet].fraction))\n            .div(ConstantsLib.PARTS_PER());\n\n        else\n            return 0;\n    }\n\n    function _absoluteRewardAmountByWalletCurrency(address wallet, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        if (\n            claimNonceByWalletCurrency[wallet][currencyCt][currencyId] < absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce &&\n            block.timestamp >= absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime\n        )\n            return absoluteRewardByWallet[wallet][currencyCt][currencyId].amount.clampMax(\n                deposited.get(currencyCt, currencyId)\n            );\n\n        else\n            return 0;\n    }\n}\n\ncontract SecurityBondable is Ownable {\n    \n    \n    \n    SecurityBond public securityBond;\n\n    \n    \n    \n    event SetSecurityBondEvent(SecurityBond oldSecurityBond, SecurityBond newSecurityBond);\n\n    \n    \n    \n    \n    \n    function setSecurityBond(SecurityBond newSecurityBond)\n    public\n    onlyDeployer\n    notNullAddress(address(newSecurityBond))\n    notSameAddresses(address(newSecurityBond), address(securityBond))\n    {\n        \n        SecurityBond oldSecurityBond = securityBond;\n        securityBond = newSecurityBond;\n\n        \n        emit SetSecurityBondEvent(oldSecurityBond, newSecurityBond);\n    }\n\n    \n    \n    \n    modifier securityBondInitialized() {\n        require(address(securityBond) != address(0), \"Security bond not initialized [SecurityBondable.sol:52]\");\n        _;\n    }\n}\n\ncontract FraudChallenge is Ownable, Servable {\n    \n    \n    \n    string constant public ADD_SEIZED_WALLET_ACTION = \"add_seized_wallet\";\n    string constant public ADD_DOUBLE_SPENDER_WALLET_ACTION = \"add_double_spender_wallet\";\n    string constant public ADD_FRAUDULENT_ORDER_ACTION = \"add_fraudulent_order\";\n    string constant public ADD_FRAUDULENT_TRADE_ACTION = \"add_fraudulent_trade\";\n    string constant public ADD_FRAUDULENT_PAYMENT_ACTION = \"add_fraudulent_payment\";\n\n    \n    \n    \n    address[] public doubleSpenderWallets;\n    mapping(address => bool) public doubleSpenderByWallet;\n\n    bytes32[] public fraudulentOrderHashes;\n    mapping(bytes32 => bool) public fraudulentByOrderHash;\n\n    bytes32[] public fraudulentTradeHashes;\n    mapping(bytes32 => bool) public fraudulentByTradeHash;\n\n    bytes32[] public fraudulentPaymentHashes;\n    mapping(bytes32 => bool) public fraudulentByPaymentHash;\n\n    \n    \n    \n    event AddDoubleSpenderWalletEvent(address wallet);\n    event AddFraudulentOrderHashEvent(bytes32 hash);\n    event AddFraudulentTradeHashEvent(bytes32 hash);\n    event AddFraudulentPaymentHashEvent(bytes32 hash);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    \n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    \n    \n    function doubleSpenderWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return doubleSpenderWallets.length;\n    }\n\n    \n    \n    function addDoubleSpenderWallet(address wallet)\n    public\n    onlyEnabledServiceAction(ADD_DOUBLE_SPENDER_WALLET_ACTION) {\n        if (!doubleSpenderByWallet[wallet]) {\n            doubleSpenderWallets.push(wallet);\n            doubleSpenderByWallet[wallet] = true;\n            emit AddDoubleSpenderWalletEvent(wallet);\n        }\n    }\n\n    \n    function fraudulentOrderHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentOrderHashes.length;\n    }\n\n    \n    \n    function isFraudulentOrderHash(bytes32 hash)\n    public\n    view returns (bool) {\n        return fraudulentByOrderHash[hash];\n    }\n\n    \n    function addFraudulentOrderHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_ORDER_ACTION)\n    {\n        if (!fraudulentByOrderHash[hash]) {\n            fraudulentByOrderHash[hash] = true;\n            fraudulentOrderHashes.push(hash);\n            emit AddFraudulentOrderHashEvent(hash);\n        }\n    }\n\n    \n    function fraudulentTradeHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentTradeHashes.length;\n    }\n\n    \n    \n    \n    function isFraudulentTradeHash(bytes32 hash)\n    public\n    view\n    returns (bool)\n    {\n        return fraudulentByTradeHash[hash];\n    }\n\n    \n    function addFraudulentTradeHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_TRADE_ACTION)\n    {\n        if (!fraudulentByTradeHash[hash]) {\n            fraudulentByTradeHash[hash] = true;\n            fraudulentTradeHashes.push(hash);\n            emit AddFraudulentTradeHashEvent(hash);\n        }\n    }\n\n    \n    function fraudulentPaymentHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentPaymentHashes.length;\n    }\n\n    \n    \n    \n    function isFraudulentPaymentHash(bytes32 hash)\n    public\n    view\n    returns (bool)\n    {\n        return fraudulentByPaymentHash[hash];\n    }\n\n    \n    function addFraudulentPaymentHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_PAYMENT_ACTION)\n    {\n        if (!fraudulentByPaymentHash[hash]) {\n            fraudulentByPaymentHash[hash] = true;\n            fraudulentPaymentHashes.push(hash);\n            emit AddFraudulentPaymentHashEvent(hash);\n        }\n    }\n}\n\ncontract FraudChallengable is Ownable {\n    \n    \n    \n    FraudChallenge public fraudChallenge;\n\n    \n    \n    \n    event SetFraudChallengeEvent(FraudChallenge oldFraudChallenge, FraudChallenge newFraudChallenge);\n\n    \n    \n    \n    \n    \n    function setFraudChallenge(FraudChallenge newFraudChallenge)\n    public\n    onlyDeployer\n    notNullAddress(address(newFraudChallenge))\n    notSameAddresses(address(newFraudChallenge), address(fraudChallenge))\n    {\n        \n        FraudChallenge oldFraudChallenge = fraudChallenge;\n        fraudChallenge = newFraudChallenge;\n\n        \n        emit SetFraudChallengeEvent(oldFraudChallenge, newFraudChallenge);\n    }\n\n    \n    \n    \n    modifier fraudChallengeInitialized() {\n        require(address(fraudChallenge) != address(0), \"Fraud challenge not initialized [FraudChallengable.sol:52]\");\n        _;\n    }\n}\n\nlibrary SettlementChallengeTypesLib {\n    \n    \n    \n    enum Status {Qualified, Disqualified}\n\n    struct Proposal {\n        address wallet;\n        uint256 nonce;\n        uint256 referenceBlockNumber;\n        uint256 definitionBlockNumber;\n\n        uint256 expirationTime;\n\n        \n        Status status;\n\n        \n        Amounts amounts;\n\n        \n        MonetaryTypesLib.Currency currency;\n\n        \n        Driip challenged;\n\n        \n        bool walletInitiated;\n\n        \n        bool terminated;\n\n        \n        Disqualification disqualification;\n    }\n\n    struct Amounts {\n        \n        int256 cumulativeTransfer;\n\n        \n        int256 stage;\n\n        \n        int256 targetBalance;\n    }\n\n    struct Driip {\n        \n        string kind;\n\n        \n        bytes32 hash;\n    }\n\n    struct Disqualification {\n        \n        address challenger;\n        uint256 nonce;\n        uint256 blockNumber;\n\n        \n        Driip candidate;\n    }\n}\n\ncontract Upgradable {\n    \n    \n    \n    address public upgradeAgent;\n    bool public upgradesFrozen;\n\n    \n    \n    \n    event SetUpgradeAgentEvent(address upgradeAgent);\n    event FreezeUpgradesEvent();\n\n    \n    \n    \n    \n    \n    function setUpgradeAgent(address _upgradeAgent)\n    public\n    onlyWhenUpgradable\n    {\n        require(address(0) == upgradeAgent, \"Upgrade agent has already been set [Upgradable.sol:37]\");\n\n        \n        upgradeAgent = _upgradeAgent;\n\n        \n        emit SetUpgradeAgentEvent(upgradeAgent);\n    }\n\n    \n    \n    function freezeUpgrades()\n    public\n    onlyWhenUpgrading\n    {\n        \n        upgradesFrozen = true;\n\n        \n        emit FreezeUpgradesEvent();\n    }\n\n    \n    \n    \n    modifier onlyWhenUpgrading() {\n        require(msg.sender == upgradeAgent, \"Caller is not upgrade agent [Upgradable.sol:63]\");\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:64]\");\n        _;\n    }\n\n    modifier onlyWhenUpgradable() {\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:69]\");\n        _;\n    }\n}\n\ncontract DriipSettlementChallengeState is Ownable, Servable, Configurable, Upgradable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\n    string constant public QUALIFY_PROPOSAL_ACTION = \"qualify_proposal\";\n\n    \n    \n    \n    SettlementChallengeTypesLib.Proposal[] public proposals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => uint256)))) public proposalIndexByWalletNonceCurrency;\n\n    \n    \n    \n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n    event QualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n    event UpgradeProposalEvent(SettlementChallengeTypesLib.Proposal proposal);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function proposalsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return proposals.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string memory challengedKind)\n    public\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n    {\n        \n        _initiateProposal(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n\n        \n        emit InitiateProposalEvent(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\n            blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n    }\n\n    \n    \n    \n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        \n        proposals[index - 1].terminated = true;\n\n        \n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    \n    \n    \n    \n    \n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\n        bool walletTerminated)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n        \n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        \n        proposals[index - 1].terminated = true;\n\n        \n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    \n    \n    \n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        \n        _removeProposal(index);\n    }\n\n    \n    \n    \n    \n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n        \n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        \n        _removeProposal(index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\n    public\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n        \n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n        \n        emit DisqualifyProposalEvent(\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            challengerWallet, candidateNonce, candidateHash, candidateKind\n        );\n    }\n\n    \n    \n    \n    function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n        \n        emit QualifyProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].disqualification.challenger,\n            proposals[index - 1].disqualification.nonce,\n            proposals[index - 1].disqualification.candidate.hash,\n            proposals[index - 1].disqualification.candidate.kind\n        );\n\n        \n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        delete proposals[index - 1].disqualification;\n    }\n\n    \n    \n    \n    \n    \n    \n    function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\n        return proposals[index - 1].terminated;\n    }\n\n    \n    \n    \n    \n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\n        return block.timestamp >= proposals[index - 1].expirationTime;\n    }\n\n    \n    \n    \n    \n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\n        return proposals[index - 1].nonce;\n    }\n\n    \n    \n    \n    \n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\n        return proposals[index - 1].referenceBlockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\n        return proposals[index - 1].definitionBlockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\n        return proposals[index - 1].expirationTime;\n    }\n\n    \n    \n    \n    \n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\n        return proposals[index - 1].status;\n    }\n\n    \n    \n    \n    \n    function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\n        return proposals[index - 1].amounts.cumulativeTransfer;\n    }\n\n    \n    \n    \n    \n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\n        return proposals[index - 1].amounts.stage;\n    }\n\n    \n    \n    \n    \n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\n        return proposals[index - 1].amounts.targetBalance;\n    }\n\n    \n    \n    \n    \n    function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\n        return proposals[index - 1].challenged.hash;\n    }\n\n    \n    \n    \n    \n    function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\n        return proposals[index - 1].challenged.kind;\n    }\n\n    \n    \n    \n    \n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\n        return proposals[index - 1].walletInitiated;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (address)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\n        return proposals[index - 1].disqualification.challenger;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\n        return proposals[index - 1].disqualification.nonce;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\n        return proposals[index - 1].disqualification.blockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\n        return proposals[index - 1].disqualification.candidate.hash;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\n        return proposals[index - 1].disqualification.candidate.kind;\n    }\n\n    \n    \n    function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(\n            0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n            \"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n        );\n\n        \n        proposals.push(proposal);\n\n        \n        uint256 index = proposals.length;\n\n        \n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n        proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n        \n        emit UpgradeProposalEvent(proposal);\n    }\n\n    \n    \n    \n    function _initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated,\n        bytes32 challengedHash, string memory challengedKind)\n    private\n    {\n        \n        require(\n            0 == proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id],\n            \"Existing proposal found for wallet, nonce and currency [DriipSettlementChallengeState.sol:620]\"\n        );\n\n        \n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [DriipSettlementChallengeState.sol:626]\");\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [DriipSettlementChallengeState.sol:627]\");\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index) {\n            index = ++(proposals.length);\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\n        }\n\n        \n        proposals[index - 1].wallet = wallet;\n        proposals[index - 1].nonce = nonce;\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\n        proposals[index - 1].definitionBlockNumber = block.number;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].currency = currency;\n        proposals[index - 1].amounts.cumulativeTransfer = cumulativeTransferAmount;\n        proposals[index - 1].amounts.stage = stageAmount;\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\n        proposals[index - 1].walletInitiated = walletInitiated;\n        proposals[index - 1].terminated = false;\n        proposals[index - 1].challenged.hash = challengedHash;\n        proposals[index - 1].challenged.kind = challengedKind;\n\n        \n        proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id] = index;\n    }\n\n    function _removeProposal(uint256 index)\n    private\n    {\n        \n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        if (index < proposals.length) {\n            proposals[index - 1] = proposals[proposals.length - 1];\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n            proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n        }\n        proposals.length--;\n    }\n}\n\ncontract NullSettlementChallengeState is Ownable, Servable, Configurable, BalanceTrackable, Upgradable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\n\n    \n    \n    \n    SettlementChallengeTypesLib.Proposal[] public proposals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\n\n    \n    \n    \n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challangedNonce, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        address challengerWallet, uint256 candidateNonce, bytes32 candidateHash, string candidateKind);\n    event UpgradeProposalEvent(SettlementChallengeTypesLib.Proposal proposal);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function proposalsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return proposals.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\n    public\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n    {\n        \n        _initiateProposal(\n            wallet, nonce, stageAmount, targetBalanceAmount,\n            currency, blockNumber, walletInitiated\n        );\n\n        \n        emit InitiateProposalEvent(\n            wallet, nonce, stageAmount, targetBalanceAmount, currency,\n            blockNumber, walletInitiated\n        );\n    }\n\n    \n    \n    \n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        proposals[index - 1].terminated = true;\n\n        \n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n    }\n\n    \n    \n    \n    \n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:145]\");\n\n        \n        proposals[index - 1].terminated = true;\n\n        \n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n    }\n\n    \n    \n    \n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n\n        \n        _removeProposal(index);\n    }\n\n    \n    \n    \n    \n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:199]\");\n\n        \n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n\n        \n        _removeProposal(index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\n    public\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n        require(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:228]\");\n\n        \n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n        \n        emit DisqualifyProposalEvent(\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\n            proposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n        );\n    }\n\n    \n    \n    \n    \n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:271]\");\n        return proposals[index - 1].terminated;\n    }\n\n    \n    \n    \n    \n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:286]\");\n        return block.timestamp >= proposals[index - 1].expirationTime;\n    }\n\n    \n    \n    \n    \n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:300]\");\n        return proposals[index - 1].nonce;\n    }\n\n    \n    \n    \n    \n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:314]\");\n        return proposals[index - 1].referenceBlockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:328]\");\n        return proposals[index - 1].definitionBlockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:342]\");\n        return proposals[index - 1].expirationTime;\n    }\n\n    \n    \n    \n    \n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:356]\");\n        return proposals[index - 1].status;\n    }\n\n    \n    \n    \n    \n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:370]\");\n        return proposals[index - 1].amounts.stage;\n    }\n\n    \n    \n    \n    \n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:384]\");\n        return proposals[index - 1].amounts.targetBalance;\n    }\n\n    \n    \n    \n    \n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:398]\");\n        return proposals[index - 1].walletInitiated;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (address)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:412]\");\n        return proposals[index - 1].disqualification.challenger;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:426]\");\n        return proposals[index - 1].disqualification.blockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:440]\");\n        return proposals[index - 1].disqualification.nonce;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:454]\");\n        return proposals[index - 1].disqualification.candidate.hash;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:468]\");\n        return proposals[index - 1].disqualification.candidate.kind;\n    }\n\n    \n    \n    function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(\n            0 == proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id],\n            \"Proposal exists for wallet and currency [NullSettlementChallengeState.sol:479]\"\n        );\n\n        \n        proposals.push(proposal);\n\n        \n        uint256 index = proposals.length;\n\n        \n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n\n        \n        emit UpgradeProposalEvent(proposal);\n    }\n\n\n    \n    \n    \n    function _initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated)\n    private\n    {\n        \n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [NullSettlementChallengeState.sol:506]\");\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [NullSettlementChallengeState.sol:507]\");\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index) {\n            index = ++(proposals.length);\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\n        }\n\n        \n        proposals[index - 1].wallet = wallet;\n        proposals[index - 1].nonce = nonce;\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\n        proposals[index - 1].definitionBlockNumber = block.number;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].currency = currency;\n        proposals[index - 1].amounts.stage = stageAmount;\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\n        proposals[index - 1].walletInitiated = walletInitiated;\n        proposals[index - 1].terminated = false;\n    }\n\n    function _removeProposal(uint256 index)\n    private\n    returns (bool)\n    {\n        \n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        if (index < proposals.length) {\n            proposals[index - 1] = proposals[proposals.length - 1];\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n        }\n        proposals.length--;\n    }\n\n    function _activeBalanceLogEntry(address wallet, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        \n        (int256 depositedAmount, uint256 depositedBlockNumber) = balanceTracker.lastFungibleRecord(\n            wallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = balanceTracker.lastFungibleRecord(\n            wallet, balanceTracker.settledBalanceType(), currencyCt, currencyId\n        );\n\n        \n        amount = depositedAmount.add(settledAmount);\n\n        \n        blockNumber = depositedBlockNumber > settledBlockNumber ? depositedBlockNumber : settledBlockNumber;\n    }\n}\n\nlibrary BalanceTrackerLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    function fungibleActiveRecordByBlockNumber(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 _blockNumber)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        \n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.fungibleRecordByBlockNumber(\n            wallet, self.depositedBalanceType(), currency.ct, currency.id, _blockNumber\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = self.fungibleRecordByBlockNumber(\n            wallet, self.settledBalanceType(), currency.ct, currency.id, _blockNumber\n        );\n\n        \n        amount = depositedAmount.add(settledAmount);\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\n    }\n\n    function fungibleActiveBalanceAmountByBlockNumber(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = fungibleActiveRecordByBlockNumber(self, wallet, currency, blockNumber);\n        return amount;\n    }\n\n    function fungibleActiveDeltaBalanceAmountByBlockNumbers(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 fromBlockNumber, uint256 toBlockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, toBlockNumber) -\n        fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, fromBlockNumber);\n    }\n\n    function fungibleActiveRecord(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        \n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.lastFungibleRecord(\n            wallet, self.depositedBalanceType(), currency.ct, currency.id\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = self.lastFungibleRecord(\n            wallet, self.settledBalanceType(), currency.ct, currency.id\n        );\n\n        \n        amount = depositedAmount.add(settledAmount);\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\n    }\n\n    function fungibleActiveBalanceAmount(BalanceTracker self, address wallet, MonetaryTypesLib.Currency memory currency)\n    internal\n    view\n    returns (int256)\n    {\n        return self.get(wallet, self.depositedBalanceType(), currency.ct, currency.id).add(\n            self.get(wallet, self.settledBalanceType(), currency.ct, currency.id)\n        );\n    }\n}\n\ncontract DriipSettlementDisputeByPayment is Ownable, Configurable, Validatable, SecurityBondable, WalletLockable,\nBalanceTrackable, FraudChallengable, Servable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using BalanceTrackerLib for BalanceTracker;\n\n    \n    \n    \n    string constant public CHALLENGE_BY_PAYMENT_ACTION = \"challenge_by_payment\";\n\n    \n    \n    \n    DriipSettlementChallengeState public driipSettlementChallengeState;\n    NullSettlementChallengeState public nullSettlementChallengeState;\n\n    \n    \n    \n    event SetDriipSettlementChallengeStateEvent(DriipSettlementChallengeState oldDriipSettlementChallengeState,\n        DriipSettlementChallengeState newDriipSettlementChallengeState);\n    event SetNullSettlementChallengeStateEvent(NullSettlementChallengeState oldNullSettlementChallengeState,\n        NullSettlementChallengeState newNullSettlementChallengeState);\n    event ChallengeByPaymentEvent(address wallet, uint256 nonce, PaymentTypesLib.Payment payment,\n        address challenger);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    function setDriipSettlementChallengeState(DriipSettlementChallengeState newDriipSettlementChallengeState) public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementChallengeState))\n    {\n        DriipSettlementChallengeState oldDriipSettlementChallengeState = driipSettlementChallengeState;\n        driipSettlementChallengeState = newDriipSettlementChallengeState;\n        emit SetDriipSettlementChallengeStateEvent(oldDriipSettlementChallengeState, driipSettlementChallengeState);\n    }\n\n    \n    \n    function setNullSettlementChallengeState(NullSettlementChallengeState newNullSettlementChallengeState) public\n    onlyDeployer\n    notNullAddress(address(newNullSettlementChallengeState))\n    {\n        NullSettlementChallengeState oldNullSettlementChallengeState = nullSettlementChallengeState;\n        nullSettlementChallengeState = newNullSettlementChallengeState;\n        emit SetNullSettlementChallengeStateEvent(oldNullSettlementChallengeState, nullSettlementChallengeState);\n    }\n\n    \n    \n    \n    \n    \n    function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment, address challenger)\n    public\n    onlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\n    onlySealedPayment(payment)\n    onlyPaymentSender(payment, wallet)\n    {\n        \n        require(\n            !fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash),\n            \"Payment deemed fraudulent [DriipSettlementDisputeByPayment.sol:102]\"\n        );\n\n        \n        require(\n            driipSettlementChallengeState.hasProposal(wallet, payment.currency),\n            \"No proposal found [DriipSettlementDisputeByPayment.sol:108]\"\n        );\n\n        \n        require(\n            !driipSettlementChallengeState.hasProposalExpired(wallet, payment.currency),\n            \"Proposal found expired [DriipSettlementDisputeByPayment.sol:114]\"\n        );\n\n        \n        \n        require(\n            payment.sender.nonce > driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n            \"Payment nonce not strictly greater than proposal nonce [DriipSettlementDisputeByPayment.sol:121]\"\n        );\n        require(\n            payment.sender.nonce > driipSettlementChallengeState.proposalDisqualificationNonce(wallet, payment.currency),\n            \"Payment nonce not strictly greater than proposal disqualification nonce [DriipSettlementDisputeByPayment.sol:125]\"\n        );\n\n        \n        require(_overrun(wallet, payment), \"No overrun found [DriipSettlementDisputeByPayment.sol:131]\");\n\n        \n        _settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\n\n        \n        driipSettlementChallengeState.disqualifyProposal(\n            wallet, payment.currency, challenger, payment.blockNumber,\n            payment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n        );\n\n        \n        nullSettlementChallengeState.terminateProposal(wallet, payment.currency);\n\n        \n        emit ChallengeByPaymentEvent(\n            wallet, driipSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\n        );\n    }\n\n    \n    \n    \n    function _overrun(address wallet, PaymentTypesLib.Payment memory payment)\n    private\n    view\n    returns (bool)\n    {\n        \n        int targetBalanceAmount = driipSettlementChallengeState.proposalTargetBalanceAmount(\n            wallet, payment.currency\n        );\n\n        \n        int256 deltaBalanceAmountSinceStart = balanceTracker.fungibleActiveDeltaBalanceAmountByBlockNumbers(\n            wallet, payment.currency,\n            driipSettlementChallengeState.proposalReferenceBlockNumber(wallet, payment.currency),\n            block.number\n        );\n\n        \n        int256 paymentCumulativeTransferAmount = payment.sender.balances.current.sub(\n            balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\n                wallet, payment.currency, payment.blockNumber\n            )\n        );\n\n        \n        int proposalCumulativeTransferAmount = driipSettlementChallengeState.proposalCumulativeTransferAmount(\n            wallet, payment.currency\n        );\n\n        return targetBalanceAmount.add(deltaBalanceAmountSinceStart) < proposalCumulativeTransferAmount.sub(paymentCumulativeTransferAmount);\n    }\n\n    \n    function _settleRewards(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\n        address challenger)\n    private\n    {\n        if (driipSettlementChallengeState.proposalWalletInitiated(wallet, currency))\n            _settleBalanceReward(wallet, walletAmount, currency, challenger);\n\n        else\n            _settleSecurityBondReward(wallet, walletAmount, currency, challenger);\n    }\n\n    function _settleBalanceReward(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\n        address challenger)\n    private\n    {\n        \n        if (SettlementChallengeTypesLib.Status.Disqualified == driipSettlementChallengeState.proposalStatus(\n            wallet, currency\n        ))\n            walletLocker.unlockFungibleByProxy(\n                wallet,\n                driipSettlementChallengeState.proposalDisqualificationChallenger(\n                    wallet, currency\n                ),\n                currency.ct, currency.id\n            );\n\n        \n        walletLocker.lockFungibleByProxy(\n            wallet, challenger, walletAmount, currency.ct, currency.id, configuration.settlementChallengeTimeout()\n        );\n    }\n\n    \n    \n    \n    \n    \n    function _settleSecurityBondReward(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\n        address challenger)\n    private\n    {\n        \n        if (SettlementChallengeTypesLib.Status.Disqualified == driipSettlementChallengeState.proposalStatus(\n            wallet, currency\n        ))\n            securityBond.depriveAbsolute(\n                driipSettlementChallengeState.proposalDisqualificationChallenger(\n                    wallet, currency\n                ),\n                currency.ct, currency.id\n            );\n\n        \n        MonetaryTypesLib.Figure memory flatReward = _flatReward();\n        securityBond.rewardAbsolute(\n            challenger, flatReward.amount, flatReward.currency.ct, flatReward.currency.id, 0\n        );\n\n        \n        int256 progressiveRewardAmount = walletAmount.clampMax(\n            securityBond.depositedFractionalBalance(\n                currency.ct, currency.id, configuration.operatorSettlementStakeFraction()\n            )\n        );\n        securityBond.rewardAbsolute(\n            challenger, progressiveRewardAmount, currency.ct, currency.id, 0\n        );\n    }\n\n    function _flatReward()\n    private\n    view\n    returns (MonetaryTypesLib.Figure memory)\n    {\n        (int256 amount, address currencyCt, uint256 currencyId) = configuration.operatorSettlementStake();\n        return MonetaryTypesLib.Figure(amount, MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n}\n\ncontract CommunityVote is Ownable {\n    \n    \n    \n    mapping(address => bool) doubleSpenderByWallet;\n    uint256 maxDriipNonce;\n    uint256 maxNullNonce;\n    bool dataAvailable;\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        dataAvailable = true;\n    }\n\n    \n    \n    \n    \n    \n    \n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    \n    \n    function getMaxDriipNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxDriipNonce;\n    }\n\n    \n    \n    function getMaxNullNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxNullNonce;\n    }\n\n    \n    \n    function isDataAvailable()\n    public\n    view\n    returns (bool)\n    {\n        return dataAvailable;\n    }\n}\n\ncontract CommunityVotable is Ownable {\n    \n    \n    \n    CommunityVote public communityVote;\n    bool public communityVoteFrozen;\n\n    \n    \n    \n    event SetCommunityVoteEvent(CommunityVote oldCommunityVote, CommunityVote newCommunityVote);\n    event FreezeCommunityVoteEvent();\n\n    \n    \n    \n    \n    \n    function setCommunityVote(CommunityVote newCommunityVote) \n    public \n    onlyDeployer\n    notNullAddress(address(newCommunityVote))\n    notSameAddresses(address(newCommunityVote), address(communityVote))\n    {\n        require(!communityVoteFrozen, \"Community vote frozen [CommunityVotable.sol:41]\");\n\n        \n        CommunityVote oldCommunityVote = communityVote;\n        communityVote = newCommunityVote;\n\n        \n        emit SetCommunityVoteEvent(oldCommunityVote, newCommunityVote);\n    }\n\n    \n    \n    function freezeCommunityVote()\n    public\n    onlyDeployer\n    {\n        communityVoteFrozen = true;\n\n        \n        emit FreezeCommunityVoteEvent();\n    }\n\n    \n    \n    \n    modifier communityVoteInitialized() {\n        require(address(communityVote) != address(0), \"Community vote not initialized [CommunityVotable.sol:67]\");\n        _;\n    }\n}\n\ncontract Benefactor is Ownable {\n    \n    \n    \n    Beneficiary[] public beneficiaries;\n    mapping(address => uint256) public beneficiaryIndexByAddress;\n\n    \n    \n    \n    event RegisterBeneficiaryEvent(Beneficiary beneficiary);\n    event DeregisterBeneficiaryEvent(Beneficiary beneficiary);\n\n    \n    \n    \n    \n    \n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] > 0)\n            return false;\n\n        beneficiaries.push(beneficiary);\n        beneficiaryIndexByAddress[_beneficiary] = beneficiaries.length;\n\n        \n        emit RegisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] == 0)\n            return false;\n\n        uint256 idx = beneficiaryIndexByAddress[_beneficiary] - 1;\n        if (idx < beneficiaries.length - 1) {\n            \n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\n            beneficiaryIndexByAddress[address(beneficiaries[idx])] = idx + 1;\n        }\n        beneficiaries.length--;\n        beneficiaryIndexByAddress[_beneficiary] = 0;\n\n        \n        emit DeregisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    \n    function isRegisteredBeneficiary(Beneficiary beneficiary)\n    public\n    view\n    returns (bool)\n    {\n        return beneficiaryIndexByAddress[address(beneficiary)] > 0;\n    }\n\n    \n    \n    function registeredBeneficiariesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return beneficiaries.length;\n    }\n}\n\ncontract AccrualBenefactor is Benefactor {\n    using SafeMathIntLib for int256;\n\n    \n    \n    \n    mapping(address => int256) private _beneficiaryFractionMap;\n    int256 public totalBeneficiaryFraction;\n\n    \n    \n    \n    event RegisterAccrualBeneficiaryEvent(Beneficiary beneficiary, int256 fraction);\n    event DeregisterAccrualBeneficiaryEvent(Beneficiary beneficiary);\n\n    \n    \n    \n    \n    \n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        return registerFractionalBeneficiary(AccrualBeneficiary(address(beneficiary)), ConstantsLib.PARTS_PER());\n    }\n\n    \n    \n    \n    function registerFractionalBeneficiary(AccrualBeneficiary beneficiary, int256 fraction)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        require(fraction > 0, \"Fraction not strictly positive [AccrualBenefactor.sol:59]\");\n        require(\n            totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER(),\n            \"Total beneficiary fraction out of bounds [AccrualBenefactor.sol:60]\"\n        );\n\n        if (!super.registerBeneficiary(beneficiary))\n            return false;\n\n        _beneficiaryFractionMap[address(beneficiary)] = fraction;\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\n\n        \n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\n\n        return true;\n    }\n\n    \n    \n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        if (!super.deregisterBeneficiary(beneficiary))\n            return false;\n\n        address _beneficiary = address(beneficiary);\n\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[_beneficiary]);\n        _beneficiaryFractionMap[_beneficiary] = 0;\n\n        \n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    \n    function beneficiaryFraction(AccrualBeneficiary beneficiary)\n    public\n    view\n    returns (int256)\n    {\n        return _beneficiaryFractionMap[address(beneficiary)];\n    }\n}\n\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    FungibleBalanceLib.Balance periodAccrual;\n    CurrenciesLib.Currencies periodCurrencies;\n\n    FungibleBalanceLib.Balance aggregateAccrual;\n    CurrenciesLib.Currencies aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    \n    \n    \n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent();\n    event RegisterServiceEvent(address service);\n    event DeregisterServiceEvent(address service);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        \n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        \n        txHistory.addDeposit(amount, address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [RevenueFund.sol:115]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [RevenueFund.sol:124]\");\n\n        \n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        \n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        \n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    \n    \n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyOperator\n    {\n        require(\n            ConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n            \"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n        );\n\n        \n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\n\n            if (0 >= remaining)\n                continue;\n\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\n                AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n                if (beneficiaryFraction(beneficiary) > 0) {\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\n                    .mul(beneficiaryFraction(beneficiary))\n                    .div(ConstantsLib.PARTS_PER());\n\n                    if (transferable > remaining)\n                        transferable = remaining;\n\n                    if (transferable > 0) {\n                        \n                        if (currency.ct == address(0))\n                            beneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n                        \n                        else {\n                            TransferController controller = transferController(currency.ct, \"\");\n                            (bool success,) = address(controller).delegatecall(\n                                abi.encodeWithSelector(\n                                    controller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n                                )\n                            );\n                            require(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\n                            beneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n                        }\n\n                        remaining = remaining.sub(transferable);\n                    }\n                }\n            }\n\n            \n            periodAccrual.set(remaining, currency.ct, currency.id);\n        }\n\n        \n        for (uint256 j = 0; j < beneficiaries.length; j++) {\n            AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n            \n            if (0 >= beneficiaryFraction(beneficiary))\n                continue;\n\n            \n            beneficiary.closeAccrualPeriod(currencies);\n        }\n\n        \n        emit CloseAccrualPeriodEvent();\n    }\n}\n\nlibrary Strings {\n\n    \n    function concat(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length > 0);\n\n        string memory _tmpValue = new string(_baseBytes.length +\n            _valueBytes.length);\n        bytes memory _newValue = bytes(_tmpValue);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < _baseBytes.length; i++) {\n            _newValue[j++] = _baseBytes[i];\n        }\n\n        for (i = 0; i < _valueBytes.length; i++) {\n            _newValue[j++] = _valueBytes[i];\n        }\n\n        return string(_newValue);\n    }\n\n    \n    function indexOf(string memory _base, string memory _value)\n        internal\n        pure\n        returns (int) {\n        return _indexOf(_base, _value, 0);\n    }\n\n    \n    function _indexOf(string memory _base, string memory _value, uint _offset)\n        internal\n        pure\n        returns (int) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint i = _offset; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] == _valueBytes[0]) {\n                return int(i);\n            }\n        }\n\n        return -1;\n    }\n\n    \n    function length(string memory _base)\n        internal\n        pure\n        returns (uint) {\n        bytes memory _baseBytes = bytes(_base);\n        return _baseBytes.length;\n    }\n\n    \n    function substring(string memory _base, int _length)\n        internal\n        pure\n        returns (string memory) {\n        return _substring(_base, _length, 0);\n    }\n\n    \n    function _substring(string memory _base, int _length, int _offset)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n\n        assert(uint(_offset + _length) <= _baseBytes.length);\n\n        string memory _tmp = new string(uint(_length));\n        bytes memory _tmpBytes = bytes(_tmp);\n\n        uint j = 0;\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\n            _tmpBytes[j++] = _baseBytes[i];\n        }\n\n        return string(_tmpBytes);\n    }\n\n    \n    function split(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string[] memory splitArr) {\n        bytes memory _baseBytes = bytes(_base);\n\n        uint _offset = 0;\n        uint _splitsCount = 1;\n        while (_offset < _baseBytes.length - 1) {\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1)\n                break;\n            else {\n                _splitsCount++;\n                _offset = uint(_limit) + 1;\n            }\n        }\n\n        splitArr = new string[](_splitsCount);\n\n        _offset = 0;\n        _splitsCount = 0;\n        while (_offset < _baseBytes.length - 1) {\n\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == - 1) {\n                _limit = int(_baseBytes.length);\n            }\n\n            string memory _tmp = new string(uint(_limit) - _offset);\n            bytes memory _tmpBytes = bytes(_tmp);\n\n            uint j = 0;\n            for (uint i = _offset; i < uint(_limit); i++) {\n                _tmpBytes[j++] = _baseBytes[i];\n            }\n            _offset = uint(_limit) + 1;\n            splitArr[_splitsCount++] = string(_tmpBytes);\n        }\n        return splitArr;\n    }\n\n    \n    function compareTo(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    function compareToIgnoreCase(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i] &&\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    function upper(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    \n    function lower(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    \n    function _upper(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    \n    function _lower(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n\ncontract PartnerFund is Ownable, Beneficiary, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using Strings for string;\n\n    \n    \n    \n    struct Partner {\n        bytes32 nameHash;\n\n        uint256 fee;\n        address wallet;\n        uint256 index;\n\n        bool operatorCanUpdate;\n        bool partnerCanUpdate;\n\n        FungibleBalanceLib.Balance active;\n        FungibleBalanceLib.Balance staged;\n\n        TxHistoryLib.TxHistory txHistory;\n        FullBalanceHistory[] fullBalanceHistory;\n    }\n\n    struct FullBalanceHistory {\n        uint256 listIndex;\n        int256 balance;\n        uint256 blockNumber;\n    }\n\n    \n    \n    \n    Partner[] private partners;\n\n    mapping(bytes32 => uint256) private _indexByNameHash;\n    mapping(address => uint256) private _indexByWallet;\n\n    \n    \n    \n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event RegisterPartnerByNameEvent(string name, uint256 fee, address wallet);\n    event RegisterPartnerByNameHashEvent(bytes32 nameHash, uint256 fee, address wallet);\n    event SetFeeByIndexEvent(uint256 index, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameEvent(string name, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameHashEvent(bytes32 nameHash, uint256 oldFee, uint256 newFee);\n    event SetFeeByWalletEvent(address wallet, uint256 oldFee, uint256 newFee);\n    event SetPartnerWalletByIndexEvent(uint256 index, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameEvent(string name, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameHashEvent(bytes32 nameHash, address oldWallet, address newWallet);\n    event SetPartnerWalletByWalletEvent(address oldWallet, address newWallet);\n    event StageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function() external payable {\n        _receiveEthersTo(\n            indexByWallet(msg.sender) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    \n    \n    function receiveEthersTo(address tag, string memory)\n    public\n    payable\n    {\n        _receiveEthersTo(\n            uint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            indexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            uint256(tag) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    \n    \n    \n    function hashName(string memory name)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(name.upper()));\n    }\n\n    \n    \n    \n    \n    function depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        require(0 < partnerIndex && partnerIndex <= partners.length, \"Some error message when require fails [PartnerFund.sol:160]\");\n\n        return _depositByIndices(partnerIndex - 1, depositIndex);\n    }\n\n    \n    \n    \n    \n    function depositByName(string memory name, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        return _depositByIndices(indexByName(name) - 1, depositIndex);\n    }\n\n    \n    \n    \n    \n    function depositByNameHash(bytes32 nameHash, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        return _depositByIndices(indexByNameHash(nameHash) - 1, depositIndex);\n    }\n\n    \n    \n    \n    \n    function depositByWallet(address wallet, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        return _depositByIndices(indexByWallet(wallet) - 1, depositIndex);\n    }\n\n    \n    \n    \n    function depositsCountByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:213]\");\n\n        return _depositsCountByIndex(index - 1);\n    }\n\n    \n    \n    \n    function depositsCountByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _depositsCountByIndex(indexByName(name) - 1);\n    }\n\n    \n    \n    \n    function depositsCountByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _depositsCountByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    \n    \n    \n    function depositsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _depositsCountByIndex(indexByWallet(wallet) - 1);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:265]\");\n\n        return _activeBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _activeBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _activeBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:323]\");\n\n        return _stagedBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _stagedBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _stagedBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    function partnersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return partners.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    function registerByName(string memory name, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        \n        require(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n        \n        bytes32 nameHash = hashName(name);\n\n        \n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        \n        emit RegisterPartnerByNameEvent(name, fee, wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        \n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        \n        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);\n    }\n\n    \n    \n    \n    function indexByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByNameHash[nameHash];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:431]\");\n        return index;\n    }\n\n    \n    \n    \n    function indexByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        return indexByNameHash(hashName(name));\n    }\n\n    \n    \n    \n    function indexByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByWallet[wallet];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:455]\");\n        return index;\n    }\n\n    \n    \n    \n    function isRegisteredByName(string memory name)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[hashName(name)]);\n    }\n\n    \n    \n    \n    function isRegisteredByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[nameHash]);\n    }\n\n    \n    \n    \n    function isRegisteredByWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByWallet[wallet]);\n    }\n\n    \n    \n    \n    function feeByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:501]\");\n\n        return _partnerFeeByIndex(index - 1);\n    }\n\n    \n    \n    \n    function feeByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _partnerFeeByIndex(indexByName(name) - 1);\n    }\n\n    \n    \n    \n    function feeByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _partnerFeeByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    \n    \n    \n    function feeByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _partnerFeeByIndex(indexByWallet(wallet) - 1);\n    }\n\n    \n    \n    \n    function setFeeByIndex(uint256 index, uint256 newFee)\n    public\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:549]\");\n\n        \n        uint256 oldFee = _setPartnerFeeByIndex(index - 1, newFee);\n\n        \n        emit SetFeeByIndexEvent(index, oldFee, newFee);\n    }\n\n    \n    \n    \n    function setFeeByName(string memory name, uint256 newFee)\n    public\n    {\n        \n        uint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n        \n        emit SetFeeByNameEvent(name, oldFee, newFee);\n    }\n\n    \n    \n    \n    function setFeeByNameHash(bytes32 nameHash, uint256 newFee)\n    public\n    {\n        \n        uint256 oldFee = _setPartnerFeeByIndex(indexByNameHash(nameHash) - 1, newFee);\n\n        \n        emit SetFeeByNameHashEvent(nameHash, oldFee, newFee);\n    }\n\n    \n    \n    \n    function setFeeByWallet(address wallet, uint256 newFee)\n    public\n    {\n        \n        uint256 oldFee = _setPartnerFeeByIndex(indexByWallet(wallet) - 1, newFee);\n\n        \n        emit SetFeeByWalletEvent(wallet, oldFee, newFee);\n    }\n\n    \n    \n    \n    function walletByIndex(uint256 index)\n    public\n    view\n    returns (address)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:606]\");\n\n        return partners[index - 1].wallet;\n    }\n\n    \n    \n    \n    function walletByName(string memory name)\n    public\n    view\n    returns (address)\n    {\n        \n        return partners[indexByName(name) - 1].wallet;\n    }\n\n    \n    \n    \n    function walletByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (address)\n    {\n        \n        return partners[indexByNameHash(nameHash) - 1].wallet;\n    }\n\n    \n    \n    \n    function setWalletByIndex(uint256 index, address newWallet)\n    public\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:642]\");\n\n        \n        address oldWallet = _setPartnerWalletByIndex(index - 1, newWallet);\n\n        \n        emit SetPartnerWalletByIndexEvent(index, oldWallet, newWallet);\n    }\n\n    \n    \n    \n    function setWalletByName(string memory name, address newWallet)\n    public\n    {\n        \n        address oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n        \n        emit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n    }\n\n    \n    \n    \n    function setWalletByNameHash(bytes32 nameHash, address newWallet)\n    public\n    {\n        \n        address oldWallet = _setPartnerWalletByIndex(indexByNameHash(nameHash) - 1, newWallet);\n\n        \n        emit SetPartnerWalletByNameHashEvent(nameHash, oldWallet, newWallet);\n    }\n\n    \n    \n    \n    function setWalletByWallet(address oldWallet, address newWallet)\n    public\n    {\n        \n        _setPartnerWalletByIndex(indexByWallet(oldWallet) - 1, newWallet);\n\n        \n        emit SetPartnerWalletByWalletEvent(oldWallet, newWallet);\n    }\n\n    \n    \n    \n    \n    function stage(int256 amount, address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        uint256 index = indexByWallet(msg.sender);\n\n        \n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:701]\");\n\n        \n        amount = amount.clampMax(partners[index - 1].active.get(currencyCt, currencyId));\n\n        partners[index - 1].active.sub(amount, currencyCt, currencyId);\n        partners[index - 1].staged.add(amount, currencyCt, currencyId);\n\n        partners[index - 1].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        partners[index - 1].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index - 1].txHistory.depositsCount() - 1,\n                partners[index - 1].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        \n        emit StageEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        uint256 index = indexByWallet(msg.sender);\n\n        \n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n        \n        amount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\n        partners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n        }\n\n        \n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function _receiveEthersTo(uint256 index, int256 amount)\n    private\n    {\n        \n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:769]\");\n\n        \n        partners[index].active.add(amount, address(0), 0);\n        partners[index].txHistory.addDeposit(amount, address(0), 0);\n\n        \n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(address(0), 0),\n                block.number\n            )\n        );\n\n        \n        emit ReceiveEvent(msg.sender, amount, address(0), 0);\n    }\n\n    \n    function _receiveTokensTo(uint256 index, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    private\n    {\n        \n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:794]\");\n\n        require(amount.isNonZeroPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:796]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Some error message when require fails [PartnerFund.sol:805]\");\n\n        \n        partners[index].active.add(amount, currencyCt, currencyId);\n        partners[index].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        \n        emit ReceiveEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    \n    function _depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    private\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(depositIndex < partners[partnerIndex].fullBalanceHistory.length, \"Some error message when require fails [PartnerFund.sol:830]\");\n\n        FullBalanceHistory storage entry = partners[partnerIndex].fullBalanceHistory[depositIndex];\n        (,, currencyCt, currencyId) = partners[partnerIndex].txHistory.deposit(entry.listIndex);\n\n        balance = entry.balance;\n        blockNumber = entry.blockNumber;\n    }\n\n    \n    function _depositsCountByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fullBalanceHistory.length;\n    }\n\n    \n    function _activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].active.get(currencyCt, currencyId);\n    }\n\n    \n    function _stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].staged.get(currencyCt, currencyId);\n    }\n\n    function _registerPartnerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    private\n    {\n        \n        require(0 == _indexByNameHash[nameHash], \"Some error message when require fails [PartnerFund.sol:871]\");\n\n        \n        require(partnerCanUpdate || operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:874]\");\n\n        \n        partners.length++;\n\n        \n        uint256 index = partners.length;\n\n        \n        partners[index - 1].nameHash = nameHash;\n        partners[index - 1].fee = fee;\n        partners[index - 1].wallet = wallet;\n        partners[index - 1].partnerCanUpdate = partnerCanUpdate;\n        partners[index - 1].operatorCanUpdate = operatorCanUpdate;\n        partners[index - 1].index = index;\n\n        \n        _indexByNameHash[nameHash] = index;\n\n        \n        _indexByWallet[wallet] = index;\n    }\n\n    \n    function _setPartnerFeeByIndex(uint256 index, uint256 fee)\n    private\n    returns (uint256)\n    {\n        uint256 oldFee = partners[index].fee;\n\n        \n        if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:906]\");\n\n        else {\n            \n            require(msg.sender == partners[index].wallet, \"Some error message when require fails [PartnerFund.sol:910]\");\n\n            \n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:913]\");\n        }\n\n        \n        partners[index].fee = fee;\n\n        return oldFee;\n    }\n\n    \n    function _setPartnerWalletByIndex(uint256 index, address newWallet)\n    private\n    returns (address)\n    {\n        address oldWallet = partners[index].wallet;\n\n        \n        if (oldWallet == address(0))\n            require(isOperator(), \"Some error message when require fails [PartnerFund.sol:931]\");\n\n        \n        else if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:935]\");\n\n        else {\n            \n            require(msg.sender == oldWallet, \"Some error message when require fails [PartnerFund.sol:939]\");\n\n            \n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:942]\");\n\n            \n            require(partners[index].operatorCanUpdate || newWallet != address(0), \"Some error message when require fails [PartnerFund.sol:945]\");\n        }\n\n        \n        partners[index].wallet = newWallet;\n\n        \n        if (oldWallet != address(0))\n            _indexByWallet[oldWallet] = 0;\n        if (newWallet != address(0))\n            _indexByWallet[newWallet] = index;\n\n        return oldWallet;\n    }\n\n    \n    function _partnerFeeByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fee;\n    }\n}\n\nlibrary DriipSettlementTypesLib {\n    \n    \n    \n    enum SettlementRole {Origin, Target}\n\n    struct SettlementParty {\n        uint256 nonce;\n        address wallet;\n        uint256 doneBlockNumber;\n    }\n\n    struct Settlement {\n        string settledKind;\n        bytes32 settledHash;\n        SettlementParty origin;\n        SettlementParty target;\n    }\n}\n\ncontract DriipSettlementState is Ownable, Servable, CommunityVotable, Upgradable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    string constant public INIT_SETTLEMENT_ACTION = \"init_settlement\";\n    string constant public COMPLETE_SETTLEMENT_ACTION = \"complete_settlement\";\n    string constant public SET_MAX_NONCE_ACTION = \"set_max_nonce\";\n    string constant public ADD_SETTLED_AMOUNT_ACTION = \"add_settled_amount\";\n    string constant public SET_TOTAL_FEE_ACTION = \"set_total_fee\";\n\n    \n    \n    \n    uint256 public maxDriipNonce;\n\n    DriipSettlementTypesLib.Settlement[] public settlements;\n    mapping(address => uint256[]) public walletSettlementIndices;\n    mapping(address => mapping(uint256 => uint256)) public walletNonceSettlementIndex;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyMaxNonce;\n\n    mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => int256)))) public walletCurrencyBlockNumberSettledAmount;\n    mapping(address => mapping(address => mapping(uint256 => uint256[]))) public walletCurrencySettledBlockNumbers;\n\n    mapping(address => mapping(address => mapping(address => mapping(address => mapping(uint256 => MonetaryTypesLib.NoncedAmount))))) public totalFeesMap;\n\n    \n    \n    \n    event InitSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n    event CompleteSettlementPartyEvent(address wallet, uint256 nonce, DriipSettlementTypesLib.SettlementRole settlementRole,\n        uint256 doneBlockNumber);\n    event SetMaxDriipNonceEvent(uint256 maxDriipNonce);\n    event UpdateMaxDriipNonceFromCommunityVoteEvent(uint256 maxDriipNonce);\n    event SetMaxNonceByWalletAndCurrencyEvent(address wallet, MonetaryTypesLib.Currency currency,\n        uint256 maxNonce);\n    event AddSettledAmountEvent(address wallet, int256 amount, MonetaryTypesLib.Currency currency,\n        uint256 blockNumber);\n    event SetTotalFeeEvent(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount totalFee);\n    event UpgradeSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n    event UpgradeSettledAmountEvent(address wallet, int256 amount, MonetaryTypesLib.Currency currency,\n        uint256 blockNumber);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function settlementsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return settlements.length;\n    }\n\n    \n    \n    \n    function settlementsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementIndices[wallet].length;\n    }\n\n    \n    \n    \n    \n    function settlementByWalletAndIndex(address wallet, uint256 index)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(walletSettlementIndices[wallet].length > index, \"Index out of bounds [DriipSettlementState.sol:114]\");\n        return settlements[walletSettlementIndices[wallet][index] - 1];\n    }\n\n    \n    \n    \n    \n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(0 != walletNonceSettlementIndex[wallet][nonce], \"No settlement found for wallet and nonce [DriipSettlementState.sol:127]\");\n        return settlements[walletNonceSettlementIndex[wallet][nonce] - 1];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\n        uint256 originNonce, address targetWallet, uint256 targetNonce)\n    public\n    onlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n    {\n        if (\n            0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n            0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n        ) {\n            \n            settlements.length++;\n\n            \n            uint256 index = settlements.length - 1;\n\n            \n            settlements[index].settledKind = settledKind;\n            settlements[index].settledHash = settledHash;\n            settlements[index].origin.nonce = originNonce;\n            settlements[index].origin.wallet = originWallet;\n            settlements[index].target.nonce = targetNonce;\n            settlements[index].target.wallet = targetWallet;\n\n            \n            emit InitSettlementEvent(settlements[index]);\n\n            \n            index++;\n            walletSettlementIndices[originWallet].push(index);\n            walletSettlementIndices[targetWallet].push(index);\n            walletNonceSettlementIndex[originWallet][originNonce] = index;\n            walletNonceSettlementIndex[targetWallet][targetNonce] = index;\n        }\n    }\n\n    \n    \n    \n    \n    \n    function completeSettlement(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done)\n    public\n    onlyEnabledServiceAction(COMPLETE_SETTLEMENT_ACTION)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:188]\");\n\n        \n        DriipSettlementTypesLib.SettlementParty storage party =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin :\n        settlements[index - 1].target;\n\n        \n        party.doneBlockNumber = done ? block.number : 0;\n\n        \n        emit CompleteSettlementPartyEvent(wallet, nonce, settlementRole, party.doneBlockNumber);\n    }\n\n    \n    \n    \n    \n    function isSettlementPartyDone(address wallet, uint256 nonce)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        if (0 == index)\n            return false;\n\n        \n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        0 != settlements[index - 1].origin.doneBlockNumber :\n        0 != settlements[index - 1].target.doneBlockNumber\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function isSettlementPartyDone(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        if (0 == index)\n            return false;\n\n        \n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        \n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:252]\");\n\n        \n        return 0 != settlementParty.doneBlockNumber;\n    }\n\n    \n    \n    \n    \n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce)\n    public\n    view\n    returns (uint256)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:271]\");\n\n        \n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        settlements[index - 1].origin.doneBlockNumber :\n        settlements[index - 1].target.doneBlockNumber\n        );\n    }\n\n    \n    \n    \n    \n    \n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (uint256)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:296]\");\n\n        \n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        \n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:304]\");\n\n        \n        return settlementParty.doneBlockNumber;\n    }\n\n    \n    \n    function setMaxDriipNonce(uint256 _maxDriipNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        maxDriipNonce = _maxDriipNonce;\n\n        \n        emit SetMaxDriipNonceEvent(maxDriipNonce);\n    }\n\n    \n    function updateMaxDriipNonceFromCommunityVote()\n    public\n    {\n        uint256 _maxDriipNonce = communityVote.getMaxDriipNonce();\n        if (0 == _maxDriipNonce)\n            return;\n\n        maxDriipNonce = _maxDriipNonce;\n\n        \n        emit UpdateMaxDriipNonceFromCommunityVoteEvent(maxDriipNonce);\n    }\n\n    \n    \n    \n    \n    function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        return walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 maxNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        \n        walletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n        \n        emit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n    }\n\n    \n    \n    \n    \n    function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        uint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n        return walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\n    }\n\n    \n    \n    \n    \n    \n    function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    public\n    onlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\n    {\n        \n        uint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n\n        \n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\n\n        \n        walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\n\n        \n        emit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function totalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (MonetaryTypesLib.NoncedAmount memory)\n    {\n        return totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    \n    \n    function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\n    public\n    onlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\n    {\n        \n        totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n        \n        emit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n    }\n\n    \n    \n    function upgradeSettlement(DriipSettlementTypesLib.Settlement memory settlement)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(\n            0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\n            \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\n        );\n        require(\n            0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\n            \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\n        );\n\n        \n        settlements.push(settlement);\n\n        \n        uint256 index = settlements.length;\n\n        \n        walletSettlementIndices[settlement.origin.wallet].push(index);\n        walletSettlementIndices[settlement.target.wallet].push(index);\n        walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\n        walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\n\n        \n        emit UpgradeSettlementEvent(settlement);\n    }\n\n    \n    \n    \n    \n    \n    function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\n\n        \n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\n\n        \n        walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\n\n        \n        emit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\n    }\n\n    \n    \n    \n    function _walletSettledBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n    {\n        for (uint256 i = walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].length; i > 0; i--)\n            if (walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id][i - 1] <= blockNumber)\n                return walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id][i - 1];\n        return 0;\n    }\n}\n\ncontract DriipSettlementChallengeByPayment is Ownable, ConfigurableOperational, Validatable, WalletLockable,\nBalanceTrackable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using BalanceTrackerLib for BalanceTracker;\n\n    \n    \n    \n    DriipSettlementDisputeByPayment public driipSettlementDisputeByPayment;\n    DriipSettlementChallengeState public driipSettlementChallengeState;\n    NullSettlementChallengeState public nullSettlementChallengeState;\n    DriipSettlementState public driipSettlementState;\n\n    \n    \n    \n    event SetDriipSettlementDisputeByPaymentEvent(DriipSettlementDisputeByPayment oldDriipSettlementDisputeByPayment,\n        DriipSettlementDisputeByPayment newDriipSettlementDisputeByPayment);\n    event SetDriipSettlementChallengeStateEvent(DriipSettlementChallengeState oldDriipSettlementChallengeState,\n        DriipSettlementChallengeState newDriipSettlementChallengeState);\n    event SetNullSettlementChallengeStateEvent(NullSettlementChallengeState oldNullSettlementChallengeState,\n        NullSettlementChallengeState newNullSettlementChallengeState);\n    event SetDriipSettlementStateEvent(DriipSettlementState oldDriipSettlementState,\n        DriipSettlementState newDriipSettlementState);\n    event StartChallengeFromPaymentEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId);\n    event StartChallengeFromPaymentByProxyEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId, address proxy);\n    event StopChallengeEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId);\n    event StopChallengeByProxyEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId, address proxy);\n    event ChallengeByPaymentEvent(address challengedWallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId, address challengerWallet);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function setDriipSettlementDisputeByPayment(DriipSettlementDisputeByPayment newDriipSettlementDisputeByPayment)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementDisputeByPayment))\n    {\n        DriipSettlementDisputeByPayment oldDriipSettlementDisputeByPayment = driipSettlementDisputeByPayment;\n        driipSettlementDisputeByPayment = newDriipSettlementDisputeByPayment;\n        emit SetDriipSettlementDisputeByPaymentEvent(oldDriipSettlementDisputeByPayment, driipSettlementDisputeByPayment);\n    }\n\n    \n    \n    function setDriipSettlementChallengeState(DriipSettlementChallengeState newDriipSettlementChallengeState)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementChallengeState))\n    {\n        DriipSettlementChallengeState oldDriipSettlementChallengeState = driipSettlementChallengeState;\n        driipSettlementChallengeState = newDriipSettlementChallengeState;\n        emit SetDriipSettlementChallengeStateEvent(oldDriipSettlementChallengeState, driipSettlementChallengeState);\n    }\n\n    \n    \n    function setNullSettlementChallengeState(NullSettlementChallengeState newNullSettlementChallengeState)\n    public\n    onlyDeployer\n    notNullAddress(address(newNullSettlementChallengeState))\n    {\n        NullSettlementChallengeState oldNullSettlementChallengeState = nullSettlementChallengeState;\n        nullSettlementChallengeState = newNullSettlementChallengeState;\n        emit SetNullSettlementChallengeStateEvent(oldNullSettlementChallengeState, nullSettlementChallengeState);\n    }\n\n    \n    \n    function setDriipSettlementState(DriipSettlementState newDriipSettlementState)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementState))\n    {\n        DriipSettlementState oldDriipSettlementState = driipSettlementState;\n        driipSettlementState = newDriipSettlementState;\n        emit SetDriipSettlementStateEvent(oldDriipSettlementState, driipSettlementState);\n    }\n\n    \n    \n    \n    function startChallengeFromPayment(PaymentTypesLib.Payment memory payment, int256 stageAmount)\n    public\n    {\n        \n        require(!walletLocker.isLocked(msg.sender), \"Wallet found locked [DriipSettlementChallengeByPayment.sol:134]\");\n\n        \n        _startChallengeFromPayment(msg.sender, payment, stageAmount, true);\n\n        \n        emit StartChallengeFromPaymentEvent(\n            msg.sender,\n            driipSettlementChallengeState.proposalNonce(msg.sender, payment.currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(msg.sender, payment.currency),\n            stageAmount,\n            driipSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, payment.currency),\n            payment.currency.ct, payment.currency.id\n        );\n    }\n\n    \n    \n    \n    \n    function startChallengeFromPaymentByProxy(address wallet, PaymentTypesLib.Payment memory payment, int256 stageAmount)\n    public\n    onlyOperator\n    {\n        \n        _startChallengeFromPayment(wallet, payment, stageAmount, false);\n\n        \n        emit StartChallengeFromPaymentByProxyEvent(\n            wallet,\n            driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\n            stageAmount,\n            driipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\n            payment.currency.ct, payment.currency.id, msg.sender\n        );\n    }\n\n    \n    \n    \n    function stopChallenge(address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\n\n        \n        _stopChallenge(msg.sender, currency, true, true);\n\n        \n        emit StopChallengeEvent(\n            msg.sender,\n            driipSettlementChallengeState.proposalNonce(msg.sender, currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(msg.sender, currency),\n            driipSettlementChallengeState.proposalStageAmount(msg.sender, currency),\n            driipSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, currency),\n            currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    function stopChallengeByProxy(address wallet, address currencyCt, uint256 currencyId)\n    public\n    onlyOperator\n    {\n        \n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\n\n        \n        _stopChallenge(wallet, currency, true, false);\n\n        \n        emit StopChallengeByProxyEvent(\n            wallet,\n            driipSettlementChallengeState.proposalNonce(wallet, currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, currency),\n            driipSettlementChallengeState.proposalStageAmount(wallet, currency),\n            driipSettlementChallengeState.proposalTargetBalanceAmount(wallet, currency),\n            currencyCt, currencyId, msg.sender\n        );\n    }\n\n    \n    \n    \n    \n    \n    function hasProposal(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.hasProposal(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function hasProposalTerminated(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.hasProposalTerminated(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function hasProposalExpired(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.hasProposalExpired(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalNonce(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalNonce(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalReferenceBlockNumber(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalReferenceBlockNumber(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalExpirationTime(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalExpirationTime(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalStatus(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        return driipSettlementChallengeState.proposalStatus(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalStageAmount(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return driipSettlementChallengeState.proposalStageAmount(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalTargetBalanceAmount(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return driipSettlementChallengeState.proposalTargetBalanceAmount(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalChallengedHash(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bytes32)\n    {\n        return driipSettlementChallengeState.proposalChallengedHash(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalChallengedKind(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (string memory)\n    {\n        return driipSettlementChallengeState.proposalChallengedKind(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalWalletInitiated(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.proposalWalletInitiated(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalDisqualificationChallenger(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationChallenger(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n    \n    \n    \n    \n    \n    function proposalDisqualificationBlockNumber(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationBlockNumber(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalDisqualificationCandidateKind(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (string memory)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationCandidateKind(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function proposalDisqualificationCandidateHash(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bytes32)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationCandidateHash(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    \n    \n    \n    function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment)\n    public\n    onlyOperationalModeNormal\n    {\n        \n        driipSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\n\n        \n        emit ChallengeByPaymentEvent(\n            wallet,\n            driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\n            driipSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\n            driipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\n            payment.currency.ct, payment.currency.id, msg.sender\n        );\n    }\n\n    \n    \n    \n    function _startChallengeFromPayment(address wallet, PaymentTypesLib.Payment memory payment,\n        int256 stageAmount, bool walletInitiated)\n    private\n    onlySealedPayment(payment)\n    {\n        \n        require(\n            block.number >= configuration.earliestSettlementBlockNumber(),\n            \"Current block number below earliest settlement block number [DriipSettlementChallengeByPayment.sol:489]\"\n        );\n\n        \n        require(\n            validator.isPaymentParty(payment, wallet),\n            \"Wallet is not payment party [DriipSettlementChallengeByPayment.sol:495]\"\n        );\n\n        \n        require(\n            !driipSettlementChallengeState.hasProposal(wallet, payment.currency) ||\n        driipSettlementChallengeState.hasProposalTerminated(wallet, payment.currency),\n            \"Overlapping driip settlement challenge proposal found [DriipSettlementChallengeByPayment.sol:501]\"\n        );\n\n        \n        require(\n            !nullSettlementChallengeState.hasProposal(wallet, payment.currency) ||\n        nullSettlementChallengeState.hasProposalTerminated(wallet, payment.currency),\n            \"Overlapping null settlement challenge proposal found [DriipSettlementChallengeByPayment.sol:508]\"\n        );\n\n        \n        (uint256 nonce, int256 correctedCumulativeTransferAmount) = _paymentPartyProperties(payment, wallet);\n\n        \n        require(\n            driipSettlementState.maxNonceByWalletAndCurrency(wallet, payment.currency) < nonce,\n            \"Wallet's nonce below highest settled nonce [DriipSettlementChallengeByPayment.sol:518]\"\n        );\n\n        \n        \n        driipSettlementChallengeState.initiateProposal(\n            wallet, nonce, correctedCumulativeTransferAmount, stageAmount,\n            balanceTracker.fungibleActiveBalanceAmount(wallet, payment.currency)\n            .add(correctedCumulativeTransferAmount.sub(stageAmount)),\n            payment.currency, payment.blockNumber,\n            walletInitiated, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n        );\n    }\n\n    function _stopChallenge(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce, bool walletTerminated)\n    private\n    {\n        \n        require(\n            driipSettlementChallengeState.hasProposal(wallet, currency),\n            \"No proposal found [DriipSettlementChallengeByPayment.sol:538]\"\n        );\n        require(\n            !driipSettlementChallengeState.hasProposalTerminated(wallet, currency),\n            \"Proposal found terminated [DriipSettlementChallengeByPayment.sol:542]\"\n        );\n\n        \n        driipSettlementChallengeState.terminateProposal(wallet, currency, clearNonce, walletTerminated);\n\n        \n        nullSettlementChallengeState.terminateProposal(wallet, currency);\n    }\n\n    function _paymentPartyProperties(PaymentTypesLib.Payment memory payment, address wallet)\n    private\n    view\n    returns (uint256 nonce, int256 correctedCumulativeTransferAmount)\n    {\n        \n        int256 activeBalanceAmountAtPaymentBlock = balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\n            wallet, payment.currency, payment.blockNumber\n        );\n\n        \n        int256 deltaSettledBalanceAmount = driipSettlementState.settledAmountByBlockNumber(\n            wallet, payment.currency, payment.blockNumber\n        );\n\n        \n        \n        if (validator.isPaymentSender(payment, wallet)) {\n            nonce = payment.sender.nonce;\n            correctedCumulativeTransferAmount = payment.sender.balances.current\n            .sub(activeBalanceAmountAtPaymentBlock)\n            .sub(deltaSettledBalanceAmount);\n        } else {\n            nonce = payment.recipient.nonce;\n            correctedCumulativeTransferAmount = payment.recipient.balances.current\n            .sub(activeBalanceAmountAtPaymentBlock)\n            .sub(deltaSettledBalanceAmount);\n        }\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalChallengedKind\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalStatus\",\"outputs\":[{\"internalType\":\"enum SettlementChallengeTypesLib.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementDisputeByPayment\",\"outputs\":[{\"internalType\":\"contract DriipSettlementDisputeByPayment\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Validator\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalTargetBalanceAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTracker\",\"outputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLockerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementState\",\"outputs\":[{\"internalType\":\"contract DriipSettlementState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"}],\"name\":\"startChallengeFromPaymentByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"contract Validator\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposalExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTrackerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DriipSettlementState\",\"name\":\"newDriipSettlementState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalStageAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposalTerminated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"}],\"name\":\"startChallengeFromPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DriipSettlementDisputeByPayment\",\"name\":\"newDriipSettlementDisputeByPayment\",\"type\":\"address\"}],\"name\":\"setDriipSettlementDisputeByPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementChallengeState\",\"outputs\":[{\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"setBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configuration\",\"outputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"newNullSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setNullSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalReferenceBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalWalletInitiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract WalletLocker\",\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"setWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"}],\"name\":\"challengeByPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stopChallengeByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalChallengedHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationCandidateHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stopChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationCandidateKind\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLocker\",\"outputs\":[{\"internalType\":\"contract WalletLocker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullSettlementChallengeState\",\"outputs\":[{\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalExpirationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationChallenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract DriipSettlementDisputeByPayment\",\"name\":\"oldDriipSettlementDisputeByPayment\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract DriipSettlementDisputeByPayment\",\"name\":\"newDriipSettlementDisputeByPayment\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementDisputeByPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"oldDriipSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"oldNullSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"newNullSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetNullSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract DriipSettlementState\",\"name\":\"oldDriipSettlementState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract DriipSettlementState\",\"name\":\"newDriipSettlementState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StartChallengeFromPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"StartChallengeFromPaymentByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StopChallengeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"StopChallengeByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengedWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengerWallet\",\"type\":\"address\"}],\"name\":\"ChallengeByPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"oldBalanceTracker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"SetBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract WalletLocker\",\"name\":\"oldWalletLocker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract WalletLocker\",\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"SetWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Validator\",\"name\":\"oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Validator\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"SetValidatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"oldConfiguration\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"SetConfigurationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementChallengeByPayment","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"PaymentTypesLib:b99f3f4aacb6e1197a623919103b99f4b41aaef0;SafeMathUintLib:0ff948c236c8d4dfcd0168bf243314c8ff8ec967","SwarmSource":"bzzr://8377fca6c152a24ff05ca78673a209831b0e8caf71a351e7a734ab34c4fd3ad0"}]}