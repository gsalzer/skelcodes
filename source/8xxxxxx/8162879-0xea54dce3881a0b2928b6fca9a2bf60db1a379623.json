{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n * \r\n * @dev Default OpenZeppelin\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * \r\n * @dev Completely default OpenZeppelin.\r\n */\r\ncontract Ownable {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address payable newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev This has been changed slightly from OpenZeppelin to get rid of the Roles library \r\n *      and only allow owner to add pausers (and allow them to renounce).\r\n**/\r\ncontract Pauser is Ownable {\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    mapping (address => bool) private pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return pausers[account];\r\n    }\r\n\r\n    function addPauser(address account) public onlyOwner {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser(address account) public {\r\n        require(msg.sender == account || isOwner());\r\n        _removePauser(account);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        pausers[account] = true;\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        pausers[account] = false;\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable  is Pauser {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyDateTime {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        uint year;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        uint year;\r\n        uint month;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n        \r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Subscriptions allows recurring payments to be made to businesses or individuals with\r\n *      no interaction by the user required after the initial subscription.\r\n**/\r\ncontract PostAuditSubscriptions is Pausable {\r\n\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n    using BokkyDateTime for *;\r\n\r\n    // Contract that will be inputting date and prices.\r\n    address public subOracle;\r\n\r\n    // Incrementing ID count to assign ID when a new subscription is created.\r\n    // First ID is 1.\r\n    uint256 public idCount;\r\n\r\n    // Addresses to pay out fees to.\r\n    address public monarch;\r\n\r\n    // Fee to be sent to the Monarch wallet--a value of 100 == 1%.\r\n    uint256 public adminFee;\r\n\r\n    // Gas amount that will be paid for each payment call and the maximum gas price that can be used.\r\n    uint256 public gasAmt;\r\n    uint256 public gasPriceCap;\r\n\r\n    // User => subscription id => subscription details.\r\n    // Need to change to account for monthly payments and set length.\r\n    mapping (address => mapping (uint256 => Subscription)) public subscriptions;\r\n\r\n    // ID => universal data for subscription types.\r\n    mapping (uint256 => Template) public templates;\r\n\r\n    // IERC20 and Ether balances of users\r\n    mapping (address => mapping (address => uint256)) public balances;\r\n\r\n    // Mapping of tokens that are approved to be used as payment to their number of decimals (we don't want to take fees in worthless tokens).\r\n    mapping (address => uint256) public approvedTokens;\r\n\r\n    // Mapping of token => eth conversion in order to pay payment senders accurately. Only able to be changed by SubOracle. uint256 = amount of wei 1 token is worth.\r\n    mapping (address => uint256) public tokenPrices;\r\n\r\n    // Emitted when a company creates a new subscription structure.\r\n    event Creation(uint256 indexed id, address indexed recipient, address token, uint256 price, uint256 interval,\r\n                   uint8 target, bool setLen, uint48 payments, address creator, bool payNow, bool payInFiat);\r\n\r\n    // User deposits Ether or IERC20 tokens to the contract.\r\n    event Deposit(address indexed user, address indexed token, uint256 balance);\r\n\r\n    // User withdraws Ether or IERC20 tokens from the contract.\r\n    event Withdrawal(address indexed user, address indexed token, uint256 balance);\r\n\r\n    // Used for when balance changes outside of deposit and withdrawal.\r\n    event NewBals(address[4] users, uint256[4] balances, address token);\r\n\r\n    // Emitted if a payment is attempting to be made for a subscription that never existed, has been cancelled, or is not yet due.\r\n    event NotDue(address indexed user, uint256 indexed id);\r\n\r\n    // Emit user, id of subscription, and time for subscription payment.\r\n    event Paid(address indexed user, uint256 indexed id, uint48 nextDue, uint256 datetime, bool setLen, uint48 paymentsLeft);\r\n\r\n    // Emit user, id of subscription, and time for a payment failure.\r\n    event Failed(address indexed user, uint256 indexed id, uint256 datetime);\r\n\r\n    // Emit user, id, and time for new subscription.\r\n    event Subscribed(address indexed user, uint256 indexed id, uint256 datetime, uint48 nextDue);\r\n\r\n    // Emit user, id, and time for cancelled subscription.\r\n    event Unsubscribed(address indexed user, uint256 indexed id, uint256 datetime);\r\n\r\n    /**\r\n     * @dev Data for a subscription type created by company.\r\n     * @param price The price of the template in token wei or USD wei in the case of payInFiat.\r\n     * @param recipient Company/entity to receive funds.\r\n     * @param token Token to receive funds in.\r\n     * @param amount Amount of the token to receive.\r\n     * @param interval Number of seconds between each payment.\r\n     * @param monthly Whether this is made on a specific day of the month.\r\n     * @param target If monthly, this is the day of the month that the payment should be made.\r\n     * @param setLen Whether or not the subscriptions will have a fixed number of payments.\r\n     * @param payments The number of payments to be made before the subscription cancels if setLen.\r\n     * @param creator The address that created this template.\r\n     * @param payNow Whether or not the first payment should be made immediately.\r\n     * @param payInFiat Allows the template to be paid using a token's USD value.\r\n    **/\r\n    struct Template {\r\n        uint256 price;\r\n        address recipient;\r\n        uint48 interval;\r\n        uint8 target;\r\n        address token;\r\n        bool setLen;\r\n        uint48 payments;\r\n        address creator;\r\n        bool payNow;\r\n        bool payInFiat;\r\n    }\r\n\r\n    /**\r\n     * @dev Data for each individual subscription.\r\n     * @param startTime The original unix time this subscription was created.\r\n     * @param lastPaid The last time this subscription was paid, either unix time or month.\r\n     * @param nextDue The next unix time or next month that the subscription is due.\r\n     * @param paymentsLeft The amount of payments left (if the template is setLen)\r\n     * @param startPaid Whether or not the user has paid the first installment of a payNow template.\r\n    **/\r\n    struct Subscription {\r\n        uint48 startTime;\r\n        uint48 lastPaid;\r\n        uint48 nextDue;\r\n        uint48 paymentsLeft;\r\n        bool startPaid;\r\n    }\r\n\r\n/** ************************************************* Constructor ******************************************************** **/\r\n\r\n    /**\r\n     * @param _subOracle The address of the subscription Oracle contract that will be fetching token prices.\r\n     * @param _monarch The Monarch wallet that will be receiving admin fees.\r\n    **/\r\n    constructor(address _subOracle, address _monarch)\r\n      public\r\n    {\r\n        subOracle = _subOracle;\r\n        approveToken(address(0), true);\r\n        approveToken(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359, true);\r\n        tokenPrices[address(0)] = 1 ether;\r\n        setMonarch(_monarch);\r\n        setAdminFee(100);\r\n\r\n        // 40 gwei for test, will lower.\r\n        setGasFees(85000, 40000000000);\r\n    }\r\n\r\n/** ************************************************* Deposit/Withdrawal ******************************************************** **/\r\n\r\n    /**\r\n     * @dev Deposit an IERC20 or Ether to the contract to fund it for subscriptions.\r\n     * @param _token The address of the token to deposit (0x000... for Ether).\r\n     * @param _amount The amount of the token to deposit (for Ether this will change to msg.value).\r\n    **/\r\n    function deposit(address _token, uint256 _amount)\r\n      public\r\n      payable\r\n      whenNotPaused\r\n    {\r\n        require(approvedTokens[_token] > 0, \"You may only deposit approved tokens.\");\r\n        require(_amount > 0, \"You must deposit a non-zero amount.\");\r\n\r\n        if (_token != address(0)) {\r\n\r\n            IERC20 token = IERC20(_token);\r\n            SafeERC20.safeTransferFrom(token, msg.sender, address(this), _amount);\r\n\r\n        } else {\r\n\r\n            _amount = msg.value;\r\n            require(_amount > 0, \"No Ether was included in the transaction.\");\r\n\r\n        }\r\n\r\n        uint256 newBal = balances[msg.sender][_token].add(_amount);\r\n        balances[msg.sender][_token] = newBal;\r\n\r\n        emit Deposit(msg.sender, _token, newBal);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit an IERC20 or Ether to the contract to fund it for subscriptions.\r\n     * @param _token The address of the token to be withdrawn (address(0) for Ether).\r\n     * @param _amount The amount of token to withdraw (msg.value is used for Ether).\r\n    **/\r\n    function withdraw(address _token, uint256 _amount)\r\n      external\r\n    {\r\n        require(_amount > 0, \"You must withdraw a non-zero amount.\");\r\n\r\n        // Will throw if there's an inadequate balance.\r\n        uint256 newBal = balances[msg.sender][_token].sub(_amount);\r\n        balances[msg.sender][_token] = newBal;\r\n\r\n        if (_token != address(0)) {\r\n\r\n            IERC20 token = IERC20(_token);\r\n            SafeERC20.safeTransfer(token, msg.sender, _amount);\r\n\r\n        } else {\r\n\r\n            msg.sender.transfer(_amount);\r\n\r\n        }\r\n\r\n        emit Withdrawal(msg.sender, _token, newBal);\r\n    }\r\n\r\n/** ************************************************* Subscriptions ******************************************************** **/\r\n\r\n    /**\r\n     * @dev User creates a subscription.\r\n     * @param _id The ID of the template to sign up for that was emitted on template creation.\r\n    **/\r\n    function subscribe(uint256 _id)\r\n      public\r\n      whenNotPaused\r\n    {\r\n        // Require subscription exists\r\n        require(_id != 0 && _id <= idCount, \"Subscription does not exist.\");\r\n\r\n        // Require user is not already subscribed.\r\n        require(subscriptions[msg.sender][_id].lastPaid == 0, \"User is already subscribed.\");\r\n\r\n        Template memory template = templates[_id];\r\n\r\n        // Target and interval types require some different information.\r\n        uint48 lastPaid;\r\n        uint48 nextDue;\r\n\r\n        if (template.target > 0) {\r\n\r\n            lastPaid = uint48(now);\r\n\r\n            // Pacific Standard Time\r\n            uint256 pstNow = BokkyDateTime.subHours(now, 8);\r\n\r\n            // Simply adding 1 month may not keep target accurate.\r\n            uint256 year = BokkyDateTime.getYear(pstNow);\r\n            uint256 month = BokkyDateTime.getMonth(pstNow);\r\n            uint256 day = BokkyDateTime.getDay(pstNow);\r\n\r\n            // If we're before the target in a month it's due, make nextDue this month's target, else next month's.\r\n            if (day < template.target) nextDue = uint48(BokkyDateTime.timestampFromDate(year, month, template.target));\r\n            else nextDue = uint48(BokkyDateTime.timestampFromDate(BokkyDateTime.getYear(BokkyDateTime.addMonths(pstNow, 1)), (month % 12) + 1, template.target));\r\n\r\n        } else {\r\n\r\n            lastPaid = uint48(now);\r\n            nextDue = uint48(now + template.interval);\r\n\r\n        }\r\n\r\n        subscriptions[msg.sender][_id] = Subscription(uint48(now), lastPaid, nextDue, template.payments, false);\r\n        emit Subscribed(msg.sender, _id, now, nextDue);\r\n\r\n        if (template.payNow) require(payment(msg.sender, _id), \"Payment failed.\");\r\n    }\r\n\r\n    /**\r\n     * @dev Unsubscribe from a service.\r\n     * @param _id ID of the template that the user is currently subscribed to.\r\n    **/\r\n    function unsubscribe(uint256 _id)\r\n      public\r\n    {\r\n        _unsubscribe(msg.sender, _id);\r\n    }\r\n\r\n    /**\r\n     * @dev Unsubscribe one of your users from a subscription. May only be used by template creator.\r\n     * @param _user The user to unsubscribe.\r\n     * @param _id The template to unsubscribe the user from.\r\n    **/\r\n    function unsubscribeUser(address _user, uint256 _id)\r\n      public\r\n    {\r\n        require(msg.sender == templates[_id].creator, \"Only the template creator may unsubscribe a user.\");\r\n        _unsubscribe(_user, _id);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal unsubscribe.\r\n     * @param _user The user to unsubscribe.\r\n     * @param _id The of the subscription.\r\n    **/\r\n    function _unsubscribe(address _user, uint256 _id)\r\n      internal\r\n    {\r\n        delete subscriptions[_user][_id];\r\n        emit Unsubscribed(_user, _id, now);\r\n    }\r\n\r\n    /**\r\n     * @dev If a user is depositing for a specific subscription, they can use this to do both at once.\r\n     * @param _token The address of the token to be deposited.\r\n     * @param _amount The amount of the token to be deposited.\r\n     * @param _id The ID of the template to subscribe to.\r\n    **/\r\n    function depositAndSubscribe(address _token, uint256 _amount, uint256 _id)\r\n      public\r\n      payable\r\n      whenNotPaused\r\n    {\r\n        deposit(_token, _amount);\r\n        subscribe(_id);\r\n    }\r\n\r\n/** ************************************************* Payments ******************************************************** **/\r\n\r\n    /**\r\n     * @dev Make a payment for a subscription, may be called by anyone.\r\n     * @param _user The user whose subscription is being paid.\r\n     * @param _id The ID of the subscription.\r\n     * @return Whether the payment was a success or not.\r\n    **/\r\n    function payment(address _user, uint256 _id)\r\n      public\r\n      whenNotPaused\r\n    returns (bool)\r\n    {\r\n        Subscription memory sub = subscriptions[_user][_id];\r\n        Template memory template = templates[_id];\r\n\r\n        // Convert Fiat price to a token value. Original token price is in USD wei, return is token wei.\r\n        if (template.payInFiat) template.price = tokenToFiat(template.token, template.price);\r\n\r\n        // Check subscription for whether it's due.\r\n        if (!checkDue(_user, _id, template, sub)) return false;\r\n\r\n        // Update the 4 balances being altered (user, recipient, monarch, payment daemon).\r\n        updateBals(_user, template);\r\n\r\n        // Set new due dates.\r\n        sub = updateDue(_user, _id, template, sub);\r\n\r\n        emit Paid(_user, _id, sub.nextDue, now, template.setLen, sub.paymentsLeft);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Accepts token and USD amount desired then finds token value equivalent.\r\n     * @param _token The address of the token to convert.\r\n     * @param _usdAmount The amount of USD the token amount must equal.\r\n     * @return How much Dai the given token and amount is worth.\r\n    **/\r\n    function tokenToFiat(address _token, uint256 _usdAmount)\r\n      public\r\n      view\r\n    returns (uint256 tokenAmount)\r\n    {\r\n        // Dai is our USD stand-in.\r\n        uint256 daiPerEth = tokenPrices[0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359];\r\n        uint256 tokenPerEth = tokenPrices[_token];\r\n\r\n        // (USD * buffer) / ((Eth USD price * buffer) / Eth token price).\r\n        tokenAmount = (_usdAmount.mul(1 ether)).div(((daiPerEth.mul(1 ether)).div((tokenPerEth))));\r\n\r\n        // Hacked approvedTokens into also saving the decimals of a token.\r\n        uint256 decimals = 10 ** approvedTokens[_token];\r\n        tokenAmount = tokenAmount.mul(decimals).div(1 ether);\r\n    }\r\n\r\n    /**\r\n     * @dev Check whether the payment is due and if it can be paid.\r\n     * @param _user The address of the user who is paying.\r\n     * @param _id The id of the subscription to update.\r\n     * @param _template Memory struct of the template information.\r\n     * @param _sub Memory struct of the user subscription information.\r\n     * @return Whether or not a payment is currently due.\r\n    **/\r\n    function checkDue(address _user, uint256 _id, Template memory _template, Subscription memory _sub)\r\n      internal\r\n    returns (bool due)\r\n    {\r\n        // We must check user balance and allowance beforehand so, in the case of bulk payments, one failed payment won't revert everything.\r\n        uint256 balance = balances[_user][_template.token];\r\n\r\n        // Fail if not enough balance.\r\n        if (balance < _template.price) {\r\n\r\n            emit Failed(_user, _id, now);\r\n            return false;\r\n\r\n        }\r\n\r\n        // Protection in case user is not subscribed.\r\n        if (_sub.lastPaid == 0) {\r\n\r\n            emit NotDue(_user, _id);\r\n            return false;\r\n\r\n        }\r\n\r\n        // If this is the first payment and payNow is true, let it through.\r\n        if (_template.payNow && !_sub.startPaid) return true;\r\n\r\n        // Check if interval payment is owed.\r\n        if (_sub.nextDue >= now) {\r\n\r\n            emit NotDue(_user, _id);\r\n            return false;\r\n\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update each relevant balance.\r\n     * @param _user The address of the user who is paying.\r\n     * @param _template Memory struct of the template information.\r\n    **/\r\n    function updateBals(address _user, Template memory _template)\r\n      internal\r\n    {\r\n        address token = _template.token;\r\n        uint256 price = _template.price;\r\n        uint256 monarchFee = price / adminFee;\r\n\r\n        uint256 gasPrice = tx.gasprice;\r\n        if (gasPrice > gasPriceCap) gasPrice = gasPriceCap;\r\n\r\n        // If a token is being paid, convert the Ether gas fee to equivalent token value.\r\n        uint256 gasFee;\r\n        if (token != address(0)) gasFee = (tokenPrices[token].mul(gasAmt).mul(gasPrice)).div(1 ether);\r\n        else gasFee = gasAmt.mul(gasPrice);\r\n\r\n        // User balance - price\r\n        uint256 userBal = balances[_user][token].sub(price);\r\n        balances[_user][token] = userBal;\r\n\r\n        // Recipient balance + (price - (gasFee + monarchFee))\r\n        uint256 recipBal = balances[_template.recipient][token].add(price.sub(gasFee.add(monarchFee)));\r\n        balances[_template.recipient][token] = recipBal;\r\n\r\n        // Pay daemon balance + gasFee\r\n        uint256 paydBal = balances[msg.sender][token].add(gasFee);\r\n        balances[msg.sender][token] = paydBal;\r\n\r\n        // Monarch balance + monarchFee\r\n        uint256 monarchBal = balances[monarch][token].add(monarchFee);\r\n        balances[monarch][token] = monarchBal;\r\n\r\n        emit NewBals([_user, _template.recipient, msg.sender, monarch], [userBal, recipBal, paydBal, monarchBal], token);\r\n    }\r\n\r\n    /**\r\n     * @dev Update due dates and payments left.\r\n     * @param _user The address of the user who is paying.\r\n     * @param _id The id of the subscription to update.\r\n     * @param _template Memory struct of the template information.\r\n     * @param _sub Memory struct of the user subscription information.\r\n     * @return The user's updated subscription struct.\r\n    **/\r\n    function updateDue(address _user, uint256 _id, Template memory _template, Subscription memory _sub)\r\n      internal\r\n    returns (Subscription memory)\r\n    {\r\n        // We don't want lastPaid and nextDue changed if it's a payNow payment.\r\n        bool payNow = _template.payNow && !_sub.startPaid;\r\n\r\n        // If this is called late, we don't want to use 'now' but rather give them 'interval' time from last payment.\r\n        if (!payNow && _template.interval > 0) {\r\n\r\n            _sub.lastPaid = _sub.nextDue;\r\n            _sub.nextDue = _sub.lastPaid + _template.interval;\r\n\r\n        } else if (!payNow) {\r\n\r\n            _sub.lastPaid = _sub.nextDue;\r\n            _sub.nextDue = uint48(BokkyDateTime.addMonths(_sub.lastPaid, 1));\r\n\r\n        }\r\n\r\n        // If there's a set length, alter paymentsLeft, unsubscribe if 0.\r\n        if (_template.setLen) _sub.paymentsLeft = _sub.paymentsLeft - 1;\r\n\r\n        // Set original payment to true.\r\n        if (payNow) _sub.startPaid = true;\r\n\r\n        if (_template.setLen && _sub.paymentsLeft == 0) _unsubscribe(_user, _id);\r\n        else subscriptions[_user][_id] = _sub;\r\n\r\n        return _sub;\r\n    }\r\n\r\n    /**\r\n     * @dev Used for bulk payments.\r\n     * @param _users Address of users to ping contracts for payments.\r\n     * @param _ids IDs of template to pay for the corresponding user.\r\n    **/\r\n    function bulkPayments(address[] calldata _users, uint256[] calldata _ids)\r\n      external\r\n      whenNotPaused\r\n    {\r\n        require(_users.length == _ids.length, \"The submitted arrays are of uneven length.\");\r\n\r\n        for (uint256 i = 0; i < _users.length; i++) {\r\n\r\n            payment(_users[i], _ids[i]);\r\n\r\n        }\r\n    }\r\n\r\n/** ************************************************* Creation ******************************************************** **/\r\n\r\n    /**\r\n     * @dev Used by a company to create a new subscription structure.\r\n     * @param _recipient The entity to be paid by the subscription.\r\n     * @param _token The token the subscription should be paid in.\r\n     * @param _price The amount of tokens to be paid (token wei).\r\n     * @param _interval How often the subscription should be paid.\r\n     * @param _target The target day of the month to be paid (if not interval).\r\n     * @param _setLen Whether or not there will be a fixed amount of payments.\r\n     * @param _payments The number of payments if fixed.\r\n     * @param _payNow True if the payment is to be made immediately.\r\n     * @param _payInFiat True if the price should be paid in Fiat (i.e. $10 USD of the token each interval).\r\n     * @return The ID of the newly created template.\r\n    **/\r\n    function createTemplate(address payable _recipient, address _token, uint256 _price, uint48 _interval,\r\n                            uint8 _target, bool _setLen, uint48 _payments, bool _payNow, bool _payInFiat)\r\n      public\r\n      whenNotPaused\r\n    returns (uint256 id)\r\n    {\r\n        // Make sure the template is EITHER interval or target. Interval should be more than a day to prevent payment spam.\r\n        require((_interval >= 86400 && _target == 0) || (_interval == 0 && _target > 0), \"You must choose >= 1 day interval or target.\");\r\n\r\n        // Prevent overflow with a max interval of 100 years.\r\n        require(_interval <= 3153600000, \"You may not have an interval of over 100 years.\");\r\n\r\n        // Target must be a valid day of the month.\r\n        if (_target > 0) require(_target <= 28, \"Target must be a valid day.\");\r\n\r\n        // Token must be on our approved list.\r\n        require(approvedTokens[_token] > 0, \"The desired token is not on the approved tokens list.\");\r\n\r\n        // Price must be above $1.\r\n        require(_price >= tokenToFiat(_token, 1 ether), \"Your subscription must have a price of at least $1.\");\r\n\r\n        // Must have a set amount of payments if it's a set length and vice versa.\r\n        if (_setLen) require(_payments > 0, \"A set-length template must have non-zero payments.\");\r\n        else require(_payments == 0, \"A non-set-length template must have zero payments.\");\r\n\r\n        Template memory template = Template(_price, _recipient, _interval, _target, _token, _setLen, _payments, msg.sender, _payNow, _payInFiat);\r\n\r\n        idCount++;\r\n        id = idCount;\r\n        templates[id] = template;\r\n\r\n        emit Creation(id, _recipient, _token, _price, _interval, _target, _setLen, _payments, msg.sender, _payNow, _payInFiat);\r\n    }\r\n\r\n    /**\r\n     * @dev Simpler way for an individual to make their own subscription and subscribe with only one function call.\r\n     *      Same params as createSubscription.\r\n    **/\r\n    function createAndSubscribe(address payable _recipient, address _token, uint256 _price, uint48 _interval,\r\n                                uint8 _target, bool _setLen, uint48 _payments, bool _payNow, bool _payInFiat)\r\n      external\r\n      whenNotPaused\r\n    {\r\n        uint256 id = createTemplate(_recipient, _token, _price, _interval, _target, _setLen, _payments, _payNow, _payInFiat);\r\n        subscribe(id);\r\n    }\r\n\r\n    /**\r\n     * @dev As above but with deposit added.\r\n     * @param _amount The amount of token wei to deposit.\r\n    **/\r\n    function createDepositAndSubscribe(address payable _recipient, address _token, uint256 _price, uint48 _interval, uint8 _target,\r\n                                       bool _setLen, uint48 _payments, bool _payNow, bool _payInFiat, uint256 _amount)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        uint256 id = createTemplate(_recipient, _token, _price, _interval, _target, _setLen, _payments, _payNow, _payInFiat);\r\n        deposit(_token, _amount);\r\n        subscribe(id);\r\n    }\r\n\r\n/** ************************************************* onlyOracle ******************************************************** **/\r\n\r\n    /**\r\n     * @dev For functions that only admins can call.\r\n    **/\r\n    modifier onlyOracle\r\n    {\r\n        require(msg.sender == subOracle, \"Only the oracle may call this function.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Used by the subscription oracle to set the current token prices (in Ether).\r\n     * @param _tokens Array of the token addresses.\r\n     * @param _prices Array of the prices for each address.\r\n    **/\r\n    function setPrices(address[] calldata _tokens, uint256[] calldata _prices)\r\n      external\r\n      onlyOracle\r\n    {\r\n        require(_tokens.length == _prices.length, \"Submitted arrays are of uneven length.\");\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n\r\n            require(approvedTokens[_tokens[i]] > 0, \"Price may only be set for approved tokens.\");\r\n            tokenPrices[_tokens[i]] = _prices[i];\r\n\r\n        }\r\n    }\r\n\r\n/** ************************************************* Privileged ******************************************************** **/\r\n\r\n    /**\r\n     * @dev Used in the case that something happens to the contract or the contract is being updated and all funds must be withdrawn.\r\n     * @param _users Array of users to withdraw for.\r\n     * @param _tokens Token to withdraw for the corresponding user.\r\n    **/\r\n    function bulkWithdraw(address payable[] calldata _users, address[] calldata _tokens)\r\n      external\r\n      onlyOwner\r\n    {\r\n        require(_users.length == _tokens.length, \"Submitted arrays are of uneven length.\");\r\n\r\n        for (uint256 i = 0; i < _users.length; i++) {\r\n\r\n            address payable user = _users[i];\r\n            address token = _tokens[i];\r\n\r\n            uint256 balance = balances[user][token];\r\n            if (balance == 0) continue;\r\n\r\n            balances[user][token] = 0;\r\n\r\n            if (token != address(0)) {\r\n\r\n                IERC20 tokenC = IERC20(token);\r\n                SafeERC20.safeTransfer(tokenC, user, balance);\r\n\r\n                // require(tokenC.transfer(user, balance), \"Token transfer failed.\");\r\n\r\n            } else {\r\n\r\n                // We don't want one user to cause a revert so we're allowing send to fail.\r\n                if (!user.send(balance)) {\r\n                    balances[user][token] = balance;\r\n                    continue;\r\n                }\r\n\r\n            }\r\n\r\n            emit Withdrawal(user, token, balance);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Used to change the Monarch address that will be given the admin fees.\r\n     * @param _monarch The new Monarch wallet address.\r\n    **/\r\n    function setMonarch(address _monarch)\r\n      public\r\n      onlyOwner\r\n    {\r\n        monarch = _monarch;\r\n    }\r\n\r\n    /**\r\n     * @dev Used by Monarch to approve (or disapprove) tokens that may be used for payment.\r\n     * @param _token The address of the token in question.\r\n     * @param _add Whether to add or remove the token.\r\n    **/\r\n    function approveToken(address _token, bool _add)\r\n      public\r\n      onlyPauser\r\n    {\r\n        if (_add) {\r\n\r\n            uint256 decimals;\r\n            //if (_token == address(0)) decimals = 18;\r\n            //else decimals = uint256(IERC20(_token).decimals());\r\n            decimals = 18;\r\n\r\n            approvedTokens[_token] = decimals;\r\n\r\n        } else {\r\n\r\n            delete approvedTokens[_token];\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Used by Monarch to change the current gas fee.\r\n     * @param _gasAmt The amount of gas that the payment function will cost to execute.\r\n     * @param _gasPriceCap The maximum gwei cost that may be used to pay for sending payments.\r\n    **/\r\n    function setGasFees(uint256 _gasAmt, uint256 _gasPriceCap)\r\n      public\r\n      onlyPauser\r\n    {\r\n        // Generally this is a constant number but we may want it lowered in some cases.\r\n        require(_gasAmt <= 85000, \"Desired gas amount is too high.\");\r\n\r\n        // Limit gas price to 40 gwei to dissuade malicious admins.\r\n        require(_gasPriceCap <= 40000000000, \"Desired gas price is too high.\");\r\n\r\n        gasAmt = _gasAmt;\r\n        gasPriceCap = _gasPriceCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Used by Monarch to change the current gas fee.\r\n     * @param _adminFee is a number to divide price by: i.e. adminFee of 100 is 1%\r\n    **/\r\n    function setAdminFee(uint256 _adminFee)\r\n      public\r\n      onlyPauser\r\n    {\r\n        // Limit fee to 10% to dissuade malicious admins.\r\n        require(_adminFee >= 10, \"Desired fee is too large.\");\r\n        adminFee = _adminFee;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"gasAmt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_add\",\"type\":\"bool\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint48\"},{\"name\":\"_target\",\"type\":\"uint8\"},{\"name\":\"_setLen\",\"type\":\"bool\"},{\"name\":\"_payments\",\"type\":\"uint48\"},{\"name\":\"_payNow\",\"type\":\"bool\"},{\"name\":\"_payInFiat\",\"type\":\"bool\"}],\"name\":\"createAndSubscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint48\"},{\"name\":\"_target\",\"type\":\"uint8\"},{\"name\":\"_setLen\",\"type\":\"bool\"},{\"name\":\"_payments\",\"type\":\"uint48\"},{\"name\":\"_payNow\",\"type\":\"bool\"},{\"name\":\"_payInFiat\",\"type\":\"bool\"}],\"name\":\"createTemplate\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"bulkPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_usdAmount\",\"type\":\"uint256\"}],\"name\":\"tokenToFiat\",\"outputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subscriptions\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint48\"},{\"name\":\"lastPaid\",\"type\":\"uint48\"},{\"name\":\"nextDue\",\"type\":\"uint48\"},{\"name\":\"paymentsLeft\",\"type\":\"uint48\"},{\"name\":\"startPaid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"unsubscribeUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint48\"},{\"name\":\"_target\",\"type\":\"uint8\"},{\"name\":\"_setLen\",\"type\":\"bool\"},{\"name\":\"_payments\",\"type\":\"uint48\"},{\"name\":\"_payNow\",\"type\":\"bool\"},{\"name\":\"_payInFiat\",\"type\":\"bool\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createDepositAndSubscribe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_monarch\",\"type\":\"address\"}],\"name\":\"setMonarch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminFee\",\"type\":\"uint256\"}],\"name\":\"setAdminFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monarch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"bulkWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasAmt\",\"type\":\"uint256\"},{\"name\":\"_gasPriceCap\",\"type\":\"uint256\"}],\"name\":\"setGasFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"unsubscribe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templates\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"interval\",\"type\":\"uint48\"},{\"name\":\"target\",\"type\":\"uint8\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"setLen\",\"type\":\"bool\"},{\"name\":\"payments\",\"type\":\"uint48\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"payNow\",\"type\":\"bool\"},{\"name\":\"payInFiat\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"depositAndSubscribe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPriceCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_subOracle\",\"type\":\"address\"},{\"name\":\"_monarch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interval\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"setLen\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"payments\",\"type\":\"uint48\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payNow\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"payInFiat\",\"type\":\"bool\"}],\"name\":\"Creation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"users\",\"type\":\"address[4]\"},{\"indexed\":false,\"name\":\"balances\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"NewBals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NotDue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextDue\",\"type\":\"uint48\"},{\"indexed\":false,\"name\":\"datetime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"setLen\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"paymentsLeft\",\"type\":\"uint48\"}],\"name\":\"Paid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"datetime\",\"type\":\"uint256\"}],\"name\":\"Failed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"datetime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextDue\",\"type\":\"uint48\"}],\"name\":\"Subscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"datetime\",\"type\":\"uint256\"}],\"name\":\"Unsubscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PostAuditSubscriptions","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000711169ff510be33e76db9bd8afd685bcaa74f78f0000000000000000000000004e70812b550687692e18f53445c601458228affd","Library":"","SwarmSource":"bzzr://337a49ce932274ef886203f915b1e491a10628dab744105b1888a0f6db6af8ac"}]}