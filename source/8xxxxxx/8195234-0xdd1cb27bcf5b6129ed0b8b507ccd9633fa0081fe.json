{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.1;\n\n/**\n *Submitted for verification at Etherscan.io on 2019-07-21\n*/\n\n\n\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a,m);\n        uint256 d = sub(c,1);\n        return mul(div(d,m),m);\n    }\n\n}\n\ninterface Token {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract StandardToken is Token {\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string memory name, string memory symbol, uint8 decimals) public {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n  }\n\n  function name() public view returns(string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns(string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view returns(uint8) {\n    return _decimals;\n  }\n\n}\n\ncontract ForeignToken {\n    function balanceOf(address _owner) pure public returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool);\n}\n\ncontract SultanChain is StandardToken {\n    \n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) private allowed;\n    mapping (address => bool) public Claimed; \n\n    mapping (address => uint256) allocations;    \n    \n    // mapping\n    mapping(address => bool) public frozenAccount;\n    \n    bool private unFreeze;\n\n    // list of receiver accounts\n    address[] public receivers;\n\n    // events\n    event FundsFrozen(address target, bool frozen);\n    event AccountFrozenError();\n    event Refund(address target, uint256 amount);\n\n    uint256 public basePercent = 100;\n\n    string constant tokenName = \"Sultan Chain\";\n    string constant tokenSymbol = \"STN\";\n    uint8  constant tokenDecimals = 18;\n\n    uint public deadline = now + 60 * 1 days;\n    uint public round2 = now + 60 * 1 days;\n    uint public round1 = now + 60 * 1 days;\n    \n    uint256 public totalSupply = 7000000e18;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 1 ether / 1000; // 0.01 Ether\n    uint256 public tokensPerEth = 1000e18;\n\n    uint public targetAirdrop = 100000;\n    uint public progressAirdrop = 0;\n    uint256 public unlockDate;\n\n    uint256 constant AirSelfDropDonation = 3000000e18;\n    uint256 constant marketingPromotion = 500000e18;     \n    uint256 constant adminSalary = 500000e18;     \n    uint256 constant stakingRewards = 1000000e18;     \n    uint256 constant devMaintenance = 1000000e18;     \n    uint256 constant lockDeposit = 1000000e18;     \n\n    address wallet_marketingPromotion = 0x431e5f0C520Ad95CcD7C1063fAa088732BA059F6;     \n    address wallet_adminSalary = 0x28c35c792B78E46D7d12Cae17d4A4D1A30c36Ff1;     \n    address wallet_stakingRewards = 0x91dc5b87a10cdCD37f707dFC13918DA991d7a37b;     \n    address wallet_devMaintenance = 0xeA110053959380Df3a91b97c57d54c976A210B3b;     \n    address wallet_lockDeposit = 0xc1AE350AE6ffE65cE10756184fA1cdEd701de1ba;     \n\n    address payable ethFundDeposit = 0x7b88D2A62682749919e1e0401200139624cc5A82;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n    \n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n\n    event TokensPerEthUpdated(uint _tokensPerEth);\n    \n    event Burn(address indexed burner, uint256 value);\n    \n    event Add(uint256 value);\n\n    bool public distributionFinished = false;\n    \n    modifier canDistr() {\n        require(!distributionFinished);\n        _;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    constructor() public payable StandardToken(tokenName, tokenSymbol, tokenDecimals) {\n        unFreeze = true;\n        owner = msg.sender;\n        unlockDate = now + 12 * 30 days;\n        distr(owner, devMaintenance);\n        distr(wallet_marketingPromotion, marketingPromotion);\n        distr(wallet_adminSalary, adminSalary);\n        distr(wallet_stakingRewards, stakingRewards);\n        distr(wallet_lockDeposit, lockDeposit);\n    }\n    \n    function transferOwnership(address newOwner) onlyOwner public {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n        distributionFinished = true;\n        emit DistrFinished();\n        return true;\n    }\n    \n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n        totalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n    \n    function Distribute(address _participant, uint _amount) onlyOwner internal {\n\n        require( _amount > 0 );      \n        require( totalDistributed < totalSupply );\n        balances[_participant] = balances[_participant].add(_amount);\n        totalDistributed = totalDistributed.add(_amount);\n\n        if (totalDistributed >= totalSupply) {\n            distributionFinished = true;\n        }\n\n        // log\n        emit Airdrop(_participant, _amount, balances[_participant]);\n        emit Transfer(address(0), _participant, _amount);\n    }\n    \n    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        \n        Distribute(_participant, _amount);\n    }\n\n    function DistributeAirdropMultiple(address[] calldata _addresses, uint _amount) onlyOwner external {        \n        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);\n    }\n\n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n        tokensPerEth = _tokensPerEth;\n        emit TokensPerEthUpdated(_tokensPerEth);\n    }\n           \n    function () external payable {\n        getTokens();\n     }\n\n    function getTokens() payable canDistr  public {\n        uint256 tokens = 0;\n        uint256 bonus = 0;\n        uint256 countbonus = 0;\n        uint256 bonusCond1 = 1 ether / 10;\n        uint256 bonusCond2 = 5 ether / 10;\n        uint256 bonusCond3 = 1 ether;\n\n        tokens = tokensPerEth.mul(msg.value) / 1 ether;        \n        address investor = msg.sender;\n\n        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {\n            if(msg.value >= bonusCond1 && msg.value < bonusCond2){\n                countbonus = tokens * 10 / 100;\n            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){\n                countbonus = tokens * 20 / 100;\n            }else if(msg.value >= bonusCond3){\n                countbonus = tokens * 35 / 100;\n            }\n        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){\n            if(msg.value >= bonusCond2 && msg.value < bonusCond3){\n                countbonus = tokens * 2 / 100;\n            }else if(msg.value >= bonusCond3){\n                countbonus = tokens * 3 / 100;\n            }\n        }else{\n            countbonus = 0;\n        }\n\n        bonus = tokens + countbonus;\n        \n        if (tokens == 0) {\n            uint256 valdrop = 5e18;\n            if (Claimed[investor] == false && progressAirdrop <= targetAirdrop ) {\n                distr(investor, valdrop);\n                Claimed[investor] = true;\n                progressAirdrop++;\n            }else{\n                require( msg.value >= requestMinimum );\n            }\n        }else if(tokens > 0 && msg.value >= requestMinimum){\n            if( now >= deadline && now >= round1 && now < round2){\n                distr(investor, tokens);\n            }else{\n                if(msg.value >= bonusCond1){\n                    distr(investor, bonus);\n                }else{\n                    distr(investor, tokens);\n                }   \n            }\n        }else{\n            require( msg.value >= requestMinimum );\n        }\n\n        if (totalDistributed >= totalSupply) {\n            distributionFinished = true;\n        }\n        \n        ethFundDeposit.transfer(msg.value);\n    }\n    \n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n    \n\n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n        require(_amount <= balances[msg.sender]);\n        require(_to != address(0));\n\n        // source account should not be frozen\n        if (frozenAccount[msg.sender] && !unFreeze) {\n            emit AccountFrozenError();\n            return false;\n        }\n\n        // record the receiver address into list\n        receivers.push(_to);\n\n        uint256 tokensToBurn = findOnePercent(_amount);\n        uint256 tokensToTransfer = _amount.sub(tokensToBurn);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(tokensToTransfer);\n\n        totalSupply = totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, _to, tokensToTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n    }\n    \n    function transferFrom(address from, address to, uint256 value) onlyPayloadSize(3 * 32) public returns (bool) { \n        require(value <= balances[from]);\n        require(value <= allowed[from][msg.sender]);\n        require(to != address(0));\n\n        // source account should not be frozen\n        if (frozenAccount[from] && !unFreeze) {\n            emit AccountFrozenError();\n            return false;\n        }\n\n        // record the receiver address into list\n        receivers.push(to);\n\n        balances[from] = balances[from].sub(value);\n        uint256 tokensToBurn = findOnePercent(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n        balances[to] = balances[to].add(tokensToTransfer);\n        totalSupply = totalSupply.sub(tokensToBurn);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, tokensToTransfer);\n        emit Transfer(from, address(0), tokensToBurn);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) view public returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    \n    function getTokenBalance(address tokenAddress, address who) pure public returns (uint){\n        ForeignToken t = ForeignToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }\n    \n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= balances[account]);\n        totalSupply = totalSupply.sub(amount);\n        balances[account] = balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external {\n        require(amount <= allowed[account][msg.sender]);\n        allowed[account][msg.sender] = allowed[account][msg.sender].sub(amount);\n        _burn(account, amount);\n    }\n    \n    function findOnePercent(uint256 value) public view returns (uint256)  {\n        uint256 onePercent = value.mul(basePercent).div(10000);   \n        return onePercent;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        allowed[msg.sender][spender] = (allowed[msg.sender][spender].sub(subtractedValue));\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Refund - transfer tokens back to the owner\n    * Requires the refund account to approve the owner to withdraw the amount\n    * @param _to address Refund account address\n    * @param _value uint256 the amount of tokens to be transferred\n    */\n    function refund(address _to, uint256 _value) public payable onlyOwner returns (bool) {\n        // transfer funds from refund account to owner\n        require(transferFrom(_to, owner, _value), \"Transfer failed.\");\n        emit Refund(_to, _value);\n        return true;\n    }\n\n    // returns full list of receiver addresses\n    function getAccountList() public view returns (address[] memory) {\n        address[] memory v = new address[](receivers.length);\n        for (uint256 i = 0; i < receivers.length; i++) {\n            v[i] = receivers[i];\n        }\n        return v;\n    }\n\n    // freeze accounts\n    function changeFreezeStatus(address target, bool freeze) public onlyOwner {\n        frozenAccount[target] = freeze;\n        emit FundsFrozen(target, freeze);\n    }\n\n    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n\n    /*\n    function unlock() onlyOwner external {\n        if(now < unlockDate) throw;\n        uint256 entitled = allocations[owner];\n        allocations[owner] = 0;\n        if(!distr(owner, allocations[wallet_lockDeposit])) throw;\n    }\n    */\n\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DistributeAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"changeFreezeStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerEth\",\"type\":\"uint256\"}],\"name\":\"updateTokensPerEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"findOnePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"receivers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"progressAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DistributeAirdropMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FundsFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AccountFrozenError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Distr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DistrFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokensPerEth\",\"type\":\"uint256\"}],\"name\":\"TokensPerEthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Add\",\"type\":\"event\"}]","ContractName":"SultanChain","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://196f40e3e067800d8dcd6a5d3f53f9ee892242f6f212368f023fdb52913fb475"}]}