{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface PrimaryStorage {\r\n    function getDisputeProjectId(uint256 disputeId) external view returns (uint256);\r\n    function getIsRefundInProgress(uint256 pid) external view returns(bool);\r\n    function getAmountAvailableForWithdraw(address userAddr, uint256 pid) external view returns (uint256);\r\n    function setAmountAvailableForWithdraw(address userAddr, uint256 pid, uint256 amount) external;\r\n    function getResultCountPeriod(uint256 did) external view returns (uint256);\r\n    function setPayment(address participant, uint256 disputeId, uint256 paymentAmount) external;\r\n    function getPayment(address payee, uint256 disputeId) external view returns (uint256);\r\n    function isCanceled(uint256 insId) external view returns (bool);\r\n    function getPoolContribution(uint256 insId) external view returns (uint256);\r\n    function setPoolContribution(uint256 insId, uint256 amount) external;\r\n    function setEtherSecured(uint256 insId, uint256 amount) external;\r\n    function getInsuranceOwner(uint256 insId) external view returns (address);\r\n    function getModerationResources() external view returns (address payable);\r\n    function cancelInsurance(uint256 insId) external;\r\n    function getRefundPool() external view returns (address payable);\r\n    function getDisputeCreator(uint256 disputeId) external view returns (address payable);\r\n    function getDisputeControllerOfProject(uint256 disputeId) external view returns (address);\r\n    function getRevealedVote(uint256 disputeId, address voter) external view returns (bool);\r\n    function getVotedForARefund(uint256 insId) external view returns (bool);\r\n    function getVotedAfterFailedVoting(uint256 insId) external view returns (bool);\r\n    function getProjectOfInvestment(uint256 insId) external view returns (uint256 projectId);\r\n    function isVoteRevealed(uint256 disputeId, address voter) external view returns (bool);\r\n}\r\n\r\n\r\ninterface SecondaryStorage {\r\n    function getProjectCurrentState(uint256 pid) external view returns (uint8);\r\n    function getFreezeStatePeriod(uint256 pid) external view returns (uint256);\r\n    function getPolicyBase(uint256 pid) external view returns (uint256);\r\n    function getOwnerFunds(uint256 pid, address ownerAddr) external view returns (uint256);\r\n    function getPolicyEndDate(uint256 pid) external view returns (uint256);\r\n    function setProjectCurrentState(uint256 pid, uint8 currentState) external;\r\n    function setOwnerFunds(uint256 pid, address ownerAddr, uint256 amount) external;\r\n    function setOwnerContribution(uint256 pid, uint256 amount) external;\r\n    function getOwnerContribution(uint256 pid) external view returns (uint256);\r\n    function getOwnerBaseFundsRepaid(uint256 pid, address owner) external view returns (bool);\r\n    function setOwnerBaseFundsRepaid(uint256 pid, address owner) external;\r\n    function getIsRefundInProgress(uint256 pid) external view returns(bool);\r\n    function getRefundControllerOfProject(uint256 pid) external view returns (address payable);\r\n    function getNumberOfCoveredProjects() external view returns (uint256);\r\n    function getInvalidInsurances(uint256 pid) external view returns (uint256[8] memory invalidInsurances);\r\n    function getIncorrectlyVoted(uint256 pid) external view returns (uint256[8] memory invalidInsurances);\r\n    function getVotesForRefundState(uint256 pid) external view returns (uint256);\r\n    function getIsDisputed(uint256 pid) external view returns (bool);\r\n    function getCrowdsaleEndTime(uint256 pid) external view returns (uint256);\r\n    function getTotalAmountSecuredEther(uint256 pid) external view returns (uint256);\r\n    function getNumberOfProjectInvestments(uint256 pid) external view returns (uint256);\r\n    function getInvestmentToProject(uint256 pid, uint256 insuranceNumber) external view returns (uint256 investmentId);\r\n    function setAmountOfFundsContributed(uint256 pid, uint256 amount) external;\r\n    function setTotalAmountSecuredEther(uint256 pid, uint256 amount) external;\r\n    function getReturnedRefundTokens(uint256 pid) external view returns (uint256);\r\n    function getVoteEnd(uint256 pid) external view returns (uint256);\r\n    function getIsInvestorsVoteFailed(uint256 pid) external view returns (bool);\r\n    function setFreezeStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n    function getAmountOfFundsContributed(uint256 pid) external view returns (uint256);\r\n    function getBasePolicyExpired(uint256 pid) external view returns (bool);\r\n    function setBasePolicyExpired(uint256 pid) external;\r\n    function getOverallSecuredFunds() external view returns (uint256);\r\n    function getActiveProjects() external view returns (uint256);\r\n    function getTokenLitter(uint256 pid, uint256 ins) external view returns (address);\r\n    function getProjectTokenAddress(uint256 pid) external view returns (address);\r\n    function getMinAmountProjectTokens(uint256 pid, address investor) external view returns (uint256);\r\n    function removeInsuranceIdFromProject(uint256 pid, uint256 ins, uint256 idx) external;\r\n    function removeInvestorAddressFromProject(uint256 pid, address investorAddress, uint256 idx) external;\r\n    function getNumberOfInvestmentToProject(uint256 pid, uint256 insId) external view returns (uint256);\r\n    function getNumberOfInvestor(uint256 pid, address investorAddress) external view returns(uint256);\r\n    function getRefundStatePeriod(uint256 pid) external view returns (uint256);\r\n    function setIsRefundInProgress(uint256 pid, bool status) external;\r\n    function getUtilityControllerOfProject(uint256 pid) external view returns (address payable);\r\n}\r\n\r\n\r\ninterface RefundPool {\r\n    function deposit(uint256 pid) external payable;\r\n    function insuranceDeposit(uint256 pid) external payable;\r\n    function getProjectFunds (uint256 pid) external view returns (uint256);\r\n    function withdraw(uint256 pid, address payable to, uint256 amount) external;\r\n    function withdrawInsuranceFee(uint256 pid, address payable to, uint256 amount) external;\r\n    function cleanIfNoProjects() external;\r\n}\r\n\r\n\r\ninterface ProjectToken {\r\n    function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface Logger {\r\n    function emitOwnerBaseFundsRepaid(address owner, uint256 projectId, uint256 amount) external;\r\n    function emitOwnerFundsRepaid(address owner, uint256 projectId, uint256 amount) external;\r\n    function emitDisputePayment(address payable participant, uint256 disputeId, uint256 amount) external;\r\n    function emitPoolFeeRepaid(address owner, uint256 projectId, uint256 amount) external;\r\n}\r\n\r\n\r\ninterface RefundController {\r\n    function invalidateInsurance(uint256 ins, uint256 pid) external;\r\n    function finalizeVote(uint256 pid) external;\r\n}\r\n\r\n\r\ninterface UtilityController {\r\n    function projectStateMaintenance(uint256 pid) external;\r\n    function projectVoteMaintenance(uint256 pid) external;\r\n}\r\n\r\n\r\ncontract RefundableTokenOfferingUtility {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint64;\r\n\r\n    PrimaryStorage   masterStorage;\r\n    SecondaryStorage secondStorage;\r\n    RefundPool       refundPool;\r\n    Logger           eventLogger;\r\n\r\n    address private main;\r\n\r\n    constructor(\r\n        address dAppMainContractAddr,\r\n        address storageAddr,\r\n        address secStorageAddr,\r\n        address eventLoggerAddr,\r\n        address payable refundPoolAddr\r\n    )\r\n        public\r\n    {\r\n        masterStorage = PrimaryStorage(storageAddr);\r\n        secondStorage = SecondaryStorage(secStorageAddr);\r\n        refundPool = RefundPool(refundPoolAddr);\r\n        eventLogger = Logger(eventLoggerAddr);\r\n        main = dAppMainContractAddr;\r\n    }\r\n\r\n    modifier onlyMain {\r\n        if(msg.sender == main) {\r\n            _;\r\n        }\r\n        else {\r\n            revert(\"Only main ICO-Refund.com contract is allowed\");\r\n        }\r\n    }\r\n    function withdrawInsuranceFee(uint256 pid, address payable owner, uint256 insuranceId) external onlyMain {\r\n        uint256 amount = masterStorage.getAmountAvailableForWithdraw(owner, pid);\r\n        require(masterStorage.isCanceled(insuranceId) == true, \"Insurance was canceled\");\r\n        require(amount > 0, \"No funds available\");\r\n        refundPool.withdrawInsuranceFee(pid, owner, amount);\r\n    }\r\n\r\n    function withdraw(uint256 pid, address payable owner, uint256 insuranceId) external onlyMain {\r\n        uint256 amount = masterStorage.getAmountAvailableForWithdraw(owner, pid);\r\n        require(!masterStorage.isCanceled(insuranceId), \"Insurance was canceled\");\r\n        require(amount > 0, \"No refund amount available for withdrawal\");\r\n        refundPool.withdraw(pid, owner, amount);\r\n    }\r\n\r\n    function ownerWithdraw(address payable owner, address payable sendTo, uint256 pid)\r\n        external\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        uint8 currentProjectState = secondStorage.getProjectCurrentState(pid);\r\n        require(currentProjectState == 1 || currentProjectState == 5 || currentProjectState == 6, \"Not allowed\");\r\n        require(!secondStorage.getIsRefundInProgress(pid), \"Refund in progress, not allowed\");\r\n        require(block.number > secondStorage.getFreezeStatePeriod(pid), \"Project is in freeze state now\");\r\n        require(block.number > secondStorage.getPolicyBase(pid), \"Base policy not expired\");\r\n\r\n        uint256 amount = secondStorage.getOwnerFunds(pid, owner);\r\n        address payable payee;\r\n\r\n        if (sendTo != address(0)) {\r\n            payee = sendTo;\r\n        } else {\r\n            payee = owner;\r\n        }\r\n\r\n        if (block.number > secondStorage.getPolicyEndDate(pid)) {\r\n            if (secondStorage.getProjectCurrentState(pid) != 6) {\r\n                secondStorage.setProjectCurrentState(pid, 6);\r\n            }\r\n            require(amount > 0, \"You have no owner funds for a withdraw\");\r\n            secondStorage.setOwnerFunds(pid, owner, 0);\r\n            secondStorage.setOwnerContribution(\r\n                pid,\r\n                secondStorage.getOwnerContribution(pid).sub(amount)\r\n            );\r\n            refundPool.withdraw(pid, payee, amount);\r\n\r\n            eventLogger.emitOwnerFundsRepaid(owner, pid, amount);\r\n            return true;\r\n        } else {\r\n            require(!secondStorage.getOwnerBaseFundsRepaid(pid, owner), \"Already repaid\");\r\n            amount = amount.div(2);\r\n            secondStorage.setOwnerBaseFundsRepaid(pid, owner);\r\n            secondStorage.setOwnerFunds(pid, owner, amount);\r\n            secondStorage.setOwnerContribution(\r\n                pid,\r\n                secondStorage.getOwnerContribution(pid).sub(amount)\r\n            );\r\n            refundPool.withdraw(pid, payee, amount);\r\n\r\n            eventLogger.emitOwnerBaseFundsRepaid(owner, pid, amount);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function withdrawDisputePayment(address payable payee, uint256 did)\r\n        external\r\n        onlyMain\r\n    {\r\n        require(block.number > masterStorage.getResultCountPeriod(did), \"Not allowed\");\r\n        uint256 pid = masterStorage.getDisputeProjectId(did);\r\n\r\n        if (payee == masterStorage.getDisputeCreator(did)) {\r\n            require(secondStorage.getIsRefundInProgress(pid), \"The project was not settled as failed\");\r\n        } else {\r\n            bool isVoteRevealed = masterStorage.isVoteRevealed(did, payee);\r\n            if (secondStorage.getIsRefundInProgress(pid)) {\r\n                require(isVoteRevealed && masterStorage.getRevealedVote(did, payee), \"Not allowed, vote do not match the general consensus\");\r\n            } else {\r\n                require(isVoteRevealed && !masterStorage.getRevealedVote(did, payee), \"Not allowed, vote do not match the general consensus\");\r\n            }\r\n        }\r\n        uint256 amount = masterStorage.getPayment(payee, did);\r\n        require(amount > 0, \"No funds to withdraw\");\r\n        masterStorage.setPayment(payee, did, 0);\r\n        refundPool.withdraw(pid, payee, amount);\r\n        eventLogger.emitDisputePayment(payee, did, amount);\r\n    }\r\n\r\n    function verifyEligibility(uint256 projectId)\r\n        external\r\n        view\r\n        returns (uint256[8] memory invalidInsuranceId)\r\n    {\r\n        uint8 pjs = secondStorage.getProjectCurrentState(projectId);\r\n        uint256 vfr = secondStorage.getReturnedRefundTokens(projectId);\r\n        if ((pjs == 1 || pjs == 2) && (!secondStorage.getIsRefundInProgress(projectId) && vfr > 1)) {\r\n            invalidInsuranceId = secondStorage.getInvalidInsurances(projectId);\r\n            if (invalidInsuranceId[0] != 0) {\r\n                return invalidInsuranceId;\r\n            }\r\n        }\r\n        return invalidInsuranceId;\r\n    }\r\n\r\n    function getBadVoters(uint256 pid) external view returns(uint[8] memory invalidInsuranceId) {\r\n        uint256 voteEnd = secondStorage.getVoteEnd(pid);\r\n        uint256 freezeTime = secondStorage.getFreezeStatePeriod(pid);\r\n        uint8 pjs = secondStorage.getProjectCurrentState(pid);\r\n        bool isRefundInProgress = secondStorage.getIsRefundInProgress(pid);\r\n\r\n        require (pjs == 1 && !isRefundInProgress, \"Not allowed\");\r\n        if (freezeTime == 1 && voteEnd > 1 && block.number > voteEnd) {\r\n            invalidInsuranceId = secondStorage.getIncorrectlyVoted(pid);\r\n            if (invalidInsuranceId[0] != 0) {\r\n                return invalidInsuranceId;\r\n            }\r\n        }\r\n    }\r\n\r\n    function cancelInvalid(uint256 pid, uint256[8] calldata invalidInsuranceId)\r\n        external\r\n        onlyMain\r\n    {\r\n        uint256 i;\r\n        uint8 pjs = secondStorage.getProjectCurrentState(pid);\r\n        uint256 voteEnd = secondStorage.getVoteEnd(pid);\r\n        uint256 freezeTime = secondStorage.getFreezeStatePeriod(pid);\r\n        uint256 vfr = secondStorage.getReturnedRefundTokens(pid);\r\n        require(\r\n            (pjs == 1 || pjs == 2) && (!secondStorage.getIsRefundInProgress(pid) && vfr > 1),\r\n            \"The project is not eligible for verification of insurance validity\"\r\n        );\r\n        RefundController refundController = RefundController(secondStorage.getRefundControllerOfProject(pid));\r\n        address owner;\r\n        address tokenLitter;\r\n        address tokenAddress = secondStorage.getProjectTokenAddress(pid);\r\n        uint256 minAmountProjectTokens;\r\n        ProjectToken tokenContract = ProjectToken(tokenAddress);\r\n\r\n        while (i < invalidInsuranceId.length && invalidInsuranceId[i] != 0) {\r\n            owner = masterStorage.getInsuranceOwner(invalidInsuranceId[i]);\r\n            tokenLitter = secondStorage.getTokenLitter(pid, invalidInsuranceId[i]);\r\n            minAmountProjectTokens = secondStorage.getMinAmountProjectTokens(pid, owner);\r\n            require(\r\n                (freezeTime == 1 && voteEnd > 1 && block.number > voteEnd &&\r\n                !secondStorage.getIsInvestorsVoteFailed(pid) &&\r\n                masterStorage.getVotedForARefund(invalidInsuranceId[i])) ||\r\n\r\n                (freezeTime == 1 && voteEnd > 1 && block.number > voteEnd &&\r\n                secondStorage.getIsInvestorsVoteFailed(pid) &&\r\n                masterStorage.getVotedAfterFailedVoting(invalidInsuranceId[i])) ||\r\n\r\n                (tokenContract.balanceOf(owner) < minAmountProjectTokens &&\r\n                tokenContract.balanceOf(tokenLitter) < minAmountProjectTokens),\r\n                \"Canceling insurance is not allowed\"\r\n            );\r\n            refundController.invalidateInsurance(invalidInsuranceId[i], pid);\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function removeCanceled(\r\n        uint256 pid,\r\n        uint256[8] calldata invalidInsuranceId\r\n    )\r\n        external\r\n        onlyMain\r\n    {\r\n        for (uint256 i = 0; invalidInsuranceId.length > i; i++) {\r\n            if (invalidInsuranceId[i] != 0) {\r\n                require(masterStorage.isCanceled(invalidInsuranceId[i]), \"Insurance is not canceled\");\r\n                secondStorage.removeInsuranceIdFromProject(pid, invalidInsuranceId[i], 0);\r\n                address insuranceOwner = masterStorage.getInsuranceOwner(invalidInsuranceId[i]);\r\n                secondStorage.removeInvestorAddressFromProject(pid, insuranceOwner, 0);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function voteMaintenance(uint256 startFrom, uint256 endBefore) external onlyMain {\r\n        uint256 ncp = endBefore;\r\n        address utilityControllerAddress;\r\n        if (ncp == 0) ncp = secondStorage.getNumberOfCoveredProjects();\r\n\r\n        for (uint256 i = startFrom; ncp > i; i++) {\r\n            utilityControllerAddress = secondStorage.getUtilityControllerOfProject(i);\r\n            if (utilityControllerAddress != address(this)) {\r\n                UtilityController utilityController = UtilityController(utilityControllerAddress);\r\n                utilityController.projectVoteMaintenance(i);\r\n            } else {\r\n                projectVoteMaintenance(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function projectVoteMaintenance(uint256 pid) public {\r\n        uint8 pjs;\r\n        uint256 pve;\r\n        pjs = secondStorage.getProjectCurrentState(pid);\r\n        pve = secondStorage.getVoteEnd(pid);\r\n        if (pjs == 2 && block.number > pve) {\r\n            RefundController refundController = RefundController(secondStorage.getRefundControllerOfProject(pid));\r\n            refundController.finalizeVote(pid);\r\n        }\r\n\r\n        if (secondStorage.getIsInvestorsVoteFailed(pid)   &&\r\n            !secondStorage.getIsRefundInProgress(pid)     &&\r\n            pjs == 1 && !secondStorage.getIsDisputed(pid) &&\r\n            secondStorage.getFreezeStatePeriod(pid) > 1   &&\r\n            block.number > secondStorage.getFreezeStatePeriod(pid))\r\n        {\r\n            secondStorage.setFreezeStatePeriod(pid, 1);\r\n        }\r\n    }\r\n\r\n    function managePolicies(uint256 startFrom, uint256 numberOfProjects) external onlyMain {\r\n        uint256 ncp = numberOfProjects;\r\n        address utilityControllerAddress;\r\n        if (ncp == 0) ncp = secondStorage.getNumberOfCoveredProjects();\r\n\r\n        for (uint i = startFrom; ncp > i; i++) {\r\n            utilityControllerAddress = secondStorage.getUtilityControllerOfProject(i);\r\n            if (utilityControllerAddress != address(this)) {\r\n                UtilityController utilityController = UtilityController(utilityControllerAddress);\r\n                utilityController.projectStateMaintenance(i);\r\n            } else {\r\n                projectStateMaintenance(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function projectStateMaintenance(uint256 pid) public {\r\n        uint8 pjs;\r\n        uint256 tfc;\r\n        bool refundInProgress;\r\n        bool isBasePolicyExpired;\r\n        pjs = secondStorage.getProjectCurrentState(pid);\r\n        tfc = secondStorage.getAmountOfFundsContributed(pid);\r\n        refundInProgress = secondStorage.getIsRefundInProgress(pid);\r\n        address payable modRsrc = masterStorage.getModerationResources();\r\n        isBasePolicyExpired = secondStorage.getBasePolicyExpired(pid);\r\n\r\n        pjs = secondStorage.getProjectCurrentState(pid);\r\n        if (pjs == 1 && !refundInProgress && block.number > secondStorage.getPolicyEndDate(pid)) {\r\n            secondStorage.setProjectCurrentState(pid, 6);\r\n        }\r\n\r\n        if (pjs == 1 && refundInProgress && block.number > secondStorage.getRefundStatePeriod(pid)) {\r\n            secondStorage.setProjectCurrentState(pid, 4);\r\n            secondStorage.setIsRefundInProgress(pid, false);\r\n        }\r\n\r\n        if (pjs == 0 && block.number > secondStorage.getCrowdsaleEndTime(pid).add(93558)) {\r\n            secondStorage.setProjectCurrentState(pid, 1);\r\n        }\r\n\r\n        if ((tfc > 1 && pjs == 6 && block.number > secondStorage.getPolicyEndDate(pid).add(185142)) ||\r\n            (tfc > 1 && pjs == 5))\r\n        {\r\n            if (isBasePolicyExpired) {\r\n                refundPool.withdraw(pid, modRsrc, tfc.div(2));\r\n            } else {\r\n                refundPool.withdraw(pid, modRsrc, tfc);\r\n            }\r\n            secondStorage.setAmountOfFundsContributed(pid, 0);\r\n        }\r\n\r\n        if (pjs != 6 && pjs != 5 && pjs != 4 &&\r\n            block.number > secondStorage.getPolicyBase(pid) && !isBasePolicyExpired)\r\n        {\r\n            uint256 ase = secondStorage.getTotalAmountSecuredEther(pid);\r\n            secondStorage.setTotalAmountSecuredEther(pid, ase.div(2));\r\n            refundPool.withdraw(pid, modRsrc, tfc.div(2));\r\n            secondStorage.setBasePolicyExpired(pid);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"invalidInsuranceId\",\"type\":\"uint256[8]\"}],\"name\":\"cancelInvalid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"ownerWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"insuranceId\",\"type\":\"uint256\"}],\"name\":\"withdrawInsuranceFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startFrom\",\"type\":\"uint256\"},{\"name\":\"endBefore\",\"type\":\"uint256\"}],\"name\":\"voteMaintenance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"projectVoteMaintenance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"},{\"name\":\"did\",\"type\":\"uint256\"}],\"name\":\"withdrawDisputePayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"getBadVoters\",\"outputs\":[{\"name\":\"invalidInsuranceId\",\"type\":\"uint256[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startFrom\",\"type\":\"uint256\"},{\"name\":\"numberOfProjects\",\"type\":\"uint256\"}],\"name\":\"managePolicies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"verifyEligibility\",\"outputs\":[{\"name\":\"invalidInsuranceId\",\"type\":\"uint256[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"invalidInsuranceId\",\"type\":\"uint256[8]\"}],\"name\":\"removeCanceled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"projectStateMaintenance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"insuranceId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dAppMainContractAddr\",\"type\":\"address\"},{\"name\":\"storageAddr\",\"type\":\"address\"},{\"name\":\"secStorageAddr\",\"type\":\"address\"},{\"name\":\"eventLoggerAddr\",\"type\":\"address\"},{\"name\":\"refundPoolAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"RefundableTokenOfferingUtility","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"500000","ConstructorArguments":"0000000000000000000000004f62e6629e4f1cd8b72e7db8ff097f055a6ed4c000000000000000000000000057d504f3ebcc43b8a894a7933676eb17236cc35d000000000000000000000000ac5ae06a85b710c1c68708bb04b80f2d81c00617000000000000000000000000358994ca3f907b689c4177790a2cb424a3d2bcdf000000000000000000000000df4fdbf83329be988491b047140b37bba12bc4c1","Library":"","SwarmSource":"bzzr://3a535f53baafb43cdd7d99505a361552e51f34f177acdc01faf6cce9ccb012fa"}]}