{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract StakeWar {\r\n    //// events\r\n    event Staking(bool isSoviet, address addr, uint256 value);\r\n    event LeaderboardUpdated();\r\n    event VoteBought(bool isSoviet, address addr, uint256 value);\r\n    event GameStateChanged(uint8 state);\r\n    event ChangedImageApproval(uint8 approval, address playerAddr);\r\n    event SeedPaid(address addr, uint256 value);\r\n    event SettingsChanged();\r\n    \r\n    address payable chairman;\r\n    uint256 public constant unlockFromInit = 20 hours;\r\n    DividendToken dividendToken;\r\n    address public constant dividendTokenAddr = 0x8a6A9eFdC77530bf73b05d1005089aBF1B13687C;\r\n\r\n    //// game settings / unlocked while in play\r\n    uint8 public imgInitialApproval = 1; //0: not shown, 1: shown in leaderboard only, 2: approved for president image\r\n    bool public noDividendBadPerform = true;\r\n    ////\r\n\r\n    struct Player {\r\n        address payable addr;\r\n        bytes32 name;\r\n        string img;\r\n        uint8 imgApproval;\r\n    }\r\n    mapping (address => Player) public players;\r\n    mapping (bytes32 => address payable) public campaignLinks;\r\n\r\n    struct Settings {\r\n        uint8 presidentTotalPercent;\r\n        uint8 presidentSalaryPercent;\r\n        uint8 voteAdditionPercent;\r\n        uint8 maxStakeLeadPercent;\r\n        uint8 maximumVoteLeadPercent;\r\n        uint8 behindBonusPercent;\r\n        uint8 payoutDividendPercent;\r\n        uint8 unrestrictedStakingPercent;\r\n        uint8 seedersProfitPercent;\r\n        uint256 timeIncrement;\r\n        uint256 minimumStaking;\r\n        uint256 minimumVote;\r\n        uint256 unlockFromInit;\r\n        uint256 unlockFromSeeding;\r\n    }\r\n    struct Round {\r\n        uint256 potSize;\r\n        uint256 sovietAllianceBonus;\r\n        uint256 usAllianceBonus;\r\n        uint256 presidentPot;\r\n        uint256 seed;\r\n        uint256 deadline;\r\n        uint8 gameState;//0: not started yet, 1: seeding, 2: running, 3: finished \r\n\r\n        address sovietToken;\r\n        address usToken;\r\n        address seederToken;\r\n\r\n        address payable[5] sovietLeaderboard;\r\n        address payable[5] usLeaderboard;\r\n        \r\n        mapping (address => uint256) presidentSalaries;\r\n        mapping (address => uint256) sovietVotes;\r\n        mapping (address => uint256) usVotes;\r\n    }\r\n\r\n    mapping (uint256 => Settings) public settings;\r\n    mapping (uint256 => Round) public rounds;\r\n    uint256 public currentRound = 1;\r\n    uint256 public unlockedFrom;// game can be started without chairman after this time\r\n\r\n    //// Lookup functions\r\n    function getPresidentTotalPercent(uint256 round) public view returns(uint256) { return settings[round].presidentTotalPercent;}\r\n    function getPresidentSalaryPercent(uint256 round) public view returns(uint256) { return settings[round].presidentSalaryPercent;}\r\n    function getVoteAdditionPercent(uint256 round) public view returns(uint256) { return settings[round].voteAdditionPercent;}\r\n    function getMaxStakeLeadPercent(uint256 round) public view returns(uint256) { return settings[round].maxStakeLeadPercent;}\r\n    function getMaximumVoteLeadPercent(uint256 round) public view returns(uint256) { return settings[round].maximumVoteLeadPercent;}\r\n    function getBehindBonusPercent(uint256 round) public view returns(uint256) { return settings[round].behindBonusPercent;}\r\n    function getPayoutDividendPercent(uint256 round) public view returns(uint256) { return settings[round].payoutDividendPercent;}\r\n    function getTimeIncrement(uint256 round) public view returns(uint256) { return settings[round].timeIncrement;}\r\n    function getMinimumStaking(uint256 round) public view returns(uint256) { return settings[round].minimumStaking;}\r\n    function getMinimumVote(uint256 round) public view returns(uint256) { return settings[round].minimumVote;}\r\n    function getUnrestrictedStakingPercent(uint256 round) public view returns(uint256) { return settings[round].unrestrictedStakingPercent;}\r\n    function getUnlockFromInit(uint256 round) public view returns(uint256) { return settings[round].unlockFromInit;}\r\n    function getUnlockFromSeeding(uint256 round) public view returns(uint256) { return settings[round].unlockFromSeeding;}\r\n    function getSeedersProfitPercent(uint256 round) public view returns(uint256) { return settings[round].seedersProfitPercent;}\r\n    function getGameState(uint256 round) public view returns(uint256) { return rounds[round].gameState;}\r\n    function getDeadline(uint256 round) public view returns(uint256) { return rounds[round].deadline;}\r\n    function getPresidentSalaries(uint256 round, address addr) public view returns(uint256) { return rounds[round].presidentSalaries[addr];}\r\n    function getSovietTotalEquity(uint256 round) public view returns(uint256) { return BondToken(rounds[round].sovietToken).totalMinted(); }\r\n    function getUsTotalEquity(uint256 round) public view returns(uint256) { return BondToken(rounds[round].usToken).totalMinted(); }\r\n    function getPotSize(uint256 round) public view returns(uint256) { return rounds[round].potSize;}\r\n    function getSovietAllianceBonus(uint256 round) public view returns(uint256) { return rounds[round].sovietAllianceBonus;}\r\n    function getUsAllianceBonus(uint256 round) public view returns(uint256) { return rounds[round].usAllianceBonus;}\r\n    function getPresidentPot(uint256 round) public view returns(uint256) { return rounds[round].presidentPot;}\r\n    function getSeed(uint256 round) public view returns(uint256) { return rounds[round].seed;}\r\n    function getSeedersTotalProfit(uint256 round) public view returns(uint256) { \r\n        bool sovietsWon = getSovietTotalEquity(round) > getUsTotalEquity(round);\r\n        uint256 funds;\r\n        if (sovietsWon) {\r\n            funds = rounds[round].usAllianceBonus;\r\n        } else {\r\n            funds = rounds[round].sovietAllianceBonus;\r\n        }\r\n\r\n        uint256 seedersTotalProfit = SafeMath.div(SafeMath.mul(BondToken(getSeederToken(round)).totalMinted(), getSeedersProfitPercent(round)), 100);\r\n        if (funds < seedersTotalProfit) {\r\n            seedersTotalProfit = funds;\r\n        }\r\n        return seedersTotalProfit;\r\n    }\r\n    function getSeederToken(uint256 round) public view returns(address) { return rounds[round].seederToken;}\r\n    function getSeedersProfit(uint256 round, address addr) public view returns(uint256) { \r\n        uint256 totalSeedersTokens = BondToken(rounds[round].seederToken).totalMinted();\r\n        if (totalSeedersTokens == 0) {\r\n            return 0;\r\n        }\r\n        return SafeMath.div(SafeMath.mul(BondToken(rounds[round].seederToken).balanceOf(addr), getSeedersTotalProfit(round)), totalSeedersTokens);\r\n    }\r\n    function getSeedersEquity(uint256 round, address addr) public view returns(uint256) { \r\n        return BondToken(rounds[round].seederToken).balanceOf(addr);\r\n    }\r\n    function getToken(bool isSoviet, uint256 round) public view returns(address) {\r\n        if (isSoviet) {\r\n            return rounds[round].sovietToken;\r\n        } else {\r\n            return rounds[round].usToken;\r\n        }\r\n    }\r\n    function getEquity(bool isSoviet, uint256 round, address addr) public view returns(uint256) {\r\n        if (isSoviet) {\r\n            return BondToken(rounds[round].sovietToken).balanceOf(addr);\r\n        } else {\r\n            return BondToken(rounds[round].usToken).balanceOf(addr);\r\n        }\r\n    }\r\n    function getTotalEquity(bool isSoviet, uint256 round) public view returns(uint256) {\r\n        if (isSoviet) {\r\n            return BondToken(rounds[round].sovietToken).totalMinted();\r\n        } else {\r\n            return BondToken(rounds[round].usToken).totalMinted();\r\n        }\r\n    }\r\n    function getVotes(bool isSoviet, uint256 round, address addr) public view returns(uint256) {\r\n        if (isSoviet) {\r\n            return rounds[round].sovietVotes[addr];\r\n        } else {\r\n            return rounds[round].usVotes[addr];\r\n        }\r\n    }\r\n    function getLeaderboard(bool isSoviet, uint256 round, uint256 i) public view returns(address payable) {\r\n        if (isSoviet) {\r\n            return rounds[round].sovietLeaderboard[i];\r\n        } else {\r\n            return rounds[round].usLeaderboard[i];\r\n        }\r\n    }\r\n    \r\n    constructor() public {\r\n        chairman = msg.sender;\r\n        dividendToken = DividendToken(dividendTokenAddr);\r\n        unlockedFrom = SafeMath.add(now, unlockFromInit);\r\n        loadDefaultSettings();\r\n    }\r\n\r\n    function seedPot() external payable {\r\n        require(rounds[currentRound].gameState == 1, \"Game not in seeding state\");\r\n        \r\n        rounds[currentRound].potSize = SafeMath.add(rounds[currentRound].potSize, msg.value);\r\n        rounds[currentRound].seed = SafeMath.add(rounds[currentRound].seed, msg.value);\r\n        BondToken(rounds[currentRound].seederToken).mint(msg.sender, msg.value);\r\n        emit SeedPaid(msg.sender, msg.value);\r\n    }\r\n    \r\n    function loadDefaultSettings() public {\r\n        require(msg.sender == chairman || now > unlockedFrom, \"Chairman only function\");\r\n        require(rounds[currentRound].gameState == 0, \"Game not in init state\");\r\n        require(getPresidentTotalPercent(currentRound) == 0);\r\n\r\n        if (currentRound > 1) {\r\n            settings[currentRound] = settings[SafeMath.sub(currentRound,1)];\r\n        } else {\r\n            settings[currentRound] = Settings({ \r\n                presidentTotalPercent: 10,\r\n                presidentSalaryPercent: 20,\r\n                voteAdditionPercent: 20,\r\n                maxStakeLeadPercent: 60,\r\n                maximumVoteLeadPercent: 105,\r\n                behindBonusPercent: 120,\r\n                payoutDividendPercent: 20,\r\n                unrestrictedStakingPercent: 100,\r\n                seedersProfitPercent: 150,\r\n                timeIncrement: 1 days,\r\n                minimumStaking: 1 finney,\r\n                minimumVote: 10 finney,\r\n                unlockFromInit: 20 hours,\r\n                unlockFromSeeding: 48 hours\r\n            });\r\n        }\r\n    }\r\n    \r\n    function startSeeding() external {\r\n        require(msg.sender == chairman || now > unlockedFrom, \"Chairman only function\");\r\n        require(rounds[currentRound].gameState == 0, \"Game not in init state\");\r\n\r\n        if (getPresidentTotalPercent(currentRound) == 0) {\r\n            loadDefaultSettings();\r\n        }\r\n        unlockedFrom = SafeMath.add(now, getUnlockFromSeeding(currentRound));\r\n        rounds[currentRound].gameState = 1;\r\n        setupTokens();\r\n        \r\n        emit GameStateChanged(rounds[currentRound].gameState);\r\n    }\r\n\r\n    function startRound() external {\r\n        require(msg.sender == chairman || now > unlockedFrom, \"Chairman only function\");\r\n        require(rounds[currentRound].gameState == 1, \"Game not in seeding state\");\r\n        require(rounds[currentRound].seed > 0, \"Cannot start without seeding\");\r\n\r\n        rounds[currentRound].deadline = SafeMath.add(now, getTimeIncrement(currentRound));\r\n        rounds[currentRound].gameState = 2;\r\n        \r\n        emit GameStateChanged(rounds[currentRound].gameState);\r\n    }\r\n    \r\n    function stopRound() external {\r\n        require(now > rounds[currentRound].deadline, \"Time has not run out yet\");\r\n        require(rounds[currentRound].gameState == 2, \"Game not in running state\");\r\n        require(getUsTotalEquity(currentRound) > 0 || getSovietTotalEquity(currentRound) > 0, \"Cannot stop if noone staked\");\r\n\r\n        rounds[currentRound].gameState = 3;\r\n        emit GameStateChanged(rounds[currentRound].gameState);\r\n        unlockedFrom = SafeMath.add(now, getUnlockFromInit(currentRound));\r\n        currentRound = SafeMath.add(currentRound, 1);\r\n        rounds[currentRound].gameState = 0;\r\n        fundNewRound();\r\n    }\r\n\r\n    function setupTokens() private {\r\n        string memory roundStr = uint2str(currentRound);\r\n        BondToken _sovietToken = new BondToken(string(abi.encodePacked(\"Soviet War Bonds - Stakewar.com Round \", roundStr)), string(abi.encodePacked(\"SU\", roundStr)), true, currentRound);\r\n        rounds[currentRound].sovietToken = address(_sovietToken);\r\n        BondToken _usToken = new BondToken(string(abi.encodePacked(\"US War Bonds - Stakewar.com Round \", roundStr)), string(abi.encodePacked(\"US\", roundStr)), false, currentRound);\r\n        rounds[currentRound].usToken = address(_usToken);\r\n        BondToken _seederToken = new BondToken(string(abi.encodePacked(\"Seed Bonds - Stakewar.com Round \", roundStr)), string(abi.encodePacked(\"SD\", roundStr)), false, currentRound);\r\n        rounds[currentRound].seederToken = address(_seederToken);\r\n    }\r\n    \r\n    function changeSettings(uint8 _presidentTotalPercent, uint8 _presidentSalaryPercent, uint8 _voteAdditionPercent, uint8 _maxStakeLeadPercent, uint8 _maximumVoteLeadPercent, uint8 _behindBonusPercent, uint8 _payoutDividendPercent, uint8 _unrestrictedStakingPercent, uint8 _seedersProfitPercent, uint256 _timeIncrement, uint256 _minimumStaking, uint256 _minimumVote, uint256 _unlockFromInit, uint256 _unlockFromSeeding) external {\r\n        require(msg.sender == chairman, \"Chairman only function\");\r\n        require(rounds[currentRound].gameState == 0, \"Game not in init state\");\r\n        \r\n        settings[currentRound] = Settings({ \r\n            presidentTotalPercent: _presidentTotalPercent,\r\n            presidentSalaryPercent: _presidentSalaryPercent,\r\n            voteAdditionPercent: _voteAdditionPercent,\r\n            maxStakeLeadPercent: _maxStakeLeadPercent,\r\n            maximumVoteLeadPercent: _maximumVoteLeadPercent,\r\n            behindBonusPercent: _behindBonusPercent,\r\n            payoutDividendPercent: _payoutDividendPercent,\r\n            unrestrictedStakingPercent: _unrestrictedStakingPercent,\r\n            seedersProfitPercent: _seedersProfitPercent,\r\n            timeIncrement: _timeIncrement,\r\n            minimumStaking: _minimumStaking,\r\n            minimumVote: _minimumVote,\r\n            unlockFromInit: _unlockFromInit,\r\n            unlockFromSeeding: _unlockFromSeeding\r\n        });\r\n\r\n        emit SettingsChanged();\r\n    }\r\n    \r\n    function setImageApproval(uint8 approval, address playerAddr) external {\r\n        require(msg.sender == chairman, \"Chairman only function\");\r\n        players[playerAddr].imgApproval = approval;\r\n        emit ChangedImageApproval(approval, playerAddr);\r\n    }\r\n    \r\n    function setImageInitialApproval(uint8 approval) external {\r\n        require(msg.sender == chairman, \"Chairman only function\");\r\n        imgInitialApproval = approval;\r\n    }\r\n\r\n    function setNoDividendBadPerform(bool val) external {\r\n        require(msg.sender == chairman, \"Chairman only function\");\r\n        noDividendBadPerform = val;\r\n    }\r\n    \r\n    function buyVotes(bool isSoviet) external payable {\r\n        require(rounds[currentRound].gameState == 2, \"Game not in running state\");\r\n        require(getLeaderboard(isSoviet, currentRound, 0) != msg.sender, \"You are already president\");\r\n        addVotes(isSoviet, currentRound, msg.sender, SafeMath.mul(msg.value, 1000));\r\n        require(getVotes(isSoviet, currentRound, msg.sender) <= SafeMath.mul(getMinimumVote(currentRound), 1000) || getVotes(isSoviet, currentRound, msg.sender) <= SafeMath.div(SafeMath.mul(getVotes(isSoviet, currentRound, getLeaderboard(isSoviet, currentRound, 0)), getMaximumVoteLeadPercent(currentRound)), 100), \"Amount too high\");\r\n        refreshLeaderboard(isSoviet, msg.sender);\r\n        addAllianceBonus(isSoviet, currentRound, msg.value);\r\n        emit VoteBought(isSoviet, msg.sender, msg.value);\r\n    }\r\n    \r\n    function setPlayerInfo(bytes32 name, string calldata img) external {\r\n        require(campaignLinks[name] == address(0x0), \"Name already taken\");\r\n        \r\n        players[msg.sender] = Player(msg.sender, name, img, imgInitialApproval);\r\n        campaignLinks[name] = msg.sender;\r\n    }\r\n\r\n    function buyWarBonds(bool isSoviet, address payable _voteAddr, bool behindOnly) public payable {\r\n        buyWarBondsToAddr(msg.sender, isSoviet, _voteAddr, behindOnly);\r\n    }\r\n\r\n    function addVotes(bool isSoviet, uint256 round, address voteAddr, uint256 voteAddition) private {\r\n        if (isSoviet) {\r\n            rounds[round].sovietVotes[voteAddr] = SafeMath.add(rounds[round].sovietVotes[voteAddr], voteAddition);\r\n        } else {\r\n            rounds[round].usVotes[voteAddr] = SafeMath.add(rounds[round].usVotes[voteAddr], voteAddition);\r\n        }\r\n    }\r\n\r\n    function addAllianceBonus(bool isSoviet, uint256 round, uint256 value) private {\r\n        if (isSoviet) {\r\n            rounds[round].sovietAllianceBonus = SafeMath.add(rounds[round].sovietAllianceBonus, value);\r\n        } else {\r\n            rounds[round].usAllianceBonus = SafeMath.add(rounds[round].usAllianceBonus, value);\r\n        }\r\n    }\r\n\r\n    function buyWarBondsToAddr(address payable receiver, bool isSoviet, address payable _voteAddr, bool behindOnly) public payable {\r\n        require(rounds[currentRound].gameState == 2, \"Game not in running state\");\r\n        require(msg.value >= getMinimumStaking(currentRound), \"Staking too little\");\r\n        \r\n        address payable voteAddr = _voteAddr;\r\n\r\n        uint256 presidentTotal = SafeMath.div(SafeMath.mul(msg.value,getPresidentTotalPercent(currentRound)), 100);\r\n        uint256 presidentSalary = SafeMath.div(SafeMath.mul(presidentTotal, getPresidentSalaryPercent(currentRound)), 100);\r\n        uint256 voteAddition = SafeMath.mul(SafeMath.mul(msg.value,getVoteAdditionPercent(currentRound)), 10);\r\n        uint256 value =  SafeMath.sub(msg.value, presidentTotal);\r\n        bool wasBehind = false;\r\n        uint256 equityShares;\r\n\r\n        if (voteAddr == address(0x0)) {\r\n            voteAddr = getLeaderboard(isSoviet, currentRound, 0);\r\n        }\r\n        if (voteAddr == address(0x0)) {\r\n            voteAddr = receiver;\r\n        }\r\n\r\n        if (getTotalEquity(isSoviet, currentRound) <= getTotalEquity(!isSoviet, currentRound)) {\r\n            equityShares = SafeMath.div(SafeMath.mul(msg.value, getBehindBonusPercent(currentRound)),100);\r\n            wasBehind = true;\r\n        } else {\r\n            require(!behindOnly, 'behind only requested');\r\n            equityShares = msg.value;\r\n        }\r\n        equityShares = SafeMath.mul(equityShares, 1000);\r\n        BondToken(getToken(isSoviet, currentRound)).mint(receiver, equityShares);\r\n        require(getTotalEquity(isSoviet, currentRound) <= SafeMath.mul(SafeMath.mul(rounds[currentRound].seed, getUnrestrictedStakingPercent(currentRound)), 10) || getTotalEquity(isSoviet, currentRound) <= SafeMath.div(SafeMath.mul(SafeMath.add(getTotalEquity(isSoviet, currentRound), getTotalEquity(!isSoviet, currentRound)), getMaxStakeLeadPercent(currentRound)), 100), \"Alliance too far ahead\");// otherwise people only bet on the winning alliance and bring profits of earlier stakeers down\r\n\r\n        addVotes(isSoviet, currentRound, voteAddr, voteAddition);// maybe add factor 2, too high might make staking by candidate more profitable\r\n        refreshLeaderboard(isSoviet, voteAddr);\r\n        \r\n        rounds[currentRound].presidentSalaries[getLeaderboard(isSoviet, currentRound, 0)] = SafeMath.add(rounds[currentRound].presidentSalaries[getLeaderboard(isSoviet, currentRound, 0)], presidentSalary);\r\n        \r\n        if (wasBehind && getTotalEquity(isSoviet, currentRound) > getTotalEquity(!isSoviet, currentRound)) {\r\n            rounds[currentRound].deadline = SafeMath.add(now, getTimeIncrement(currentRound));\r\n        }\r\n        \r\n        rounds[currentRound].potSize = SafeMath.add(rounds[currentRound].potSize, value);\r\n        rounds[currentRound].presidentPot = SafeMath.add(rounds[currentRound].presidentPot, SafeMath.sub(presidentTotal, presidentSalary));\r\n            \r\n        emit Staking(isSoviet, receiver, value);\r\n    }\r\n    \r\n    function payoutAmount(uint256 round, address addr) public view returns(uint256) {\r\n        require(rounds[round].gameState == 3, \"Game not in finished state\");\r\n        \r\n        uint256 share=0;\r\n        if (getSovietTotalEquity(round) > getUsTotalEquity(round)) {\r\n            if (getSovietTotalEquity(round) > 0) {\r\n                share = SafeMath.div(SafeMath.mul(BondToken(rounds[round].sovietToken).balanceOf(addr), SafeMath.add(rounds[round].potSize, rounds[round].sovietAllianceBonus)), getSovietTotalEquity(round));\r\n            }\r\n            if (rounds[round].sovietLeaderboard[0] == addr) {\r\n                share = SafeMath.add(share, rounds[round].presidentPot);\r\n            }\r\n        } else {\r\n            if (getUsTotalEquity(round) > 0) {\r\n                share = SafeMath.div(SafeMath.mul(BondToken(rounds[round].usToken).balanceOf(addr), SafeMath.add(rounds[round].potSize, rounds[round].usAllianceBonus)), getUsTotalEquity(round));\r\n            }\r\n            if (rounds[round].usLeaderboard[0] == addr) {\r\n                share = SafeMath.add(share, rounds[round].presidentPot);\r\n            }\r\n        }\r\n        share = SafeMath.add(share, rounds[round].presidentSalaries[addr]);\r\n\r\n        share = SafeMath.add(share, getSeedersProfit(round, addr));\r\n\r\n        return share;\r\n    }\r\n    \r\n    function payoutAmountAllRounds(address addr) public view returns(uint256) {\r\n        uint256 share=0;\r\n        for (uint256 round=1;round < currentRound;round = SafeMath.add(round, 1)) {\r\n            share = SafeMath.add(share, payoutAmount(round, addr));\r\n        }\r\n        return share;\r\n    }\r\n    \r\n    function payout(uint256 round) public {\r\n        require(rounds[round].gameState == 3, \"Game not in finished state\");\r\n        \r\n        uint256 share = 0;\r\n        if (getSovietTotalEquity(round) > getUsTotalEquity(round)) {\r\n            if (getSovietTotalEquity(round) > 0) {\r\n                share = SafeMath.div(SafeMath.mul(BondToken(rounds[round].sovietToken).balanceOf(msg.sender), SafeMath.add(rounds[round].potSize, rounds[round].sovietAllianceBonus)), getSovietTotalEquity(round));\r\n            }\r\n            if (rounds[round].sovietLeaderboard[0] == msg.sender) {\r\n                share = SafeMath.add(share, rounds[round].presidentPot);\r\n                rounds[round].presidentPot = 0;\r\n            }\r\n        } else {\r\n            if (getUsTotalEquity(round) > 0) {\r\n                share = SafeMath.div(SafeMath.mul(BondToken(rounds[round].usToken).balanceOf(msg.sender), SafeMath.add(rounds[round].potSize, rounds[round].usAllianceBonus)), getUsTotalEquity(round));\r\n            }\r\n            if (rounds[round].usLeaderboard[0] == msg.sender) {\r\n                share = SafeMath.add(share, rounds[round].presidentPot);\r\n                rounds[round].presidentPot = 0;\r\n            }\r\n        }\r\n\r\n        BondToken(rounds[round].sovietToken).burnAll(msg.sender);\r\n        BondToken(rounds[round].usToken).burnAll(msg.sender);\r\n\r\n        share = SafeMath.add(share, rounds[round].presidentSalaries[msg.sender]);\r\n        rounds[round].presidentSalaries[msg.sender] = 0;\r\n\r\n        share = SafeMath.add(share, getSeedersProfit(round, msg.sender));\r\n        BondToken(rounds[round].seederToken).burnAll(msg.sender);\r\n\r\n        if (share > 0) {\r\n            msg.sender.transfer(share);\r\n        }\r\n    }\r\n    \r\n    function fundNewRound() private {\r\n        uint256 lastRound = SafeMath.sub(currentRound, 1);\r\n        uint256 dividends;\r\n        uint256 remainder;\r\n        uint256 funds;\r\n        bool sovietsWon = getSovietTotalEquity(lastRound) > getUsTotalEquity(lastRound);\r\n        if (sovietsWon) {\r\n            funds = rounds[lastRound].usAllianceBonus;\r\n        } else {\r\n            funds = rounds[lastRound].sovietAllianceBonus;\r\n        }\r\n\r\n        uint256 seedersTotalProfit = getSeedersTotalProfit(lastRound);\r\n\r\n        funds = SafeMath.sub(funds, seedersTotalProfit);\r\n\r\n        dividends = SafeMath.div(SafeMath.mul(funds, getPayoutDividendPercent(lastRound)), 100);\r\n        remainder = SafeMath.sub(funds, dividends);\r\n        if (noDividendBadPerform && SafeMath.sub(rounds[lastRound].seed, BondToken(rounds[lastRound].seederToken).totalMinted()) > remainder) {\r\n            dividends = 0;\r\n            remainder = funds;\r\n        }  \r\n        if (dividends > 0) {\r\n            dividendToken.deposit.value(dividends)();\r\n        }                \r\n        rounds[currentRound].potSize = SafeMath.add(rounds[currentRound].potSize, remainder);\r\n        rounds[currentRound].seed = SafeMath.add(rounds[currentRound].seed, remainder);\r\n    }\r\n\r\n    function payoutPresidentSalary(uint256 round) public {\r\n        uint256 share = rounds[round].presidentSalaries[msg.sender];\r\n        rounds[round].presidentSalaries[msg.sender] = 0;\r\n        msg.sender.transfer(share);\r\n    }\r\n    \r\n    function payoutAllRounds() public {\r\n        for (uint256 round=1;round < currentRound;round = SafeMath.add(round, 1)) {\r\n            payout(round);\r\n        }\r\n    }\r\n\r\n    function uint2str(uint256 __i) internal pure returns (string memory) {\r\n        uint256 _i = __i;\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function setLeaderboard(bool isSoviet, uint256 round, uint256 i, address payable a) private {\r\n        if (isSoviet) {\r\n            rounds[round].sovietLeaderboard[i] = a;\r\n        } else {\r\n            rounds[round].usLeaderboard[i] = a;\r\n        }\r\n    }\r\n\r\n    function refreshLeaderboard(bool isSoviet, address payable candidateAddr) private {\r\n        uint i = 0;\r\n        for(i;i < 5;i = SafeMath.add(i, 1)) {\r\n            if(getVotes(isSoviet, currentRound, getLeaderboard(isSoviet, currentRound, i)) < getVotes(isSoviet, currentRound, candidateAddr)) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (i < 5) {\r\n            i = 0;\r\n            for(i;i < 5;i = SafeMath.add(i, 1)) {\r\n                if(getLeaderboard(isSoviet, currentRound, i) == candidateAddr) {\r\n                    for(uint j = i;j < 4;j = SafeMath.add(j, 1)) {\r\n                        rounds[currentRound].sovietLeaderboard[j] = rounds[currentRound].sovietLeaderboard[SafeMath.add(j, 1)];\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            i = 0;\r\n            for(i;i < 5;i = SafeMath.add(i, 1)) {\r\n                if(getVotes(isSoviet, currentRound, getLeaderboard(isSoviet, currentRound, i)) < getVotes(isSoviet, currentRound, candidateAddr)) {\r\n                    break;\r\n                }\r\n            }\r\n        \r\n            for(uint j = 4;j > i;j = SafeMath.sub(j, 1)) {\r\n                rounds[currentRound].sovietLeaderboard[j] = rounds[currentRound].sovietLeaderboard[SafeMath.sub(j, 1)];\r\n            }\r\n            setLeaderboard(isSoviet, currentRound, i, candidateAddr);\r\n            emit LeaderboardUpdated();\r\n        }\r\n\r\n    } \r\n}\r\n\r\ncontract DividendToken {\r\n\r\n    string public name = \"Stakewar.com Dividend Token\";\r\n    string public symbol = \"SDT\";\r\n    uint8 public decimals = 18;\r\n\r\n    uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    constructor() public {\r\n        // Initially assign all tokens to the contract's creator.\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    uint256 public scaling = uint256(10) ** 8;\r\n\r\n    mapping(address => uint256) public scaledDividendBalanceOf;\r\n\r\n    uint256 public scaledDividendPerToken;\r\n\r\n    mapping(address => uint256) public scaledDividendCreditedTo;\r\n\r\n    function update(address account) internal {\r\n        uint256 owed = SafeMath.sub(scaledDividendPerToken, scaledDividendCreditedTo[account]);\r\n        scaledDividendBalanceOf[account] = SafeMath.add(scaledDividendBalanceOf[account], SafeMath.mul(balanceOf[account], owed));\r\n        scaledDividendCreditedTo[account] = scaledDividendPerToken;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= value);\r\n\r\n        update(msg.sender);\r\n        update(to);\r\n\r\n        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], value);\r\n        balanceOf[to] = SafeMath.add(balanceOf[to], value);\r\n\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(value <= balanceOf[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n\r\n        update(from);\r\n        update(to);\r\n\r\n        balanceOf[from] = SafeMath.sub(balanceOf[from], value);\r\n        balanceOf[to] = SafeMath.add(balanceOf[to], value);\r\n        allowance[from][msg.sender] = SafeMath.sub(allowance[from][msg.sender], value);\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    uint256 public scaledRemainder = 0;\r\n\r\n    function deposit() public payable {\r\n        // scale the deposit and add the previous remainder\r\n        uint256 available = SafeMath.add(SafeMath.mul(msg.value, scaling), scaledRemainder);\r\n\r\n        scaledDividendPerToken = SafeMath.add(scaledDividendPerToken, SafeMath.div(available, totalSupply));\r\n\r\n        // compute the new remainder\r\n        scaledRemainder = available % totalSupply;\r\n    }\r\n\r\n    function withdraw() public {\r\n        update(msg.sender);\r\n        uint256 amount = SafeMath.div(scaledDividendBalanceOf[msg.sender], scaling);\r\n        scaledDividendBalanceOf[msg.sender] %= scaling;  // retain the remainder\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    \r\n    address payable stakeWar;\r\n    \r\n    uint256 total;\r\n    uint256 payout;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return SafeMath.sub(total, payout);\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function totalMinted() public view returns (uint256) {\r\n        return total;\r\n    }\r\n\r\n    function totalPayout() public view returns (uint256) {\r\n        return payout;\r\n    }\r\n\r\n    function mint(address to, uint256 value) public {\r\n        require(msg.sender == stakeWar, 'Must be initiated by Stakewar');\r\n        require(to != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _balances[to] = SafeMath.add(_balances[to], value);\r\n        total = SafeMath.add(total, value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function burnAll(address from) public {\r\n        require(msg.sender == stakeWar, 'Must be initiated by Stakewar');\r\n\r\n        _burn(from, _balances[from]);\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n \r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, SafeMath.sub(_allowances[sender][msg.sender], amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, SafeMath.add(_allowances[msg.sender][spender], addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, SafeMath.sub(_allowances[msg.sender][spender], subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0), 'Transfer to null address not allowed');\r\n        require(msg.sender == from, 'Transfer must be initiated by message sender');\r\n        require(_balances[from] >= value);\r\n\r\n        _balances[msg.sender] = SafeMath.sub(_balances[msg.sender], value);\r\n        _balances[to] = SafeMath.add(_balances[to], value);\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = SafeMath.sub(_balances[account], amount);\r\n        payout = SafeMath.add(payout, amount);\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract BondToken is ERC20, ERC20Detailed {\r\n    uint8 public constant DECIMALS = 18;\r\n    bool private isSoviet;\r\n    uint256 private round;\r\n    constructor (string memory __name, string memory __symbol, bool _isSoviet, uint256 _round) public ERC20Detailed(__name, __symbol, DECIMALS) {\r\n        stakeWar = msg.sender;\r\n        isSoviet = _isSoviet;\r\n        round = _round;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b);// There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"scaledDividendBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"scaledDividendCreditedTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scaledDividendPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scaledRemainder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scaling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DividendToken","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://ff71e4710a82443b676dc242667082839fdf73c124417ef31c716419ffd9dd56"}]}