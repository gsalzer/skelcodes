{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract Receiver {\r\n    //The purpose of this contract is to act purely as a static address\r\n    //in the Ethereum uint256 address space from which to initiate other\r\n    //actions\r\n\r\n    //State\r\n    address public implementation;\r\n    bool public isPayable;\r\n\r\n    //Events\r\n    event LogImplementationChanged(address _oldImplementation, address _newImplementation);\r\n    event LogPaymentReceived(address sender, uint256 value);\r\n\r\n    constructor(address _implementation, bool _isPayable)\r\n        public\r\n    {\r\n        require(_implementation != address(0), \"Implementation address cannot be 0\");\r\n        implementation = _implementation;\r\n        isPayable = _isPayable;\r\n    }\r\n\r\n    modifier onlyImplementation\r\n    {\r\n        require(msg.sender == implementation, \"Only the contract implementation may perform this action\");\r\n        _;\r\n    }\r\n    \r\n    function drain()\r\n        external\r\n        onlyImplementation\r\n    {\r\n        msg.sender.call.value(address(this).balance)(\"\");\r\n    }\r\n\r\n\r\n    function ()\r\n        external\r\n        payable \r\n    {\r\n        if (msg.sender != implementation) {\r\n            if (isPayable) {\r\n                emit LogPaymentReceived(msg.sender, msg.value);\r\n            } else {\r\n                revert(\"not payable\");\r\n            }\r\n        } else {\r\n            assembly {\r\n                switch calldatasize\r\n                case 0 {\r\n                }\r\n                default {\r\n                    //Copy call data into free memory region.\r\n                    let free_ptr := mload(0x40)\r\n                    calldatacopy(free_ptr, 0, calldatasize)\r\n\r\n                    //Forward all gas and call data to the target contract.\r\n                    let result := delegatecall(gas, caller, free_ptr, calldatasize, 0, 0)\r\n                    returndatacopy(free_ptr, 0, returndatasize)\r\n\r\n                    //Revert if the call failed, otherwise return the result\r\n                    if iszero(result) { revert(free_ptr, returndatasize) }\r\n                    return(free_ptr, returndatasize)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPayable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"},{\"name\":\"_isPayable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"LogImplementationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPaymentReceived\",\"type\":\"event\"}]","ContractName":"Receiver","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003d8a8205ade03f6b55b9613a7b776fb858f7bbe80000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://7c2da1f8547d974e783d8a4f31121dc30140e0bf68446b2bfa31c6c646939d98"}]}