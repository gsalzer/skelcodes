{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20Token.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24 \\u003c0.6.0;\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract IERC20Token{\\n// these functions aren\\u0027t abstract since the compiler emits automatically generated getter functions as external\\nfunction name() public view returns(string memory);\\nfunction symbol() public view returns(string memory);\\nfunction decimals() public view returns(uint256);\\nfunction totalSupply() public view returns (uint256);\\nfunction balanceOf(address _owner) public view returns (uint256);\\nfunction allowance(address _owner, address _spender) public view returns (uint256);\\n\\nfunction transfer(address _to, uint256 _value) public returns (bool success);\\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\nfunction approve(address _spender, uint256 _value) public returns (bool success);\\n event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\"},\"Omg.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24 \\u003c0.6.0;\\nimport \\\"./UrgencyPause.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20Token.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract Omg is Ownable, UrgencyPause {\\n    using SafeMath for uint256;\\n\\n    uint256 private _startTime = 1567213749;  //解仓时间s 2019/9/1 9:00:00 - 1\\n    uint256 constant UNLOCK_DURATION = 100;\\n    uint256 constant DAY_UINT = 1*24*60*60;  //换算成天数\\n    address[] private _investors;\\n    mapping (address=\\u003eInvestor) _mapInvestors;\\n\\n    IERC20Token private _xlToken;\\n     //投资者结构体\\n     struct Investor {\\n         address account;\\n         uint256 lockXLs;\\n         uint256 unlockXLs;\\n     }\\n\\n     event TokenChanged(address indexed token,uint256 indexed time);\\n     event LockXLEvent(address indexed acc,uint256 indexed lockXLs);\\n     event StartTimeUnlock(address indexed account,uint256 indexed startTime);\\n     event UnlockXLEvent(address indexed acc,uint256 indexed unlockXLs);\\n     constructor(IERC20Token token) public {\\n         _xlToken = IERC20Token(token);\\n     }\\n\\n     function () external {\\n         if(super.isManager(msg.sender)){\\n             unlockBatch(); //管理者批量发送\\n         }else{\\n             unlockAccount(msg.sender);  //单个拉取\\n         }\\n     }\\n     \\n     //当前天数 1-100\\n     function curDays() public view returns(uint256) {\\n         uint256 curSeconds = now.sub(_startTime);\\n         uint256 curDay = curSeconds.div(DAY_UINT);\\n         return curDay;\\n     }\\n     \\n     //是否完成释放\\n     function isFinished() public view returns(bool) {\\n         return curDays() \\u003e= UNLOCK_DURATION;\\n     }\\n\\n\\n     //设置解仓时间\\n      function setStartTimeUnLock(uint256 _time) public onlyOwner {\\n          _startTime = _time;\\n          emit StartTimeUnlock(msg.sender,_time);\\n      }\\n    \\n    function setToken(IERC20Token _token) public onlyOwner {\\n        _xlToken = IERC20Token(_token);\\n        emit TokenChanged(address(_token),now);\\n    }\\n\\n    //投资者数量\\n    function investors() public view returns(uint256 count) {\\n        return _investors.length;\\n    }\\n\\n    //添加用户锁仓记录\\n    function addInvestor(address _acc,uint256 _lockXLs) public notPaused onlyOwner {\\n        require(_acc != address(0),\\\"无地址\\\");\\n        uint256 lockXLs = _lockXLs;//.div(10**18); //除去精度\\n        require(_mapInvestors[_acc].account == address(0),\\\"该投资者已存在!!\\\");\\n        _investors.push(_acc);\\n        _mapInvestors[_acc] = Investor({account:_acc,lockXLs:lockXLs,unlockXLs:0});\\n        emit LockXLEvent(_acc,lockXLs);\\n    }\\n\\n    //删除用户记录\\n    function removeInvestorAtIndex(uint256  index) public onlyOwner {\\n        if(index \\u003c _investors.length) {\\n            address acc = _investors[index];\\n            _mapInvestors[acc] = Investor(address(0),0,0);\\n            delete _investors[index];\\n            //填上删除的空白\\n            _investors[index] = _investors[_investors.length - 1];\\n        }\\n    }\\n\\n    function investorAtAccount(address acc) public view returns(address account,\\n         uint256 lockXLs,\\n         uint256 unlockXLs) {\\n        Investor storage inv = _mapInvestors[acc];\\n             account = inv.account;\\n             lockXLs = inv.lockXLs;\\n             unlockXLs = inv.unlockXLs;\\n    }\\n\\n    function appendLocksXLs(address acc,uint256 lockXls) public onlyManager {\\n        require(acc != address(0),\\\"0地址\\\");\\n        if(_mapInvestors[acc].account == address(0)){//新增\\n            addInvestor(acc,lockXls);\\n        }else{ //追加\\n            Investor storage inv = _mapInvestors[acc];\\n            inv.lockXLs = inv.lockXLs.add(lockXls);\\n        }\\n    }\\n\\n   //解锁某个账户\\n    function unlockAccount(address acc) internal {\\n        Investor storage inv = _mapInvestors[acc];\\n             if(inv.account == address(0)){\\n                 return;\\n             }\\n              uint curDay = curDays();\\n              //1%,100天\\n              uint256 totalUnlock = inv.lockXLs.mul(curDay).div(UNLOCK_DURATION);\\n\\n              //当前总释放量 - 已经释放的量\\n              uint256 unlocking = totalUnlock.sub(inv.unlockXLs);\\n              if(unlocking \\u003c= 0){ //等零则已经释放过\\n                  return;\\n              }\\n              inv.unlockXLs = totalUnlock;\\n              _mapInvestors[acc].unlockXLs = totalUnlock;\\n              _xlToken.transfer(inv.account,unlocking);\\n              emit UnlockXLEvent(inv.account,unlocking);\\n    }\\n    //批量释放\\n    function unlockBatch() public notPaused onlyManager {\\n       // require(isFinished() == false,\\\"释放时间已到\\\");\\n        //当前释放量 = 锁仓总量*curDay/100 - 已经释放量\\n        uint curDay = curDays();\\n        require(curDay \\u003c= UNLOCK_DURATION,\\\"释放周期完成!\\\");\\n        for (uint256 i = 0; i \\u003c _investors.length; ++i){\\n             address acc = _investors[i];\\n             if(acc == address(0)){\\n                 continue;\\n             }\\n             unlockAccount(acc);\\n        }\\n    }\\n\\n    function balanceAt(address acc) public view returns(uint256 balance){\\n        require(acc != address(0),\\\"地址无效!\\\");\\n        balance = _xlToken.balanceOf(acc);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24 \\u003c0.6.0;\\nimport \\\"./IERC20Token.sol\\\";\\ncontract Ownable {\\n    address private _owner;\\n    mapping (address=\\u003ebool) private _managers;\\n    event OwnershipTransferred(address indexed prevOwner,address indexed newOwner);\\n    event WithdrawEtherEvent(address indexed receiver,uint256 indexed amount,uint256 indexed atime);\\n    //管理者处理事件\\n    event ManagerChange(address indexed manager,bool indexed isMgr);\\n    //modifier\\n    modifier onlyOwner{\\n        require(msg.sender == _owner, \\\"sender not eq owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyManager{\\n        require(_managers[msg.sender] == true, \\\"不是管理员\\\");\\n        _;\\n    }\\n    constructor() internal{\\n        _owner = msg.sender;\\n        _managers[msg.sender] = true;\\n    }\\n\\n    function owner() public view returns(address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"newOwner can\\u0027t be empty!\\\");\\n        address prevOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(prevOwner,newOwner);\\n    }\\n\\n    //管理员\\n    function changeManager(address account,bool isManager) public onlyOwner {\\n        _managers[account] = isManager;\\n        emit ManagerChange(account,isManager);\\n    }\\n    function isManager(address account) public view returns(bool) {\\n        return _managers[account];\\n    }\\n\\n    /**\\n     * @dev Rescue compatible ERC20 Token\\n     *\\n     * @param tokenAddr ERC20 The address of the ERC20 token contract\\n     * @param receiver The address of the receiver\\n     * @param amount uint256\\n     */\\n    function rescueTokens(IERC20Token tokenAddr, address receiver, uint256 amount) external onlyOwner {\\n        IERC20Token _token = IERC20Token(tokenAddr);\\n        require(receiver != address(0),\\\"receiver can\\u0027t be empty!\\\");\\n        uint256 balance = _token.balanceOf(address(this));\\n        require(balance \\u003e= amount,\\\"balance is not enough!\\\");\\n        require(_token.transfer(receiver, amount),\\\"transfer failed!!\\\");\\n    }\\n\\n    /**\\n     * @dev Withdraw ether\\n     */\\n    function withdrawEther(address payable to, uint256 amount) external onlyOwner {\\n        require(to != address(0),\\\"address can\\u0027t be empty\\\");\\n        uint256 balance = address(this).balance;\\n        require(balance \\u003e= amount,\\\"this balance is not enough!\\\");\\n        to.transfer(amount);\\n       emit WithdrawEtherEvent(to,amount,now);\\n    }\\n\\n\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24 \\u003c0.6.0;\\n\\n/*\\n    Library for basic math operations with overflow/underflow protection\\n*/\\nlibrary SafeMath {\\n    /**\\n        @dev returns the sum of _x and _y, reverts if the calculation overflows\\n\\n        @param _x   value 1\\n        @param _y   value 2\\n\\n        @return sum\\n    */\\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\\n        uint256 z = _x + _y;\\n        require(z \\u003e= _x,\\\"SafeMath-\\u003emul got a exception\\\");\\n        return z;\\n    }\\n\\n    /**\\n        @dev returns the difference of _x minus _y, reverts if the calculation underflows\\n\\n        @param _x   minuend\\n        @param _y   subtrahend\\n\\n        @return difference\\n    */\\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\\n        require(_x \\u003e= _y,\\\"SafeMath-\\u003esub got a exception\\\");\\n        return _x - _y;\\n    }\\n\\n    /**\\n        @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\\n\\n        @param _x   factor 1\\n        @param _y   factor 2\\n\\n        @return product\\n    */\\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\\n        // gas optimization\\n        if (_x == 0)\\n            return 0;\\n\\n        uint256 z = _x * _y;\\n        require(z / _x == _y,\\\"SafeMath-\\u003emul got a exception\\\");\\n        return z;\\n    }\\n\\n      /**\\n        @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n\\n        @param _x   dividend\\n        @param _y   divisor\\n\\n        @return quotient\\n    */\\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\\n        require(_y \\u003e 0,\\\"SafeMath-\\u003ediv got a exception\\\");\\n        uint256 c = _x / _y;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"UrgencyPause.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24 \\u003c0.6.0;\\n/*\\n*紧急情况下暂停转账\\n*\\n*/\\nimport \\\"./Ownable.sol\\\";\\ncontract UrgencyPause is Ownable{\\n    bool private _paused;\\n    event Paused(address indexed account,bool indexed state);\\n    \\n    modifier notPaused(){\\n        require(!_paused,\\\"the state is paused!\\\");\\n        _;\\n    }\\n    constructor() public{\\n        _paused = false;\\n    }\\n\\n\\n    function paused() public view returns(bool) {\\n        return _paused;\\n    }\\n\\n    function setPaused(bool state) public onlyManager {\\n            _paused = state;\\n            emit Paused(msg.sender,_paused);\\n    }\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"curDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"investorAtAccount\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"lockXLs\",\"type\":\"uint256\"},{\"name\":\"unlockXLs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"balanceAt\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investors\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setStartTimeUnLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"acc\",\"type\":\"address\"},{\"name\":\"lockXls\",\"type\":\"uint256\"}],\"name\":\"appendLocksXLs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"isManager\",\"type\":\"bool\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeInvestorAtIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_acc\",\"type\":\"address\"},{\"name\":\"_lockXLs\",\"type\":\"uint256\"}],\"name\":\"addInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"acc\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"lockXLs\",\"type\":\"uint256\"}],\"name\":\"LockXLEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"StartTimeUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"acc\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"unlockXLs\",\"type\":\"uint256\"}],\"name\":\"UnlockXLEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"atime\",\"type\":\"uint256\"}],\"name\":\"WithdrawEtherEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"isMgr\",\"type\":\"bool\"}],\"name\":\"ManagerChange\",\"type\":\"event\"}]","ContractName":"Omg","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000336a24fc03c93101d4e31160c27eeaedc34be01d","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://369bae078ad0ffb3c27a84cbcf131b5a209e9b0683d9d5d2152aa28af428d9ff"}]}