{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != 0x0);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract BasicToken is owned {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal balance_of;\r\n    mapping (address => mapping (address => uint256)) internal allowances;\r\n\r\n    mapping (address => bool) private address_exist;\r\n    address[] private address_list;\r\n\r\n    bool public transfer_close = false;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function BasicToken() public {\r\n    }\r\n\r\n    function balanceOf(address token_owner) public constant returns (uint balance) {\r\n        return balance_of[token_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _hoarder,\r\n        address _spender\r\n    ) public constant returns (uint256) {\r\n        return allowances[_hoarder][_spender];\r\n    }\r\n\r\n    function superApprove(\r\n        address _hoarder,\r\n        address _spender,\r\n        uint256 _value\r\n    ) onlyOwner public returns(bool) {\r\n        require(_hoarder != address(0));\r\n        require(_spender != address(0));\r\n        require(_value >= 0);\r\n        allowances[_hoarder][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(msg.sender != address(0));\r\n        require(_spender != address(0));\r\n        require(_value >= 0);\r\n        allowances[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function getAddressLength() onlyOwner public constant returns (uint) {\r\n        return address_list.length;\r\n    }\r\n\r\n    function getAddressIndex(uint _address_index) onlyOwner public constant returns (address _address) {\r\n        _address = address_list[_address_index];\r\n    }\r\n\r\n    function getAllAddress() onlyOwner public constant returns (address[]) {\r\n        return address_list;\r\n    }\r\n\r\n    function getAddressExist(address _target) public constant returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        } else {\r\n            return address_exist[_target];\r\n        }\r\n    }\r\n\r\n    function addAddress(address _target) internal returns(bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        } else if (address_exist[_target] == true) {\r\n            return false;\r\n        } else {\r\n            address_exist[_target] = true;\r\n            address_list[address_list.length++] = _target;\r\n        }\r\n    }\r\n\r\n    function mintToken(\r\n        address _to,\r\n        uint256 token_amount,\r\n        uint256 freeze_timestamp\r\n    ) onlyOwner public returns (bool);\r\n\r\n    function superMint(\r\n        address _to,\r\n        uint256 token_amount,\r\n        uint256 freeze_timestamp) onlyOwner public returns(bool);\r\n\r\n    function transfer(address to, uint256 value) public;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public;\r\n\r\n    function transferOpen() onlyOwner public {\r\n        transfer_close = false;\r\n    }\r\n\r\n    function transferClose() onlyOwner public {\r\n        transfer_close = true;\r\n    }\r\n}\r\n\r\ncontract PreSale is owned{\r\n    using SafeMath for uint256;\r\n\r\n    struct Sale {\r\n        uint sale_number;\r\n        uint256 start_timestamp;\r\n        uint256 end_timestamp;\r\n        uint8 bonus_rate;\r\n        uint256 sell_limit;\r\n    }\r\n\r\n    Sale[] private sale_list;\r\n    uint256[] private sale_sold;\r\n\r\n    function PreSale () public {\r\n\r\n    }\r\n\r\n    function getSaleLength() public constant returns(uint) {\r\n        return sale_list.length;\r\n    }\r\n\r\n    function getSaleInfo(uint _index) public constant returns(\r\n        uint sale_number,\r\n        uint256 start_timestamp,\r\n        uint256 end_timestamp,\r\n        uint8 bonus_rate,\r\n        uint256 sell_limit\r\n    ) {\r\n        sale_number = sale_list[_index].sale_number;\r\n        start_timestamp = sale_list[_index].start_timestamp;\r\n        end_timestamp = sale_list[_index].end_timestamp;\r\n        bonus_rate = sale_list[_index].bonus_rate;\r\n        sell_limit = sale_list[_index].sell_limit;\r\n    }\r\n\r\n    function getSaleSold(uint _index) public constant returns(uint256) {\r\n        return sale_sold[_index];\r\n    }\r\n\r\n\r\n    function addBonus(\r\n        uint256 _amount,\r\n        uint8 _bonus\r\n    ) internal pure returns(uint256) {\r\n        return _amount.add((_amount.mul(_bonus)).div(100));\r\n    }\r\n\r\n\r\n    function newSale(\r\n        uint256 start_timestamp,\r\n        uint256 end_timestamp,\r\n        uint8 bonus_rate,\r\n        uint256 sell_token_limit\r\n    ) onlyOwner public {\r\n        require(start_timestamp > 0);\r\n        require(end_timestamp > 0);\r\n        require(sell_token_limit > 0);\r\n\r\n        uint256 sale_number = sale_list.length;\r\n        for (uint i=0; i < sale_list.length; i++) {\r\n            require(sale_list[i].end_timestamp < start_timestamp);\r\n        }\r\n\r\n        sale_list[sale_list.length++] = Sale({\r\n            sale_number: sale_number,\r\n            start_timestamp: start_timestamp,\r\n            end_timestamp: end_timestamp,\r\n            bonus_rate: bonus_rate,\r\n            sell_limit: sell_token_limit\r\n        });\r\n        sale_sold[sale_sold.length++] = 0;\r\n    }\r\n\r\n    function changeSaleInfo(\r\n        uint256 _index,\r\n        uint256 start_timestamp,\r\n        uint256 end_timestamp,\r\n        uint8 bonus_rate,\r\n        uint256 sell_token_limit\r\n    ) onlyOwner public returns(bool) {\r\n        require(_index < sale_list.length);\r\n        require(start_timestamp > 0);\r\n        require(end_timestamp > 0);\r\n        require(sell_token_limit > 0);\r\n\r\n        sale_list[_index].start_timestamp = start_timestamp;\r\n        sale_list[_index].end_timestamp = end_timestamp;\r\n        sale_list[_index].bonus_rate = bonus_rate;\r\n        sale_list[_index].sell_limit = sell_token_limit;\r\n        return true;\r\n    }\r\n\r\n    function changeSaleStart(\r\n        uint256 _index,\r\n        uint256 start_timestamp\r\n    ) onlyOwner public returns(bool) {\r\n        require(_index < sale_list.length);\r\n        require(start_timestamp > 0);\r\n        sale_list[_index].start_timestamp = start_timestamp;\r\n        return true;\r\n    }\r\n\r\n    function changeSaleEnd(\r\n        uint256 _index,\r\n        uint256 end_timestamp\r\n    ) onlyOwner public returns(bool) {\r\n        require(_index < sale_list.length);\r\n        require(end_timestamp > 0);\r\n        sale_list[_index].end_timestamp = end_timestamp;\r\n        return true;\r\n    }\r\n\r\n    function changeSaleBonusRate(\r\n        uint256 _index,\r\n        uint8 bonus_rate\r\n    ) onlyOwner public returns(bool) {\r\n        require(_index < sale_list.length);\r\n        sale_list[_index].bonus_rate = bonus_rate;\r\n        return true;\r\n    }\r\n\r\n    function changeSaleTokenLimit(\r\n        uint256 _index,\r\n        uint256 sell_token_limit\r\n    ) onlyOwner public returns(bool) {\r\n        require(_index < sale_list.length);\r\n        require(sell_token_limit > 0);\r\n        sale_list[_index].sell_limit = sell_token_limit;\r\n        return true;\r\n    }\r\n\r\n\r\n    function checkSaleCanSell(\r\n        uint256 _index,\r\n        uint256 _amount\r\n    ) internal view returns(bool) {\r\n        uint256 index_sold = sale_sold[_index];\r\n        uint256 index_end_timestamp = sale_list[_index].end_timestamp;\r\n        uint256 sell_limit = sale_list[_index].sell_limit;\r\n        uint8 bonus_rate = sale_list[_index].bonus_rate;\r\n        uint256 sell_limit_plus_bonus = addBonus(sell_limit, bonus_rate);\r\n\r\n        if (now >= index_end_timestamp) {\r\n            return false;\r\n        } else if (index_sold.add(_amount) > sell_limit_plus_bonus) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function addSaleSold(uint256 _index, uint256 amount) internal {\r\n        require(amount > 0);\r\n        require(_index < sale_sold.length);\r\n        require(checkSaleCanSell(_index, amount) == true);\r\n        sale_sold[_index] += amount;\r\n    }\r\n\r\n    function subSaleSold(uint256 _index, uint256 amount) internal {\r\n        require(amount > 0);\r\n        require(_index < sale_sold.length);\r\n        require(sale_sold[_index].sub(amount) >= 0);\r\n        sale_sold[_index] -= amount;\r\n    }\r\n\r\n    function canSaleInfo() public view returns(\r\n        uint sale_number,\r\n        uint256 start_timestamp,\r\n        uint256 end_timestamp,\r\n        uint8 bonus_rate,\r\n        uint256 sell_limit\r\n    ) {\r\n        var(sale_info, isSale) = nowSaleInfo();\r\n        require(isSale == true);\r\n        sale_number = sale_info.sale_number;\r\n        start_timestamp = sale_info.start_timestamp;\r\n        end_timestamp = sale_info.end_timestamp;\r\n        bonus_rate = sale_info.bonus_rate;\r\n        sell_limit = sale_info.sell_limit;\r\n    }\r\n\r\n    function nowSaleInfo() internal view returns(Sale sale_info, bool isSale) {\r\n        isSale = false;\r\n        for (uint i=0; i < sale_list.length; i++) {\r\n            uint256 end_timestamp = sale_list[i].end_timestamp;\r\n            uint256 sell_limit = sale_list[i].sell_limit;\r\n            uint8 bonus_rate = sale_list[i].bonus_rate;\r\n            uint256 sell_limit_plus_bonus = addBonus(sell_limit, bonus_rate);\r\n            uint256 temp_sold_token = sale_sold[i];\r\n            if ((now <= end_timestamp) && (temp_sold_token < sell_limit_plus_bonus)) {\r\n                sale_info = Sale({\r\n                    sale_number: sale_list[i].sale_number,\r\n                    start_timestamp: sale_list[i].start_timestamp,\r\n                    end_timestamp: sale_list[i].end_timestamp,\r\n                    bonus_rate: sale_list[i].bonus_rate,\r\n                    sell_limit: sale_list[i].sell_limit\r\n                });\r\n                isSale = true;\r\n                break;\r\n            } else {\r\n                isSale = false;\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Vote is owned {\r\n    event ProposalAdd(uint vote_id, address generator, string descript);\r\n    event ProposalEnd(uint vote_id, string descript);\r\n\r\n    struct Proposal {\r\n        address generator;\r\n        string descript;\r\n        uint256 start_timestamp;\r\n        uint256 end_timestamp;\r\n        bool executed;\r\n        uint256 voting_cut;\r\n        uint256 threshold;\r\n\r\n        uint256 voting_count;\r\n        uint256 total_weight;\r\n        mapping (address => uint256) voteWeightOf;\r\n        mapping (address => bool) votedOf;\r\n        address[] voter_address;\r\n    }\r\n\r\n    uint private vote_id = 0;\r\n    Proposal[] private Proposals;\r\n\r\n    function getProposalLength() public constant returns (uint) {\r\n        return Proposals.length;\r\n    }\r\n\r\n    function getProposalIndex(uint _proposal_index) public constant returns (\r\n        address generator,\r\n        string descript,\r\n        uint256 start_timestamp,\r\n        uint256 end_timestamp,\r\n        bool executed,\r\n        uint256 voting_count,\r\n        uint256 total_weight,\r\n        uint256 voting_cut,\r\n        uint256 threshold\r\n    ) {\r\n        generator = Proposals[_proposal_index].generator;\r\n        descript = Proposals[_proposal_index].descript;\r\n        start_timestamp = Proposals[_proposal_index].start_timestamp;\r\n        end_timestamp = Proposals[_proposal_index].end_timestamp;\r\n        executed = Proposals[_proposal_index].executed;\r\n        voting_count = Proposals[_proposal_index].voting_count;\r\n        total_weight = Proposals[_proposal_index].total_weight;\r\n        voting_cut = Proposals[_proposal_index].voting_cut;\r\n        threshold = Proposals[_proposal_index].threshold;\r\n    }\r\n\r\n    function getProposalVoterList(uint _proposal_index) public constant returns (address[]) {\r\n        return Proposals[_proposal_index].voter_address;\r\n    }\r\n\r\n    function newVote(\r\n        address who,\r\n        string descript,\r\n        uint256 start_timestamp,\r\n        uint256 end_timestamp,\r\n        uint256 voting_cut,\r\n        uint256 threshold\r\n    ) onlyOwner public returns (uint256) {\r\n        if (Proposals.length >= 1) {\r\n            require(Proposals[vote_id].end_timestamp < start_timestamp);\r\n            require(Proposals[vote_id].executed == true);\r\n        }\r\n\r\n        vote_id = Proposals.length;\r\n        Proposal storage p = Proposals[Proposals.length++];\r\n        p.generator = who;\r\n        p.descript = descript;\r\n        p.start_timestamp = start_timestamp;\r\n        p.end_timestamp = end_timestamp;\r\n        p.executed = false;\r\n        p.voting_cut = voting_cut;\r\n        p.threshold = threshold;\r\n\r\n        p.voting_count = 0;\r\n        delete p.voter_address;\r\n        ProposalAdd(vote_id, who, descript);\r\n        return vote_id;\r\n    }\r\n\r\n    function voting(address _voter, uint256 _weight) internal returns(bool) {\r\n        if (Proposals[vote_id].end_timestamp < now) {\r\n            Proposals[vote_id].executed = true;\r\n        }\r\n\r\n        require(Proposals[vote_id].executed == false);\r\n        require(Proposals[vote_id].end_timestamp > now);\r\n        require(Proposals[vote_id].start_timestamp <= now);\r\n        require(Proposals[vote_id].votedOf[_voter] == false);\r\n        require(Proposals[vote_id].voting_cut <= _weight);\r\n\r\n        Proposals[vote_id].votedOf[_voter] = true;\r\n        Proposals[vote_id].voting_count += 1;\r\n        Proposals[vote_id].voteWeightOf[_voter] = _weight;\r\n        Proposals[vote_id].total_weight += _weight;\r\n        Proposals[vote_id].voter_address[Proposals[vote_id].voter_address.length++] = _voter;\r\n\r\n        if (Proposals[vote_id].total_weight >= Proposals[vote_id].threshold) {\r\n            Proposals[vote_id].executed = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function voteClose() onlyOwner public {\r\n        if (Proposals.length >= 1) {\r\n            Proposals[vote_id].executed = true;\r\n            ProposalEnd(vote_id, Proposals[vote_id].descript);\r\n        }\r\n    }\r\n\r\n    function checkVote() onlyOwner public {\r\n        if ((Proposals.length >= 1) &&\r\n            (Proposals[vote_id].end_timestamp < now)) {\r\n            voteClose();\r\n        }\r\n    }\r\n}\r\n\r\ncontract FreezeToken is owned {\r\n    mapping (address => uint256) public freezeDateOf;\r\n\r\n    event Freeze(address indexed _who, uint256 _date);\r\n    event Melt(address indexed _who);\r\n\r\n    function checkFreeze(address _sender) public constant returns (bool) {\r\n        if (now >= freezeDateOf[_sender]) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function freezeTo(address _who, uint256 _date) internal {\r\n        freezeDateOf[_who] = _date;\r\n        Freeze(_who, _date);\r\n    }\r\n\r\n    function meltNow(address _who) internal onlyOwner {\r\n        freezeDateOf[_who] = now;\r\n        Melt(_who);\r\n    }\r\n}\r\n\r\ncontract TokenInfo is owned {\r\n    using SafeMath for uint256;\r\n\r\n    address public token_wallet_address;\r\n\r\n    string public name = \"K_Currency\";\r\n    string public symbol = \"KCR\";\r\n    uint256 public decimals = 18;\r\n    uint256 public total_supply = 100000000 * (10 ** uint256(decimals));\r\n\r\n    // 1 ether : 10,000 token\r\n    uint256 public conversion_rate = 10;\r\n\r\n    event ChangeTokenName(address indexed who);\r\n    event ChangeTokenSymbol(address indexed who);\r\n    event ChangeTokenWalletAddress(address indexed from, address indexed to);\r\n    event ChangeTotalSupply(uint256 indexed from, uint256 indexed to);\r\n    event ChangeConversionRate(uint256 indexed from, uint256 indexed to);\r\n    event ChangeFreezeTime(uint256 indexed from, uint256 indexed to);\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n        return total_supply;\r\n    }\r\n\r\n    function changeTokenName(string newName) onlyOwner public {\r\n        name = newName;\r\n        ChangeTokenName(msg.sender);\r\n    }\r\n\r\n    function changeTokenSymbol(string newSymbol) onlyOwner public {\r\n        symbol = newSymbol;\r\n        ChangeTokenSymbol(msg.sender);\r\n    }\r\n\r\n    function changeTokenWallet(address newTokenWallet) onlyOwner internal {\r\n        require(newTokenWallet != address(0));\r\n        address pre_address = token_wallet_address;\r\n        token_wallet_address = newTokenWallet;\r\n        ChangeTokenWalletAddress(pre_address, token_wallet_address);\r\n    }\r\n\r\n    function changeTotalSupply(uint256 _total_supply) onlyOwner internal {\r\n        require(_total_supply > 0);\r\n        uint256 pre_total_supply = total_supply;\r\n        total_supply = _total_supply;\r\n        ChangeTotalSupply(pre_total_supply, total_supply);\r\n    }\r\n\r\n    function changeConversionRate(uint256 _conversion_rate) onlyOwner public {\r\n        require(_conversion_rate > 0);\r\n        uint256 pre_conversion_rate = conversion_rate;\r\n        conversion_rate = _conversion_rate;\r\n        ChangeConversionRate(pre_conversion_rate, conversion_rate);\r\n    }\r\n}\r\n\r\ncontract Token is owned, PreSale, FreezeToken, TokenInfo, Vote, BasicToken {\r\n    using SafeMath for uint256;\r\n\r\n    bool public open_free = false;\r\n\r\n    event Payable(address indexed who, uint256 eth_amount);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    event Mint(address indexed to, uint256 value);\r\n\r\n    function Token (address _owner_address, address _token_wallet_address) public {\r\n        require(_token_wallet_address != address(0));\r\n\r\n        if (_owner_address != address(0)) {\r\n            owner = _owner_address;\r\n            balance_of[owner] = 0;\r\n        } else {\r\n            owner = msg.sender;\r\n            balance_of[owner] = 0;\r\n        }\r\n\r\n        token_wallet_address = _token_wallet_address;\r\n        balance_of[token_wallet_address] = total_supply;\r\n    }\r\n\r\n    function mintToken(\r\n        address to,\r\n        uint256 token_amount,\r\n        uint256 freeze_timestamp\r\n    ) onlyOwner public returns (bool) {\r\n        require(token_amount > 0);\r\n        require(balance_of[token_wallet_address] >= token_amount);\r\n        require(balance_of[to] + token_amount > balance_of[to]);\r\n        uint256 token_plus_bonus = 0;\r\n        uint sale_number = 0;\r\n\r\n        var(sale_info, isSale) = nowSaleInfo();\r\n        if (isSale) {\r\n            sale_number = sale_info.sale_number;\r\n            uint8 bonus_rate = sale_info.bonus_rate;\r\n            token_plus_bonus = addBonus(token_amount, bonus_rate);\r\n            require(checkSaleCanSell(sale_number, token_plus_bonus) == true);\r\n            addSaleSold(sale_number, token_plus_bonus);\r\n        } else if (open_free) {\r\n            token_plus_bonus = token_amount;\r\n        } else {\r\n            require(open_free == true);\r\n        }\r\n\r\n        balance_of[token_wallet_address] -= token_plus_bonus;\r\n        balance_of[to] += token_plus_bonus;\r\n\r\n        uint256 _freeze = 0;\r\n        if (freeze_timestamp >= 0) {\r\n            _freeze = freeze_timestamp;\r\n        }\r\n\r\n        freezeTo(to, now + _freeze); // FreezeToken.sol\r\n        Transfer(0x0, to, token_plus_bonus);\r\n        addAddress(to);\r\n        return true;\r\n    }\r\n\r\n    function mintTokenBulk(address[] _tos, uint256[] _amounts) onlyOwner public {\r\n        require(_tos.length == _amounts.length);\r\n        for (uint i=0; i < _tos.length; i++) {\r\n            mintToken(_tos[i], _amounts[i], 0);\r\n        }\r\n    }\r\n\r\n    function superMint(\r\n        address to,\r\n        uint256 token_amount,\r\n        uint256 freeze_timestamp\r\n    ) onlyOwner public returns(bool) {\r\n        require(token_amount > 0);\r\n        require(balance_of[token_wallet_address] >= token_amount);\r\n        require(balance_of[to] + token_amount > balance_of[to]);\r\n\r\n        balance_of[token_wallet_address] -= token_amount;\r\n        balance_of[to] += token_amount;\r\n\r\n        uint256 _freeze = 0;\r\n        if (freeze_timestamp >= 0) {\r\n            _freeze = freeze_timestamp;\r\n        }\r\n\r\n        freezeTo(to, now + _freeze);\r\n        Transfer(0x0, to, token_amount);\r\n        Mint(to, token_amount);\r\n        addAddress(to);\r\n        return true;\r\n    }\r\n\r\n    function superMintBulk(address[] _tos, uint256[] _amounts) onlyOwner public {\r\n        require(_tos.length == _amounts.length);\r\n        for (uint i=0; i < _tos.length; i++) {\r\n            superMint(_tos[i], _amounts[i], 0);\r\n        }\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public {\r\n        _transfer(msg.sender, to, value);\r\n    }\r\n\r\n    function transferBulk(address[] tos, uint256[] values) public {\r\n        require(tos.length == values.length);\r\n        for (uint i=0; i < tos.length; i++) {\r\n            transfer(tos[i], values[i]);\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public {\r\n        require(msg.sender != address(0));\r\n        require(_from != address(0));\r\n        require(_amount <= allowances[_from][msg.sender]);\r\n        _transfer(_from, _to, _amount);\r\n        allowances[_from][msg.sender] -= _amount;\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) private {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(balance_of[_from] >= _amount);\r\n        require(balance_of[_to].add(_amount) >= balance_of[_to]);\r\n        require(transfer_close == false);\r\n        require(checkFreeze(_from) == false);\r\n\r\n        uint256 prevBalance = balance_of[_from] + balance_of[_to];\r\n        balance_of[_from] -= _amount;\r\n        balance_of[_to] += _amount;\r\n        assert(balance_of[_from] + balance_of[_to] == prevBalance);\r\n        addAddress(_to);\r\n        Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function burn(address _who, uint256 _amount) onlyOwner public returns(bool) {\r\n        require(_amount > 0);\r\n        require(balanceOf(_who) >= _amount);\r\n        balance_of[_who] -= _amount;\r\n        total_supply -= _amount;\r\n        Burn(_who, _amount);\r\n        return true;\r\n    }\r\n\r\n    function additionalTotalSupply(uint256 _addition) onlyOwner public returns(bool) {\r\n        require(_addition > 0);\r\n        uint256 change_total_supply = total_supply.add(_addition);\r\n        balance_of[token_wallet_address] += _addition;\r\n        changeTotalSupply(change_total_supply);\r\n    }\r\n\r\n    function tokenWalletChange(address newTokenWallet) onlyOwner public returns(bool) {\r\n        require(newTokenWallet != address(0));\r\n        uint256 token_wallet_amount = balance_of[token_wallet_address];\r\n        balance_of[newTokenWallet] = token_wallet_amount;\r\n        balance_of[token_wallet_address] = 0;\r\n        changeTokenWallet(newTokenWallet);\r\n    }\r\n\r\n    function () payable public {\r\n        uint256 eth_amount = msg.value;\r\n        msg.sender.transfer(eth_amount);\r\n        Payable(msg.sender, eth_amount);\r\n    }\r\n\r\n    function tokenOpen() onlyOwner public {\r\n        open_free = true;\r\n    }\r\n\r\n    function tokenClose() onlyOwner public {\r\n        open_free = false;\r\n    }\r\n\r\n    function freezeAddress(\r\n        address _who,\r\n        uint256 _addTimestamp\r\n    ) onlyOwner public returns(bool) {\r\n        freezeTo(_who, _addTimestamp);\r\n        return true;\r\n    }\r\n\r\n    function meltAddress(\r\n        address _who\r\n    ) onlyOwner public returns(bool) {\r\n        meltNow(_who);\r\n        return true;\r\n    }\r\n\r\n    // call a voting in Vote.sol\r\n    function voteAgree() public returns (bool) {\r\n        address _voter = msg.sender;\r\n        uint256 _balance = balanceOf(_voter);\r\n        require(_balance > 0);\r\n        return voting(_voter, _balance);\r\n    }\r\n\r\n    function superVoteAgree(address who) onlyOwner public returns(bool) {\r\n        require(who != address(0));\r\n        uint256 _balance = balanceOf(who);\r\n        require(_balance > 0);\r\n        return voting(who, _balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"meltAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"superVoteAgree\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"voteAgree\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hoarder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"superApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"open_free\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"freeze_timestamp\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"bonus_rate\",\"type\":\"uint8\"}],\"name\":\"changeSaleBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposal_index\",\"type\":\"uint256\"}],\"name\":\"getProposalVoterList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"freeze_timestamp\",\"type\":\"uint256\"}],\"name\":\"superMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposal_index\",\"type\":\"uint256\"}],\"name\":\"getProposalIndex\",\"outputs\":[{\"name\":\"generator\",\"type\":\"address\"},{\"name\":\"descript\",\"type\":\"string\"},{\"name\":\"start_timestamp\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"voting_count\",\"type\":\"uint256\"},{\"name\":\"total_weight\",\"type\":\"uint256\"},{\"name\":\"voting_cut\",\"type\":\"uint256\"},{\"name\":\"threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"sell_token_limit\",\"type\":\"uint256\"}],\"name\":\"changeSaleTokenLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSaleSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tos\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintTokenBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address_index\",\"type\":\"uint256\"}],\"name\":\"getAddressIndex\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSaleInfo\",\"outputs\":[{\"name\":\"sale_number\",\"type\":\"uint256\"},{\"name\":\"start_timestamp\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"},{\"name\":\"bonus_rate\",\"type\":\"uint8\"},{\"name\":\"sell_limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenWallet\",\"type\":\"address\"}],\"name\":\"tokenWalletChange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"checkFreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"}],\"name\":\"changeSaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"descript\",\"type\":\"string\"},{\"name\":\"start_timestamp\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"},{\"name\":\"voting_cut\",\"type\":\"uint256\"},{\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"newVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"start_timestamp\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"},{\"name\":\"bonus_rate\",\"type\":\"uint8\"},{\"name\":\"sell_token_limit\",\"type\":\"uint256\"}],\"name\":\"changeSaleInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tos\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"transferBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_wallet_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getAddressExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canSaleInfo\",\"outputs\":[{\"name\":\"sale_number\",\"type\":\"uint256\"},{\"name\":\"start_timestamp\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"},{\"name\":\"bonus_rate\",\"type\":\"uint8\"},{\"name\":\"sell_limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeTokenName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfer_close\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start_timestamp\",\"type\":\"uint256\"},{\"name\":\"end_timestamp\",\"type\":\"uint256\"},{\"name\":\"bonus_rate\",\"type\":\"uint8\"},{\"name\":\"sell_token_limit\",\"type\":\"uint256\"}],\"name\":\"newSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_addTimestamp\",\"type\":\"uint256\"}],\"name\":\"freezeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"voteClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"changeTokenSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeDateOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversion_rate\",\"type\":\"uint256\"}],\"name\":\"changeConversionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"start_timestamp\",\"type\":\"uint256\"}],\"name\":\"changeSaleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversion_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hoarder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addition\",\"type\":\"uint256\"}],\"name\":\"additionalTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tos\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"superMintBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner_address\",\"type\":\"address\"},{\"name\":\"_token_wallet_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth_amount\",\"type\":\"uint256\"}],\"name\":\"Payable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"vote_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"generator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"descript\",\"type\":\"string\"}],\"name\":\"ProposalAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"vote_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"descript\",\"type\":\"string\"}],\"name\":\"ProposalEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ChangeTokenName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ChangeTokenSymbol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ChangeTokenWalletAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ChangeTotalSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ChangeConversionRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ChangeFreezeTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"Melt\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000004eddec6dd148a8313eb27010510d173417c3ce900000000000000000000000004eddec6dd148a8313eb27010510d173417c3ce9","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://23b568a8fbc203974dcb4475f9e457b9d1218e92712f80a3165a55d4c3149ea9"}]}