{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.2;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool wasInitializing = initializing;\n    initializing = true;\n    initialized = true;\n\n    _;\n\n    initializing = wasInitializing;\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n/**\n * @title Adminable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Adminable is Initializable {\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\n   * validated in the constructor.\n   */\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, fails.\n   */\n  modifier ifAdmin() {\n    require(msg.sender == _admin());\n    _;\n  }\n\n  function admin() external view returns (address) {\n    return _admin();\n  }\n\n    /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\ncontract Bridge is Adminable {\n  using SafeMath for uint256;\n\n  modifier onlyOperator() {\n    require(msg.sender == operator, \"Tried to call a only-operator function from non-operator\");\n    _;\n  }\n\n  event NewHeight(uint256 height, bytes32 indexed root);\n  event NewOperator(address operator);\n\n  struct Period {\n    uint32 height;            // the height of last block in period\n    uint32 timestamp;         // the block.timestamp at submission of period\n    uint32 parentBlockNumber; // the block.number at submission of period\n    bytes32 parentBlockHash;  // the blockhash(block.number -1) at submission of period\n  }\n\n  bytes32 constant GENESIS = 0x4920616d207665727920616e6772792c20627574206974207761732066756e21;\n\n  bytes32 public tipHash; // hash of first period that has extended chain to some height\n  uint256 public genesisBlockNumber;\n  uint256 parentBlockInterval; // how often epochs can be submitted max\n  uint256 public lastParentBlock; // last ethereum block when epoch was submitted\n  address public operator; // the operator contract\n\n  mapping(bytes32 => Period) public periods;\n\n  function initialize(uint256 _parentBlockInterval) public initializer {\n    // init genesis preiod\n    Period memory genesisPeriod = Period({\n      height: 1,\n      timestamp: uint32(block.timestamp),\n      parentBlockNumber: uint32(block.number),\n      parentBlockHash: blockhash(block.number-1)\n    });\n    tipHash = GENESIS;\n    periods[GENESIS] = genesisPeriod;\n    genesisBlockNumber = block.number;\n    parentBlockInterval = _parentBlockInterval;\n    operator = msg.sender;\n  }\n\n  function setOperator(address _operator) public ifAdmin {\n    operator = _operator;\n    emit NewOperator(_operator);\n  }\n\n  function getParentBlockInterval() public view returns (uint256) {\n    return parentBlockInterval;\n  }\n\n  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {\n    parentBlockInterval = _parentBlockInterval;\n  }\n\n  function submitPeriod(\n    bytes32 _prevHash,\n    bytes32 _root)\n  public onlyOperator returns (uint256 newHeight) {\n\n    require(periods[_prevHash].timestamp > 0, \"Parent node should exist\");\n    require(periods[_root].timestamp == 0, \"Trying to submit the same root twice\");\n\n    // calculate height\n    newHeight = periods[_prevHash].height + 1;\n    // do some magic if chain extended\n    if (newHeight > periods[tipHash].height) {\n      // new periods can only be submitted every x Ethereum blocks\n      require(\n        block.number >= lastParentBlock + parentBlockInterval,\n        \"Tried to submit new period too soon\"\n      );\n      tipHash = _root;\n      lastParentBlock = block.number;\n    }\n    // strictly speaking this event should be called \"New Period\"\n    // but we don't want to break interfaces for now.\n    emit NewHeight(newHeight, _root);\n    // store the period\n    Period memory newPeriod = Period({\n      height: uint32(newHeight),\n      timestamp: uint32(block.timestamp),\n      parentBlockNumber: uint32(block.number),\n      parentBlockHash: blockhash(block.number-1)\n    });\n    periods[_root] = newPeriod;\n  }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"genesisBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastParentBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prevHash\",\"type\":\"bytes32\"},{\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"submitPeriod\",\"outputs\":[{\"name\":\"newHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentBlockInterval\",\"type\":\"uint256\"}],\"name\":\"setParentBlockInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParentBlockInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"periods\",\"outputs\":[{\"name\":\"height\",\"type\":\"uint32\"},{\"name\":\"timestamp\",\"type\":\"uint32\"},{\"name\":\"parentBlockNumber\",\"type\":\"uint32\"},{\"name\":\"parentBlockHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tipHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentBlockInterval\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"height\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"NewHeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"NewOperator\",\"type\":\"event\"}]","ContractName":"Bridge","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://53c5806ea3d2e3b7bb63649b04800ee0697d697c76d2a656191a703870721e63"}]}