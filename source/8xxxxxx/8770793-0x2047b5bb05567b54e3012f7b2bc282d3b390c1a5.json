{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/*\r\nETICA: a type1 civilization neutral protocol for medical research\r\nKEVIN WAD OSSENI\r\n*/\r\n\r\n/*\r\nMIT License\r\nCopyright © 26/08/2019, KEVIN WAD OSSENI\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nThe Software is provided “as is”, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the Software.\r\n*/\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\n// Safe maths\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        c = a + b;\r\n\r\n        require(c >= a);\r\n\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        require(b <= a);\r\n\r\n        c = a - b;\r\n\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        c = a * b;\r\n\r\n        require(a == 0 || c / a == b);\r\n\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        require(b > 0);\r\n\r\n        c = a / b;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nlibrary ExtendedMath {\r\n\r\n\r\n    //return the smaller of the two inputs (a or b)\r\n    function limitLessThan(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        if(a > b) return b;\r\n\r\n        return a;\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n\r\n\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n\r\ncontract EticaToken is ERC20Interface{\r\n\r\n    using SafeMath for uint;\r\n    using ExtendedMath for uint;\r\n\r\n    string public name = \"Etica\";\r\n    string public symbol = \"ETI\";\r\n    uint public decimals = 18;\r\n\r\n    uint public supply;\r\n    uint public inflationrate; // fixed inflation rate of phase2 (after Etica supply has reached 21 Million ETI)\r\n    uint public  periodrewardtemp; // Amount of ETI issued per period during phase1 (before Etica supply has reached 21 Million ETI)\r\n\r\n    uint public PERIOD_CURATION_REWARD_RATIO = 38196601125; // 38.196601125% of period reward will be used as curation reward\r\n    uint public PERIOD_EDITOR_REWARD_RATIO = 61803398875; // 61.803398875% of period reward will be used as editor reward\r\n\r\n    uint public UNRECOVERABLE_ETI;\r\n\r\n    // Etica is a neutral protocol, it has no founder I am only an initiator:\r\n    string public constant initiatormsg = \"Discovering our best Futures. All proposals are made under the Creative Commons license 4.0. Kevin Wad\";\r\n\r\n    mapping(address => uint) public balances;\r\n\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n   \r\n\r\n    // ----------- Mining system state variables ------------ //\r\n    uint public _totalMiningSupply;\r\n\r\n\r\n\r\n     uint public latestDifficultyPeriodStarted;\r\n\r\n\r\n\r\n    uint public epochCount; //number of 'blocks' mined\r\n\r\n\r\n    uint public _BLOCKS_PER_READJUSTMENT = 2016;\r\n\r\n\r\n    //a little number\r\n    uint public  _MINIMUM_TARGET = 2**16;\r\n\r\n\r\n    //a big number is easier ; just find a solution that is smaller\r\n    //uint public  _MAXIMUM_TARGET = 2**224;  bitcoin uses 224\r\n    //uint public  _MAXIMUM_TARGET = 2**242; // used for tests 243 much faster, 242 seems to be the limit where mining gets much harder\r\n    uint public  _MAXIMUM_TARGET = 2**220; // used for prod\r\n\r\n\r\n    uint public miningTarget;\r\n\r\n    bytes32 public challengeNumber;   //generate a new one when a new reward is minted\r\n\r\n\r\n    uint public blockreward;\r\n\r\n\r\n    address public lastRewardTo;\r\n    uint public lastRewardEthBlockNumber;\r\n\r\n\r\n    mapping(bytes32 => bytes32) solutionForChallenge;\r\n\r\n    uint public tokensMinted;\r\n\r\n    bytes32 RANDOMHASH;\r\n\r\n    // ----------- Mining system state variables ------------ //\r\n\r\n\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Mint(address indexed from, uint blockreward, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n\r\n    constructor() public{\r\n      supply = 100 * (10**18); // initial supply equals 100 ETI\r\n      balances[address(this)] = balances[address(this)].add(100 * (10**18)); // 100 ETI as the default contract balance.\r\n\r\n\r\n    // ------------ PHASE 1 (before 21 Million ETI has been reached) -------------- //\r\n      \r\n      /* Phase 1 will last about 10 years:\r\n      --> 11 550 000 ETI to be distributed through MINING as block reward\r\n      --> 9 450 000 ETI to be issued during phase 1 as periodrewardtemp for ETICA reward system\r\n      \r\n\r\n      Phase1 is divided between 10 eras:\r\n      Each Era will allocate 2 100 000 ETI between mining reward and the staking system reward.\r\n      Each era is supposed to last about a year but can vary depending on hashrate.\r\n      Era1: 90% ETI to mining and 10% ETI to Staking  |  Era2: 80% ETI to mining and 20% ETI to Staking\r\n      Era3: 70% ETI to mining and 30% ETI to Staking  |  Era4: 60% ETI to mining and 40% ETI to Staking\r\n      Era5: 50% ETI to mining and 50% ETI to Staking  |  Era6: 50% ETI to mining and 50% ETI to Staking\r\n      Era7: 50% ETI to mining and 50% ETI to Staking  |  Era8: 50% ETI to mining and 50% ETI to Staking\r\n      Era9: 50% ETI to mining and 50% ETI to Staking  |  Era10: 50% ETI to mining and 50% ETI to Staking\r\n      Era1: 1 890 000 ETI as mining reward and 210 000 ETI as Staking reward\r\n      Era2: 1 680 000 ETI as mining reward and 420 000 ETI as Staking reward\r\n      Era3: 1 470 000 ETI as mining reward and 630 000 ETI as Staking reward \r\n      Era4: 1 260 000 ETI as mining reward and 840 000 ETI as Staking reward\r\n      From Era5 to era10: 1 050 000 ETI as mining reward and 1 050 000 ETI as Staking reward\r\n      */\r\n\r\n      // --- STAKING REWARD --- //\r\n       // periodrewardtemp: It is the temporary ETI issued per period (7 days) as reward of Etica System during phase 1. (Will be replaced by dynamic inflation of golden number at phase 2)\r\n         // Calculation of initial periodrewardtemp:\r\n         // 210 000 / 52.1429 = 4027.3939500871643119; ETI per week\r\n      periodrewardtemp = 4027393950087164311900; // 4027.393950087164311900 ETI per period (7 days) for era1\r\n      // --- STAKING REWARD --- //\r\n\r\n      // --- MINING REWARD --- //\r\n      _totalMiningSupply = 11550000 * 10**uint(decimals);\r\n\r\n\r\n      tokensMinted = 0;\r\n\r\n      // Calculation of initial blockreward:\r\n      // 1 890 000 / 52.1429 = 36246.5455507844788073; ETI per week\r\n      // amounts to 5178.0779358263541153286 ETI per day;\r\n      // amounts to 215.7532473260980881386917 ETI per hour;\r\n      // amounts to 35.9588745543496813564486167 ETI per block for era1 of phase1;\r\n      blockreward = 35958874554349681356;\r\n\r\n      miningTarget = _MAXIMUM_TARGET;\r\n\r\n      latestDifficultyPeriodStarted = block.timestamp;\r\n\r\n      _startNewMiningEpoch();\r\n      // --- MINING REWARD --- //\r\n\r\n    // ------------ PHASE 1 (before 21 Million ETI has been reached) -------------- //\r\n      \r\n\r\n    // ------------ PHASE 2 (after the first 21 Million ETI have been issued) -------------- //\r\n\r\n      // Golden number power 2: 1,6180339887498948482045868343656 * 1,6180339887498948482045868343656 = 2.6180339887498948482045868343656;\r\n      // Thus yearly inflation target is 2.6180339887498948482045868343656%\r\n      // inflationrate calculation:\r\n      // Each Period is 7 days, so we need to get a weekly inflationrate from the yearlyinflationrate target (1.026180339887498948482045868343656): \r\n      // 1.026180339887498948482045868343656 ^(1 / 52.1429) = 1,0004957512263080183722688891602;\r\n      // 1,0004957512263080183722688891602 - 1 = 0,0004957512263080183722688891602;\r\n      // Hence weekly inflationrate is 0,04957512263080183722688891602%\r\n      inflationrate = 4957512263080183722688891602;  // (need to multiple by 10^(-31) to get 0,0004957512263080183722688891602;\r\n\r\n    // ------------ PHASE 2 (after the first 21 Million ETI have been issued) -------------- //\r\n\r\n\r\n       //The creator gets nothing! The only way to earn Etica is to mine it or earn it as protocol reward\r\n       //balances[creator] = _totalMiningSupply;\r\n       //Transfer(address(0), creator, _totalMiningSupply);\r\n    }\r\n\r\n\r\n    function allowance(address tokenOwner, address spender) view public returns(uint){\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    //approve allowance\r\n    function approve(address spender, uint tokens) public returns(bool){\r\n        require(balances[msg.sender] >= tokens);\r\n        require(tokens > 0);\r\n\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    //transfer tokens from the  owner account to the account that calls the function\r\n    function transferFrom(address from, address to, uint tokens) public returns(bool){\r\n\r\n      balances[from] = balances[from].sub(tokens);\r\n\r\n      allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n\r\n      balances[to] = balances[to].add(tokens);\r\n\r\n      emit Transfer(from, to, tokens);\r\n\r\n      return true;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint){\r\n        return supply;\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance){\r\n         return balances[tokenOwner];\r\n     }\r\n\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success){\r\n         require(tokens > 0);\r\n\r\n         balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n\r\n         balances[to] = balances[to].add(tokens);\r\n\r\n         emit Transfer(msg.sender, to, tokens);\r\n\r\n         return true;\r\n     }\r\n\r\n\r\n     // -------------  Mining system functions ---------------- //\r\n\r\n         function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success) {\r\n\r\n\r\n             //the PoW must contain work that includes a recent ethereum block hash (challenge number) and the msg.sender's address to prevent MITM attacks\r\n             bytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n\r\n             //the challenge digest must match the expected\r\n             if (digest != challenge_digest) revert();\r\n\r\n             //the digest must be smaller than the target\r\n             if(uint256(digest) > miningTarget) revert();\r\n\r\n\r\n             //only allow one reward for each challenge\r\n              bytes32 solution = solutionForChallenge[challengeNumber];\r\n              solutionForChallenge[challengeNumber] = digest;\r\n              if(solution != 0x0) revert();  //prevent the same answer from awarding twice\r\n\r\n              if(tokensMinted > 1890000 * 10**uint(decimals)){\r\n \r\n              if(tokensMinted >= 6300000 * 10**uint(decimals)) {\r\n                // 6 300 000 = 5 040 000 + 1 260 000;\r\n                //era5 to era10\r\n                blockreward = 19977152530194267420; // 19.977152530194267420 per block (amounts to 1050000 ETI a year)\r\n                periodrewardtemp = 20136969750435821559600; // from era5 to era 10: 20136.9697504358215596 ETI per week\r\n              }\r\n\r\n              else if (tokensMinted < 3570000 * 10**uint(decimals)) {\r\n                // 3 570 000 = 1 890 000 + 1 680 000;\r\n                // era2\r\n                blockreward = 31963444048310827872; // 31.963444048310827872 ETI per block (amounts to 1680000 ETI a year)\r\n                periodrewardtemp = 8054787900174328623800; // era2 8054.787900174328623800 ETI per week\r\n              }\r\n              else if (tokensMinted < 5040000 * 10**uint(decimals)) {\r\n                // 5 040 000 = 3 570 000 + 1 470 000;\r\n                //era3\r\n                blockreward = 27968013542271974388; // 27.968013542271974388 ETI per block (amounts to 1470000 ETI a year)\r\n                periodrewardtemp = 12082181850261492935800; // era3 12082.181850261492935800 ETI per week\r\n              }\r\n              else {\r\n                // era4\r\n                blockreward = 23972583036233120904; // 23.972583036233120904 per block (amounts to 1260000 ETI a year)\r\n                periodrewardtemp = 16109575800348657247700; // era4 16109.575800348657247700 ETI per week\r\n              }\r\n\r\n              }\r\n\r\n             tokensMinted = tokensMinted.add(blockreward);\r\n             //Cannot mint more tokens than there are: maximum ETI ever mined: _totalMiningSupply\r\n             assert(tokensMinted < _totalMiningSupply);\r\n\r\n             supply = supply.add(blockreward);\r\n             balances[msg.sender] = balances[msg.sender].add(blockreward);\r\n\r\n\r\n             //set readonly diagnostics data\r\n             lastRewardTo = msg.sender;\r\n             lastRewardEthBlockNumber = block.number;\r\n\r\n\r\n              _startNewMiningEpoch();\r\n\r\n               emit Mint(msg.sender, blockreward, epochCount, challengeNumber );\r\n\r\n            return true;\r\n\r\n         }\r\n\r\n\r\n     //a new 'block' to be mined\r\n     function _startNewMiningEpoch() internal {\r\n\r\n\r\n       epochCount = epochCount.add(1);\r\n\r\n       //every so often, readjust difficulty. Dont readjust when deploying\r\n       if(epochCount % _BLOCKS_PER_READJUSTMENT == 0)\r\n       {\r\n         _reAdjustDifficulty();\r\n       }\r\n\r\n\r\n       //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks\r\n       //do this last since this is a protection mechanism in the mint() function\r\n       challengeNumber = blockhash(block.number.sub(1));\r\n       challengeNumber = keccak256(abi.encode(challengeNumber, RANDOMHASH)); // updates challengeNumber with merged mining protection\r\n\r\n     }\r\n\r\n\r\n\r\n\r\n     //https://en.bitcoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F\r\n     //as of 2017 the bitcoin difficulty was up to 17 zeroes, it was only 8 in the early days\r\n\r\n     //readjust the target by up to 50 percent\r\n     function _reAdjustDifficulty() internal {\r\n\r\n          // should get as close as possible to (2016 * 10 minutes) seconds => 1 209 600 seconds\r\n         uint ethTimeSinceLastDifficultyPeriod = block.timestamp.sub(latestDifficultyPeriodStarted);      \r\n\r\n         //we want miners to spend 10 minutes to mine each 'block'\r\n         uint targetTimePerDiffPeriod = _BLOCKS_PER_READJUSTMENT.mul(10 minutes); //Target is 1 209 600 seconds. (2016 * 10 minutes) seconds to mine _BLOCKS_PER_READJUSTMENT blocks of ETI.\r\n\r\n         //if there were less eth seconds-timestamp than expected\r\n         if( ethTimeSinceLastDifficultyPeriod < targetTimePerDiffPeriod )\r\n         {\r\n           uint excess_block_pct = (targetTimePerDiffPeriod.mul(100)).div( ethTimeSinceLastDifficultyPeriod );\r\n\r\n           uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);\r\n           // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\r\n\r\n           //make it harder\r\n           miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra));   //by up to 50 %\r\n         }else{\r\n           uint shortage_block_pct = (ethTimeSinceLastDifficultyPeriod.mul(100)).div( targetTimePerDiffPeriod );\r\n\r\n           uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000\r\n\r\n           //make it easier\r\n           miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra));   //by up to 50 %\r\n         }\r\n\r\n\r\n\r\n         latestDifficultyPeriodStarted = block.timestamp;\r\n\r\n         if(miningTarget < _MINIMUM_TARGET) //very difficult\r\n         {\r\n           miningTarget = _MINIMUM_TARGET;\r\n         }\r\n\r\n         if(miningTarget > _MAXIMUM_TARGET) //very easy\r\n         {\r\n           miningTarget = _MAXIMUM_TARGET;\r\n         }\r\n     }\r\n\r\n\r\n     //this is a recent ethereum block hash, used to prevent pre-mining future blocks\r\n     function getChallengeNumber() public view returns (bytes32) {\r\n         return challengeNumber;\r\n     }\r\n\r\n     //the number of zeroes the digest of the PoW solution requires.  Auto adjusts\r\n      function getMiningDifficulty() public view returns (uint) {\r\n         return _MAXIMUM_TARGET.div(miningTarget);\r\n     }\r\n\r\n     function getMiningTarget() public view returns (uint) {\r\n        return miningTarget;\r\n    }\r\n\r\n\r\n    //mining reward only if the protocol didnt reach the max ETI supply that can be ever mined: \r\n    function getMiningReward() public view returns (uint) {\r\n         if(tokensMinted <= _totalMiningSupply){\r\n          return blockreward;\r\n         }\r\n         else {\r\n          return 0;\r\n         }\r\n         \r\n    }\r\n\r\n     //help debug mining software\r\n     function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {\r\n\r\n         bytes32 digest = keccak256(abi.encodePacked(challenge_number,msg.sender,nonce));\r\n\r\n         return digest;\r\n\r\n       }\r\n\r\n         //help debug mining software\r\n       function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {\r\n\r\n           bytes32 digest = keccak256(abi.encodePacked(challenge_number,msg.sender,nonce));\r\n\r\n           if(uint256(digest) > testTarget) revert();\r\n\r\n           return (digest == challenge_digest);\r\n\r\n         }\r\n\r\n\r\n// ------------------      Mining system functions   -------------------------  //\r\n\r\n// ------------------------------------------------------------------------\r\n\r\n// Don't accept ETH\r\n\r\n// ------------------------------------------------------------------------\r\n\r\nfunction () payable external {\r\n\r\n    revert();\r\n\r\n}\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract EticaRelease is EticaToken {\r\n  /* --------- PROD VALUES -------------  */\r\nuint public REWARD_INTERVAL = 7 days; // periods duration 7 jours\r\nuint public STAKING_DURATION = 28 days; // default stake duration 28 jours\r\nuint public DEFAULT_VOTING_TIME = 21 days; // default voting duration 21 days\r\nuint public DEFAULT_REVEALING_TIME = 7 days; // default revealing duration 7 days\r\n    /* --------- PROD VALUES ------------- */\r\n\r\n/* --------- TESTING VALUES -------------\r\nuint public REWARD_INTERVAL = 1 minutes; // periods duration 7 jours\r\nuint public STAKING_DURATION = 4 minutes; // default stake duration 28 jours\r\nuint public DEFAULT_VOTING_TIME = 3 minutes; // default voting duration 21 days\r\nuint public DEFAULT_REVEALING_TIME = 1 minutes; // default revealing duration 7 days\r\n --------- TESTING VALUES -------------*/\r\n\r\nuint public DISEASE_CREATION_AMOUNT = 100 * 10**uint(decimals); // 100 ETI amount to pay for creating a new disease. Necessary in order to avoid spam. Will create a function that periodically increase it in order to take into account inflation\r\nuint public PROPOSAL_DEFAULT_VOTE = 10 * 10**uint(decimals); // 10 ETI amount to vote for creating a new proposal. Necessary in order to avoid spam. Will create a function that periodically increase it in order to take into account inflation\r\n\r\n\r\nuint public APPROVAL_THRESHOLD = 5000; // threshold for proposal to be accepted. 5000 means 50.00 %, 6000 would mean 60.00%\r\nuint public PERIODS_PER_THRESHOLD = 5; // number of Periods before readjusting APPROVAL_THRESHOLD\r\nuint public SEVERITY_LEVEL = 4; // level of severity of the protocol, the higher the more slash to wrong voters\r\nuint public PROPOSERS_INCREASER = 3; // the proposers should get more slashed than regular voters to avoid spam, the higher this var the more severe the protocol will be against bad proposers\r\nuint public PROTOCOL_RATIO_TARGET = 7250; // 7250 means the Protocol has a goal of 72.50% proposals approved and 27.5% proposals rejected\r\nuint public LAST_PERIOD_COST_UPDATE = 0;\r\n\r\n\r\nstruct Period{\r\n    uint id;\r\n    uint interval;\r\n    uint curation_sum; // used for proposals weight system\r\n    uint editor_sum; // used for proposals weight system\r\n    uint reward_for_curation; // total ETI issued to be used as Period reward for Curation\r\n    uint reward_for_editor; // total ETI issued to be used as Period reward for Editor\r\n    uint forprops; // number of accepted proposals in this period\r\n    uint againstprops; // number of rejected proposals in this period\r\n}\r\n\r\n  struct Stake{\r\n      uint amount;\r\n      uint endTime; // Time when the stake will be claimable\r\n  }\r\n\r\n// -----------  PROPOSALS STRUCTS  ------------  //\r\n\r\n// general information of Proposal:\r\n  struct Proposal{\r\n      uint id;\r\n      bytes32 proposed_release_hash; // Hash of \"raw_release_hash + name of Disease\"\r\n      bytes32 disease_id;\r\n      uint period_id;\r\n      uint chunk_id;\r\n      address proposer; // address of the proposer\r\n      string title; // Title of the Proposal\r\n      string description; // Description of the Proposal\r\n      string freefield;\r\n      string raw_release_hash;\r\n  }\r\n\r\n// main data of Proposal:\r\n  struct ProposalData{\r\n\r\n      uint starttime; // epoch time of the proposal\r\n      uint endtime;  // voting limite\r\n      uint finalized_time; // when first clmpropbyhash() was called\r\n      ProposalStatus status; // Only updates once, when the voting process is over\r\n      ProposalStatus prestatus; // Updates During voting process\r\n      bool istie;  // will be initialized with value 0. if prop is tie it won't slash nor reward participants\r\n      uint nbvoters;\r\n      uint slashingratio; // solidity does not support float type. So will emulate float type by using uint\r\n      uint forvotes;\r\n      uint againstvotes;\r\n      uint lastcuration_weight; // period curation weight of proposal\r\n      uint lasteditor_weight; // period editor weight of proposal\r\n  }\r\n\r\n  // -----------  PROPOSALS STRUCTS ------------  //\r\n\r\n    // -----------  CHUNKS STRUCTS ------------  //\r\n\r\n    struct Chunk{\r\n    uint id;\r\n    bytes32 diseaseid; // hash of the disease\r\n    uint idx;\r\n    string title;\r\n    string desc;\r\n  }\r\n\r\n  // -----------  CHUNKS STRUCTS ------------  //\r\n\r\n  // -----------  VOTES STRUCTS ----------------  //\r\n  struct Vote{\r\n    bytes32 proposal_hash; // proposed_release_hash of proposal\r\n    bool approve;\r\n    bool is_editor;\r\n    uint amount;\r\n    address voter; // address of the voter\r\n    uint timestamp; // epoch time of the vote\r\n    bool is_claimed; // keeps track of whether or not vote has been claimed to avoid double claim on same vote\r\n  }\r\n\r\n    struct Commit{\r\n    uint amount;\r\n    uint timestamp; // epoch time of the vote\r\n  }\r\n    // -----------  VOTES STRUCTS ----------------  //\r\n\r\n    // -----------  DISEASES STRUCTS ----------------  //\r\n\r\n  struct Disease{\r\n      bytes32 disease_hash;\r\n      string name;\r\n  }\r\n\r\n     // -----------  DISEASES STRUCTS ----------------  //\r\n\r\nenum ProposalStatus { Rejected, Accepted, Pending, Singlevoter }\r\n\r\nmapping(uint => Period) public periods;\r\nuint public periodsCounter;\r\nmapping(uint => uint) public PeriodsIssued; // keeps track of which periods have already issued ETI\r\nuint public PeriodsIssuedCounter;\r\nmapping(uint => uint) public IntervalsPeriods; // keeps track of which intervals have already a period\r\nuint public IntervalsPeriodsCounter;\r\n\r\nmapping(uint => Disease) public diseases; // keeps track of which intervals have already a period\r\nuint public diseasesCounter;\r\nmapping(bytes32 => uint) public diseasesbyIds; // get disease.index by giving its disease_hash: example: [leiojej757575ero] => [0]  where leiojej757575ero is disease_hash of a Disease\r\nmapping(string => bytes32) private diseasesbyNames; // get disease.disease_hash by giving its name: example: [\"name of a disease\"] => [leiojej757575ero]  where leiojej757575ero is disease_hash of a Disease. Set visibility to private because mapping with strings as keys have issues when public visibility\r\n\r\nmapping(bytes32 => mapping(uint => bytes32)) public diseaseproposals; // mapping of mapping of all proposals for a disease\r\nmapping(bytes32 => uint) public diseaseProposalsCounter; // keeps track of how many proposals for each disease\r\n\r\n// -----------  PROPOSALS MAPPINGS ------------  //\r\nmapping(bytes32 => Proposal) public proposals;\r\nmapping(uint => bytes32) public proposalsbyIndex; // get proposal.proposed_release_hash by giving its id (index): example: [2] => [huhihgfytoouhi]  where huhihgfytoouhi is proposed_release_hash of a Proposal\r\nuint public proposalsCounter;\r\n\r\nmapping(bytes32 => ProposalData) public propsdatas;\r\n// -----------  PROPOSALS MAPPINGS ------------  //\r\n\r\n// -----------  CHUNKS MAPPINGS ----------------  //\r\nmapping(uint => Chunk) public chunks;\r\nuint public chunksCounter;\r\nmapping(bytes32 => mapping(uint => uint)) public diseasechunks; // chunks of a disease\r\nmapping(uint => mapping(uint => bytes32)) public chunkproposals; // proposals of a chunk\r\nmapping(bytes32 => uint) public diseaseChunksCounter; // keeps track of how many chunks for each disease\r\nmapping(uint => uint) public chunkProposalsCounter; // keeps track of how many proposals for each chunk\r\n// -----------  CHUNKS MAPPINGS ----------------  //\r\n\r\n// -----------  VOTES MAPPINGS ----------------  //\r\nmapping(bytes32 => mapping(address => Vote)) public votes;\r\nmapping(address => mapping(bytes32 => Commit)) public commits;\r\n// -----------  VOTES MAPPINGS ----------------  //\r\n\r\nmapping(address => uint) public bosoms;\r\nmapping(address => mapping(uint => Stake)) public stakes;\r\nmapping(address => uint) public stakesCounters; // keeps track of how many stakes for each user\r\nmapping(address => uint) public stakesAmount; // keeps track of total amount of stakes for each user\r\n\r\n// Blocked ETI amount, user has votes with this amount in process and can't retrieve this amount before the system knows if the user has to be slahed\r\nmapping(address => uint) public blockedeticas;\r\n\r\n// ---------- EVENTS ----------- //\r\nevent CreatedPeriod(uint indexed period_id, uint interval);\r\nevent NewDisease(uint indexed diseaseindex, string title);\r\nevent NewProposal(bytes32 proposed_release_hash, address indexed _proposer, bytes32 indexed diseasehash, uint indexed chunkid);\r\nevent NewChunk(uint indexed chunkid, bytes32 indexed diseasehash);\r\nevent RewardClaimed(address indexed voter, uint amount, bytes32 proposal_hash);\r\nevent NewFee(address indexed voter, uint fee, bytes32 proposal_hash);\r\nevent NewSlash(address indexed voter, uint duration, bytes32 proposal_hash);\r\nevent NewCommit(address indexed _voter, bytes32 votehash);\r\nevent NewReveal(address indexed _voter, bytes32 indexed _proposal);\r\nevent NewStake(address indexed staker, uint amount);\r\nevent StakeClaimed(address indexed staker, uint stakeamount);\r\n// ----------- EVENTS ---------- //\r\n\r\n\r\n\r\n// -------------  PUBLISHING SYSTEM REWARD FUNCTIONS ---------------- //\r\n\r\nfunction issue(uint _id) internal returns (bool success) {\r\n  // we check whether there is at least one period\r\n  require(periodsCounter > 0);\r\n\r\n  // we check that the period exists\r\n  require(_id > 0 && _id <= periodsCounter);\r\n\r\n  // we retrieve the period\r\n  Period storage period = periods[_id];\r\n\r\n  // we check that the period is legit and has been retrieved\r\n  require(period.id != 0);\r\n\r\n\r\n//only allow one issuance for each period\r\nuint rwd = PeriodsIssued[period.id];\r\nif(rwd != 0x0) revert();  //prevent the same period from issuing twice\r\n\r\nuint _periodsupply;\r\n\r\n// Phase 2 (after 21 000 000 ETI has been reached)\r\nif(supply >= 21000000 * 10**(decimals)){\r\n_periodsupply = uint((supply.mul(inflationrate)).div(10**(31)));\r\n}\r\n// Phase 1 (before 21 000 000 ETI has been reached)\r\nelse {\r\n  _periodsupply = periodrewardtemp;\r\n}\r\n\r\n// update Period Reward:\r\nperiod.reward_for_curation = uint((_periodsupply.mul(PERIOD_CURATION_REWARD_RATIO)).div(10**(11)));\r\nperiod.reward_for_editor = uint((_periodsupply.mul(PERIOD_EDITOR_REWARD_RATIO)).div(10**(11)));\r\n\r\n\r\nsupply = supply.add(_periodsupply);\r\nbalances[address(this)] = balances[address(this)].add(_periodsupply);\r\nPeriodsIssued[period.id] = _periodsupply;\r\nPeriodsIssuedCounter = PeriodsIssuedCounter.add(1);\r\n\r\nreturn true;\r\n\r\n}\r\n\r\n\r\n// create a period\r\nfunction newPeriod() internal {\r\n\r\n  uint _interval = uint((block.timestamp).div(REWARD_INTERVAL));\r\n\r\n  //only allow one period for each interval\r\n  uint rwd = IntervalsPeriods[_interval];\r\n  if(rwd != 0x0) revert();  //prevent the same interval from having 2 periods\r\n\r\n\r\n  periodsCounter = periodsCounter.add(1);\r\n\r\n  // store this interval period\r\n  periods[periodsCounter] = Period(\r\n    periodsCounter,\r\n    _interval,\r\n    0x0, //_curation_sum\r\n    0x0, //_editor_sum\r\n    0x0, //_reward_for_curation\r\n    0x0, //_reward_for_editor\r\n    0x0, // _forprops\r\n    0x0 //_againstprops\r\n  );\r\n\r\n  // an interval cannot have 2 Periods\r\n  IntervalsPeriods[_interval] = periodsCounter;\r\n  IntervalsPeriodsCounter = IntervalsPeriodsCounter.add(1);\r\n\r\n  // issue ETI for this Period Reward\r\n  issue(periodsCounter);\r\n\r\n\r\n  //readjust APPROVAL_THRESHOLD every PERIODS_PER_THRESHOLD periods:\r\n  if((periodsCounter.sub(1)) % PERIODS_PER_THRESHOLD == 0 && periodsCounter > 1)\r\n  {\r\n    readjustThreshold();\r\n  }\r\n\r\n  emit CreatedPeriod(periodsCounter, _interval);\r\n}\r\n\r\nfunction readjustThreshold() internal {\r\n\r\nuint _meanapproval = 0;\r\nuint _totalfor = 0; // total of proposals accepetd\r\nuint _totalagainst = 0; // total of proposals rejected\r\n\r\n\r\n// calculate the mean approval rate (forprops / againstprops) of last PERIODS_PER_THRESHOLD Periods:\r\nfor(uint _periodidx = periodsCounter.sub(PERIODS_PER_THRESHOLD); _periodidx <= periodsCounter.sub(1);  _periodidx++){\r\n   _totalfor = _totalfor.add(periods[_periodidx].forprops);\r\n   _totalagainst = _totalagainst.add(periods[_periodidx].againstprops); \r\n}\r\n\r\n  if(_totalfor.add(_totalagainst) == 0){\r\n   _meanapproval = 5000;\r\n  }\r\n  else{\r\n   _meanapproval = uint(_totalfor.mul(10000).div(_totalfor.add(_totalagainst)));\r\n  }\r\n\r\n// increase or decrease APPROVAL_THRESHOLD based on comparason between _meanapproval and PROTOCOL_RATIO_TARGET:\r\n\r\n         // if there were not enough approvals:\r\n         if( _meanapproval < PROTOCOL_RATIO_TARGET )\r\n         {\r\n           uint shortage_approvals_rate = (PROTOCOL_RATIO_TARGET.sub(_meanapproval));\r\n\r\n           // require lower APPROVAL_THRESHOLD for next period:\r\n           APPROVAL_THRESHOLD = uint(APPROVAL_THRESHOLD.sub(((APPROVAL_THRESHOLD.sub(4500)).mul(shortage_approvals_rate)).div(10000)));   // decrease by up to 27.50 % of (APPROVAL_THRESHOLD - 45)\r\n         }else{\r\n           uint excess_approvals_rate = uint((_meanapproval.sub(PROTOCOL_RATIO_TARGET)));\r\n\r\n           // require higher APPROVAL_THRESHOLD for next period:\r\n           APPROVAL_THRESHOLD = uint(APPROVAL_THRESHOLD.add(((10000 - APPROVAL_THRESHOLD).mul(excess_approvals_rate)).div(10000)));   // increase by up to 27.50 % of (100 - APPROVAL_THRESHOLD)\r\n         }\r\n\r\n\r\n         if(APPROVAL_THRESHOLD < 4500) // high discouragement to vote against proposals\r\n         {\r\n           APPROVAL_THRESHOLD = 4500;\r\n         }\r\n\r\n         if(APPROVAL_THRESHOLD > 9900) // high discouragement to vote for proposals\r\n         {\r\n           APPROVAL_THRESHOLD = 9900;\r\n         }\r\n\r\n}\r\n\r\n// -------------  PUBLISHING SYSTEM REWARD FUNCTIONS ---------------- //\r\n\r\n\r\n// -------------------- STAKING ----------------------- //\r\n// eticatobosoms(): Stake etica in exchange for bosom\r\nfunction eticatobosoms(address _staker, uint _amount) public returns (bool success){\r\n  require(msg.sender == _staker);\r\n  require(_amount > 0); // even if transfer require amount > 0 I prefer checking for more security and very few more gas\r\n  // transfer _amount ETI from staker wallet to contract balance:\r\n  transfer(address(this), _amount);\r\n\r\n  // Get bosoms and add Stake\r\n  bosomget(_staker, _amount);\r\n\r\n\r\n  return true;\r\n\r\n}\r\n\r\n\r\n\r\n// ----  Get bosoms  ------  //\r\n\r\n//bosomget(): Get bosoms and add Stake. Only contract is able to call this function:\r\nfunction bosomget (address _staker, uint _amount) internal {\r\n\r\naddStake(_staker, _amount);\r\nbosoms[_staker] = bosoms[_staker].add(_amount);\r\n\r\n}\r\n\r\n// ----  Get bosoms  ------  //\r\n\r\n// ----  add Stake ------  //\r\n\r\nfunction addStake(address _staker, uint _amount) internal returns (bool success) {\r\n\r\n    require(_amount > 0);\r\n    stakesCounters[_staker] = stakesCounters[_staker].add(1); // notice that first stake will have the index of 1 thus not 0 !\r\n\r\n\r\n    // increase variable that keeps track of total value of user's stakes\r\n    stakesAmount[_staker] = stakesAmount[_staker].add(_amount);\r\n\r\n    uint endTime = block.timestamp.add(STAKING_DURATION);\r\n\r\n    // store this stake in _staker's stakes with the index stakesCounters[_staker]\r\n    stakes[_staker][stakesCounters[_staker]] = Stake(\r\n      _amount, // stake amount\r\n      endTime // endTime\r\n    );\r\n\r\n    emit NewStake(_staker, _amount);\r\n\r\n    return true;\r\n}\r\n\r\nfunction addConsolidation(address _staker, uint _amount, uint _endTime) internal returns (bool success) {\r\n\r\n    require(_amount > 0);\r\n    stakesCounters[_staker] = stakesCounters[_staker].add(1); // notice that first stake will have the index of 1 thus not 0 !\r\n\r\n\r\n    // increase variable that keeps track of total value of user's stakes\r\n    stakesAmount[_staker] = stakesAmount[_staker].add(_amount);\r\n\r\n    // store this stake in _staker's stakes with the index stakesCounters[_staker]\r\n    stakes[_staker][stakesCounters[_staker]] = Stake(\r\n      _amount, // stake amount\r\n      _endTime // endTime\r\n    );\r\n\r\n    emit NewStake(_staker, _amount);\r\n\r\n    return true;\r\n}\r\n\r\n// ----  add Stake ------  //\r\n\r\n// ----  split Stake ------  //\r\n\r\nfunction splitStake(address _staker, uint _amount, uint _endTime) internal returns (bool success) {\r\n\r\n    require(_amount > 0);\r\n    stakesCounters[_staker] = stakesCounters[_staker].add(1); // notice that first stake will have the index of 1 thus not 0 !\r\n\r\n    // store this stake in _staker's stakes with the index stakesCounters[_staker]\r\n    stakes[_staker][stakesCounters[_staker]] = Stake(\r\n      _amount, // stake amount\r\n      _endTime // endTime\r\n    );\r\n\r\n\r\n    return true;\r\n}\r\n\r\n// ----  split Stake ------  //\r\n\r\n\r\n// ----  Redeem a Stake ------  //\r\n//stakeclmidx(): redeem a stake by its index\r\nfunction stakeclmidx (uint _stakeidx) public {\r\n\r\n  // we check that the stake exists\r\n  require(_stakeidx > 0 && _stakeidx <= stakesCounters[msg.sender]);\r\n\r\n  // we retrieve the stake\r\n  Stake storage _stake = stakes[msg.sender][_stakeidx];\r\n\r\n  // The stake must be over\r\n  require(block.timestamp > _stake.endTime);\r\n\r\n  // the amount to be unstaked must be less or equal to the amount of ETI currently marked as blocked in blockedeticas as they need to go through the clmpropbyhash before being unstaked !\r\n  require(_stake.amount <= stakesAmount[msg.sender].sub(blockedeticas[msg.sender]));\r\n\r\n  // transfer back ETI from contract to staker:\r\n  balances[address(this)] = balances[address(this)].sub(_stake.amount);\r\n\r\n  balances[msg.sender] = balances[msg.sender].add(_stake.amount);\r\n\r\n  emit Transfer(address(this), msg.sender, _stake.amount);\r\n  emit StakeClaimed(msg.sender, _stake.amount);\r\n\r\n  // deletes the stake\r\n  _deletestake(msg.sender, _stakeidx);\r\n\r\n}\r\n\r\n// ----  Redeem a Stake ------  //\r\n\r\n// ----  Remove a Stake ------  //\r\n\r\nfunction _deletestake(address _staker,uint _index) internal {\r\n  // we check that the stake exists\r\n  require(_index > 0 && _index <= stakesCounters[_staker]);\r\n\r\n  // decrease variable that keeps track of total value of user's stakes\r\n  stakesAmount[_staker] = stakesAmount[_staker].sub(stakes[_staker][_index].amount);\r\n\r\n  // replace value of stake to be deleted by value of last stake\r\n  stakes[_staker][_index] = stakes[_staker][stakesCounters[_staker]];\r\n\r\n  // remove last stake\r\n  stakes[_staker][stakesCounters[_staker]] = Stake(\r\n    0x0, // amount\r\n    0x0 // endTime\r\n    );\r\n\r\n  // updates stakesCounter of _staker\r\n  stakesCounters[_staker] = stakesCounters[_staker].sub(1);\r\n\r\n}\r\n\r\n// ----  Remove a Stake ------  //\r\n\r\n\r\n// ----- Stakes consolidation  ----- //\r\n\r\n// slashing function needs to loop through stakes. Can create issues for claiming votes:\r\n// The function stakescsldt() has been created to consolidate (gather) stakes when user has too much stakes\r\nfunction stakescsldt(uint _endTime, uint _min_limit, uint _maxidx) public {\r\n\r\n// security to avoid blocking ETI by front end apps that could call function with too high _endTime:\r\nrequire(_endTime < block.timestamp.add(730 days)); // _endTime cannot be more than two years ahead  \r\n\r\n// _maxidx must be less or equal to nb of stakes and we set a limit for loop of 50:\r\nrequire(_maxidx <= 50 && _maxidx <= stakesCounters[msg.sender]);\r\n\r\nuint newAmount = 0;\r\n\r\nuint _nbdeletes = 0;\r\n\r\nuint _currentidx = 1;\r\n\r\nfor(uint _stakeidx = 1; _stakeidx <= _maxidx;  _stakeidx++) {\r\n    // only consolidates if account nb of stakes >= 2 :\r\n    if(stakesCounters[msg.sender] >= 2){\r\n\r\n    if(_stakeidx <= stakesCounters[msg.sender]){\r\n       _currentidx = _stakeidx;\r\n    } \r\n    else {\r\n      // if _stakeidx > stakesCounters[msg.sender] it means the _deletestake() function has pushed the next stakes at the begining:\r\n      _currentidx = _stakeidx.sub(_nbdeletes); //Notice: initial stakesCounters[msg.sender] = stakesCounters[msg.sender] + _nbdeletes. \r\n      //So \"_stackidx <= _maxidx <= initial stakesCounters[msg.sender]\" ===> \"_stakidx <= stakesCounters[msg.sender] + _nbdeletes\" ===> \"_stackidx - _nbdeletes <= stakesCounters[msg.sender]\"\r\n      assert(_currentidx >= 1); // makes sure _currentidx is within existing stakes range\r\n    }\r\n      \r\n      //if stake should end sooner than _endTime it can be consolidated into a stake that end latter:\r\n      // Plus we check the stake.endTime is above the minimum limit the user is willing to consolidate. For instance user doesn't want to consolidate a stake that is ending tomorrow\r\n      if(stakes[msg.sender][_currentidx].endTime <= _endTime && stakes[msg.sender][_currentidx].endTime >= _min_limit) {\r\n\r\n        newAmount = newAmount.add(stakes[msg.sender][_currentidx].amount);\r\n\r\n        _deletestake(msg.sender, _currentidx);    \r\n\r\n        _nbdeletes = _nbdeletes.add(1);\r\n\r\n      }  \r\n\r\n    }\r\n}\r\n\r\nif (newAmount > 0){\r\n// creates the new Stake\r\naddConsolidation(msg.sender, newAmount, _endTime);\r\n}\r\n\r\n}\r\n\r\n// ----- Stakes consolidation  ----- //\r\n\r\n// ----- Stakes de-consolidation  ----- //\r\n\r\n// this function is necessary because if user has a stake with huge amount and has blocked few ETI then he can't claim the Stake because\r\n// stake.amount > StakesAmount - blockedeticas\r\nfunction stakesnap(uint _stakeidx, uint _snapamount) public {\r\n\r\n  require(_snapamount > 0);\r\n  \r\n  // we check that the stake exists\r\n  require(_stakeidx > 0 && _stakeidx <= stakesCounters[msg.sender]);\r\n\r\n  // we retrieve the stake\r\n  Stake storage _stake = stakes[msg.sender][_stakeidx];\r\n\r\n\r\n  // the stake.amount must be higher than _snapamount:\r\n  require(_stake.amount > _snapamount);\r\n\r\n  // calculate the amount of new stake:\r\n  uint _restAmount = _stake.amount.sub(_snapamount);\r\n  \r\n  // updates the stake amount:\r\n  _stake.amount = _snapamount;\r\n\r\n\r\n  // ----- creates a new stake with the rest -------- //\r\n  stakesCounters[msg.sender] = stakesCounters[msg.sender].add(1);\r\n\r\n  // store this stake in _staker's stakes with the index stakesCounters[_staker]\r\n  stakes[msg.sender][stakesCounters[msg.sender]] = Stake(\r\n      _restAmount, // stake amount\r\n      _stake.endTime // endTime\r\n    );\r\n  // ------ creates a new stake with the rest ------- //  \r\n\r\nassert(_restAmount > 0);\r\n\r\n}\r\n\r\n// ----- Stakes de-consolidation  ----- //\r\n\r\n\r\nfunction stakescount(address _staker) public view returns (uint slength){\r\n  return stakesCounters[_staker];\r\n}\r\n\r\n// ----------------- STAKING ------------------ //\r\n\r\n\r\n// -------------  PUBLISHING SYSTEM CORE FUNCTIONS ---------------- //\r\nfunction createdisease(string memory _name) public {\r\n\r\n\r\n  // --- REQUIRE PAYMENT FOR ADDING A DISEASE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\r\n\r\n  // make sure the user has enough ETI to create a disease\r\n  require(balances[msg.sender] >= DISEASE_CREATION_AMOUNT);\r\n  // transfer DISEASE_CREATION_AMOUNT ETI from user wallet to contract wallet:\r\n  transfer(address(this), DISEASE_CREATION_AMOUNT);\r\n\r\n  UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(DISEASE_CREATION_AMOUNT);\r\n\r\n  // --- REQUIRE PAYMENT FOR ADDING A DISEASE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\r\n\r\n\r\n  bytes32 _diseasehash = keccak256(abi.encode(_name));\r\n\r\n  diseasesCounter = diseasesCounter.add(1); // notice that first disease will have the index of 1 thus not 0 !\r\n\r\n  //check: if the disease is new we continue, otherwise we exit\r\n   if(diseasesbyIds[_diseasehash] != 0x0) revert();  //prevent the same disease from being created twice. The software manages diseases uniqueness based on their unique english name. Note that even the first disease will not have index of 0 thus should pass this check\r\n   require(diseasesbyNames[_name] == 0); // make sure it is not overwriting another disease thanks to unexpected string tricks from user\r\n\r\n   // store the Disease\r\n   diseases[diseasesCounter] = Disease(\r\n     _diseasehash,\r\n     _name\r\n   );\r\n\r\n   // Updates diseasesbyIds and diseasesbyNames mappings:\r\n   diseasesbyIds[_diseasehash] = diseasesCounter;\r\n   diseasesbyNames[_name] = _diseasehash;\r\n\r\n   emit NewDisease(diseasesCounter, _name);\r\n\r\n}\r\n\r\n\r\n\r\nfunction propose(bytes32 _diseasehash, string memory _title, string memory _description, string memory raw_release_hash, string memory _freefield, uint _chunkid) public {\r\n\r\n    //check if the disease exits\r\n     require(diseasesbyIds[_diseasehash] > 0 && diseasesbyIds[_diseasehash] <= diseasesCounter);\r\n     if(diseases[diseasesbyIds[_diseasehash]].disease_hash != _diseasehash) revert(); // second check not necessary but I decided to add it as the gas cost value for security is worth it\r\n\r\n    require(_chunkid <= chunksCounter);\r\n\r\n     bytes32 _proposed_release_hash = keccak256(abi.encode(raw_release_hash, _diseasehash));\r\n     diseaseProposalsCounter[_diseasehash] = diseaseProposalsCounter[_diseasehash].add(1);\r\n     diseaseproposals[_diseasehash][diseaseProposalsCounter[_diseasehash]] = _proposed_release_hash;\r\n\r\n     proposalsCounter = proposalsCounter.add(1); // notice that first proposal will have the index of 1 thus not 0 !\r\n     proposalsbyIndex[proposalsCounter] = _proposed_release_hash;\r\n\r\n     // Check that proposal does not already exist\r\n     // only allow one proposal for each {raw_release_hash,  _diseasehash} combinasion\r\n      bytes32 existing_proposal = proposals[_proposed_release_hash].proposed_release_hash;\r\n      if(existing_proposal != 0x0 || proposals[_proposed_release_hash].id != 0) revert();  //prevent the same raw_release_hash from being submited twice on same proposal. Double check for better security and slightly higher gas cost even though one would be enough !\r\n\r\n     uint _current_interval = uint((block.timestamp).div(REWARD_INTERVAL));\r\n\r\n      // Create new Period if this current interval did not have its Period created yet\r\n      if(IntervalsPeriods[_current_interval] == 0x0){\r\n        newPeriod();\r\n      }\r\n\r\n     Proposal storage proposal = proposals[_proposed_release_hash];\r\n\r\n       proposal.id = proposalsCounter;\r\n       proposal.disease_id = _diseasehash; // _diseasehash has already been checked to equal diseases[diseasesbyIds[_diseasehash]].disease_hash\r\n       proposal.period_id = IntervalsPeriods[_current_interval];\r\n       proposal.proposed_release_hash = _proposed_release_hash; // Hash of \"raw_release_hash + name of Disease\",\r\n       proposal.proposer = msg.sender;\r\n       proposal.title = _title;\r\n       proposal.description = _description;\r\n       proposal.raw_release_hash = raw_release_hash;\r\n       proposal.freefield = _freefield;\r\n\r\n\r\n       //  Proposal Data:\r\n       ProposalData storage proposaldata = propsdatas[_proposed_release_hash];\r\n       proposaldata.status = ProposalStatus.Pending;\r\n       proposaldata.istie = true;\r\n       proposaldata.prestatus = ProposalStatus.Pending;\r\n       proposaldata.nbvoters = 0;\r\n       proposaldata.slashingratio = 0;\r\n       proposaldata.forvotes = 0;\r\n       proposaldata.againstvotes = 0;\r\n       proposaldata.lastcuration_weight = 0;\r\n       proposaldata.lasteditor_weight = 0;\r\n       proposaldata.starttime = block.timestamp;\r\n       proposaldata.endtime = block.timestamp.add(DEFAULT_VOTING_TIME);\r\n\r\n\r\n// --- REQUIRE DEFAULT VOTE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\r\n\r\n    require(bosoms[msg.sender] >= PROPOSAL_DEFAULT_VOTE); // this check is not mandatory as handled by safemath sub function: (bosoms[msg.sender].sub(PROPOSAL_DEFAULT_VOTE))\r\n\r\n    // Consume bosom:\r\n    bosoms[msg.sender] = bosoms[msg.sender].sub(PROPOSAL_DEFAULT_VOTE);\r\n\r\n\r\n    // Block Eticas in eticablkdtbl to prevent user from unstaking before eventual slash\r\n    blockedeticas[msg.sender] = blockedeticas[msg.sender].add(PROPOSAL_DEFAULT_VOTE);\r\n\r\n\r\n    // store vote:\r\n    Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\r\n    vote.proposal_hash = proposal.proposed_release_hash;\r\n    vote.approve = true;\r\n    vote.is_editor = true;\r\n    vote.amount = PROPOSAL_DEFAULT_VOTE;\r\n    vote.voter = msg.sender;\r\n    vote.timestamp = block.timestamp;\r\n\r\n\r\n\r\n      // UPDATE PROPOSAL:\r\n      proposaldata.prestatus = ProposalStatus.Singlevoter;\r\n\r\n      // if chunk exists and belongs to disease updates proposal.chunk_id:\r\n      uint existing_chunk = chunks[_chunkid].id;\r\n      if(existing_chunk != 0x0 && chunks[_chunkid].diseaseid == _diseasehash) {\r\n        proposal.chunk_id = _chunkid;\r\n        // updates chunk proposals infos:\r\n        chunkProposalsCounter[_chunkid] = chunkProposalsCounter[_chunkid].add(1);\r\n        chunkproposals[_chunkid][chunkProposalsCounter[_chunkid]] = proposal.proposed_release_hash;\r\n      }\r\n\r\n  // --- REQUIRE DEFAULT VOTE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\r\n\r\n  RANDOMHASH = keccak256(abi.encode(RANDOMHASH, _proposed_release_hash)); // updates RANDOMHASH\r\n\r\n    emit NewProposal(_proposed_release_hash, msg.sender, proposal.disease_id, _chunkid);\r\n\r\n}\r\n\r\n\r\n function updatecost() public {\r\n\r\n// only start to increase PROPOSAL AND DISEASE COSTS once we are in phase2\r\nrequire(supply >= 21000000 * 10**(decimals));\r\n// update disease and proposal cost each 52 periods to take into account inflation:\r\nrequire(periodsCounter % 52 == 0);\r\nuint _new_disease_cost = supply.mul(47619046).div(10**13); // disease cost is 0.00047619046% of supply\r\nuint _new_proposal_vote = supply.mul(47619046).div(10**14); // default vote amount is 0.000047619046% of supply\r\n\r\nPROPOSAL_DEFAULT_VOTE = _new_proposal_vote;\r\nDISEASE_CREATION_AMOUNT = _new_disease_cost;\r\n\r\nassert(LAST_PERIOD_COST_UPDATE < periodsCounter);\r\nLAST_PERIOD_COST_UPDATE = periodsCounter;\r\n\r\n }\r\n\r\n\r\n\r\n function commitvote(uint _amount, bytes32 _votehash) public {\r\n\r\nrequire(_amount > 10);\r\n\r\n // Consume bosom:\r\n require(bosoms[msg.sender] >= _amount); // this check is not mandatory as handled by safemath sub function\r\n bosoms[msg.sender] = bosoms[msg.sender].sub(_amount);\r\n\r\n // Block Eticas in eticablkdtbl to prevent user from unstaking before eventual slash\r\n blockedeticas[msg.sender] = blockedeticas[msg.sender].add(_amount);\r\n\r\n // store _votehash in commits with _amount and current block.timestamp value:\r\n commits[msg.sender][_votehash].amount = commits[msg.sender][_votehash].amount.add(_amount);\r\n commits[msg.sender][_votehash].timestamp = block.timestamp;\r\n\r\n RANDOMHASH = keccak256(abi.encode(RANDOMHASH, _votehash)); // updates RANDOMHASH\r\n\r\nemit NewCommit(msg.sender, _votehash);\r\n\r\n }\r\n\r\n\r\n function revealvote(bytes32 _proposed_release_hash, bool _approved, string memory _vary) public {\r\n \r\n\r\n// --- check commit --- //\r\nbytes32 _votehash;\r\n_votehash = keccak256(abi.encode(_proposed_release_hash, _approved, msg.sender, _vary));\r\n\r\nrequire(commits[msg.sender][_votehash].amount > 0);\r\n// --- check commit done --- //\r\n\r\n//check if the proposal exists and that we get the right proposal:\r\nProposal storage proposal = proposals[_proposed_release_hash];\r\nrequire(proposal.id > 0 && proposal.proposed_release_hash == _proposed_release_hash);\r\n\r\n\r\nProposalData storage proposaldata = propsdatas[_proposed_release_hash];\r\n\r\n // Verify commit was done within voting time:\r\n require( commits[msg.sender][_votehash].timestamp <= proposaldata.endtime);\r\n\r\n // Verify we are within revealing time:\r\n require( block.timestamp > proposaldata.endtime && block.timestamp <= proposaldata.endtime.add(DEFAULT_REVEALING_TIME));\r\n\r\n require(proposaldata.prestatus != ProposalStatus.Pending); // can vote for proposal only if default vote has changed prestatus of Proposal. Thus can vote only if default vote occured as supposed to\r\n\r\nuint _old_proposal_curationweight = proposaldata.lastcuration_weight;\r\nuint _old_proposal_editorweight = proposaldata.lasteditor_weight;\r\n\r\n\r\n// get Period of Proposal:\r\nPeriod storage period = periods[proposal.period_id];\r\n\r\n\r\n// Check that vote does not already exist\r\n// only allow one vote for each {raw_release_hash, voter} combinasion\r\nbytes32 existing_vote = votes[proposal.proposed_release_hash][msg.sender].proposal_hash;\r\nif(existing_vote != 0x0 || votes[proposal.proposed_release_hash][msg.sender].amount != 0) revert();  //prevent the same user from voting twice for same raw_release_hash. Double condition check for better security and slightly higher gas cost even though one would be enough !\r\n\r\n\r\n // store vote:\r\n Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\r\n vote.proposal_hash = proposal.proposed_release_hash;\r\n vote.approve = _approved;\r\n vote.is_editor = false;\r\n vote.amount = commits[msg.sender][_votehash].amount;\r\n vote.voter = msg.sender;\r\n vote.timestamp = block.timestamp;\r\n\r\n proposaldata.nbvoters = proposaldata.nbvoters.add(1);\r\n\r\n     // PROPOSAL VAR UPDATE\r\n     if(_approved){\r\n      proposaldata.forvotes = proposaldata.forvotes.add(commits[msg.sender][_votehash].amount);\r\n     }\r\n     else {\r\n       proposaldata.againstvotes = proposaldata.againstvotes.add(commits[msg.sender][_votehash].amount);\r\n     }\r\n\r\n\r\n     // Determine slashing conditions\r\n     bool _isapproved = false;\r\n     bool _istie = false;\r\n     uint totalVotes = proposaldata.forvotes.add(proposaldata.againstvotes);\r\n     uint _forvotes_numerator = proposaldata.forvotes.mul(10000); // (newproposal_forvotes / totalVotes) will give a number between 0 and 1. Multiply by 10000 to store it as uint\r\n     uint _ratio_slashing = 0;\r\n\r\n     if ((_forvotes_numerator.div(totalVotes)) > APPROVAL_THRESHOLD){\r\n    _isapproved = true;\r\n    }\r\n    if ((_forvotes_numerator.div(totalVotes)) == APPROVAL_THRESHOLD){\r\n        _istie = true;\r\n    }\r\n\r\n    proposaldata.istie = _istie;\r\n\r\n    if (_isapproved){\r\n    _ratio_slashing = uint(((10000 - APPROVAL_THRESHOLD).mul(totalVotes)).div(10000));\r\n    _ratio_slashing = uint((proposaldata.againstvotes.mul(10000)).div(_ratio_slashing));  \r\n    proposaldata.slashingratio = uint(10000 - _ratio_slashing);\r\n    }\r\n    else{\r\n    _ratio_slashing = uint((totalVotes.mul(APPROVAL_THRESHOLD)).div(10000));\r\n    _ratio_slashing = uint((proposaldata.forvotes.mul(10000)).div(_ratio_slashing));\r\n    proposaldata.slashingratio = uint(10000 - _ratio_slashing);\r\n    }\r\n\r\n    // Make sure the slashing reward ratio is within expected range:\r\n     require(proposaldata.slashingratio >=0 && proposaldata.slashingratio <= 10000);\r\n\r\n        // updates period forvotes and againstvotes system\r\n        ProposalStatus _newstatus = ProposalStatus.Rejected;\r\n        if(_isapproved){\r\n         _newstatus = ProposalStatus.Accepted;\r\n        }\r\n\r\n        if(proposaldata.prestatus == ProposalStatus.Singlevoter){\r\n\r\n          if(_isapproved){\r\n            period.forprops = period.forprops.add(1);\r\n          }\r\n          else {\r\n            period.againstprops = period.againstprops.add(1);\r\n          }\r\n        }\r\n        // in this case the proposal becomes rejected after being accepted or becomes accepted after being rejected:\r\n        else if(_newstatus != proposaldata.prestatus){\r\n\r\n         if(_newstatus == ProposalStatus.Accepted){\r\n          period.againstprops = period.againstprops.sub(1);\r\n          period.forprops = period.forprops.add(1);\r\n         }\r\n         // in this case proposal is necessarily Rejected:\r\n         else {\r\n          period.forprops = period.forprops.sub(1);\r\n          period.againstprops = period.againstprops.add(1);\r\n         }\r\n\r\n        }\r\n        // updates period forvotes and againstvotes system done\r\n\r\n         // Proposal and Period new weight\r\n         if (_istie) {\r\n         proposaldata.prestatus =  ProposalStatus.Rejected;\r\n         proposaldata.lastcuration_weight = 0;\r\n         proposaldata.lasteditor_weight = 0;\r\n         // Proposal tied, remove proposal curation and editor sum\r\n         period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight);\r\n         period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight);\r\n         }\r\n         else {\r\n             // Proposal approved, strengthen curation sum\r\n         if (_isapproved){\r\n             proposaldata.prestatus =  ProposalStatus.Accepted;\r\n             proposaldata.lastcuration_weight = proposaldata.forvotes;\r\n             proposaldata.lasteditor_weight = proposaldata.forvotes;\r\n             // Proposal approved, replace proposal curation and editor sum with forvotes\r\n             period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight).add(proposaldata.lastcuration_weight);\r\n             period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight).add(proposaldata.lasteditor_weight);\r\n         }\r\n         else{\r\n             proposaldata.prestatus =  ProposalStatus.Rejected;\r\n             proposaldata.lastcuration_weight = proposaldata.againstvotes;\r\n             proposaldata.lasteditor_weight = 0;\r\n             // Proposal rejected, replace proposal curation sum with againstvotes and remove proposal editor sum\r\n             period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight).add(proposaldata.lastcuration_weight);\r\n             period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight);\r\n         }\r\n         }\r\n         \r\n        // resets commit to save space: \r\n        _removecommit(_votehash);\r\n        emit NewReveal(msg.sender, proposal.proposed_release_hash);\r\n\r\n  }\r\n\r\n  function _removecommit(bytes32 _votehash) internal {\r\n        commits[msg.sender][_votehash].amount = 0;\r\n        commits[msg.sender][_votehash].timestamp = 0;\r\n  }\r\n\r\n\r\n  function clmpropbyhash(bytes32 _proposed_release_hash) public {\r\n\r\n   //check if the proposal exists and that we get the right proposal:\r\n   Proposal storage proposal = proposals[_proposed_release_hash];\r\n   require(proposal.id > 0 && proposal.proposed_release_hash == _proposed_release_hash);\r\n\r\n\r\n   ProposalData storage proposaldata = propsdatas[_proposed_release_hash];\r\n   // Verify voting and revealing period is over\r\n   require( block.timestamp > proposaldata.endtime.add(DEFAULT_REVEALING_TIME));\r\n\r\n   \r\n    // we check that the vote exists\r\n    Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\r\n    require(vote.proposal_hash == _proposed_release_hash);\r\n    \r\n    // make impossible to claim same vote twice\r\n    require(!vote.is_claimed);\r\n    vote.is_claimed = true;\r\n\r\n\r\n\r\n  \r\n    // De-Block Eticas from eticablkdtbl to enable user to unstake these Eticas\r\n    blockedeticas[msg.sender] = blockedeticas[msg.sender].sub(vote.amount);\r\n\r\n\r\n    // get Period of Proposal:\r\n    Period storage period = periods[proposal.period_id];\r\n\r\n   uint _current_interval = uint((block.timestamp).div(REWARD_INTERVAL));\r\n\r\n   // Check if Period is ready for claims or if it needs to wait more\r\n   uint _min_intervals = uint(((DEFAULT_VOTING_TIME.add(DEFAULT_REVEALING_TIME)).div(REWARD_INTERVAL)).add(1)); // Minimum intervals before claimable\r\n   require(_current_interval >= period.interval.add(_min_intervals)); // Period not ready for claims yet. Need to wait more !\r\n\r\n  // if status equals pending this is the first claim for this proposal\r\n  if (proposaldata.status == ProposalStatus.Pending) {\r\n\r\n  // SET proposal new status\r\n  if (proposaldata.prestatus == ProposalStatus.Accepted) {\r\n            proposaldata.status = ProposalStatus.Accepted;\r\n  }\r\n  else {\r\n    proposaldata.status = ProposalStatus.Rejected;\r\n  }\r\n\r\n  proposaldata.finalized_time = block.timestamp;\r\n\r\n  // NEW STATUS AFTER FIRST CLAIM DONE\r\n\r\n  }\r\n\r\n\r\n  // only slash and reward if prop is not tie:\r\n  if (!proposaldata.istie) {\r\n   \r\n   // convert boolean to enum format for making comparasion with proposaldata.status possible:\r\n   ProposalStatus voterChoice = ProposalStatus.Rejected;\r\n   if(vote.approve){\r\n     voterChoice = ProposalStatus.Accepted;\r\n   }\r\n\r\n   if(voterChoice != proposaldata.status) {\r\n     // slash loosers: voter has voted wrongly and needs to be slashed\r\n     uint _slashRemaining = vote.amount;\r\n     uint _extraTimeInt = uint(STAKING_DURATION.mul(SEVERITY_LEVEL).mul(proposaldata.slashingratio).div(10000));\r\n\r\n     if(vote.is_editor){\r\n     _extraTimeInt = uint(_extraTimeInt.mul(PROPOSERS_INCREASER));\r\n     }\r\n\r\n\r\n// REQUIRE FEE if slashingratio is superior to 90.00%:\r\nif(proposaldata.slashingratio > 9000){\r\n    // 33% fee if voter is not proposer or 100% fee if voter is proposer\r\n    uint _feeRemaining = uint(vote.amount.mul(33).div(100));\r\n      if(vote.is_editor){\r\n        _feeRemaining = vote.amount;\r\n      }\r\n    emit NewFee(msg.sender, _feeRemaining, vote.proposal_hash);  \r\n    UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(_feeRemaining);  \r\n     // update _slashRemaining \r\n    _slashRemaining = vote.amount.sub(_feeRemaining);\r\n\r\n         for(uint _stakeidxa = 1; _stakeidxa <= stakesCounters[msg.sender];  _stakeidxa++) {\r\n      //if stake is big enough and can take into account the whole fee:\r\n      if(stakes[msg.sender][_stakeidxa].amount > _feeRemaining) {\r\n \r\n        stakes[msg.sender][_stakeidxa].amount = stakes[msg.sender][_stakeidxa].amount.sub(_feeRemaining);\r\n        stakesAmount[msg.sender] = stakesAmount[msg.sender].sub(_feeRemaining);\r\n        _feeRemaining = 0;\r\n         break;\r\n      }\r\n      else {\r\n        // The fee amount is more than or equal to a full stake, so the stake needs to be deleted:\r\n          _feeRemaining = _feeRemaining.sub(stakes[msg.sender][_stakeidxa].amount);\r\n          _deletestake(msg.sender, _stakeidxa);\r\n          if(_feeRemaining == 0){\r\n           break;\r\n          }\r\n      }\r\n    }\r\n}\r\n\r\n\r\n\r\n// SLASH only if slash remaining > 0\r\nif(_slashRemaining > 0){\r\n  emit NewSlash(msg.sender, _slashRemaining, vote.proposal_hash);\r\n         for(uint _stakeidx = 1; _stakeidx <= stakesCounters[msg.sender];  _stakeidx++) {\r\n      //if stake is too small and will only be able to take into account a part of the slash:\r\n      if(stakes[msg.sender][_stakeidx].amount <= _slashRemaining) {\r\n \r\n        stakes[msg.sender][_stakeidx].endTime = stakes[msg.sender][_stakeidx].endTime.add(_extraTimeInt);\r\n        _slashRemaining = _slashRemaining.sub(stakes[msg.sender][_stakeidx].amount);\r\n        \r\n       if(_slashRemaining == 0){\r\n         break;\r\n       }\r\n      }\r\n      else {\r\n        // The slash amount does not fill a full stake, so the stake needs to be split\r\n        uint newAmount = stakes[msg.sender][_stakeidx].amount.sub(_slashRemaining);\r\n        uint oldCompletionTime = stakes[msg.sender][_stakeidx].endTime;\r\n\r\n        // slash amount split in _slashRemaining and newAmount\r\n        stakes[msg.sender][_stakeidx].amount = _slashRemaining; // only slash the part of the stake that amounts to _slashRemaining\r\n        stakes[msg.sender][_stakeidx].endTime = stakes[msg.sender][_stakeidx].endTime.add(_extraTimeInt); // slash the stake\r\n\r\n        if(newAmount > 0){\r\n          // create a new stake with the rest of what remained from original stake that was split in 2\r\n          splitStake(msg.sender, newAmount, oldCompletionTime);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n}\r\n    // the slash is over\r\n   }\r\n   else {\r\n\r\n   uint _reward_amount = 0;\r\n\r\n   // check beforte diving by 0\r\n   require(period.curation_sum > 0); // period curation sum pb !\r\n   // get curation reward only if voter is not the proposer:\r\n   if (!vote.is_editor){\r\n   _reward_amount = _reward_amount.add((vote.amount.mul(period.reward_for_curation)).div(period.curation_sum));\r\n   }\r\n\r\n       // if voter is editor and proposal accepted:\r\n    if (vote.is_editor && proposaldata.status == ProposalStatus.Accepted){\r\n          // check before dividing by 0\r\n          require( period.editor_sum > 0); // Period editor sum pb !\r\n          _reward_amount = _reward_amount.add((proposaldata.lasteditor_weight.mul(period.reward_for_editor)).div(period.editor_sum));\r\n    }\r\n\r\n    require(_reward_amount <= period.reward_for_curation.add(period.reward_for_editor)); // \"System logic error. Too much ETICA calculated for reward.\"\r\n\r\n    // SEND ETICA AS REWARD\r\n    balances[address(this)] = balances[address(this)].sub(_reward_amount);\r\n    balances[msg.sender] = balances[msg.sender].add(_reward_amount);\r\n\r\n    emit Transfer(address(this), msg.sender, _reward_amount);\r\n    emit RewardClaimed(msg.sender, _reward_amount, _proposed_release_hash);\r\n   }\r\n\r\n  }   // end bracket if (proposaldata.istie not true)\r\n  \r\n  }\r\n\r\n\r\n    function createchunk(bytes32 _diseasehash, string memory _title, string memory _description) public {\r\n\r\n  //check if the disease exits\r\n  require(diseasesbyIds[_diseasehash] > 0 && diseasesbyIds[_diseasehash] <= diseasesCounter);\r\n  if(diseases[diseasesbyIds[_diseasehash]].disease_hash != _diseasehash) revert(); // second check not necessary but I decided to add it as the gas cost value for security is worth it\r\n\r\n  // --- REQUIRE PAYMENT FOR ADDING A CHUNK TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\r\n  uint _cost = DISEASE_CREATION_AMOUNT.div(20);\r\n  // make sure the user has enough ETI to create a chunk\r\n  require(balances[msg.sender] >= _cost);\r\n  // transfer DISEASE_CREATION_AMOUNT / 20  ETI from user wallet to contract wallet:\r\n  transfer(address(this), _cost);\r\n\r\n  // --- REQUIRE PAYMENT FOR ADDING A CHUNK TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\r\n\r\n  chunksCounter = chunksCounter.add(1); // get general id of Chunk\r\n\r\n  // updates disease's chunks infos:\r\n  diseaseChunksCounter[_diseasehash] = diseaseChunksCounter[_diseasehash].add(1); // Increase chunks index of Disease\r\n  diseasechunks[_diseasehash][diseaseChunksCounter[_diseasehash]] = chunksCounter;\r\n  \r\n\r\n  // store the Chunk\r\n   chunks[chunksCounter] = Chunk(\r\n     chunksCounter, // general id of the chunk\r\n     _diseasehash, // disease of the chunk\r\n     diseaseChunksCounter[_diseasehash], // Index of chunk within disease\r\n     _title,\r\n     _description\r\n   );\r\n\r\n  UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(_cost);\r\n  emit NewChunk(chunksCounter, _diseasehash);\r\n\r\n  }\r\n\r\n\r\n// -------------  PUBLISHING SYSTEM CORE FUNCTIONS ---------------- //\r\n\r\n\r\n\r\n// -------------  GETTER FUNCTIONS ---------------- //\r\n// get bosoms balance of user:\r\nfunction bosomsOf(address tokenOwner) public view returns (uint _bosoms){\r\n     return bosoms[tokenOwner];\r\n }\r\n\r\n function getdiseasehashbyName(string memory _name) public view returns (bytes32 _diseasehash){\r\n     return diseasesbyNames[_name];\r\n }\r\n// -------------  GETTER FUNCTIONS ---------------- //\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PERIOD_EDITOR_REWARD_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPOSERS_INCREASER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"diseasesbyIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardEthBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IntervalsPeriodsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_diseasehash\",\"type\":\"bytes32\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"raw_release_hash\",\"type\":\"string\"},{\"name\":\"_freefield\",\"type\":\"string\"},{\"name\":\"_chunkid\",\"type\":\"uint256\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_votehash\",\"type\":\"bytes32\"}],\"name\":\"commitvote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAKING_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chunksCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"proposed_release_hash\",\"type\":\"bytes32\"},{\"name\":\"disease_id\",\"type\":\"bytes32\"},{\"name\":\"period_id\",\"type\":\"uint256\"},{\"name\":\"chunk_id\",\"type\":\"uint256\"},{\"name\":\"proposer\",\"type\":\"address\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"freefield\",\"type\":\"string\"},{\"name\":\"raw_release_hash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalsbyIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISEASE_CREATION_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_VOTING_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAST_PERIOD_COST_UPDATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_REVEALING_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"APPROVAL_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_diseasehash\",\"type\":\"bytes32\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"createchunk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalMiningSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"diseasechunks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"diseases\",\"outputs\":[{\"name\":\"disease_hash\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"propsdatas\",\"outputs\":[{\"name\":\"starttime\",\"type\":\"uint256\"},{\"name\":\"endtime\",\"type\":\"uint256\"},{\"name\":\"finalized_time\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"prestatus\",\"type\":\"uint8\"},{\"name\":\"istie\",\"type\":\"bool\"},{\"name\":\"nbvoters\",\"type\":\"uint256\"},{\"name\":\"slashingratio\",\"type\":\"uint256\"},{\"name\":\"forvotes\",\"type\":\"uint256\"},{\"name\":\"againstvotes\",\"type\":\"uint256\"},{\"name\":\"lastcuration_weight\",\"type\":\"uint256\"},{\"name\":\"lasteditor_weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNRECOVERABLE_ETI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_min_limit\",\"type\":\"uint256\"},{\"name\":\"_maxidx\",\"type\":\"uint256\"}],\"name\":\"stakescsldt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bosoms\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initiatormsg\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chunks\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"diseaseid\",\"type\":\"bytes32\"},{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"desc\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"stakescount\",\"outputs\":[{\"name\":\"slength\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"diseaseproposals\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposed_release_hash\",\"type\":\"bytes32\"},{\"name\":\"_approved\",\"type\":\"bool\"},{\"name\":\"_vary\",\"type\":\"string\"}],\"name\":\"revealvote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createdisease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"diseasesCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SEVERITY_LEVEL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commits\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"name\":\"challenge_number\",\"type\":\"bytes32\"},{\"name\":\"testTarget\",\"type\":\"uint256\"}],\"name\":\"checkMintSolution\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"diseaseProposalsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MAXIMUM_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IntervalsPeriods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"name\":\"proposal_hash\",\"type\":\"bytes32\"},{\"name\":\"approve\",\"type\":\"bool\"},{\"name\":\"is_editor\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"is_claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"name\":\"challenge_number\",\"type\":\"bytes32\"}],\"name\":\"getMintDigest\",\"outputs\":[{\"name\":\"digesttest\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROPOSAL_DEFAULT_VOTE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updatecost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeidx\",\"type\":\"uint256\"},{\"name\":\"_snapamount\",\"type\":\"uint256\"}],\"name\":\"stakesnap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getdiseasehashbyName\",\"outputs\":[{\"name\":\"_diseasehash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERIOD_CURATION_REWARD_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_BLOCKS_PER_READJUSTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inflationrate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERIODS_PER_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"eticatobosoms\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chunkproposals\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakesAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockreward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PeriodsIssuedCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodrewardtemp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakesCounters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MINIMUM_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chunkProposalsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"diseaseChunksCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROTOCOL_RATIO_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periods\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"curation_sum\",\"type\":\"uint256\"},{\"name\":\"editor_sum\",\"type\":\"uint256\"},{\"name\":\"reward_for_curation\",\"type\":\"uint256\"},{\"name\":\"reward_for_editor\",\"type\":\"uint256\"},{\"name\":\"forprops\",\"type\":\"uint256\"},{\"name\":\"againstprops\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeidx\",\"type\":\"uint256\"}],\"name\":\"stakeclmidx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"bosomsOf\",\"outputs\":[{\"name\":\"_bosoms\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposed_release_hash\",\"type\":\"bytes32\"}],\"name\":\"clmpropbyhash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PeriodsIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockedeticas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"period_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"CreatedPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"diseaseindex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"title\",\"type\":\"string\"}],\"name\":\"NewDisease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposed_release_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_proposer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"diseasehash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"chunkid\",\"type\":\"uint256\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"chunkid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"diseasehash\",\"type\":\"bytes32\"}],\"name\":\"NewChunk\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposal_hash\",\"type\":\"bytes32\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposal_hash\",\"type\":\"bytes32\"}],\"name\":\"NewFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposal_hash\",\"type\":\"bytes32\"}],\"name\":\"NewSlash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votehash\",\"type\":\"bytes32\"}],\"name\":\"NewCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_proposal\",\"type\":\"bytes32\"}],\"name\":\"NewReveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stakeamount\",\"type\":\"uint256\"}],\"name\":\"StakeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blockreward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"}]","ContractName":"EticaRelease","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://16f3272bcc5ac61d4e6d245984afea8eb5da628435fdca4c947a9adb0475a13e"}]}