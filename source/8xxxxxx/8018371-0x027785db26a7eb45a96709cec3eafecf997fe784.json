{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Structs {\r\n    struct Hmmm {\r\n        uint256 value;\r\n    }\r\n\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n}\r\n\r\ncontract DyDx is Structs {\r\n    function getEarningsRate() public view returns (Hmmm memory);\r\n    function getMarketInterestRate(uint256 marketId) public view returns (Hmmm memory);\r\n    function getMarketTotalPar(uint256 marketId) public view returns (TotalPar memory);\r\n    function getAccountWei(Info memory account, uint256 marketId) public view returns (Wei memory);\r\n    function operate(Info[] memory, ActionArgs[] memory) public;\r\n}\r\n\r\ncontract Compound {\r\n    struct Market {\r\n        bool isSupported;\r\n        uint blockNumber;\r\n        address interestRateModel;\r\n\r\n        uint totalSupply;\r\n        uint supplyRateMantissa;\r\n        uint supplyIndex;\r\n\r\n        uint totalBorrows;\r\n        uint borrowRateMantissa;\r\n        uint borrowIndex;\r\n    }\r\n\r\n    function supply(address asset, uint amount) public returns (uint);\r\n    function withdraw(address asset, uint requestedAmount) public returns (uint);\r\n    function getSupplyBalance(address account, address asset) view public returns (uint);\r\n    function markets(address) public view returns(Market memory);\r\n    function supplyRatePerBlock() public view returns (uint);\r\n    function mint(uint mintAmount) public returns (uint);\r\n    function redeem(uint redeemTokens) public returns (uint);\r\n    function balanceOf(address account) public view returns (uint);\r\n}\r\n\r\ncontract Defimanager is Structs {\r\n\r\n    uint256 DECIMAL = 10 ** 18;\r\n    // address dydxAddr       = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    // address compoundAddr   = 0x61bbd7Bd5EE2A202d7e62519750170A52A8DFD45;\r\n    // address daiAddr        = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\r\n    //0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; //0x4e17c87c52d0E9a0cAd3Fbc53b77d9514F003807\r\n\r\n    // MAINNET ADDRESSES\r\n    address dydxAddr       = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    address compoundAddr   = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n    address daiAddr        = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n\r\n    // KOVAN ADDRESSES\r\n    // address dydxAddr       = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;\r\n    // address compoundAddr   = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;\r\n    // address daiAddr        = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\r\n\r\n    uint256 public balancePrev           = 10 ** 18; // at least this much dai must be sent to the contract on creation\r\n    uint256 public benchmarkBalancePrev  = 10 ** 18;\r\n\r\n    struct Account {\r\n        uint256 userBalanceLast;\r\n        uint256 benchmarkBalanceLast;\r\n    }\r\n\r\n    mapping (address => Account) accounts;\r\n\r\n    enum CurrentLender {\r\n        NONE,\r\n        DYDX,\r\n        COMPOUND\r\n    }\r\n\r\n    DyDx dydx      = DyDx(dydxAddr);\r\n    Compound comp  = Compound(compoundAddr);\r\n    ERC20 dai      = ERC20(daiAddr);\r\n\r\n    CurrentLender public lender;\r\n\r\n    function approveDai() public {\r\n        dai.approve(compoundAddr, uint(-1)); //also add to constructor\r\n        dai.approve(dydxAddr, uint(-1));\r\n    }\r\n\r\n    function poke() public {\r\n        uint move = which();\r\n        require(move != 999, \"Something went wrong finding the best rate\");\r\n        if (move == 0 && lender == CurrentLender.DYDX) {\r\n            supplyDyDx(balanceDai());\r\n        } else if (move == 0 && lender == CurrentLender.COMPOUND) {\r\n            compToDyDx();\r\n        } else if (move == 1 && lender == CurrentLender.COMPOUND) {\r\n            supplyComp(balanceDai());\r\n        } else if (move == 1 && lender == CurrentLender.DYDX) {\r\n            dydxToComp();\r\n        }\r\n    }\r\n\r\n    function which() public view returns(uint) {\r\n        uint aprDyDx = pokeDyDx();\r\n        uint aprComp = pokeCompound();\r\n        if (aprDyDx > aprComp) return 0;\r\n        if (aprComp > aprDyDx) return 1;\r\n        return 999;\r\n    }\r\n\r\n    function dydxToComp() internal {\r\n        withdrawDyDx(balanceDyDx());\r\n        supplyComp(balanceDai());\r\n    }\r\n\r\n    function compToDyDx() internal {\r\n        withdrawComp(balanceComp());\r\n        supplyDyDx(balanceDai());\r\n    }\r\n\r\n    function pokeDyDx() public view returns(uint256) {\r\n        uint256 rate      = dydx.getMarketInterestRate(1).value;\r\n        uint256 aprBorrow = rate * 31622400;\r\n        uint256 borrow    = dydx.getMarketTotalPar(1).borrow;\r\n        uint256 supply    = dydx.getMarketTotalPar(1).supply;\r\n        uint256 usage     = (borrow * DECIMAL) / supply;\r\n        uint256 apr       = (((aprBorrow * usage) / DECIMAL) * dydx.getEarningsRate().value) / DECIMAL;\r\n        return apr;\r\n    }\r\n\r\n    function pokeCompound() public view returns(uint256) {\r\n        uint interestRate = comp.supplyRatePerBlock();\r\n        uint apr          = interestRate * 2108160;\r\n        return apr;\r\n    }\r\n\r\n    function balanceDyDx() public view returns(uint256) {\r\n        Wei memory bal = dydx.getAccountWei(Info(address(this), 0), 1);\r\n        return bal.value;\r\n    }\r\n\r\n    function balanceComp() public view returns(uint) {\r\n        return comp.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceDai() public view returns(uint) {\r\n        return dai.balanceOf(address(this));\r\n    }\r\n\r\n    function balanceDaiCurrent() public view returns (uint) {\r\n        if (lender == CurrentLender.COMPOUND) {\r\n            return balanceComp() + balanceDai();\r\n        }\r\n        if (lender == CurrentLender.DYDX) { \r\n            return balanceDyDx() + balanceDai();\r\n        }\r\n        return balanceDai();\r\n    }\r\n\r\n    function supplyDyDx(uint256 amount) public returns(uint) {\r\n        Info[] memory infos = new Info[](1);\r\n        infos[0] = Info(address(this), 0);\r\n\r\n        AssetAmount memory amt = AssetAmount(true, AssetDenomination.Wei, AssetReference.Delta, amount);\r\n        ActionArgs memory act;\r\n        act.actionType = ActionType.Deposit;\r\n        act.accountId = 0;\r\n        act.amount = amt;\r\n        act.primaryMarketId = 1;\r\n        act.otherAddress = address(this);\r\n\r\n        ActionArgs[] memory args = new ActionArgs[](1);\r\n        args[0] = act;\r\n\r\n        dydx.operate(infos, args);\r\n\r\n        lender = CurrentLender.DYDX;\r\n    }\r\n\r\n    function withdrawDyDx(uint256 amount) public {\r\n        Info[] memory infos = new Info[](1);\r\n        infos[0] = Info(address(this), 0);\r\n\r\n        AssetAmount memory amt = AssetAmount(true, AssetDenomination.Wei, AssetReference.Delta, amount);\r\n        ActionArgs memory act;\r\n        act.actionType = ActionType.Withdraw;\r\n        act.accountId = 0;\r\n        act.amount = amt;\r\n        act.primaryMarketId = 1;\r\n        act.otherAddress = address(this);\r\n\r\n        ActionArgs[] memory args = new ActionArgs[](1);\r\n        args[0] = act;\r\n\r\n        dydx.operate(infos, args);\r\n        // lender = CurrentLender.NONE; - only if amount = entire dydx balance\r\n    }\r\n\r\n    function supplyComp(uint amount) public {\r\n        require(comp.mint(amount) == 0, \"COMPOUND: mint fail\");\r\n\r\n        lender = CurrentLender.COMPOUND;\r\n    }\r\n\r\n    function withdrawComp(uint amount) public {\r\n        require(comp.redeem(amount) == 0, \"COMPOUND: redeem fail\");\r\n        // lender = CurrentLender.NONE;\r\n    }\r\n\r\n    function initializeNewUser() public {\r\n        accounts[msg.sender].userBalanceLast = 0;\r\n        accounts[msg.sender].benchmarkBalanceLast = (benchmarkBalancePrev * balanceDaiCurrent()) / balancePrev;\r\n    }\r\n\r\n    function depositDai(uint amount) public returns(uint) {\r\n\r\n        dai.approve(compoundAddr, uint(-1)); //also add to constructor\r\n        dai.approve(dydxAddr, uint(-1));\r\n\r\n        //figure out current benchmark account balance\r\n        uint256 benchmarkCurrentBalance = (benchmarkBalancePrev * balanceDaiCurrent()) / balancePrev;\r\n        \r\n        //figure out how much the user actually has right now\r\n\r\n        uint256 userCurrentBalance = benchmarkCurrentBalance * accounts[msg.sender].userBalanceLast / accounts[msg.sender].benchmarkBalanceLast;\r\n\r\n        //update user's balance to add the amount being deposited\r\n        accounts[msg.sender].userBalanceLast = userCurrentBalance + amount;\r\n\r\n        //update the global benchmark balance\r\n        benchmarkBalancePrev = benchmarkCurrentBalance;\r\n\r\n        //track the benchmark balance for the user\r\n        accounts[msg.sender].benchmarkBalanceLast = benchmarkCurrentBalance;\r\n\r\n        balancePrev = balanceDaiCurrent() + amount;\r\n        require(dai.transferFrom(msg.sender, address(this), amount), 'balance too low');\r\n\r\n        if (lender == CurrentLender.DYDX) {\r\n            supplyDyDx(amount);\r\n        }\r\n        if (lender == CurrentLender.COMPOUND) {\r\n            supplyComp(amount);\r\n        }\r\n    }\r\n\r\n    function withdrawDai(uint amount) public returns(uint) {\r\n        uint256 benchmarkCurrentBalance = (benchmarkBalancePrev * balanceDaiCurrent()) / balancePrev;\r\n        uint256 userCurrentBalance = benchmarkCurrentBalance * accounts[msg.sender].userBalanceLast / accounts[msg.sender].benchmarkBalanceLast;\r\n        require(amount <= userCurrentBalance, 'cannot withdraw'); \r\n\r\n        accounts[msg.sender].userBalanceLast = userCurrentBalance - amount;\r\n        benchmarkBalancePrev = benchmarkCurrentBalance;\r\n        accounts[msg.sender].benchmarkBalanceLast = benchmarkCurrentBalance;\r\n\r\n        balancePrev = balanceDaiCurrent() + amount;\r\n\r\n        //do withdrawal\r\n        if (lender == CurrentLender.DYDX) {\r\n            withdrawDyDx(amount);\r\n        }\r\n\r\n        if (lender == CurrentLender.COMPOUND) {\r\n            withdrawComp(amount);\r\n        }\r\n\r\n        require(dai.transferFrom(address(this), msg.sender, amount), 'transfer failed');\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"balanceDyDx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeNewUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyDyDx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceDaiCurrent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pokeDyDx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balancePrev\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawComp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"benchmarkBalancePrev\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyComp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDyDx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"which\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pokeCompound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceComp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Defimanager","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4ba8fadfc2a37470772f5eb41f956debbafb83b9205354f4d99cfd1808202dce"}]}