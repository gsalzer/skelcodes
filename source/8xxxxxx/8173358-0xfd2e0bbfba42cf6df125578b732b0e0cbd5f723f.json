{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n/*\r\n* This smart contract implements voting for tokenholders of ERC20 tokens based on the principle\r\n* \"one token - one vote\"\r\n* It requires external script to count votes.\r\n*\r\n* Rules:\r\n* Voting can be started for any contract with ERC20 tokens, to start a voting an address have to own at lest one token.\r\n* To start a voting, voting creator must provide:\r\n* 1) address of a contract with tokens (ERC20),\r\n* 2) text of the proposal,\r\n* 3) number of block on witch voting will be finished and results have to be calculated.\r\n*\r\n* Every proposal for a contract receives a sequence number that serves as a proposal ID for this contract.\r\n* Each smart contract with tokens has its own numbering.\r\n* So proposal can be identified by contract address with tokens + number (ID) of the proposal.\r\n*\r\n* To vote 'for' or 'against' voter has to provide an address of a contract with tokens + proposal ID.\r\n*\r\n* In most scenarios only votes 'for' can be used, who did not voted 'for' can be considered as voted 'against'.\r\n* But our dApp also supports votes 'against'\r\n*\r\n* To calculate results we collect all voted addresses by an external script, which is also open sourced.\r\n* Than we check their balances in tokens on resulting block, and and sum up the voices.\r\n* Thus, for the results, the number of tokens of the voter at the moment of voting does not matter\r\n* (it should just has at least one).\r\n* What matters is the number of tokens on the voter's address on the block where the results should calculated.\r\n*\r\n*/\r\n\r\ncontract ERC20TokensContract {\r\n\r\n    /*\r\n    * These are functions that smart contract needs to have to work with our dApp\r\n    */\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n}\r\n\r\ncontract VotingForERC20 {\r\n\r\n    mapping(address => uint256) public votingCounterForContract;\r\n    mapping(address => mapping(uint256 => string)) public proposalText;\r\n    mapping(address => mapping(uint256 => uint256)) public numberOfVotersFor;\r\n    mapping(address => mapping(uint256 => uint256)) public numberOfVotersAgainst;\r\n    mapping(address => mapping(uint256 => mapping(uint256 => address))) public votedFor;\r\n    mapping(address => mapping(uint256 => mapping(uint256 => address))) public votedAgainst;\r\n    mapping(address => mapping(uint256 => mapping(address => bool))) public boolVotedFor;\r\n    mapping(address => mapping(uint256 => mapping(address => bool))) public boolVotedAgainst;\r\n    mapping(address => mapping(uint256 => uint256)) public resultsInBlock;\r\n\r\n    event Proposal(\r\n        address indexed forContract,\r\n        uint indexed proposalId,\r\n        address indexed by,\r\n        string proposalText,\r\n        uint resultsInBlock\r\n    );\r\n\r\n    function create(\r\n        address _erc20ContractAddress, //...1\r\n        string calldata _proposalText, //...2\r\n        uint256 _resultsInBlock //..........3\r\n    ) external returns (bool success){\r\n\r\n        ERC20TokensContract erc20TokensContract = ERC20TokensContract(_erc20ContractAddress);\r\n\r\n        require(\r\n            erc20TokensContract.balanceOf(msg.sender) > 0,\r\n            \"Only tokenholder can start voting\"\r\n        );\r\n\r\n        require(\r\n            _resultsInBlock > block.number,\r\n            \"Block for results should be later than current block\"\r\n        );\r\n\r\n        // votingCounterForContract[_erc20ContractAddress]++; // < does not work\r\n        votingCounterForContract[_erc20ContractAddress] = votingCounterForContract[_erc20ContractAddress] + 1;\r\n        uint proposalId = votingCounterForContract[_erc20ContractAddress];\r\n\r\n        proposalText[_erc20ContractAddress][proposalId] = _proposalText;\r\n        resultsInBlock[_erc20ContractAddress][proposalId] = _resultsInBlock;\r\n\r\n        emit Proposal(_erc20ContractAddress, proposalId, msg.sender, _proposalText, _resultsInBlock);\r\n\r\n        return true;\r\n    }\r\n\r\n    event VoteFor(\r\n        address indexed forContract,\r\n        uint indexed proposalId,\r\n        address indexed by\r\n    );\r\n\r\n    event VoteAgainst(\r\n        address indexed forContract,\r\n        uint indexed proposalId,\r\n        address indexed by\r\n    );\r\n\r\n    function voteFor(\r\n        address _erc20ContractAddress, //..1\r\n        uint256 _proposalId //.............2\r\n    ) external returns (bool success){\r\n\r\n        ERC20TokensContract erc20TokensContract = ERC20TokensContract(_erc20ContractAddress);\r\n\r\n        require(\r\n            erc20TokensContract.balanceOf(msg.sender) > 0,\r\n            \"Only tokenholder can vote\"\r\n        );\r\n\r\n        require(\r\n            resultsInBlock[_erc20ContractAddress][_proposalId] > block.number,\r\n            \"Voting finished\"\r\n        );\r\n\r\n        require(\r\n            !boolVotedFor[_erc20ContractAddress][_proposalId][msg.sender],\r\n            \"Already voted\"\r\n        );\r\n        require(\r\n            !boolVotedAgainst[_erc20ContractAddress][_proposalId][msg.sender],\r\n            \"Already voted\"\r\n        );\r\n\r\n        numberOfVotersFor[_erc20ContractAddress][_proposalId] = numberOfVotersFor[_erc20ContractAddress][_proposalId] + 1;\r\n        uint voterId = numberOfVotersFor[_erc20ContractAddress][_proposalId];\r\n\r\n        votedFor[_erc20ContractAddress][_proposalId][voterId] = msg.sender;\r\n        boolVotedFor[_erc20ContractAddress][_proposalId][msg.sender] = true;\r\n\r\n        emit VoteFor(_erc20ContractAddress, _proposalId, msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    function voteAgainst(\r\n        address _erc20ContractAddress, //..1\r\n        uint256 _proposalId //.............2\r\n    ) external returns (bool success){\r\n\r\n        ERC20TokensContract erc20TokensContract = ERC20TokensContract(_erc20ContractAddress);\r\n\r\n        require(\r\n            erc20TokensContract.balanceOf(msg.sender) > 0,\r\n            \"Only tokenholder can vote\"\r\n        );\r\n\r\n        require(\r\n            resultsInBlock[_erc20ContractAddress][_proposalId] > block.number,\r\n            \"Voting finished\"\r\n        );\r\n\r\n        require(\r\n            !boolVotedFor[_erc20ContractAddress][_proposalId][msg.sender],\r\n            \"Already voted\"\r\n        );\r\n        require(\r\n            !boolVotedAgainst[_erc20ContractAddress][_proposalId][msg.sender],\r\n            \"Already voted\"\r\n        );\r\n\r\n        numberOfVotersAgainst[_erc20ContractAddress][_proposalId] = numberOfVotersAgainst[_erc20ContractAddress][_proposalId] + 1;\r\n        uint voterId = numberOfVotersAgainst[_erc20ContractAddress][_proposalId];\r\n\r\n        votedAgainst[_erc20ContractAddress][_proposalId][voterId] = msg.sender;\r\n        boolVotedAgainst[_erc20ContractAddress][_proposalId][msg.sender] = true;\r\n\r\n        emit VoteAgainst(_erc20ContractAddress, _proposalId, msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_erc20ContractAddress\",\"type\":\"address\"},{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"voteAgainst\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_erc20ContractAddress\",\"type\":\"address\"},{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"voteFor\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votingCounterForContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numberOfVotersFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"boolVotedAgainst\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votedAgainst\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"boolVotedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_erc20ContractAddress\",\"type\":\"address\"},{\"name\":\"_proposalText\",\"type\":\"string\"},{\"name\":\"_resultsInBlock\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resultsInBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numberOfVotersAgainst\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalText\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"forContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proposalText\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"resultsInBlock\",\"type\":\"uint256\"}],\"name\":\"Proposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"forContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"VoteFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"forContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"VoteAgainst\",\"type\":\"event\"}]","ContractName":"VotingForERC20","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0e9d8cd1cd1abec89b283bba7a08cef763a92db621a2190567a421e3f74bb370"}]}