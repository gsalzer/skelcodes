{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-10-16\r\n*/\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ninterface IERC20 {\r\n    /*\r\n     * Metadata\r\n     */\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Only used on BASE token\r\n     */\r\n    function transferFromWithFee(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Only used on BASE token\r\n     */\r\n    function transferWithFee(address _to, uint256 _value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapExchange.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ninterface IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n// File: contracts/utils/IsContract.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary IsContract {\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        /* solium-disable-next-line */\r\n        assembly { codehash := extcodehash(_addr) }\r\n        return codehash != bytes32(0) && codehash != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IDefswapExchange.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ninterface IDefswapExchange {\r\n    function base() external view returns (IERC20);\r\n    function token() external view returns (IERC20);\r\n    function addLiquidity(uint256 _tokens, uint256 _maxBase) external returns (uint256);\r\n    function removeLiquidity(uint256 _amount, uint256 _minBase, uint256 _minTokens) external returns (uint256, uint256);\r\n    function ethToTokenSwapInput(uint256 _minTokens) external payable returns (uint256);\r\n    function baseToTokenSwapInput(uint256 _amount, uint256 _minTokens) external returns (uint256);\r\n    function baseToTokenTransferInput(uint256 _amount, uint256 _minTokens, address _recipient) external returns (uint256);\r\n    function tokenToEthSwapInput(uint256 _amount, uint256 _minEth) external returns (uint256);\r\n    function tokenToEthTransferInput(uint256 _amount, uint256 _minTokens, address _recipient) external returns (uint256);\r\n    function tokenToEthExchangeTransferInput(uint256 _amount, uint256 _minTokens, address _recipient, address _exchangeAddr) external returns (uint256);\r\n    function tokenToBaseSwapInput(uint256 _amount, uint256 _minTokens) external returns (uint256);\r\n    function tokenToBaseTransferInput(uint256 _amount, uint256 _minTokens, address _recipient) external returns (uint256);\r\n    function tokenToBaseExchangeTransferInput(uint256 _amount, uint256 _minTokens, address _recipient, address _exchangeAddr) external returns (uint256);\r\n    // Uniswap exchange compat\r\n    function ethToTokenTransferInput(uint256 _minTokens, uint256 _deadline, address _recipient) external payable returns (uint256);\r\n}\r\n\r\n// File: contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    uint256 private _guardFlag;\r\n\r\n    uint256 private constant FLAG_LOCK = 2;\r\n    uint256 private constant FLAG_UNLOCK = 1;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardFlag = FLAG_UNLOCK;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_guardFlag != FLAG_LOCK, \"reentrancy-guard: reentrant call\");\r\n        _guardFlag = FLAG_LOCK;\r\n        _;\r\n        _guardFlag = FLAG_UNLOCK;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"safemath: add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"safemath: sub overflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z / x == y, \"safemath: mul overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"safemath: div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"safemath: div by zero\");\r\n        uint256 r = x / y;\r\n        if (x % y != 0) {\r\n            r = r + 1;\r\n        }\r\n\r\n        return r;\r\n    }\r\n}\r\n\r\n// File: contracts/commons/ERC20.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal p_totalSupply;\r\n    mapping(address => uint256) internal p_balance;\r\n    mapping(address => mapping(address => uint256)) internal p_allowance;\r\n\r\n    string private p_symbol;\r\n    string private p_name;\r\n    uint256 private p_decimals;\r\n\r\n    function _setMetadata(\r\n        string memory _symbol,\r\n        string memory _name,\r\n        uint256 _decimals\r\n    ) internal {\r\n        p_symbol = _symbol;\r\n        p_name = _name;\r\n        p_decimals = _decimals;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return p_symbol;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return p_name;\r\n    }\r\n\r\n    function decimals() external view returns (uint256) {\r\n        return p_decimals;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return p_totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _addr) external view returns (uint256) {\r\n        return p_balance[_addr];\r\n    }\r\n\r\n    function allowance(address _addr, address _spender) external view returns (uint256) {\r\n        return p_allowance[_addr][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _wad) external returns (bool) {\r\n        emit Approval(msg.sender, _spender, _wad);\r\n        p_allowance[msg.sender][_spender] = _wad;\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(msg.sender, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function transferWithFee(address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(msg.sender, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(_from, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function transferFromWithFee(address _from, address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(_from, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _wad\r\n    ) internal {\r\n        p_totalSupply = p_totalSupply.add(_wad);\r\n        p_balance[_to] = p_balance[_to].add(_wad);\r\n\r\n        emit Transfer(address(0), _to, _wad);\r\n    }\r\n\r\n    function _burn(\r\n        address _from,\r\n        uint256 _wad\r\n    ) internal {\r\n        uint256 balance = p_balance[_from];\r\n        require(balance >= _wad, \"erc20: burn _from balance is not enough\");\r\n        p_balance[_from] = balance.sub(_wad);\r\n        p_totalSupply = p_totalSupply.sub(_wad);\r\n        emit Transfer(_from, address(0), _wad);\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _wad\r\n    ) private {\r\n        if (_from != _to) {\r\n            uint256 t_allowance = p_allowance[_from][msg.sender];\r\n            if (t_allowance != uint(-1)) {\r\n                require(t_allowance >= _wad, \"erc20: sender allowance is not enough\");\r\n                p_allowance[_from][msg.sender] = t_allowance.sub(_wad);\r\n            }\r\n        }\r\n\r\n        uint256 balance = p_balance[_from];\r\n        require(balance >= _wad, \"erc20: transfer _from balance is not enough\");\r\n        p_balance[_from] = balance.sub(_wad);\r\n        p_balance[_to] = balance.add(_wad);\r\n\r\n        emit Transfer(_from, _to, _wad);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeDefERC20.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\nlibrary SafeDefERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 _token,\r\n        address _to,\r\n        uint256 _wad\r\n    ) internal returns (uint256) {\r\n        uint256 prev = _token.balanceOf(address(this));\r\n\r\n        (bool success, ) = address(_token).call(\r\n            abi.encodeWithSelector(\r\n                _token.transfer.selector,\r\n                _to,\r\n                _wad\r\n            )\r\n        );\r\n\r\n        require(success, \"safedeferc20: error pulling tokens\");\r\n        return prev.sub(_token.balanceOf(address(this)));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _wad\r\n    ) internal returns (uint256) {\r\n        uint256 prev = _token.balanceOf(_to);\r\n\r\n        (bool success, ) = address(_token).call(\r\n            abi.encodeWithSelector(\r\n                _token.transferFrom.selector,\r\n                _from,\r\n                _to,\r\n                _wad\r\n            )\r\n        );\r\n\r\n        require(success, \"safedeferc20: error pulling tokens\");\r\n        return _token.balanceOf(_to).sub(prev);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/ShufUtils.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary ShufUtils {\r\n    function takeFee(uint256 _a) internal pure returns (uint256) {\r\n        if (_a == 1) {\r\n            return 1;\r\n        }\r\n\r\n        uint256 fee = _a / 100;\r\n        if (_a % 100 != 0) {\r\n            fee = fee + 1;\r\n        }\r\n\r\n        return _a - (fee * 2);\r\n    }\r\n\r\n    function untakeFee(uint256 _a) internal pure returns (uint256) {\r\n        if (_a == 1) {\r\n            return 1;\r\n        }\r\n\r\n        uint256 aux = _a / 49;\r\n        if (aux % 2 == 0) {\r\n            aux = _a + aux;\r\n            if (aux % 100 == 0) {\r\n                return aux;\r\n            } else {\r\n                return aux + 2;\r\n            }\r\n        } else {\r\n            return _a + aux + 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/DefswapExchange.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DefswapExchange is IDefswapExchange, ERC20, ReentrancyGuard {\r\n    using SafeDefERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 private p_base;\r\n    IERC20 private p_token;\r\n    IUniswapExchange private p_uniswap;\r\n\r\n    string private constant SYMBOL_PREFIX = \"SHUF-\";\r\n    string private constant NAME_SUFIX = \" - defswap.io pooled\";\r\n    uint256 private constant DECIMALS = 18;\r\n\r\n    event AddLiquidity(address indexed _provider, uint256 _baseAmount, uint256 _tokenAmount, uint256 _minted);\r\n    event RemoveLiquidity(address indexed _provider, uint256 _baseAmount, uint256 _tokenAmount, uint256 _burned);\r\n    event TokenPurchase(address indexed _buyer, uint256 _baseSold, uint256 _tokensBought, address _recipient);\r\n    event BasePurchase(address indexed _buyer, uint256 _tokensSold, uint256 _baseBought, address _recipient);\r\n\r\n    constructor(IERC20 _base, IERC20 _token, IUniswapExchange _uniswap) public {\r\n        require(_uniswap.tokenAddress() == address(_base), \"defswap: uniswap token doesn't match\");\r\n        require(address(_base) != address(_token), \"defswap: token and base can't be the same\");\r\n\r\n        p_base = _base;\r\n        p_token = _token;\r\n        p_uniswap = _uniswap;\r\n\r\n        approveUniswap();\r\n        buildMetadata();\r\n    }\r\n\r\n    function approveUniswap() public nonReentrant {\r\n        p_base.approve(\r\n            address(p_uniswap),\r\n            uint(-1)\r\n        );\r\n    }\r\n\r\n    function buildMetadata() public nonReentrant {\r\n        address token = address(p_token);\r\n        require(gasleft() >= 402000, \"defswap: gasleft build metadata is not enough\");\r\n\r\n        (\r\n            bool successName,\r\n            bytes memory name\r\n        ) = token.call.gas(200000)(\r\n            abi.encodeWithSelector(p_token.name.selector)\r\n        );\r\n\r\n        (\r\n            bool successSymbol,\r\n            bytes memory symbol\r\n        ) = token.call.gas(200000)(\r\n            abi.encodeWithSelector(p_token.symbol.selector)\r\n        );\r\n\r\n        _setMetadata(\r\n            string(abi.encodePacked(SYMBOL_PREFIX, successSymbol ? abi.decode(symbol, (string)) : \"???\")),\r\n            string(abi.encodePacked(successName ? abi.decode(name, (string)) : \"Unknown\", NAME_SUFIX)),\r\n            DECIMALS\r\n        );\r\n    }\r\n\r\n    function base() external view returns (IERC20) {\r\n        return p_base;\r\n    }\r\n\r\n    function token() external view returns (IERC20) {\r\n        return p_token;\r\n    }\r\n\r\n    function uniswap() external view returns (IUniswapExchange) {\r\n        return p_uniswap;\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 _tokens,\r\n        uint256 _maxBase\r\n    ) external nonReentrant returns (uint256 minted) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _tokens);\r\n        uint256 pulled;\r\n        require(received != 0, \"defswap: pull zero tokens is not allowed\");\r\n\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        if (t_totalSupply == 0) {\r\n            require(t_base.transferFrom(msg.sender, address(this), _maxBase), \"defswap: error pulling base tokens\");\r\n            minted = ShufUtils.takeFee(_maxBase);\r\n        } else {\r\n            // TODO Check received\r\n            uint256 tokenReserve = t_token.balanceOf(address(this)).sub(received);\r\n            uint256 baseReserve = t_base.balanceOf(address(this));\r\n            uint256 requiredPull = received.mul(baseReserve).divRound(tokenReserve);\r\n\r\n            pulled = t_base.safeTransferFrom(msg.sender, address(this), ShufUtils.untakeFee(requiredPull));\r\n            require(pulled <= _maxBase, \"defswap: _maxBase is below of pulled required\");\r\n            require(pulled >= requiredPull, \"defswap: pulled base is not enough\");\r\n\r\n            minted = pulled.mul(t_totalSupply).div(baseReserve);\r\n        }\r\n\r\n        emit AddLiquidity(msg.sender, pulled, received, minted);\r\n        _mint(msg.sender, minted);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        uint256 _minBase,\r\n        uint256 _minTokens\r\n    ) external nonReentrant returns (\r\n        uint256 baseAmount,\r\n        uint256 tokenAmount\r\n    ) {\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        require(t_totalSupply != 0, \"defswap: pool is empty\");\r\n\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        baseAmount = _amount.mul(baseReserve) / t_totalSupply;\r\n        tokenAmount = _amount.mul(tokenReserve) / t_totalSupply;\r\n\r\n        require(ShufUtils.takeFee(baseAmount) >= _minBase, \"defswap: baseAmount is below _minBase\");\r\n\r\n        emit RemoveLiquidity(msg.sender, baseAmount, tokenAmount, _amount);\r\n        _burn(msg.sender, _amount);\r\n\r\n        require(t_token.safeTransfer(msg.sender, tokenAmount) >= _minTokens, \"defswap: tokenAmount is below _minTokens\");\r\n        t_base.transferWithFee(msg.sender, baseAmount); // t_base is trusted\r\n    }\r\n\r\n    function removeBaseLiquidity(\r\n        uint256 _amount,\r\n        uint256 _minBase\r\n    ) external nonReentrant returns (\r\n        uint256 baseAmount\r\n    ) {\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        require(t_totalSupply != 0, \"defswap: pool is empty\");\r\n\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        baseAmount = _amount.mul(baseReserve) / t_totalSupply;\r\n\r\n        require(ShufUtils.takeFee(baseAmount) >= _minBase, \"defswap: baseAmount is below _minBase\");\r\n\r\n        emit RemoveLiquidity(msg.sender, baseAmount, 0, _amount);\r\n        _burn(msg.sender, _amount);\r\n\r\n        t_base.transferWithFee(msg.sender, baseAmount); // t_base is trusted\r\n    }\r\n\r\n    function removeTokenLiquidity(\r\n        uint256 _amount,\r\n        uint256 _minTokens\r\n    ) external nonReentrant returns (\r\n        uint256 tokenAmount\r\n    ) {\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        require(t_totalSupply != 0, \"defswap: pool is empty\");\r\n\r\n        IERC20 t_token = p_token;\r\n\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n\r\n        tokenAmount = _amount.mul(tokenReserve) / t_totalSupply;\r\n\r\n        emit RemoveLiquidity(msg.sender, 0, tokenAmount, _amount);\r\n        _burn(msg.sender, _amount);\r\n\r\n        require(t_token.safeTransfer(msg.sender, tokenAmount) >= _minTokens, \"defswap: tokenAmount is below _minTokens\");\r\n    }\r\n\r\n    function getBaseToTokenPrice(uint256 _baseSold) external view returns (uint256 tokensBought) {\r\n        return _getInputPrice(_baseSold, p_base.balanceOf(address(this)), p_token.balanceOf(address(this)));\r\n    }\r\n\r\n    function getTokenToBasePrice(uint256 _tokenSold) external view returns (uint256 baseBought) {\r\n        return _getInputPrice(_tokenSold, p_token.balanceOf(address(this)), p_base.balanceOf(address(this)));\r\n    }\r\n\r\n    function ethToTokenSwapInput(\r\n        uint256 _minTokens\r\n    ) external nonReentrant payable returns (uint256 bought) {\r\n        uint256 baseBought = msg.value != 0 ? ShufUtils.takeFee(\r\n            p_uniswap.ethToTokenSwapInput.value(msg.value)(1, uint(-1))\r\n        ) : 0;\r\n\r\n        bought = _baseToToken(\r\n            p_base,\r\n            p_token,\r\n            baseBought,\r\n            _minTokens,\r\n            msg.sender,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function ethToTokenTransferInput(\r\n        uint256 _minTokens,\r\n        address _recipient\r\n    ) external nonReentrant payable returns (uint256 bought) {\r\n        uint256 baseBought = msg.value != 0 ? ShufUtils.takeFee(\r\n            p_uniswap.ethToTokenSwapInput.value(msg.value)(1, uint(-1))\r\n        ) : 0;\r\n\r\n        bought = _baseToToken(\r\n            p_base,\r\n            p_token,\r\n            baseBought,\r\n            _minTokens,\r\n            msg.sender,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    // Uniswap exchange compat\r\n    function ethToTokenTransferInput(\r\n        uint256 _minTokens,\r\n        uint256 _deadline,\r\n        address _recipient\r\n    ) external nonReentrant payable returns (uint256 bought) {\r\n        require(_deadline >= block.timestamp, \"defswap: expired transaction\");\r\n\r\n        uint256 baseBought = msg.value != 0 ? ShufUtils.takeFee(\r\n            p_uniswap.ethToTokenSwapInput.value(msg.value)(1, uint(-1))\r\n        ) : 0;\r\n\r\n        bought = _baseToToken(\r\n            p_base,\r\n            p_token,\r\n            baseBought,\r\n            _minTokens,\r\n            msg.sender,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    function baseToTokenSwapInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_base = p_base;\r\n\r\n        t_base.transferFromWithFee(msg.sender, address(this), _amount);\r\n\r\n        bought = _baseToToken(\r\n            t_base,\r\n            p_token,\r\n            ShufUtils.takeFee(_amount),\r\n            _minTokens,\r\n            msg.sender,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function baseToTokenTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _recipient\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_base = p_base;\r\n\r\n        t_base.transferFromWithFee(msg.sender, address(this), _amount);\r\n\r\n        bought = _baseToToken(\r\n            t_base,\r\n            p_token,\r\n            ShufUtils.takeFee(_amount),\r\n            _minTokens,\r\n            msg.sender,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    function tokenToEthSwapInput(\r\n        uint256 _amount,\r\n        uint256 _minEth\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 amount = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 baseBought = ShufUtils.takeFee(\r\n            _tokenToBase(\r\n                t_base,\r\n                t_token,\r\n                amount,\r\n                0,\r\n                msg.sender,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        bought = baseBought != 0 ? p_uniswap.tokenToEthTransferInput(\r\n            baseBought,\r\n            1,\r\n            uint(-1),\r\n            msg.sender\r\n        ) : 0;\r\n\r\n        require(bought >= _minEth, \"defswap: eth bought is below _minEth\");\r\n    }\r\n\r\n    function tokenToEthTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minEth,\r\n        address _recipient\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 amount = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 baseBought = ShufUtils.takeFee(\r\n            _tokenToBase(\r\n                t_base,\r\n                t_token,\r\n                amount,\r\n                0,\r\n                msg.sender,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        bought = baseBought != 0 ? p_uniswap.tokenToEthTransferInput(\r\n            baseBought,\r\n            1,\r\n            uint(-1),\r\n            _recipient\r\n        ) : 0;\r\n\r\n        require(bought >= _minEth, \"defswap: eth bought is below _minEth\");\r\n    }\r\n\r\n    function tokenToEthExchangeTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _recipient,\r\n        address _exchangeAddr\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 amount = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 baseBought = ShufUtils.takeFee(\r\n            _tokenToBase(\r\n                t_base,\r\n                t_token,\r\n                amount,\r\n                0,\r\n                msg.sender,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        uint256 ethBought = baseBought != 0 ? p_uniswap.tokenToEthSwapInput(\r\n            baseBought,\r\n            1,\r\n            uint(-1)\r\n        ) : 0;\r\n\r\n        bought = ethBought != 0 ? IUniswapExchange(_exchangeAddr).ethToTokenTransferInput.value(\r\n            ethBought\r\n        )(\r\n            1, uint(-1), _recipient\r\n        ) : 0;\r\n\r\n        require(bought >= _minTokens, \"defswap: tokens bought is below _minTokens\");\r\n    }\r\n\r\n    function tokenToBaseSwapInput(\r\n        uint256 _amount,\r\n        uint256 _minBase\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 amount = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        bought = _tokenToBase(\r\n            t_base,\r\n            t_token,\r\n            amount,\r\n            _minBase,\r\n            msg.sender,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function tokenToBaseTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minBase,\r\n        address _recipient\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 amount = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        bought = _tokenToBase(\r\n            t_base,\r\n            t_token,\r\n            amount,\r\n            _minBase,\r\n            msg.sender,\r\n            _recipient\r\n        );\r\n    }\r\n\r\n    function tokenToBaseExchangeTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _recipient,\r\n        address _exchangeAddr\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        require(_exchangeAddr != address(p_uniswap), \"defswap: _exchange can't be Uniswap\");\r\n\r\n        // Convert amount tokens to base\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        uint256 amount = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        uint256 baseBought = _getInputPrice(amount, tokenReserve.sub(amount), baseReserve);\r\n        emit BasePurchase(msg.sender, amount, baseBought, address(this));\r\n\r\n        // Trade base to tokens using exchange\r\n        t_base.approve(_exchangeAddr, baseBought);\r\n        bought = IDefswapExchange(_exchangeAddr).baseToTokenTransferInput(\r\n            baseBought,\r\n            _minTokens,\r\n            _recipient\r\n        );\r\n\r\n        t_base.approve(_exchangeAddr, 0);\r\n    }\r\n\r\n    function _getInputPrice(\r\n        uint256 _inputAmount,\r\n        uint256 _inputReserve,\r\n        uint256 _outputReserve\r\n    ) private pure returns (uint256) {\r\n        require(_inputReserve != 0 && _outputReserve != 0, \"defswap: one reserve is empty\");\r\n        uint256 inputAmountWithFee = _inputAmount.mul(997);\r\n        uint256 numerator = inputAmountWithFee.mul(_outputReserve);\r\n        uint256 denominator = _inputReserve.mul(1000).add(inputAmountWithFee);\r\n        return numerator / denominator;\r\n    }\r\n\r\n    function _baseToToken(\r\n        IERC20 t_base,\r\n        IERC20 t_token,\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _buyer,\r\n        address _recipient\r\n    ) private returns (uint256 tokensBought) {\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        tokensBought = _getInputPrice(_amount, baseReserve.sub(_amount), tokenReserve);\r\n        require(tokensBought >= _minTokens, \"defswap: bought tokens below _minTokens\");\r\n        require(t_token.safeTransfer(_recipient, tokensBought) != 0 || tokensBought == 0, \"defswap: error sending tokens\");\r\n\r\n        emit TokenPurchase(_buyer, _amount, tokensBought, _recipient);\r\n    }\r\n\r\n    function _tokenToBase(\r\n        IERC20 t_base,\r\n        IERC20 t_token,\r\n        uint256 _amount,\r\n        uint256 _minBase,\r\n        address _buyer,\r\n        address _recipient\r\n    ) private returns (uint256 baseBought) {\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        baseBought = _getInputPrice(_amount, tokenReserve.sub(_amount), baseReserve);\r\n        require(baseBought >= _minBase, \"defswap: bought base below _minBase\");\r\n        t_base.transferWithFee(_recipient, baseBought);\r\n\r\n        emit BasePurchase(_buyer, _amount, baseBought, _recipient);\r\n    }\r\n\r\n    function() external payable {\r\n        require(msg.sender != tx.origin, \"defswap: ETH rejected\");\r\n    }\r\n}\r\n\r\n// File: contracts/DefswapFactory.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DefswapFactory {\r\n    using IsContract for address;\r\n\r\n    IUniswapExchange public uniswap;\r\n    IERC20 public base;\r\n\r\n    event CreatedExchange(address indexed _token, address indexed _exchange);\r\n\r\n    address[] private p_tokens;\r\n    mapping(address => address) public tokenToExchange;\r\n    mapping(address => address) public exchangeToToken;\r\n\r\n    constructor(IERC20 _base, IUniswapExchange _uniswap) public {\r\n        require(_uniswap.tokenAddress() == address(_base), \"defswap-factory: uniswap token doesn't match\");\r\n\r\n        base = _base;\r\n        uniswap = _uniswap;\r\n    }\r\n\r\n    function getToken(uint256 _i) external view returns (address) {\r\n        require(_i < p_tokens.length, \"defswap-factory: array out of bounds\");\r\n        return p_tokens[_i];\r\n    }\r\n\r\n    function getExchange(uint256 _i) external view returns (address) {\r\n        require(_i < p_tokens.length, \"defswap-factory: array out of bounds\");\r\n        return tokenToExchange[p_tokens[_i]];\r\n    }\r\n\r\n    function createExchange(address _token) external returns (address exchange) {\r\n        require(tokenToExchange[_token] == address(0), \"defswap-factory: exchange already exists\");\r\n        require(_token.isContract(), \"defswap-factory: _token has to be a contract\");\r\n\r\n        exchange = address(\r\n            new DefswapExchange(\r\n                base,\r\n                IERC20(_token),\r\n                uniswap\r\n            )\r\n        );\r\n\r\n        emit CreatedExchange(_token, exchange);\r\n\r\n        tokenToExchange[_token] = exchange;\r\n        exchangeToToken[exchange] = _token;\r\n        p_tokens.push(_token);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapExchange\",\"name\":\"_uniswap\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minted\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"BasePurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_burned\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBase\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveUniswap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"baseToTokenSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"baseToTokenTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buildMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"ethToTokenSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"ethToTokenTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"ethToTokenTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseSold\",\"type\":\"uint256\"}],\"name\":\"getBaseToTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenSold\",\"type\":\"uint256\"}],\"name\":\"getTokenToBasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBase\",\"type\":\"uint256\"}],\"name\":\"removeBaseLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"removeTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeAddr\",\"type\":\"address\"}],\"name\":\"tokenToBaseExchangeTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBase\",\"type\":\"uint256\"}],\"name\":\"tokenToBaseSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBase\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"tokenToBaseTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeAddr\",\"type\":\"address\"}],\"name\":\"tokenToEthExchangeTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minEth\",\"type\":\"uint256\"}],\"name\":\"tokenToEthSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minEth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"tokenToEthTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wad\",\"type\":\"uint256\"}],\"name\":\"transferFromWithFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wad\",\"type\":\"uint256\"}],\"name\":\"transferWithFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract IUniswapExchange\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DefswapExchange","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003a9fff453d50d4ac52a6890647b823379ba36b9e000000000000000000000000e7bf3aee922367c10c8acec3793fe7d809a38eef000000000000000000000000536956fab86774fb55cfaacf496bc25e4d2b435c","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://20298f7cb68e53f4aacdfaaea388bb35d91d92752e358200dbe857552d47fa85"}]}