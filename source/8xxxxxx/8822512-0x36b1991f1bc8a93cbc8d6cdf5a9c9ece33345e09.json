{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity > 0.5.2 < 0.6.0;\r\n\r\ncontract MultiSig {\r\n    // Addresses of the MultiSig representatives\r\n    address private addr1;\r\n    address private addr2;\r\n    address private addr3;\r\n\r\n    // Address of the contract that manages the tokens\r\n    address private tokenContract;\r\n    \r\n    // This is necessary to detect malleable signatures.\r\n    uint256 constant HALF_CURVE_ORDER = uint256(0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0);\r\n    \r\n    /**\r\n     * Signatures must not be used twice. Therefore, they need to contain a unique\r\n     * value. These nonces need to be stored such that an additional usage is detectable.\r\n     */\r\n    mapping (bytes32 => bool) public nonces;\r\n    \r\n    /**\r\n     * @param _addr1 first authorized representative\r\n     * @param _addr2 second authorized representative\r\n     * @param _addr3 third authorized representative\r\n     * @param _tokenContract address of the contract that manages the tokens\r\n     */\r\n    constructor(address _addr1, address _addr2, address _addr3, address _tokenContract) public {\r\n        require(_addr1 != _addr2 && _addr2 != _addr3 && _addr1 != _addr3, 'MultiSig representatives must not be the same.');\r\n\r\n        addr1 = _addr1;\r\n        addr2 = _addr2;\r\n        addr3 = _addr3;\r\n\r\n        tokenContract = _tokenContract;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the signature of the transaction and the co-signature come from the expected addresses. If that\r\n     * is the case, deploy a smart contract at a precomputable address that transfers `amount` tokens from itselfs balance\r\n     * to `to`.\r\n     *\r\n     * @param amount how much token should be transferred\r\n     * @param sender address of the token sender\r\n     * @param to address of the token receiver\r\n     * @param r first part of the co-signature\r\n     * @param s second part of the co-signature\r\n     * @param v recovery value of the co-signature\r\n     */\r\n    function claim(uint256 amount, address sender, address to, bytes32 r, bytes32 s, uint8 v, bytes32 salt) public {\r\n        checkSignature(amount, sender, to, r, s, v);\r\n        \r\n        deploy(salt, sender, to, amount);\r\n    }\r\n    \r\n    /**\r\n     * Checks whether the signature of the transaction comes from one of the expected addresses. It also checks\r\n     * whether the given co-signature comes from one of the expected addresses, excluding the address of the \r\n     * transaction sender.\r\n     *\r\n     * @param amount the amount of assets that are transferred\r\n     * @param sender address of the token sender\r\n     * @param to address of the token receiver\r\n     * @param r first part of the co-signature\r\n     * @param s second part of the co-signature\r\n     * @param v recovery value of the co-signature\r\n     */\r\n    function checkSignature(uint256 amount, address sender, address to, bytes32 r, bytes32 s, uint8 v) internal {\r\n        require(msg.sender == addr1 || msg.sender == addr2 || msg.sender == addr3, \"Invalid signer.\");\r\n\r\n        require(uint256(s) <= HALF_CURVE_ORDER, \"Found malleable signature. Please insert a low-s signature.\");\r\n        \r\n        bytes32 msgString = keccak256(abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n96\",\r\n            tokenContract,\r\n            bytes4(keccak256(\"transfer(address,uint256)\")),\r\n            sender,\r\n            to,\r\n            amount\r\n        ));\r\n        \r\n        address signer = ecrecover(msgString, v, r, s);\r\n\r\n        require(signer != msg.sender, \"Cosigner and signer must not be the same.\");\r\n\r\n        require(signer == addr1 || signer == addr2 || signer == addr3, \"Invalid co-signer.\");\r\n\r\n        require(!nonces[msgString], \"Nonce was already used.\");\r\n        nonces[msgString] = true;\r\n    }\r\n    \r\n    /**\r\n     * This deploys a smart contract which checks that `msg.sender == address()` where `address()` is the\r\n     * address of this contract. The newly deployed smart contract then transfers `amount` tokens that are\r\n     * stored in `tokenContract` to `to`.\r\n     * Afterwards, the newly created contract triggers a self-destroy to save gas.\r\n     *\r\n     * @param salt used as user identifier to make contracts unique\r\n     * @param to address of the receiver\r\n     * @param amount amount of tokens that are transferred\r\n     */\r\n    function deploy(bytes32 salt, address sender, address to, uint256 amount) internal {\r\n        bytes memory result = new bytes(273);\r\n        address addr;\r\n\r\n        assembly {\r\n            let bytecode := add(result, 0x20)\r\n            \r\n            mstore(add(bytecode, 0),  0x608060405234801561001057600080fd5b5060f28061001f6000396000f3fe60) // 32 bytes\r\n            mstore(add(bytecode, 32),  0x80604052348015600f57600080fd5b506004361060285760003560e01c8063a9) // 32 bytes\r\n            mstore(add(bytecode, 64),  0x059cbb14602d575b600080fd5b605660048036036040811015604157600080fd) // 32 bytes\r\n            mstore(add(bytecode, 96),  0x5b506001600160a01b0381351690602001356058565b005b7300000000000000) // 25 bytes\r\n\r\n            mstore(add(bytecode, 121), shl(96, address())) // 20 bytes\r\n\r\n            mstore(add(bytecode, 141), 0x803314607857600080fd5b730000000000000000000000000000000000000000) // 12 bytes\r\n\r\n            mstore(add(bytecode, 153), shl(96, sload(tokenContract_slot))) // 20 bytes\r\n\r\n            mstore(add(bytecode, 173), 0x60405163a9059cbb60e01b815284600482015283602482015260008060448360) // 32 bytes\r\n            mstore(add(bytecode, 205), 0x00865af18060ba57600080fd5b83fffea265627a7a72305820a57bc3e7ae7d2e) // 32 bytes\r\n            mstore(add(bytecode, 237), 0xb2dbb60e9abedab864f8ff1848db33ef2cec7a159a1793027864736f6c634300) // 32 bytes\r\n            mstore(add(bytecode, 269), 0x0509003200000000000000000000000000000000000000000000000000000000) // 32 bytes\r\n            \r\n            // creates a new contract at a counterfactual address.\r\n            // see http://eips.ethereum.org/EIPS/eip-1014 for more information\r\n            // and https://github.com/miguelmota/solidity-create2-example for a PoC\r\n            addr := create2(0, bytecode, 273, salt)\r\n            \r\n            if iszero(eq(addr, sender)) {\r\n                revert(0,0)\r\n            }\r\n\r\n            mstore(bytecode, shl(224, 0xa9059cbb))\r\n            mstore(add(bytecode, 4), to)\r\n            mstore(add(bytecode, 36), amount)\r\n            \r\n            // Revert if not successful\r\n            if iszero(call(gas(), addr, 0, bytecode, 68, 0, 0)) {\r\n                revert(0,0)\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addr1\",\"type\":\"address\"},{\"name\":\"_addr2\",\"type\":\"address\"},{\"name\":\"_addr3\",\"type\":\"address\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MultiSig","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000011e0b4e6cd3340e30e55f165c8d0d633fd1d3706000000000000000000000000e35942494f9e3e4293e61cc6fa25e3f87d5ff587000000000000000000000000a88974b0fb33f52b23557427fa7d4c0143df68c9000000000000000000000000d780ae2bf04cd96e577d3d014762f831d97129d0","Library":"","LicenseType":"None","SwarmSource":"bzzr://64a39c4e95a9d34d19b0deefcd9da89265d274bd722baa90ec1b41d852a66b95"}]}