{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.3<0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Just inlining part of the standard ERC20 contract\r\ninterface ERC20Token {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title Staking is a contract to support locking and releasing ERC-20 tokens\r\n * for the purposes of staking.\r\n */\r\ncontract Staking {\r\n    struct PendingDeposit {\r\n        address depositor;\r\n        uint256 amount;\r\n    }\r\n\r\n    address public _owner;\r\n    address public _authorizedNewOwner;\r\n    address public _tokenAddress;\r\n\r\n    address public _withdrawalPublisher;\r\n    address public _fallbackPublisher;\r\n    uint256 public _fallbackWithdrawalDelaySeconds = 1 weeks;\r\n\r\n    // 1% of total supply\r\n    uint256 public _immediatelyWithdrawableLimit = 100_000 * (10**18);\r\n    address public _immediatelyWithdrawableLimitPublisher;\r\n\r\n    uint256 public _depositNonce = 0;\r\n    mapping(uint256 => PendingDeposit) public _nonceToPendingDeposit;\r\n\r\n    uint256 public _maxWithdrawalRootNonce = 0;\r\n    mapping(bytes32 => uint256) public _withdrawalRootToNonce;\r\n    mapping(address => uint256) public _addressToWithdrawalNonce;\r\n    mapping(address => uint256) public _addressToCumulativeAmountWithdrawn;\r\n\r\n    bytes32 public _fallbackRoot;\r\n    uint256 public _fallbackMaxDepositIncluded = 0;\r\n    uint256 public _fallbackSetDate = 2**200;\r\n\r\n    event WithdrawalRootHashAddition(\r\n        bytes32 indexed rootHash,\r\n        uint256 indexed nonce\r\n    );\r\n\r\n    event WithdrawalRootHashRemoval(\r\n        bytes32 indexed rootHash,\r\n        uint256 indexed nonce\r\n    );\r\n\r\n    event FallbackRootHashSet(\r\n        bytes32 indexed rootHash,\r\n        uint256 indexed maxDepositNonceIncluded,\r\n        uint256 setDate\r\n    );\r\n\r\n    event Deposit(\r\n        address indexed depositor,\r\n        uint256 indexed amount,\r\n        uint256 indexed nonce\r\n    );\r\n\r\n    event Withdrawal(\r\n        address indexed toAddress,\r\n        uint256 indexed amount,\r\n        uint256 indexed rootNonce,\r\n        uint256 authorizedAccountNonce\r\n    );\r\n\r\n    event FallbackWithdrawal(\r\n        address indexed toAddress,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    event PendingDepositRefund(\r\n        address indexed depositorAddress,\r\n        uint256 indexed amount,\r\n        uint256 indexed nonce\r\n    );\r\n\r\n    event RenounceWithdrawalAuthorization(\r\n        address indexed forAddress\r\n    );\r\n\r\n    event FallbackWithdrawalDelayUpdate(\r\n        uint256 indexed oldValue,\r\n        uint256 indexed newValue\r\n    );\r\n\r\n    event FallbackMechanismDateReset(\r\n        uint256 indexed newDate\r\n    );\r\n\r\n    event ImmediatelyWithdrawableLimitUpdate(\r\n        uint256 indexed oldValue,\r\n        uint256 indexed newValue\r\n    );\r\n\r\n    event OwnershipTransferAuthorization(\r\n        address indexed authorizedAddress\r\n    );\r\n\r\n    event OwnerUpdate(\r\n        address indexed oldValue,\r\n        address indexed newValue\r\n    );\r\n\r\n    event FallbackPublisherUpdate(\r\n        address indexed oldValue,\r\n        address indexed newValue\r\n    );\r\n\r\n    event WithdrawalPublisherUpdate(\r\n        address indexed oldValue,\r\n        address indexed newValue\r\n    );\r\n\r\n    event ImmediatelyWithdrawableLimitPublisherUpdate(\r\n        address indexed oldValue,\r\n        address indexed newValue\r\n    );\r\n\r\n    constructor(\r\n        address tokenAddress,\r\n        address fallbackPublisher,\r\n        address withdrawalPublisher,\r\n        address immediatelyWithdrawableLimitPublisher\r\n    ) public {\r\n        _owner = msg.sender;\r\n        _fallbackPublisher = fallbackPublisher;\r\n        _withdrawalPublisher = withdrawalPublisher;\r\n        _immediatelyWithdrawableLimitPublisher = immediatelyWithdrawableLimitPublisher;\r\n        _tokenAddress = tokenAddress;\r\n    }\r\n\r\n    /********************\r\n     * STANDARD ACTIONS *\r\n     ********************/\r\n\r\n    /**\r\n     * @notice Deposits the provided amount of FXC from the message sender into this wallet.\r\n     * Note: The sending address must own the provided amount of FXC to deposit, and\r\n     * the sender must have indicated to the FXC ERC-20 contract that this contract is\r\n     * allowed to transfer at least the provided amount from its address.\r\n     *\r\n     * @param amount The amount to deposit.\r\n     * @return The deposit nonce for this deposit. This can be useful in calling\r\n     * refundPendingDeposit(...).\r\n     */\r\n    function deposit(uint256 amount) external returns(uint256) {\r\n        require(\r\n            amount > 0,\r\n            \"Cannot deposit 0\"\r\n        );\r\n\r\n        _depositNonce = SafeMath.add(_depositNonce, 1);\r\n        _nonceToPendingDeposit[_depositNonce].depositor = msg.sender;\r\n        _nonceToPendingDeposit[_depositNonce].amount = amount;\r\n\r\n        emit Deposit(\r\n            msg.sender,\r\n            amount,\r\n            _depositNonce\r\n        );\r\n\r\n        bool transferred = ERC20Token(_tokenAddress).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        require(transferred, \"Transfer failed\");\r\n        \r\n        return _depositNonce;\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates that this address would not like its withdrawable\r\n     * funds to be available for withdrawal. This will prevent withdrawal\r\n     * for this address until the next withdrawal root is published.\r\n     *\r\n     * Note: The caller does not need to know or prove the details of the current\r\n     * withdrawal authorization in order to renounce it.\r\n     * @param forAddress The address for which the withdrawal is being renounced.\r\n     */\r\n    function renounceWithdrawalAuthorization(address forAddress) external {\r\n        require(\r\n            msg.sender == _owner ||\r\n            msg.sender == _withdrawalPublisher ||\r\n            msg.sender == forAddress,\r\n            \"Only the owner, withdrawal publisher, and address in question can renounce a withdrawal authorization\"\r\n        );\r\n        require(\r\n            _addressToWithdrawalNonce[forAddress] < _maxWithdrawalRootNonce,\r\n            \"Address nonce indicates there are no funds withdrawable\"\r\n        );\r\n        _addressToWithdrawalNonce[forAddress] = _maxWithdrawalRootNonce;\r\n        emit RenounceWithdrawalAuthorization(forAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a previously authorized token withdrawal.\r\n     * @param toAddress The address to which the tokens are to be transferred.\r\n     * @param amount The amount of tokens to be withdrawn.\r\n     * @param maxAuthorizedAccountNonce The maximum authorized account nonce for the withdrawing\r\n     * address encoded within the withdrawal authorization. Prevents double-withdrawals.\r\n     * @param merkleProof The Merkle tree proof associated with the withdrawal\r\n     * authorization.\r\n     */\r\n    function withdraw(\r\n        address toAddress,\r\n        uint256 amount,\r\n        uint256 maxAuthorizedAccountNonce,\r\n        bytes32[] calldata merkleProof\r\n    ) external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == toAddress,\r\n            \"Only the owner or recipient can execute a withdrawal\"\r\n        );\r\n\r\n        require(\r\n            _addressToWithdrawalNonce[toAddress] <= maxAuthorizedAccountNonce,\r\n            \"Account nonce in contract exceeds provided max authorized withdrawal nonce for this account\"\r\n        );\r\n\r\n        require(\r\n            amount <= _immediatelyWithdrawableLimit,\r\n            \"Withdrawal would push contract over its immediately withdrawable limit\"\r\n        );\r\n\r\n        bytes32 leafDataHash = keccak256(abi.encodePacked(\r\n            toAddress,\r\n            amount,\r\n            maxAuthorizedAccountNonce\r\n        ));\r\n\r\n        bytes32 calculatedRoot = calculateMerkleRoot(merkleProof, leafDataHash);\r\n        uint256 withdrawalPermissionRootNonce = _withdrawalRootToNonce[calculatedRoot];\r\n\r\n        require(\r\n            withdrawalPermissionRootNonce > 0,\r\n            \"Root hash unauthorized\");\r\n        require(\r\n            withdrawalPermissionRootNonce > maxAuthorizedAccountNonce,\r\n            \"Encoded nonce not greater than max last authorized nonce for this account\"\r\n        );\r\n\r\n        _immediatelyWithdrawableLimit -= amount; // amount guaranteed <= _immediatelyWithdrawableLimit\r\n        _addressToWithdrawalNonce[toAddress] = withdrawalPermissionRootNonce;\r\n        _addressToCumulativeAmountWithdrawn[toAddress] = SafeMath.add(amount, _addressToCumulativeAmountWithdrawn[toAddress]);\r\n\r\n        emit Withdrawal(\r\n            toAddress,\r\n            amount,\r\n            withdrawalPermissionRootNonce,\r\n            maxAuthorizedAccountNonce\r\n        );\r\n\r\n        bool transferred = ERC20Token(_tokenAddress).transfer(\r\n            toAddress,\r\n            amount\r\n        );\r\n\r\n        require(transferred, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a fallback withdrawal transfer.\r\n     * @param toAddress The address to which the tokens are to be transferred.\r\n     * @param maxCumulativeAmountWithdrawn The lifetime withdrawal limit that this address is\r\n     * subject to. This is encoded within the fallback authorization to prevent regular \r\n     * withdrawal / fallback withdrawal double-spends\r\n     * @param merkleProof The Merkle tree proof associated with the withdrawal authorization.\r\n     */\r\n    function withdrawFallback(\r\n        address toAddress,\r\n        uint256 maxCumulativeAmountWithdrawn,\r\n        bytes32[] calldata merkleProof\r\n    ) external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == toAddress,\r\n            \"Only the owner or recipient can execute a fallback withdrawal\"\r\n        );\r\n        require(\r\n            SafeMath.add(_fallbackSetDate, _fallbackWithdrawalDelaySeconds) <= block.timestamp,\r\n            \"Fallback withdrawal period is not active\"\r\n        );\r\n        require(\r\n            _addressToCumulativeAmountWithdrawn[toAddress] < maxCumulativeAmountWithdrawn,\r\n            \"Withdrawal not permitted when amount withdrawn is at lifetime withdrawal limit\"\r\n        );\r\n\r\n        bytes32 msgHash = keccak256(abi.encodePacked(\r\n            toAddress,\r\n            maxCumulativeAmountWithdrawn\r\n        ));\r\n\r\n        bytes32 calculatedRoot = calculateMerkleRoot(merkleProof, msgHash);\r\n        require(\r\n            _fallbackRoot == calculatedRoot,\r\n            \"Root hash unauthorized\"\r\n        );\r\n\r\n        // If user is triggering fallback withdrawal, invalidate all existing regular withdrawals\r\n        _addressToWithdrawalNonce[toAddress] = _maxWithdrawalRootNonce;\r\n\r\n        // _addressToCumulativeAmountWithdrawn[toAddress] guaranteed < maxCumulativeAmountWithdrawn\r\n        uint256 withdrawalAmount = maxCumulativeAmountWithdrawn - _addressToCumulativeAmountWithdrawn[toAddress];\r\n        _addressToCumulativeAmountWithdrawn[toAddress] = maxCumulativeAmountWithdrawn;\r\n        \r\n        emit FallbackWithdrawal(\r\n            toAddress,\r\n            withdrawalAmount\r\n        );\r\n\r\n        bool transferred = ERC20Token(_tokenAddress).transfer(\r\n            toAddress,\r\n            withdrawalAmount\r\n        );\r\n\r\n        require(transferred, \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Refunds a pending deposit for the provided address, refunding the pending funds.\r\n     * This may only take place if the fallback withdrawal period has lapsed.\r\n     * @param depositNonce The deposit nonce uniquely identifying the deposit to cancel\r\n     */\r\n    function refundPendingDeposit(uint256 depositNonce) external {\r\n        address depositor = _nonceToPendingDeposit[depositNonce].depositor;\r\n        require(\r\n            msg.sender == _owner || msg.sender == depositor,\r\n            \"Only the owner or depositor can initiate the refund of a pending deposit\"\r\n        );\r\n        require(\r\n            SafeMath.add(_fallbackSetDate, _fallbackWithdrawalDelaySeconds) <= block.timestamp,\r\n            \"Fallback withdrawal period is not active, so refunds are not permitted\"\r\n        );\r\n        uint256 amount = _nonceToPendingDeposit[depositNonce].amount;\r\n        require(\r\n            depositNonce > _fallbackMaxDepositIncluded &&\r\n            amount > 0,\r\n            \"There is no pending deposit for the specified nonce\"\r\n        );\r\n        delete _nonceToPendingDeposit[depositNonce];\r\n\r\n        emit PendingDepositRefund(depositor, amount, depositNonce);\r\n\r\n        bool transferred = ERC20Token(_tokenAddress).transfer(\r\n            depositor,\r\n            amount\r\n        );\r\n        require(transferred, \"Transfer failed\");\r\n    }\r\n\r\n    /*****************\r\n     * ADMIN ACTIONS *\r\n     *****************/\r\n\r\n    /**\r\n     * @notice Authorizes the transfer of ownership from _owner to the provided address.\r\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership( ).\r\n     * This authorization may be removed by another call to this function authorizing\r\n     * the null address.\r\n     * @param authorizedAddress The address authorized to become the new owner.\r\n     */\r\n    function authorizeOwnershipTransfer(address authorizedAddress) external {\r\n        require(\r\n            msg.sender == _owner,\r\n            \"Only the owner can authorize a new address to become owner\"\r\n        );\r\n\r\n        _authorizedNewOwner = authorizedAddress;\r\n\r\n        emit OwnershipTransferAuthorization(_authorizedNewOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of this contract to the _authorizedNewOwner.\r\n     */\r\n    function assumeOwnership() external {\r\n        require(\r\n            msg.sender == _authorizedNewOwner,\r\n            \"Only the authorized new owner can accept ownership\"\r\n        );\r\n        address oldValue = _owner;\r\n        _owner = _authorizedNewOwner;\r\n        _authorizedNewOwner = address(0);\r\n\r\n        emit OwnerUpdate(oldValue, _owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Withdrawal Publisher address, the only address other than the\r\n     * owner that can publish / remove withdrawal Merkle tree roots.\r\n     * @param newWithdrawalPublisher The address of the new Withdrawal Publisher\r\n     */\r\n    function setWithdrawalPublisher(address newWithdrawalPublisher) external {\r\n        require(\r\n            msg.sender == _owner,\r\n            \"Only the owner can set the withdrawal publisher address\"\r\n        );\r\n        address oldValue = _withdrawalPublisher;\r\n        _withdrawalPublisher = newWithdrawalPublisher;\r\n\r\n        emit WithdrawalPublisherUpdate(oldValue, _withdrawalPublisher);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Fallback Publisher address, the only address other than\r\n     * the owner that can publish / remove fallback withdrawal Merkle tree roots.\r\n     * @param newFallbackPublisher The address of the new Fallback Publisher\r\n     */\r\n    function setFallbackPublisher(address newFallbackPublisher) external {\r\n        require(\r\n            msg.sender == _owner,\r\n            \"Only the owner can set the fallback publisher address\"\r\n        );\r\n        address oldValue = _fallbackPublisher;\r\n        _fallbackPublisher = newFallbackPublisher;\r\n\r\n        emit FallbackPublisherUpdate(oldValue, _fallbackPublisher);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Immediately Withdrawable Limit Publisher address, the only address\r\n     * other than the owner that can set the immediately withdrawable limit.\r\n     * @param newImmediatelyWithdrawableLimitPublisher The address of the new Immediately\r\n     * Withdrawable Limit Publisher\r\n     */\r\n    function setImmediatelyWithdrawableLimitPublisher(\r\n      address newImmediatelyWithdrawableLimitPublisher\r\n    ) external {\r\n        require(\r\n            msg.sender == _owner,\r\n            \"Only the owner can set the immediately withdrawable limit publisher address\"\r\n        );\r\n        address oldValue = _immediatelyWithdrawableLimitPublisher;\r\n        _immediatelyWithdrawableLimitPublisher = newImmediatelyWithdrawableLimitPublisher;\r\n\r\n        emit ImmediatelyWithdrawableLimitPublisherUpdate(\r\n          oldValue,\r\n          _immediatelyWithdrawableLimitPublisher\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Modifies the immediately withdrawable limit (the maximum amount that\r\n     * can be withdrawn from withdrawal authorization roots before the limit needs\r\n     * to be updated by Flexa) by the provided amount.\r\n     * If negative, it will be decreased, if positive, increased.\r\n     * This is to prevent contract funds from being drained by error or publisher malice.\r\n     * This does not affect the fallback withdrawal mechanism.\r\n     * @param amount amount to modify the limit by.\r\n     */\r\n    function modifyImmediatelyWithdrawableLimit(int256 amount) external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _immediatelyWithdrawableLimitPublisher,\r\n            \"Only the immediately withdrawable limit publisher and owner can modify the immediately withdrawable limit\"\r\n        );\r\n        uint256 oldLimit = _immediatelyWithdrawableLimit;\r\n\r\n        if (amount < 0) {\r\n            uint256 unsignedAmount = uint256(-amount);\r\n            _immediatelyWithdrawableLimit = SafeMath.sub(_immediatelyWithdrawableLimit, unsignedAmount);\r\n        } else {\r\n            uint256 unsignedAmount = uint256(amount);\r\n            _immediatelyWithdrawableLimit = SafeMath.add(_immediatelyWithdrawableLimit, unsignedAmount);\r\n        }\r\n\r\n        emit ImmediatelyWithdrawableLimitUpdate(oldLimit, _immediatelyWithdrawableLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the time-lock period for a fallback withdrawal to be permitted if no\r\n     * action is taken by Flexa.\r\n     * @param newFallbackDelaySeconds The new delay period in seconds.\r\n     */\r\n    function setFallbackWithdrawalDelay(uint256 newFallbackDelaySeconds) external {\r\n        require(\r\n            msg.sender == _owner,\r\n            \"Only the owner can set the fallback withdrawal delay\"\r\n        );\r\n        require(\r\n            newFallbackDelaySeconds != 0,\r\n            \"New fallback delay may not be 0\"\r\n        );\r\n\r\n        uint256 oldDelay = _fallbackWithdrawalDelaySeconds;\r\n        _fallbackWithdrawalDelaySeconds = newFallbackDelaySeconds;\r\n\r\n        emit FallbackWithdrawalDelayUpdate(oldDelay, newFallbackDelaySeconds);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds the root hash of a merkle tree containing authorized token withdrawals.\r\n     * @param root The root hash to be added to the repository.\r\n     * @param nonce The nonce of the new root hash. Must be exactly one higher\r\n     * than the existing max nonce.\r\n     * @param replacedRoots The root hashes to be removed from the repository.\r\n     */\r\n    function addWithdrawalRoot(\r\n        bytes32 root,\r\n        uint256 nonce,\r\n        bytes32[] calldata replacedRoots\r\n    ) external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _withdrawalPublisher,\r\n            \"Only the owner and withdrawal publisher can add and replace withdrawal root hashes\"\r\n        );\r\n        require(\r\n            root != 0,\r\n            \"Added root may not be 0\"\r\n        );\r\n        require(\r\n            // Overflowing uint256 by incrementing by 1 not plausible and guarded by nonce variable.\r\n            _maxWithdrawalRootNonce + 1 == nonce,\r\n            \"Nonce must be exactly max nonce + 1\"\r\n        );\r\n        require(\r\n            _withdrawalRootToNonce[root] == 0,\r\n            \"Root already exists and is associated with a different nonce\"\r\n        );\r\n\r\n        _withdrawalRootToNonce[root] = nonce;\r\n        _maxWithdrawalRootNonce = nonce;\r\n\r\n        emit WithdrawalRootHashAddition(root, nonce);\r\n\r\n        for (uint256 i = 0; i < replacedRoots.length; i++) {\r\n            deleteWithdrawalRoot(replacedRoots[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes root hashes of a merkle trees containing authorized\r\n     * token withdrawals.\r\n     * @param roots The root hashes to be removed from the repository.\r\n     */\r\n    function removeWithdrawalRoots(bytes32[] calldata roots) external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _withdrawalPublisher,\r\n            \"Only the owner and withdrawal publisher can remove withdrawal root hashes\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < roots.length; i++) {\r\n            deleteWithdrawalRoot(roots[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the _fallbackSetDate to the current block's timestamp.\r\n     * This is mainly used to deactivate the fallback mechanism so new\r\n     * fallback roots may be published.\r\n     */\r\n    function resetFallbackMechanismDate() external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _fallbackPublisher,\r\n            \"Only the owner and fallback publisher can reset fallback mechanism date\"\r\n        );\r\n\r\n        _fallbackSetDate = block.timestamp;\r\n\r\n        emit FallbackMechanismDateReset(_fallbackSetDate);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the root hash of the Merkle tree containing fallback\r\n     * withdrawal authorizations. This is used in scenarios where the contract\r\n     * owner has stopped interacting with the contract, and therefore is no\r\n     * longer honoring requests to unlock funds. After the configured fallback\r\n     * delay elapses, the withdrawal authorizations included in the supplied\r\n     * Merkle tree can be executed to recover otherwise locked funds.\r\n     * @param root The root hash to be saved as the fallback withdrawal\r\n     * authorizations.\r\n     * @param maxDepositIncluded The max deposit nonce represented in this root.\r\n     */\r\n    function setFallbackRoot(bytes32 root, uint256 maxDepositIncluded) external {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _fallbackPublisher,\r\n            \"Only the owner and fallback publisher can set the fallback root hash\"\r\n        );\r\n        require(\r\n            root != 0,\r\n            \"New root may not be 0\"\r\n        );\r\n        require(\r\n            SafeMath.add(_fallbackSetDate, _fallbackWithdrawalDelaySeconds) > block.timestamp,\r\n            \"Cannot set fallback root while fallback mechanism is active\"\r\n        );\r\n        require(\r\n            maxDepositIncluded >= _fallbackMaxDepositIncluded,\r\n            \"Max deposit included must remain the same or increase\"\r\n        );\r\n        require(\r\n            maxDepositIncluded <= _depositNonce,\r\n            \"Cannot invalidate future deposits\"\r\n        );\r\n\r\n        _fallbackRoot = root;\r\n        _fallbackMaxDepositIncluded = maxDepositIncluded;\r\n        _fallbackSetDate = block.timestamp;\r\n\r\n        emit FallbackRootHashSet(\r\n            root,\r\n            _fallbackMaxDepositIncluded,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Deletes the provided root from the collection of\r\n     * withdrawal authorization merkle tree roots, invalidating the\r\n     * withdrawals contained in the tree assocated with this root.\r\n     * @param root The root hash to delete.\r\n     */\r\n    function deleteWithdrawalRoot(bytes32 root) private {\r\n        uint256 nonce = _withdrawalRootToNonce[root];\r\n\r\n        require(\r\n            nonce > 0,\r\n            \"Root hash not set\"\r\n        );\r\n\r\n        delete _withdrawalRootToNonce[root];\r\n\r\n        emit WithdrawalRootHashRemoval(root, nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the Merkle root for the unique Merkle tree described by the provided\r\n       Merkle proof and leaf hash.\r\n     * @param merkleProof The sibling node hashes at each level of the tree.\r\n     * @param leafHash The hash of the leaf data for which merkleProof is an inclusion proof.\r\n     * @return The calculated Merkle root.\r\n     */\r\n    function calculateMerkleRoot(\r\n        bytes32[] memory merkleProof,\r\n        bytes32 leafHash\r\n    ) private pure returns (bytes32) {\r\n        bytes32 computedHash = leafHash;\r\n\r\n        for (uint256 i = 0; i < merkleProof.length; i++) {\r\n            bytes32 proofElement = merkleProof[i];\r\n\r\n            if (computedHash < proofElement) {\r\n                computedHash = keccak256(abi.encodePacked(\r\n                    computedHash,\r\n                    proofElement\r\n                ));\r\n            } else {\r\n                computedHash = keccak256(abi.encodePacked(\r\n                    proofElement,\r\n                    computedHash\r\n                ));\r\n            }\r\n        }\r\n\r\n        return computedHash;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_withdrawalPublisher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_authorizedNewOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_fallbackMaxDepositIncluded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"replacedRoots\",\"type\":\"bytes32[]\"}],\"name\":\"addWithdrawalRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_immediatelyWithdrawableLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"roots\",\"type\":\"bytes32[]\"}],\"name\":\"removeWithdrawalRoots\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_fallbackPublisher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_nonceToPendingDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_depositNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"}],\"name\":\"renounceWithdrawalAuthorization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetFallbackMechanismDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxCumulativeAmountWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_withdrawalRootToNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_fallbackSetDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositNonce\",\"type\":\"uint256\"}],\"name\":\"refundPendingDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"authorizeOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFallbackPublisher\",\"type\":\"address\"}],\"name\":\"setFallbackPublisher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFallbackDelaySeconds\",\"type\":\"uint256\"}],\"name\":\"setFallbackWithdrawalDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositIncluded\",\"type\":\"uint256\"}],\"name\":\"setFallbackRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"modifyImmediatelyWithdrawableLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAuthorizedAccountNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"assumeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_fallbackWithdrawalDelaySeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImmediatelyWithdrawableLimitPublisher\",\"type\":\"address\"}],\"name\":\"setImmediatelyWithdrawableLimitPublisher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_fallbackRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_addressToWithdrawalNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWithdrawalPublisher\",\"type\":\"address\"}],\"name\":\"setWithdrawalPublisher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_maxWithdrawalRootNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_addressToCumulativeAmountWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_immediatelyWithdrawableLimitPublisher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fallbackPublisher\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"withdrawalPublisher\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"immediatelyWithdrawableLimitPublisher\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRootHashAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRootHashRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxDepositNonceIncluded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setDate\",\"type\":\"uint256\"}],\"name\":\"FallbackRootHashSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rootNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"authorizedAccountNonce\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FallbackWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"PendingDepositRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"}],\"name\":\"RenounceWithdrawalAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"FallbackWithdrawalDelayUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"FallbackMechanismDateReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ImmediatelyWithdrawableLimitUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"OwnershipTransferAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"FallbackPublisherUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"WithdrawalPublisherUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"ImmediatelyWithdrawableLimitPublisherUpdate\",\"type\":\"event\"}]","ContractName":"Staking","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004a57e687b9126435a9b19e4a802113e266adebde00000000000000000000000005ba2781777e83e244f81a16e8fda2a7fa60328e0000000000000000000000005390a2d7128b1d3f0f692754c3d72cbeab59856b000000000000000000000000c7d20cc1e80971102984207a341a4f64371f853f","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://c1f13e23118e7d3dab73a9826ea8b90ee5219b2f6b8564c2ccde6d5e0392d272"}]}