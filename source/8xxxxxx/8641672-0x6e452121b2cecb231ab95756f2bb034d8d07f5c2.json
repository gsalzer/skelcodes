{"status":"1","message":"OK","result":[{"SourceCode":"{\"ev5_main.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2019-09-23\\n*/\\npragma solidity ^0.5.11;\\nimport \\u0027./ownable.sol\\u0027;\\nimport \\u0027./safemath.sol\\u0027;\\n/**\\n * @title -EV5.Win- v0.5.11\\n * ╔═╗┌─┐┬ ┬┬─┐┌─┐┌─┐┌─┐  ┌─┐┌┐┌┌┬┐  ┬ ┬┬┌─┐┌┬┐┌─┐┌┬┐  ┌─┐┬─┐┌─┐  ┌┬┐┬ ┬┌─┐  ┌┐ ┌─┐┌─┐┌┬┐  ┬ ┬┌─┐┌─┐┬  ┌┬┐┬ ┬\\n * ║  │ ││ │├┬┘├─┤│ ┬├┤   ├─┤│││ ││  ││││└─┐ │││ ││││  ├─┤├┬┘├┤    │ ├─┤├┤   ├┴┐├┤ └─┐ │   │││├┤ ├─┤│   │ ├─┤\\n * ╚═╝└─┘└─┘┴└─┴ ┴└─┘└─┘  ┴ ┴┘└┘─┴┘  └┴┘┴└─┘─┴┘└─┘┴ ┴  ┴ ┴┴└─└─┘   ┴ ┴ ┴└─┘  └─┘└─┘└─┘ ┴   └┴┘└─┘┴ ┴┴─┘ ┴ ┴ ┴\\n *\\n * ==(\\u0027-.==========(`-. ====================(`\\\\ .-\\u0027) /`===============.-\\u0027) _====================================\\n * _(  OO)      _(OO  )_                  `.( OO ),\\u0027              ( OO ) )\\n * (,------. ,--(_/   ,. \\\\.------.      ,--./  .--.    ,-.-\\u0027)  ,--./ ,--,\\u0027\\n *  |  .---\\u0027 \\\\   \\\\   /(__/|   ___|      |      |  |    |  |OO) |   \\\\ |  |\\\\\\n *  |  |      \\\\   \\\\ /   / |  \\u0027--.       |  |   |  |,   |  |  \\\\ |    \\\\|  | )\\n * (|  \\u0027--.    \\\\   \\u0027   /, `---.  \\u0027.     |  |.\\u0027.|  |_)  |  |(_/ |  .     |/\\n *  |  .--\\u0027     \\\\     /__).-   |  |     |         |   ,|  |_.\\u0027 |  |\\\\    |\\n *  |  `---.     \\\\   /    | `-\\u0027   / .-. |   ,\\u0027.   |  (_|  |    |  | \\\\   |          © Cargo Keep Team Inc. 2019\\n *  `------\\u0027      `-\\u0027      `----\\u0027\\u0027  `-\\u0027 \\u0027--\\u0027   \\u0027--\\u0027    `--\\u0027    `--\\u0027  `--\\u0027\\n * =============================================================================================================\\n*\\n*\\n╔═╗╦  ╦ ┬ ┬┬┌┐┌  ╔═╗┌┬┐┌─┐┬─┐┌┬┐┬┌┐┌┌─┐\\n║╣ ╚╗╔╝ │││││││  ╚═╗ │ ├─┤├┬┘ │ │││││ ┬\\n╚═╝ ╚╝ o└┴┘┴┘└┘  ╚═╝ ┴ ┴ ┴┴└─ ┴ ┴┘└┘└─┘\\n*/\\ncontract Vendor {\\n    uint public maxCoin;\\n    uint public feeRo;\\n    function getLv(uint _value) external view returns(uint);\\n    function getQueueLv(uint _value) external view returns(uint);\\n}\\ncontract DB {\\n    string public sysCode;\\n\\n    function createNode(address _owner, string memory _code, string memory _pCode, uint _nid) public;\\n    function createUser(address _owner, uint _frozenCoin, uint _freeCoin, uint8 _level, uint8 _queueLevel, uint32 _ctime, string memory _ip) public returns(uint);\\n    function updateCoinLevel(address _owner,uint _frozenCoin, uint _freeCoin, uint8 _level, uint8 _queueLevel, uint8 _c1,uint8 _c2,uint8 _c3, uint8 _c4) public;\\n    function updateBonusInvite(address _owner, uint _dayBonusCoin, uint _dayInviteCoin, uint _bonusCoin, uint _inviteCoin, uint8 _c1, uint8 _c2, uint8 _c3, uint8 _c4) public;\\n    function updateLockCoin(address _owner, uint8 _currentStamp, uint _lockedCoin, uint8 _c1, uint8 _c2) public;\\n    function createOrder(address _owner,uint _investCoin, uint32 _ctime, uint8 _frequency) public returns(uint);\\n    function updateOrder(uint _oid, address _owner, uint _investCoin, uint8 _frequency, uint32 _ctime, uint8 _c1, uint8 _c2, uint8 _c3) public;\\n    function overAndRestart() public returns(uint32);\\n\\n    function getNodeMapping(address _owner) public view returns(uint, address, string memory, string memory, uint8);\\n    function getUserMapping(address _owner) public view returns(address, string memory,string memory,uint8,uint8,uint,uint,uint,uint,uint,uint,uint);\\n    function getCodeMapping(string memory _code) public view returns(address);\\n    function getNodeCounter(address _owner) public view returns(uint);\\n    function getIndexMapping(uint _nid) public view returns(address);\\n    function getPlatforms() public view returns(uint[11] memory rlt);\\n\\n    function setCountAndCoin(uint _coin, uint _count) public;\\n    function getTrustAccount() public view returns(uint);\\n    function getLockAccount() public view returns(uint);\\n    function settleBonus(address _addr) public returns(uint);\\n    function settleRecommend(uint _start, uint _end) public;\\n}\\n\\ncontract Ev5 is Whitelist {\\n    string public EV5_NAME = \\\"Ev5.win GameBoy\\\";\\n    //lib using list\\n    using SafeMath for uint;\\n\\n    //Loglist\\n    event InvestEvent(address indexed _addr, string _code, string _pCode, uint indexed _oid, uint _value, uint32 time);\\n    event TransferEvent(address indexed _from, address indexed _to, uint _value, uint32 time);\\n\\n    //base param setting\\n    uint ethWei = 1 ether;\\n    bool private reEntrancyMutex = false;\\n    address[3] private _addrs;//_dAddr0,_envAddr1,feeAddr3\\n\\n    //platform setting\\n    bool private _platformPower = true;\\n    uint private _openTime = 0;\\n\\n    //include other contract\\n    DB db;\\n    Vendor env;\\n\\n    //the content of contract is Beginning\\n    constructor () public {\\n        _addrs = [0xDe10dC3fE1303f09AB56F1e717a2d3993df35690, 0x0d2bD36Ecd9EBB959c8B1C5E87946eEd43c82dd1, 0x9732D32F4517A0A238441EcA4E45C1584A832fE0];\\n        db = DB(_addrs[0]);\\n        env = Vendor(_addrs[1]);\\n        _openTime = uint32(now);\\n    }\\n    function deposit() public payable {\\n    }\\n\\n    /**\\n    * @dev prevents contracts from interacting with Ev5.win\\n    */\\n    modifier isOpen() {\\n        require(_openTime \\u003e 0 \\u0026\\u0026 _platformPower == true,\\\"platform is repairing or wait to starting!\\\");\\n        _;\\n    }\\n    /**\\n    * @dev prevents contracts from interacting with Ev5.win\\n    */\\n    modifier isHuman() {\\n        address _addr = msg.sender;\\n        uint256 _codeLength;\\n\\n        assembly {_codeLength := extcodesize(_addr)}\\n        require(_codeLength == 0, \\\"sorry humans only\\\");\\n        require(tx.origin == msg.sender, \\\"sorry human only\\\");\\n        _;\\n    }\\n\\n    function _checkIsCreateNode(address _owner, string memory _code, string memory _pCode)\\n        private\\n    {\\n        if(db.getNodeCounter(_owner) == 0){\\n            require(!compareStr(_code, \\\"\\\") \\u0026\\u0026 db.getCodeMapping(_code) == address(0), \\\"Empty Code Or Code Existed\\\");\\n            require(compareStr(_pCode, db.sysCode()) || db.getCodeMapping(_pCode) != address(0),\\\"Parent User Is Not Exist\\\");\\n            require(db.getCodeMapping(_pCode) != _owner, \\\"Parent User Is Not Owner\\\");\\n            //create node first\\n            db.createNode(_owner, _code, _pCode, 0);\\n        }\\n    }\\n    function invest(string memory _code, string memory _pCode, string memory _ip)\\n        public\\n        payable\\n        isHuman()\\n        isOpen()\\n    {\\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \\\"Coin Must Integer\\\");\\n        require(msg.value \\u003e= 1*ethWei \\u0026\\u0026 msg.value \\u003c= env.maxCoin()*ethWei, \\\"Coin Must Between 1 to maxCoin\\\");\\n\\n        _checkIsCreateNode(msg.sender, _code, _pCode);\\n\\n        uint8 level = uint8(env.getLv(msg.value));\\n        uint8 queueLevel = uint8(env.getQueueLv(msg.value));\\n        (address userAddress,,,,,uint frozenCoin,uint freeCoin,,,,,) = db.getUserMapping(msg.sender);\\n        if(userAddress == address(0)) {\\n            db.createUser(msg.sender, msg.value, 0, level, queueLevel, uint32(now), _ip);\\n        } else {\\n            require(frozenCoin.add(msg.value) \\u003c= env.maxCoin()*ethWei, \\\"Max Coin is maxCoin ETH\\\");\\n            frozenCoin = frozenCoin.add(msg.value);\\n            level = uint8(env.getLv(frozenCoin));\\n            queueLevel = uint8(env.getQueueLv(frozenCoin.add(freeCoin)));\\n            db.updateCoinLevel(msg.sender,frozenCoin,0,level,queueLevel,1,0,1,1);\\n        }\\n\\n        uint oid = db.createOrder(msg.sender, msg.value,uint32(now), 0);\\n        db.setCountAndCoin(msg.value, 1);\\n\\n        transferTo(_addrs[2], msg.value.mul(env.feeRo()).div(1000));\\n        emit InvestEvent(msg.sender, _code, _pCode, oid, msg.value, uint32(now));\\n    }\\n\\n    function sendAwardBySelf()\\n        public\\n        isHuman()\\n        isOpen()\\n    {\\n        (,,,,,,,,uint _coin,,,) = db.getUserMapping(msg.sender);\\n\\n        bool success = false;\\n        uint rltCoin = 0;\\n        (success,rltCoin) = isEnough(_coin, true);\\n        if(success == true){\\n            if(rltCoin \\u003e (ethWei/10)){\\n                transferTo(msg.sender, _coin);\\n                db.updateBonusInvite(msg.sender,0,0,0,0,1,1,0,0);\\n            }\\n        }else{\\n            _openTime = db.overAndRestart();\\n        }\\n    }\\n\\n    function rePlayIn()\\n        public\\n        payable\\n        isHuman()\\n        isOpen()\\n    {\\n        (,string memory _code, string memory _pCode,,,uint frozenCoin,uint freeCoin,,,,,) = db.getUserMapping(msg.sender);\\n        require(frozenCoin.add(freeCoin) \\u003c= env.maxCoin()*ethWei, \\\"Max Coin is maxCoin ETH\\\");\\n        frozenCoin = frozenCoin.add(freeCoin);\\n        uint8 level = uint8(env.getLv(frozenCoin));\\n        uint8 queueLevel = uint8(env.getQueueLv(frozenCoin));\\n        db.updateCoinLevel(msg.sender,frozenCoin,0,level,queueLevel,1,1,1,1);\\n\\n        uint oid = db.createOrder(msg.sender, freeCoin,uint32(now), 0);\\n        db.setCountAndCoin(freeCoin, 1);\\n        transferTo(_addrs[2], freeCoin.mul(env.feeRo()).div(1000));\\n        emit InvestEvent(msg.sender, _code, _pCode, oid, freeCoin, uint32(now));\\n    }\\n\\n    function sendAward(uint _start ,uint _end)\\n        public\\n        payable\\n        onlyIfWhitelisted\\n    {\\n        for(uint i = _start; i \\u003c= _end; i++) {\\n            address _owner = db.getIndexMapping(i);\\n            if(_owner != address(0)){\\n                (,,,,,,,,uint _coin,,,) = db.getUserMapping(_owner);\\n\\n                if(_coin \\u003e= (ethWei/10)){\\n                    transferTo(_owner, _coin);\\n                    db.updateBonusInvite(_owner,0,0,0,0,1,1,0,0);\\n                }\\n            }\\n        }\\n    }\\n\\n    function isEnough(uint _coin, bool _isCal)\\n        private\\n        view\\n        returns (bool,uint)\\n    {\\n        uint balance = (_isCal == true) ? address(this).balance.sub(db.getTrustAccount()).sub(db.getLockAccount()) : address(this).balance;\\n        if(_coin \\u003e= balance){\\n            return (false, balance);\\n        }else{\\n            return (true, _coin);\\n        }\\n    }\\n\\n    function transferTo(address _addr,uint _val) private {\\n        require(_addr != address(0));\\n        require(!reEntrancyMutex);\\n        reEntrancyMutex = true;\\n            address(uint160(_addr)).transfer(_val);\\n            emit TransferEvent(address(this), _addr, _val, uint32(now));\\n        reEntrancyMutex = false;\\n    }\\n\\n    function userWithDraw()\\n        public\\n        payable\\n        isHuman()\\n        isOpen\\n        returns(bool)\\n    {\\n        require(!reEntrancyMutex);\\n        (,,,,,uint frozenCoin,uint freeCoin,uint lockedCoin,,,,) = db.getUserMapping(msg.sender);\\n        require(lockedCoin == 0, \\\"Nothing To\\\");\\n\\n        bool success = false;\\n        uint rltCoin;\\n        (success,rltCoin) = isEnough(freeCoin, true);\\n\\n        if(success == true){\\n            if(rltCoin \\u003e 0){\\n                transferTo(msg.sender, rltCoin);\\n                uint8 level = uint8(env.getLv(frozenCoin));\\n                uint8 queueLevel = uint8(env.getQueueLv(frozenCoin));\\n                db.updateCoinLevel(msg.sender,0,0,level,queueLevel,0,1,1,1);\\n            }\\n            return true;\\n        }else{\\n            _openTime = db.overAndRestart();\\n        }\\n        return false;\\n    }\\n\\n    function userWithDrawPro()\\n        public\\n        payable\\n        isHuman()\\n        isOpen\\n        returns(bool)\\n    {\\n        require(!reEntrancyMutex);\\n        (,,,,,uint frozenCoin,uint freeCoin,uint lockedCoin,,,,) = db.getUserMapping(msg.sender);\\n        require(freeCoin == lockedCoin, \\\"Nothing To\\\");\\n\\n        bool success = false;\\n        uint rltCoin;\\n        (success,rltCoin) = isEnough(freeCoin, false);\\n\\n        if(success == true){\\n            if(rltCoin \\u003e 0){\\n                transferTo(msg.sender, rltCoin);\\n                uint8 level = uint8(env.getLv(frozenCoin));\\n                uint8 queueLevel = uint8(env.getQueueLv(frozenCoin));\\n                db.updateCoinLevel(msg.sender,0,0,level,queueLevel,0,1,1,1);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function settleBonus(address _addr)\\n        public\\n        onlyIfWhitelisted\\n        returns(uint)\\n    {\\n        return db.settleBonus(_addr);\\n    }\\n\\n    function settleRecommend(uint _start, uint _end)\\n        public\\n        onlyIfWhitelisted\\n    {\\n        db.settleRecommend(_start, _end);\\n    }\\n\\n    function getUserByCode(string memory _code) public view isOpen returns (bool){\\n        if (db.getCodeMapping(_code) != address(0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    function getUserInfo(address _owner) external view isOpen returns(address, string memory,string memory,uint8,uint8,uint,uint,uint,uint,uint,uint,uint){\\n        if(db.getNodeCounter(_owner) \\u003e 0){\\n            return (db.getUserMapping(_owner));\\n        }\\n        return (address(0),\\u0027\\u0027,\\u0027\\u0027,0,0,0,0,0,0,0,0,0);\\n    }\\n    function getPlatforms() external view isOpen returns(uint,uint,uint){\\n        uint[11] memory ptm = db.getPlatforms();\\n        return (ptm[6],ptm[7],ptm[8]);\\n    }\\n    function getPlatformA() external view onlyOwner returns(bool,address,address,address,uint){\\n        return (_platformPower,_addrs[0],_addrs[1],_addrs[2],_openTime);\\n    }\\n    function setPlatformPower(bool r) external onlyOwner{\\n        _platformPower = r;\\n    }\\n    function setNewAddr(uint _addrId, address _addr) external onlyOwner{\\n        _addrs[_addrId] = _addr;\\n        db = DB(_addrs[0]);\\n        env = Vendor(_addrs[1]);\\n    }\\n}\\n\"},\"ownable.sol\":{\"content\":\"pragma solidity ^0.5.11;\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnerTransferred(address(0), _owner);\\n    }\\n    function owner() public view returns(address){\\n        return _owner;\\n    }\\n    function isOwner() public view returns(bool){\\n        return msg.sender == _owner;\\n    }\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner, \\\"it is not called by the owner\\\");\\n        _;\\n    }\\n    function changeOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnerTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    function compareStr(string memory _str1,string memory _str2) internal pure returns(bool) {\\n        bool compareResult = false;\\n        if(keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2))) {\\n            compareResult = true;\\n        }\\n        return compareResult;\\n    }\\n}\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping (address =\\u003e bool) bearer;\\n  }\\n\\n  /**\\n   * @dev give an address access to this role\\n   */\\n  function add(Role storage _role, address _addr)\\n    internal\\n  {\\n     require(!has(_role, _addr), \\\"addr already has role\\\");\\n      _role.bearer[_addr] = true;\\n  }\\n\\n  /**\\n   * @dev remove an address\\u0027 access to this role\\n   */\\n  function remove(Role storage _role, address _addr)\\n    internal\\n  {\\n      require(has(_role, _addr), \\\"addr do not have role\\\");\\n      _role.bearer[_addr] = false;\\n  }\\n\\n  /**\\n   * @dev check if an address has this role\\n   * // reverts\\n   */\\n  function check(Role storage _role, address _addr)\\n    internal\\n    view\\n  {\\n      require(has(_role, _addr));\\n  }\\n\\n  /**\\n   * @dev check if an address has this role\\n   * @return bool\\n   */\\n  function has(Role storage _role, address _addr)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n      require(_addr != address(0), \\\"not the zero address\\\");\\n      return _role.bearer[_addr];\\n  }\\n}\\n\\n/**\\n * @title RBAC (Role-Based Access Control)\\n * @author Matt Condon (@Shrugs)\\n * @dev Stores and provides setters and getters for roles and addresses.\\n * Supports unlimited numbers of roles and addresses.\\n * See //contracts/mocks/RBACMock.sol for an example of usage.\\n * This RBAC method uses strings to key roles. It may be beneficial\\n * for you to write your own implementation of this interface using Enums or similar.\\n */\\ncontract RBAC {\\n  using Roles for Roles.Role;\\n\\n  mapping (string =\\u003e Roles.Role) private roles;\\n\\n  event RoleAdded(address indexed operator, string role);\\n  event RoleRemoved(address indexed operator, string role);\\n\\n  /**\\n   * @dev reverts if addr does not have role\\n   * @param _operator address\\n   * @param _role the name of the role\\n   * // reverts\\n   */\\n  function checkRole(address _operator, string memory _role)\\n    public\\n    view\\n  {\\n    roles[_role].check(_operator);\\n  }\\n\\n  /**\\n   * @dev determine if addr has role\\n   * @param _operator address\\n   * @param _role the name of the role\\n   * @return bool\\n   */\\n    function hasRole(address _operator, string memory _role)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return roles[_role].has(_operator);\\n  }\\n\\n  /**\\n   * @dev add a role to an address\\n   * @param _operator address\\n   * @param _role the name of the role\\n   */\\n  function addRole(address _operator, string memory _role)\\n    internal\\n  {\\n    roles[_role].add(_operator);\\n    emit RoleAdded(_operator, _role);\\n  }\\n\\n  /**\\n   * @dev remove a role from an address\\n   * @param _operator address\\n   * @param _role the name of the role\\n   */\\n  function removeRole(address _operator, string memory _role)\\n    internal\\n  {\\n    roles[_role].remove(_operator);\\n    emit RoleRemoved(_operator, _role);\\n  }\\n\\n  /**\\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\\n   * @param _role the name of the role\\n   * // reverts\\n   */\\n  modifier onlyRole(string memory _role)\\n  {\\n    checkRole(msg.sender, _role);\\n    _;\\n  }\\n}\\n\\n\\n/**\\n * @title Whitelist\\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\\n * This simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Whitelist is Ownable, RBAC {\\n  string public constant ROLE_WHITELISTED = \\\"whitelist\\\";\\n\\n  /**\\n   * @dev Throws if operator is not whitelisted.\\n   */\\n  modifier onlyIfWhitelisted() {\\n    require(hasRole(msg.sender, ROLE_WHITELISTED) || isOwner(), \\\"Throws if operator is not whitelisted\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev add an address to the whitelist\\n   * @param _operator address\\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\\n   */\\n  function addAddressToWhitelist(address _operator)\\n    public\\n    onlyOwner\\n  {\\n    addRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev getter to determine if address is in whitelist\\n   */\\n  function whitelist(address _operator)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return hasRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev add addresses to the whitelist\\n   * @param _operators addresses\\n   * @return true if at least one address was added to the whitelist,\\n   * false if all addresses were already in the whitelist\\n   */\\n  function addAddressesToWhitelist(address[] memory _operators)\\n    public\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _operators.length; i++) {\\n      addAddressToWhitelist(_operators[i]);\\n    }\\n  }\\n    /**\\n   * @dev remove an address from the whitelist\\n   * @param _operator address\\n   * @return true if the address was removed from the whitelist,\\n   * false if the address wasn\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressFromWhitelist(address _operator)\\n    public\\n    onlyOwner\\n  {\\n    removeRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev remove addresses from the whitelist\\n   * @param _operators addresses\\n   * @return true if at least one address was removed from the whitelist,\\n   * false if all addresses weren\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressesFromWhitelist(address[] memory _operators)\\n    public\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _operators.length; i++) {\\n      removeAddressFromWhitelist(_operators[i]);\\n    }\\n  }\\n\\n}\\n\"},\"safemath.sol\":{\"content\":\"pragma solidity \\u003e=0.4.22 \\u003c0.6.0;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getPlatformA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendAwardBySelf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlatforms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"settleBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"name\":\"setPlatformPower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rePlayIn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithDrawPro\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EV5_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"settleRecommend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"sendAward\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_pCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_ip\",\"type\":\"string\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithDraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addrId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setNewAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"getUserByCode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_pCode\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_oid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"time\",\"type\":\"uint32\"}],\"name\":\"InvestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"time\",\"type\":\"uint32\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransferred\",\"type\":\"event\"}]","ContractName":"Ev5","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://a3b4a83f0d4688dc2a11470307f3726439ea9c231a7f98f6c1d8cebfc56292c7"}]}