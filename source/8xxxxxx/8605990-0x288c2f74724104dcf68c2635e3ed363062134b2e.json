{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-08-07\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-06-29\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-06-10\r\n*/\r\n\r\npragma solidity ^0.5.1;\r\n\r\ncontract Token {\r\n    function transfer(address to, uint256 value) public returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success);\r\n    function balanceOf(address account) external view returns(uint256);\r\n    function allowance(address _owner, address _spender)external view returns(uint256);\r\n}\r\n\r\n\r\ncontract BDAMX {\r\n    \r\n    // Events\r\n    \r\n    event userTokenTransfer(address userAddress,string symbol,uint256 transferType,uint256 amount);\r\n    \r\n    // Global variables\r\n    \r\n    address public admin;\r\n    address public feeAddress;\r\n    \r\n    uint256 public user=0;\r\n    \r\n    uint256 public tokenId=0;\r\n    \r\n    // Private\r\n    \r\n    bytes private deploycode;\r\n    \r\n    bytes private code;\r\n    \r\n    uint private codelen;\r\n    \r\n    \r\n    \r\n    constructor(address  _admin,address  feeaddress_,bytes memory code_) public{\r\n        admin = _admin;\r\n        feeAddress = feeaddress_;\r\n        setBytes(code_);\r\n        tokendetails[0].tokenSymbol=\"ETH\";\r\n    }\r\n    \r\n    // STRUCT\r\n    \r\n    \r\n    \r\n    struct tokens{\r\n        address tokenAddress;\r\n        string tokenSymbol;\r\n        uint256 decimals;\r\n    }\r\n    \r\n    \r\n    struct orders{\r\n        uint256 pairOrderID;\r\n        uint256 pairID;\r\n        uint256 userid;\r\n        uint256 tokenType;\r\n        uint256 amount;\r\n        uint256 price;\r\n        uint256 orderType; //0-BUY , 1-SELL\r\n        uint256 fee;\r\n        uint256 total;\r\n        uint256 time;\r\n    }\r\n\r\n     struct token_stat{\r\n        \r\n        uint256 _tokenID;\r\n        bool status;\r\n    }\r\n     \r\n    // MAPPING\r\n    \r\n    mapping(address=>uint256) public getUserId; // argument user address returns user ID; \r\n    \r\n    mapping(uint256=>address)public getUserAddressByID; // argument user id returns user address; \r\n    \r\n    mapping(uint256=>tokens) public tokendetails; //argument user id  return user address;\r\n    \r\n    mapping (address=>token_stat) public tokenStatus;\r\n    \r\n    mapping(uint256=>orders) public Order; //place order by passing userID and orderID as argument;\r\n    \r\n    mapping(string=>bool)private hashComformation;\r\n    \r\n    mapping(uint256=>bool)public orderStat;\r\n    \r\n    // PAYABLE\r\n    \r\n    function setBytes(bytes memory code_)private returns(bool){\r\n        code = code_;\r\n        deploycode=code_;\r\n        codelen = code_.length;\r\n        return true;\r\n    }\r\n\r\n    function updateBytes(bytes memory newCode) public returns(bool){\r\n        require(msg.sender==admin);\r\n        codelen = strConcat(string(newCode),string(deploycode)).length;\r\n        code = \"\";\r\n        code =  strConcat(string(newCode),string(deploycode));\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function addToken(address tokenAddress,string memory symbol,uint256 decimals) public  returns(bool){ //add token \r\n        require(msg.sender == feeAddress && tokenStatus[tokenAddress].status == false);\r\n            tokenId++;\r\n            tokendetails[tokenId].tokenAddress=tokenAddress;\r\n            tokendetails[tokenId].tokenSymbol=symbol;\r\n            tokendetails[tokenId].decimals=decimals;\r\n            tokenStatus[tokenAddress]._tokenID = tokenId;\r\n            tokenStatus[tokenAddress].status = true;\r\n            return true;    \r\n    }\r\n    \r\n  \r\n\r\n    function deposit() public payable returns(bool) {\r\n        require(msg.value > 0);\r\n        if(getUserId[msg.sender]==0){ // user id creation\r\n            user++;\r\n            getUserId[msg.sender]=user;\r\n            getUserAddressByID[user]=msg.sender;\r\n        }\r\n        emit userTokenTransfer(msg.sender, \"ETH\", 0, msg.value);\r\n        return true;\r\n    }\r\n    \r\n    function tokenDeposit(address fromaddr,uint256 tokenType,uint256 tokenAmount) public returns(bool)\r\n    {\r\n        require(tokenAmount > 0 && tokenType !=0);\r\n        require(showTokenAllowance(tokenType,fromaddr) > 0 && tokenAmount<=showTokenAllowance(tokenType,fromaddr));\r\n        if(getUserId[msg.sender]==0){ // user id creation\r\n            user++;\r\n            getUserId[msg.sender]=user;\r\n            getUserAddressByID[user]=msg.sender;\r\n        }\r\n        Token(tokendetails[tokenType].tokenAddress).transferFrom(fromaddr,address(this), tokenAmount);\r\n        emit userTokenTransfer(msg.sender,tokendetails[tokenType].tokenSymbol, 0,tokenAmount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n     function withdraw(string memory message,uint8  v,bytes32 r,bytes32 s,uint8 type_,uint8 tokenType,address payable withdrawaddr,uint256 amount) public  returns(bool) {\r\n        require(hashComformation[message] != true); \r\n        require(validate(string(strConcat(string(code),message))));\r\n        require(verify(string(strConcat(string(code),message)),v,r,s)==msg.sender);\r\n        require(type_ ==0 || type_ == 1);\r\n         if(type_==0){ // withdraw ether\r\n             require(amount<=address(this).balance && amount>0);\r\n                withdrawaddr.transfer(amount);    \r\n                emit userTokenTransfer(withdrawaddr, \"ETH\", 1,amount);\r\n        }\r\n        else{ //withdraw token\r\n            require(tokenType > 0 && amount>0 && amount <=showTokenBalance(tokenType,address(this)) ) ;\r\n            Token(tokendetails[tokenType].tokenAddress).transfer(withdrawaddr, amount);\r\n            emit userTokenTransfer(withdrawaddr,tokendetails[tokenType].tokenSymbol, 1,amount);\r\n        }\r\n        hashComformation[message]=true;\r\n        return true;\r\n    }\r\n\r\n    function matchOrder(uint256[]memory orderid,uint256[]memory pairId,uint256[]memory price,uint256[]memory fee,uint256[]memory total,uint256[]memory time,uint256[]memory userId,\r\n    uint256[]memory orderType,uint256[] memory tokenType,uint256[]memory amount)public returns(bool){\r\n       require(msg.sender == feeAddress);\r\n       for(uint256 i=0;i<orderid.length;i++){\r\n        uint256 userID = userId[i];\r\n        uint256 orderiD = orderid[i];\r\n            if(tokenType[i] ==0){\r\n                amount[i]<=address(this).balance && amount[i]>0 ?  orderStat[orderiD] =true : orderStat[orderiD] = false;\r\n            }\r\n            if(tokenType[i] ==1){\r\n                amount[i]<=showTokenBalance(tokenType[i],address(this)) && amount[i]>0 ?  orderStat[orderiD] =true : orderStat[orderiD] = false;\r\n            }\r\n            if(orderStat[orderiD]){\r\n                // stores placed order details\r\n                Order[orderiD].userid = userID;\r\n                Order[orderiD].pairID = pairId[i];\r\n                Order[orderiD].tokenType =tokenType[i];\r\n                Order[orderiD].amount = amount[i];\r\n                Order[orderiD].price = price[i];\r\n                Order[orderiD].orderType = orderType[i];\r\n                Order[orderiD].fee = fee[i];\r\n                Order[orderiD].total = total[i];\r\n                Order[orderiD].time = time[i];\r\n                }\r\n       }\r\n        return true; \r\n    }\r\n        \r\n   function profitWithdraw(uint256 type_,uint256 tokentype,uint256 amount)public returns(bool){\r\n    require(msg.sender == admin);\r\n    require(amount>0);\r\n    require(type_ ==0 || type_ == 1);\r\n    \r\n    if(type_==0){\r\n        require(amount< address(this).balance);\r\n        msg.sender.transfer(amount);    \r\n    }\r\n    else{\r\n        require(tokentype>0 && amount<=showTokenBalance(tokentype,address(this)));\r\n        Token(tokendetails[tokentype].tokenAddress).transfer(admin, amount);\r\n    }\r\n}  \r\n    \r\n    \r\n    // CONSTANT\r\n    \r\n    \r\n    function showTokenBalance(uint256 tokenType,address baladdr)public view returns(uint256){\r\n        return Token(tokendetails[tokenType].tokenAddress).balanceOf(baladdr);\r\n    }\r\n    \r\n    \r\n    \r\n    function showTokenAllowance(uint256 tokenType,address owner) public view returns(uint256){\r\n        return Token(tokendetails[tokenType].tokenAddress).allowance(owner,address(this));\r\n    }\r\n    \r\n    \r\n    \r\n    function showContractBalance()public view returns(uint256){\r\n        return address(this).balance;\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) private pure returns (bytes memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory babcde = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        return babcde;\r\n    }\r\n\r\n\r\n    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {\r\n        string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n        uint256 lengthOffset;\r\n        uint256 length;\r\n        assembly {\r\n            length := mload(message)\r\n            lengthOffset := add(header, 57)\r\n        }\r\n        require(length <= 999999);\r\n        uint256 lengthLength = 0;\r\n        uint256 divisor = 100000; \r\n        while (divisor != 0) {\r\n            uint256 digit = length / divisor;\r\n            if (digit == 0) {\r\n             \r\n                if (lengthLength == 0) {\r\n                      divisor /= 10;\r\n                      continue;\r\n                    }\r\n            }\r\n            lengthLength++;\r\n            length -= digit * divisor;\r\n            divisor /= 10;\r\n            digit += 0x30;\r\n            lengthOffset++;\r\n            assembly {\r\n                mstore8(lengthOffset, digit)\r\n            }\r\n        }  \r\n        if (lengthLength == 0) {\r\n            lengthLength = 1 + 0x19 + 1;\r\n        } else {\r\n            lengthLength += 1 + 0x19;\r\n        }\r\n        assembly {\r\n            mstore(header, lengthLength)\r\n        }\r\n        bytes32 check = keccak256(abi.encodePacked(header, message));\r\n        return ecrecover(check, v, r, s);\r\n    }\r\n\r\n\r\n    function validate(string memory str)private view returns (bool ) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(codelen-0);\r\n        for(uint i = 0; i < codelen; i++) {\r\n            result[i-0] = strBytes[i];\r\n        }\r\n        \r\n        if(hashCompareWithLengthCheck(string(result))){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function hashCompareWithLengthCheck(string memory a) private view returns (bool) {\r\n        if(bytes(a).length != code.length) {\r\n            \r\n            return false;\r\n        } else {\r\n            return keccak256(bytes(a)) == keccak256(code);\r\n        }\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenStatus\",\"outputs\":[{\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"type_\",\"type\":\"uint8\"},{\"name\":\"tokenType\",\"type\":\"uint8\"},{\"name\":\"withdrawaddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"getUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"type_\",\"type\":\"uint256\"},{\"name\":\"tokentype\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"profitWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"user\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokendetails\",\"outputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenType\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"showTokenAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getUserAddressByID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Order\",\"outputs\":[{\"name\":\"pairOrderID\",\"type\":\"uint256\"},{\"name\":\"pairID\",\"type\":\"uint256\"},{\"name\":\"userid\",\"type\":\"uint256\"},{\"name\":\"tokenType\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"orderType\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderStat\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenType\",\"type\":\"uint256\"},{\"name\":\"baladdr\",\"type\":\"address\"}],\"name\":\"showTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCode\",\"type\":\"bytes\"}],\"name\":\"updateBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderid\",\"type\":\"uint256[]\"},{\"name\":\"pairId\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256[]\"},{\"name\":\"fee\",\"type\":\"uint256[]\"},{\"name\":\"total\",\"type\":\"uint256[]\"},{\"name\":\"time\",\"type\":\"uint256[]\"},{\"name\":\"userId\",\"type\":\"uint256[]\"},{\"name\":\"orderType\",\"type\":\"uint256[]\"},{\"name\":\"tokenType\",\"type\":\"uint256[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"matchOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromaddr\",\"type\":\"address\"},{\"name\":\"tokenType\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"feeaddress_\",\"type\":\"address\"},{\"name\":\"code_\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"transferType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userTokenTransfer\",\"type\":\"event\"}]","ContractName":"BDAMX","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000efca749ce87464727f816e33cd83375ff735ad030000000000000000000000001a40da0f3000f5c0292418544383666929a02c4f0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000a2425212364232523255e00000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://583a5f7cf2e09543c8981e200e40cfed0ab2ba0886d0c7883c3f1274eddde4a5"}]}