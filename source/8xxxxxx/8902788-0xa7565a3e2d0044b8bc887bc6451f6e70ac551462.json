{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n// This is the smart contract for Simple FOMO\r\n// A game theory based lottery that rewards the last entry with the 50% of the pot.\r\n// Round 2 now also rewards the address/person that has the most entries with the other 50% of the pot\r\n// This encourages players to enter early so they can take advantage of the lower entry cost.\r\n\r\n// Modeled on the infamous Fomo3D but without its complexities, Simple FOMO has safeguards to reduce the chance\r\n// a person will clog the blockchain to make them become the last entry and the winner.\r\n\r\ncontract Simple_FOMO_Round_2 {\r\n\r\n  // Administrator information\r\n  address public feeAddress; // This is the address of the person that collects the fees, nothing more, nothing less. It can be changed.\r\n  uint256 public feePercent = 2500; // This is the percent of the fee (2500 = 2.5%, 1 = 0.001%)\r\n\r\n  // Lotto information\r\n  uint256 public potSize = 0; // This is the size of the lottery pool in Wei\r\n  uint256 public entryCost = 1000000000000000; // This is the initial cost to enter the lottery pool (0.001 ETH)\r\n  uint256 constant entryCostStep = 5000000000000000; // This is the increase in the entry cost per 10 entries (0.005 ETH)\r\n  address public lastEntryAddress; // This is the address of the person who has entered the pool last\r\n  address public mostEntryAddress; // The address that has the most entries\r\n  uint256 public mostEntryCount = 0; // Represents the number of entries from the top entry address\r\n  uint256 public deadline; // This represents the initial deadline for the pool\r\n  uint256 constant gameDuration = 7; // This is the default amount of days the lottery will last for, can be extended with entries\r\n  uint256 public extensionTime = 600; // The default extension time per entry (600 seconds = 10 minutes)\r\n                                      // Extension time is increased by 0.5 seconds for each entry\r\n\r\n  // Player information                                    \r\n  uint256 public totalEntries = 0; // The total amount of entries in the pool\r\n  mapping (address => uint256) private entryAmountList; // A list of entry amounts, mapped by each address (key)\r\n\r\n  constructor() public payable {\r\n    feeAddress = msg.sender; // Set the contract creator to the first feeAddress\r\n    lastEntryAddress = msg.sender;\r\n    mostEntryAddress = msg.sender;\r\n    potSize = msg.value;\r\n    deadline = now + gameDuration * 86400; // Set the game to end 7 days after lottery start\r\n  }\r\n\r\n  event ClaimedLotto(address _user, uint256 _amount); // Auxillary events\r\n  event MostEntries(address _user, uint256 _amount, uint256 _entries);\r\n  event AddedEntry(address _user, uint256 _amount, uint256 _entrycount);\r\n  event AddedNewParticipant(address _user);\r\n  event ChangedFeeAddress(address _newFeeAddress);\r\n  event FailedFeeSend(address _user, uint256 _amount);\r\n\r\n  // View function\r\n  function viewLottoDetails() public view returns (\r\n    uint256 _entryCost,\r\n    uint256 _potSize,\r\n    address _lastEntryAddress,\r\n    address _mostEntryAddress,\r\n    uint256 _mostEntryCount, \r\n    uint256 _deadline\r\n  ) {\r\n    return (entryCost, potSize, lastEntryAddress, mostEntryAddress, mostEntryCount, deadline);\r\n  }\r\n\r\n  // Action functions\r\n  // Change contract fee address\r\n  function changeContractFeeAddress(address _newFeeAddress) public {\r\n    require (msg.sender == feeAddress); // Only the current feeAddress can change the feeAddress of the contract\r\n    \r\n    feeAddress = _newFeeAddress; // Update the fee address\r\n\r\n     // Trigger event.\r\n    emit ChangedFeeAddress(_newFeeAddress);\r\n  }\r\n\r\n  // Withdraw from pool when time has expired\r\n  function claimLottery() public {\r\n    require (msg.sender == lastEntryAddress || msg.sender == mostEntryAddress); // Only the last person to enter or most entries can claim the lottery\r\n    uint256 currentTime = now; // Get the current time in seconds\r\n    uint256 claimTime = deadline + 300; // Add 5 minutes to the deadline, only after then can the lotto be claimed\r\n    require (currentTime > claimTime);\r\n    // Congrats, this person has won the lottery\r\n    require (potSize > 0); // Cannot claim an empty pot\r\n    uint256 totalTransferAmount = potSize; // The amount that is going to the winners\r\n    potSize = 0; // Set the potSize to zero before contacting the external address\r\n\r\n    uint256 transferAmountLastEntry = totalTransferAmount / 2; // This is the amount going to the last entry\r\n    uint256 transferAmountMostEntries = totalTransferAmount - transferAmountLastEntry; // The rest goes to the player with most entries\r\n\r\n    // Send to external accounts\r\n    // This method will only be used once, so make sure the receiving address is not a contract\r\n    bool sendok_most = mostEntryAddress.send(transferAmountMostEntries);\r\n    bool sendok_last = lastEntryAddress.send(transferAmountLastEntry);\r\n\r\n     // Trigger event.\r\n    if(sendok_last == true){\r\n      emit ClaimedLotto(lastEntryAddress, transferAmountLastEntry);\r\n    }\r\n    if(sendok_most == true){\r\n      emit MostEntries(mostEntryAddress, transferAmountMostEntries, mostEntryCount);\r\n    } \r\n  }\r\n\r\n  // Add entry to the pool\r\n  function addEntry() public payable {\r\n    require (msg.value == entryCost); // Entry must be equal to entry cost, not more or less\r\n    uint256 currentTime = now; // Get the current time in seconds\r\n    require (currentTime <= deadline); // Cannot submit an entry if the deadline has passed\r\n\r\n    // Add this player to the entry list if not already on it (new in Round 2)\r\n    uint256 entryAmount = entryAmountList[msg.sender];\r\n    if(entryAmount == 0){\r\n      // This is a new participant\r\n      emit AddedNewParticipant(msg.sender);\r\n    }\r\n    entryAmount++;\r\n    entryAmountList[msg.sender] = entryAmount; // Increase the entry count for this participant\r\n\r\n    //Now compare this entry to the most entries\r\n    if(entryAmount > mostEntryCount){\r\n      // This entry makes this user have the most entries\r\n      mostEntryCount = entryAmount;\r\n      mostEntryAddress = msg.sender;\r\n    }\r\n\r\n    // Entry is valid, now modify the pool based on it\r\n    uint256 feeAmount = (entryCost * feePercent) / 100000; // Calculate the usage fee\r\n    uint256 potAddition = entryCost - feeAmount; // This is the amount actually going into the pot\r\n\r\n    potSize = potSize + potAddition; // Add this amount to the pot\r\n    extensionTime = 600 + (totalEntries / 2); // The extension time increases as more entries are submitted\r\n    totalEntries = totalEntries + 1; // Increased the amount of entries\r\n    if(totalEntries % 10 == 0){\r\n      entryCost = entryCost + entryCostStep; // Increase the cost to enter every 10 entries\r\n    }\r\n\r\n    if(currentTime + extensionTime > deadline){ // Move the deadline if the extension time brings it beyond\r\n      deadline = currentTime + extensionTime;\r\n    }\r\n\r\n    lastEntryAddress = msg.sender; // Now this entry is the last address for now\r\n\r\n    //Pay a fee to the feeAddress\r\n    bool sentfee = feeAddress.send(feeAmount);\r\n    if(sentfee == false){\r\n      emit FailedFeeSend(feeAddress, feeAmount); // Create an event in case of fee sending failed, but don't stop registering the entry\r\n    }\r\n\r\n    // Trigger event.\r\n    emit AddedEntry(msg.sender, msg.value, entryAmountList[msg.sender]);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mostEntryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewLottoDetails\",\"outputs\":[{\"name\":\"_entryCost\",\"type\":\"uint256\"},{\"name\":\"_potSize\",\"type\":\"uint256\"},{\"name\":\"_lastEntryAddress\",\"type\":\"address\"},{\"name\":\"_mostEntryAddress\",\"type\":\"address\"},{\"name\":\"_mostEntryCount\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFeeAddress\",\"type\":\"address\"}],\"name\":\"changeContractFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEntries\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addEntry\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entryCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEntryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mostEntryCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extensionTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedLotto\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_entries\",\"type\":\"uint256\"}],\"name\":\"MostEntries\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_entrycount\",\"type\":\"uint256\"}],\"name\":\"AddedEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AddedNewParticipant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFeeAddress\",\"type\":\"address\"}],\"name\":\"ChangedFeeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FailedFeeSend\",\"type\":\"event\"}]","ContractName":"Simple_FOMO_Round_2","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://85d596b2d3a965811ce649e3c14a664ccc31cea054a3e46c4452a64b0653675e"}]}