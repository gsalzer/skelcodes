{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.4;\r\n\r\n/// @title Utils\r\n/// @notice Utils contract for various helpers used by the Raiden Network smart\r\n/// contracts.\r\ncontract Utils {\r\n    enum MessageTypeId {\r\n        None,\r\n        BalanceProof,\r\n        BalanceProofUpdate,\r\n        Withdraw,\r\n        CooperativeSettle,\r\n        IOU,\r\n        MSReward\r\n    }\r\n\r\n    /// @notice Check if a contract exists\r\n    /// @param contract_address The address to check whether a contract is\r\n    /// deployed or not\r\n    /// @return True if a contract exists, false otherwise\r\n    function contractExists(address contract_address) public view returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(contract_address)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\ninterface Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // Optionally implemented function to show the number of decimals for the token\r\n    function decimals() external view returns (uint8 decimals);\r\n}\r\n\r\nlibrary ECVerify {\r\n\r\n    function ecverify(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address signature_address)\r\n    {\r\n        require(signature.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n\r\n            // Here we are loading the last 32 bytes, including 31 bytes following the signature.\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n\r\n        signature_address = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(signature_address != address(0x0));\r\n\r\n        return signature_address;\r\n    }\r\n}\r\n\r\n/// @title SecretRegistry\r\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\r\n/// clients.\r\ncontract SecretRegistry {\r\n    // sha256(secret) => block number at which the secret was revealed\r\n    mapping(bytes32 => uint256) private secrethash_to_block;\r\n\r\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\r\n\r\n    /// @notice Registers a hash time lock secret and saves the block number.\r\n    /// This allows the lock to be unlocked after the expiration block.\r\n    /// @param secret The secret used to lock the hash time lock.\r\n    /// @return true if secret was registered, false if the secret was already\r\n    /// registered.\r\n    function registerSecret(bytes32 secret) public returns (bool) {\r\n        bytes32 secrethash = sha256(abi.encodePacked(secret));\r\n        if (secrethash_to_block[secrethash] > 0) {\r\n            return false;\r\n        }\r\n        secrethash_to_block[secrethash] = block.number;\r\n        emit SecretRevealed(secrethash, secret);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Registers multiple hash time lock secrets and saves the block\r\n    /// number.\r\n    /// @param secrets The array of secrets to be registered.\r\n    /// @return true if all secrets could be registered, false otherwise.\r\n    function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\r\n        bool completeSuccess = true;\r\n        for(uint i = 0; i < secrets.length; i++) {\r\n            if(!registerSecret(secrets[i])) {\r\n                completeSuccess = false;\r\n            }\r\n        }\r\n        return completeSuccess;\r\n    }\r\n\r\n    /// @notice Get the stored block number at which the secret was revealed.\r\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`.\r\n    /// @return The block number at which the secret was revealed.\r\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\r\n        return secrethash_to_block[secrethash];\r\n    }\r\n}\r\n\r\n// MIT License\r\n\r\n// Copyright (c) 2018\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\n/// @title TokenNetwork\r\n/// @notice Stores and manages all the Raiden Network channels that use the\r\n/// token specified\r\n/// in this TokenNetwork contract.\r\ncontract TokenNetwork is Utils {\r\n    // Instance of the token used by the channels\r\n    Token public token;\r\n\r\n    // Instance of SecretRegistry used for storing secrets revealed in a\r\n    // mediating transfer.\r\n    SecretRegistry public secret_registry;\r\n\r\n    // Chain ID as specified by EIP155 used in balance proof signatures to\r\n    // avoid replay attacks\r\n    uint256 public chain_id;\r\n\r\n    uint256 public settlement_timeout_min;\r\n    uint256 public settlement_timeout_max;\r\n\r\n    uint256 constant public MAX_SAFE_UINT256 = (\r\n        115792089237316195423570985008687907853269984665640564039457584007913129639935\r\n    );\r\n\r\n    // The deposit limit per channel per participant.\r\n    uint256 public channel_participant_deposit_limit;\r\n    // The total combined deposit of all channels across the whole network\r\n    uint256 public token_network_deposit_limit;\r\n\r\n    // Global, monotonically increasing counter that keeps track of all the\r\n    // opened channels in this contract\r\n    uint256 public channel_counter;\r\n\r\n    string public constant signature_prefix = '\\x19Ethereum Signed Message:\\n';\r\n\r\n    // Only for the limited Red Eyes release\r\n    address public deprecation_executor;\r\n    bool public safety_deprecation_switch = false;\r\n\r\n    // channel_identifier => Channel\r\n    // channel identifier is the channel_counter value at the time of opening\r\n    // the channel\r\n    mapping (uint256 => Channel) public channels;\r\n\r\n    // This is needed to enforce one channel per pair of participants\r\n    // The key is keccak256(participant1_address, participant2_address)\r\n    mapping (bytes32 => uint256) public participants_hash_to_channel_identifier;\r\n\r\n    // We keep the unlock data in a separate mapping to allow channel data\r\n    // structures to be removed when settling uncooperatively. If there are\r\n    // locked pending transfers, we need to store data needed to unlock them at\r\n    // a later time.\r\n    // The key is `keccak256(uint256 channel_identifier, address participant,\r\n    // address partner)` Where `participant` is the participant that sent the\r\n    // pending transfers We need `partner` for knowing where to send the\r\n    // claimable tokens\r\n    mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data;\r\n\r\n    struct Participant {\r\n        // Total amount of tokens transferred to this smart contract through\r\n        // the `setTotalDeposit` function, for a specific channel, in the\r\n        // participant's benefit.\r\n        // This is a strictly monotonic value. Note that direct token transfer\r\n        // into the contract cannot be tracked and will be stuck.\r\n        uint256 deposit;\r\n\r\n        // Total amount of tokens withdrawn by the participant during the\r\n        // lifecycle of this channel.\r\n        // This is a strictly monotonic value.\r\n        uint256 withdrawn_amount;\r\n\r\n        // This is a value set to true after the channel has been closed, only\r\n        // if this is the participant who closed the channel.\r\n        bool is_the_closer;\r\n\r\n        // keccak256 of the balance data provided after a closeChannel or an\r\n        // updateNonClosingBalanceProof call\r\n        bytes32 balance_hash;\r\n\r\n        // Monotonically increasing counter of the off-chain transfers,\r\n        // provided along with the balance_hash\r\n        uint256 nonce;\r\n    }\r\n\r\n    enum ChannelState {\r\n        NonExistent, // 0\r\n        Opened,      // 1\r\n        Closed,      // 2\r\n        Settled,     // 3; Note: The channel has at least one pending unlock\r\n        Removed      // 4; Note: Channel data is removed, there are no pending unlocks\r\n    }\r\n\r\n    struct Channel {\r\n        // After opening the channel this value represents the settlement\r\n        // window. This is the number of blocks that need to be mined between\r\n        // closing the channel uncooperatively and settling the channel.\r\n        // After the channel has been uncooperatively closed, this value\r\n        // represents the block number after which settleChannel can be called.\r\n        uint256 settle_block_number;\r\n\r\n        ChannelState state;\r\n\r\n        mapping(address => Participant) participants;\r\n    }\r\n\r\n    struct SettlementData {\r\n        uint256 deposit;\r\n        uint256 withdrawn;\r\n        uint256 transferred;\r\n        uint256 locked;\r\n    }\r\n\r\n    struct UnlockData {\r\n        // keccak256 hash of the pending locks from the Raiden client\r\n        bytes32 locksroot;\r\n        // Total amount of tokens locked in the pending locks corresponding\r\n        // to the `locksroot`\r\n        uint256 locked_amount;\r\n    }\r\n\r\n    event ChannelOpened(\r\n        uint256 indexed channel_identifier,\r\n        address indexed participant1,\r\n        address indexed participant2,\r\n        uint256 settle_timeout\r\n    );\r\n\r\n    event ChannelNewDeposit(\r\n        uint256 indexed channel_identifier,\r\n        address indexed participant,\r\n        uint256 total_deposit\r\n    );\r\n\r\n    // Fires when the deprecation_switch's value changes\r\n    event DeprecationSwitch(bool new_value);\r\n\r\n    // total_withdraw is how much the participant has withdrawn during the\r\n    // lifetime of the channel. The actual amount which the participant withdrew\r\n    // is `total_withdraw - total_withdraw_from_previous_event_or_zero`\r\n    event ChannelWithdraw(\r\n        uint256 indexed channel_identifier,\r\n        address indexed participant,\r\n        uint256 total_withdraw\r\n    );\r\n\r\n    event ChannelClosed(\r\n        uint256 indexed channel_identifier,\r\n        address indexed closing_participant,\r\n        uint256 indexed nonce,\r\n        bytes32 balance_hash\r\n    );\r\n\r\n    event ChannelUnlocked(\r\n        uint256 indexed channel_identifier,\r\n        address indexed receiver,\r\n        address indexed sender,\r\n        bytes32 locksroot,\r\n        uint256 unlocked_amount,\r\n        uint256 returned_tokens\r\n    );\r\n\r\n    event NonClosingBalanceProofUpdated(\r\n        uint256 indexed channel_identifier,\r\n        address indexed closing_participant,\r\n        uint256 indexed nonce,\r\n        bytes32 balance_hash\r\n    );\r\n\r\n    event ChannelSettled(\r\n        uint256 indexed channel_identifier,\r\n        uint256 participant1_amount,\r\n        bytes32 participant1_locksroot,\r\n        uint256 participant2_amount,\r\n        bytes32 participant2_locksroot\r\n    );\r\n\r\n    modifier onlyDeprecationExecutor() {\r\n        require(msg.sender == deprecation_executor);\r\n        _;\r\n    }\r\n\r\n    modifier isSafe() {\r\n        require(safety_deprecation_switch == false);\r\n        _;\r\n    }\r\n\r\n    modifier isOpen(uint256 channel_identifier) {\r\n        require(channels[channel_identifier].state == ChannelState.Opened);\r\n        _;\r\n    }\r\n\r\n    modifier settleTimeoutValid(uint256 timeout) {\r\n        require(timeout >= settlement_timeout_min);\r\n        require(timeout <= settlement_timeout_max);\r\n        _;\r\n    }\r\n\r\n    /// @param _token_address The address of the ERC20 token contract.\r\n    /// @param _secret_registry The address of SecretRegistry contract that witnesses the onchain secret reveals.\r\n    /// @param _chain_id EIP-155 Chain ID of the blockchain where this instance is being deployed.\r\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening.\r\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening.\r\n    /// @param _deprecation_executor The Ethereum address that can disable new deposits and channel creation.\r\n    /// @param _channel_participant_deposit_limit The maximum amount of tokens that can be deposited by each\r\n    /// participant of each channel. MAX_SAFE_UINT256 means no limits.\r\n    /// @param _token_network_deposit_limit The maximum amount of tokens that this contract can hold.\r\n    /// MAX_SAFE_UINT256 means no limits.\r\n    constructor(\r\n        address _token_address,\r\n        address _secret_registry,\r\n        uint256 _chain_id,\r\n        uint256 _settlement_timeout_min,\r\n        uint256 _settlement_timeout_max,\r\n        address _deprecation_executor,\r\n        uint256 _channel_participant_deposit_limit,\r\n        uint256 _token_network_deposit_limit\r\n    )\r\n        public\r\n    {\r\n        require(_token_address != address(0x0));\r\n        require(_secret_registry != address(0x0));\r\n        require(_deprecation_executor != address(0x0));\r\n        require(_chain_id > 0);\r\n        require(_settlement_timeout_min > 0);\r\n        require(_settlement_timeout_max > _settlement_timeout_min);\r\n        require(contractExists(_token_address));\r\n        require(contractExists(_secret_registry));\r\n        require(_channel_participant_deposit_limit > 0);\r\n        require(_token_network_deposit_limit > 0);\r\n        require(_token_network_deposit_limit >= _channel_participant_deposit_limit);\r\n\r\n        token = Token(_token_address);\r\n\r\n        secret_registry = SecretRegistry(_secret_registry);\r\n        chain_id = _chain_id;\r\n        settlement_timeout_min = _settlement_timeout_min;\r\n        settlement_timeout_max = _settlement_timeout_max;\r\n\r\n        // Make sure the contract is indeed a token contract\r\n        require(token.totalSupply() > 0);\r\n\r\n        deprecation_executor = _deprecation_executor;\r\n        channel_participant_deposit_limit = _channel_participant_deposit_limit;\r\n        token_network_deposit_limit = _token_network_deposit_limit;\r\n    }\r\n\r\n    function deprecate() public isSafe onlyDeprecationExecutor {\r\n        safety_deprecation_switch = true;\r\n        emit DeprecationSwitch(safety_deprecation_switch);\r\n    }\r\n\r\n    /// @notice Opens a new channel between `participant1` and `participant2`.\r\n    /// Can be called by anyone.\r\n    /// @param participant1 Ethereum address of a channel participant.\r\n    /// @param participant2 Ethereum address of the other channel participant.\r\n    /// @param settle_timeout Number of blocks that need to be mined between a\r\n    /// call to closeChannel and settleChannel.\r\n    function openChannel(address participant1, address participant2, uint256 settle_timeout)\r\n        public\r\n        isSafe\r\n        settleTimeoutValid(settle_timeout)\r\n        returns (uint256)\r\n    {\r\n        bytes32 pair_hash;\r\n        uint256 channel_identifier;\r\n\r\n        // Red Eyes release token network limit\r\n        require(token.balanceOf(address(this)) < token_network_deposit_limit);\r\n\r\n        // First increment the counter\r\n        // There will never be a channel with channel_identifier == 0\r\n        channel_counter += 1;\r\n        channel_identifier = channel_counter;\r\n\r\n        pair_hash = getParticipantsHash(participant1, participant2);\r\n\r\n        // There must only be one channel opened between two participants at\r\n        // any moment in time.\r\n        require(participants_hash_to_channel_identifier[pair_hash] == 0);\r\n        participants_hash_to_channel_identifier[pair_hash] = channel_identifier;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        // We always increase the channel counter, therefore no channel data can already exist,\r\n        // corresponding to this channel_identifier. This check must never fail.\r\n        assert(channel.settle_block_number == 0);\r\n        assert(channel.state == ChannelState.NonExistent);\r\n\r\n        // Store channel information\r\n        channel.settle_block_number = settle_timeout;\r\n        channel.state = ChannelState.Opened;\r\n\r\n        emit ChannelOpened(\r\n            channel_identifier,\r\n            participant1,\r\n            participant2,\r\n            settle_timeout\r\n        );\r\n\r\n        return channel_identifier;\r\n    }\r\n\r\n    /// @notice Sets the channel participant total deposit value.\r\n    /// Can be called by anyone.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param participant Channel participant whose deposit is being set.\r\n    /// @param total_deposit The total amount of tokens that the participant\r\n    /// will have as a deposit.\r\n    /// @param partner Channel partner address, needed to compute the total\r\n    /// channel deposit.\r\n    function setTotalDeposit(\r\n        uint256 channel_identifier,\r\n        address participant,\r\n        uint256 total_deposit,\r\n        address partner\r\n    )\r\n        public\r\n        isSafe\r\n        isOpen(channel_identifier)\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(participant, partner));\r\n        require(total_deposit > 0);\r\n        require(total_deposit <= channel_participant_deposit_limit);\r\n\r\n        uint256 added_deposit;\r\n        uint256 channel_deposit;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n        Participant storage participant_state = channel.participants[participant];\r\n        Participant storage partner_state = channel.participants[partner];\r\n\r\n        // Calculate the actual amount of tokens that will be transferred\r\n        added_deposit = total_deposit - participant_state.deposit;\r\n\r\n        // The actual amount of tokens that will be transferred must be > 0\r\n        require(added_deposit > 0);\r\n\r\n        // Underflow check; we use <= because added_deposit == total_deposit for the first deposit\r\n\r\n        require(added_deposit <= total_deposit);\r\n\r\n        // This should never fail at this point. Added check for security, because we directly set\r\n        // the participant_state.deposit = total_deposit, while we transfer `added_deposit` tokens.\r\n        assert(participant_state.deposit + added_deposit == total_deposit);\r\n\r\n        // Red Eyes release token network limit\r\n        require(token.balanceOf(address(this)) + added_deposit <= token_network_deposit_limit);\r\n\r\n        // Update the participant's channel deposit\r\n        participant_state.deposit = total_deposit;\r\n\r\n        // Calculate the entire channel deposit, to avoid overflow\r\n        channel_deposit = participant_state.deposit + partner_state.deposit;\r\n        // Overflow check\r\n        require(channel_deposit >= participant_state.deposit);\r\n\r\n        emit ChannelNewDeposit(\r\n            channel_identifier,\r\n            participant,\r\n            participant_state.deposit\r\n        );\r\n\r\n        // Do the transfer\r\n        require(token.transferFrom(msg.sender, address(this), added_deposit));\r\n    }\r\n\r\n    /// @notice Allows `participant` to withdraw tokens from the channel that he\r\n    /// has with `partner`, without closing it. Can be called by anyone. Can\r\n    /// only be called once per each signed withdraw message.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param participant Channel participant, who will receive the withdrawn\r\n    /// amount.\r\n    /// @param total_withdraw Total amount of tokens that are marked as\r\n    /// withdrawn from the channel during the channel lifecycle.\r\n    /// @param participant_signature Participant's signature on the withdraw\r\n    /// data.\r\n    /// @param partner_signature Partner's signature on the withdraw data.\r\n    function setTotalWithdraw(\r\n        uint256 channel_identifier,\r\n        address participant,\r\n        uint256 total_withdraw,\r\n        uint256 expiration_block,\r\n        bytes calldata participant_signature,\r\n        bytes calldata partner_signature\r\n    )\r\n        external\r\n        isOpen(channel_identifier)\r\n    {\r\n        uint256 total_deposit;\r\n        uint256 current_withdraw;\r\n        address partner;\r\n\r\n        require(total_withdraw > 0);\r\n        require(block.number < expiration_block);\r\n\r\n        // Authenticate both channel partners via their signatures.\r\n        // `participant` is a part of the signed message, so given in the calldata.\r\n        require(participant == recoverAddressFromWithdrawMessage(\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw,\r\n            expiration_block,\r\n            participant_signature\r\n        ));\r\n        partner = recoverAddressFromWithdrawMessage(\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw,\r\n            expiration_block,\r\n            partner_signature\r\n        );\r\n\r\n        // Validate that authenticated partners and the channel identifier match\r\n        require(channel_identifier == getChannelIdentifier(participant, partner));\r\n\r\n        // Read channel state after validating the function input\r\n        Channel storage channel = channels[channel_identifier];\r\n        Participant storage participant_state = channel.participants[participant];\r\n        Participant storage partner_state = channel.participants[partner];\r\n\r\n        total_deposit = participant_state.deposit + partner_state.deposit;\r\n\r\n        // Entire withdrawn amount must not be bigger than the current channel deposit\r\n        require((total_withdraw + partner_state.withdrawn_amount) <= total_deposit);\r\n        require(total_withdraw <= (total_withdraw + partner_state.withdrawn_amount));\r\n\r\n        // Using the total_withdraw (monotonically increasing) in the signed\r\n        // message ensures that we do not allow replay attack to happen, by\r\n        // using the same withdraw proof twice.\r\n        // Next two lines enforce the monotonicity of total_withdraw and check for an underflow:\r\n        // (we use <= because current_withdraw == total_withdraw for the first withdraw)\r\n        current_withdraw = total_withdraw - participant_state.withdrawn_amount;\r\n        require(current_withdraw <= total_withdraw);\r\n\r\n        // The actual amount of tokens that will be transferred must be > 0 to disable the reuse of\r\n        // withdraw messages completely.\r\n        require(current_withdraw > 0);\r\n\r\n        // This should never fail at this point. Added check for security, because we directly set\r\n        // the participant_state.withdrawn_amount = total_withdraw,\r\n        // while we transfer `current_withdraw` tokens.\r\n        assert(participant_state.withdrawn_amount + current_withdraw == total_withdraw);\r\n\r\n        emit ChannelWithdraw(\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw\r\n        );\r\n\r\n        // Do the state change and tokens transfer\r\n        participant_state.withdrawn_amount = total_withdraw;\r\n        require(token.transfer(participant, current_withdraw));\r\n\r\n        // This should never happen, as we have an overflow check in setTotalDeposit\r\n        assert(total_deposit >= participant_state.deposit);\r\n        assert(total_deposit >= partner_state.deposit);\r\n\r\n        // A withdraw should never happen if a participant already has a\r\n        // balance proof in storage. This should never fail as we use isOpen.\r\n        assert(participant_state.nonce == 0);\r\n        assert(partner_state.nonce == 0);\r\n\r\n    }\r\n\r\n    /// @notice Close the channel defined by the two participant addresses.\r\n    /// Anybody can call this function on behalf of a participant (called\r\n    /// the closing participant), providing a balance proof signed by\r\n    /// both parties. Callable only once.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param closing_participant Channel participant who closes the channel.\r\n    /// @param non_closing_participant Channel partner of the `closing_participant`,\r\n    /// who provided the balance proof.\r\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\r\n    /// locksroot).\r\n    /// @param additional_hash Computed from the message. Used for message\r\n    /// authentication.\r\n    /// @param nonce Strictly monotonic value used to order transfers.\r\n    /// @param non_closing_signature Non-closing participant's signature of the balance proof data.\r\n    /// @param closing_signature Closing participant's signature of the balance\r\n    /// proof data.\r\n    function closeChannel(\r\n        uint256 channel_identifier,\r\n        address non_closing_participant,\r\n        address closing_participant,\r\n        // The next four arguments form a balance proof.\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes memory non_closing_signature,\r\n        bytes memory closing_signature\r\n    )\r\n        public\r\n        isOpen(channel_identifier)\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant));\r\n\r\n        address recovered_non_closing_participant_address;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        channel.state = ChannelState.Closed;\r\n        channel.participants[closing_participant].is_the_closer = true;\r\n\r\n        // This is the block number at which the channel can be settled.\r\n        channel.settle_block_number += uint256(block.number);\r\n\r\n        // The closing participant must have signed the balance proof.\r\n        address recovered_closing_participant_address = recoverAddressFromBalanceProofCounterSignature(\r\n            MessageTypeId.BalanceProof,\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            non_closing_signature,\r\n            closing_signature\r\n        );\r\n        require(closing_participant == recovered_closing_participant_address);\r\n\r\n        // Nonce 0 means that the closer never received a transfer, therefore\r\n        // never received a balance proof, or he is intentionally not providing\r\n        // the latest transfer, in which case the closing party is going to\r\n        // lose the tokens that were transferred to him.\r\n        if (nonce > 0) {\r\n            recovered_non_closing_participant_address = recoverAddressFromBalanceProof(\r\n                channel_identifier,\r\n                balance_hash,\r\n                nonce,\r\n                additional_hash,\r\n                non_closing_signature\r\n            );\r\n            // Signature must be from the channel partner\r\n            require(non_closing_participant == recovered_non_closing_participant_address);\r\n\r\n            updateBalanceProofData(\r\n                channel,\r\n                recovered_non_closing_participant_address,\r\n                nonce,\r\n                balance_hash\r\n            );\r\n        }\r\n\r\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\r\n    }\r\n\r\n    /// @notice Called on a closed channel, the function allows the non-closing\r\n    /// participant to provide the last balance proof, which modifies the\r\n    /// closing participant's state. Can be called multiple times by anyone.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param closing_participant Channel participant who closed the channel.\r\n    /// @param non_closing_participant Channel participant who needs to update\r\n    /// the balance proof.\r\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\r\n    /// locksroot).\r\n    /// @param additional_hash Computed from the message. Used for message\r\n    /// authentication.\r\n    /// @param nonce Strictly monotonic value used to order transfers.\r\n    /// @param closing_signature Closing participant's signature of the balance\r\n    /// proof data.\r\n    /// @param non_closing_signature Non-closing participant signature of the\r\n    /// balance proof data.\r\n    function updateNonClosingBalanceProof(\r\n        uint256 channel_identifier,\r\n        address closing_participant,\r\n        address non_closing_participant,\r\n        // The next four arguments form a balance proof\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes calldata closing_signature,\r\n        bytes calldata non_closing_signature\r\n    )\r\n        external\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(\r\n            closing_participant,\r\n            non_closing_participant\r\n        ));\r\n        require(balance_hash != bytes32(0x0));\r\n        require(nonce > 0);\r\n\r\n        address recovered_non_closing_participant;\r\n        address recovered_closing_participant;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        require(channel.state == ChannelState.Closed);\r\n\r\n        // Calling this function after the settlement window is forbidden to\r\n        // fix the following race condition:\r\n        //\r\n        // 1 A badly configured node A, that doesn't have a monitoring service\r\n        //   and is temporarily offline does not call update during the\r\n        //   settlement window.\r\n        // 2 The well behaved partner B, who called close, sees the\r\n        //   settlement window is over and calls settle. At this point the B's\r\n        //   balance proofs which should be provided by A is missing, so B will\r\n        //   call settle with its balance proof zeroed out.\r\n        // 3 A restarts and calls update, which will change B's balance\r\n        //   proof.\r\n        // 4 At this point, the transactions from 2 and 3 are racing, and one\r\n        //   of them will fail.\r\n        //\r\n        // To avoid the above race condition, which would require special\r\n        // handling on both nodes, the call to update is forbidden after the\r\n        // settlement window. This does not affect safety, since we assume the\r\n        // nodes are always properly configured and have a monitoring service\r\n        // available to call update on the user's behalf.\r\n        require(channel.settle_block_number >= block.number);\r\n\r\n        // We need the signature from the non-closing participant to allow\r\n        // anyone to make this transaction. E.g. a monitoring service.\r\n        recovered_non_closing_participant = recoverAddressFromBalanceProofCounterSignature(\r\n            MessageTypeId.BalanceProofUpdate,\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            closing_signature,\r\n            non_closing_signature\r\n        );\r\n        require(non_closing_participant == recovered_non_closing_participant);\r\n\r\n        recovered_closing_participant = recoverAddressFromBalanceProof(\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            closing_signature\r\n        );\r\n        require(closing_participant == recovered_closing_participant);\r\n\r\n        Participant storage closing_participant_state = channel.participants[closing_participant];\r\n        // Make sure the first signature is from the closing participant\r\n        require(closing_participant_state.is_the_closer);\r\n\r\n        // Update the balance proof data for the closing_participant\r\n        updateBalanceProofData(channel, closing_participant, nonce, balance_hash);\r\n\r\n        emit NonClosingBalanceProofUpdated(\r\n            channel_identifier,\r\n            closing_participant,\r\n            nonce,\r\n            balance_hash\r\n        );\r\n    }\r\n\r\n    /// @notice Settles the balance between the two parties. Note that arguments\r\n    /// order counts: `participant1_transferred_amount +\r\n    /// participant1_locked_amount` <= `participant2_transferred_amount +\r\n    /// participant2_locked_amount`\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param participant1 Channel participant.\r\n    /// @param participant1_transferred_amount The latest known amount of tokens\r\n    /// transferred from `participant1` to `participant2`.\r\n    /// @param participant1_locked_amount Amount of tokens owed by\r\n    /// `participant1` to `participant2`, contained in locked transfers that\r\n    /// will be retrieved by calling `unlock` after the channel is settled.\r\n    /// @param participant1_locksroot The latest known hash of the\r\n    /// pending hash-time locks of `participant1`, used to validate the unlocked\r\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored.\r\n    /// @param participant2 Other channel participant.\r\n    /// @param participant2_transferred_amount The latest known amount of tokens\r\n    /// transferred from `participant2` to `participant1`.\r\n    /// @param participant2_locked_amount Amount of tokens owed by\r\n    /// `participant2` to `participant1`, contained in locked transfers that\r\n    /// will be retrieved by calling `unlock` after the channel is settled.\r\n    /// @param participant2_locksroot The latest known hash of the\r\n    /// pending hash-time locks of `participant2`, used to validate the unlocked\r\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored.\r\n    function settleChannel(\r\n        uint256 channel_identifier,\r\n        address participant1,\r\n        uint256 participant1_transferred_amount,\r\n        uint256 participant1_locked_amount,\r\n        bytes32 participant1_locksroot,\r\n        address participant2,\r\n        uint256 participant2_transferred_amount,\r\n        uint256 participant2_locked_amount,\r\n        bytes32 participant2_locksroot\r\n    )\r\n        public\r\n    {\r\n        // There are several requirements that this function MUST enforce:\r\n        // - it MUST never fail; therefore, any overflows or underflows must be\r\n        // handled gracefully\r\n        // - it MUST ensure that if participants use the latest valid balance proofs,\r\n        // provided by the official Raiden client, the participants will be able\r\n        // to receive correct final balances at the end of the channel lifecycle\r\n        // - it MUST ensure that the participants cannot cheat by providing an\r\n        // old, valid balance proof of their partner; meaning that their partner MUST\r\n        // receive at least the amount of tokens that he would have received if\r\n        // the latest valid balance proofs are used.\r\n        // - the contract cannot determine if a balance proof is invalid (values\r\n        // are not within the constraints enforced by the official Raiden client),\r\n        // therefore it cannot ensure correctness. Users MUST use the official\r\n        // Raiden clients for signing balance proofs.\r\n\r\n        require(channel_identifier == getChannelIdentifier(participant1, participant2));\r\n\r\n        bytes32 pair_hash;\r\n\r\n        pair_hash = getParticipantsHash(participant1, participant2);\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        require(channel.state == ChannelState.Closed);\r\n\r\n        // Settlement window must be over\r\n        require(channel.settle_block_number < block.number);\r\n\r\n        Participant storage participant1_state = channel.participants[participant1];\r\n        Participant storage participant2_state = channel.participants[participant2];\r\n\r\n        require(verifyBalanceHashData(\r\n            participant1_state,\r\n            participant1_transferred_amount,\r\n            participant1_locked_amount,\r\n            participant1_locksroot\r\n        ));\r\n\r\n        require(verifyBalanceHashData(\r\n            participant2_state,\r\n            participant2_transferred_amount,\r\n            participant2_locked_amount,\r\n            participant2_locksroot\r\n        ));\r\n\r\n        // We are calculating the final token amounts that need to be\r\n        // transferred to the participants now and the amount of tokens that\r\n        // need to remain locked in the contract. These tokens can be unlocked\r\n        // by calling `unlock`.\r\n        // participant1_transferred_amount = the amount of tokens that\r\n        //   participant1 will receive in this transaction.\r\n        // participant2_transferred_amount = the amount of tokens that\r\n        //   participant2 will receive in this transaction.\r\n        // participant1_locked_amount = the amount of tokens remaining in the\r\n        //   contract, representing pending transfers from participant1 to participant2.\r\n        // participant2_locked_amount = the amount of tokens remaining in the\r\n        //   contract, representing pending transfers from participant2 to participant1.\r\n        // We are reusing variables due to the local variables number limit.\r\n        // For better readability this can be refactored further.\r\n        (\r\n            participant1_transferred_amount,\r\n            participant2_transferred_amount,\r\n            participant1_locked_amount,\r\n            participant2_locked_amount\r\n        ) = getSettleTransferAmounts(\r\n            participant1_state,\r\n            participant1_transferred_amount,\r\n            participant1_locked_amount,\r\n            participant2_state,\r\n            participant2_transferred_amount,\r\n            participant2_locked_amount\r\n        );\r\n\r\n        // Remove the channel data from storage\r\n        delete channel.participants[participant1];\r\n        delete channel.participants[participant2];\r\n        delete channels[channel_identifier];\r\n\r\n        // Remove the pair's channel counter\r\n        delete participants_hash_to_channel_identifier[pair_hash];\r\n\r\n        // Store balance data needed for `unlock`, including the calculated\r\n        // locked amounts remaining in the contract.\r\n        storeUnlockData(\r\n            channel_identifier,\r\n            participant1,\r\n            participant2,\r\n            participant1_locked_amount,\r\n            participant1_locksroot\r\n        );\r\n        storeUnlockData(\r\n            channel_identifier,\r\n            participant2,\r\n            participant1,\r\n            participant2_locked_amount,\r\n            participant2_locksroot\r\n        );\r\n\r\n        emit ChannelSettled(\r\n            channel_identifier,\r\n            participant1_transferred_amount,\r\n            participant1_locksroot,\r\n            participant2_transferred_amount,\r\n            participant2_locksroot\r\n        );\r\n\r\n        // Do the actual token transfers\r\n        if (participant1_transferred_amount > 0) {\r\n            require(token.transfer(participant1, participant1_transferred_amount));\r\n        }\r\n\r\n        if (participant2_transferred_amount > 0) {\r\n            require(token.transfer(participant2, participant2_transferred_amount));\r\n        }\r\n    }\r\n\r\n    /// @notice Unlocks all pending off-chain transfers from `sender` to\r\n    /// `receiver` and sends the locked tokens corresponding to locks with\r\n    /// secrets registered on-chain to the `receiver`. Locked tokens\r\n    /// corresponding to locks where the secret was not revealed on-chain will\r\n    /// return to the `sender`. Anyone can call unlock.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param receiver Address who will receive the claimable unlocked\r\n    /// tokens.\r\n    /// @param sender Address who sent the pending transfers and will receive\r\n    /// the unclaimable unlocked tokens.\r\n    /// @param locks All pending locks concatenated in order of creation.\r\n    /// that `sender` sent to `receiver`.\r\n    function unlock(\r\n        uint256 channel_identifier,\r\n        address receiver,\r\n        address sender,\r\n        bytes memory locks\r\n    )\r\n        public\r\n    {\r\n        // Channel represented by channel_identifier must be settled and\r\n        // channel data deleted\r\n        require(channel_identifier != getChannelIdentifier(receiver, sender));\r\n\r\n        // After the channel is settled the storage is cleared, therefore the\r\n        // value will be NonExistent and not Settled. The value Settled is used\r\n        // for the external APIs\r\n        require(channels[channel_identifier].state == ChannelState.NonExistent);\r\n\r\n        bytes32 unlock_key;\r\n        bytes32 computed_locksroot;\r\n        uint256 unlocked_amount;\r\n        uint256 locked_amount;\r\n        uint256 returned_tokens;\r\n\r\n        // Calculate the locksroot for the pending transfers and the amount of\r\n        // tokens corresponding to the locked transfers with secrets revealed\r\n        // on chain.\r\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\r\n            locks\r\n        );\r\n\r\n        // The sender must have a non-empty locksroot on-chain that must be\r\n        // the same as the computed locksroot.\r\n        // Get the amount of tokens that have been left in the contract, to\r\n        // account for the pending transfers `sender` -> `receiver`.\r\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\r\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\r\n        locked_amount = unlock_data.locked_amount;\r\n\r\n        // Locksroot must be the same as the computed locksroot\r\n        require(unlock_data.locksroot == computed_locksroot);\r\n\r\n        // There are no pending transfers if the locked_amount is 0.\r\n        // Transaction must fail\r\n        require(locked_amount > 0);\r\n\r\n        // Make sure we don't transfer more tokens than previously reserved in\r\n        // the smart contract.\r\n        unlocked_amount = min(unlocked_amount, locked_amount);\r\n\r\n        // Transfer the rest of the tokens back to the sender\r\n        returned_tokens = locked_amount - unlocked_amount;\r\n\r\n        // Remove sender's unlock data\r\n        delete unlock_identifier_to_unlock_data[unlock_key];\r\n\r\n        emit ChannelUnlocked(\r\n            channel_identifier,\r\n            receiver,\r\n            sender,\r\n            computed_locksroot,\r\n            unlocked_amount,\r\n            returned_tokens\r\n        );\r\n\r\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\r\n        // be 0\r\n        if (unlocked_amount > 0) {\r\n            require(token.transfer(receiver, unlocked_amount));\r\n        }\r\n\r\n        // Transfer the rest of the tokens back to the sender\r\n        if (returned_tokens > 0) {\r\n            require(token.transfer(sender, returned_tokens));\r\n        }\r\n\r\n        // At this point, this should always be true\r\n        assert(locked_amount >= returned_tokens);\r\n        assert(locked_amount >= unlocked_amount);\r\n    }\r\n\r\n    /* /// @notice Cooperatively settles the balances between the two channel\r\n    /// participants and transfers the agreed upon token amounts to the\r\n    /// participants. After this the channel lifecycle has ended and no more\r\n    /// operations can be done on it.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param participant1_address Address of channel participant.\r\n    /// @param participant1_balance Amount of tokens that `participant1_address`\r\n    /// must receive when the channel is settled and removed.\r\n    /// @param participant2_address Address of the other channel participant.\r\n    /// @param participant2_balance Amount of tokens that `participant2_address`\r\n    /// must receive when the channel is settled and removed.\r\n    /// @param participant1_signature Signature of `participant1_address` on the\r\n    /// cooperative settle message.\r\n    /// @param participant2_signature Signature of `participant2_address` on the\r\n    /// cooperative settle message.\r\n    function cooperativeSettle(\r\n        uint256 channel_identifier,\r\n        address participant1_address,\r\n        uint256 participant1_balance,\r\n        address participant2_address,\r\n        uint256 participant2_balance,\r\n        bytes participant1_signature,\r\n        bytes participant2_signature\r\n    )\r\n        public\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(\r\n            participant1_address,\r\n            participant2_address\r\n        ));\r\n        bytes32 pair_hash;\r\n        address participant1;\r\n        address participant2;\r\n        uint256 total_available_deposit;\r\n\r\n        pair_hash = getParticipantsHash(participant1_address, participant2_address);\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        require(channel.state == ChannelState.Opened);\r\n\r\n        participant1 = recoverAddressFromCooperativeSettleSignature(\r\n            channel_identifier,\r\n            participant1_address,\r\n            participant1_balance,\r\n            participant2_address,\r\n            participant2_balance,\r\n            participant1_signature\r\n        );\r\n        // The provided address must be the same as the recovered one\r\n        require(participant1 == participant1_address);\r\n\r\n        participant2 = recoverAddressFromCooperativeSettleSignature(\r\n            channel_identifier,\r\n            participant1_address,\r\n            participant1_balance,\r\n            participant2_address,\r\n            participant2_balance,\r\n            participant2_signature\r\n        );\r\n        // The provided address must be the same as the recovered one\r\n        require(participant2 == participant2_address);\r\n\r\n        Participant storage participant1_state = channel.participants[participant1];\r\n        Participant storage participant2_state = channel.participants[participant2];\r\n\r\n        total_available_deposit = getChannelAvailableDeposit(\r\n            participant1_state,\r\n            participant2_state\r\n        );\r\n        // The sum of the provided balances must be equal to the total\r\n        // available deposit\r\n        require(total_available_deposit == (participant1_balance + participant2_balance));\r\n        // Overflow check for the balances addition from the above check.\r\n        // This overflow should never happen if the token.transfer function is implemented\r\n        // correctly. We do not control the token implementation, therefore we add this\r\n        // check for safety.\r\n        require(participant1_balance <= participant1_balance + participant2_balance);\r\n\r\n        // Remove channel data from storage before doing the token transfers\r\n        delete channel.participants[participant1];\r\n        delete channel.participants[participant2];\r\n        delete channels[channel_identifier];\r\n\r\n        // Remove the pair's channel counter\r\n        delete participants_hash_to_channel_identifier[pair_hash];\r\n\r\n        emit ChannelSettled(channel_identifier, participant1_balance, participant2_balance);\r\n\r\n        // Do the token transfers\r\n        if (participant1_balance > 0) {\r\n            require(token.transfer(participant1, participant1_balance));\r\n        }\r\n\r\n        if (participant2_balance > 0) {\r\n            require(token.transfer(participant2, participant2_balance));\r\n        }\r\n    } */\r\n\r\n    /// @notice Returns the unique identifier for the channel given by the\r\n    /// contract.\r\n    /// @param participant Address of a channel participant.\r\n    /// @param partner Address of the other channel participant.\r\n    /// @return Unique identifier for the channel. It can be 0 if channel does\r\n    /// not exist.\r\n    function getChannelIdentifier(address participant, address partner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(participant != address(0x0));\r\n        require(partner != address(0x0));\r\n        require(participant != partner);\r\n\r\n        bytes32 pair_hash = getParticipantsHash(participant, partner);\r\n        return participants_hash_to_channel_identifier[pair_hash];\r\n    }\r\n\r\n    /// @dev Returns the channel specific data.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param participant1 Address of a channel participant.\r\n    /// @param participant2 Address of the other channel participant.\r\n    /// @return Channel settle_block_number and state.\r\n    /// @notice The contract cannot really distinguish Settled and Removed\r\n    /// states, especially when wrong participants are given as input.\r\n    /// The contract does not remember the participants of the channel.\r\n    function getChannelInfo(\r\n        uint256 channel_identifier,\r\n        address participant1,\r\n        address participant2\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, ChannelState)\r\n    {\r\n        bytes32 unlock_key1;\r\n        bytes32 unlock_key2;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n        ChannelState state = channel.state;  // This must **not** update the storage\r\n\r\n        if (state == ChannelState.NonExistent &&\r\n            channel_identifier > 0 &&\r\n            channel_identifier <= channel_counter\r\n        ) {\r\n            // The channel has been settled, channel data is removed Therefore,\r\n            // the channel state in storage is actually `0`, or `NonExistent`\r\n            // However, for this view function, we return `Settled`, in order\r\n            // to provide a consistent external API\r\n            state = ChannelState.Settled;\r\n\r\n            // We might still have data stored for future unlock operations\r\n            // Only if we do not, we can consider the channel as `Removed`\r\n            unlock_key1 = getUnlockIdentifier(channel_identifier, participant1, participant2);\r\n            UnlockData storage unlock_data1 = unlock_identifier_to_unlock_data[unlock_key1];\r\n\r\n            unlock_key2 = getUnlockIdentifier(channel_identifier, participant2, participant1);\r\n            UnlockData storage unlock_data2 = unlock_identifier_to_unlock_data[unlock_key2];\r\n\r\n            if (unlock_data1.locked_amount == 0 && unlock_data2.locked_amount == 0) {\r\n                state = ChannelState.Removed;\r\n            }\r\n        }\r\n\r\n        return (\r\n            channel.settle_block_number,\r\n            state\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the channel specific data.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place.\r\n    /// @param participant Address of the channel participant whose data will be\r\n    /// returned.\r\n    /// @param partner Address of the channel partner.\r\n    /// @return Participant's deposit, withdrawn_amount, whether the participant\r\n    /// has called `closeChannel` or not, balance_hash, nonce, locksroot,\r\n    /// locked_amount.\r\n    function getChannelParticipantInfo(\r\n            uint256 channel_identifier,\r\n            address participant,\r\n            address partner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, uint256, bool, bytes32, uint256, bytes32, uint256)\r\n    {\r\n        bytes32 unlock_key;\r\n\r\n        Participant storage participant_state = channels[channel_identifier].participants[\r\n            participant\r\n        ];\r\n        unlock_key = getUnlockIdentifier(channel_identifier, participant, partner);\r\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\r\n\r\n        return (\r\n            participant_state.deposit,\r\n            participant_state.withdrawn_amount,\r\n            participant_state.is_the_closer,\r\n            participant_state.balance_hash,\r\n            participant_state.nonce,\r\n            unlock_data.locksroot,\r\n            unlock_data.locked_amount\r\n        );\r\n    }\r\n\r\n    /// @dev Get the hash of the participant addresses, ordered\r\n    /// lexicographically.\r\n    /// @param participant Address of a channel participant.\r\n    /// @param partner Address of the other channel participant.\r\n    function getParticipantsHash(address participant, address partner)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(participant != address(0x0));\r\n        require(partner != address(0x0));\r\n        require(participant != partner);\r\n\r\n        if (participant < partner) {\r\n            return keccak256(abi.encodePacked(participant, partner));\r\n        } else {\r\n            return keccak256(abi.encodePacked(partner, participant));\r\n        }\r\n    }\r\n\r\n    /// @dev Get the hash of the channel identifier and the participant\r\n    /// addresses (whose ordering matters). The hash might be useful for\r\n    /// the receiver to look up the appropriate UnlockData to claim.\r\n    /// @param channel_identifier Identifier for the channel which the\r\n    /// UnlockData is about.\r\n    /// @param sender Sender of the pending transfers that the UnlockData\r\n    /// represents.\r\n    /// @param receiver Receiver of the pending transfers that the UnlockData\r\n    /// represents.\r\n    function getUnlockIdentifier(\r\n        uint256 channel_identifier,\r\n        address sender,\r\n        address receiver\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(sender != receiver);\r\n        return keccak256(abi.encodePacked(channel_identifier, sender, receiver));\r\n    }\r\n\r\n    function updateBalanceProofData(\r\n        Channel storage channel,\r\n        address participant,\r\n        uint256 nonce,\r\n        bytes32 balance_hash\r\n    )\r\n        internal\r\n    {\r\n        Participant storage participant_state = channel.participants[participant];\r\n\r\n        // Multiple calls to updateNonClosingBalanceProof can be made and we\r\n        // need to store the last known balance proof data.\r\n        // This line prevents Monitoring Services from getting rewards\r\n        // again and again using the same reward proof.\r\n        require(nonce > participant_state.nonce);\r\n\r\n        participant_state.nonce = nonce;\r\n        participant_state.balance_hash = balance_hash;\r\n    }\r\n\r\n    function storeUnlockData(\r\n        uint256 channel_identifier,\r\n        address sender,\r\n        address receiver,\r\n        uint256 locked_amount,\r\n        bytes32 locksroot\r\n    )\r\n        internal\r\n    {\r\n        // If there are transfers to unlock, store the locksroot and total\r\n        // amount of tokens\r\n        if (locked_amount == 0) {\r\n            return;\r\n        }\r\n\r\n        bytes32 key = getUnlockIdentifier(channel_identifier, sender, receiver);\r\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[key];\r\n        unlock_data.locksroot = locksroot;\r\n        unlock_data.locked_amount = locked_amount;\r\n    }\r\n\r\n    function getChannelAvailableDeposit(\r\n        Participant storage participant1_state,\r\n        Participant storage participant2_state\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 total_available_deposit)\r\n    {\r\n        total_available_deposit = (\r\n            participant1_state.deposit +\r\n            participant2_state.deposit -\r\n            participant1_state.withdrawn_amount -\r\n            participant2_state.withdrawn_amount\r\n        );\r\n    }\r\n\r\n    /// @dev Function that calculates the amount of tokens that the participants\r\n    /// will receive when calling settleChannel.\r\n    /// Check https://github.com/raiden-network/raiden-contracts/issues/188 for the settlement\r\n    /// algorithm analysis and explanations.\r\n    function getSettleTransferAmounts(\r\n        Participant storage participant1_state,\r\n        uint256 participant1_transferred_amount,\r\n        uint256 participant1_locked_amount,\r\n        Participant storage participant2_state,\r\n        uint256 participant2_transferred_amount,\r\n        uint256 participant2_locked_amount\r\n    )\r\n        private\r\n        view\r\n        returns (uint256, uint256, uint256, uint256)\r\n    {\r\n        // The scope of this function is to compute the settlement amounts that\r\n        // the two channel participants will receive when calling settleChannel\r\n        // and the locked amounts that remain in the contract, to account for\r\n        // the pending, not finalized transfers, that will be received by the\r\n        // participants when calling `unlock`.\r\n\r\n        // The amount of tokens that participant1 MUST receive at the end of\r\n        // the channel lifecycle (after settleChannel and unlock) is:\r\n        // B1 = D1 - W1 + T2 - T1 + Lc2 - Lc1\r\n\r\n        // The amount of tokens that participant2 MUST receive at the end of\r\n        // the channel lifecycle (after settleChannel and unlock) is:\r\n        // B2 = D2 - W2 + T1 - T2 + Lc1 - Lc2\r\n\r\n        // B1 + B2 = TAD = D1 + D2 - W1 - W2\r\n        // TAD = total available deposit at settlement time\r\n\r\n        // L1 = Lc1 + Lu1\r\n        // L2 = Lc2 + Lu2\r\n\r\n        // where:\r\n        // B1 = final balance of participant1 after the channel is removed\r\n        // D1 = total amount deposited by participant1 into the channel\r\n        // W1 = total amount withdrawn by participant1 from the channel\r\n        // T2 = total amount transferred by participant2 to participant1 (finalized transfers)\r\n        // T1 = total amount transferred by participant1 to participant2 (finalized transfers)\r\n        // L1 = total amount of tokens locked in pending transfers, sent by\r\n        //   participant1 to participant2\r\n        // L2 = total amount of tokens locked in pending transfers, sent by\r\n        //   participant2 to participant1\r\n        // Lc2 = the amount that can be claimed by participant1 from the pending\r\n        //   transfers (that have not been finalized off-chain), sent by\r\n        //   participant2 to participant1. These are part of the locked amount\r\n        //   value from participant2's balance proof. They are considered claimed\r\n        //   if the secret corresponding to these locked transfers was registered\r\n        //   on-chain, in the SecretRegistry contract, before the lock's expiration.\r\n        // Lu1 = unclaimable locked amount from L1\r\n        // Lc1 = the amount that can be claimed by participant2 from the pending\r\n        //   transfers (that have not been finalized off-chain),\r\n        //   sent by participant1 to participant2\r\n        // Lu2 = unclaimable locked amount from L2\r\n\r\n        // Notes:\r\n        // 1) The unclaimble tokens from a locked amount will return to the sender.\r\n        // At the time of calling settleChannel, the TokenNetwork contract does\r\n        // not know what locked amounts are claimable or unclaimable.\r\n        // 2) There are some Solidity constraints that make the calculations\r\n        // more difficult: attention to overflows and underflows, that MUST be\r\n        // handled without throwing.\r\n\r\n        // Cases that require attention:\r\n        // case1. If participant1 does NOT provide a balance proof or provides\r\n        // an old balance proof.  participant2_transferred_amount can be [0,\r\n        // real_participant2_transferred_amount) We MUST NOT punish\r\n        // participant2.\r\n        // case2. If participant2 does NOT provide a balance proof or provides\r\n        // an old balance proof.  participant1_transferred_amount can be [0,\r\n        // real_participant1_transferred_amount) We MUST NOT punish\r\n        // participant1.\r\n        // case3. If neither participants provide a balance proof, we just\r\n        // subtract their withdrawn amounts from their deposits.\r\n\r\n        // This is why, the algorithm implemented in Solidity is:\r\n        // (explained at each step, below)\r\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\r\n        // RmaxP1 = min(TAD, RmaxP1)\r\n        // RmaxP2 = TAD - RmaxP1\r\n        // SL2 = min(RmaxP1, L2)\r\n        // S1 = RmaxP1 - SL2\r\n        // SL1 = min(RmaxP2, L1)\r\n        // S2 = RmaxP2 - SL1\r\n\r\n        // where:\r\n        // RmaxP1 = due to possible over/underflows that only appear when using\r\n        //    old balance proofs & the fact that settlement balance calculation\r\n        //    is symmetric (we can calculate either RmaxP1 and RmaxP2 first,\r\n        //    order does not affect result), this is a convention used to determine\r\n        //    the maximum receivable amount of participant1 at settlement time\r\n        // S1 = amount received by participant1 when calling settleChannel\r\n        // SL1 = the maximum amount from L1 that can be locked in the\r\n        //   TokenNetwork contract when calling settleChannel (due to overflows\r\n        //   that only happen when using old balance proofs)\r\n        // S2 = amount received by participant2 when calling settleChannel\r\n        // SL2 = the maximum amount from L2 that can be locked in the\r\n        //   TokenNetwork contract when calling settleChannel (due to overflows\r\n        //   that only happen when using old balance proofs)\r\n\r\n        uint256 participant1_amount;\r\n        uint256 participant2_amount;\r\n        uint256 total_available_deposit;\r\n\r\n        SettlementData memory participant1_settlement;\r\n        SettlementData memory participant2_settlement;\r\n\r\n        participant1_settlement.deposit = participant1_state.deposit;\r\n        participant1_settlement.withdrawn = participant1_state.withdrawn_amount;\r\n        participant1_settlement.transferred = participant1_transferred_amount;\r\n        participant1_settlement.locked = participant1_locked_amount;\r\n\r\n        participant2_settlement.deposit = participant2_state.deposit;\r\n        participant2_settlement.withdrawn = participant2_state.withdrawn_amount;\r\n        participant2_settlement.transferred = participant2_transferred_amount;\r\n        participant2_settlement.locked = participant2_locked_amount;\r\n\r\n        // TAD = D1 + D2 - W1 - W2 = total available deposit at settlement time\r\n        total_available_deposit = getChannelAvailableDeposit(\r\n            participant1_state,\r\n            participant2_state\r\n        );\r\n\r\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\r\n        // This amount is the maximum possible amount that participant1 can\r\n        // receive at settlement time and also contains the entire locked amount\r\n        //  of the pending transfers from participant2 to participant1.\r\n        participant1_amount = getMaxPossibleReceivableAmount(\r\n            participant1_settlement,\r\n            participant2_settlement\r\n        );\r\n\r\n        // RmaxP1 = min(TAD, RmaxP1)\r\n        // We need to bound this to the available channel deposit in order to\r\n        // not send tokens from other channels. The only case where TAD is\r\n        // smaller than RmaxP1 is when at least one balance proof is old.\r\n        participant1_amount = min(participant1_amount, total_available_deposit);\r\n\r\n        // RmaxP2 = TAD - RmaxP1\r\n        // Now it is safe to subtract without underflow\r\n        participant2_amount = total_available_deposit - participant1_amount;\r\n\r\n        // SL2 = min(RmaxP1, L2)\r\n        // S1 = RmaxP1 - SL2\r\n        // Both operations are done by failsafe_subtract\r\n        // We take out participant2's pending transfers locked amount, bounding\r\n        // it by the maximum receivable amount of participant1\r\n        (participant1_amount, participant2_locked_amount) = failsafe_subtract(\r\n            participant1_amount,\r\n            participant2_locked_amount\r\n        );\r\n\r\n        // SL1 = min(RmaxP2, L1)\r\n        // S2 = RmaxP2 - SL1\r\n        // Both operations are done by failsafe_subtract\r\n        // We take out participant1's pending transfers locked amount, bounding\r\n        // it by the maximum receivable amount of participant2\r\n        (participant2_amount, participant1_locked_amount) = failsafe_subtract(\r\n            participant2_amount,\r\n            participant1_locked_amount\r\n        );\r\n\r\n        // This should never throw:\r\n        // S1 and S2 MUST be smaller than TAD\r\n        assert(participant1_amount <= total_available_deposit);\r\n        assert(participant2_amount <= total_available_deposit);\r\n        // S1 + S2 + SL1 + SL2 == TAD\r\n        assert(total_available_deposit == (\r\n            participant1_amount +\r\n            participant2_amount +\r\n            participant1_locked_amount +\r\n            participant2_locked_amount\r\n        ));\r\n\r\n        return (\r\n            participant1_amount,\r\n            participant2_amount,\r\n            participant1_locked_amount,\r\n            participant2_locked_amount\r\n        );\r\n    }\r\n\r\n    function getMaxPossibleReceivableAmount(\r\n        SettlementData memory participant1_settlement,\r\n        SettlementData memory participant2_settlement\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 participant1_max_transferred;\r\n        uint256 participant2_max_transferred;\r\n        uint256 participant1_net_max_received;\r\n        uint256 participant1_max_amount;\r\n\r\n        // This is the maximum possible amount that participant1 could transfer\r\n        // to participant2, if all the pending lock secrets have been\r\n        // registered\r\n        participant1_max_transferred = failsafe_addition(\r\n            participant1_settlement.transferred,\r\n            participant1_settlement.locked\r\n        );\r\n\r\n        // This is the maximum possible amount that participant2 could transfer\r\n        // to participant1, if all the pending lock secrets have been\r\n        // registered\r\n        participant2_max_transferred = failsafe_addition(\r\n            participant2_settlement.transferred,\r\n            participant2_settlement.locked\r\n        );\r\n\r\n        // We enforce this check artificially, in order to get rid of hard\r\n        // to deal with over/underflows. Settlement balance calculation is\r\n        // symmetric (we can calculate either RmaxP1 and RmaxP2 first, order does\r\n        // not affect result). This means settleChannel must be called with\r\n        // ordered values.\r\n        require(participant2_max_transferred >= participant1_max_transferred);\r\n\r\n        assert(participant1_max_transferred >= participant1_settlement.transferred);\r\n        assert(participant2_max_transferred >= participant2_settlement.transferred);\r\n\r\n        // This is the maximum amount that participant1 can receive at settlement time\r\n        participant1_net_max_received = (\r\n            participant2_max_transferred -\r\n            participant1_max_transferred\r\n        );\r\n\r\n        // Next, we add the participant1's deposit and subtract the already\r\n        // withdrawn amount\r\n        participant1_max_amount = failsafe_addition(\r\n            participant1_net_max_received,\r\n            participant1_settlement.deposit\r\n        );\r\n\r\n        // Subtract already withdrawn amount\r\n        (participant1_max_amount, ) = failsafe_subtract(\r\n            participant1_max_amount,\r\n            participant1_settlement.withdrawn\r\n        );\r\n        return participant1_max_amount;\r\n    }\r\n\r\n    function verifyBalanceHashData(\r\n        Participant storage participant,\r\n        uint256 transferred_amount,\r\n        uint256 locked_amount,\r\n        bytes32 locksroot\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // When no balance proof has been provided, we need to check this\r\n        // separately because hashing values of 0 outputs a value != 0\r\n        if (participant.balance_hash == 0 &&\r\n            transferred_amount == 0 &&\r\n            locked_amount == 0\r\n            /* locksroot is ignored. */\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        // Make sure the hash of the provided state is the same as the stored\r\n        // balance_hash\r\n        return participant.balance_hash == keccak256(abi.encodePacked(\r\n            transferred_amount,\r\n            locked_amount,\r\n            locksroot\r\n        ));\r\n    }\r\n\r\n    function recoverAddressFromBalanceProof(\r\n        uint256 channel_identifier,\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32\r\n        string memory message_length = '212';\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(MessageTypeId.BalanceProof),\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, signature);\r\n    }\r\n\r\n    function recoverAddressFromBalanceProofCounterSignature(\r\n        MessageTypeId message_type_id,\r\n        uint256 channel_identifier,\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes memory closing_signature,\r\n        bytes memory non_closing_signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32 + 65\r\n        string memory message_length = '277';\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(message_type_id),\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            closing_signature\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, non_closing_signature);\r\n    }\r\n\r\n    /* function recoverAddressFromCooperativeSettleSignature(\r\n        uint256 channel_identifier,\r\n        address participant1,\r\n        uint256 participant1_balance,\r\n        address participant2,\r\n        uint256 participant2_balance,\r\n        bytes signature\r\n    )\r\n        view\r\n        internal\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 20 + 32\r\n        string memory message_length = '220';\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(MessageTypeId.CooperativeSettle),\r\n            channel_identifier,\r\n            participant1,\r\n            participant1_balance,\r\n            participant2,\r\n            participant2_balance\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, signature);\r\n    } */\r\n\r\n    function recoverAddressFromWithdrawMessage(\r\n        uint256 channel_identifier,\r\n        address participant,\r\n        uint256 total_withdraw,\r\n        uint256 expiration_block,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 32\r\n        string memory message_length = '200';\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(MessageTypeId.Withdraw),\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw,\r\n            expiration_block\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, signature);\r\n    }\r\n\r\n    /// @dev Calculates the hash of the pending transfers data and\r\n    /// calculates the amount of tokens that can be unlocked because the secret\r\n    /// was registered on-chain.\r\n    function getHashAndUnlockedAmount(bytes memory locks)\r\n        internal\r\n        view\r\n        returns (bytes32, uint256)\r\n    {\r\n        uint256 length = locks.length;\r\n\r\n        // each lock has this form:\r\n        // (locked_amount || expiration_block || secrethash) = 3 * 32 bytes\r\n        require(length % 96 == 0);\r\n\r\n        uint256 i;\r\n        uint256 total_unlocked_amount;\r\n        uint256 unlocked_amount;\r\n        bytes32 lockhash;\r\n        bytes32 total_hash;\r\n\r\n        for (i = 32; i < length; i += 96) {\r\n            unlocked_amount = getLockedAmountFromLock(locks, i);\r\n            total_unlocked_amount += unlocked_amount;\r\n        }\r\n\r\n        total_hash = keccak256(locks);\r\n\r\n        return (total_hash, total_unlocked_amount);\r\n    }\r\n\r\n    function getLockedAmountFromLock(bytes memory locks, uint256 offset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 expiration_block;\r\n        uint256 locked_amount;\r\n        uint256 reveal_block;\r\n        bytes32 secrethash;\r\n\r\n        if (locks.length <= offset) {\r\n            return 0;\r\n        }\r\n\r\n        assembly {\r\n            expiration_block := mload(add(locks, offset))\r\n            locked_amount := mload(add(locks, add(offset, 32)))\r\n            secrethash := mload(add(locks, add(offset, 64)))\r\n        }\r\n\r\n        // Check if the lock's secret was revealed in the SecretRegistry The\r\n        // secret must have been revealed in the SecretRegistry contract before\r\n        // the lock's expiration_block in order for the hash time lock transfer\r\n        // to be successful.\r\n        reveal_block = secret_registry.getSecretRevealBlockHeight(secrethash);\r\n        if (reveal_block == 0 || expiration_block <= reveal_block) {\r\n            locked_amount = 0;\r\n        }\r\n\r\n        return locked_amount;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /// @dev Special subtraction function that does not fail when underflowing.\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Minimum between the result of the subtraction and 0, the maximum\r\n    /// subtrahend for which no underflow occurs.\r\n    function failsafe_subtract(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, uint256)\r\n    {\r\n        return a > b ? (a - b, b) : (0, a);\r\n    }\r\n\r\n    /// @dev Special addition function that does not fail when overflowing.\r\n    /// @param a Addend\r\n    /// @param b Addend\r\n    /// @return Maximum between the result of the addition or the maximum\r\n    /// uint256 value.\r\n    function failsafe_addition(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 sum = a + b;\r\n        return sum >= a ? sum : MAX_SAFE_UINT256;\r\n    }\r\n}\r\n\r\n\r\n/// @title TokenNetworkRegistry\r\n/// @notice The TokenNetwork Registry deploys new TokenNetwork contracts for the\r\n/// Raiden Network protocol.\r\ncontract TokenNetworkRegistry is Utils {\r\n    address public secret_registry_address;\r\n    uint256 public chain_id;\r\n    uint256 public settlement_timeout_min;\r\n    uint256 public settlement_timeout_max;\r\n    uint256 public max_token_networks;\r\n\r\n    // Only for the limited Red Eyes release\r\n    address public deprecation_executor;\r\n    uint256 public token_network_created = 0;\r\n\r\n    // Token address => TokenNetwork address\r\n    mapping(address => address) public token_to_token_networks;\r\n\r\n    event TokenNetworkCreated(address indexed token_address, address indexed token_network_address);\r\n\r\n    modifier canCreateTokenNetwork() {\r\n        require(token_network_created < max_token_networks, \"registry full\");\r\n        _;\r\n    }\r\n\r\n    /// @param _secret_registry_address The address of SecretRegistry that's used by all\r\n    /// TokenNetworks created by this contract.\r\n    /// @param _chain_id EIP-155 Chain-ID of the chain where this contract is deployed.\r\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening.\r\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening.\r\n    /// @param _max_token_networks the number of tokens that can be registered.\r\n    /// MAX_UINT256 means no limits.\r\n    constructor(\r\n        address _secret_registry_address,\r\n        uint256 _chain_id,\r\n        uint256 _settlement_timeout_min,\r\n        uint256 _settlement_timeout_max,\r\n        uint256 _max_token_networks\r\n    )\r\n        public\r\n    {\r\n        require(_chain_id > 0);\r\n        require(_settlement_timeout_min > 0);\r\n        require(_settlement_timeout_max > 0);\r\n        require(_settlement_timeout_max > _settlement_timeout_min);\r\n        require(_secret_registry_address != address(0x0));\r\n        require(contractExists(_secret_registry_address));\r\n        require(_max_token_networks > 0);\r\n        secret_registry_address = _secret_registry_address;\r\n        chain_id = _chain_id;\r\n        settlement_timeout_min = _settlement_timeout_min;\r\n        settlement_timeout_max = _settlement_timeout_max;\r\n        max_token_networks = _max_token_networks;\r\n\r\n        deprecation_executor = msg.sender;\r\n    }\r\n\r\n    /// @notice Deploy a new TokenNetwork contract for the Token deployed at\r\n    /// `_token_address`.\r\n    /// @param _token_address Ethereum address of an already deployed token, to\r\n    /// be used in the new TokenNetwork contract.\r\n    function createERC20TokenNetwork(\r\n        address _token_address,\r\n        uint256 _channel_participant_deposit_limit,\r\n        uint256 _token_network_deposit_limit\r\n    )\r\n        external\r\n        canCreateTokenNetwork\r\n        returns (address token_network_address)\r\n    {\r\n        require(token_to_token_networks[_token_address] == address(0x0));\r\n\r\n        // We limit the number of token networks to 1 for the Bug Bounty release\r\n        token_network_created = token_network_created + 1;\r\n\r\n        TokenNetwork token_network;\r\n\r\n        // Token contract checks are in the corresponding TokenNetwork contract\r\n        token_network = new TokenNetwork(\r\n            _token_address,\r\n            secret_registry_address,\r\n            chain_id,\r\n            settlement_timeout_min,\r\n            settlement_timeout_max,\r\n            deprecation_executor,\r\n            _channel_participant_deposit_limit,\r\n            _token_network_deposit_limit\r\n        );\r\n\r\n        token_network_address = address(token_network);\r\n\r\n        token_to_token_networks[_token_address] = token_network_address;\r\n        emit TokenNetworkCreated(_token_address, token_network_address);\r\n\r\n        return token_network_address;\r\n    }\r\n}\r\n\r\n// MIT License\r\n\r\n// Copyright (c) 2018\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"locks\",\"type\":\"bytes\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant1\",\"type\":\"address\"},{\"name\":\"participant2\",\"type\":\"address\"},{\"name\":\"settle_timeout\",\"type\":\"uint256\"}],\"name\":\"openChannel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deprecate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlement_timeout_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deprecation_executor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secret_registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chain_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_network_deposit_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"participants_hash_to_channel_identifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_participant_deposit_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"total_deposit\",\"type\":\"uint256\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"setTotalDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SAFE_UINT256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getParticipantsHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"name\":\"closing_participant\",\"type\":\"address\"},{\"name\":\"balance_hash\",\"type\":\"bytes32\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"additional_hash\",\"type\":\"bytes32\"},{\"name\":\"non_closing_signature\",\"type\":\"bytes\"},{\"name\":\"closing_signature\",\"type\":\"bytes\"}],\"name\":\"closeChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant1\",\"type\":\"address\"},{\"name\":\"participant2\",\"type\":\"address\"}],\"name\":\"getChannelInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signature_prefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getChannelIdentifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant1\",\"type\":\"address\"},{\"name\":\"participant1_transferred_amount\",\"type\":\"uint256\"},{\"name\":\"participant1_locked_amount\",\"type\":\"uint256\"},{\"name\":\"participant1_locksroot\",\"type\":\"bytes32\"},{\"name\":\"participant2\",\"type\":\"address\"},{\"name\":\"participant2_transferred_amount\",\"type\":\"uint256\"},{\"name\":\"participant2_locked_amount\",\"type\":\"uint256\"},{\"name\":\"participant2_locksroot\",\"type\":\"bytes32\"}],\"name\":\"settleChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"total_withdraw\",\"type\":\"uint256\"},{\"name\":\"expiration_block\",\"type\":\"uint256\"},{\"name\":\"participant_signature\",\"type\":\"bytes\"},{\"name\":\"partner_signature\",\"type\":\"bytes\"}],\"name\":\"setTotalWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safety_deprecation_switch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlement_timeout_min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"channels\",\"outputs\":[{\"name\":\"settle_block_number\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getChannelParticipantInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"closing_participant\",\"type\":\"address\"},{\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"name\":\"balance_hash\",\"type\":\"bytes32\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"additional_hash\",\"type\":\"bytes32\"},{\"name\":\"closing_signature\",\"type\":\"bytes\"},{\"name\":\"non_closing_signature\",\"type\":\"bytes\"}],\"name\":\"updateNonClosingBalanceProof\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getUnlockIdentifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_secret_registry\",\"type\":\"address\"},{\"name\":\"_chain_id\",\"type\":\"uint256\"},{\"name\":\"_settlement_timeout_min\",\"type\":\"uint256\"},{\"name\":\"_settlement_timeout_max\",\"type\":\"uint256\"},{\"name\":\"_deprecation_executor\",\"type\":\"address\"},{\"name\":\"_channel_participant_deposit_limit\",\"type\":\"uint256\"},{\"name\":\"_token_network_deposit_limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"participant1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"participant2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"settle_timeout\",\"type\":\"uint256\"}],\"name\":\"ChannelOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total_deposit\",\"type\":\"uint256\"}],\"name\":\"ChannelNewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"new_value\",\"type\":\"bool\"}],\"name\":\"DeprecationSwitch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total_withdraw\",\"type\":\"uint256\"}],\"name\":\"ChannelWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"closing_participant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance_hash\",\"type\":\"bytes32\"}],\"name\":\"ChannelClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"locksroot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"unlocked_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"returned_tokens\",\"type\":\"uint256\"}],\"name\":\"ChannelUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"closing_participant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance_hash\",\"type\":\"bytes32\"}],\"name\":\"NonClosingBalanceProofUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant1_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant1_locksroot\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"participant2_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant2_locksroot\",\"type\":\"bytes32\"}],\"name\":\"ChannelSettled\",\"type\":\"event\"}]","ContractName":"TokenNetwork","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a2326035900000000000000000000000008f730e5f5596cbd77c242cf1856ed8b7f3f1d50000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000879a4000000000000000000000000bbf11c2f66e1887681c902095cefb1018c854c0f00000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000d3c21bcecceda1000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://041c0663dd6ae55964b5b294f5655e232f447a7283a15b0987ad0ea5ca05a759"}]}