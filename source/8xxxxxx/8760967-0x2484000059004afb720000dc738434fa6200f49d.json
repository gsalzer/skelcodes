{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaKeyRingFactoryV2Interface {\r\n  // Fires an event when a new key ring is deployed and initialized.\r\n  event KeyRingDeployed(address keyRing, address userSigningKey);\r\n\r\n  function newKeyRing(\r\n    address userSigningKey, address targetKeyRing\r\n  ) external returns (address keyRing);\r\n\r\n  function newKeyRingAndAdditionalKey(\r\n    address userSigningKey,\r\n    address targetKeyRing,\r\n    address additionalSigningKey,\r\n    bytes calldata signature\r\n  ) external returns (address keyRing);\r\n\r\n  function newKeyRingAndDaiWithdrawal(\r\n    address userSigningKey,\r\n    address targetKeyRing,\r\n    address smartWallet,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (address keyRing, bool withdrawalSuccess);\r\n\r\n  function newKeyRingAndUSDCWithdrawal(\r\n    address userSigningKey,\r\n    address targetKeyRing,\r\n    address smartWallet,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (address keyRing, bool withdrawalSuccess);\r\n\r\n  function getNextKeyRing(\r\n    address userSigningKey\r\n  ) external view returns (address targetKeyRing);\r\n\r\n  function getFirstKeyRingAdminActionID(\r\n    address keyRing, address additionalUserSigningKey\r\n  ) external view returns (bytes32 adminActionID);\r\n}\r\n\r\n\r\ninterface DharmaKeyRingImplementationV0Interface {\r\n  enum AdminActionType {\r\n    AddStandardKey,\r\n    RemoveStandardKey,\r\n    SetStandardThreshold,\r\n    AddAdminKey,\r\n    RemoveAdminKey,\r\n    SetAdminThreshold,\r\n    AddDualKey,\r\n    RemoveDualKey,\r\n    SetDualThreshold\r\n  }\r\n\r\n  function takeAdminAction(\r\n    AdminActionType adminActionType, uint160 argument, bytes calldata signatures\r\n  ) external;\r\n\r\n  function getVersion() external view returns (uint256 version);\r\n}\r\n\r\n\r\ninterface DharmaSmartWalletImplementationV0Interface {\r\n  function withdrawDai(\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok);\r\n\r\n  function withdrawUSDC(\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (bool ok);\r\n}\r\n\r\n\r\ninterface DharmaKeyRingInitializer {\r\n  function initialize(\r\n    uint128 adminThreshold,\r\n    uint128 executorThreshold,\r\n    address[] calldata keys,\r\n    uint8[] calldata keyTypes\r\n  ) external;\r\n}\r\n\r\n\r\n/**\r\n * @title KeyRingUpgradeBeaconProxyV1\r\n * @author 0age\r\n * @notice This contract delegates all logic, including initialization, to a key\r\n * ring implementation contract specified by a hard-coded \"upgrade beacon\". Note\r\n * that this implementation can be reduced in size by stripping out the metadata\r\n * hash, or even more significantly by using a minimal upgrade beacon proxy\r\n * implemented using raw EVM opcodes.\r\n */\r\ncontract KeyRingUpgradeBeaconProxyV1 {\r\n  // Set upgrade beacon address as a constant (i.e. not in contract storage).\r\n  address private constant _KEY_RING_UPGRADE_BEACON = address(\r\n    0x0000000000BDA2152794ac8c76B2dc86cbA57cad\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, perform initialization via delegatecall to the\r\n   * implementation set on the key ring upgrade beacon, supplying initialization\r\n   * calldata as a constructor argument. The deployment will revert and pass\r\n   * along the revert reason if the initialization delegatecall reverts.\r\n   * @param initializationCalldata Calldata to supply when performing the\r\n   * initialization delegatecall.\r\n   */\r\n  constructor(bytes memory initializationCalldata) public payable {\r\n    // Delegatecall into the implementation, supplying initialization calldata.\r\n    (bool ok, ) = _implementation().delegatecall(initializationCalldata);\r\n    \r\n    // Revert and include revert data if delegatecall to implementation reverts.\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice In the fallback, delegate execution to the implementation set on\r\n   * the key ring upgrade beacon.\r\n   */\r\n  function () external payable {\r\n    // Delegate execution to implementation contract provided by upgrade beacon.\r\n    _delegate(_implementation());\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to get the current implementation from the\r\n   * key ring upgrade beacon. This is accomplished via a staticcall to the key\r\n   * ring upgrade beacon with no data, and the beacon will return an abi-encoded\r\n   * implementation address.\r\n   * @return implementation Address of the implementation.\r\n   */\r\n  function _implementation() private view returns (address implementation) {\r\n    // Get the current implementation address from the upgrade beacon.\r\n    (bool ok, bytes memory returnData) = _KEY_RING_UPGRADE_BEACON.staticcall(\"\");\r\n    \r\n    // Revert and pass along revert message if call to upgrade beacon reverts.\r\n    require(ok, string(returnData));\r\n\r\n    // Set the implementation to the address returned from the upgrade beacon.\r\n    implementation = abi.decode(returnData, (address));\r\n  }\r\n\r\n  /**\r\n   * @notice Private function that delegates execution to an implementation\r\n   * contract. This is a low level function that doesn't return to its internal\r\n   * call site. It will return whatever is returned by the implementation to the\r\n   * external caller, reverting and returning the revert data if implementation\r\n   * reverts.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) private {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize)\r\n\r\n      // Delegatecall to the implementation, supplying calldata and gas.\r\n      // Out and outsize are set to zero - instead, use the return buffer.\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n      // Copy the returned data from the return buffer.\r\n      returndatacopy(0, 0, returndatasize)\r\n\r\n      switch result\r\n      // Delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaKeyRingFactoryV2\r\n * @author 0age\r\n * @notice This contract deploys new Dharma Key Ring instances as \"Upgrade\r\n * Beacon\" proxies that reference a shared implementation contract specified by\r\n * the Dharma Key Ring Upgrade Beacon contract. It also supplies methods for\r\n * performing additional operations post-deployment, including setting a second\r\n * signing key on the keyring and making a withdrawal from the associated smart\r\n * wallet. Note that the batch operations may fail, or be applied to the wrong\r\n * keyring, if another caller frontruns them by deploying a keyring to the\r\n * intended address first. If this becomes an issue, a future version of this\r\n * factory can remedy this by passing the target deployment address as an\r\n * additional argument and checking for existence of a contract at that address.\r\n * This factory builds on V1 by additionally including a helper function for\r\n * deriving adminActionIDs for keyrings that have not yet been deployed in order\r\n * to support creation of the signature parameter provided as part of calls to\r\n * `newKeyRingAndAdditionalKey`.\r\n */\r\ncontract DharmaKeyRingFactoryV2 is DharmaKeyRingFactoryV2Interface {\r\n  // Use DharmaKeyRing initialize selector to construct initialization calldata.\r\n  bytes4 private constant _INITIALIZE_SELECTOR = bytes4(0x30fc201f);\r\n\r\n  // The keyring upgrade beacon is used in order to get the current version.\r\n  address private constant _KEY_RING_UPGRADE_BEACON = address(\r\n    0x0000000000BDA2152794ac8c76B2dc86cbA57cad\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, ensure that the initialize selector constant is\r\n   * correct.\r\n   */\r\n  constructor() public {\r\n    DharmaKeyRingInitializer initializer;\r\n    require(\r\n      initializer.initialize.selector == _INITIALIZE_SELECTOR,\r\n      \"Incorrect initializer selector supplied.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new key ring contract using the provided user signing key.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @param targetKeyRing address The expected counterfactual address of the new\r\n   * keyring - if a contract is already deployed to this address, the deployment\r\n   * step will be skipped (supply the null address for this argument to force a\r\n   * deployment of a new key ring).\r\n   * @return The address of the new key ring.\r\n   */\r\n  function newKeyRing(\r\n    address userSigningKey, address targetKeyRing\r\n  ) external returns (address keyRing) {\r\n    // Deploy and initialize a keyring if needed and emit a corresponding event.\r\n    keyRing = _deployNewKeyRingIfNeeded(userSigningKey, targetKeyRing);\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new key ring contract using the provided user signing key\r\n   * and immediately add a second signing key to the key ring.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @param targetKeyRing address The expected counterfactual address of the new\r\n   * keyring - if a contract is already deployed to this address, the deployment\r\n   * step will be skipped and the supplied address will be used for all\r\n   * subsequent steps.\r\n   * @param additionalSigningKey address The second user signing key, supplied\r\n   * as an argument to `takeAdminAction` on the newly-deployed keyring.\r\n   * @param signature bytes A signature approving the addition of the second key\r\n   * that has been signed by the first key.\r\n   * @return The address of the new key ring.\r\n   */\r\n  function newKeyRingAndAdditionalKey(\r\n    address userSigningKey,\r\n    address targetKeyRing,\r\n    address additionalSigningKey,\r\n    bytes calldata signature\r\n  ) external returns (address keyRing) {\r\n    // Deploy and initialize a keyring if needed and emit a corresponding event.\r\n    keyRing = _deployNewKeyRingIfNeeded(userSigningKey, targetKeyRing);\r\n\r\n    // Set the additional key on the newly-deployed keyring.\r\n    DharmaKeyRingImplementationV0Interface(keyRing).takeAdminAction(\r\n      DharmaKeyRingImplementationV0Interface.AdminActionType.AddDualKey,\r\n      uint160(additionalSigningKey),\r\n      signature\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new key ring contract using the provided user signing key\r\n   * and immediately make a Dai withdrawal from the supplied smart wallet.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @param targetKeyRing address The expected counterfactual address of the new\r\n   * keyring - if a contract is already deployed to this address, the deployment\r\n   * step will be skipped and the supplied address will be used for all\r\n   * subsequent steps.\r\n   * @param smartWallet address The smart wallet to make the withdrawal from and\r\n   * that has the keyring to be deployed set as its user singing address.\r\n   * @param amount uint256 The amount of Dai to withdraw.\r\n   * @param recipient address The account to transfer the withdrawn Dai to.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to the call to the smart wallet - be aware that additional gas\r\n   * must still be included to account for the cost of overhead incurred up\r\n   * until the start of the function call.\r\n   * @param userSignature bytes A signature that resolves to userSigningKey set\r\n   * on the keyring and resolved using ERC1271. A unique hash returned from\r\n   * `getCustomActionID` on the smart wallet is prefixed and hashed to create\r\n   * the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for the smart wallet from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` on the smart wallet is prefixed and\r\n   * hashed to create the signed message.\r\n   * @return The address of the new key ring and the success status of the\r\n   * withdrawal.\r\n   */\r\n  function newKeyRingAndDaiWithdrawal(\r\n    address userSigningKey,\r\n    address targetKeyRing,\r\n    address smartWallet,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (address keyRing, bool withdrawalSuccess) {\r\n    // Deploy and initialize a keyring if needed and emit a corresponding event.\r\n    keyRing = _deployNewKeyRingIfNeeded(userSigningKey, targetKeyRing);\r\n\r\n    // Attempt to withdraw Dai from the provided smart wallet.\r\n    withdrawalSuccess = DharmaSmartWalletImplementationV0Interface(\r\n      smartWallet\r\n    ).withdrawDai(\r\n      amount, recipient, minimumActionGas, userSignature, dharmaSignature\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new key ring contract using the provided user signing key\r\n   * and immediately make a USDC withdrawal from the supplied smart wallet.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @param targetKeyRing address The expected counterfactual address of the new\r\n   * keyring - if a contract is already deployed to this address, the deployment\r\n   * step will be skipped and the supplied address will be used for all\r\n   * subsequent steps.\r\n   * @param smartWallet address The smart wallet to make the withdrawal from and\r\n   * that has the keyring to be deployed set as its user singing address.\r\n   * @param amount uint256 The amount of USDC to withdraw.\r\n   * @param recipient address The account to transfer the withdrawn USDC to.\r\n   * @param minimumActionGas uint256 The minimum amount of gas that must be\r\n   * provided to the call to the smart wallet - be aware that additional gas\r\n   * must still be included to account for the cost of overhead incurred up\r\n   * until the start of the function call.\r\n   * @param userSignature bytes A signature that resolves to userSigningKey set\r\n   * on the keyring and resolved using ERC1271. A unique hash returned from\r\n   * `getCustomActionID` on the smart wallet is prefixed and hashed to create\r\n   * the message hash for the signature.\r\n   * @param dharmaSignature bytes A signature that resolves to the public key\r\n   * returned for the smart wallet from the Dharma Key Registry. A unique hash\r\n   * returned from `getCustomActionID` on the smart wallet is prefixed and\r\n   * hashed to create the signed message.\r\n   * @return The address of the new key ring and the success status of the\r\n   * withdrawal.\r\n   */\r\n  function newKeyRingAndUSDCWithdrawal(\r\n    address userSigningKey,\r\n    address targetKeyRing,\r\n    address smartWallet,\r\n    uint256 amount,\r\n    address recipient,\r\n    uint256 minimumActionGas,\r\n    bytes calldata userSignature,\r\n    bytes calldata dharmaSignature\r\n  ) external returns (address keyRing, bool withdrawalSuccess) {\r\n    // Deploy and initialize a keyring if needed and emit a corresponding event.\r\n    keyRing = _deployNewKeyRingIfNeeded(userSigningKey, targetKeyRing);\r\n\r\n    // Attempt to withdraw USDC from the provided smart wallet.\r\n    withdrawalSuccess = DharmaSmartWalletImplementationV0Interface(\r\n      smartWallet\r\n    ).withdrawUSDC(\r\n      amount, recipient, minimumActionGas, userSignature, dharmaSignature\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to find the address of the next key ring address that\r\n   * will be deployed for a given user signing key. Note that a new value will\r\n   * be returned if a particular user signing key has been used before.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument.\r\n   * @return The future address of the next key ring.\r\n   */\r\n  function getNextKeyRing(\r\n    address userSigningKey\r\n  ) external view returns (address targetKeyRing) {\r\n    // Ensure that a user signing key has been provided.\r\n    require(userSigningKey != address(0), \"No user signing key supplied.\");\r\n\r\n    // Get initialization calldata using the initial user signing key.\r\n    bytes memory initializationCalldata = _constructInitializationCalldata(\r\n      userSigningKey\r\n    );\r\n\r\n    // Determine target key ring address based on the user signing key.\r\n    targetKeyRing = _computeNextAddress(initializationCalldata);\r\n  }\r\n\r\n  /**\r\n   * @notice View function for deriving the adminActionID that must be signed in\r\n   * order to add a new key to a given key ring that has not yet been deployed\r\n   * based on given parameters.\r\n   * @param keyRing address The yet-to-be-deployed keyring address.\r\n   * @param additionalUserSigningKey address The additional user signing key to\r\n   * add.\r\n   * @return The adminActionID that will be prefixed, hashed, and signed.\r\n   */\r\n  function getFirstKeyRingAdminActionID(\r\n    address keyRing, address additionalUserSigningKey\r\n  ) external view returns (bytes32 adminActionID) {\r\n    adminActionID = keccak256(\r\n      abi.encodePacked(\r\n        keyRing, _getKeyRingVersion(), uint256(0), additionalUserSigningKey\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to deploy a new key ring contract if needed using\r\n   * the provided user signing key. The expected keyring address is supplied as\r\n   * an argument, and if a contract is already deployed to that address then the\r\n   * deployment will be skipped and the supplied address will be returned.\r\n   * @param userSigningKey address The user signing key, supplied as a\r\n   * constructor argument during deployment.\r\n   * @return The address of the new key ring, or of the supplied key ring if a\r\n   * contract already exists at the supplied address.\r\n   */\r\n  function _deployNewKeyRingIfNeeded(\r\n    address userSigningKey, address expectedKeyRing\r\n  ) internal returns (address keyRing) {\r\n    // Only deploy if a key ring doesn't already exist at the expected address.\r\n    uint256 size;\r\n    assembly { size := extcodesize(expectedKeyRing) }\r\n    if (size == 0) {\r\n      // Get initialization calldata using the initial user signing key.\r\n      bytes memory initializationCalldata = _constructInitializationCalldata(\r\n        userSigningKey\r\n      );\r\n\r\n      // Deploy and initialize new user key ring as an Upgrade Beacon proxy.\r\n      keyRing = _deployUpgradeBeaconProxyInstance(initializationCalldata);\r\n\r\n      // Emit an event to signal the creation of the new key ring contract.\r\n      emit KeyRingDeployed(keyRing, userSigningKey);\r\n    } else {\r\n      // Note: specifying an address that was not returned from `getNextKeyRing`\r\n      // will cause this assumption to fail. Furthermore, the key ring at the\r\n      // expected address may have been modified so that the supplied user\r\n      // signing key is no longer a valid key - therefore, treat this helper as\r\n      // a way to protect against race conditions, not as a primary mechanism\r\n      // for interacting with key ring contracts.\r\n      keyRing = expectedKeyRing;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to deploy an upgrade beacon proxy via `CREATE2`.\r\n   * @param initializationCalldata bytes The calldata that will be supplied to\r\n   * the `DELEGATECALL` from the deployed contract to the implementation set on\r\n   * the upgrade beacon during contract creation.\r\n   * @return The address of the newly-deployed upgrade beacon proxy.\r\n   */\r\n  function _deployUpgradeBeaconProxyInstance(\r\n    bytes memory initializationCalldata\r\n  ) private returns (address upgradeBeaconProxyInstance) {\r\n    // Place creation code and constructor args of new proxy instance in memory.\r\n    bytes memory initCode = abi.encodePacked(\r\n      type(KeyRingUpgradeBeaconProxyV1).creationCode,\r\n      abi.encode(initializationCalldata)\r\n    );\r\n\r\n    // Get salt to use during deployment using the supplied initialization code.\r\n    (uint256 salt, ) = _getSaltAndTarget(initCode);\r\n\r\n    // Deploy the new upgrade beacon proxy contract using `CREATE2`.\r\n    assembly {\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      upgradeBeaconProxyInstance := create2(  // call `CREATE2` w/ 4 arguments.\r\n        callvalue,                            // forward any supplied endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n\r\n      // Pass along failure message and revert if contract deployment fails.\r\n      if iszero(upgradeBeaconProxyInstance) {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n  }\r\n\r\n  function _constructInitializationCalldata(\r\n    address userSigningKey\r\n  ) private pure returns (bytes memory initializationCalldata) {\r\n    address[] memory keys = new address[](1);\r\n    keys[0] = userSigningKey;\r\n\r\n    uint8[] memory keyTypes = new uint8[](1);\r\n    keyTypes[0] = uint8(3); // Dual key type\r\n\r\n    // Get initialization calldata from initialize selector & arguments.\r\n    initializationCalldata = abi.encodeWithSelector(\r\n      _INITIALIZE_SELECTOR, 1, 1, keys, keyTypes\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function for finding the address of the next upgrade\r\n   * beacon proxy that will be deployed, given a particular initialization\r\n   * calldata payload.\r\n   * @param initializationCalldata bytes The calldata that will be supplied to\r\n   * the `DELEGATECALL` from the deployed contract to the implementation set on\r\n   * the upgrade beacon during contract creation.\r\n   * @return The address of the next upgrade beacon proxy contract with the\r\n   * given initialization calldata.\r\n   */\r\n  function _computeNextAddress(\r\n    bytes memory initializationCalldata\r\n  ) private view returns (address target) {\r\n    // Place creation code and constructor args of the proxy instance in memory.\r\n    bytes memory initCode = abi.encodePacked(\r\n      type(KeyRingUpgradeBeaconProxyV1).creationCode,\r\n      abi.encode(initializationCalldata)\r\n    );\r\n\r\n    // Get target address using the constructed initialization code.\r\n    (, target) = _getSaltAndTarget(initCode);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for determining the salt and the target deployment\r\n   * address for the next deployed contract (using `CREATE2`) based on the\r\n   * contract creation code.\r\n   */\r\n  function _getSaltAndTarget(\r\n    bytes memory initCode\r\n  ) private view returns (uint256 nonce, address target) {\r\n    // Get the keccak256 hash of the init code for address derivation.\r\n    bytes32 initCodeHash = keccak256(initCode);\r\n\r\n    // Set the initial nonce to be provided when constructing the salt.\r\n    nonce = 0;\r\n\r\n    // Declare variable for code size of derived address.\r\n    uint256 codeSize;\r\n\r\n    // Loop until an contract deployment address with no code has been found.\r\n    while (true) {\r\n      target = address(            // derive the target deployment address.\r\n        uint160(                   // downcast to match the address type.\r\n          uint256(                 // cast to uint to truncate upper digits.\r\n            keccak256(             // compute CREATE2 hash using 4 inputs.\r\n              abi.encodePacked(    // pack all inputs to the hash together.\r\n                bytes1(0xff),      // pass in the control character.\r\n                address(this),     // pass in the address of this contract.\r\n                nonce,              // pass in the salt from above.\r\n                initCodeHash       // pass in hash of contract creation code.\r\n              )\r\n            )\r\n          )\r\n        )\r\n      );\r\n\r\n      // Determine if a contract is already deployed to the target address.\r\n      assembly { codeSize := extcodesize(target) }\r\n\r\n      // Exit the loop if no contract is deployed to the target address.\r\n      if (codeSize == 0) {\r\n        break;\r\n      }\r\n\r\n      // Otherwise, increment the nonce and derive a new salt.\r\n      nonce++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for getting the version of the current key ring\r\n   * implementation by using the upgrade beacon to determine the implementation\r\n   * and then calling into the returned implementation contract directly.\r\n   */\r\n  function _getKeyRingVersion() private view returns (uint256 version) {\r\n    // Perform the staticcall into the key ring upgrade beacon.\r\n    (bool ok, bytes memory data) = _KEY_RING_UPGRADE_BEACON.staticcall(\"\");\r\n\r\n    // Revert if underlying staticcall reverts, passing along revert message.\r\n    require(ok, string(data));\r\n\r\n    // Ensure that the data returned from the beacon is the correct length.\r\n    require(data.length == 32, \"Return data must be exactly 32 bytes.\");\r\n\r\n    // Decode the implementation address from the returned data.\r\n    address implementation = abi.decode(data, (address));\r\n\r\n    // Call into the implementation address directly to get the version.\r\n    version = DharmaKeyRingImplementationV0Interface(\r\n      implementation\r\n    ).getVersion();\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetKeyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"newKeyRingAndUSDCWithdrawal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"keyRing\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawalSuccess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"keyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"additionalUserSigningKey\",\"type\":\"address\"}],\"name\":\"getFirstKeyRingAdminActionID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"adminActionID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetKeyRing\",\"type\":\"address\"}],\"name\":\"newKeyRing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"keyRing\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetKeyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumActionGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"dharmaSignature\",\"type\":\"bytes\"}],\"name\":\"newKeyRingAndDaiWithdrawal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"keyRing\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawalSuccess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"getNextKeyRing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"targetKeyRing\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetKeyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"additionalSigningKey\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"newKeyRingAndAdditionalKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"keyRing\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keyRing\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userSigningKey\",\"type\":\"address\"}],\"name\":\"KeyRingDeployed\",\"type\":\"event\"}]","ContractName":"DharmaKeyRingFactoryV2","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://2020202020446861726d614b657952696e67466163746f727956322020202020"}]}