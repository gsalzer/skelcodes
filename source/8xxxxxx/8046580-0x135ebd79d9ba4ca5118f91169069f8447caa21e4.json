{"status":"1","message":"OK","result":[{"SourceCode":"{\"Moldex721New.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\\n\\ncontract ERC721  {\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\\n\\ncontract Moldex721New {\\n    using SafeMath for uint256;\\n\\n    //コントラクトowner\\n    address public owner;\\n    // feeを受け取るaccount\\n    address public feeAccount;\\n    // contract admins\\n    mapping (address =\\u003e bool) admins;\\n    // trade済みのorderを記録\\n    mapping (bytes32 =\\u003e bool) public traded;\\n    // is initialize proxy\\n    bool internal _initialized;\\n    // Events\\n\\t\\tevent Trade(address indexed ownerAddress, address indexed receiverAddress, address indexed sellTokenAddress, uint256 tokenId, uint256 amount, uint256 fee, uint256 _now);\\n    // onlyOwner modifier\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _; \\n    }\\n\\n    // Admin Validation msg.sender should be owner or admin\\n    modifier onlyAdmin {\\n        if(msg.sender != owner \\u0026\\u0026 !admins[msg.sender]) revert();\\n        _;\\n    }\\n\\n    constructor\\n    (\\n        address _feeAccount\\n    ) \\n    public\\n    {\\n        owner = msg.sender;\\n        admins[msg.sender] = true;\\n        feeAccount = _feeAccount;\\n    }\\n\\n    function initialize(address _owner, address _feeAccount) public {\\n        require(!_initialized);\\n        owner = _owner;\\n        admins[_owner] = true;\\n        feeAccount = _feeAccount;\\n        _initialized = true;\\n   }\\n\\n\\n    function setOwner\\n    (\\n        address _owner\\n    )\\n    external onlyOwner\\n    {\\n        owner = _owner;\\n    }\\n\\n    function setAdmin\\n    (\\n        address admin,\\n        bool isAdmin\\n    )\\n    external onlyOwner\\n    {\\n        admins[admin] = isAdmin;\\n    }\\n\\n    function trade\\n    (\\n        uint256[2] tradeValues,\\n        address[4] tradeAddresses,\\n        uint8[2] v,\\n        bytes32[4] rs\\n    )\\n    external onlyAdmin\\n    returns (bool)\\n    {\\n        /* \\n        params\\n            tradeValues[0] erc721 token id\\n            tradeValues[1] mold amount\\n        */\\n        /* \\n            tradeAddresses[0] erc721 token address\\n            tradeAddresses[1] mold token address\\n            tradeAddresses[2] erc721 token owner address\\n            tradeAddresses[3] erc721 receiver address / mold token owner\\n        */\\n        /*\\n            rs[0] erc721 token owner recovery r\\n            rs[1] erc721 token owner recovery s\\n            rs[2] dex admin recovery r\\n            rs[3] dex admin recovery s\\n        */\\n        /*\\n            v[0] erc721 token owner recovery v\\n            v[1] dex admin recovery v\\n         */\\n         bytes32 orderHash = keccak256(abi.encodePacked(\\n             address(this), // dex address\\n             tradeAddresses[0], // 721 token address\\n             tradeAddresses[2], // 721 token owner address\\n             tradeValues[0], // token Id\\n             tradeAddresses[1], //  moldToken Address\\n             tradeValues[1] // mold amount\\n         ));\\n\\n        bytes32 tradeHash = keccak256(abi.encodePacked(\\n            orderHash,\\n            tradeAddresses[3] // 721 token receiver address\\n        ));\\n         // check maker signature is valid\\n        require(ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", orderHash)), v[0], rs[0], rs[1]) == tradeAddresses[2]);\\n        require(ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", tradeHash)), v[1], rs[2], rs[3]) == tradeAddresses[3]);\\n        // transfer mold\\n        uint256 tradeAmount = tradeValues[1] * 95 / 100;\\n        uint256 feeAmount = tradeValues[1] * 5 / 100;\\n        if (!ERC20(tradeAddresses[1]).transferFrom(tradeAddresses[3], tradeAddresses[2], tradeAmount)) revert();\\n        if (!ERC20(tradeAddresses[1]).transferFrom(tradeAddresses[3], feeAccount,feeAmount)) revert();\\n        // transfer 721 token\\n        ERC721(tradeAddresses[0]).transferFrom(tradeAddresses[2], tradeAddresses[3], tradeValues[0]);\\n        emit Trade(tradeAddresses[2], tradeAddresses[3] , tradeAddresses[0], tradeValues[0], tradeAmount, feeAmount, now);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeValues\",\"type\":\"uint256[2]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[4]\"},{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"traded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiverAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"}]","ContractName":"Moldex721New","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003f50f35e6d3a1de2f8d7ebbce56e7da8ae4ccf31","Library":"","SwarmSource":"bzzr://d84d8d5e553eda092c4f8bc8e82a869279d8723ddd65a2993d94157b2eec20da"}]}