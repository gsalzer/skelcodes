{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface PrimaryStorage {\r\n\t\tfunction getInsuranceOwner(uint256 insId) external view returns (address);\r\n\t\tfunction getPoolContribution(uint256 insId) external view returns (uint256);\r\n\t\tfunction getTimeOfTheRequest(uint256 insId) external view returns (uint256);\r\n\t\tfunction getAmountAvailableForWithdraw(address userAddr, uint256 pid) external view returns (uint256);\r\n\t\tfunction getIsRefunded(uint256 insId) external view returns (bool);\r\n\t\tfunction getVotedForARefund(uint256 insId) external view returns (bool);\r\n\t\tfunction getVotedAfterFailedVoting(uint256 insId) external view returns (bool);\r\n\t\tfunction getEtherSecured(uint256 insId) external view returns (uint256);\r\n\t\tfunction setEtherSecured(uint256 insId, uint256 amount) external;\r\n\t\tfunction setIsRefunded(uint256 insId) external;\r\n\t\tfunction setAmountAvailableForWithdraw(address userAddr, uint256 pid, uint256 amount) external;\r\n\t\tfunction setVotedForARefund(uint256 insId) external;\r\n\t\tfunction setVotedAfterFailedVoting(uint256 insId) external;\r\n\t\tfunction setPoolContribution(uint256 insId, uint256 amount) external;\r\n\t\tfunction cancelInsurance(uint256 insId) external;\r\n\t\tfunction isCanceled(uint256 insId) external view returns (bool);\r\n\t\tfunction isInvestor(address who) external view returns (bool);\r\n\t\tfunction getUtilityController() external view returns (address);\r\n\t\tfunction getDisputesOfProject(uint256 pid) external view returns (uint256[] memory disputeIds);\r\n\t\tfunction getNumberOfVotesForRefundState(uint256 disputeId) external view returns (uint256);\r\n\t\tfunction getNumberOfVotesAgainstRefundState(uint256 disputeId) external view  returns (uint256);\r\n}\r\n\r\n\r\ninterface ProjectTokenInterface {\r\n    function balanceOf(address who) external returns (uint256);\r\n}\r\n\r\n\r\ninterface SecondaryStorage {\r\n\t\tfunction getPolicyEndDate(uint256 pid) external view returns (uint256);\r\n\t\tfunction getPolicyBase(uint256 pid) external view returns (uint256);\r\n\t\tfunction getCrowdsaleEndTime(uint256 pid) external view returns (uint256);\r\n\t\tfunction getProjectCurrentState(uint256 pid) external view returns (uint8);\r\n\t\tfunction setProjectCurrentState(uint256 pid, uint8 currentState) external;\r\n\t\tfunction getIsInvestorsVoteFailed(uint256 pid) external view returns (bool);\r\n\t\tfunction getVoteEnd(uint256 pid) external view returns (uint256);\r\n\t\tfunction setVoteEnd(uint256 pid, uint256 numberOfBlock) external;\r\n\t\tfunction getFreezeStatePeriod(uint256 pid) external view returns (uint256);\r\n\t\tfunction getTokenLitter(uint256 pid, uint256 ins) external view returns (address);\r\n\t\tfunction getProjectTokenContract(uint256 pid) external view returns (ProjectTokenInterface);\r\n\t\tfunction getMinAmountProjectTokens(uint256 pid, address investor) external view returns (uint256);\r\n\t\tfunction getVotesForRefundState(uint256 pid) external view returns (uint256);\r\n\t\tfunction getNumberOfProjectInvestments(uint256 pid) external view returns (uint256);\r\n\t\tfunction getReturnedRefundTokens(uint256 pid) external view returns (uint256);\r\n\t\tfunction getIsRefundInProgress(uint256 pid) external view returns (bool);\r\n\t\tfunction getRefundStatePeriod(uint256 pid) external view returns (uint256);\r\n\t\tfunction setIsRefundInProgress(uint256 pid, bool status) external;\r\n\t\tfunction getTotalAmountSecuredEther(uint256 pid) external view returns (uint256);\r\n\t\tfunction setVotesForRefundState(uint256 pid, uint256 numberOfVotes) external;\r\n\t\tfunction setRefundStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n\t\tfunction setFreezeStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n\t\tfunction setAmountOfFundsContributed(uint256 pid, uint256 amount) external;\r\n\t\tfunction getAmountOfFundsContributed(uint256 pid) external view returns (uint256);\r\n\t\tfunction setTotalAmountSecuredEther(uint256 pid, uint256 amount) external;\r\n\t\tfunction removeInsuranceIdFromProject(uint256 pid, uint256 insuranceId, uint256 insIdx) external;\r\n\t\tfunction removeInvestorAddressFromProject(uint256 pid, address investorAddress, uint256 insOwnerIdx) external;\r\n\t\tfunction setReturnedRefundTokens(uint256 pid, uint256 amount) external;\r\n\t\tfunction getIsDisputed(uint256 pid) external view returns (bool);\r\n\t\tfunction setIsInvestorsVoteFailed(uint256 pid, bool failedOrNot) external;\r\n\t\tfunction getUtilityControllerOfProject(uint256 pid) external view returns (address payable);\r\n\t\tfunction getEligibleForInternalVote(uint256 pid) external view returns (uint256 eligibleInvestors, uint256 validSecuredEther);\r\n\t\tfunction isRefundStateForced(uint256 pid) external view returns (uint8);\r\n\t\tfunction setForcedRefundState(uint256 pid, uint8 value) external;\r\n}\r\n\r\ninterface RefundEtherInterface {\r\n    function getAmountOfSecuredEther(address investor, uint256 projectId) external view returns (uint256);\r\n    function setAmountOfSecuredEther(address investor, uint256 projectId, uint256 amount) external returns (bool success);\r\n    function burn(address _tokensOwner, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface Logger {\r\n    function emitInsuranceCanceled(address owner, uint256 insuranceId) external;\r\n    function emitRefundStateRequested(address investor, uint256 insuranceId, uint256 projectId) external;\r\n    function emitInternalVoteFailed(uint256 projectId) external;\r\n    function emitRefundInProgress(uint256 projectId) external;\r\n    function emitRefundWithdraw(address investor, uint256 projectId, uint256 insuranceId, uint256 amount) external;\r\n    function emitRefundStateForced(address moderator, uint256 projectId) external;\r\n    function emitRefundStateEnded(uint256 projdectId) external;\r\n}\r\n\r\ncontract RefundController {\r\n    using SafeMath for uint256;\r\n\r\n    PrimaryStorage       masterStorage;\r\n    SecondaryStorage     secondStorage;\r\n    RefundEtherInterface refundEther;\r\n    Logger               eventLogger;\r\n\r\n    address payable private main;\r\n\r\n    constructor(\r\n        address payable dAppMainContractAddr,\r\n        address storageAddr,\r\n        address secStorageAddr,\r\n        address refundEtherAddr,\r\n        address eventLoggerAddr\r\n    )\r\n        public\r\n    {\r\n        masterStorage = PrimaryStorage(storageAddr);\r\n        secondStorage = SecondaryStorage(secStorageAddr);\r\n        refundEther = RefundEtherInterface(refundEtherAddr);\r\n        eventLogger = Logger(eventLoggerAddr);\r\n        main = dAppMainContractAddr;\r\n    }\r\n\r\n    modifier onlyMain {\r\n        if(msg.sender == main) {\r\n            _;\r\n        }\r\n        else {\r\n            revert(\"Only main contract is allowed\");\r\n        }\r\n    }\r\n\r\n    modifier onlyInsuranceOwner(address owner, uint256 ins) {\r\n        if (owner == masterStorage.getInsuranceOwner(ins)) {\r\n            _;\r\n        } else {\r\n            revert(\"Only the address owning the insurance is allowed\");\r\n        }\r\n    }\r\n\r\n    modifier notCanceled(uint256 ins) {\r\n        if (!masterStorage.isCanceled(ins)) {\r\n            _;\r\n        } else {\r\n            revert(\"Insurance is canceled\");\r\n        }\r\n    }\r\n\r\n    function cancel(uint256 ins, uint256 pid, address insOwner)\r\n        external\r\n        onlyMain\r\n        onlyInsuranceOwner(insOwner, ins)\r\n        notCanceled(ins)\r\n        returns (bool)\r\n    {\r\n        uint8 currentProjectState = secondStorage.getProjectCurrentState(pid);\r\n\r\n        require(\r\n            currentProjectState == 0 || currentProjectState == 1,\r\n            \"Project is not in a state allowing insurance cancelation\"\r\n        );\r\n        require(\r\n            block.number > masterStorage.getTimeOfTheRequest(ins).add(185142) &&\r\n            block.number < masterStorage.getTimeOfTheRequest(ins).add(555426),\r\n            \"Canceling is only allowed for 3 months after insurance was made\"\r\n        );\r\n        require(!_isRefundInProgress(pid), \"In process of refunding\");\r\n        if (block.number > secondStorage.getPolicyEndDate(pid)) {\r\n            secondStorage.setProjectCurrentState(pid, 6);\r\n            return false;\r\n        }\r\n        _cancelInvestmentProtection(ins, pid, insOwner);\r\n        uint256 poolContrib = masterStorage.getPoolContribution(ins);\r\n        secondStorage.setAmountOfFundsContributed(\r\n            pid,\r\n            secondStorage.getAmountOfFundsContributed(pid).sub(poolContrib)\r\n        );\r\n        secondStorage.removeInsuranceIdFromProject(pid, ins, 0);\r\n        secondStorage.removeInvestorAddressFromProject(pid, insOwner, 0);\r\n        masterStorage.setPoolContribution(ins, 0);\r\n\r\n        require(poolContrib > 0, \"No secured funds\");\r\n        masterStorage.setAmountAvailableForWithdraw(\r\n            insOwner,\r\n            pid,\r\n            poolContrib\r\n        );\r\n        poolContrib = 0;\r\n        return true;\r\n    }\r\n\r\n    function voteForRefundState(address owner, uint256 ins, uint256 pid)\r\n        external\r\n        onlyMain\r\n        onlyInsuranceOwner(owner, ins)\r\n        notCanceled(ins)\r\n        returns (bool)\r\n    {\r\n        uint8 cps = secondStorage.getProjectCurrentState(pid);\r\n        if (block.number > secondStorage.getCrowdsaleEndTime(pid).add(93558) && cps == 0) {\r\n            secondStorage.setProjectCurrentState(pid, 1);\r\n            cps = 1;\r\n        }\r\n        require(cps == 1 || cps == 2, \"Vote not allowed in the current project state\");\r\n        if (block.number > secondStorage.getPolicyEndDate(pid)) {\r\n            secondStorage.setProjectCurrentState(pid, 6);\r\n            return false;\r\n        }\r\n        require(\r\n            block.number > secondStorage.getCrowdsaleEndTime(pid).add(555426) &&\r\n            !masterStorage.getIsRefunded(ins),\r\n            \"Cancelation period for this project is not expired or it has been already refunded\"\r\n        );\r\n        if (secondStorage.getIsInvestorsVoteFailed(pid) && masterStorage.getVotedForARefund(ins)) {\r\n            _cancelInvestmentProtection(ins, pid, owner);\r\n            return false;\r\n        }\r\n        require(\r\n            block.number > secondStorage.getFreezeStatePeriod(pid) &&\r\n            !masterStorage.getVotedForARefund(ins) &&\r\n            !_isRefundInProgress(pid),\r\n            \"Not eligible for a refund state vote\"\r\n        );\r\n        if (!_checkReturnedTokens(pid, owner, secondStorage.getTokenLitter(pid, ins))) {\r\n            if (secondStorage.getProjectTokenContract(pid).balanceOf(owner) < secondStorage.getMinAmountProjectTokens(pid, owner)) {\r\n                _cancelInvestmentProtection(ins, pid, owner);\r\n                return false;\r\n            } else {\r\n                revert(\"You have to sent your project tokens to your token litter in order to request a refund state\");\r\n            }\r\n        }\r\n\r\n        if (cps != 2 && secondStorage.getVoteEnd(pid).add(185142) > block.number) {\r\n            revert(\"1 month is not passed since the previous minor internal vote\");\r\n        }\r\n        if (cps == 2 && block.number > secondStorage.getVoteEnd(pid)) {\r\n            return _processInternalVote(pid);\r\n        }\r\n        uint256 reth = refundEther.getAmountOfSecuredEther(owner, pid);\r\n        require(reth > 1, \"Not allowed. No RefundEther tokens.\");\r\n\r\n        refundEther.setAmountOfSecuredEther(owner, pid, 1);\r\n        refundEther.burn(owner, reth);\r\n        secondStorage.setReturnedRefundTokens(\r\n            pid,\r\n            secondStorage.getReturnedRefundTokens(pid).add(reth)\r\n        );\r\n        reth = 0;\r\n        secondStorage.setVotesForRefundState(\r\n            pid,\r\n            secondStorage.getVotesForRefundState(pid).add(1)\r\n        );\r\n\r\n        if (!secondStorage.getIsInvestorsVoteFailed(pid)) {\r\n            masterStorage.setVotedForARefund(ins);\r\n        } else {\r\n            masterStorage.setVotedAfterFailedVoting(ins);\r\n        }\r\n        uint256 vfr = secondStorage.getVotesForRefundState(pid).mul(100);\r\n        uint256 mpv = (secondStorage.getNumberOfProjectInvestments(pid).sub(1)).mul(15);\r\n        if (cps != 2 && vfr > mpv && secondStorage.getReturnedRefundTokens(pid) > 12 ether) {\r\n            secondStorage.setProjectCurrentState(pid, 2);\r\n            secondStorage.setVoteEnd(pid, block.number.add(555426));\r\n        }\r\n        eventLogger.emitRefundStateRequested(owner, ins, pid);\r\n        return true;\r\n    }\r\n\r\n    function withdraw(address owner, uint256 ins, uint256 pid)\r\n        external\r\n        onlyInsuranceOwner(owner, ins)\r\n        notCanceled(ins)\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        require(secondStorage.getProjectCurrentState(pid) == 1, \"Project is not in a refund state\");\r\n        require(!masterStorage.getIsRefunded(ins), \"Already refunded investment\");\r\n        require(block.number > secondStorage.getFreezeStatePeriod(pid), \"Freezetime, not available yet\");\r\n        require(secondStorage.getIsRefundInProgress(pid), \"Not in a refund State\");\r\n        if (secondStorage.getRefundStatePeriod(pid) < block.number) {\r\n            secondStorage.setProjectCurrentState(pid, 4);\r\n            secondStorage.setIsRefundInProgress(pid, false);\r\n            eventLogger.emitRefundStateEnded(pid);\r\n            return false;\r\n        }\r\n\r\n        bool isInternalVoteFailed = secondStorage.getIsInvestorsVoteFailed(pid);\r\n        if (isInternalVoteFailed && masterStorage.getVotedForARefund(ins)) {\r\n            _cancelInvestmentProtection(ins, pid, owner);\r\n            return false;\r\n        }\r\n\r\n        uint256 etherToRefund;\r\n\r\n        if (secondStorage.getPolicyBase(pid) < block.number) {\r\n            etherToRefund = masterStorage.getEtherSecured(ins).div(2);\r\n        } else {\r\n            etherToRefund = masterStorage.getEtherSecured(ins);\r\n        }\r\n        secondStorage.setTotalAmountSecuredEther(\r\n            pid,\r\n            secondStorage.getTotalAmountSecuredEther(pid).sub(etherToRefund)\r\n        );\r\n        masterStorage.setEtherSecured(ins, 0);\r\n        masterStorage.setIsRefunded(ins);\r\n        require(etherToRefund > 0, \"No funds available\");\r\n        masterStorage.setAmountAvailableForWithdraw(\r\n            owner,\r\n            pid,\r\n            etherToRefund\r\n        );\r\n\r\n        eventLogger.emitRefundWithdraw(owner, pid, ins, etherToRefund);\r\n        return true;\r\n    }\r\n\r\n    function forceRefundState(address moderator, uint256 pid)\r\n        external\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        uint8 currentProjectState = secondStorage.getProjectCurrentState(pid);\r\n        uint8 isRefundStateForced = secondStorage.isRefundStateForced(pid);\r\n        require (\r\n            currentProjectState != 3 || currentProjectState != 4 ||\r\n            currentProjectState != 5 || currentProjectState != 6, \"Not allowed\"\r\n        );\r\n        require(!_isRefundInProgress(pid) && isRefundStateForced == 0, \"In a refund state or was already forced to one previously.\");\r\n        secondStorage.setForcedRefundState(pid, 1);\r\n        eventLogger.emitRefundStateForced(moderator, pid);\r\n        return _setRefundState(pid);\r\n    }\r\n\r\n    function invalidateInsurance(uint256 ins, uint256 pid) external {\r\n        address utilityController = secondStorage.getUtilityControllerOfProject(pid);\r\n        require(msg.sender == utilityController, \"Not allowed\");\r\n\r\n        address insOwner = masterStorage.getInsuranceOwner(ins);\r\n        _cancelInvestmentProtection(ins, pid, insOwner);\r\n    }\r\n\r\n    function finalizeVote(uint256 pid) external {\r\n        address utilityController = secondStorage.getUtilityControllerOfProject(pid);\r\n        require(msg.sender == utilityController || msg.sender == main, \"Not allowed\");\r\n        _processInternalVote(pid);\r\n    }\r\n\r\n    function _processInternalVote(uint256 pid) internal returns (bool) {\r\n        (uint256 evi, uint256 ese) = secondStorage.getEligibleForInternalVote(pid);\r\n        bool forcedRefundState = (secondStorage.isRefundStateForced(pid) == 1);\r\n        if (forcedRefundState && _isRefundInProgress(pid)) {\r\n            secondStorage.setVoteEnd(pid, 1);\r\n            return true;\r\n        }\r\n\r\n        if (ese < 188 ether && evi <= 24) {\r\n            if (secondStorage.getReturnedRefundTokens(pid) >= ese.mul(90).div(100) &&\r\n               (secondStorage.getVotesForRefundState(pid) - 1).mul(100) >= evi.mul(900).div(10)) {\r\n                return _setRefundState(pid);\r\n            }\r\n        }\r\n        if (ese >= 188 ether && ese <= 812 ether && evi > 24 && evi <= 88) {\r\n            if (secondStorage.getReturnedRefundTokens(pid) >= ese.mul(85).div(100) &&\r\n               (secondStorage.getVotesForRefundState(pid) - 1).mul(100) >= evi.mul(850).div(10)) {\r\n                return _setRefundState(pid);\r\n            }\r\n        }\r\n        if (ese > 812 ether && evi > 88) {\r\n            if (secondStorage.getReturnedRefundTokens(pid) >= ese.mul(80).div(100) &&\r\n               (secondStorage.getVotesForRefundState(pid) - 1).mul(100) >= evi.mul(800).div(10)) {\r\n                return _setRefundState(pid);\r\n            }\r\n        } else {\r\n            if ((secondStorage.getVotesForRefundState(pid) - 1).mul(100) >= evi.mul(950).div(10)) {\r\n                return _setRefundState(pid);\r\n            }\r\n        }\r\n        _internalVoteFailed(pid, evi, ese);\r\n        return false;\r\n    }\r\n\r\n    function _setRefundState(uint256 pid) internal returns (bool) {\r\n        secondStorage.setRefundStatePeriod(pid, block.number.add(1110852));\r\n        secondStorage.setFreezeStatePeriod(pid, block.number.add(46779));\r\n        secondStorage.setIsRefundInProgress(pid, true);\r\n        secondStorage.setProjectCurrentState(pid, 1);\r\n\r\n        eventLogger.emitRefundInProgress(pid);\r\n        return true;\r\n    }\r\n\r\n    function _internalVoteFailed(\r\n        uint256 pid,\r\n        uint256 evi,\r\n        uint256 ese\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        secondStorage.setProjectCurrentState(pid, 1);\r\n        if (secondStorage.getIsInvestorsVoteFailed(pid) &&\r\n            secondStorage.getReturnedRefundTokens(pid) > ese.mul(51).div(100) &&\r\n            secondStorage.getVotesForRefundState(pid).mul(100) > evi.mul(51))\r\n        {\r\n            secondStorage.setProjectCurrentState(pid, 5);\r\n            eventLogger.emitInternalVoteFailed(pid);\r\n            return true;\r\n        }\r\n        if (!secondStorage.getIsInvestorsVoteFailed(pid) &&\r\n            secondStorage.getReturnedRefundTokens(pid) > ese.mul(51).div(100) &&\r\n            secondStorage.getVotesForRefundState(pid).mul(100) > evi.mul(51))\r\n        {\r\n            secondStorage.setFreezeStatePeriod(pid, block.number.add(46779));\r\n            secondStorage.setIsInvestorsVoteFailed(pid, true);\r\n\r\n            secondStorage.setVoteEnd(pid, 1);\r\n\r\n            secondStorage.setVotesForRefundState(pid, 1);\r\n            secondStorage.setReturnedRefundTokens(pid, 2);\r\n            eventLogger.emitInternalVoteFailed(pid);\r\n            return true;\r\n        } else {\r\n            secondStorage.setVotesForRefundState(pid, 1);\r\n            secondStorage.setReturnedRefundTokens(pid, 2);\r\n            secondStorage.setFreezeStatePeriod(pid, 1);\r\n            eventLogger.emitInternalVoteFailed(pid);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _checkReturnedTokens(uint256 pid, address owner, address litter)\r\n        internal\r\n        returns (bool tokensAreReturned)\r\n    {\r\n        uint256 returnedTokens = secondStorage.getProjectTokenContract(pid).balanceOf(litter);\r\n        tokensAreReturned = returnedTokens >= secondStorage.getMinAmountProjectTokens(pid, owner);\r\n        return tokensAreReturned;\r\n    }\r\n\r\n    function _cancelInvestmentProtection(uint256 ins, uint256 pid, address insOwner)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        masterStorage.cancelInsurance(ins);\r\n        uint256 ethSecured = masterStorage.getEtherSecured(ins);\r\n\r\n        if (secondStorage.getPolicyBase(pid) < block.number) {\r\n            ethSecured = masterStorage.getEtherSecured(ins).div(2);\r\n        } else {\r\n            ethSecured = masterStorage.getEtherSecured(ins);\r\n        }\r\n\r\n        masterStorage.setEtherSecured(ins, 0);\r\n        secondStorage.setTotalAmountSecuredEther(\r\n            pid,\r\n            secondStorage.getTotalAmountSecuredEther(pid).sub(ethSecured)\r\n        );\r\n\r\n        eventLogger.emitInsuranceCanceled(insOwner, ins);\r\n        return true;\r\n    }\r\n\r\n    function _isRefundInProgress(uint256 pid) internal view returns (bool) {\r\n        return secondStorage.getIsRefundInProgress(pid);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ins\",\"type\":\"uint256\"},{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"invalidateInsurance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"ins\",\"type\":\"uint256\"},{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"voteForRefundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"moderator\",\"type\":\"address\"},{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"forceRefundState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"ins\",\"type\":\"uint256\"},{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"finalizeVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ins\",\"type\":\"uint256\"},{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"insOwner\",\"type\":\"address\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dAppMainContractAddr\",\"type\":\"address\"},{\"name\":\"storageAddr\",\"type\":\"address\"},{\"name\":\"secStorageAddr\",\"type\":\"address\"},{\"name\":\"refundEtherAddr\",\"type\":\"address\"},{\"name\":\"eventLoggerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"RefundController","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"500000","ConstructorArguments":"0000000000000000000000004f62e6629e4f1cd8b72e7db8ff097f055a6ed4c000000000000000000000000057d504f3ebcc43b8a894a7933676eb17236cc35d000000000000000000000000ac5ae06a85b710c1c68708bb04b80f2d81c0061700000000000000000000000090d44256f40fb8ab49d80c88251ff5132edf885e000000000000000000000000358994ca3f907b689c4177790a2cb424a3d2bcdf","Library":"","SwarmSource":"bzzr://ecc867a6e4647a805c24b68d94bd1db0e7c3a6b3996f8c1e9fa89464bb770477"}]}