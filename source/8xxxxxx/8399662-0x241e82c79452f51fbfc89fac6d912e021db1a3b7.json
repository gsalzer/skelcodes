{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2019 The Hydro Protocol Foundation\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract GlobalStore {\r\n    Store.State state;\r\n}\r\n\r\ncontract ExternalFunctions is GlobalStore {\r\n\r\n    ////////////////////////////\r\n    // Batch Actions Function //\r\n    ////////////////////////////\r\n\r\n    function batch(\r\n        BatchActions.Action[] memory actions\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        BatchActions.batch(state, actions, msg.value);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Signature Function //\r\n    ////////////////////////\r\n\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        Types.Signature calldata signature\r\n    )\r\n        external\r\n        pure\r\n        returns (bool isValid)\r\n    {\r\n        isValid = Signature.isValidSignature(hash, signerAddress, signature);\r\n    }\r\n\r\n    ///////////////////////\r\n    // Markets Functions //\r\n    ///////////////////////\r\n\r\n    function getAllMarketsCount()\r\n        external\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        count = state.marketsCount;\r\n    }\r\n\r\n    function getAsset(address assetAddress)\r\n        external\r\n        view returns (Types.Asset memory asset)\r\n    {\r\n        Requires.requireAssetExist(state, assetAddress);\r\n        asset = state.assets[assetAddress];\r\n    }\r\n\r\n    function getAssetOraclePrice(address assetAddress)\r\n        external\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        Requires.requireAssetExist(state, assetAddress);\r\n        price = AssemblyCall.getAssetPriceFromPriceOracle(\r\n            address(state.assets[assetAddress].priceOracle),\r\n            assetAddress\r\n        );\r\n    }\r\n\r\n    function getMarket(uint16 marketID)\r\n        external\r\n        view\r\n        returns (Types.Market memory market)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        market = state.markets[marketID];\r\n    }\r\n\r\n    //////////////////////////////////\r\n    // Collateral Account Functions //\r\n    //////////////////////////////////\r\n\r\n    function isAccountLiquidatable(\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        external\r\n        view\r\n        returns (bool isLiquidatable)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        isLiquidatable = CollateralAccounts.getDetails(state, user, marketID).liquidatable;\r\n    }\r\n\r\n    function getAccountDetails(\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        external\r\n        view\r\n        returns (Types.CollateralAccountDetails memory details)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        details = CollateralAccounts.getDetails(state, user, marketID);\r\n    }\r\n\r\n    function getAuctionsCount()\r\n        external\r\n        view\r\n        returns (uint32 count)\r\n    {\r\n        count = state.auction.auctionsCount;\r\n    }\r\n\r\n    function getCurrentAuctions()\r\n        external\r\n        view\r\n        returns (uint32[] memory)\r\n    {\r\n        return state.auction.currentAuctions;\r\n    }\r\n\r\n    function getAuctionDetails(uint32 auctionID)\r\n        external\r\n        view\r\n        returns (Types.AuctionDetails memory details)\r\n    {\r\n        Requires.requireAuctionExist(state, auctionID);\r\n        details = Auctions.getAuctionDetails(state, auctionID);\r\n    }\r\n\r\n    function fillAuctionWithAmount(\r\n        uint32 auctionID,\r\n        uint256 amount\r\n    )\r\n        external\r\n    {\r\n        Requires.requireAuctionExist(state, auctionID);\r\n        Requires.requireAuctionNotFinished(state, auctionID);\r\n        Auctions.fillAuctionWithAmount(state, auctionID, amount);\r\n    }\r\n\r\n    function liquidateAccount(\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        external\r\n        returns (bool hasAuction, uint32 auctionID)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        (hasAuction, auctionID) = Auctions.liquidate(state, user, marketID);\r\n    }\r\n\r\n    ///////////////////////////\r\n    // LendingPool Functions //\r\n    ///////////////////////////\r\n\r\n    function getPoolCashableAmount(address asset)\r\n        external\r\n        view\r\n        returns (uint256 cashableAmount)\r\n    {\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            cashableAmount = address(this).balance - uint256(state.cash[asset]);\r\n        } else {\r\n            cashableAmount = IStandardToken(asset).balanceOf(address(this)) - uint256(state.cash[asset]);\r\n        }\r\n    }\r\n\r\n    function getIndex(address asset)\r\n        external\r\n        view\r\n        returns (uint256 supplyIndex, uint256 borrowIndex)\r\n    {\r\n        return LendingPool.getCurrentIndex(state, asset);\r\n    }\r\n\r\n    function getTotalBorrow(address asset)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Requires.requireAssetExist(state, asset);\r\n        amount = LendingPool.getTotalBorrow(state, asset);\r\n    }\r\n\r\n    function getTotalSupply(address asset)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Requires.requireAssetExist(state, asset);\r\n        amount = LendingPool.getTotalSupply(state, asset);\r\n    }\r\n\r\n    function getAmountBorrowed(\r\n        address asset,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireMarketIDAndAssetMatch(state, marketID, asset);\r\n        amount = LendingPool.getAmountBorrowed(state, asset, user, marketID);\r\n    }\r\n\r\n    function getAmountSupplied(\r\n        address asset,\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Requires.requireAssetExist(state, asset);\r\n        amount = LendingPool.getAmountSupplied(state, asset, user);\r\n    }\r\n\r\n    function getInterestRates(\r\n        address asset,\r\n        uint256 extraBorrowAmount\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 borrowInterestRate, uint256 supplyInterestRate)\r\n    {\r\n        Requires.requireAssetExist(state, asset);\r\n        (borrowInterestRate, supplyInterestRate) = LendingPool.getInterestRates(state, asset, extraBorrowAmount);\r\n    }\r\n\r\n    function getInsuranceBalance(address asset)\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Requires.requireAssetExist(state, asset);\r\n        amount = state.pool.insuranceBalances[asset];\r\n    }\r\n\r\n    ///////////////////////\r\n    // Relayer Functions //\r\n    ///////////////////////\r\n\r\n    function approveDelegate(address delegate)\r\n        external\r\n    {\r\n        Relayer.approveDelegate(state, delegate);\r\n    }\r\n\r\n    function revokeDelegate(address delegate)\r\n        external\r\n    {\r\n        Relayer.revokeDelegate(state, delegate);\r\n    }\r\n\r\n    function joinIncentiveSystem()\r\n        external\r\n    {\r\n        Relayer.joinIncentiveSystem(state);\r\n    }\r\n\r\n    function exitIncentiveSystem()\r\n        external\r\n    {\r\n        Relayer.exitIncentiveSystem(state);\r\n    }\r\n\r\n    function canMatchOrdersFrom(address relayer)\r\n        external\r\n        view\r\n        returns (bool canMatch)\r\n    {\r\n        canMatch = Relayer.canMatchOrdersFrom(state, relayer);\r\n    }\r\n\r\n    function isParticipant(address relayer)\r\n        external\r\n        view\r\n        returns (bool result)\r\n    {\r\n        result = Relayer.isParticipant(state, relayer);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Balances Functions //\r\n    ////////////////////////\r\n\r\n    function balanceOf(\r\n        address asset,\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        balance = Transfer.balanceOf(state,  BalancePath.getCommonPath(user), asset);\r\n    }\r\n\r\n    function marketBalanceOf(\r\n        uint16 marketID,\r\n        address asset,\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireMarketIDAndAssetMatch(state, marketID, asset);\r\n        balance = Transfer.balanceOf(state,  BalancePath.getMarketPath(user, marketID), asset);\r\n    }\r\n\r\n    function getMarketTransferableAmount(\r\n        uint16 marketID,\r\n        address asset,\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireMarketIDAndAssetMatch(state, marketID, asset);\r\n        amount = CollateralAccounts.getTransferableAmount(state, marketID, user, asset);\r\n    }\r\n\r\n    /** fallback function to allow deposit ether into this contract */\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // deposit ${msg.value} ether for ${msg.sender}\r\n        Transfer.deposit(\r\n            state,\r\n            Consts.ETHEREUM_TOKEN_ADDRESS(),\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    ////////////////////////\r\n    // Exchange Functions //\r\n    ////////////////////////\r\n\r\n    function cancelOrder(\r\n        Types.Order calldata order\r\n    )\r\n        external\r\n    {\r\n        Exchange.cancelOrder(state, order);\r\n    }\r\n\r\n    function isOrderCancelled(\r\n        bytes32 orderHash\r\n    )\r\n        external\r\n        view\r\n        returns(bool isCancelled)\r\n    {\r\n        isCancelled = state.exchange.cancelled[orderHash];\r\n    }\r\n\r\n    function matchOrders(\r\n        Types.MatchParams memory params\r\n    )\r\n        public\r\n    {\r\n        Exchange.matchOrders(state, params);\r\n    }\r\n\r\n    function getDiscountedRate(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 rate)\r\n    {\r\n        rate = Discount.getDiscountedRate(state, user);\r\n    }\r\n\r\n    function getHydroTokenAddress()\r\n        external\r\n        view\r\n        returns (address hydroTokenAddress)\r\n    {\r\n        hydroTokenAddress = state.exchange.hotTokenAddress;\r\n    }\r\n\r\n    function getOrderFilledAmount(\r\n        bytes32 orderHash\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        amount = state.exchange.filled[orderHash];\r\n    }\r\n}\r\n\r\nlibrary OperationsComponent {\r\n\r\n    function createMarket(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        public\r\n    {\r\n        Requires.requireMarketAssetsValid(state, market);\r\n        Requires.requireMarketNotExist(state, market);\r\n        Requires.requireDecimalLessOrEquanThanOne(market.auctionRatioStart);\r\n        Requires.requireDecimalLessOrEquanThanOne(market.auctionRatioPerBlock);\r\n        Requires.requireDecimalGreaterThanOne(market.liquidateRate);\r\n        Requires.requireDecimalGreaterThanOne(market.withdrawRate);\r\n        require(market.withdrawRate > market.liquidateRate, \"WITHDARW_RATE_LESS_OR_EQUAL_THAN_LIQUIDATE_RATE\");\r\n\r\n        state.markets[state.marketsCount++] = market;\r\n        Events.logCreateMarket(market);\r\n    }\r\n\r\n    function updateMarket(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    )\r\n        external\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireDecimalLessOrEquanThanOne(newAuctionRatioStart);\r\n        Requires.requireDecimalLessOrEquanThanOne(newAuctionRatioPerBlock);\r\n        Requires.requireDecimalGreaterThanOne(newLiquidateRate);\r\n        Requires.requireDecimalGreaterThanOne(newWithdrawRate);\r\n        require(newWithdrawRate > newLiquidateRate, \"WITHDARW_RATE_LESS_OR_EQUAL_THAN_LIQUIDATE_RATE\");\r\n\r\n        state.markets[marketID].auctionRatioStart = newAuctionRatioStart;\r\n        state.markets[marketID].auctionRatioPerBlock = newAuctionRatioPerBlock;\r\n        state.markets[marketID].liquidateRate = newLiquidateRate;\r\n        state.markets[marketID].withdrawRate = newWithdrawRate;\r\n\r\n        Events.logUpdateMarket(\r\n            marketID,\r\n            newAuctionRatioStart,\r\n            newAuctionRatioPerBlock,\r\n            newLiquidateRate,\r\n            newWithdrawRate\r\n        );\r\n    }\r\n\r\n    function setMarketBorrowUsability(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        bool   usability\r\n    )\r\n        external\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        state.markets[marketID].borrowEnable = usability;\r\n        if (usability) {\r\n            Events.logMarketBorrowDisable(\r\n                marketID\r\n            );\r\n        } else {\r\n            Events.logMarketBorrowEnable(\r\n                marketID\r\n            );\r\n        }\r\n    }\r\n\r\n    function createAsset(\r\n        Store.State storage state,\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress,\r\n        string calldata poolTokenName,\r\n        string calldata poolTokenSymbol,\r\n        uint8 poolTokenDecimals\r\n    )\r\n        external\r\n    {\r\n        Requires.requirePriceOracleAddressValid(oracleAddress);\r\n        Requires.requireAssetNotExist(state, asset);\r\n\r\n        LendingPool.initializeAssetLendingPool(state, asset);\r\n\r\n        state.assets[asset].priceOracle = IPriceOracle(oracleAddress);\r\n        state.assets[asset].interestModel = IInterestModel(interestModelAddress);\r\n        state.assets[asset].lendingPoolToken = ILendingPoolToken(address(new LendingPoolToken(\r\n            poolTokenName,\r\n            poolTokenSymbol,\r\n            poolTokenDecimals\r\n        )));\r\n\r\n        Events.logCreateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            address(state.assets[asset].lendingPoolToken),\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    function updateAsset(\r\n        Store.State storage state,\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    )\r\n        external\r\n    {\r\n        Requires.requirePriceOracleAddressValid(oracleAddress);\r\n        Requires.requireAssetExist(state, asset);\r\n\r\n        state.assets[asset].priceOracle = IPriceOracle(oracleAddress);\r\n        state.assets[asset].interestModel = IInterestModel(interestModelAddress);\r\n\r\n        Events.logUpdateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param newConfig A data blob representing the new discount config. Details on format above.\r\n     */\r\n    function updateDiscountConfig(\r\n        Store.State storage state,\r\n        bytes32 newConfig\r\n    )\r\n        external\r\n    {\r\n        state.exchange.discountConfig = newConfig;\r\n        Events.logUpdateDiscountConfig(newConfig);\r\n    }\r\n\r\n    function updateAuctionInitiatorRewardRatio(\r\n        Store.State storage state,\r\n        uint256 newInitiatorRewardRatio\r\n    )\r\n        external\r\n    {\r\n        Requires.requireDecimalLessOrEquanThanOne(newInitiatorRewardRatio);\r\n\r\n        state.auction.initiatorRewardRatio = newInitiatorRewardRatio;\r\n        Events.logUpdateAuctionInitiatorRewardRatio(newInitiatorRewardRatio);\r\n    }\r\n\r\n    function updateInsuranceRatio(\r\n        Store.State storage state,\r\n        uint256 newInsuranceRatio\r\n    )\r\n        external\r\n    {\r\n        Requires.requireDecimalLessOrEquanThanOne(newInsuranceRatio);\r\n\r\n        state.pool.insuranceRatio = newInsuranceRatio;\r\n        Events.logUpdateInsuranceRatio(newInsuranceRatio);\r\n    }\r\n}\r\n\r\nlibrary Discount {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculate and return the rate at which fees will be charged for an address. The discounted\r\n     * rate depends on how much HOT token is owned by the user. Values returned will be a percentage\r\n     * used to calculate how much of the fee is paid, so a return value of 100 means there is 0\r\n     * discount, and a return value of 70 means a 30% rate reduction.\r\n     *\r\n     * The discountConfig is defined as such:\r\n     * ╔═══════════════════╤════════════════════════════════════════════╗\r\n     * ║                   │ length(bytes)   desc                       ║\r\n     * ╟───────────────────┼────────────────────────────────────────────╢\r\n     * ║ count             │ 1               the count of configs       ║\r\n     * ║ maxDiscountedRate │ 1               the max discounted rate    ║\r\n     * ║ config            │ 5 each                                     ║\r\n     * ╚═══════════════════╧════════════════════════════════════════════╝\r\n     *\r\n     * The default discount structure as defined in code would give the following result:\r\n     *\r\n     * Fee discount table\r\n     * ╔════════════════════╤══════════╗\r\n     * ║     HOT BALANCE    │ DISCOUNT ║\r\n     * ╠════════════════════╪══════════╣\r\n     * ║     0 <= x < 10000 │     0%   ║\r\n     * ╟────────────────────┼──────────╢\r\n     * ║ 10000 <= x < 20000 │    10%   ║\r\n     * ╟────────────────────┼──────────╢\r\n     * ║ 20000 <= x < 30000 │    20%   ║\r\n     * ╟────────────────────┼──────────╢\r\n     * ║ 30000 <= x < 40000 │    30%   ║\r\n     * ╟────────────────────┼──────────╢\r\n     * ║ 40000 <= x         │    40%   ║\r\n     * ╚════════════════════╧══════════╝\r\n     *\r\n     * Breaking down the bytes of 0x043c000027106400004e205a000075305000009c404600000000000000000000\r\n     *\r\n     * 0x  04           3c          0000271064  00004e205a  0000753050  00009c4046  0000000000  0000000000;\r\n     *     ~~           ~~          ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~\r\n     *      |            |               |           |           |           |           |           |\r\n     *    count  maxDiscountedRate       1           2           3           4           5           6\r\n     *\r\n     * The first config breaks down as follows:  00002710   64\r\n     *                                           ~~~~~~~~   ~~\r\n     *                                               |      |\r\n     *                                              bar    rate\r\n     *\r\n     * Meaning if a user has less than 10000 (0x00002710) HOT, they will pay 100%(0x64) of the\r\n     * standard fee.\r\n     *\r\n     * @param  user The user address to calculate a fee discount for.\r\n     * @return      The percentage of the regular fee this user will pay.\r\n     */\r\n    function getDiscountedRate(\r\n        Store.State storage state,\r\n        address user\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 result)\r\n    {\r\n        uint256 hotBalance = AssemblyCall.getHotBalance(\r\n            state.exchange.hotTokenAddress,\r\n            user\r\n        );\r\n\r\n        if (hotBalance == 0) {\r\n            return Consts.DISCOUNT_RATE_BASE();\r\n        }\r\n\r\n        bytes32 config = state.exchange.discountConfig;\r\n        uint256 count = uint256(uint8(byte(config)));\r\n        uint256 bar;\r\n\r\n        // HOT Token has 18 decimals\r\n        hotBalance = hotBalance.div(10**18);\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            bar = uint256(uint32(bytes4(config << (2 + i * 5) * 8)));\r\n\r\n            if (hotBalance < bar) {\r\n                result = uint256(uint8(byte(config << (2 + i * 5 + 4) * 8)));\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If we haven't found a rate in the config yet, use the maximum rate.\r\n        if (result == 0) {\r\n            result = uint256(uint8(config[1]));\r\n        }\r\n\r\n        // Make sure our discount algorithm never returns a higher rate than the base.\r\n        require(result <= Consts.DISCOUNT_RATE_BASE(), \"DISCOUNT_ERROR\");\r\n    }\r\n}\r\n\r\nlibrary Exchange {\r\n    using SafeMath for uint256;\r\n    using Order for Types.Order;\r\n    using OrderParam for Types.OrderParam;\r\n\r\n    uint256 private constant EXCHANGE_FEE_RATE_BASE = 100000;\r\n    uint256 private constant SUPPORTED_ORDER_VERSION = 2;\r\n\r\n    /**\r\n     * Calculated data about an order object.\r\n     * Generally the filledAmount is specified in base token units, however in the case of a market\r\n     * buy order the filledAmount is specified in quote token units.\r\n     */\r\n    struct OrderInfo {\r\n        bytes32 orderHash;\r\n        uint256 filledAmount;\r\n        Types.BalancePath balancePath;\r\n    }\r\n\r\n    /**\r\n     * Match taker order to a list of maker orders. Common addresses are passed in\r\n     * separately as an Types.OrderAddressSet to reduce call size data and save gas.\r\n     */\r\n    function matchOrders(\r\n        Store.State storage state,\r\n        Types.MatchParams memory params\r\n    )\r\n        internal\r\n    {\r\n        require(Relayer.canMatchOrdersFrom(state, params.orderAddressSet.relayer), \"INVALID_SENDER\");\r\n        require(!params.takerOrderParam.isMakerOnly(), \"MAKER_ONLY_ORDER_CANNOT_BE_TAKER\");\r\n\r\n        bool isParticipantRelayer = Relayer.isParticipant(state, params.orderAddressSet.relayer);\r\n        uint256 takerFeeRate = getTakerFeeRate(state, params.takerOrderParam, isParticipantRelayer);\r\n        OrderInfo memory takerOrderInfo = getOrderInfo(state, params.takerOrderParam, params.orderAddressSet);\r\n\r\n        // Calculate which orders match for settlement.\r\n        Types.MatchResult[] memory results = new Types.MatchResult[](params.makerOrderParams.length);\r\n\r\n        for (uint256 i = 0; i < params.makerOrderParams.length; i++) {\r\n            require(!params.makerOrderParams[i].isMarketOrder(), \"MAKER_ORDER_CAN_NOT_BE_MARKET_ORDER\");\r\n            require(params.takerOrderParam.isSell() != params.makerOrderParams[i].isSell(), \"INVALID_SIDE\");\r\n            validatePrice(params.takerOrderParam, params.makerOrderParams[i]);\r\n\r\n            OrderInfo memory makerOrderInfo = getOrderInfo(state, params.makerOrderParams[i], params.orderAddressSet);\r\n\r\n            results[i] = getMatchResult(\r\n                state,\r\n                params.takerOrderParam,\r\n                takerOrderInfo,\r\n                params.makerOrderParams[i],\r\n                makerOrderInfo,\r\n                params.baseAssetFilledAmounts[i],\r\n                takerFeeRate,\r\n                isParticipantRelayer\r\n            );\r\n\r\n            // Update amount filled for this maker order.\r\n            state.exchange.filled[makerOrderInfo.orderHash] = makerOrderInfo.filledAmount;\r\n        }\r\n\r\n        // Update amount filled for this taker order.\r\n        state.exchange.filled[takerOrderInfo.orderHash] = takerOrderInfo.filledAmount;\r\n\r\n        settleResults(state, results, params.takerOrderParam, params.orderAddressSet);\r\n    }\r\n\r\n    /**\r\n     * Cancels an order, preventing it from being matched. In practice, matching mode relayers will\r\n     * generally handle cancellation off chain by removing the order from their system, however if\r\n     * the trader wants to ensure the order never goes through, or they no longer trust the relayer,\r\n     * this function may be called to block it from ever matching at the contract level.\r\n     *\r\n     * Emits a Cancel event on success.\r\n     *\r\n     * @param order The order to be cancelled.\r\n     */\r\n    function cancelOrder(\r\n        Store.State storage state,\r\n        Types.Order memory order\r\n    )\r\n        internal\r\n    {\r\n        require(order.trader == msg.sender, \"INVALID_TRADER\");\r\n\r\n        bytes32 orderHash = order.getHash();\r\n        state.exchange.cancelled[orderHash] = true;\r\n\r\n        Events.logOrderCancel(orderHash);\r\n    }\r\n\r\n    /**\r\n     * Calculates current state of the order. Will revert transaction if this order is not\r\n     * fillable for any reason, or if the order signature is invalid.\r\n     *\r\n     * @param orderParam The Types.OrderParam object containing Order data.\r\n     * @param orderAddressSet An object containing addresses common across each order.\r\n     * @return An OrderInfo object containing the hash and current amount filled\r\n     */\r\n    function getOrderInfo(\r\n        Store.State storage state,\r\n        Types.OrderParam memory orderParam,\r\n        Types.OrderAddressSet memory orderAddressSet\r\n    )\r\n        private\r\n        view\r\n        returns (OrderInfo memory orderInfo)\r\n    {\r\n        require(orderParam.getOrderVersion() == SUPPORTED_ORDER_VERSION, \"ORDER_VERSION_NOT_SUPPORTED\");\r\n\r\n        Types.Order memory order = getOrderFromOrderParam(orderParam, orderAddressSet);\r\n        orderInfo.orderHash = order.getHash();\r\n        orderInfo.filledAmount = state.exchange.filled[orderInfo.orderHash];\r\n        uint8 status = uint8(Types.OrderStatus.FILLABLE);\r\n\r\n        if (!orderParam.isMarketBuy() && orderInfo.filledAmount >= order.baseAssetAmount) {\r\n            status = uint8(Types.OrderStatus.FULLY_FILLED);\r\n        } else if (orderParam.isMarketBuy() && orderInfo.filledAmount >= order.quoteAssetAmount) {\r\n            status = uint8(Types.OrderStatus.FULLY_FILLED);\r\n        } else if (block.timestamp >= orderParam.getExpiredAtFromOrderData()) {\r\n            status = uint8(Types.OrderStatus.EXPIRED);\r\n        } else if (state.exchange.cancelled[orderInfo.orderHash]) {\r\n            status = uint8(Types.OrderStatus.CANCELLED);\r\n        }\r\n\r\n        require(\r\n            status == uint8(Types.OrderStatus.FILLABLE),\r\n            \"ORDER_IS_NOT_FILLABLE\"\r\n        );\r\n\r\n        require(\r\n            Signature.isValidSignature(orderInfo.orderHash, orderParam.trader, orderParam.signature),\r\n            \"INVALID_ORDER_SIGNATURE\"\r\n        );\r\n\r\n        orderInfo.balancePath = orderParam.getBalancePathFromOrderData();\r\n        Requires.requirePathNormalStatus(state, orderInfo.balancePath);\r\n\r\n        return orderInfo;\r\n    }\r\n\r\n    /**\r\n     * Reconstruct an Order object from the given Types.OrderParam and Types.OrderAddressSet objects.\r\n     *\r\n     * @param orderParam The Types.OrderParam object containing the Order data.\r\n     * @param orderAddressSet An object containing addresses common across each order.\r\n     * @return The reconstructed Order object.\r\n     */\r\n    function getOrderFromOrderParam(\r\n        Types.OrderParam memory orderParam,\r\n        Types.OrderAddressSet memory orderAddressSet\r\n    )\r\n        private\r\n        pure\r\n        returns (Types.Order memory order)\r\n    {\r\n        order.trader = orderParam.trader;\r\n        order.baseAssetAmount = orderParam.baseAssetAmount;\r\n        order.quoteAssetAmount = orderParam.quoteAssetAmount;\r\n        order.gasTokenAmount = orderParam.gasTokenAmount;\r\n        order.data = orderParam.data;\r\n        order.baseAsset = orderAddressSet.baseAsset;\r\n        order.quoteAsset = orderAddressSet.quoteAsset;\r\n        order.relayer = orderAddressSet.relayer;\r\n    }\r\n\r\n    /**\r\n     * Validates that the maker and taker orders can be matched based on the listed prices.\r\n     *\r\n     * If the taker submitted a sell order, the matching maker order must have a price greater than\r\n     * or equal to the price the taker is willing to sell for.\r\n     *\r\n     * Since the price of an order is computed by order.quoteAssetAmount / order.baseAssetAmount\r\n     * we can establish the following formula:\r\n     *\r\n     *    takerOrder.quoteAssetAmount        makerOrder.quoteAssetAmount\r\n     *   -----------------------------  <=  -----------------------------\r\n     *     takerOrder.baseAssetAmount        makerOrder.baseAssetAmount\r\n     *\r\n     * To avoid precision loss from division, we modify the formula to avoid division entirely.\r\n     * In shorthand, this becomes:\r\n     *\r\n     *   takerOrder.quote * makerOrder.base <= takerOrder.base * makerOrder.quote\r\n     *\r\n     * We can apply this same process to buy orders - if the taker submitted a buy order then\r\n     * the matching maker order must have a price less than or equal to the price the taker is\r\n     * willing to pay. This means we can use the same result as above, but simply flip the\r\n     * sign of the comparison operator.\r\n     *\r\n     * The function will revert the transaction if the orders cannot be matched.\r\n     *\r\n     * @param takerOrderParam The Types.OrderParam object representing the taker's order data\r\n     * @param makerOrderParam The Types.OrderParam object representing the maker's order data\r\n     */\r\n    function validatePrice(\r\n        Types.OrderParam memory takerOrderParam,\r\n        Types.OrderParam memory makerOrderParam\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 left = takerOrderParam.quoteAssetAmount.mul(makerOrderParam.baseAssetAmount);\r\n        uint256 right = takerOrderParam.baseAssetAmount.mul(makerOrderParam.quoteAssetAmount);\r\n        require(takerOrderParam.isSell() ? left <= right : left >= right, \"INVALID_MATCH\");\r\n    }\r\n\r\n    /**\r\n     * Construct a Types.MatchResult from matching taker and maker order data, which will be used when\r\n     * settling the orders and transferring token.\r\n     *\r\n     * @param takerOrderParam The Types.OrderParam object representing the taker's order data\r\n     * @param takerOrderInfo The OrderInfo object representing the current taker order state\r\n     * @param makerOrderParam The Types.OrderParam object representing the maker's order data\r\n     * @param makerOrderInfo The OrderInfo object representing the current maker order state\r\n     * @param takerFeeRate The rate used to calculate the fee charged to the taker\r\n     * @param isParticipantRelayer Whether this relayer is participating in hot discount\r\n     * @return Types.MatchResult object containing data that will be used during order settlement.\r\n     */\r\n    function getMatchResult(\r\n        Store.State storage state,\r\n        Types.OrderParam memory takerOrderParam,\r\n        OrderInfo memory takerOrderInfo,\r\n        Types.OrderParam memory makerOrderParam,\r\n        OrderInfo memory makerOrderInfo,\r\n        uint256 baseAssetFilledAmount,\r\n        uint256 takerFeeRate,\r\n        bool isParticipantRelayer\r\n    )\r\n        private\r\n        view\r\n        returns (Types.MatchResult memory result)\r\n    {\r\n        result.baseAssetFilledAmount = baseAssetFilledAmount;\r\n        result.quoteAssetFilledAmount = convertBaseToQuote(makerOrderParam, baseAssetFilledAmount);\r\n\r\n        result.takerBalancePath = takerOrderInfo.balancePath;\r\n        result.makerBalancePath = makerOrderInfo.balancePath;\r\n\r\n        // Each order only pays gas once, so only pay gas when nothing has been filled yet.\r\n        if (takerOrderInfo.filledAmount == 0) {\r\n            result.takerGasFee = takerOrderParam.gasTokenAmount;\r\n        }\r\n\r\n        if (makerOrderInfo.filledAmount == 0) {\r\n            result.makerGasFee = makerOrderParam.gasTokenAmount;\r\n        }\r\n\r\n        if(!takerOrderParam.isMarketBuy()) {\r\n            takerOrderInfo.filledAmount = takerOrderInfo.filledAmount.add(result.baseAssetFilledAmount);\r\n            require(takerOrderInfo.filledAmount <= takerOrderParam.baseAssetAmount, \"TAKER_ORDER_OVER_MATCH\");\r\n        } else {\r\n            takerOrderInfo.filledAmount = takerOrderInfo.filledAmount.add(result.quoteAssetFilledAmount);\r\n            require(takerOrderInfo.filledAmount <= takerOrderParam.quoteAssetAmount, \"TAKER_ORDER_OVER_MATCH\");\r\n        }\r\n\r\n        makerOrderInfo.filledAmount = makerOrderInfo.filledAmount.add(result.baseAssetFilledAmount);\r\n        require(makerOrderInfo.filledAmount <= makerOrderParam.baseAssetAmount, \"MAKER_ORDER_OVER_MATCH\");\r\n\r\n        result.maker = makerOrderParam.trader;\r\n        result.taker = takerOrderParam.trader;\r\n\r\n        if(takerOrderParam.isSell()) {\r\n            result.buyer = result.maker;\r\n        } else {\r\n            result.buyer = result.taker;\r\n        }\r\n\r\n        uint256 rebateRate = makerOrderParam.getMakerRebateRateFromOrderData();\r\n\r\n        if (rebateRate > 0) {\r\n            // If the rebate rate is not zero, maker pays no fees.\r\n            result.makerFee = 0;\r\n\r\n            // RebateRate will never exceed REBATE_RATE_BASE, so rebateFee will never exceed the fees paid by the taker.\r\n            result.makerRebate = result.quoteAssetFilledAmount.mul(takerFeeRate).mul(rebateRate).div(\r\n                EXCHANGE_FEE_RATE_BASE.mul(Consts.DISCOUNT_RATE_BASE()).mul(Consts.REBATE_RATE_BASE())\r\n            );\r\n        } else {\r\n            uint256 makerRawFeeRate = makerOrderParam.getAsMakerFeeRateFromOrderData();\r\n            result.makerRebate = 0;\r\n\r\n            // maker fee will be reduced, but still >= 0\r\n            uint256 makerFeeRate = getFinalFeeRate(\r\n                state,\r\n                makerOrderParam.trader,\r\n                makerRawFeeRate,\r\n                isParticipantRelayer\r\n            );\r\n\r\n            result.makerFee = result.quoteAssetFilledAmount.mul(makerFeeRate).div(\r\n                EXCHANGE_FEE_RATE_BASE.mul(Consts.DISCOUNT_RATE_BASE())\r\n            );\r\n        }\r\n\r\n        result.takerFee = result.quoteAssetFilledAmount.mul(takerFeeRate).div(\r\n            EXCHANGE_FEE_RATE_BASE.mul(Consts.DISCOUNT_RATE_BASE())\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the rate used to calculate the taker fee.\r\n     *\r\n     * @param orderParam The Types.OrderParam object representing the taker order data.\r\n     * @param isParticipantRelayer Whether this relayer is participating in hot discount.\r\n     * @return The final potentially discounted rate to use for the taker fee.\r\n     */\r\n    function getTakerFeeRate(\r\n        Store.State storage state,\r\n        Types.OrderParam memory orderParam,\r\n        bool isParticipantRelayer\r\n    )\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 rawRate = orderParam.getAsTakerFeeRateFromOrderData();\r\n        return getFinalFeeRate(state, orderParam.trader, rawRate, isParticipantRelayer);\r\n    }\r\n\r\n    /**\r\n     * Take a fee rate and calculate the potentially discounted rate for this trader based on\r\n     * HOT token ownership.\r\n     *\r\n     * @param trader The address of the trader who made the order.\r\n     * @param rate The raw rate which we will discount if needed.\r\n     * @param isParticipantRelayer Whether this relayer is participating in hot discount.\r\n     * @return The final potentially discounted rate.\r\n     */\r\n    function getFinalFeeRate(\r\n        Store.State storage state,\r\n        address trader,\r\n        uint256 rate,\r\n        bool isParticipantRelayer\r\n    )\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (isParticipantRelayer) {\r\n            return rate.mul(Discount.getDiscountedRate(state, trader));\r\n        } else {\r\n            return rate.mul(Consts.DISCOUNT_RATE_BASE());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Take an amount and convert it from base token units to quote token units based on the price\r\n     * in the order param.\r\n     *\r\n     * @param orderParam The Types.OrderParam object containing the Order data.\r\n     * @param amount An amount of base token.\r\n     * @return The converted amount in quote token units.\r\n     */\r\n    function convertBaseToQuote(\r\n        Types.OrderParam memory orderParam,\r\n        uint256 amount\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SafeMath.getPartialAmountFloor(\r\n            orderParam.quoteAssetAmount,\r\n            orderParam.baseAssetAmount,\r\n            amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Take a list of matches and settle them with the taker order, transferring tokens all tokens\r\n     * and paying all fees necessary to complete the transaction.\r\n     *\r\n     * Settles a order given a list of Types.MatchResult objects. A naive approach would be to take\r\n     * each result, have the taker and maker transfer the appropriate tokens, and then have them\r\n     * each send the appropriate fees to the relayer, meaning that for n makers there would be 4n\r\n     * transactions.\r\n     *\r\n     * Instead we do the following:\r\n     *\r\n     * For a match which has a taker as seller:\r\n     *  - Taker transfers the required base token to each maker\r\n     *  - Each maker sends an amount of quote token to the taker equal to:\r\n     *    [Amount owed to taker] + [Maker fee] + [Maker gas cost] - [Maker rebate amount]\r\n     *  - Since the taker has received all the maker fees and gas costs, it can then send them along\r\n     *    with taker fees in a single batch transaction to the relayer, equal to:\r\n     *    [All maker and taker fees] + [All maker and taker gas costs] - [All maker rebates]\r\n     *\r\n     * Thus in the end the taker will have the full amount of quote token, sans the fee and cost of\r\n     * their share of gas. Each maker will have their share of base token, sans the fee and cost of\r\n     * their share of gas, and will keep their rebate in quote token. The relayer will end up with\r\n     * the fees from the taker and each maker (sans rebate), and the gas costs will pay for the\r\n     * transactions.\r\n     *\r\n     * For a match which has a taker as buyer:\r\n     *  - Each maker transfers base tokens to the taker\r\n     *  - The taker sends an amount of quote tokens to each maker equal to:\r\n     *    [Amount owed to maker] + [Maker rebate amount] - [Maker fee] - [Maker gas cost]\r\n     *  - Since the taker saved all the maker fees and gas costs, it can then send them as a single\r\n     *    batch transaction to the relayer, equal to:\r\n     *    [All maker and taker fees] + [All maker and taker gas costs] - [All maker rebates]\r\n     *\r\n     * Thus in the end the taker will have the full amount of base token, sans the fee and cost of\r\n     * their share of gas. Each maker will have their share of quote token, including their rebate,\r\n     * but sans the fee and cost of their share of gas. The relayer will end up with the fees from\r\n     * the taker and each maker (sans rebates), and the gas costs will pay for the transactions.\r\n     *\r\n     * In this scenario, with n makers there will be 2n + 1 transactions, which will be a significant\r\n     * gas savings over the original method.\r\n     *\r\n     * @param results List of Types.MatchResult objects representing each individual trade to settle.\r\n     * @param takerOrderParam The Types.OrderParam object representing the taker order data.\r\n     * @param orderAddressSet An object containing addresses common across each order.\r\n     */\r\n    function settleResults(\r\n        Store.State storage state,\r\n        Types.MatchResult[] memory results,\r\n        Types.OrderParam memory takerOrderParam,\r\n        Types.OrderAddressSet memory orderAddressSet\r\n    )\r\n        private\r\n    {\r\n        bool isTakerSell = takerOrderParam.isSell();\r\n\r\n        uint256 totalFee = 0;\r\n\r\n        Types.BalancePath memory relayerBalancePath = Types.BalancePath({\r\n            user: orderAddressSet.relayer,\r\n            marketID: 0,\r\n            category: Types.BalanceCategory.Common\r\n        });\r\n\r\n        for (uint256 i = 0; i < results.length; i++) {\r\n            Transfer.transfer(\r\n                state,\r\n                orderAddressSet.baseAsset,\r\n                isTakerSell ? results[i].takerBalancePath : results[i].makerBalancePath,\r\n                isTakerSell ? results[i].makerBalancePath : results[i].takerBalancePath,\r\n                results[i].baseAssetFilledAmount\r\n            );\r\n\r\n            uint256 transferredQuoteAmount;\r\n\r\n            if(isTakerSell) {\r\n                transferredQuoteAmount = results[i].quoteAssetFilledAmount.\r\n                    add(results[i].makerFee).\r\n                    add(results[i].makerGasFee).\r\n                    sub(results[i].makerRebate);\r\n            } else {\r\n                transferredQuoteAmount = results[i].quoteAssetFilledAmount.\r\n                    sub(results[i].makerFee).\r\n                    sub(results[i].makerGasFee).\r\n                    add(results[i].makerRebate);\r\n            }\r\n\r\n            Transfer.transfer(\r\n                state,\r\n                orderAddressSet.quoteAsset,\r\n                isTakerSell ? results[i].makerBalancePath : results[i].takerBalancePath,\r\n                isTakerSell ? results[i].takerBalancePath : results[i].makerBalancePath,\r\n                transferredQuoteAmount\r\n            );\r\n\r\n            Requires.requireCollateralAccountNotLiquidatable(state, results[i].makerBalancePath);\r\n\r\n            totalFee = totalFee.add(results[i].takerFee).add(results[i].makerFee);\r\n            totalFee = totalFee.add(results[i].makerGasFee).add(results[i].takerGasFee);\r\n            totalFee = totalFee.sub(results[i].makerRebate);\r\n\r\n            Events.logMatch(results[i], orderAddressSet);\r\n        }\r\n\r\n        Transfer.transfer(\r\n            state,\r\n            orderAddressSet.quoteAsset,\r\n            results[0].takerBalancePath,\r\n            relayerBalancePath,\r\n            totalFee\r\n        );\r\n\r\n        Requires.requireCollateralAccountNotLiquidatable(state, results[0].takerBalancePath);\r\n    }\r\n}\r\n\r\nlibrary Relayer {\r\n    /**\r\n     * Approve an address to match orders on behalf of msg.sender\r\n     */\r\n    function approveDelegate(\r\n        Store.State storage state,\r\n        address delegate\r\n    )\r\n        internal\r\n    {\r\n        state.relayer.relayerDelegates[msg.sender][delegate] = true;\r\n        Events.logRelayerApproveDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    /**\r\n     * Revoke an existing delegate\r\n     */\r\n    function revokeDelegate(\r\n        Store.State storage state,\r\n        address delegate\r\n    )\r\n        internal\r\n    {\r\n        state.relayer.relayerDelegates[msg.sender][delegate] = false;\r\n        Events.logRelayerRevokeDelegate(msg.sender, delegate);\r\n    }\r\n\r\n    /**\r\n     * @return true if msg.sender is allowed to match orders which belong to relayer\r\n     */\r\n    function canMatchOrdersFrom(\r\n        Store.State storage state,\r\n        address relayer\r\n    )\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == relayer || state.relayer.relayerDelegates[relayer][msg.sender] == true;\r\n    }\r\n\r\n    /**\r\n     * Join the Hydro incentive system.\r\n     */\r\n    function joinIncentiveSystem(\r\n        Store.State storage state\r\n    )\r\n        internal\r\n    {\r\n        delete state.relayer.hasExited[msg.sender];\r\n        Events.logRelayerJoin(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Exit the Hydro incentive system.\r\n     * For relayers that choose to opt-out, the Hydro Protocol\r\n     * effective becomes a tokenless protocol.\r\n     */\r\n    function exitIncentiveSystem(\r\n        Store.State storage state\r\n    )\r\n        internal\r\n    {\r\n        state.relayer.hasExited[msg.sender] = true;\r\n        Events.logRelayerExit(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @return true if relayer is participating in the Hydro incentive system.\r\n     */\r\n    function isParticipant(\r\n        Store.State storage state,\r\n        address relayer\r\n    )\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        return !state.relayer.hasExited[relayer];\r\n    }\r\n}\r\n\r\nlibrary Auctions {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n    using Auction for Types.Auction;\r\n\r\n    /**\r\n     * Liquidate a collateral account\r\n     */\r\n    function liquidate(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        external\r\n        returns (bool, uint32)\r\n    {\r\n        // if the account is in liquidate progress, liquidatable will be false\r\n        Types.CollateralAccountDetails memory details = CollateralAccounts.getDetails(\r\n            state,\r\n            user,\r\n            marketID\r\n        );\r\n\r\n        require(details.liquidatable, \"ACCOUNT_NOT_LIQUIDABLE\");\r\n\r\n        Types.Market storage market = state.markets[marketID];\r\n        Types.CollateralAccount storage account = state.accounts[user][marketID];\r\n\r\n        LendingPool.repay(\r\n            state,\r\n            user,\r\n            marketID,\r\n            market.baseAsset,\r\n            account.balances[market.baseAsset]\r\n        );\r\n\r\n        LendingPool.repay(\r\n            state,\r\n            user,\r\n            marketID,\r\n            market.quoteAsset,\r\n            account.balances[market.quoteAsset]\r\n        );\r\n\r\n        address collateralAsset;\r\n        address debtAsset;\r\n\r\n        uint256 leftBaseAssetDebt = LendingPool.getAmountBorrowed(\r\n            state,\r\n            market.baseAsset,\r\n            user,\r\n            marketID\r\n        );\r\n\r\n        uint256 leftQuoteAssetDebt = LendingPool.getAmountBorrowed(\r\n            state,\r\n            market.quoteAsset,\r\n            user,\r\n            marketID\r\n        );\r\n\r\n        bool hasAution = !(leftBaseAssetDebt == 0 && leftQuoteAssetDebt == 0);\r\n\r\n        Events.logLiquidate(\r\n            user,\r\n            marketID,\r\n            hasAution\r\n        );\r\n\r\n        if (!hasAution) {\r\n            // no auction\r\n            return (false, 0);\r\n        }\r\n\r\n        account.status = Types.CollateralAccountStatus.Liquid;\r\n\r\n        if(account.balances[market.baseAsset] > 0) {\r\n            // quote asset is debt, base asset is collateral\r\n            collateralAsset = market.baseAsset;\r\n            debtAsset = market.quoteAsset;\r\n        } else {\r\n            // base asset is debt, quote asset is collateral\r\n            collateralAsset = market.quoteAsset;\r\n            debtAsset = market.baseAsset;\r\n        }\r\n\r\n        uint32 newAuctionID = create(\r\n            state,\r\n            marketID,\r\n            user,\r\n            msg.sender,\r\n            debtAsset,\r\n            collateralAsset\r\n        );\r\n\r\n        return (true, newAuctionID);\r\n    }\r\n\r\n    function fillHealthyAuction(\r\n        Store.State storage state,\r\n        Types.Auction storage auction,\r\n        uint256 ratio,\r\n        uint256 repayAmount\r\n    )\r\n        private\r\n        returns (uint256, uint256) // bidderRepay collateral\r\n    {\r\n        uint256 leftDebtAmount = LendingPool.getAmountBorrowed(\r\n            state,\r\n            auction.debtAsset,\r\n            auction.borrower,\r\n            auction.marketID\r\n        );\r\n\r\n        // get remaining collateral\r\n        uint256 leftCollateralAmount = state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset];\r\n\r\n        state.accounts[auction.borrower][auction.marketID].balances[auction.debtAsset] = repayAmount;\r\n\r\n        // borrower pays back to the lending pool\r\n        uint256 actualRepayAmount = LendingPool.repay(\r\n            state,\r\n            auction.borrower,\r\n            auction.marketID,\r\n            auction.debtAsset,\r\n            repayAmount\r\n        );\r\n\r\n        state.accounts[auction.borrower][auction.marketID].balances[auction.debtAsset] = 0;\r\n\r\n        // compute how much collateral is divided up amongst the bidder, auction initiator, and borrower\r\n        state.balances[msg.sender][auction.debtAsset] = SafeMath.sub(\r\n            state.balances[msg.sender][auction.debtAsset],\r\n            actualRepayAmount\r\n        );\r\n\r\n        uint256 collateralToProcess = leftCollateralAmount.mul(actualRepayAmount).div(leftDebtAmount);\r\n        uint256 collateralForBidder = Decimal.mulFloor(collateralToProcess, ratio);\r\n\r\n        uint256 collateralForInitiator = Decimal.mulFloor(collateralToProcess.sub(collateralForBidder), state.auction.initiatorRewardRatio);\r\n        uint256 collateralForBorrower = collateralToProcess.sub(collateralForBidder).sub(collateralForInitiator);\r\n\r\n        // update remaining collateral ammount\r\n        state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset] = SafeMath.sub(\r\n            state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset],\r\n            collateralToProcess\r\n        );\r\n\r\n        // send a portion of collateral to the bidder\r\n        state.balances[msg.sender][auction.collateralAsset] = SafeMath.add(\r\n            state.balances[msg.sender][auction.collateralAsset],\r\n            collateralForBidder\r\n        );\r\n\r\n        // send a portion of collateral to the initiator\r\n        state.balances[auction.initiator][auction.collateralAsset] = SafeMath.add(\r\n            state.balances[auction.initiator][auction.collateralAsset],\r\n            collateralForInitiator\r\n        );\r\n\r\n        // send a portion of collateral to the borrower\r\n        state.balances[auction.borrower][auction.collateralAsset] = SafeMath.add(\r\n            state.balances[auction.borrower][auction.collateralAsset],\r\n            collateralForBorrower\r\n        );\r\n\r\n        // withdraw collateralForBorrower to borrower's wallet account\r\n        Transfer.withdraw(\r\n            state,\r\n            auction.borrower,\r\n            auction.collateralAsset,\r\n            collateralForBorrower\r\n        );\r\n\r\n        return (actualRepayAmount, collateralForBidder);\r\n    }\r\n\r\n    /**\r\n     * Msg.sender only need to afford bidderRepayAmount and get collateralAmount\r\n     * insurance and suppliers will cover the badDebtAmount\r\n     */\r\n    function fillBadAuction(\r\n        Store.State storage state,\r\n        Types.Auction storage auction,\r\n        uint256 ratio,\r\n        uint256 bidderRepayAmount\r\n    )\r\n        private\r\n        returns (uint256, uint256, uint256) // totalRepay bidderRepay collateral\r\n    {\r\n\r\n        uint256 leftDebtAmount = LendingPool.getAmountBorrowed(\r\n            state,\r\n            auction.debtAsset,\r\n            auction.borrower,\r\n            auction.marketID\r\n        );\r\n\r\n        uint256 leftCollateralAmount = state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset];\r\n\r\n        uint256 repayAmount = Decimal.mulFloor(bidderRepayAmount, ratio);\r\n\r\n        state.accounts[auction.borrower][auction.marketID].balances[auction.debtAsset] = repayAmount;\r\n\r\n        uint256 actualRepayAmount = LendingPool.repay(\r\n            state,\r\n            auction.borrower,\r\n            auction.marketID,\r\n            auction.debtAsset,\r\n            repayAmount\r\n        );\r\n\r\n        state.accounts[auction.borrower][auction.marketID].balances[auction.debtAsset] = 0; // recover unused principal\r\n\r\n        uint256 actualBidderRepay = bidderRepayAmount;\r\n\r\n        if (actualRepayAmount < repayAmount) {\r\n            actualBidderRepay = Decimal.divCeil(actualRepayAmount, ratio);\r\n        }\r\n\r\n        // gather repay capital\r\n        LendingPool.claimInsurance(state, auction.debtAsset, actualRepayAmount.sub(actualBidderRepay));\r\n\r\n        state.balances[msg.sender][auction.debtAsset] = SafeMath.sub(\r\n            state.balances[msg.sender][auction.debtAsset],\r\n            actualBidderRepay\r\n        );\r\n\r\n        // update collateralAmount\r\n        uint256 collateralForBidder = leftCollateralAmount.mul(actualRepayAmount).div(leftDebtAmount);\r\n\r\n        state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset] = SafeMath.sub(\r\n            state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset],\r\n            collateralForBidder\r\n        );\r\n\r\n        // bidder receive collateral\r\n        state.balances[msg.sender][auction.collateralAsset] = SafeMath.add(\r\n            state.balances[msg.sender][auction.collateralAsset],\r\n            collateralForBidder\r\n        );\r\n\r\n        return (actualRepayAmount, actualBidderRepay, collateralForBidder);\r\n    }\r\n\r\n    // ensure repay no more than repayAmount\r\n    function fillAuctionWithAmount(\r\n        Store.State storage state,\r\n        uint32 auctionID,\r\n        uint256 repayAmount\r\n    )\r\n        external\r\n    {\r\n        Types.Auction storage auction = state.auction.auctions[auctionID];\r\n        uint256 ratio = auction.ratio(state);\r\n\r\n        uint256 actualRepayAmount;\r\n        uint256 actualBidderRepayAmount;\r\n        uint256 collateralForBidder;\r\n\r\n        if (ratio <= Decimal.one()) {\r\n            (actualRepayAmount, collateralForBidder) = fillHealthyAuction(state, auction, ratio, repayAmount);\r\n            actualBidderRepayAmount = actualRepayAmount;\r\n        } else {\r\n            (actualRepayAmount, actualBidderRepayAmount, collateralForBidder) = fillBadAuction(state, auction, ratio, repayAmount);\r\n        }\r\n\r\n        // reset account state if all debts are paid\r\n        uint256 leftDebtAmount = LendingPool.getAmountBorrowed(\r\n            state,\r\n            auction.debtAsset,\r\n            auction.borrower,\r\n            auction.marketID\r\n        );\r\n\r\n        Events.logFillAuction(auction.id, msg.sender, actualRepayAmount, actualBidderRepayAmount, collateralForBidder, leftDebtAmount);\r\n\r\n        if (leftDebtAmount == 0) {\r\n            endAuction(state, auction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mark an auction as finished.\r\n     * An auction typically ends either when it becomes fully filled, or when it expires and is closed\r\n     */\r\n    function endAuction(\r\n        Store.State storage state,\r\n        Types.Auction storage auction\r\n    )\r\n        private\r\n    {\r\n        auction.status = Types.AuctionStatus.Finished;\r\n\r\n        state.accounts[auction.borrower][auction.marketID].status = Types.CollateralAccountStatus.Normal;\r\n\r\n        for (uint i = 0; i < state.auction.currentAuctions.length; i++) {\r\n            if (state.auction.currentAuctions[i] == auction.id) {\r\n                state.auction.currentAuctions[i] = state.auction.currentAuctions[state.auction.currentAuctions.length-1];\r\n                state.auction.currentAuctions.length--;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new auction and save it in global state\r\n     */\r\n    function create(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address borrower,\r\n        address initiator,\r\n        address debtAsset,\r\n        address collateralAsset\r\n    )\r\n        private\r\n        returns (uint32)\r\n    {\r\n        uint32 id = state.auction.auctionsCount++;\r\n\r\n        Types.Auction memory auction = Types.Auction({\r\n            id: id,\r\n            status: Types.AuctionStatus.InProgress,\r\n            startBlockNumber: uint32(block.number),\r\n            marketID: marketID,\r\n            borrower: borrower,\r\n            initiator: initiator,\r\n            debtAsset: debtAsset,\r\n            collateralAsset: collateralAsset\r\n        });\r\n\r\n        state.auction.auctions[id] = auction;\r\n        state.auction.currentAuctions.push(id);\r\n\r\n        Events.logAuctionCreate(id);\r\n\r\n        return id;\r\n    }\r\n\r\n    // price = debt / collateral / ratio\r\n    function getAuctionDetails(\r\n        Store.State storage state,\r\n        uint32 auctionID\r\n    )\r\n        external\r\n        view\r\n        returns (Types.AuctionDetails memory details)\r\n    {\r\n        Types.Auction memory auction = state.auction.auctions[auctionID];\r\n\r\n        details.borrower = auction.borrower;\r\n        details.marketID = auction.marketID;\r\n        details.debtAsset = auction.debtAsset;\r\n        details.collateralAsset = auction.collateralAsset;\r\n\r\n        if (state.auction.auctions[auctionID].status == Types.AuctionStatus.Finished){\r\n            details.finished = true;\r\n        } else {\r\n            details.finished = false;\r\n            details.leftDebtAmount = LendingPool.getAmountBorrowed(\r\n                state,\r\n                auction.debtAsset,\r\n                auction.borrower,\r\n                auction.marketID\r\n            );\r\n            details.leftCollateralAmount = state.accounts[auction.borrower][auction.marketID].balances[auction.collateralAsset];\r\n\r\n            details.ratio = auction.ratio(state);\r\n\r\n            if (details.leftCollateralAmount != 0 && details.ratio != 0) {\r\n                // price = debt/collateral/ratio\r\n                details.price = Decimal.divFloor(Decimal.divFloor(details.leftDebtAmount, details.leftCollateralAmount), details.ratio);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BatchActions {\r\n    using SafeMath for uint256;\r\n    /**\r\n     * All allowed actions types\r\n     */\r\n    enum ActionType {\r\n        Deposit,   // Move asset from your wallet to tradeable balance\r\n        Withdraw,  // Move asset from your tradeable balance to wallet\r\n        Transfer,  // Move asset between tradeable balance and margin account\r\n        Borrow,    // Borrow asset from pool\r\n        Repay,     // Repay asset to pool\r\n        Supply,    // Move asset from tradeable balance to pool to earn interest\r\n        Unsupply   // Move asset from pool back to tradeable balance\r\n    }\r\n\r\n    /**\r\n     * Uniform parameter for an action\r\n     */\r\n    struct Action {\r\n        ActionType actionType;  // The action type\r\n        bytes encodedParams;    // Encoded params, it's different for each action\r\n    }\r\n\r\n    /**\r\n     * Batch actions entrance\r\n     * @param actions List of actions\r\n     */\r\n    function batch(\r\n        Store.State storage state,\r\n        Action[] memory actions,\r\n        uint256 msgValue\r\n    )\r\n        public\r\n    {\r\n        uint256 totalDepositedEtherAmount = 0;\r\n\r\n        for (uint256 i = 0; i < actions.length; i++) {\r\n            Action memory action = actions[i];\r\n            ActionType actionType = action.actionType;\r\n\r\n            if (actionType == ActionType.Deposit) {\r\n                uint256 depositedEtherAmount = deposit(state, action);\r\n                totalDepositedEtherAmount = totalDepositedEtherAmount.add(depositedEtherAmount);\r\n            } else if (actionType == ActionType.Withdraw) {\r\n                withdraw(state, action);\r\n            } else if (actionType == ActionType.Transfer) {\r\n                transfer(state, action);\r\n            } else if (actionType == ActionType.Borrow) {\r\n                borrow(state, action);\r\n            } else if (actionType == ActionType.Repay) {\r\n                repay(state, action);\r\n            } else if (actionType == ActionType.Supply) {\r\n                supply(state, action);\r\n            } else if (actionType == ActionType.Unsupply) {\r\n                unsupply(state, action);\r\n            }\r\n        }\r\n\r\n        require(totalDepositedEtherAmount == msgValue, \"MSG_VALUE_AND_AMOUNT_MISMATCH\");\r\n    }\r\n\r\n    function deposit(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        (\r\n            address asset,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                address,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        return Transfer.deposit(\r\n            state,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function withdraw(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n    {\r\n        (\r\n            address asset,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                address,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        Transfer.withdraw(\r\n            state,\r\n            msg.sender,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n    {\r\n        (\r\n            address asset,\r\n            Types.BalancePath memory fromBalancePath,\r\n            Types.BalancePath memory toBalancePath,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                address,\r\n                Types.BalancePath,\r\n                Types.BalancePath,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        require(fromBalancePath.user == msg.sender, \"CAN_NOT_MOVE_OTHER_USER_ASSET\");\r\n        require(toBalancePath.user == msg.sender, \"CAN_NOT_MOVE_ASSET_TO_OTHER_USER\");\r\n\r\n        Requires.requirePathNormalStatus(state, fromBalancePath);\r\n        Requires.requirePathNormalStatus(state, toBalancePath);\r\n\r\n        // The below two requires will be checked in Transfer.transfer\r\n        // Requires.requirePathMarketIDAssetMatch(state, fromBalancePath, asset);\r\n        // Requires.requirePathMarketIDAssetMatch(state, toBalancePath, asset);\r\n\r\n        if (fromBalancePath.category == Types.BalanceCategory.CollateralAccount) {\r\n            require(\r\n                CollateralAccounts.getTransferableAmount(state, fromBalancePath.marketID, fromBalancePath.user, asset) >= amount,\r\n                \"COLLATERAL_ACCOUNT_TRANSFERABLE_AMOUNT_NOT_ENOUGH\"\r\n            );\r\n        }\r\n\r\n        Transfer.transfer(\r\n            state,\r\n            asset,\r\n            fromBalancePath,\r\n            toBalancePath,\r\n            amount\r\n        );\r\n\r\n        if (toBalancePath.category == Types.BalanceCategory.CollateralAccount) {\r\n            Events.logIncreaseCollateral(msg.sender, toBalancePath.marketID, asset, amount);\r\n        }\r\n        if (fromBalancePath.category == Types.BalanceCategory.CollateralAccount) {\r\n            Events.logDecreaseCollateral(msg.sender, fromBalancePath.marketID, asset, amount);\r\n        }\r\n    }\r\n\r\n    function borrow(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n    {\r\n        (\r\n            uint16 marketID,\r\n            address asset,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                uint16,\r\n                address,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireMarketBorrowEnabled(state, marketID);\r\n        Requires.requireMarketIDAndAssetMatch(state, marketID, asset);\r\n        Requires.requireAccountNormal(state, marketID, msg.sender);\r\n        LendingPool.borrow(\r\n            state,\r\n            msg.sender,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function repay(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n    {\r\n        (\r\n            uint16 marketID,\r\n            address asset,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                uint16,\r\n                address,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireMarketIDAndAssetMatch(state, marketID, asset);\r\n\r\n        LendingPool.repay(\r\n            state,\r\n            msg.sender,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function supply(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n    {\r\n        (\r\n            address asset,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                address,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        Requires.requireAssetExist(state, asset);\r\n        LendingPool.supply(\r\n            state,\r\n            asset,\r\n            amount,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function unsupply(\r\n        Store.State storage state,\r\n        Action memory action\r\n    )\r\n        private\r\n    {\r\n        (\r\n            address asset,\r\n            uint256 amount\r\n        ) = abi.decode(\r\n            action.encodedParams,\r\n            (\r\n                address,\r\n                uint256\r\n            )\r\n        );\r\n\r\n        Requires.requireAssetExist(state, asset);\r\n        LendingPool.unsupply(\r\n            state,\r\n            asset,\r\n            amount,\r\n            msg.sender\r\n        );\r\n    }\r\n}\r\n\r\nlibrary CollateralAccounts {\r\n    using SafeMath for uint256;\r\n\r\n    function getDetails(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n        returns (Types.CollateralAccountDetails memory details)\r\n    {\r\n        Types.CollateralAccount storage account = state.accounts[user][marketID];\r\n        Types.Market storage market = state.markets[marketID];\r\n\r\n        details.status = account.status;\r\n\r\n        address baseAsset = market.baseAsset;\r\n        address quoteAsset = market.quoteAsset;\r\n\r\n        uint256 baseUSDPrice = AssemblyCall.getAssetPriceFromPriceOracle(\r\n            address(state.assets[baseAsset].priceOracle),\r\n            baseAsset\r\n        );\r\n        uint256 quoteUSDPrice = AssemblyCall.getAssetPriceFromPriceOracle(\r\n            address(state.assets[quoteAsset].priceOracle),\r\n            quoteAsset\r\n        );\r\n\r\n        uint256 baseBorrowOf = LendingPool.getAmountBorrowed(state, baseAsset, user, marketID);\r\n        uint256 quoteBorrowOf = LendingPool.getAmountBorrowed(state, quoteAsset, user, marketID);\r\n\r\n        details.debtsTotalUSDValue = SafeMath.add(\r\n            baseBorrowOf.mul(baseUSDPrice),\r\n            quoteBorrowOf.mul(quoteUSDPrice)\r\n        ) / Decimal.one();\r\n\r\n        details.balancesTotalUSDValue = SafeMath.add(\r\n            account.balances[baseAsset].mul(baseUSDPrice),\r\n            account.balances[quoteAsset].mul(quoteUSDPrice)\r\n        ) / Decimal.one();\r\n\r\n        if (details.status == Types.CollateralAccountStatus.Normal) {\r\n            details.liquidatable = details.balancesTotalUSDValue < Decimal.mulCeil(details.debtsTotalUSDValue, market.liquidateRate);\r\n        } else {\r\n            details.liquidatable = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the amount that is avaliable to transfer out of the collateral account.\r\n     *\r\n     * If there are no open loans, this is just the total asset balance.\r\n     *\r\n     * If there are open loans, then this is the maximum amount that can be withdrawn\r\n     *   without falling below the withdraw collateral ratio\r\n     */\r\n    function getTransferableAmount(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address user,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Types.CollateralAccountDetails memory details = getDetails(state, user, marketID);\r\n\r\n        // already checked at batch operation\r\n        // liquidating or liquidatable account can't move asset\r\n\r\n        uint256 assetBalance = state.accounts[user][marketID].balances[asset];\r\n\r\n        // If and only if balance USD value is larger than transferableUSDValueBar, the user is able to withdraw some assets\r\n        uint256 transferableThresholdUSDValue = Decimal.mulCeil(\r\n            details.debtsTotalUSDValue,\r\n            state.markets[marketID].withdrawRate\r\n        );\r\n\r\n        if(transferableThresholdUSDValue > details.balancesTotalUSDValue) {\r\n            return 0;\r\n        } else {\r\n            uint256 transferableUSD = details.balancesTotalUSDValue - transferableThresholdUSDValue;\r\n            uint256 assetUSDPrice = state.assets[asset].priceOracle.getPrice(asset);\r\n            uint256 transferableAmount = Decimal.divFloor(transferableUSD, assetUSDPrice);\r\n            if (transferableAmount > assetBalance) {\r\n                return assetBalance;\r\n            } else {\r\n                return transferableAmount;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary LendingPool {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    uint256 private constant SECONDS_OF_YEAR = 31536000;\r\n\r\n    // create new pool\r\n    function initializeAssetLendingPool(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n    {\r\n        // indexes starts at 1 for easy computation\r\n        state.pool.borrowIndex[asset] = Decimal.one();\r\n        state.pool.supplyIndex[asset] = Decimal.one();\r\n\r\n        // record starting time for the pool\r\n        state.pool.indexStartTime[asset] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Supply asset into the pool. Supplied asset in the pool gains interest.\r\n     */\r\n    function supply(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount,\r\n        address user\r\n    )\r\n        internal\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // transfer asset from user's balance account\r\n        Transfer.transferOut(state, asset, BalancePath.getCommonPath(user), amount);\r\n\r\n        // compute the normalized value of 'amount'\r\n        // round floor\r\n        uint256 normalizedAmount = Decimal.divFloor(amount, state.pool.supplyIndex[asset]);\r\n\r\n        // mint normalizedAmount of pool token for user\r\n        state.assets[asset].lendingPoolToken.mint(user, normalizedAmount);\r\n\r\n        // update interest rate based on latest state\r\n        updateInterestRate(state, asset);\r\n\r\n        Events.logSupply(user, asset, amount);\r\n    }\r\n\r\n    /**\r\n     * unsupply asset from the pool, up to initial asset supplied plus interest\r\n     */\r\n    function unsupply(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount,\r\n        address user\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // compute the normalized value of 'amount'\r\n        // round ceiling\r\n        uint256 normalizedAmount = Decimal.divCeil(amount, state.pool.supplyIndex[asset]);\r\n\r\n        uint256 unsupplyAmount = amount;\r\n\r\n        // check and cap the amount so user can't overdraw\r\n        if (getNormalizedSupplyOf(state, asset, user) <= normalizedAmount) {\r\n            normalizedAmount = getNormalizedSupplyOf(state, asset, user);\r\n            unsupplyAmount = Decimal.mulFloor(normalizedAmount, state.pool.supplyIndex[asset]);\r\n        }\r\n\r\n        // transfer asset to user's balance account\r\n        Transfer.transferIn(state, asset, BalancePath.getCommonPath(user), unsupplyAmount);\r\n        Requires.requireCashLessThanOrEqualContractBalance(state, asset);\r\n\r\n        // subtract normalizedAmount from the pool\r\n        state.assets[asset].lendingPoolToken.burn(user, normalizedAmount);\r\n\r\n        // update interest rate based on latest state\r\n        updateInterestRate(state, asset);\r\n\r\n        Events.logUnsupply(user, asset, unsupplyAmount);\r\n\r\n        return unsupplyAmount;\r\n    }\r\n\r\n    /**\r\n     * Borrow money from the lending pool.\r\n     */\r\n    function borrow(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // compute the normalized value of 'amount'\r\n        uint256 normalizedAmount = Decimal.divCeil(amount, state.pool.borrowIndex[asset]);\r\n\r\n        // transfer assets to user's balance account\r\n        Transfer.transferIn(state, asset, BalancePath.getMarketPath(user, marketID), amount);\r\n        Requires.requireCashLessThanOrEqualContractBalance(state, asset);\r\n\r\n        // update normalized amount borrowed by user\r\n        state.pool.normalizedBorrow[user][marketID][asset] = state.pool.normalizedBorrow[user][marketID][asset].add(normalizedAmount);\r\n\r\n        // update normalized amount borrowed from the pool\r\n        state.pool.normalizedTotalBorrow[asset] = state.pool.normalizedTotalBorrow[asset].add(normalizedAmount);\r\n\r\n        // update interest rate based on latest state\r\n        updateInterestRate(state, asset);\r\n\r\n        Requires.requireCollateralAccountNotLiquidatable(state, user, marketID);\r\n\r\n        Events.logBorrow(user, marketID, asset, amount);\r\n    }\r\n\r\n    /**\r\n     * repay money borrowed money from the pool.\r\n     */\r\n    function repay(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // get normalized value of amount to be repaid, which in effect take into account interest\r\n        // (ex: if you borrowed 10, with index at 1.1, amount repaid needs to be 11 to make 11/1.1 = 10)\r\n        uint256 normalizedAmount = Decimal.divFloor(amount, state.pool.borrowIndex[asset]);\r\n\r\n        uint256 repayAmount = amount;\r\n\r\n        // make sure user cannot repay more than amount owed\r\n        if (state.pool.normalizedBorrow[user][marketID][asset] <= normalizedAmount) {\r\n            normalizedAmount = state.pool.normalizedBorrow[user][marketID][asset];\r\n            // repayAmount <= amount\r\n            // because ⌈⌊a/b⌋*b⌉ <= a\r\n            repayAmount = Decimal.mulCeil(normalizedAmount, state.pool.borrowIndex[asset]);\r\n        }\r\n\r\n        // transfer assets from user's balance account\r\n        Transfer.transferOut(state, asset, BalancePath.getMarketPath(user, marketID), repayAmount);\r\n\r\n        // update amount(normalized) borrowed by user\r\n        state.pool.normalizedBorrow[user][marketID][asset] = state.pool.normalizedBorrow[user][marketID][asset].sub(normalizedAmount);\r\n\r\n        // update total amount(normalized) borrowed from pool\r\n        state.pool.normalizedTotalBorrow[asset] = state.pool.normalizedTotalBorrow[asset].sub(normalizedAmount);\r\n\r\n        // update interest rate\r\n        updateInterestRate(state, asset);\r\n\r\n        Events.logRepay(user, marketID, asset, repayAmount);\r\n\r\n        return repayAmount;\r\n    }\r\n\r\n    /**\r\n     * This method is called if a loan could not be paid back by the borrower, auction, or insurance,\r\n     * in which case the generalized loss is recognized across all lenders.\r\n     */\r\n    function recognizeLoss(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        uint256 totalnormalizedSupply = getTotalNormalizedSupply(\r\n            state,\r\n            asset\r\n        );\r\n\r\n        uint256 actualSupply = getTotalSupply(\r\n            state,\r\n            asset\r\n        ).sub(amount);\r\n\r\n        state.pool.supplyIndex[asset] = Decimal.divFloor(\r\n            actualSupply,\r\n            totalnormalizedSupply\r\n        );\r\n\r\n        updateIndex(state, asset);\r\n\r\n        Events.logLoss(asset, amount);\r\n    }\r\n\r\n    /**\r\n     * Claim an amount from the insurance pool, in return for all the collateral.\r\n     * Only called if an auction expired without being filled.\r\n     */\r\n    function claimInsurance(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        uint256 insuranceBalance = state.pool.insuranceBalances[asset];\r\n\r\n        uint256 compensationAmount = SafeMath.min(amount, insuranceBalance);\r\n\r\n        state.cash[asset] = state.cash[asset].add(amount);\r\n\r\n        // remove compensationAmount from insurance balances\r\n        state.pool.insuranceBalances[asset] = SafeMath.sub(\r\n            state.pool.insuranceBalances[asset],\r\n            compensationAmount\r\n        );\r\n\r\n        // all suppliers pay debt if insurance not enough\r\n        if (compensationAmount < amount) {\r\n            recognizeLoss(\r\n                state,\r\n                asset,\r\n                amount.sub(compensationAmount)\r\n            );\r\n        }\r\n\r\n        Events.logInsuranceCompensation(\r\n            asset,\r\n            compensationAmount\r\n        );\r\n\r\n    }\r\n\r\n    function updateInterestRate(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n    {\r\n        (uint256 borrowInterestRate, uint256 supplyInterestRate) = getInterestRates(state, asset, 0);\r\n        state.pool.borrowAnnualInterestRate[asset] = borrowInterestRate;\r\n        state.pool.supplyAnnualInterestRate[asset] = supplyInterestRate;\r\n    }\r\n\r\n    // get interestRate\r\n    function getInterestRates(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 extraBorrowAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 borrowInterestRate, uint256 supplyInterestRate)\r\n    {\r\n        (uint256 currentSupplyIndex, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n\r\n        uint256 _supply = getTotalSupplyWithIndex(state, asset, currentSupplyIndex);\r\n\r\n        if (_supply == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint256 _borrow = getTotalBorrowWithIndex(state, asset, currentBorrowIndex).add(extraBorrowAmount);\r\n\r\n        uint256 borrowRatio = _borrow.mul(Decimal.one()).div(_supply);\r\n\r\n        borrowInterestRate = AssemblyCall.getBorrowInterestRate(\r\n            address(state.assets[asset].interestModel),\r\n            borrowRatio\r\n        );\r\n        require(borrowInterestRate <= 3 * Decimal.one(), \"BORROW_INTEREST_RATE_EXCEED_300%\");\r\n\r\n        uint256 borrowInterest = Decimal.mulCeil(_borrow, borrowInterestRate);\r\n        uint256 supplyInterest = Decimal.mulFloor(borrowInterest, Decimal.one().sub(state.pool.insuranceRatio));\r\n\r\n        supplyInterestRate = Decimal.divFloor(supplyInterest, _supply);\r\n    }\r\n\r\n    /**\r\n     * update the index value\r\n     */\r\n    function updateIndex(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n    {\r\n        if (state.pool.indexStartTime[asset] == block.timestamp) {\r\n            return;\r\n        }\r\n\r\n        (uint256 currentSupplyIndex, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n\r\n        // get the total equity value\r\n        uint256 normalizedBorrow = state.pool.normalizedTotalBorrow[asset];\r\n        uint256 normalizedSupply = getTotalNormalizedSupply(state, asset);\r\n\r\n        // interest = equity value * (current index value - starting index value)\r\n        uint256 recentBorrowInterest = Decimal.mulCeil(\r\n            normalizedBorrow,\r\n            currentBorrowIndex.sub(state.pool.borrowIndex[asset])\r\n        );\r\n\r\n        uint256 recentSupplyInterest = Decimal.mulFloor(\r\n            normalizedSupply,\r\n            currentSupplyIndex.sub(state.pool.supplyIndex[asset])\r\n        );\r\n\r\n        // the interest rate spread goes into the insurance pool\r\n        state.pool.insuranceBalances[asset] = state.pool.insuranceBalances[asset].add(recentBorrowInterest.sub(recentSupplyInterest));\r\n\r\n        // update the indexes\r\n        Events.logUpdateIndex(\r\n            asset,\r\n            state.pool.borrowIndex[asset],\r\n            currentBorrowIndex,\r\n            state.pool.supplyIndex[asset],\r\n            currentSupplyIndex\r\n        );\r\n\r\n        state.pool.supplyIndex[asset] = currentSupplyIndex;\r\n        state.pool.borrowIndex[asset] = currentBorrowIndex;\r\n        state.pool.indexStartTime[asset] = block.timestamp;\r\n\r\n    }\r\n\r\n    function getAmountSupplied(\r\n        Store.State storage state,\r\n        address asset,\r\n        address user\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 currentSupplyIndex, ) = getCurrentIndex(state, asset);\r\n        return Decimal.mulFloor(getNormalizedSupplyOf(state, asset, user), currentSupplyIndex);\r\n    }\r\n\r\n    function getAmountBorrowed(\r\n        Store.State storage state,\r\n        address asset,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // the actual amount borrowed = normalizedAmount * poolIndex\r\n        (, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n        return Decimal.mulCeil(state.pool.normalizedBorrow[user][marketID][asset], currentBorrowIndex);\r\n    }\r\n\r\n    function getTotalSupply(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 currentSupplyIndex, ) = getCurrentIndex(state, asset);\r\n        return getTotalSupplyWithIndex(state, asset, currentSupplyIndex);\r\n    }\r\n\r\n    function getTotalBorrow(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n        return getTotalBorrowWithIndex(state, asset, currentBorrowIndex);\r\n    }\r\n\r\n    function getTotalSupplyWithIndex(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 currentSupplyIndex\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return Decimal.mulFloor(getTotalNormalizedSupply(state, asset), currentSupplyIndex);\r\n    }\r\n\r\n    function getTotalBorrowWithIndex(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 currentBorrowIndex\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return Decimal.mulCeil(state.pool.normalizedTotalBorrow[asset], currentBorrowIndex);\r\n    }\r\n\r\n    /**\r\n     * Compute the current value of poolIndex based on the time elapsed and the interest rate\r\n     */\r\n    function getCurrentIndex(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 currentSupplyIndex, uint256 currentBorrowIndex)\r\n    {\r\n        uint256 timeDelta = block.timestamp.sub(state.pool.indexStartTime[asset]);\r\n\r\n        uint256 borrowInterestRate = state.pool.borrowAnnualInterestRate[asset]\r\n            .mul(timeDelta).divCeil(SECONDS_OF_YEAR); // Ceil Ensure asset greater than liability\r\n\r\n        uint256 supplyInterestRate = state.pool.supplyAnnualInterestRate[asset]\r\n            .mul(timeDelta).div(SECONDS_OF_YEAR);\r\n\r\n        currentBorrowIndex = Decimal.mulCeil(state.pool.borrowIndex[asset], Decimal.onePlus(borrowInterestRate));\r\n        currentSupplyIndex = Decimal.mulFloor(state.pool.supplyIndex[asset], Decimal.onePlus(supplyInterestRate));\r\n\r\n        return (currentSupplyIndex, currentBorrowIndex);\r\n    }\r\n\r\n    function getNormalizedSupplyOf(\r\n        Store.State storage state,\r\n        address asset,\r\n        address user\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return state.assets[asset].lendingPoolToken.balanceOf(user);\r\n    }\r\n\r\n    function getTotalNormalizedSupply(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return state.assets[asset].lendingPoolToken.totalSupply();\r\n    }\r\n}\r\n\r\ncontract StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\r\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\r\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\r\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n\r\n        balances[from] = balances[from].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param spender The address which will spend the funds.\r\n    * @param amount The amount of tokens to be spent.\r\n    */\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[owner][spender];\r\n    }\r\n}\r\n\r\ninterface IInterestModel {\r\n    function polynomialInterestModel(\r\n        uint256 borrowRatio\r\n    )\r\n        external\r\n        pure\r\n        returns(uint256);\r\n}\r\n\r\ninterface ILendingPoolToken {\r\n    function mint(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function burn(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function balanceOf(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IPriceOracle {\r\n    /** return USD price of token */\r\n    function getPrice(\r\n        address asset\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IStandardToken {\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\nlibrary AssemblyCall {\r\n    function getAssetPriceFromPriceOracle(\r\n        address oracleAddress,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // saves about 1200 gas.\r\n        // return state.assets[asset].priceOracle.getPrice(asset);\r\n\r\n        // keccak256('getPrice(address)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n        bytes32 functionSelector = 0x41976e0900000000000000000000000000000000000000000000000000000000;\r\n\r\n        (uint256 result, bool success) = callWith32BytesReturnsUint256(\r\n            oracleAddress,\r\n            functionSelector,\r\n            bytes32(uint256(uint160(asset)))\r\n        );\r\n\r\n        if (!success) {\r\n            revert(\"ASSEMBLY_CALL_GET_ASSET_PRICE_FAILED\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the HOT token balance of an address.\r\n     *\r\n     * @param owner The address to check.\r\n     * @return The HOT balance for the owner address.\r\n     */\r\n    function getHotBalance(\r\n        address hotToken,\r\n        address owner\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // saves about 1200 gas.\r\n        // return HydroToken(hotToken).balanceOf(owner);\r\n\r\n        // keccak256('balanceOf(address)') bitmasked to 4 bytes\r\n        bytes32 functionSelector = 0x70a0823100000000000000000000000000000000000000000000000000000000;\r\n\r\n        (uint256 result, bool success) = callWith32BytesReturnsUint256(\r\n            hotToken,\r\n            functionSelector,\r\n            bytes32(uint256(uint160(owner)))\r\n        );\r\n\r\n        if (!success) {\r\n            revert(\"ASSEMBLY_CALL_GET_HOT_BALANCE_FAILED\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getBorrowInterestRate(\r\n        address interestModel,\r\n        uint256 borrowRatio\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // saves about 1200 gas.\r\n        // return IInterestModel(interestModel).polynomialInterestModel(borrowRatio);\r\n\r\n        // keccak256('polynomialInterestModel(uint256)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n        bytes32 functionSelector = 0x69e8a15f00000000000000000000000000000000000000000000000000000000;\r\n\r\n        (uint256 result, bool success) = callWith32BytesReturnsUint256(\r\n            interestModel,\r\n            functionSelector,\r\n            bytes32(borrowRatio)\r\n        );\r\n\r\n        if (!success) {\r\n            revert(\"ASSEMBLY_CALL_GET_BORROW_INTEREST_RATE_FAILED\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function callWith32BytesReturnsUint256(\r\n        address to,\r\n        bytes32 functionSelector,\r\n        bytes32 param1\r\n    )\r\n        private\r\n        view\r\n        returns (uint256 result, bool success)\r\n    {\r\n        assembly {\r\n            let freePtr := mload(0x40)\r\n            let tmp1 := mload(freePtr)\r\n            let tmp2 := mload(add(freePtr, 4))\r\n\r\n            mstore(freePtr, functionSelector)\r\n            mstore(add(freePtr, 4), param1)\r\n\r\n            // call ERC20 Token contract transfer function\r\n            success := staticcall(\r\n                gas,           // Forward all gas\r\n                to,            // Interest Model Address\r\n                freePtr,       // Pointer to start of calldata\r\n                36,            // Length of calldata\r\n                freePtr,       // Overwrite calldata with output\r\n                32             // Expecting uint256 output\r\n            )\r\n\r\n            result := mload(freePtr)\r\n\r\n            mstore(freePtr, tmp1)\r\n            mstore(add(freePtr, 4), tmp2)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Consts {\r\n    function ETHEREUM_TOKEN_ADDRESS()\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return 0x000000000000000000000000000000000000000E;\r\n    }\r\n\r\n    // The base discounted rate is 100% of the current rate, or no discount.\r\n    function DISCOUNT_RATE_BASE()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 100;\r\n    }\r\n\r\n    function REBATE_RATE_BASE()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 100;\r\n    }\r\n}\r\n\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant BASE = 10**18;\r\n\r\n    function one()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return BASE;\r\n    }\r\n\r\n    function onePlus(\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return d.add(BASE);\r\n    }\r\n\r\n    function mulFloor(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(d) / BASE;\r\n    }\r\n\r\n    function mulCeil(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(d).divCeil(BASE);\r\n    }\r\n\r\n    function divFloor(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(BASE).div(d);\r\n    }\r\n\r\n    function divCeil(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(BASE).divCeil(d);\r\n    }\r\n}\r\n\r\nlibrary EIP712 {\r\n    string private constant DOMAIN_NAME = \"Hydro Protocol\";\r\n\r\n    /**\r\n     * Hash of the EIP712 Domain Separator Schema\r\n     */\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        abi.encodePacked(\"EIP712Domain(string name)\")\r\n    );\r\n\r\n    bytes32 private constant DOMAIN_SEPARATOR = keccak256(\r\n        abi.encodePacked(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            keccak256(bytes(DOMAIN_NAME))\r\n        )\r\n    );\r\n\r\n    /**\r\n     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\r\n     *\r\n     * @param eip712hash The EIP712 hash struct.\r\n     * @return EIP712 hash applied to this EIP712 Domain.\r\n     */\r\n    function hashMessage(\r\n        bytes32 eip712hash\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\r\n    }\r\n}\r\n\r\nlibrary Events {\r\n    //////////////////\r\n    // Funds moving //\r\n    //////////////////\r\n\r\n    // some assets move into contract\r\n    event Deposit(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logDeposit(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Deposit(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // some assets move out of contract\r\n    event Withdraw(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logWithdraw(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Withdraw(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // transfer from balance to collateral account\r\n    event IncreaseCollateral (\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logIncreaseCollateral(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit IncreaseCollateral(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // transfer from collateral account to balance\r\n    event DecreaseCollateral (\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logDecreaseCollateral(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit DecreaseCollateral(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    //////////////////\r\n    // Lending Pool //\r\n    //////////////////\r\n\r\n    event UpdateIndex(\r\n        address indexed asset,\r\n        uint256 oldBorrowIndex,\r\n        uint256 newBorrowIndex,\r\n        uint256 oldSupplyIndex,\r\n        uint256 newSupplyIndex\r\n    );\r\n\r\n    function logUpdateIndex(\r\n        address asset,\r\n        uint256 oldBorrowIndex,\r\n        uint256 newBorrowIndex,\r\n        uint256 oldSupplyIndex,\r\n        uint256 newSupplyIndex\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateIndex(\r\n            asset,\r\n            oldBorrowIndex,\r\n            newBorrowIndex,\r\n            oldSupplyIndex,\r\n            newSupplyIndex\r\n        );\r\n    }\r\n\r\n    event Borrow(\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logBorrow(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Borrow(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Repay(\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logRepay(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Repay(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Supply(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logSupply(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Supply(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Unsupply(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logUnsupply(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Unsupply(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Loss(\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logLoss(\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Loss(\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event InsuranceCompensation(\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logInsuranceCompensation(\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit InsuranceCompensation(\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // Admin Actions //\r\n    ///////////////////\r\n\r\n    event CreateMarket(Types.Market market);\r\n\r\n    function logCreateMarket(\r\n        Types.Market memory market\r\n    )\r\n        internal\r\n    {\r\n        emit CreateMarket(market);\r\n    }\r\n\r\n    event UpdateMarket(\r\n        uint16 indexed marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    );\r\n\r\n    function logUpdateMarket(\r\n        uint16 marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateMarket(\r\n            marketID,\r\n            newAuctionRatioStart,\r\n            newAuctionRatioPerBlock,\r\n            newLiquidateRate,\r\n            newWithdrawRate\r\n        );\r\n    }\r\n\r\n    event MarketBorrowDisable(\r\n        uint16 indexed marketID\r\n    );\r\n\r\n    function logMarketBorrowDisable(\r\n        uint16 marketID\r\n    )\r\n        internal\r\n    {\r\n        emit MarketBorrowDisable(\r\n            marketID\r\n        );\r\n    }\r\n\r\n    event MarketBorrowEnable(\r\n        uint16 indexed marketID\r\n    );\r\n\r\n    function logMarketBorrowEnable(\r\n        uint16 marketID\r\n    )\r\n        internal\r\n    {\r\n        emit MarketBorrowEnable(\r\n            marketID\r\n        );\r\n    }\r\n\r\n    event UpdateDiscountConfig(bytes32 newConfig);\r\n\r\n    function logUpdateDiscountConfig(\r\n        bytes32 newConfig\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateDiscountConfig(newConfig);\r\n    }\r\n\r\n    event CreateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address poolTokenAddress,\r\n        address interestModelAddress\r\n    );\r\n\r\n    function logCreateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address poolTokenAddress,\r\n        address interestModelAddress\r\n    )\r\n        internal\r\n    {\r\n        emit CreateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            poolTokenAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    event UpdateAsset(\r\n        address indexed asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    );\r\n\r\n    function logUpdateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    event UpdateAuctionInitiatorRewardRatio(\r\n        uint256 newInitiatorRewardRatio\r\n    );\r\n\r\n    function logUpdateAuctionInitiatorRewardRatio(\r\n        uint256 newInitiatorRewardRatio\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateAuctionInitiatorRewardRatio(\r\n            newInitiatorRewardRatio\r\n        );\r\n    }\r\n\r\n    event UpdateInsuranceRatio(\r\n        uint256 newInsuranceRatio\r\n    );\r\n\r\n    function logUpdateInsuranceRatio(\r\n        uint256 newInsuranceRatio\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateInsuranceRatio(newInsuranceRatio);\r\n    }\r\n\r\n    /////////////\r\n    // Auction //\r\n    /////////////\r\n\r\n    event Liquidate(\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        bool indexed hasAuction\r\n    );\r\n\r\n    function logLiquidate(\r\n        address user,\r\n        uint16 marketID,\r\n        bool hasAuction\r\n    )\r\n        internal\r\n    {\r\n        emit Liquidate(\r\n            user,\r\n            marketID,\r\n            hasAuction\r\n        );\r\n    }\r\n\r\n    // an auction is created\r\n    event AuctionCreate(\r\n        uint256 auctionID\r\n    );\r\n\r\n    function logAuctionCreate(\r\n        uint256 auctionID\r\n    )\r\n        internal\r\n    {\r\n        emit AuctionCreate(auctionID);\r\n    }\r\n\r\n    // a user filled an acution\r\n    event FillAuction(\r\n        uint256 indexed auctionID,\r\n        address bidder,\r\n        uint256 repayDebt,\r\n        uint256 bidderRepayDebt,\r\n        uint256 bidderCollateral,\r\n        uint256 leftDebt\r\n    );\r\n\r\n    function logFillAuction(\r\n        uint256 auctionID,\r\n        address bidder,\r\n        uint256 repayDebt,\r\n        uint256 bidderRepayDebt,\r\n        uint256 bidderCollateral,\r\n        uint256 leftDebt\r\n    )\r\n        internal\r\n    {\r\n        emit FillAuction(\r\n            auctionID,\r\n            bidder,\r\n            repayDebt,\r\n            bidderRepayDebt,\r\n            bidderCollateral,\r\n            leftDebt\r\n        );\r\n    }\r\n\r\n    /////////////\r\n    // Relayer //\r\n    /////////////\r\n\r\n    event RelayerApproveDelegate(\r\n        address indexed relayer,\r\n        address indexed delegate\r\n    );\r\n\r\n    function logRelayerApproveDelegate(\r\n        address relayer,\r\n        address delegate\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerApproveDelegate(\r\n            relayer,\r\n            delegate\r\n        );\r\n    }\r\n\r\n    event RelayerRevokeDelegate(\r\n        address indexed relayer,\r\n        address indexed delegate\r\n    );\r\n\r\n    function logRelayerRevokeDelegate(\r\n        address relayer,\r\n        address delegate\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerRevokeDelegate(\r\n            relayer,\r\n            delegate\r\n        );\r\n    }\r\n\r\n    event RelayerExit(\r\n        address indexed relayer\r\n    );\r\n\r\n    function logRelayerExit(\r\n        address relayer\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerExit(relayer);\r\n    }\r\n\r\n    event RelayerJoin(\r\n        address indexed relayer\r\n    );\r\n\r\n    function logRelayerJoin(\r\n        address relayer\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerJoin(relayer);\r\n    }\r\n\r\n    //////////////\r\n    // Exchange //\r\n    //////////////\r\n\r\n    event Match(\r\n        Types.OrderAddressSet addressSet,\r\n        address maker,\r\n        address taker,\r\n        address buyer,\r\n        uint256 makerFee,\r\n        uint256 makerRebate,\r\n        uint256 takerFee,\r\n        uint256 makerGasFee,\r\n        uint256 takerGasFee,\r\n        uint256 baseAssetFilledAmount,\r\n        uint256 quoteAssetFilledAmount\r\n\r\n    );\r\n\r\n    function logMatch(\r\n        Types.MatchResult memory result,\r\n        Types.OrderAddressSet memory addressSet\r\n    )\r\n        internal\r\n    {\r\n        emit Match(\r\n            addressSet,\r\n            result.maker,\r\n            result.taker,\r\n            result.buyer,\r\n            result.makerFee,\r\n            result.makerRebate,\r\n            result.takerFee,\r\n            result.makerGasFee,\r\n            result.takerGasFee,\r\n            result.baseAssetFilledAmount,\r\n            result.quoteAssetFilledAmount\r\n        );\r\n    }\r\n\r\n    event OrderCancel(\r\n        bytes32 indexed orderHash\r\n    );\r\n\r\n    function logOrderCancel(\r\n        bytes32 orderHash\r\n    )\r\n        internal\r\n    {\r\n        emit OrderCancel(orderHash);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /** @dev The Ownable constructor sets the original `owner` of the contract to the sender account. */\r\n    constructor()\r\n        internal\r\n    {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /** @return the address of the owner. */\r\n    function owner()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    /** @dev Throws if called by any account other than the owner. */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /** @return true if `msg.sender` is the owner of the contract. */\r\n    function isOwner()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /** @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /** @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(\r\n        address newOwner\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"INVALID_OWNER\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Operations is Ownable, GlobalStore {\r\n\r\n    function createMarket(\r\n        Types.Market memory market\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.createMarket(state, market);\r\n    }\r\n\r\n    function updateMarket(\r\n        uint16 marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.updateMarket(\r\n            state,\r\n            marketID,\r\n            newAuctionRatioStart,\r\n            newAuctionRatioPerBlock,\r\n            newLiquidateRate,\r\n            newWithdrawRate\r\n        );\r\n    }\r\n\r\n    function setMarketBorrowUsability(\r\n        uint16 marketID,\r\n        bool   usability\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.setMarketBorrowUsability(\r\n            state,\r\n            marketID,\r\n            usability\r\n        );\r\n    }\r\n\r\n    function createAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress,\r\n        string calldata poolTokenName,\r\n        string calldata poolTokenSymbol,\r\n        uint8 poolTokenDecimals\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.createAsset(\r\n            state,\r\n            asset,\r\n            oracleAddress,\r\n            interestModelAddress,\r\n            poolTokenName,\r\n            poolTokenSymbol,\r\n            poolTokenDecimals\r\n        );\r\n    }\r\n\r\n    function updateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.updateAsset(\r\n            state,\r\n            asset,\r\n            oracleAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param newConfig A data blob representing the new discount config. Details on format above.\r\n     */\r\n    function updateDiscountConfig(\r\n        bytes32 newConfig\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.updateDiscountConfig(\r\n            state,\r\n            newConfig\r\n        );\r\n    }\r\n\r\n    function updateAuctionInitiatorRewardRatio(\r\n        uint256 newInitiatorRewardRatio\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.updateAuctionInitiatorRewardRatio(\r\n            state,\r\n            newInitiatorRewardRatio\r\n        );\r\n    }\r\n\r\n    function updateInsuranceRatio(\r\n        uint256 newInsuranceRatio\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        OperationsComponent.updateInsuranceRatio(\r\n            state,\r\n            newInsuranceRatio\r\n        );\r\n    }\r\n}\r\n\r\ncontract Hydro is GlobalStore, ExternalFunctions, Operations {\r\n    constructor(\r\n        address _hotTokenAddress\r\n    )\r\n        public\r\n    {\r\n        state.exchange.hotTokenAddress = _hotTokenAddress;\r\n        state.exchange.discountConfig = 0x043c000027106400004e205a000075305000009c404600000000000000000000;\r\n    }\r\n}\r\n\r\ncontract LendingPoolToken is StandardToken, Ownable {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    event Mint(address indexed user, uint256 value);\r\n    event Burn(address indexed user, uint256 value);\r\n\r\n    constructor (\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        uint8 tokenDecimals\r\n    )\r\n        public\r\n    {\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = tokenDecimals;\r\n    }\r\n\r\n    function mint(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        balances[user] = balances[user].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n        emit Mint(user, value);\r\n    }\r\n\r\n    function burn(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        balances[user] = balances[user].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(user, value);\r\n    }\r\n\r\n}\r\n\r\nlibrary Requires {\r\n    function requireAssetExist(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(isAssetExist(state, asset), \"ASSET_NOT_EXIST\");\r\n    }\r\n\r\n    function requireAssetNotExist(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(!isAssetExist(state, asset), \"ASSET_ALREADY_EXIST\");\r\n    }\r\n\r\n    function requireMarketIDAndAssetMatch(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            asset == state.markets[marketID].baseAsset || asset == state.markets[marketID].quoteAsset,\r\n            \"ASSET_NOT_BELONGS_TO_MARKET\"\r\n        );\r\n    }\r\n\r\n    function requireMarketNotExist(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(!isMarketExist(state, market), \"MARKET_ALREADY_EXIST\");\r\n    }\r\n\r\n    function requireMarketAssetsValid(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(market.baseAsset != market.quoteAsset, \"BASE_QUOTE_DUPLICATED\");\r\n        require(isAssetExist(state, market.baseAsset), \"MARKET_BASE_ASSET_NOT_EXIST\");\r\n        require(isAssetExist(state, market.quoteAsset), \"MARKET_QUOTE_ASSET_NOT_EXIST\");\r\n    }\r\n\r\n    function requireCashLessThanOrEqualContractBalance(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            if (state.cash[asset] > 0) {\r\n                require(uint256(state.cash[asset]) <= address(this).balance, \"CONTRACT_BALANCE_NOT_ENOUGH\");\r\n            }\r\n        } else {\r\n            if (state.cash[asset] > 0) {\r\n                require(uint256(state.cash[asset]) <= IStandardToken(asset).balanceOf(address(this)), \"CONTRACT_BALANCE_NOT_ENOUGH\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function requirePriceOracleAddressValid(\r\n        address oracleAddress\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(oracleAddress != address(0), \"ORACLE_ADDRESS_NOT_VALID\");\r\n    }\r\n\r\n    function requireDecimalLessOrEquanThanOne(\r\n        uint256 decimal\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(decimal <= Decimal.one(), \"DECIMAL_GREATER_THAN_ONE\");\r\n    }\r\n\r\n    function requireDecimalGreaterThanOne(\r\n        uint256 decimal\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(decimal > Decimal.one(), \"DECIMAL_LESS_OR_EQUAL_THAN_ONE\");\r\n    }\r\n\r\n    function requireMarketIDExist(\r\n        Store.State storage state,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(marketID < state.marketsCount, \"MARKET_NOT_EXIST\");\r\n    }\r\n\r\n    function requireMarketBorrowEnabled(\r\n        Store.State storage state,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(state.markets[marketID].borrowEnable, \"MARKET_BORROW_DISABLED\");\r\n    }\r\n\r\n    function requirePathNormalStatus(\r\n        Store.State storage state,\r\n        Types.BalancePath memory path\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (path.category == Types.BalanceCategory.CollateralAccount) {\r\n            requireAccountNormal(state, path.marketID, path.user);\r\n        }\r\n    }\r\n\r\n    function requireAccountNormal(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address user\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            state.accounts[user][marketID].status == Types.CollateralAccountStatus.Normal,\r\n            \"CAN_NOT_OPERATE_LIQUIDATING_COLLATERAL_ACCOUNT\"\r\n        );\r\n    }\r\n\r\n    function requirePathMarketIDAssetMatch(\r\n        Store.State storage state,\r\n        Types.BalancePath memory path,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (path.category == Types.BalanceCategory.CollateralAccount) {\r\n            requireMarketIDExist(state, path.marketID);\r\n            requireMarketIDAndAssetMatch(state, path.marketID, asset);\r\n        }\r\n    }\r\n\r\n    function requireCollateralAccountNotLiquidatable(\r\n        Store.State storage state,\r\n        Types.BalancePath memory path\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (path.category == Types.BalanceCategory.CollateralAccount) {\r\n            requireCollateralAccountNotLiquidatable(state, path.user, path.marketID);\r\n        }\r\n    }\r\n\r\n    function requireCollateralAccountNotLiquidatable(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            !CollateralAccounts.getDetails(state, user, marketID).liquidatable,\r\n            \"COLLATERAL_ACCOUNT_LIQUIDATABLE\"\r\n        );\r\n    }\r\n\r\n    function requireAuctionNotFinished(\r\n        Store.State storage state,\r\n        uint32 auctionID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            state.auction.auctions[auctionID].status == Types.AuctionStatus.InProgress,\r\n            \"AUCTION_ALREADY_FINISHED\"\r\n        );\r\n    }\r\n\r\n    function requireAuctionExist(\r\n        Store.State storage state,\r\n        uint32 auctionID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            auctionID < state.auction.auctionsCount,\r\n            \"AUCTION_NOT_EXIST\"\r\n        );\r\n    }\r\n\r\n    function isAssetExist(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.assets[asset].priceOracle != IPriceOracle(address(0));\r\n    }\r\n\r\n    function isMarketExist(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        for(uint16 i = 0; i < state.marketsCount; i++) {\r\n            if (state.markets[i].baseAsset == market.baseAsset && state.markets[i].quoteAsset == market.quoteAsset) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        bool result;\r\n\r\n        assembly {\r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n\r\n            // keccak256('transfer(address,uint256)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, to)\r\n            mstore(36, amount)\r\n\r\n            // call ERC20 Token contract transfer function\r\n            let callResult := call(gas, token, 0, 0, 68, 0, 32)\r\n            let returnValue := mload(0)\r\n\r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n\r\n            // result check\r\n            result := and (\r\n                eq(callResult, 1),\r\n                or(eq(returndatasize, 0), and(eq(returndatasize, 32), gt(returnValue, 0)))\r\n            )\r\n        }\r\n\r\n        if (!result) {\r\n            revert(\"TOKEN_TRANSFER_ERROR\");\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        bool result;\r\n\r\n        assembly {\r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n            let tmp4 := mload(68)\r\n\r\n            // keccak256('transferFrom(address,address,uint256)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, from)\r\n            mstore(36, to)\r\n            mstore(68, amount)\r\n\r\n            // call ERC20 Token contract transferFrom function\r\n            let callResult := call(gas, token, 0, 0, 100, 0, 32)\r\n            let returnValue := mload(0)\r\n\r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n            mstore(68, tmp4)\r\n\r\n            // result check\r\n            result := and (\r\n                eq(callResult, 1),\r\n                or(eq(returndatasize, 0), and(eq(returndatasize, 32), gt(returnValue, 0)))\r\n            )\r\n        }\r\n\r\n        if (!result) {\r\n            revert(\"TOKEN_TRANSFER_FROM_ERROR\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    // Multiplies two numbers, reverts on overflow.\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    // Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    function div(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    // Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function sub(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b <= 2**255-1, \"INT256_SUB_ERROR\");\r\n        int256 c = a - int256(b);\r\n        require(c <= a, \"INT256_SUB_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    // Adds two numbers, reverts on overflow.\r\n    function add(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function add(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b <= 2**255 - 1, \"INT256_ADD_ERROR\");\r\n        int256 c = a + int256(b);\r\n        require(c >= a, \"INT256_ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    // Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, \"MOD_ERROR\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * Check the amount of precision lost by calculating multiple * (numerator / denominator). To\r\n     * do this, we check the remainder and make sure it's proportionally less than 0.1%. So we have:\r\n     *\r\n     *     ((numerator * multiple) % denominator)     1\r\n     *     -------------------------------------- < ----\r\n     *              numerator * multiple            1000\r\n     *\r\n     * To avoid further division, we can move the denominators to the other sides and we get:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 < numerator * multiple\r\n     *\r\n     * Since we want to return true if there IS a rounding error, we simply flip the sign and our\r\n     * final equation becomes:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 >= numerator * multiple\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return Boolean indicating if there is a rounding error when calculating the proportion\r\n     */\r\n    function isRoundingError(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple)\r\n        return mul(mod(mul(numerator, multiple), denominator), 1000) >= mul(numerator, multiple);\r\n    }\r\n\r\n    /**\r\n     * Takes an amount (multiple) and calculates a proportion of it given a numerator/denominator\r\n     * pair of values. The final value will be rounded down to the nearest integer value.\r\n     *\r\n     * This function will revert the transaction if rounding the final value down would lose more\r\n     * than 0.1% precision.\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return The final proportion of multiple rounded down\r\n     */\r\n    function getPartialAmountFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(!isRoundingError(numerator, denominator, multiple), \"ROUNDING_ERROR\");\r\n        // numerator.mul(multiple).div(denominator)\r\n        return div(mul(numerator, multiple), denominator);\r\n    }\r\n\r\n    /**\r\n     * Returns the smaller integer of the two passed in.\r\n     *\r\n     * @param a Unsigned integer\r\n     * @param b Unsigned integer\r\n     * @return The smaller of the two integers\r\n     */\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary Signature {\r\n\r\n    enum SignatureMethod {\r\n        EthSign,\r\n        EIP712\r\n    }\r\n\r\n    /**\r\n     * Validate a signature given a hash calculated from the order data, the signer, and the\r\n     * signature data passed in with the order.\r\n     *\r\n     * This function will revert the transaction if the signature method is invalid.\r\n     *\r\n     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\r\n     * @param signerAddress The address of the signer\r\n     * @param signature The signature data passed along with the order to validate against\r\n     * @return True if the calculated signature matches the order signature data, false otherwise.\r\n     */\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        Types.Signature memory signature\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint8 method = uint8(signature.config[1]);\r\n        address recovered;\r\n        uint8 v = uint8(signature.config[0]);\r\n\r\n        if (method == uint8(SignatureMethod.EthSign)) {\r\n            recovered = ecrecover(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                v,\r\n                signature.r,\r\n                signature.s\r\n            );\r\n        } else if (method == uint8(SignatureMethod.EIP712)) {\r\n            recovered = ecrecover(hash, v, signature.r, signature.s);\r\n        } else {\r\n            revert(\"INVALID_SIGN_METHOD\");\r\n        }\r\n\r\n        return signerAddress == recovered;\r\n    }\r\n}\r\n\r\nlibrary Store {\r\n\r\n    struct RelayerState {\r\n        /**\r\n        * Mapping of relayerAddress => delegateAddress\r\n        */\r\n        mapping (address => mapping (address => bool)) relayerDelegates;\r\n\r\n        /**\r\n        * Mapping of relayerAddress => whether relayer is opted out of the liquidity incentive system\r\n        */\r\n        mapping (address => bool) hasExited;\r\n    }\r\n\r\n    struct ExchangeState {\r\n\r\n        /**\r\n        * Calculate and return the rate at which fees will be charged for an address. The discounted\r\n        * rate depends on how much HOT token is owned by the user. Values returned will be a percentage\r\n        * used to calculate how much of the fee is paid, so a return value of 100 means there is 0\r\n        * discount, and a return value of 70 means a 30% rate reduction.\r\n        *\r\n        * The discountConfig is defined as such:\r\n        * ╔═══════════════════╤════════════════════════════════════════════╗\r\n        * ║                   │ length(bytes)   desc                       ║\r\n        * ╟───────────────────┼────────────────────────────────────────────╢\r\n        * ║ count             │ 1               the count of configs       ║\r\n        * ║ maxDiscountedRate │ 1               the max discounted rate    ║\r\n        * ║ config            │ 5 each                                     ║\r\n        * ╚═══════════════════╧════════════════════════════════════════════╝\r\n        *\r\n        * The default discount structure as defined in code would give the following result:\r\n        *\r\n        * Fee discount table\r\n        * ╔════════════════════╤══════════╗\r\n        * ║     HOT BALANCE    │ DISCOUNT ║\r\n        * ╠════════════════════╪══════════╣\r\n        * ║     0 <= x < 10000 │     0%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 10000 <= x < 20000 │    10%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 20000 <= x < 30000 │    20%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 30000 <= x < 40000 │    30%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 40000 <= x         │    40%   ║\r\n        * ╚════════════════════╧══════════╝\r\n        *\r\n        * Breaking down the bytes of 0x043c000027106400004e205a000075305000009c404600000000000000000000\r\n        *\r\n        * 0x  04           3c          0000271064  00004e205a  0000753050  00009c4046  0000000000  0000000000;\r\n        *     ~~           ~~          ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~\r\n        *      |            |               |           |           |           |           |           |\r\n        *    count  maxDiscountedRate       1           2           3           4           5           6\r\n        *\r\n        * The first config breaks down as follows:  00002710   64\r\n        *                                           ~~~~~~~~   ~~\r\n        *                                               |      |\r\n        *                                              bar    rate\r\n        *\r\n        * Meaning if a user has less than 10000 (0x00002710) HOT, they will pay 100%(0x64) of the\r\n        * standard fee.\r\n        *\r\n        */\r\n        bytes32 discountConfig;\r\n\r\n        /**\r\n        * Mapping of orderHash => amount\r\n        * Generally the amount will be specified in base token units, however in the case of a market\r\n        * buy order the amount is specified in quote token units.\r\n        */\r\n        mapping (bytes32 => uint256) filled;\r\n\r\n        /**\r\n        * Mapping of orderHash => whether order has been cancelled.\r\n        */\r\n        mapping (bytes32 => bool) cancelled;\r\n\r\n        address hotTokenAddress;\r\n    }\r\n\r\n    struct LendingPoolState {\r\n        uint256 insuranceRatio;\r\n\r\n        // insurance balances\r\n        mapping(address => uint256) insuranceBalances;\r\n\r\n        mapping (address => uint256) borrowIndex; // decimal\r\n        mapping (address => uint256) supplyIndex; // decimal\r\n        mapping (address => uint256) indexStartTime; // timestamp\r\n\r\n        mapping (address => uint256) borrowAnnualInterestRate; // decimal\r\n        mapping (address => uint256) supplyAnnualInterestRate; // decimal\r\n\r\n        // total borrow\r\n        mapping(address => uint256) normalizedTotalBorrow;\r\n\r\n        // user => marketID => balances\r\n        mapping (address => mapping (uint16 => mapping(address => uint256))) normalizedBorrow;\r\n    }\r\n\r\n    struct AuctionState {\r\n\r\n        // count of auctions\r\n        uint32 auctionsCount;\r\n\r\n        // all auctions\r\n        mapping(uint32 => Types.Auction) auctions;\r\n\r\n        // current auctions\r\n        uint32[] currentAuctions;\r\n\r\n        // auction initiator reward ratio\r\n        uint256 initiatorRewardRatio;\r\n    }\r\n\r\n    struct State {\r\n\r\n        uint16 marketsCount;\r\n\r\n        mapping(address => Types.Asset) assets;\r\n        mapping(address => int256) cash;\r\n\r\n        // user => marketID => account\r\n        mapping(address => mapping(uint16 => Types.CollateralAccount)) accounts;\r\n\r\n        // all markets\r\n        mapping(uint16 => Types.Market) markets;\r\n\r\n        // user balances\r\n        mapping(address => mapping(address => uint256)) balances;\r\n\r\n        LendingPoolState pool;\r\n\r\n        ExchangeState exchange;\r\n\r\n        RelayerState relayer;\r\n\r\n        AuctionState auction;\r\n    }\r\n}\r\n\r\nlibrary Transfer {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n    using BalancePath for Types.BalancePath;\r\n\r\n    // Transfer asset into current contract\r\n    function deposit(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 depositedEtherAmount = 0;\r\n\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            // Since this method is able to be called in batch,\r\n            // there is a chance that a batch contains multi deposit ether calls.\r\n            // To make sure the the msg.value is equal to the total deposit ethers,\r\n            // each ether deposit function needs to return the actual deposited ether amount.\r\n            depositedEtherAmount = amount;\r\n        } else {\r\n            SafeERC20.safeTransferFrom(asset, msg.sender, address(this), amount);\r\n        }\r\n\r\n        transferIn(state, asset, BalancePath.getCommonPath(msg.sender), amount);\r\n        Events.logDeposit(msg.sender, asset, amount);\r\n\r\n        return depositedEtherAmount;\r\n    }\r\n\r\n    // Transfer asset out of current contract\r\n    function withdraw(\r\n        Store.State storage state,\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        require(state.balances[user][asset] >= amount, \"BALANCE_NOT_ENOUGH\");\r\n\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            address payable payableUser = address(uint160(user));\r\n            payableUser.transfer(amount);\r\n        } else {\r\n            SafeERC20.safeTransfer(asset, user, amount);\r\n        }\r\n\r\n        transferOut(state, asset, BalancePath.getCommonPath(user), amount);\r\n\r\n        Events.logWithdraw(user, asset, amount);\r\n    }\r\n\r\n    // Get a user's asset balance\r\n    function balanceOf(\r\n        Store.State storage state,\r\n        Types.BalancePath memory balancePath,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        mapping(address => uint256) storage balances = balancePath.getBalances(state);\r\n        return balances[asset];\r\n    }\r\n\r\n    // Move asset from a balances map to another\r\n    function transfer(\r\n        Store.State storage state,\r\n        address asset,\r\n        Types.BalancePath memory fromBalancePath,\r\n        Types.BalancePath memory toBalancePath,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n\r\n        Requires.requirePathMarketIDAssetMatch(state, fromBalancePath, asset);\r\n        Requires.requirePathMarketIDAssetMatch(state, toBalancePath, asset);\r\n\r\n        mapping(address => uint256) storage fromBalances = fromBalancePath.getBalances(state);\r\n        mapping(address => uint256) storage toBalances = toBalancePath.getBalances(state);\r\n\r\n        require(fromBalances[asset] >= amount, \"TRANSFER_BALANCE_NOT_ENOUGH\");\r\n\r\n        fromBalances[asset] = fromBalances[asset] - amount;\r\n        toBalances[asset] = toBalances[asset].add(amount);\r\n    }\r\n\r\n    function transferIn(\r\n        Store.State storage state,\r\n        address asset,\r\n        Types.BalancePath memory path,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        mapping(address => uint256) storage balances = path.getBalances(state);\r\n        balances[asset] = balances[asset].add(amount);\r\n        state.cash[asset] = state.cash[asset].add(amount);\r\n    }\r\n\r\n    function transferOut(\r\n        Store.State storage state,\r\n        address asset,\r\n        Types.BalancePath memory path,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        mapping(address => uint256) storage balances = path.getBalances(state);\r\n        balances[asset] = balances[asset].sub(amount);\r\n        state.cash[asset] = state.cash[asset].sub(amount);\r\n    }\r\n}\r\n\r\nlibrary Types {\r\n    enum AuctionStatus {\r\n        InProgress,\r\n        Finished\r\n    }\r\n\r\n    enum CollateralAccountStatus {\r\n        Normal,\r\n        Liquid\r\n    }\r\n\r\n    enum OrderStatus {\r\n        EXPIRED,\r\n        CANCELLED,\r\n        FILLABLE,\r\n        FULLY_FILLED\r\n    }\r\n\r\n    /**\r\n     * Signature struct contains typical signature data as v, r, and s with the signature\r\n     * method encoded in as well.\r\n     */\r\n    struct Signature {\r\n        /**\r\n         * Config contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ v                  │ 1               the v parameter of a signature            ║\r\n         * ║ signatureMethod    │ 1               SignatureMethod enum value                ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    enum BalanceCategory {\r\n        Common,\r\n        CollateralAccount\r\n    }\r\n\r\n    struct BalancePath {\r\n        BalanceCategory category;\r\n        uint16          marketID;\r\n        address         user;\r\n    }\r\n\r\n    struct Asset {\r\n        ILendingPoolToken  lendingPoolToken;\r\n        IPriceOracle      priceOracle;\r\n        IInterestModel    interestModel;\r\n    }\r\n\r\n    struct Market {\r\n        address baseAsset;\r\n        address quoteAsset;\r\n\r\n        // If the collateralRate is below this rate, the account will be liquidated\r\n        uint256 liquidateRate;\r\n\r\n        // If the collateralRate is above this rate, the account asset balance can be withdrawed\r\n        uint256 withdrawRate;\r\n\r\n        uint256 auctionRatioStart;\r\n        uint256 auctionRatioPerBlock;\r\n\r\n        bool borrowEnable;\r\n    }\r\n\r\n    struct CollateralAccount {\r\n        uint32 id;\r\n        uint16 marketID;\r\n        CollateralAccountStatus status;\r\n        address owner;\r\n\r\n        mapping(address => uint256) balances;\r\n    }\r\n\r\n    // memory only\r\n    struct CollateralAccountDetails {\r\n        bool       liquidatable;\r\n        CollateralAccountStatus status;\r\n        uint256    debtsTotalUSDValue;\r\n        uint256    balancesTotalUSDValue;\r\n    }\r\n\r\n    struct Auction {\r\n        uint32 id;\r\n        AuctionStatus status;\r\n\r\n        // To calculate the ratio\r\n        uint32 startBlockNumber;\r\n\r\n        uint16 marketID;\r\n\r\n        address borrower;\r\n        address initiator;\r\n\r\n        address debtAsset;\r\n        address collateralAsset;\r\n    }\r\n\r\n    struct AuctionDetails {\r\n        address borrower;\r\n        uint16  marketID;\r\n        address debtAsset;\r\n        address collateralAsset;\r\n        uint256 leftDebtAmount;\r\n        uint256 leftCollateralAmount;\r\n        uint256 ratio;\r\n        uint256 price;\r\n        bool    finished;\r\n    }\r\n\r\n    struct Order {\r\n        address trader;\r\n        address relayer;\r\n        address baseAsset;\r\n        address quoteAsset;\r\n        uint256 baseAssetAmount;\r\n        uint256 quoteAssetAmount;\r\n        uint256 gasTokenAmount;\r\n\r\n        /**\r\n         * Data contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ version            │ 1               order version                             ║\r\n         * ║ side               │ 1               0: buy, 1: sell                           ║\r\n         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\r\n         * ║ expiredAt          │ 5               order expiration time in seconds          ║\r\n         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\r\n         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\r\n         * ║ makerRebateRate    │ 2               rebate rate for maker (base 100)          ║\r\n         * ║ salt               │ 8               salt                                      ║\r\n         * ║ isMakerOnly        │ 1               is maker only                             ║\r\n         * ║ balancesType       │ 1               0: common, 1: collateralAccount           ║\r\n         * ║ marketID           │ 2               marketID                                  ║\r\n         * ║                    │ 6               reserved                                  ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 data;\r\n    }\r\n\r\n        /**\r\n     * When orders are being matched, they will always contain the exact same base token,\r\n     * quote token, and relayer. Since excessive call data is very expensive, we choose\r\n     * to create a stripped down OrderParam struct containing only data that may vary between\r\n     * Order objects, and separate out the common elements into a set of addresses that will\r\n     * be shared among all of the OrderParam items. This is meant to eliminate redundancy in\r\n     * the call data, reducing it's size, and hence saving gas.\r\n     */\r\n    struct OrderParam {\r\n        address trader;\r\n        uint256 baseAssetAmount;\r\n        uint256 quoteAssetAmount;\r\n        uint256 gasTokenAmount;\r\n        bytes32 data;\r\n        Signature signature;\r\n    }\r\n\r\n\r\n    struct OrderAddressSet {\r\n        address baseAsset;\r\n        address quoteAsset;\r\n        address relayer;\r\n    }\r\n\r\n    struct MatchResult {\r\n        address maker;\r\n        address taker;\r\n        address buyer;\r\n        uint256 makerFee;\r\n        uint256 makerRebate;\r\n        uint256 takerFee;\r\n        uint256 makerGasFee;\r\n        uint256 takerGasFee;\r\n        uint256 baseAssetFilledAmount;\r\n        uint256 quoteAssetFilledAmount;\r\n        BalancePath makerBalancePath;\r\n        BalancePath takerBalancePath;\r\n    }\r\n    /**\r\n     * @param takerOrderParam A Types.OrderParam object representing the order from the taker.\r\n     * @param makerOrderParams An array of Types.OrderParam objects representing orders from a list of makers.\r\n     * @param orderAddressSet An object containing addresses common across each order.\r\n     */\r\n    struct MatchParams {\r\n        OrderParam       takerOrderParam;\r\n        OrderParam[]     makerOrderParams;\r\n        uint256[]        baseAssetFilledAmounts;\r\n        OrderAddressSet  orderAddressSet;\r\n    }\r\n}\r\n\r\nlibrary Auction {\r\n    using SafeMath for uint256;\r\n\r\n    function ratio(\r\n        Types.Auction memory auction,\r\n        Store.State storage state\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 increasedRatio = (block.number - auction.startBlockNumber).mul(state.markets[auction.marketID].auctionRatioPerBlock);\r\n        uint256 initRatio = state.markets[auction.marketID].auctionRatioStart;\r\n        uint256 totalRatio = initRatio.add(increasedRatio);\r\n        return totalRatio;\r\n    }\r\n}\r\n\r\nlibrary BalancePath {\r\n\r\n    function getBalances(\r\n        Types.BalancePath memory path,\r\n        Store.State storage state\r\n    )\r\n        internal\r\n        view\r\n        returns (mapping(address => uint256) storage)\r\n    {\r\n        if (path.category == Types.BalanceCategory.Common) {\r\n            return state.balances[path.user];\r\n        } else {\r\n            return state.accounts[path.user][path.marketID].balances;\r\n        }\r\n    }\r\n\r\n    function getCommonPath(\r\n        address user\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.BalancePath memory)\r\n    {\r\n        return Types.BalancePath({\r\n            user: user,\r\n            category: Types.BalanceCategory.Common,\r\n            marketID: 0\r\n        });\r\n    }\r\n\r\n    function getMarketPath(\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.BalancePath memory)\r\n    {\r\n        return Types.BalancePath({\r\n            user: user,\r\n            category: Types.BalanceCategory.CollateralAccount,\r\n            marketID: marketID\r\n        });\r\n    }\r\n}\r\n\r\nlibrary Order {\r\n\r\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(address trader,address relayer,address baseAsset,address quoteAsset,uint256 baseAssetAmount,uint256 quoteAssetAmount,uint256 gasTokenAmount,bytes32 data)\"\r\n        )\r\n    );\r\n\r\n    /**\r\n     * Calculates the Keccak-256 EIP712 hash of the order using the Hydro Protocol domain.\r\n     *\r\n     * @param order The order data struct.\r\n     * @return Fully qualified EIP712 hash of the order in the Hydro Protocol domain.\r\n     */\r\n    function getHash(\r\n        Types.Order memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 orderHash)\r\n    {\r\n        orderHash = EIP712.hashMessage(_hashContent(order));\r\n        return orderHash;\r\n    }\r\n\r\n    /**\r\n     * Calculates the EIP712 hash of the order.\r\n     *\r\n     * @param order The order data struct.\r\n     * @return Hash of the order.\r\n     */\r\n    function _hashContent(\r\n        Types.Order memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        /**\r\n         * Calculate the following hash in solidity assembly to save gas.\r\n         *\r\n         * keccak256(\r\n         *     abi.encodePacked(\r\n         *         EIP712_ORDER_TYPE,\r\n         *         bytes32(order.trader),\r\n         *         bytes32(order.relayer),\r\n         *         bytes32(order.baseAsset),\r\n         *         bytes32(order.quoteAsset),\r\n         *         order.baseAssetAmount,\r\n         *         order.quoteAssetAmount,\r\n         *         order.gasTokenAmount,\r\n         *         order.data\r\n         *     )\r\n         * );\r\n         */\r\n\r\n        bytes32 orderType = EIP712_ORDER_TYPE;\r\n\r\n        assembly {\r\n            let start := sub(order, 32)\r\n            let tmp := mload(start)\r\n\r\n            // 288 = (1 + 8) * 32\r\n            //\r\n            // [0...32)   bytes: EIP712_ORDER_TYPE\r\n            // [32...288) bytes: order\r\n            mstore(start, orderType)\r\n            result := keccak256(start, 288)\r\n\r\n            mstore(start, tmp)\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary OrderParam {\r\n    /* Functions to extract info from data bytes in Order struct */\r\n\r\n    function getOrderVersion(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint8(byte(order.data)));\r\n    }\r\n\r\n    function getExpiredAtFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint40(bytes5(order.data << (8*3))));\r\n    }\r\n\r\n    function isSell(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return uint8(order.data[1]) == 1;\r\n    }\r\n\r\n    function isMarketOrder(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return uint8(order.data[2]) == 1;\r\n    }\r\n\r\n    function isMakerOnly(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return uint8(order.data[22]) == 1;\r\n    }\r\n\r\n    function isMarketBuy(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !isSell(order) && isMarketOrder(order);\r\n    }\r\n\r\n    function getAsMakerFeeRateFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint16(bytes2(order.data << (8*8))));\r\n    }\r\n\r\n    function getAsTakerFeeRateFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint16(bytes2(order.data << (8*10))));\r\n    }\r\n\r\n    function getMakerRebateRateFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 makerRebate = uint256(uint16(bytes2(order.data << (8*12))));\r\n\r\n        // make sure makerRebate will never be larger than REBATE_RATE_BASE, which is 100\r\n        return SafeMath.min(makerRebate, Consts.REBATE_RATE_BASE());\r\n    }\r\n\r\n    function getBalancePathFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.BalancePath memory)\r\n    {\r\n        Types.BalanceCategory category;\r\n        uint16 marketID;\r\n\r\n        if (byte(order.data << (8*23)) == \"\\x01\") {\r\n            category = Types.BalanceCategory.CollateralAccount;\r\n            marketID = uint16(bytes2(order.data << (8*24)));\r\n        } else {\r\n            category = Types.BalanceCategory.Common;\r\n            marketID = 0;\r\n        }\r\n\r\n        return Types.BalancePath({\r\n            user: order.trader,\r\n            category: category,\r\n            marketID: marketID\r\n        });\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"approveDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"isOrderCancelled\",\"outputs\":[{\"name\":\"isCancelled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"marketID\",\"type\":\"uint16\"}],\"name\":\"isAccountLiquidatable\",\"outputs\":[{\"name\":\"isLiquidatable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPoolCashableAmount\",\"outputs\":[{\"name\":\"cashableAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"marketID\",\"type\":\"uint16\"}],\"name\":\"getMarket\",\"outputs\":[{\"components\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"quoteAsset\",\"type\":\"address\"},{\"name\":\"liquidateRate\",\"type\":\"uint256\"},{\"name\":\"withdrawRate\",\"type\":\"uint256\"},{\"name\":\"auctionRatioStart\",\"type\":\"uint256\"},{\"name\":\"auctionRatioPerBlock\",\"type\":\"uint256\"},{\"name\":\"borrowEnable\",\"type\":\"bool\"}],\"name\":\"market\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"marketID\",\"type\":\"uint16\"}],\"name\":\"liquidateAccount\",\"outputs\":[{\"name\":\"hasAuction\",\"type\":\"bool\"},{\"name\":\"auctionID\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"marketID\",\"type\":\"uint16\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMarketTransferableAmount\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"marketID\",\"type\":\"uint16\"},{\"name\":\"newAuctionRatioStart\",\"type\":\"uint256\"},{\"name\":\"newAuctionRatioPerBlock\",\"type\":\"uint256\"},{\"name\":\"newLiquidateRate\",\"type\":\"uint256\"},{\"name\":\"newWithdrawRate\",\"type\":\"uint256\"}],\"name\":\"updateMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionID\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fillAuctionWithAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionID\",\"type\":\"uint32\"}],\"name\":\"getAuctionDetails\",\"outputs\":[{\"components\":[{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"marketID\",\"type\":\"uint16\"},{\"name\":\"debtAsset\",\"type\":\"address\"},{\"name\":\"collateralAsset\",\"type\":\"address\"},{\"name\":\"leftDebtAmount\",\"type\":\"uint256\"},{\"name\":\"leftCollateralAmount\",\"type\":\"uint256\"},{\"name\":\"ratio\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"}],\"name\":\"details\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"getAsset\",\"outputs\":[{\"components\":[{\"name\":\"lendingPoolToken\",\"type\":\"address\"},{\"name\":\"priceOracle\",\"type\":\"address\"},{\"name\":\"interestModel\",\"type\":\"address\"}],\"name\":\"asset\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAmountSupplied\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHydroTokenAddress\",\"outputs\":[{\"name\":\"hydroTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exitIncentiveSystem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"interestModelAddress\",\"type\":\"address\"},{\"name\":\"poolTokenName\",\"type\":\"string\"},{\"name\":\"poolTokenSymbol\",\"type\":\"string\"},{\"name\":\"poolTokenDecimals\",\"type\":\"uint8\"}],\"name\":\"createAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canMatchOrdersFrom\",\"outputs\":[{\"name\":\"canMatch\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"extraBorrowAmount\",\"type\":\"uint256\"}],\"name\":\"getInterestRates\",\"outputs\":[{\"name\":\"borrowInterestRate\",\"type\":\"uint256\"},{\"name\":\"supplyInterestRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDiscountedRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"marketID\",\"type\":\"uint16\"}],\"name\":\"getAccountDetails\",\"outputs\":[{\"components\":[{\"name\":\"liquidatable\",\"type\":\"bool\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"debtsTotalUSDValue\",\"type\":\"uint256\"},{\"name\":\"balancesTotalUSDValue\",\"type\":\"uint256\"}],\"name\":\"details\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderFilledAmount\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"getAssetOraclePrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getInsuranceBalance\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"interestModelAddress\",\"type\":\"address\"}],\"name\":\"updateAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"signerAddress\",\"type\":\"address\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"isValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"actionType\",\"type\":\"uint8\"},{\"name\":\"encodedParams\",\"type\":\"bytes\"}],\"name\":\"actions\",\"type\":\"tuple[]\"}],\"name\":\"batch\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getTotalBorrow\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"quoteAsset\",\"type\":\"address\"},{\"name\":\"liquidateRate\",\"type\":\"uint256\"},{\"name\":\"withdrawRate\",\"type\":\"uint256\"},{\"name\":\"auctionRatioStart\",\"type\":\"uint256\"},{\"name\":\"auctionRatioPerBlock\",\"type\":\"uint256\"},{\"name\":\"borrowEnable\",\"type\":\"bool\"}],\"name\":\"market\",\"type\":\"tuple\"}],\"name\":\"createMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"marketID\",\"type\":\"uint16\"}],\"name\":\"getAmountBorrowed\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"isParticipant\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllMarketsCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"baseAssetAmount\",\"type\":\"uint256\"},{\"name\":\"quoteAssetAmount\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"takerOrderParam\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"baseAssetAmount\",\"type\":\"uint256\"},{\"name\":\"quoteAssetAmount\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"config\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"makerOrderParams\",\"type\":\"tuple[]\"},{\"name\":\"baseAssetFilledAmounts\",\"type\":\"uint256[]\"},{\"components\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"quoteAsset\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"orderAddressSet\",\"type\":\"tuple\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"matchOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newInitiatorRewardRatio\",\"type\":\"uint256\"}],\"name\":\"updateAuctionInitiatorRewardRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getIndex\",\"outputs\":[{\"name\":\"supplyIndex\",\"type\":\"uint256\"},{\"name\":\"borrowIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"quoteAsset\",\"type\":\"address\"},{\"name\":\"baseAssetAmount\",\"type\":\"uint256\"},{\"name\":\"quoteAssetAmount\",\"type\":\"uint256\"},{\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"joinIncentiveSystem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newInsuranceRatio\",\"type\":\"uint256\"}],\"name\":\"updateInsuranceRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newConfig\",\"type\":\"bytes32\"}],\"name\":\"updateDiscountConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"marketID\",\"type\":\"uint16\"},{\"name\":\"usability\",\"type\":\"bool\"}],\"name\":\"setMarketBorrowUsability\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionsCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"marketID\",\"type\":\"uint16\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"marketBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_hotTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Hydro","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009af839687f6c94542ac5ece2e317daae355493a1","Library":"BatchActions:bf7e93f3a5730416e2229eac9d4fa9794b327477;Auctions:3eb39889f4b38691249d5e67d5ecc844ce0297b8;OperationsComponent:723091df82333033f1b646fe1ad7bbbf9cbe420c","SwarmSource":"bzzr://398b9cc4453519448f572a80050a76d547f927512a27d158ef90497e37907b1f"}]}