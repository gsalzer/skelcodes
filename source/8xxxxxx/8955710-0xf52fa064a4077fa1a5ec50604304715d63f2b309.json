{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-11-10\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-10-13\r\n*/\r\n\r\npragma solidity >=0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n  \r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Interface {\r\n  function name() public view returns (string memory);\r\n  function symbol() public view returns (string memory);\r\n  function decimals() public view returns (uint8);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\ncontract ERC20BadInterface {\r\n  function name() public view returns (bytes32);\r\n  function symbol() public view returns (bytes32);\r\n  function decimals() public view returns (uint8);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\ncontract RegistryLookup is Ownable{\r\n\r\n    mapping (address => bool) public authorisedStatus;\r\n    event AddNewToken(address newToken);\r\n    event RemoveToken(address token);\r\n\r\n    address[] public authorisedTokens;\r\n\r\n    function addNewTokens(address[] memory _tokens) public onlyOwner {\r\n        for (uint32 i = 0; i < _tokens.length; i++) {\r\n            authorisedStatus[_tokens[i]] = true;\r\n            authorisedTokens.push(_tokens[i]);\r\n            emit AddNewToken(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    function removeTokens(address[] memory _tokens) public onlyOwner {\r\n        for (uint32 i = 0; i < _tokens.length; i++) {\r\n            require(authorisedStatus[_tokens[i]] == true, \"token already removed\");\r\n            authorisedStatus[_tokens[i]] = false;\r\n            emit RemoveToken(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    function getAvailableTokens() public view returns(address[] memory tokens) {\r\n        tokens = new address[](authorisedTokens.length);\r\n\r\n        for (uint32 i = 0; i < authorisedTokens.length; i++) {\r\n            if (authorisedStatus[authorisedTokens[i]]) {\r\n                tokens[i] = authorisedTokens[i];\r\n            } else {\r\n                tokens[i] = address(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\r\n      bytes memory bytesString = new bytes(32);\r\n      uint charCount = 0;\r\n      for (uint j = 0; j < 32; j++) {\r\n        byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n        if (char != 0) {\r\n          bytesString[charCount] = char;\r\n          charCount++;\r\n        }\r\n      }\r\n      bytes memory bytesStringTrimmed = new bytes(charCount);\r\n      for (uint32 j = 0; j < charCount; j++) {\r\n        bytesStringTrimmed[j] = bytesString[j];\r\n      }\r\n      return string(bytesStringTrimmed);\r\n    }\r\n\r\n    function getTokenName(address tokenAddress) private view returns (string memory){\r\n      // check if bytes32 call returns correctly\r\n      string memory name = bytes32ToString(ERC20BadInterface(tokenAddress).name());\r\n      bytes memory nameBytes = bytes(name);\r\n      if(nameBytes.length <= 1){\r\n        name = ERC20Interface(tokenAddress).name();\r\n      }\r\n      return name;\r\n    }\r\n\r\n    function getTokenSymbol(address tokenAddress) private view returns (string memory){\r\n      // check if bytes32 call returns correctly\r\n      string memory symbol = bytes32ToString(ERC20BadInterface(tokenAddress).symbol());\r\n      bytes memory symbolBytes = bytes(symbol);\r\n      if(symbolBytes.length <= 1){\r\n        symbol = ERC20Interface(tokenAddress).symbol();\r\n      }\r\n      return symbol;\r\n    }\r\n\r\n    // get name, symbol and decimals for multiple tokens\r\n    function getTokenData(address[] memory _tokens) public view returns (\r\n      string[] memory names, string[] memory symbols, uint[] memory decimals\r\n      ) {\r\n      names = new string[](_tokens.length);\r\n      symbols = new string[](_tokens.length);\r\n      decimals = new uint[](_tokens.length);\r\n      for (uint32 i = 0; i < _tokens.length; i++) {\r\n        names[i] = getTokenName(_tokens[i]);\r\n        symbols[i] = getTokenSymbol(_tokens[i]);\r\n        decimals[i] = ERC20Interface(_tokens[i]).decimals();\r\n      }\r\n    }\r\n\r\n    // get external balance of multiple tokens\r\n    function getExternalBalances(address trader, address[] memory assetAddresses) public view returns (uint256[] memory) {\r\n        uint256[] memory balances = new uint256[](assetAddresses.length);\r\n        for (uint i = 0; i < assetAddresses.length; i++) {\r\n            balances[i] = ERC20Interface(assetAddresses[i]).balanceOf(trader);\r\n        }\r\n        return balances;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"addNewTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorisedStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"removeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorisedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"getTokenData\",\"outputs\":[{\"name\":\"names\",\"type\":\"string[]\"},{\"name\":\"symbols\",\"type\":\"string[]\"},{\"name\":\"decimals\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"assetAddresses\",\"type\":\"address[]\"}],\"name\":\"getExternalBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"AddNewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"RemoveToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RegistryLookup","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://60091ad19fd9d3dc53a1141692451a75bf4f0de4f8c59437a506ce1ed9f607a1"}]}