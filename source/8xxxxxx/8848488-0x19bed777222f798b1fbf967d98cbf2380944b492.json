{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n//////////////CONTRACT//////////////\r\n\r\n\r\n\r\n\r\ncontract DragonLeaderboard is Upgradable {\r\n    using SafeMath256 for uint256;\r\n\r\n    struct Leaderboard {\r\n        uint256 id;\r\n        uint32 coolness;\r\n    }\r\n\r\n    Leaderboard[10] leaderboard;\r\n\r\n    uint256 constant REWARDED_DRAGONS_AMOUNT = 10;\r\n    uint256 constant DISTRIBUTING_FRACTION_OF_REMAINING_GOLD = 10000;\r\n    uint256 rewardPeriod = 24 hours;\r\n    uint256 lastRewardDate;\r\n\r\n    constructor() public {\r\n        lastRewardDate = now; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    function update(uint256 _id, uint32 _coolness) external onlyController {\r\n        uint256 _index;\r\n        bool _isIndex;\r\n        uint256 _existingIndex;\r\n        bool _isExistingIndex;\r\n\r\n        // if coolness is more than coolness of the last dragon\r\n        if (_coolness > leaderboard[leaderboard.length.sub(1)].coolness) {\r\n\r\n            for (uint256 i = 0; i < leaderboard.length; i = i.add(1)) {\r\n                // if a place for a dragon is found\r\n                if (_coolness > leaderboard[i].coolness && !_isIndex) {\r\n                    _index = i;\r\n                    _isIndex = true;\r\n                }\r\n                // if dragon is already in leaderboard\r\n                if (leaderboard[i].id == _id && !_isExistingIndex) {\r\n                    _existingIndex = i;\r\n                    _isExistingIndex = true;\r\n                }\r\n                if(_isIndex && _isExistingIndex) break;\r\n            }\r\n            // if dragon stayed at the same place\r\n            if (_isExistingIndex && _index >= _existingIndex) {\r\n                leaderboard[_existingIndex] = Leaderboard(_id, _coolness);\r\n            } else if (_isIndex) {\r\n                _add(_index, _existingIndex, _isExistingIndex, _id, _coolness);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _add(\r\n        uint256 _index,\r\n        uint256 _existingIndex,\r\n        bool _isExistingIndex,\r\n        uint256 _id,\r\n        uint32 _coolness\r\n    ) internal {\r\n        uint256 _length = leaderboard.length;\r\n        uint256 _indexTo = _isExistingIndex ? _existingIndex : _length.sub(1);\r\n\r\n        // shift other dragons\r\n        for (uint256 i = _indexTo; i > _index; i = i.sub(1)){\r\n            leaderboard[i] = leaderboard[i.sub(1)];\r\n        }\r\n\r\n        leaderboard[_index] = Leaderboard(_id, _coolness);\r\n    }\r\n\r\n    function getDragonsFromLeaderboard() external view returns (uint256[10] result) {\r\n        for (uint256 i = 0; i < leaderboard.length; i = i.add(1)) {\r\n            result[i] = leaderboard[i].id;\r\n        }\r\n    }\r\n\r\n    function updateRewardTime() external onlyController {\r\n        require(lastRewardDate.add(rewardPeriod) < now, \"too early\"); // solium-disable-line security/no-block-members\r\n        lastRewardDate = now; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    function getRewards(uint256 _remainingGold) external view returns (uint256[10] rewards) {\r\n        for (uint8 i = 0; i < REWARDED_DRAGONS_AMOUNT; i++) {\r\n            rewards[i] = _remainingGold.mul(uint256(2).pow(REWARDED_DRAGONS_AMOUNT.sub(1))).div(\r\n                DISTRIBUTING_FRACTION_OF_REMAINING_GOLD.mul((uint256(2).pow(REWARDED_DRAGONS_AMOUNT)).sub(1)).mul(uint256(2).pow(i))\r\n            );\r\n        }\r\n    }\r\n\r\n    function getDate() external view returns (uint256, uint256) {\r\n        return (lastRewardDate, rewardPeriod);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDragonsFromLeaderboard\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_remainingGold\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"name\":\"rewards\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_coolness\",\"type\":\"uint32\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateRewardTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonLeaderboard","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://d4138b4c95b680d45c4125356b97fa005a56feef8966f8e995e94152d79665b8"}]}