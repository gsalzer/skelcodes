{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract ParameterStore {\r\n    // EVENTS\r\n    event ProposalCreated(\r\n        uint256 proposalID,\r\n        address indexed proposer,\r\n        uint256 requestID,\r\n        string key,\r\n        bytes32 value,\r\n        bytes metadataHash\r\n    );\r\n    event Initialized();\r\n    event ParameterSet(string name, bytes32 key, bytes32 value);\r\n    event ProposalAccepted(uint256 proposalID, string key, bytes32 value);\r\n\r\n\r\n    // STATE\r\n    using SafeMath for uint256;\r\n\r\n    address owner;\r\n    bool public initialized;\r\n    mapping(bytes32 => bytes32) public params;\r\n\r\n    // A proposal to change a value\r\n    struct Proposal {\r\n        address gatekeeper;\r\n        uint256 requestID;\r\n        string key;\r\n        bytes32 value;\r\n        bytes metadataHash;\r\n        bool executed;\r\n    }\r\n\r\n    // All submitted proposals\r\n    Proposal[] public proposals;\r\n\r\n    // IMPLEMENTATION\r\n    /**\r\n     @dev Initialize a ParameterStore with a set of names and associated values.\r\n     @param _names Names of parameters\r\n     @param _values abi-encoded values to assign them\r\n    */\r\n    constructor(string[] memory _names, bytes32[] memory _values) public {\r\n        owner = msg.sender;\r\n        require(_names.length == _values.length, \"All inputs must have the same length\");\r\n\r\n        for (uint i = 0; i < _names.length; i++) {\r\n            string memory name = _names[i];\r\n            set(name, _values[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Initialize the contract, preventing any more changes not made through slate governance\r\n     */\r\n    function init() public {\r\n        require(msg.sender == owner, \"Only the owner can initialize the ParameterStore\");\r\n        require(initialized == false, \"Contract has already been initialized\");\r\n\r\n        initialized = true;\r\n\r\n        // Do not allow initialization unless the gatekeeperAddress is set\r\n        // Check after setting initialized so we can use the getter\r\n        require(getAsAddress(\"gatekeeperAddress\") != address(0), \"Missing gatekeeper\");\r\n\r\n        emit Initialized();\r\n    }\r\n\r\n    // GETTERS\r\n\r\n    /**\r\n     @dev Get the parameter value associated with the given name.\r\n     @param _name The name of the parameter to get the value for\r\n    */\r\n    function get(string memory _name) public view returns (bytes32 value) {\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n        return params[keccak256(abi.encodePacked(_name))];\r\n    }\r\n\r\n    /**\r\n     @dev Get the parameter value and cast to `uint256`\r\n     @param _name The name of the parameter to get the value for\r\n    */\r\n    function getAsUint(string memory _name) public view returns(uint256) {\r\n        bytes32 value = get(_name);\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     @dev Get the parameter value and cast to `address`\r\n     @param _name The name of the parameter to get the value for\r\n    */\r\n    function getAsAddress(string memory _name) public view returns (address) {\r\n        bytes32 value = get(_name);\r\n        return address(uint256(value));\r\n    }\r\n\r\n    // SETTERS\r\n    /**\r\n     @dev Assign the parameter with the given key to the given value.\r\n     @param _name The name of the parameter to be set\r\n     @param _value The abi-encoded value to assign the parameter\r\n    */\r\n    function set(string memory _name, bytes32 _value) private {\r\n        bytes32 key = keccak256(abi.encodePacked(_name));\r\n        params[key] = _value;\r\n        emit ParameterSet(_name, key, _value);\r\n    }\r\n\r\n    /**\r\n     @dev Set a parameter before the ParameterStore has been initialized\r\n     @param _name The name of the parameter to set\r\n     @param _value The abi-encoded value to assign the parameter\r\n    */\r\n    function setInitialValue(string memory _name, bytes32 _value) public {\r\n        require(msg.sender == owner, \"Only the owner can set initial values\");\r\n        require(initialized == false, \"Cannot set values after initialization\");\r\n\r\n        set(_name, _value);\r\n    }\r\n\r\n    function _createProposal(Gatekeeper gatekeeper, string memory key, bytes32 value, bytes memory metadataHash) internal returns(uint256) {\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n\r\n        Proposal memory p = Proposal({\r\n            gatekeeper: address(gatekeeper),\r\n            requestID: 0,\r\n            key: key,\r\n            value: value,\r\n            metadataHash: metadataHash,\r\n            executed: false\r\n        });\r\n\r\n        // Request permission from the Gatekeeper and store the proposal data for later.\r\n        // If the request is approved, a user can execute the proposal by providing the\r\n        // proposalID.\r\n        uint requestID = gatekeeper.requestPermission(metadataHash);\r\n        p.requestID = requestID;\r\n        uint proposalID = proposalCount();\r\n        proposals.push(p);\r\n\r\n        emit ProposalCreated(proposalID, msg.sender, requestID, key, value, metadataHash);\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     @dev Create a proposal to set a value.\r\n     @param key The key to set\r\n     @param value The value to set\r\n     @param metadataHash A reference to metadata describing the proposal\r\n     */\r\n    function createProposal(string calldata key, bytes32 value, bytes calldata metadataHash) external returns(uint256) {\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n\r\n        Gatekeeper gatekeeper = _gatekeeper();\r\n        return _createProposal(gatekeeper, key, value, metadataHash);\r\n    }\r\n\r\n    /**\r\n     @dev Create multiple proposals to set values.\r\n     @param keys The keys to set\r\n     @param values The values to set for the keys\r\n     @param metadataHashes Metadata hashes describing the proposals\r\n    */\r\n    function createManyProposals(\r\n        string[] calldata keys,\r\n        bytes32[] calldata values,\r\n        bytes[] calldata metadataHashes\r\n    ) external {\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n        require(\r\n            keys.length == values.length && values.length == metadataHashes.length,\r\n            \"All inputs must have the same length\"\r\n        );\r\n\r\n        Gatekeeper gatekeeper = _gatekeeper();\r\n        for (uint i = 0; i < keys.length; i++) {\r\n            string memory key = keys[i];\r\n            bytes32 value = values[i];\r\n            bytes memory metadataHash = metadataHashes[i];\r\n            _createProposal(gatekeeper, key, value, metadataHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Execute a proposal to set a parameter. The proposal must have been included in an\r\n     accepted governance slate.\r\n     @param proposalID The proposal\r\n     */\r\n    function setValue(uint256 proposalID) public returns(bool) {\r\n        require(proposalID < proposalCount(), \"Invalid proposalID\");\r\n        require(initialized, \"Contract has not yet been initialized\");\r\n\r\n        Proposal memory p = proposals[proposalID];\r\n        Gatekeeper gatekeeper = Gatekeeper(p.gatekeeper);\r\n\r\n        require(gatekeeper.hasPermission(p.requestID), \"Proposal has not been approved\");\r\n        require(p.executed == false, \"Proposal already executed\");\r\n\r\n        proposals[proposalID].executed = true;\r\n\r\n        set(p.key, p.value);\r\n\r\n        emit ProposalAccepted(proposalID, p.key, p.value);\r\n        return true;\r\n    }\r\n\r\n    function proposalCount() public view returns(uint256) {\r\n        return proposals.length;\r\n    }\r\n\r\n    function _gatekeeper() private view returns(Gatekeeper) {\r\n        address gatekeeperAddress = getAsAddress(\"gatekeeperAddress\");\r\n        require(gatekeeperAddress != address(0), \"Missing gatekeeper\");\r\n        return Gatekeeper(gatekeeperAddress);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Donation receiver interface\r\n * @dev Contracts (like the TokenCapacitor) that can receive donations\r\n */\r\ninterface IDonationReceiver {\r\n    event Donation(address indexed payer, address indexed donor, uint numTokens, bytes metadataHash);\r\n\r\n    function donate(address donor, uint tokens, bytes calldata metadataHash) external returns(bool);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Gatekeeper {\r\n    // EVENTS\r\n    event PermissionRequested(\r\n        uint256 indexed epochNumber,\r\n        address indexed resource,\r\n        uint requestID,\r\n        bytes metadataHash\r\n    );\r\n    event SlateCreated(uint slateID, address indexed recommender, uint[] requestIDs, bytes metadataHash);\r\n    event SlateStaked(uint slateID, address indexed staker, uint numTokens);\r\n    event VotingTokensDeposited(address indexed voter, uint numTokens);\r\n    event VotingTokensWithdrawn(address indexed voter, uint numTokens);\r\n    event VotingRightsDelegated(address indexed voter, address delegate);\r\n    event BallotCommitted(\r\n        uint indexed epochNumber,\r\n        address indexed committer,\r\n        address indexed voter,\r\n        uint numTokens,\r\n        bytes32 commitHash\r\n    );\r\n    event BallotRevealed(uint indexed epochNumber, address indexed voter, uint numTokens);\r\n    event ContestAutomaticallyFinalized(\r\n        uint256 indexed epochNumber,\r\n        address indexed resource,\r\n        uint256 winningSlate\r\n    );\r\n    event ContestFinalizedWithoutWinner(uint indexed epochNumber, address indexed resource);\r\n    event VoteFinalized(\r\n        uint indexed epochNumber,\r\n        address indexed resource,\r\n        uint winningSlate,\r\n        uint winnerVotes,\r\n        uint totalVotes\r\n    );\r\n    event VoteFailed(\r\n        uint indexed epochNumber,\r\n        address indexed resource,\r\n        uint leadingSlate,\r\n        uint leaderVotes,\r\n        uint runnerUpSlate,\r\n        uint runnerUpVotes,\r\n        uint totalVotes\r\n    );\r\n    event RunoffFinalized(\r\n        uint indexed epochNumber,\r\n        address indexed resource,\r\n        uint winningSlate,\r\n        uint winnerVotes,\r\n        uint losingSlate,\r\n        uint loserVotes\r\n    );\r\n    event StakeWithdrawn(uint slateID, address indexed staker, uint numTokens);\r\n\r\n    // STATE\r\n    using SafeMath for uint256;\r\n\r\n    uint constant ONE_WEEK = 604800;\r\n\r\n    // The timestamp of the start of the first epoch\r\n    uint public startTime;\r\n    uint public constant EPOCH_LENGTH = ONE_WEEK * 13;\r\n    uint public constant SLATE_SUBMISSION_PERIOD_START = ONE_WEEK;\r\n    uint public constant COMMIT_PERIOD_START = ONE_WEEK * 11;\r\n    uint public constant REVEAL_PERIOD_START = ONE_WEEK * 12;\r\n\r\n    // Parameters\r\n    ParameterStore public parameters;\r\n\r\n    // Associated token\r\n    IERC20 public token;\r\n\r\n    // Requests\r\n    struct Request {\r\n        bytes metadataHash;\r\n        // The resource (contract) the permission is being requested for\r\n        address resource;\r\n        bool approved;\r\n        uint expirationTime;\r\n        uint epochNumber;\r\n    }\r\n\r\n    // The requests made to the Gatekeeper.\r\n    Request[] public requests;\r\n\r\n    // Voting\r\n    enum SlateStatus {\r\n        Unstaked,\r\n        Staked,\r\n        Accepted\r\n    }\r\n\r\n    struct Slate {\r\n        address recommender;\r\n        bytes metadataHash;\r\n        mapping(uint => bool) requestIncluded;\r\n        uint[] requests;\r\n        SlateStatus status;\r\n        // Staking info\r\n        address staker;\r\n        uint stake;\r\n        // Ballot info\r\n        uint256 epochNumber;\r\n        address resource;\r\n    }\r\n\r\n    // The slates created by the Gatekeeper.\r\n    Slate[] public slates;\r\n\r\n    // The number of tokens each account has available for voting\r\n    mapping(address => uint) public voteTokenBalance;\r\n\r\n    // The delegated account for each voting account\r\n    mapping(address => address) public delegate;\r\n\r\n    // The data committed when voting\r\n    struct VoteCommitment {\r\n        bytes32 commitHash;\r\n        uint numTokens;\r\n        bool committed;\r\n        bool revealed;\r\n    }\r\n\r\n    // The votes for a slate in a contest\r\n    struct SlateVotes {\r\n        uint firstChoiceVotes;\r\n        // slateID -> count\r\n        mapping(uint => uint) secondChoiceVotes;\r\n        uint totalSecondChoiceVotes;\r\n    }\r\n\r\n    enum ContestStatus {\r\n        Empty,\r\n        NoContest,\r\n        Active,\r\n        Finalized\r\n    }\r\n\r\n    struct Contest {\r\n        ContestStatus status;\r\n\r\n        // slateIDs\r\n        uint[] slates;\r\n        uint[] stakedSlates;\r\n        uint256 lastStaked;\r\n\r\n        // slateID -> tally\r\n        mapping(uint => SlateVotes) votes;\r\n        uint256 stakesDonated;\r\n\r\n        // Intermediate results\r\n        uint voteLeader;\r\n        uint voteRunnerUp;\r\n        uint256 leaderVotes;\r\n        uint256 runnerUpVotes;\r\n        uint256 totalVotes;\r\n\r\n        // Final results\r\n        uint winner;\r\n    }\r\n\r\n    // The current incumbent for a resource\r\n    mapping(address => address) public incumbent;\r\n\r\n    // A group of Contests in an epoch\r\n    struct Ballot {\r\n        // resource -> Contest\r\n        mapping(address => Contest) contests;\r\n        // NOTE: keep to avoid error about \"internal or recursive type\"\r\n        bool created;\r\n\r\n        // commitments for each voter\r\n        mapping(address => VoteCommitment) commitments;\r\n    }\r\n\r\n    // All the ballots created so far\r\n    // epoch number -> Ballot\r\n    mapping(uint => Ballot) public ballots;\r\n\r\n\r\n    // IMPLEMENTATION\r\n    /**\r\n     @dev Initialize a Gatekeeper contract.\r\n     @param _startTime The start time of the first batch\r\n     @param _parameters The parameter store to use\r\n    */\r\n    constructor(uint _startTime, ParameterStore _parameters, IERC20 _token) public {\r\n        require(address(_parameters) != address(0), \"Parameter store address cannot be zero\");\r\n        parameters = _parameters;\r\n\r\n        require(address(_token) != address(0), \"Token address cannot be zero\");\r\n        token = _token;\r\n\r\n        startTime = _startTime;\r\n    }\r\n\r\n    // TIMING\r\n    /**\r\n    * @dev Get the number of the current epoch.\r\n    */\r\n    function currentEpochNumber() public view returns(uint) {\r\n        uint elapsed = now.sub(startTime);\r\n        uint epoch = elapsed.div(EPOCH_LENGTH);\r\n\r\n        return epoch;\r\n    }\r\n\r\n    /**\r\n    * @dev Get the start of the given epoch.\r\n    */\r\n    function epochStart(uint256 epoch) public view returns(uint) {\r\n        return startTime.add(EPOCH_LENGTH.mul(epoch));\r\n    }\r\n\r\n\r\n    // SLATE GOVERNANCE\r\n    /**\r\n    * @dev Create a new slate with the associated requestIds and metadata hash.\r\n    * @param resource The resource to submit the slate for\r\n    * @param requestIDs A list of request IDs to include in the slate\r\n    * @param metadataHash A reference to metadata about the slate\r\n    */\r\n    function recommendSlate(\r\n        address resource,\r\n        uint[] memory requestIDs,\r\n        bytes memory metadataHash\r\n    )\r\n        public returns(uint)\r\n    {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        require(slateSubmissionPeriodActive(resource), \"Submission period not active\");\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n\r\n        uint256 epochNumber = currentEpochNumber();\r\n\r\n        // create slate\r\n        Slate memory s = Slate({\r\n            recommender: msg.sender,\r\n            metadataHash: metadataHash,\r\n            requests: requestIDs,\r\n            status: SlateStatus.Unstaked,\r\n            staker: address(0),\r\n            stake: 0,\r\n            epochNumber: epochNumber,\r\n            resource: resource\r\n        });\r\n\r\n        // Record slate and return its ID\r\n        uint slateID = slateCount();\r\n        slates.push(s);\r\n\r\n        // Set up the requests\r\n        for (uint i = 0; i < requestIDs.length; i++) {\r\n            uint requestID = requestIDs[i];\r\n            require(requestID < requestCount(), \"Invalid requestID\");\r\n\r\n            Request memory r = requests[requestID];\r\n            // Every request's resource must match the one passed in\r\n            require(r.resource == resource, \"Resource does not match\");\r\n\r\n            // Requests must be current\r\n            require(r.epochNumber == epochNumber, \"Invalid epoch\");\r\n\r\n            // Requests cannot be duplicated\r\n            require(slates[slateID].requestIncluded[requestID] == false, \"Duplicate requests are not allowed\");\r\n            slates[slateID].requestIncluded[requestID] = true;\r\n        }\r\n\r\n        // Assign the slate to the appropriate contest\r\n        ballots[epochNumber].contests[resource].slates.push(slateID);\r\n\r\n        emit SlateCreated(slateID, msg.sender, requestIDs, metadataHash);\r\n        return slateID;\r\n    }\r\n\r\n    /**\r\n    @dev Get a list of the requests associated with a slate\r\n    @param slateID The slate\r\n     */\r\n    function slateRequests(uint slateID) public view returns(uint[] memory) {\r\n        return slates[slateID].requests;\r\n    }\r\n\r\n    /**\r\n    @dev Stake tokens on the given slate to include it for consideration in votes. If the slate\r\n    loses in a contest, the amount staked will go to the winner. If it wins, it will be returned.\r\n    @param slateID The slate to stake on\r\n     */\r\n    function stakeTokens(uint slateID) public returns(bool) {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        require(slateID < slateCount(), \"No slate exists with that slateID\");\r\n        require(slates[slateID].status == SlateStatus.Unstaked, \"Slate has already been staked\");\r\n\r\n        address staker = msg.sender;\r\n\r\n        // Staker must have enough tokens\r\n        uint stakeAmount = parameters.getAsUint(\"slateStakeAmount\");\r\n        require(token.balanceOf(staker) >= stakeAmount, \"Insufficient token balance\");\r\n\r\n        Slate storage slate = slates[slateID];\r\n\r\n        // Submission period must be active\r\n        require(slateSubmissionPeriodActive(slate.resource), \"Submission period not active\");\r\n        uint256 epochNumber = currentEpochNumber();\r\n        assert(slate.epochNumber == epochNumber);\r\n\r\n        // Transfer tokens and update the slate's staking info\r\n        // Must successfully transfer tokens from staker to this contract\r\n        slate.staker = staker;\r\n        slate.stake = stakeAmount;\r\n        slate.status = SlateStatus.Staked;\r\n        require(token.transferFrom(staker, address(this), stakeAmount), \"Failed to transfer tokens\");\r\n\r\n        // Associate the slate with a contest and update the contest status\r\n        // A vote can only happen if there is more than one associated slate\r\n        Contest storage contest = ballots[slate.epochNumber].contests[slate.resource];\r\n        contest.stakedSlates.push(slateID);\r\n        // offset from the start of the epoch, for easier calculations\r\n        contest.lastStaked = now.sub(epochStart(epochNumber));\r\n\r\n        uint256 numSlates = contest.stakedSlates.length;\r\n        if (numSlates == 1) {\r\n            contest.status = ContestStatus.NoContest;\r\n        } else {\r\n            contest.status = ContestStatus.Active;\r\n        }\r\n\r\n        emit SlateStaked(slateID, staker, stakeAmount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    @dev Withdraw tokens previously staked on a slate that was accepted through slate governance.\r\n    @param slateID The slate to withdraw the stake from\r\n     */\r\n    function withdrawStake(uint slateID) public returns(bool) {\r\n        require(slateID < slateCount(), \"No slate exists with that slateID\");\r\n\r\n        // get slate\r\n        Slate memory slate = slates[slateID];\r\n\r\n        require(slate.status == SlateStatus.Accepted, \"Slate has not been accepted\");\r\n        require(msg.sender == slate.staker, \"Only the original staker can withdraw this stake\");\r\n        require(slate.stake > 0, \"Stake has already been withdrawn\");\r\n\r\n        // Update slate and transfer tokens\r\n        slates[slateID].stake = 0;\r\n        require(token.transfer(slate.staker, slate.stake), \"Failed to transfer tokens\");\r\n\r\n        emit StakeWithdrawn(slateID, slate.staker, slate.stake);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     @dev Deposit `numToken` tokens into the Gatekeeper to use in voting\r\n     Assumes that `msg.sender` has approved the Gatekeeper to spend on their behalf\r\n     @param numTokens The number of tokens to devote to voting\r\n     */\r\n    function depositVoteTokens(uint numTokens) public returns(bool) {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        address voter = msg.sender;\r\n\r\n        // Voter must have enough tokens\r\n        require(token.balanceOf(msg.sender) >= numTokens, \"Insufficient token balance\");\r\n\r\n        // Transfer tokens to increase the voter's balance by `numTokens`\r\n        uint originalBalance = voteTokenBalance[voter];\r\n        voteTokenBalance[voter] = originalBalance.add(numTokens);\r\n\r\n        // Must successfully transfer tokens from voter to this contract\r\n        require(token.transferFrom(voter, address(this), numTokens), \"Failed to transfer tokens\");\r\n\r\n        emit VotingTokensDeposited(voter, numTokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @dev Withdraw `numTokens` vote tokens to the caller and decrease voting power\r\n    @param numTokens The number of tokens to withdraw\r\n     */\r\n    function withdrawVoteTokens(uint numTokens) public returns(bool) {\r\n        require(commitPeriodActive() == false, \"Tokens locked during voting\");\r\n\r\n        address voter = msg.sender;\r\n\r\n        uint votingRights = voteTokenBalance[voter];\r\n        require(votingRights >= numTokens, \"Insufficient vote token balance\");\r\n\r\n        // Transfer tokens to decrease the voter's balance by `numTokens`\r\n        voteTokenBalance[voter] = votingRights.sub(numTokens);\r\n\r\n        require(token.transfer(voter, numTokens), \"Failed to transfer tokens\");\r\n\r\n        emit VotingTokensWithdrawn(voter, numTokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Set a delegate account that can vote on behalf of the voter\r\n     @param _delegate The account being delegated to\r\n     */\r\n    function delegateVotingRights(address _delegate) public returns(bool) {\r\n        address voter = msg.sender;\r\n        require(voter != _delegate, \"Delegate and voter cannot be equal\");\r\n\r\n        delegate[voter] = _delegate;\r\n\r\n        emit VotingRightsDelegated(voter, _delegate);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     @dev Submit a commitment for the current ballot\r\n     @param voter The voter to commit for\r\n     @param commitHash The hash representing the voter's vote choices\r\n     @param numTokens The number of vote tokens to use\r\n     */\r\n    function commitBallot(address voter, bytes32 commitHash, uint numTokens) public {\r\n        uint epochNumber = currentEpochNumber();\r\n\r\n        require(commitPeriodActive(), \"Commit period not active\");\r\n\r\n        require(didCommit(epochNumber, voter) == false, \"Voter has already committed for this ballot\");\r\n        require(commitHash != 0, \"Cannot commit zero hash\");\r\n\r\n        address committer = msg.sender;\r\n\r\n        // Must be a delegate if not the voter\r\n        if (committer != voter) {\r\n            require(committer == delegate[voter], \"Not a delegate\");\r\n            require(voteTokenBalance[voter] >= numTokens, \"Insufficient tokens\");\r\n        } else {\r\n            // If the voter doesn't have enough tokens for voting, deposit more\r\n            if (voteTokenBalance[voter] < numTokens) {\r\n                uint remainder = numTokens.sub(voteTokenBalance[voter]);\r\n                depositVoteTokens(remainder);\r\n            }\r\n        }\r\n\r\n        assert(voteTokenBalance[voter] >= numTokens);\r\n\r\n        // Set the voter's commitment for the current ballot\r\n        Ballot storage ballot = ballots[epochNumber];\r\n        VoteCommitment memory commitment = VoteCommitment({\r\n            commitHash: commitHash,\r\n            numTokens: numTokens,\r\n            committed: true,\r\n            revealed: false\r\n        });\r\n\r\n        ballot.commitments[voter] = commitment;\r\n\r\n        emit BallotCommitted(epochNumber, committer, voter, numTokens, commitHash);\r\n    }\r\n\r\n    /**\r\n     @dev Return true if the voter has committed for the given epoch\r\n     @param epochNumber The epoch to check\r\n     @param voter The voter's address\r\n     */\r\n    function didCommit(uint epochNumber, address voter) public view returns(bool) {\r\n        return ballots[epochNumber].commitments[voter].committed;\r\n    }\r\n\r\n    /**\r\n     @dev Get the commit hash for a given voter and epoch. Revert if voter has not committed yet.\r\n     @param epochNumber The epoch to check\r\n     @param voter The voter's address\r\n     */\r\n    function getCommitHash(uint epochNumber, address voter) public view returns(bytes32) {\r\n        VoteCommitment memory v = ballots[epochNumber].commitments[voter];\r\n        require(v.committed, \"Voter has not committed for this ballot\");\r\n\r\n        return v.commitHash;\r\n    }\r\n\r\n    /**\r\n     @dev Reveal a given voter's choices for the current ballot and record their choices\r\n     @param voter The voter's address\r\n     @param resources The contests to vote on\r\n     @param firstChoices The corresponding first choices\r\n     @param secondChoices The corresponding second choices\r\n     @param salt The salt used to generate the original commitment\r\n     */\r\n    function revealBallot(\r\n        uint256 epochNumber,\r\n        address voter,\r\n        address[] memory resources,\r\n        uint[] memory firstChoices,\r\n        uint[] memory secondChoices,\r\n        uint salt\r\n    ) public {\r\n        uint256 epochTime = now.sub(epochStart(epochNumber));\r\n        require(\r\n            (REVEAL_PERIOD_START <= epochTime) && (epochTime < EPOCH_LENGTH),\r\n            \"Reveal period not active\"\r\n        );\r\n\r\n        require(voter != address(0), \"Voter address cannot be zero\");\r\n        require(resources.length == firstChoices.length, \"All inputs must have the same length\");\r\n        require(firstChoices.length == secondChoices.length, \"All inputs must have the same length\");\r\n\r\n        require(didCommit(epochNumber, voter), \"Voter has not committed\");\r\n        require(didReveal(epochNumber, voter) == false, \"Voter has already revealed\");\r\n\r\n\r\n        // calculate the hash\r\n        bytes memory buf;\r\n        uint votes = resources.length;\r\n        for (uint i = 0; i < votes; i++) {\r\n            buf = abi.encodePacked(\r\n                buf,\r\n                resources[i],\r\n                firstChoices[i],\r\n                secondChoices[i]\r\n            );\r\n        }\r\n        buf = abi.encodePacked(buf, salt);\r\n        bytes32 hashed = keccak256(buf);\r\n\r\n        Ballot storage ballot = ballots[epochNumber];\r\n\r\n        // compare to the stored data\r\n        VoteCommitment memory v = ballot.commitments[voter];\r\n        require(hashed == v.commitHash, \"Submitted ballot does not match commitment\");\r\n\r\n        // Update tally for each contest\r\n        for (uint i = 0; i < votes; i++) {\r\n            address resource = resources[i];\r\n\r\n            // get the contest for the current resource\r\n            Contest storage contest = ballot.contests[resource];\r\n\r\n            // Increment totals for first and second choice slates\r\n            uint firstChoice = firstChoices[i];\r\n            uint secondChoice = secondChoices[i];\r\n\r\n            // Update first choice standings\r\n            if (slates[firstChoice].status == SlateStatus.Staked) {\r\n                SlateVotes storage firstChoiceSlate = contest.votes[firstChoice];\r\n                contest.totalVotes = contest.totalVotes.add(v.numTokens);\r\n                uint256 newCount = firstChoiceSlate.firstChoiceVotes.add(v.numTokens);\r\n\r\n                // Update first choice standings\r\n                if (firstChoice == contest.voteLeader) {\r\n                    // Leader is still the leader\r\n                    contest.leaderVotes = newCount;\r\n                } else if (newCount > contest.leaderVotes) {\r\n                    // This slate is now the leader, and the previous leader is now the runner-up\r\n                    contest.voteRunnerUp = contest.voteLeader;\r\n                    contest.runnerUpVotes = contest.leaderVotes;\r\n\r\n                    contest.voteLeader = firstChoice;\r\n                    contest.leaderVotes = newCount;\r\n                } else if (newCount > contest.runnerUpVotes) {\r\n                    // This slate overtook the previous runner-up\r\n                    contest.voteRunnerUp = firstChoice;\r\n                    contest.runnerUpVotes = newCount;\r\n                }\r\n\r\n                firstChoiceSlate.firstChoiceVotes = newCount;\r\n\r\n                // Update second choice standings\r\n                if (slates[secondChoice].status == SlateStatus.Staked) {\r\n                    SlateVotes storage secondChoiceSlate = contest.votes[secondChoice];\r\n                    secondChoiceSlate.totalSecondChoiceVotes = secondChoiceSlate.totalSecondChoiceVotes.add(v.numTokens);\r\n                    firstChoiceSlate.secondChoiceVotes[secondChoice] = firstChoiceSlate.secondChoiceVotes[secondChoice].add(v.numTokens);\r\n                }\r\n            }\r\n        }\r\n\r\n        // update state\r\n        ballot.commitments[voter].revealed = true;\r\n\r\n        emit BallotRevealed(epochNumber, voter, v.numTokens);\r\n    }\r\n\r\n    /**\r\n    @dev Reveal ballots for multiple voters\r\n     */\r\n    function revealManyBallots(\r\n        uint256 epochNumber,\r\n        address[] memory _voters,\r\n        bytes[] memory _ballots,\r\n        uint[] memory _salts\r\n    ) public {\r\n        uint numBallots = _voters.length;\r\n        require(\r\n            _salts.length == _voters.length && _ballots.length == _voters.length,\r\n            \"Inputs must have the same length\"\r\n        );\r\n\r\n        for (uint i = 0; i < numBallots; i++) {\r\n            // extract resources, firstChoices, secondChoices from the ballot\r\n            (\r\n                address[] memory resources,\r\n                uint[] memory firstChoices,\r\n                uint[] memory secondChoices\r\n            ) = abi.decode(_ballots[i], (address[], uint[], uint[]));\r\n\r\n            revealBallot(epochNumber, _voters[i], resources, firstChoices, secondChoices, _salts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Get the number of first-choice votes cast for the given slate and resource\r\n     @param epochNumber The epoch\r\n     @param resource The resource\r\n     @param slateID The slate\r\n     */\r\n    function getFirstChoiceVotes(uint epochNumber, address resource, uint slateID) public view returns(uint) {\r\n        SlateVotes storage v = ballots[epochNumber].contests[resource].votes[slateID];\r\n        return v.firstChoiceVotes;\r\n    }\r\n\r\n    /**\r\n     @dev Get the number of second-choice votes cast for the given slate and resource\r\n     @param epochNumber The epoch\r\n     @param resource The resource\r\n     @param slateID The slate\r\n     */\r\n    function getSecondChoiceVotes(uint epochNumber, address resource, uint slateID) public view returns(uint) {\r\n        // for each option that isn't this one, get the second choice votes\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n        uint numSlates = contest.stakedSlates.length;\r\n        uint votes = 0;\r\n        for (uint i = 0; i < numSlates; i++) {\r\n            uint otherSlateID = contest.stakedSlates[i];\r\n            if (otherSlateID != slateID) {\r\n                SlateVotes storage v = contest.votes[otherSlateID];\r\n                // get second-choice votes for the target slate\r\n                votes = votes.add(v.secondChoiceVotes[slateID]);\r\n            }\r\n        }\r\n        return votes;\r\n    }\r\n\r\n    /**\r\n     @dev Return true if the voter has revealed for the given epoch\r\n     @param epochNumber The epoch\r\n     @param voter The voter's address\r\n     */\r\n    function didReveal(uint epochNumber, address voter) public view returns(bool) {\r\n        return ballots[epochNumber].commitments[voter].revealed;\r\n    }\r\n\r\n    /**\r\n     @dev Finalize contest, triggering a vote count if necessary, and update the status of the\r\n     contest.\r\n\r\n     If there is a single slate, it automatically wins. Otherwise, count votes.\r\n     Count the first choice votes for each slate. If a slate has more than 50% of the votes,\r\n     then it wins and the vote is finalized. Otherwise, wait for a runoff. If no\r\n     votes are counted, finalize without a winner.\r\n\r\n     @param epochNumber The epoch\r\n     @param resource The resource to finalize for\r\n     */\r\n    function finalizeContest(uint epochNumber, address resource) public {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n\r\n        // Finalization must be after the vote period (i.e when the given epoch is over)\r\n        require(currentEpochNumber() > epochNumber, \"Contest epoch still active\");\r\n\r\n        // Make sure the ballot has a contest for this resource\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n        require(contest.status == ContestStatus.Active || contest.status == ContestStatus.NoContest,\r\n            \"Either no contest is in progress for this resource, or it has been finalized\");\r\n\r\n        // A single staked slate in the contest automatically wins\r\n        if (contest.status == ContestStatus.NoContest) {\r\n            uint256 winningSlate = contest.stakedSlates[0];\r\n            assert(slates[winningSlate].status == SlateStatus.Staked);\r\n\r\n            contest.winner = winningSlate;\r\n            contest.status = ContestStatus.Finalized;\r\n\r\n            acceptSlate(winningSlate);\r\n            emit ContestAutomaticallyFinalized(epochNumber, resource, winningSlate);\r\n            return;\r\n        }\r\n\r\n        // no votes\r\n        if (contest.totalVotes > 0) {\r\n            uint256 winnerVotes = contest.leaderVotes;\r\n\r\n            // If the winner has more than 50%, we are done\r\n            // Otherwise, trigger a runoff\r\n            if (winnerVotes.mul(2) > contest.totalVotes) {\r\n                contest.winner = contest.voteLeader;\r\n                acceptSlate(contest.winner);\r\n\r\n                contest.status = ContestStatus.Finalized;\r\n                emit VoteFinalized(epochNumber, resource, contest.winner, winnerVotes, contest.totalVotes);\r\n            } else {\r\n                emit VoteFailed(epochNumber, resource, contest.voteLeader, winnerVotes, contest.voteRunnerUp, contest.runnerUpVotes, contest.totalVotes);\r\n                _finalizeRunoff(epochNumber, resource);\r\n            }\r\n        } else {\r\n            // no one voted\r\n            contest.status = ContestStatus.Finalized;\r\n            emit ContestFinalizedWithoutWinner(epochNumber, resource);\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Return the status of the specified contest\r\n     */\r\n    function contestStatus(uint epochNumber, address resource) public view returns(ContestStatus) {\r\n        return ballots[epochNumber].contests[resource].status;\r\n    }\r\n\r\n    /**\r\n     @dev Return the IDs of the slates (staked and unstaked) associated with the contest\r\n     */\r\n    function contestSlates(uint epochNumber, address resource) public view returns(uint[] memory) {\r\n        return ballots[epochNumber].contests[resource].slates;\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Get the details of the specified contest\r\n     */\r\n    function contestDetails(uint256 epochNumber, address resource) external view\r\n        returns(\r\n            ContestStatus status,\r\n            uint256[] memory allSlates,\r\n            uint256[] memory stakedSlates,\r\n            uint256 lastStaked,\r\n            uint256 voteWinner,\r\n            uint256 voteRunnerUp,\r\n            uint256 winner\r\n        ) {\r\n        Contest memory c =  ballots[epochNumber].contests[resource];\r\n\r\n        status = c.status;\r\n        allSlates = c.slates;\r\n        stakedSlates = c.stakedSlates;\r\n        lastStaked = c.lastStaked;\r\n        voteWinner = c.voteLeader;\r\n        voteRunnerUp = c.voteRunnerUp;\r\n        winner = c.winner;\r\n    }\r\n\r\n    /**\r\n     @dev Trigger a runoff and update the status of the contest\r\n\r\n     Revert if a runoff is not pending.\r\n     Eliminate all slates but the top two from the initial vote. Re-count, including the\r\n     second-choice votes for the top two slates. The slate with the most votes wins. In case\r\n     of a tie, the earliest slate submitted (slate with the lowest ID) wins.\r\n\r\n     @param epochNumber The epoch\r\n     @param resource The resource to count votes for\r\n     */\r\n    function _finalizeRunoff(uint epochNumber, address resource) internal {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n\r\n        uint voteLeader = contest.voteLeader;\r\n        uint voteRunnerUp = contest.voteRunnerUp;\r\n\r\n        // Get the number of second-choice votes for the top two choices, subtracting\r\n        // any second choice votes where the first choice was for one of the top two\r\n        SlateVotes storage leader = contest.votes[voteLeader];\r\n        SlateVotes storage runnerUp = contest.votes[voteRunnerUp];\r\n\r\n        uint256 secondChoiceVotesForLeader = leader.totalSecondChoiceVotes\r\n            .sub(runnerUp.secondChoiceVotes[voteLeader]).sub(leader.secondChoiceVotes[voteLeader]);\r\n\r\n        uint256 secondChoiceVotesForRunnerUp = runnerUp.totalSecondChoiceVotes\r\n            .sub(leader.secondChoiceVotes[voteRunnerUp]).sub(runnerUp.secondChoiceVotes[voteRunnerUp]);\r\n\r\n        uint256 leaderTotal = contest.leaderVotes.add(secondChoiceVotesForLeader);\r\n        uint256 runnerUpTotal = contest.runnerUpVotes.add(secondChoiceVotesForRunnerUp);\r\n\r\n\r\n        // Tally for the runoff\r\n        uint runoffWinner = 0;\r\n        uint runoffWinnerVotes = 0;\r\n        uint runoffLoser = 0;\r\n        uint runoffLoserVotes = 0;\r\n\r\n        // Original winner has more votes, or it's tied and the original winner has a smaller ID\r\n        if ((leaderTotal > runnerUpTotal) ||\r\n           ((leaderTotal == runnerUpTotal) &&\r\n            (voteLeader < voteRunnerUp)\r\n            )) {\r\n            runoffWinner = voteLeader;\r\n            runoffWinnerVotes = leaderTotal;\r\n            runoffLoser = voteRunnerUp;\r\n            runoffLoserVotes = runnerUpTotal;\r\n        } else {\r\n            runoffWinner = voteRunnerUp;\r\n            runoffWinnerVotes = runnerUpTotal;\r\n            runoffLoser = voteLeader;\r\n            runoffLoserVotes = leaderTotal;\r\n        }\r\n\r\n        // Update state\r\n        contest.winner = runoffWinner;\r\n        contest.status = ContestStatus.Finalized;\r\n        acceptSlate(runoffWinner);\r\n\r\n        emit RunoffFinalized(epochNumber, resource, runoffWinner, runoffWinnerVotes, runoffLoser, runoffLoserVotes);\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Send tokens of the rejected slates to the token capacitor.\r\n     @param epochNumber The epoch\r\n     @param resource The resource\r\n     */\r\n    function donateChallengerStakes(uint256 epochNumber, address resource, uint256 startIndex, uint256 count) public {\r\n        Contest storage contest = ballots[epochNumber].contests[resource];\r\n        require(contest.status == ContestStatus.Finalized, \"Contest is not finalized\");\r\n\r\n        uint256 numSlates = contest.stakedSlates.length;\r\n        require(contest.stakesDonated != numSlates, \"All stakes donated\");\r\n\r\n        // If there are still stakes to be donated, continue\r\n        require(startIndex == contest.stakesDonated, \"Invalid start index\");\r\n\r\n        uint256 endIndex = startIndex.add(count);\r\n        require(endIndex <= numSlates, \"Invalid end index\");\r\n\r\n        address stakeDonationAddress = parameters.getAsAddress(\"stakeDonationAddress\");\r\n        IDonationReceiver donationReceiver = IDonationReceiver(stakeDonationAddress);\r\n        bytes memory stakeDonationHash = \"Qmepxeh4KVkyHYgt3vTjmodB5RKZgUEmdohBZ37oKXCUCm\";\r\n\r\n        for (uint256 i = startIndex; i < endIndex; i++) {\r\n            uint256 slateID = contest.stakedSlates[i];\r\n            Slate storage slate = slates[slateID];\r\n            if (slate.status != SlateStatus.Accepted) {\r\n                uint256 donationAmount = slate.stake;\r\n                slate.stake = 0;\r\n\r\n                // Only donate for non-zero amounts\r\n                if (donationAmount > 0) {\r\n                    require(\r\n                        token.approve(address(donationReceiver), donationAmount),\r\n                        \"Failed to approve Gatekeeper to spend tokens\"\r\n                    );\r\n                    donationReceiver.donate(address(this), donationAmount, stakeDonationHash);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update state\r\n        contest.stakesDonated = endIndex;\r\n    }\r\n\r\n    /**\r\n     @dev Return the ID of the winning slate for the given epoch and resource\r\n     Revert if the vote has not been finalized yet.\r\n     @param epochNumber The epoch\r\n     @param resource The resource of interest\r\n     */\r\n    function getWinningSlate(uint epochNumber, address resource) public view returns(uint) {\r\n        Contest storage c = ballots[epochNumber].contests[resource];\r\n        require(c.status == ContestStatus.Finalized, \"Vote is not finalized yet\");\r\n\r\n        return c.winner;\r\n    }\r\n\r\n\r\n    // ACCESS CONTROL\r\n    /**\r\n    @dev Request permission to perform the action described in the metadataHash\r\n    @param metadataHash A reference to metadata about the action\r\n    */\r\n    function requestPermission(bytes memory metadataHash) public returns(uint) {\r\n        require(isCurrentGatekeeper(), \"Not current gatekeeper\");\r\n        require(metadataHash.length > 0, \"metadataHash cannot be empty\");\r\n        address resource = msg.sender;\r\n        uint256 epochNumber = currentEpochNumber();\r\n\r\n        require(slateSubmissionPeriodActive(resource), \"Submission period not active\");\r\n\r\n        // If the request is created in epoch n, expire at the start of epoch n + 2\r\n        uint256 expirationTime = epochStart(epochNumber.add(2));\r\n\r\n        // Create new request\r\n        Request memory r = Request({\r\n            metadataHash: metadataHash,\r\n            resource: resource,\r\n            approved: false,\r\n            expirationTime: expirationTime,\r\n            epochNumber: epochNumber\r\n        });\r\n\r\n        // Record request and return its ID\r\n        uint requestID = requestCount();\r\n        requests.push(r);\r\n\r\n        emit PermissionRequested(epochNumber, resource, requestID, metadataHash);\r\n        return requestID;\r\n    }\r\n\r\n    /**\r\n    @dev Update a slate and its associated requests\r\n    @param slateID The slate to update\r\n     */\r\n    function acceptSlate(uint slateID) private {\r\n        // Mark the slate as accepted\r\n        Slate storage s = slates[slateID];\r\n        s.status = SlateStatus.Accepted;\r\n\r\n        // Record the incumbent\r\n        if (incumbent[s.resource] != s.recommender) {\r\n            incumbent[s.resource] = s.recommender;\r\n        }\r\n\r\n        // mark all of its requests as approved\r\n        uint[] memory requestIDs = s.requests;\r\n        for (uint i = 0; i < requestIDs.length; i++) {\r\n            uint requestID = requestIDs[i];\r\n            requests[requestID].approved = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev Return true if the requestID has been approved via slate governance and has not expired\r\n    @param requestID The ID of the request to check\r\n     */\r\n    function hasPermission(uint requestID) public view returns(bool) {\r\n        return requests[requestID].approved && now < requests[requestID].expirationTime;\r\n    }\r\n\r\n\r\n    // MISCELLANEOUS GETTERS\r\n    function slateCount() public view returns(uint256) {\r\n        return slates.length;\r\n    }\r\n\r\n    function requestCount() public view returns (uint256) {\r\n        return requests.length;\r\n    }\r\n\r\n    /**\r\n    @dev Return the slate submission deadline for the given resource\r\n    @param epochNumber The epoch\r\n    @param resource The resource\r\n     */\r\n    function slateSubmissionDeadline(uint256 epochNumber, address resource) public view returns(uint256) {\r\n        Contest memory contest = ballots[epochNumber].contests[resource];\r\n        uint256 offset = (contest.lastStaked.add(COMMIT_PERIOD_START)).div(2);\r\n\r\n        return epochStart(epochNumber).add(offset);\r\n    }\r\n\r\n    /**\r\n    @dev Return true if the slate submission period is active for the given resource and the\r\n     current epoch.\r\n     */\r\n    function slateSubmissionPeriodActive(address resource) public view returns(bool) {\r\n        uint256 epochNumber = currentEpochNumber();\r\n        uint256 start = epochStart(epochNumber).add(SLATE_SUBMISSION_PERIOD_START);\r\n        uint256 end = slateSubmissionDeadline(epochNumber, resource);\r\n\r\n        return (start <= now) && (now < end);\r\n    }\r\n\r\n    /**\r\n    @dev Return true if the commit period is active for the current epoch\r\n     */\r\n    function commitPeriodActive() private view returns(bool) {\r\n        uint256 epochTime = now.sub(epochStart(currentEpochNumber()));\r\n        return (COMMIT_PERIOD_START <= epochTime) && (epochTime < REVEAL_PERIOD_START);\r\n    }\r\n\r\n    /**\r\n    @dev Return true if this is the Gatekeeper currently pointed to by the ParameterStore\r\n     */\r\n    function isCurrentGatekeeper() public view returns(bool) {\r\n        return parameters.getAsAddress(\"gatekeeperAddress\") == address(this);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"getWinningSlate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"depositVoteTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"}],\"name\":\"slateRequests\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawVoteTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"contestSlates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"delegateVotingRights\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"}],\"name\":\"getFirstChoiceVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"requestPermission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"finalizeContest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"donateChallengerStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"commitBallot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"requestIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"recommendSlate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"didCommit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"resources\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"firstChoices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"secondChoices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"revealBallot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ballots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"created\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"}],\"name\":\"getSecondChoiceVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"didReveal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMIT_PERIOD_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getCommitHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"contract ParameterStore\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slateCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REVEAL_PERIOD_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"slateSubmissionPeriodActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"slateSubmissionDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"contestDetails\",\"outputs\":[{\"internalType\":\"enum Gatekeeper.ContestStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"allSlates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakedSlates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteRunnerUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"epochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EPOCH_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"contestStatus\",\"outputs\":[{\"internalType\":\"enum Gatekeeper.ContestStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_voters\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_ballots\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_salts\",\"type\":\"uint256[]\"}],\"name\":\"revealManyBallots\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"incumbent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SLATE_SUBMISSION_PERIOD_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCurrentGatekeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recommender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"},{\"internalType\":\"enum Gatekeeper.SlateStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"contract ParameterStore\",\"name\":\"_parameters\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"PermissionRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recommender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"requestIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadataHash\",\"type\":\"bytes\"}],\"name\":\"SlateCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"SlateStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"VotingTokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"VotingTokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"VotingRightsDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"committer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"}],\"name\":\"BallotCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"BallotRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningSlate\",\"type\":\"uint256\"}],\"name\":\"ContestAutomaticallyFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"}],\"name\":\"ContestFinalizedWithoutWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningSlate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnerVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"}],\"name\":\"VoteFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leadingSlate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leaderVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"runnerUpSlate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"runnerUpVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"}],\"name\":\"VoteFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningSlate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnerVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"losingSlate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loserVotes\",\"type\":\"uint256\"}],\"name\":\"RunoffFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slateID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"}]","ContractName":"Gatekeeper","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005bdc82900000000000000000000000006a43334331dc689318af551b0cfd624a8b11a70b000000000000000000000000d56dac73a4d6766464b38ec6d91eb45ce7457c44","Library":"","SwarmSource":"bzzr://618c6c60497718c8d41260b9e067689018e9c0510e377e8259fc1744368124e1"}]}