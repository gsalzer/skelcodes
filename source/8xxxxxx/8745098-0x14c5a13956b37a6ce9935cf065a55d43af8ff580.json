{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IGovernanceRegistry.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n/**\r\n * @title Governance Registry Interface\r\n */\r\ninterface IGovernanceRegistry {\r\n    \r\n    /**\r\n     * @return true if @param account is a signee.\r\n     */\r\n    function isSignee(address account) external view returns (bool);\r\n\r\n    /**\r\n     * @return true if @param account is a vault.\r\n     */\r\n    function isVault(address account) external view returns (bool) ;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n/**\r\n * @title Token Interface\r\n * @dev Exposes token functionality\r\n */\r\ninterface IToken {\r\n\r\n    function burn(uint256 amount) external ;\r\n\r\n    function mint(address account, uint256 amount) external ;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/governance/Minter.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Minter\r\n * @dev Minter contract for the AWG tokens.\r\n */\r\ncontract Minter {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public index;\r\n\r\n    /**\r\n     * @dev Fired when a vault calls `createMintRequest`.\r\n     */\r\n    event MintRequestCreated(\r\n        address indexed vault, \r\n        uint256 indexed id, \r\n        address indexed receiver, \r\n        bytes32 barId,\r\n        uint256 barSize,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Fired when a vault calls `signMintRequest`.\r\n     */\r\n    event MintRequestSigned(\r\n        address indexed signer, \r\n        uint256 indexed id, \r\n        address indexed vault, \r\n        address receiver, \r\n        bytes32 barId,\r\n        uint256 barSize,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Holds the data required for an actual token minting.\r\n     */\r\n    struct MintRequest{\r\n        /**\r\n         * @dev Autoincremented from 'index'.\r\n         */\r\n        uint256 id;\r\n\r\n        /**\r\n         * @dev Who will get the minted token.\r\n         */\r\n        address receiver; \r\n\r\n        /**\r\n         * @dev Who initiated the mint transaction.\r\n         */\r\n        address vault;\r\n\r\n        /**\r\n         * @dev How many tokens are minted.\r\n         */\r\n        uint256 value;\r\n\r\n        /**\r\n         * @dev Gold bar identifier.\r\n         */\r\n        bytes32 barId;\r\n\r\n        /**\r\n         * @dev Size of gold bar.\r\n         */\r\n        uint256 barSize;\r\n\r\n        /**\r\n         * @dev Indicates if the transaction was signed by a signee.\r\n         */\r\n        bool signed;\r\n    }\r\n\r\n    /**\r\n     * @dev Holds all mint requests initialised by the vaults.\r\n     */\r\n    mapping (uint256 => MintRequest) public requests;\r\n\r\n    /**\r\n     * @dev Reference to governance registry contract.\r\n     */\r\n    IGovernanceRegistry public registry;\r\n\r\n    /**\r\n     * @dev Reference to minted token contract.\r\n     */\r\n    IToken public token;\r\n\r\n    /**\r\n     * @param governanceRegistry Deployed address of the Governance Registry smart contract.\r\n     * @param mintedToken Specifies the minted token address.     \r\n     */\r\n    constructor(IGovernanceRegistry governanceRegistry, IToken mintedToken) public {\r\n        registry = governanceRegistry;\r\n        token = mintedToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialises a mint request.\r\n     * @dev Actual minting will hapen only after `signMintRequest` is called.\r\n     * @param barId Use web3.utils.fromAscii(string).\r\n     */\r\n    function createMintRequest(address receiver, bytes32 barId, uint256 barSize, uint256 value) onlyVault external {\r\n        index = index.add(1);\r\n        requests[index] = MintRequest(index, receiver, msg.sender, value, barId, barSize, false);\r\n        emit MintRequestCreated(msg.sender, index, receiver, barId, barSize, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Signs a mint request.\r\n     * @dev Mints the amount of token specified in the `MintRequest` struct.\r\n     */\r\n    function signMintRequest(uint256 id) onlySignee external {\r\n        MintRequest storage request = requests[id];\r\n        require(!request.signed, \"Request was signed previosuly\");\r\n        request.signed = true;\r\n        token.mint(request.receiver, request.value);\r\n        emit MintRequestSigned(\r\n            msg.sender, \r\n            request.id, \r\n            request.vault, \r\n            request.receiver, \r\n            request.barId,\r\n            request.barSize,\r\n            request.value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Only a vault can call a function with this modifier\r\n     */\r\n    modifier onlyVault() {\r\n        require(registry.isVault(msg.sender), \"Caller is not a vault\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Only a signee can call a function with this modifier\r\n     */\r\n    modifier onlySignee() {\r\n        require(registry.isSignee(msg.sender), \"Caller is not a signee\");\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"barId\",\"type\":\"bytes32\"},{\"name\":\"barSize\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"createMintRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requests\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"barId\",\"type\":\"bytes32\"},{\"name\":\"barSize\",\"type\":\"uint256\"},{\"name\":\"signed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"signMintRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"governanceRegistry\",\"type\":\"address\"},{\"name\":\"mintedToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"barId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"barSize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MintRequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"barId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"barSize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MintRequestSigned\",\"type\":\"event\"}]","ContractName":"Minter","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006ff91423f256a4db280f17af9842d6876f2f760800000000000000000000000032310f5cf83ba8ebb45cae9454e072a08850e057","Library":"","LicenseType":"None","SwarmSource":"bzzr://a541b29b1cca86f9e699590feb10c6a48b7cf77e633efe36cc632f26d57accfc"}]}