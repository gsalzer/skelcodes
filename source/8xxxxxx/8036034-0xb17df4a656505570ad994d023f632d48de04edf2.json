{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface INMR {\r\n\r\n    /* ERC20 Interface */\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /* NMR Special Interface */\r\n\r\n    // used for user balance management\r\n    function withdraw(address _from, address _to, uint256 _value) external returns(bool ok);\r\n\r\n    // used for migrating active stakes\r\n    function destroyStake(address _staker, bytes32 _tag, uint256 _tournamentID, uint256 _roundID) external returns (bool ok);\r\n\r\n    // used for disabling token upgradability\r\n    function createRound(uint256, uint256, uint256, uint256) external returns (bool ok);\r\n\r\n    // used for upgrading the token delegate logic\r\n    function createTournament(uint256 _newDelegate) external returns (bool ok);\r\n\r\n    // used like burn(uint256)\r\n    function mint(uint256 _value) external returns (bool ok);\r\n\r\n    // used like burnFrom(address, uint256)\r\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\r\n\r\n    // used to check if upgrade completed\r\n    function contractUpgradable() external view returns (bool);\r\n\r\n    function getTournament(uint256 _tournamentID) external view returns (uint256, uint256[] memory);\r\n\r\n    function getRound(uint256 _tournamentID, uint256 _roundID) external view returns (uint256, uint256, uint256);\r\n\r\n    function getStake(uint256 _tournamentID, uint256 _roundID, address _staker, bytes32 _tag) external view returns (uint256, uint256, bool, bool);\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\ncontract Manageable is Initializable, Ownable {\r\n    address private _manager;\r\n\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    /**\r\n     * @dev The Managable constructor sets the original `manager` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) initializer public {\r\n        Ownable.initialize(sender);\r\n        _manager = sender;\r\n        emit ManagementTransferred(address(0), _manager);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the manager.\r\n     */\r\n    function manager() public view returns (address) {\r\n        return _manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner or manager.\r\n     */\r\n    modifier onlyManagerOrOwner() {\r\n        require(isManagerOrOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner or manager of the contract.\r\n     */\r\n    function isManagerOrOwner() public view returns (bool) {\r\n        return (msg.sender == _manager || isOwner());\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\r\n     * @param newManager The address to transfer management to.\r\n     */\r\n    function transferManagement(address newManager) public onlyOwner {\r\n        require(newManager != address(0));\r\n        emit ManagementTransferred(_manager, newManager);\r\n        _manager = newManager;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\ncontract Relay is Manageable {\r\n\r\n    bool public active = true;\r\n    bool private _upgraded;\r\n\r\n    // set NMR token, 1M address, null address, burn address as constants\r\n    address private constant _TOKEN = address(\r\n        0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671\r\n    );\r\n    address private constant _ONE_MILLION_ADDRESS = address(\r\n        0x00000000000000000000000000000000000F4240\r\n    );    \r\n    address private constant _NULL_ADDRESS = address(\r\n        0x0000000000000000000000000000000000000000\r\n    );\r\n    address private constant _BURN_ADDRESS = address(\r\n        0x000000000000000000000000000000000000dEaD\r\n    );\r\n\r\n    /// @dev Throws if the address does not match the required conditions.\r\n    modifier isUser(address _user) {\r\n        require(\r\n            _user <= _ONE_MILLION_ADDRESS\r\n            && _user != _NULL_ADDRESS\r\n            && _user != _BURN_ADDRESS\r\n            , \"_from must be a user account managed by Numerai\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called after the relay is disabled.\r\n    modifier onlyActive() {\r\n        require(active, \"User account relay has been disabled\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Contructor function called at time of deployment\r\n    /// @param _owner The initial owner and manager of the relay\r\n    constructor(address _owner) public {\r\n        require(\r\n            address(this) == address(0xB17dF4a656505570aD994D023F632D48De04eDF2),\r\n            \"incorrect deployment address - check submitting account & nonce.\"\r\n        );\r\n\r\n        Manageable.initialize(_owner);\r\n    }\r\n\r\n    /// @notice Transfer NMR on behalf of a Numerai user\r\n    ///         Can only be called by Manager or Owner\r\n    /// @dev Can only be used on the first 1 million ethereum addresses\r\n    /// @param _from The user address\r\n    /// @param _to The recipient address\r\n    /// @param _value The amount of NMR in wei\r\n    function withdraw(address _from, address _to, uint256 _value) public onlyManagerOrOwner onlyActive isUser(_from) returns (bool ok) {\r\n        require(INMR(_TOKEN).withdraw(_from, _to, _value));\r\n        return true;\r\n    }\r\n\r\n    /// @notice Burn the NMR sent to address 0 and burn address\r\n    function burnZeroAddress() public {\r\n        uint256 amtZero = INMR(_TOKEN).balanceOf(_NULL_ADDRESS);\r\n        uint256 amtBurn = INMR(_TOKEN).balanceOf(_BURN_ADDRESS);\r\n        require(INMR(_TOKEN).withdraw(_NULL_ADDRESS, address(this), amtZero));\r\n        require(INMR(_TOKEN).withdraw(_BURN_ADDRESS, address(this), amtBurn));\r\n        uint256 amtThis = INMR(_TOKEN).balanceOf(address(this));\r\n        _burn(amtThis);\r\n    }\r\n\r\n    /// @notice Permanantly disable the relay contract\r\n    ///         Can only be called by Owner\r\n    function disable() public onlyOwner onlyActive {\r\n        active = false;\r\n    }\r\n\r\n    /// @notice Permanantly disable token upgradability\r\n    ///         Can only be called by Owner\r\n    function disableTokenUpgradability() public onlyOwner onlyActive {\r\n        require(INMR(_TOKEN).createRound(uint256(0),uint256(0),uint256(0),uint256(0)));\r\n    }\r\n\r\n    /// @notice Upgrade the token delegate logic.\r\n    ///         Can only be called by Owner\r\n    /// @param _newDelegate Address of the new delegate contract\r\n    function changeTokenDelegate(address _newDelegate) public onlyOwner onlyActive {\r\n        require(INMR(_TOKEN).createTournament(uint256(_newDelegate)));\r\n    }\r\n\r\n    /// @notice Get the address of the NMR token contract\r\n    /// @return The address of the NMR token contract\r\n    function token() external pure returns (address) {\r\n        return _TOKEN;\r\n    }\r\n\r\n    /// @notice Internal helper function to burn NMR\r\n    /// @dev If before the token upgrade, sends the tokens to address 0\r\n    ///      If after the token upgrade, calls the repurposed mint function to burn\r\n    /// @param _value The amount of NMR in wei\r\n    function _burn(uint256 _value) internal {\r\n        if (INMR(_TOKEN).contractUpgradable()) {\r\n            require(INMR(_TOKEN).transfer(address(0), _value));\r\n        } else {\r\n            require(INMR(_TOKEN).mint(_value), \"burn not successful\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnZeroAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTokenUpgradability\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManagerOrOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDelegate\",\"type\":\"address\"}],\"name\":\"changeTokenDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Relay","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"65535","ConstructorArguments":"000000000000000000000000249e479b571fea3de01f186cf22383a79b21ca7f","Library":"","SwarmSource":"bzzr://2b687279c89379764607ae985b367646374af5081dd69b19e46daafbbc2aad44"}]}