{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.9;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract OtcInterface {\r\n    function getOffer(uint id) external view returns (uint, ERC20, uint, ERC20);\r\n    function getBestOffer(ERC20 sellGem, ERC20 buyGem) external view returns(uint);\r\n    function getWorseOffer(uint id) external view returns(uint);\r\n    function take(bytes32 id, uint128 maxTakeAmount) external;\r\n}\r\n\r\n\r\ncontract WethInterface is ERC20 {\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\n\r\ncontract TradeEth2DAI {\r\n    // constants\r\n    uint constant BASE_TAKE_OFFERS = 2;\r\n    uint constant BASE_TRAVERSE_OFFERS = 6;\r\n    uint constant  MIN_TAKE_AMOUNT_DAI = 30;\r\n    uint constant  BIGGEST_MIN_TAKE_AMOUNT_DAI = 90;\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint constant MAX_TAKE_ORDERS = 5;\r\n    uint constant MAX_TRAVERSE_ORDERS = 20;\r\n    uint constant TAKE_ORDER_GAS_COST = 100000; //according to off chain checks.\r\n    \r\n    // values\r\n    uint public offerDAIFactor = 700; // $700 \r\n    address public admin;\r\n    uint constant INVALID_ID = uint(-1);\r\n    uint constant internal COMMON_DECIMALS = 18;\r\n    OtcInterface public otc = OtcInterface(0x39755357759cE0d7f32dC8dC45414CCa409AE24e);\r\n    WethInterface public wethToken = WethInterface(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    ERC20 public DAIToken = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    \r\n    \r\n    constructor() public {\r\n        require(wethToken.decimals() == COMMON_DECIMALS);\r\n    \r\n        admin = msg.sender;\r\n\r\n        require(DAIToken.approve(address(otc), 2**255));\r\n        require(wethToken.approve(address(otc), 2**255));\r\n    }\r\n\r\n    function() external payable {\r\n        \r\n    }\r\n    \r\n    function setOfferDAIFactor(uint factor) public {\r\n        offerDAIFactor = factor;    \r\n    }\r\n    \r\n    event TradeExecute(\r\n        address indexed sender,\r\n        bool isEthToDai,\r\n        uint srcAmount,\r\n        uint destAmount,\r\n        address destAddress\r\n    );\r\n\r\n    function tradeEthVsDAI(\r\n        uint numTakeOrders,\r\n        uint numTraverseOrders,\r\n        bool isEthToDai,\r\n        uint srcAmount\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        address payable dstAddress = msg.sender;\r\n        uint userTotalDestAmount;\r\n        \r\n        if (isEthToDai) {\r\n            require(msg.value == srcAmount);\r\n            wethToken.deposit.value(msg.value)();\r\n            userTotalDestAmount = takeOrders(wethToken, DAIToken, srcAmount, numTakeOrders, numTraverseOrders);\r\n            require(DAIToken.transfer(dstAddress, userTotalDestAmount));\r\n        } else {\r\n            //Dai To Eth\r\n            require(DAIToken.transferFrom(msg.sender, address(this), srcAmount));\r\n            userTotalDestAmount = takeOrders(DAIToken, wethToken, srcAmount, numTakeOrders, numTraverseOrders);\r\n            wethToken.withdraw(userTotalDestAmount);    \r\n            dstAddress.transfer(userTotalDestAmount);\r\n        }\r\n\r\n        emit TradeExecute(msg.sender, isEthToDai, srcAmount, userTotalDestAmount, dstAddress);\r\n    }\r\n\r\n    function getNextOffer(uint prevOfferId, bool isEthToDai) public view\r\n        returns(uint offerId, uint offerPayAmount, uint offerBuyAmount) \r\n    {\r\n        uint prevId = prevOfferId == 0 ? INVALID_ID : prevOfferId;       \r\n        \r\n        if(isEthToDai) {\r\n            // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n            return(getNextBestOffer(DAIToken, wethToken, 1, prevId));\r\n        }\r\n        \r\n        // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n        return(getNextBestOffer(wethToken, DAIToken, 1, prevId));\r\n    }\r\n    \r\n    struct OfferDescriptor {\r\n        uint payAmount;\r\n        uint buyAmount;\r\n        uint id;\r\n    }\r\n    \r\n    function showBestOffers1(bool isEthToDai, uint srcAmountTokenx10) public view\r\n        returns(uint destAmount, uint destAmountTokenx10, uint numTaken, uint numTraversed, uint [] memory offerIds, \r\n            uint maxTakes, uint maxTraverse, uint minTakeAmount) \r\n    {\r\n        OfferDescriptor [] memory offers;\r\n        (destAmount, numTaken, numTraversed, offers, maxTakes, maxTraverse, minTakeAmount) = findBestOffers(isEthToDai, (srcAmountTokenx10 * 10 ** 17), calcOfferLimits1);\r\n        \r\n        \r\n        destAmountTokenx10 = destAmount / 10 ** 17;\r\n        \r\n        uint i;\r\n        for (i; i < offers.length; i++) {\r\n            if(offers[i].id == 0) {\r\n                break;\r\n            }\r\n        }\r\n    \r\n        offerIds = new uint[](i);\r\n        for (i = 0; i < offerIds.length; i++) {\r\n            offerIds[i] = offers[i].id;\r\n        }\r\n    }\r\n    \r\n    function showBestOffers2(bool isEthToDai, uint srcAmountTokenx10) public view\r\n        returns(uint destAmount, uint destAmountTokenx10, uint numTaken, uint numTraversed, uint [] memory offerIds, \r\n            uint maxTakes, uint maxTraverse, uint minTakeAmount) \r\n    {\r\n        OfferDescriptor [] memory offers;\r\n        (destAmount, numTaken, numTraversed, offers, maxTakes, maxTraverse, minTakeAmount) = findBestOffers(isEthToDai, (srcAmountTokenx10 * 10 ** 17), calcOfferLimits2);\r\n        \r\n        destAmountTokenx10 = destAmount / 10 ** 17;\r\n        \r\n        uint i;\r\n        for (i; i < offers.length; i++) {\r\n            if(offers[i].id == 0) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        offerIds = new uint[](i);\r\n        for (i = 0; i < offerIds.length; i++) {\r\n            offerIds[i] = offers[i].id;\r\n        }\r\n    }\r\n    \r\n    \r\n    function showBestOffers3(bool isEthToDai, uint srcAmountTokenx10) public view\r\n        returns(uint destAmount, uint destAmountTokenx10, uint numTaken, uint numTraversed, uint [] memory offerIds, \r\n            uint maxTakes, uint maxTraverse, uint minTakeAmount) \r\n    {\r\n        OfferDescriptor [] memory offers;\r\n        (destAmount, numTaken, numTraversed, offers, maxTakes, maxTraverse, minTakeAmount) = findBestOffers(isEthToDai, (srcAmountTokenx10 * 10 ** 17), calcOfferLimits3);\r\n        \r\n        destAmountTokenx10 = destAmount / 10 ** 17;\r\n        \r\n        uint i;\r\n        for (i; i < offers.length; i++) {\r\n            if(offers[i].id == 0) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        offerIds = new uint[](i);\r\n        for (i = 0; i < offerIds.length; i++) {\r\n            offerIds[i] = offers[i].id;\r\n        }\r\n    }\r\n    \r\n    function findBestOffers(bool isEthToDai, uint srcAmount, function (bool, uint, uint, uint) view returns (uint, uint, uint) calcLim) \r\n        internal view\r\n        returns(uint totalDestAmount, uint numTaken, uint numTraversed, OfferDescriptor [] memory offers, uint remainingTakeOrders, uint maxTraverse, uint minAmount) \r\n    {\r\n        uint remainingSrcAmount = srcAmount;\r\n        offers = new OfferDescriptor[](MAX_TRAVERSE_ORDERS);\r\n        \r\n        ERC20 srcToken = isEthToDai ? wethToken : DAIToken;\r\n        ERC20 dstToken = isEthToDai ? DAIToken : wethToken;\r\n        \r\n        // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n        offers[0].id = otc.getBestOffer(dstToken, srcToken);\r\n        (offers[0].payAmount, , offers[0].buyAmount, ) = otc.getOffer(offers[0].id);\r\n        \r\n        (remainingTakeOrders, maxTraverse, minAmount) = calcLim(isEthToDai, offers[0].payAmount, offers[0].buyAmount, srcAmount); \r\n        uint thisOffer;\r\n        numTraversed = 1;\r\n        // uint remainingTakeOrders = maxTakes;\r\n        \r\n        OfferDescriptor memory biggestSkippedOffer;\r\n        \r\n        for (uint i = 0; i < maxTraverse; ++i) {\r\n            thisOffer = numTaken;\r\n            \r\n            if (remainingSrcAmount < biggestSkippedOffer.payAmount) {\r\n                offers[numTaken].id = biggestSkippedOffer.id;\r\n                offers[numTaken].buyAmount = biggestSkippedOffer.payAmount * remainingSrcAmount / biggestSkippedOffer.buyAmount;\r\n                offers[numTaken].payAmount = remainingSrcAmount;\r\n                totalDestAmount += offers[numTaken].buyAmount;\r\n                ++numTaken;\r\n                remainingSrcAmount = 0;\r\n                break; \r\n            } else if (offers[numTaken].payAmount > remainingSrcAmount) {\r\n                offers[numTaken].buyAmount = offers[numTaken].payAmount * remainingSrcAmount / offers[numTaken].buyAmount;\r\n                offers[numTaken].payAmount = remainingSrcAmount;\r\n                totalDestAmount += offers[numTaken].buyAmount;\r\n                ++numTaken;\r\n                remainingSrcAmount = 0;\r\n                break;\r\n            } else if (remainingTakeOrders > 1 && \r\n                    minAmount < offers[numTaken].payAmount) \r\n            {\r\n                    totalDestAmount += offers[numTaken].buyAmount;\r\n                    remainingSrcAmount -= offers[numTaken].payAmount;\r\n                    --remainingTakeOrders;\r\n                    ++numTaken;\r\n            } else if (offers[numTaken].payAmount > biggestSkippedOffer.payAmount) {\r\n                biggestSkippedOffer.payAmount = offers[numTaken].payAmount;\r\n                biggestSkippedOffer.buyAmount = offers[numTaken].buyAmount;\r\n                biggestSkippedOffer.id = offers[numTaken].id;\r\n            }\r\n\r\n            offers[numTaken].id = otc.getWorseOffer(offers[thisOffer].id);\r\n            (offers[numTaken].payAmount, , offers[numTaken].buyAmount, ) = otc.getOffer(offers[numTaken].id);\r\n        \r\n            ++numTraversed;\r\n        }\r\n        \r\n        if (totalDestAmount == 0) numTaken = 0;\r\n        \r\n        if (remainingSrcAmount > 0) totalDestAmount = 0;\r\n    }\r\n    \r\n    function calcDaiAmount (bool isEthToDai, uint payAmount, uint buyAmount, uint srcAmount) public view returns (uint daiAmount, uint daiTokens) {\r\n        daiAmount = isEthToDai ? srcAmount * buyAmount / payAmount : srcAmount;\r\n        daiTokens = daiAmount / 10 ** 18;\r\n    }\r\n    \r\n    function calcOfferLimits1(bool isEthToDai, uint payAmount, uint buyAmount, uint srcAmount) internal view \r\n        returns(uint maxTakes, uint maxTraverse, uint minAmount) \r\n    {\r\n        uint daiSrcAmount;\r\n        (daiSrcAmount, ) = calcDaiAmount(isEthToDai, payAmount, buyAmount, srcAmount); \r\n        uint offerLevel = daiSrcAmount / 10 ** 18 / offerDAIFactor;\r\n        \r\n        maxTakes = BASE_TAKE_OFFERS + offerLevel;\r\n        maxTakes = maxTakes > MAX_TAKE_ORDERS ? MAX_TAKE_ORDERS : maxTakes;\r\n        maxTraverse = BASE_TRAVERSE_OFFERS + 2 * offerLevel;\r\n        maxTraverse = maxTraverse > MAX_TRAVERSE_ORDERS ? MAX_TRAVERSE_ORDERS : maxTraverse;\r\n        minAmount = srcAmount / maxTakes / 2;\r\n        minAmount = minAmount > BIGGEST_MIN_TAKE_AMOUNT_DAI ? BIGGEST_MIN_TAKE_AMOUNT_DAI : minAmount;\r\n    }\r\n    \r\n    function calcOfferLimits2(bool isEthToDai, uint payAmount, uint buyAmount, uint srcAmount) internal view \r\n        returns(uint maxTakes, uint maxTraverse, uint minAmount)\r\n    {\r\n        uint daiSrcAmount;\r\n        (daiSrcAmount, ) = calcDaiAmount(isEthToDai, payAmount, buyAmount, srcAmount); \r\n        uint offerLevel = daiSrcAmount / 10 ** 18 / offerDAIFactor;\r\n        \r\n        maxTakes = BASE_TAKE_OFFERS + offerLevel;\r\n        maxTakes = maxTakes > MAX_TAKE_ORDERS ? MAX_TAKE_ORDERS : maxTakes;\r\n        maxTraverse = BASE_TRAVERSE_OFFERS + 2 * offerLevel;\r\n        maxTraverse = maxTraverse > MAX_TRAVERSE_ORDERS ? MAX_TRAVERSE_ORDERS : maxTraverse;\r\n        minAmount = isEthToDai ? MIN_TAKE_AMOUNT_DAI * buyAmount / payAmount : MIN_TAKE_AMOUNT_DAI;\r\n    }\r\n\r\n    function calcOfferLimits3(bool isEthToDai, uint payAmount, uint buyAmount, uint srcAmount) internal view \r\n        returns(uint maxTakes, uint maxTraverse, uint minAmount) \r\n    {\r\n        uint daiSrcAmount;\r\n        (daiSrcAmount, ) = calcDaiAmount(isEthToDai, payAmount, buyAmount, srcAmount); \r\n        uint offerLevel = daiSrcAmount * 2 / 10 ** 18 / offerDAIFactor;\r\n        \r\n        maxTakes = BASE_TAKE_OFFERS + 1 + offerLevel;\r\n        maxTakes = maxTakes > MAX_TAKE_ORDERS ? MAX_TAKE_ORDERS : maxTakes;\r\n        maxTraverse = BASE_TRAVERSE_OFFERS + 2 + (2 * offerLevel);\r\n        maxTraverse = maxTraverse > MAX_TRAVERSE_ORDERS ? MAX_TRAVERSE_ORDERS : maxTraverse;\r\n        minAmount = srcAmount / maxTakes / 3;\r\n        minAmount = minAmount > BIGGEST_MIN_TAKE_AMOUNT_DAI ? BIGGEST_MIN_TAKE_AMOUNT_DAI : minAmount;\r\n    }\r\n    \r\n    function takeOrders(ERC20 srcToken, ERC20 dstToken, uint srcAmount, uint numTakeOrders, uint numTraverseOrders) \r\n        internal \r\n        returns(uint userTotalDestAmount)\r\n    {\r\n        uint remainingAmount = srcAmount;\r\n        uint destAmount;\r\n        uint offerId = INVALID_ID;\r\n        uint i;\r\n        \r\n        for (i = numTraverseOrders; i > 0; i--) {\r\n            //this loop to see cost of 'peeking' into order\r\n            (offerId, , ) = getNextBestOffer(dstToken, srcToken, remainingAmount / i, offerId);\r\n            \r\n            require(offerId > 0);\r\n        }\r\n        \r\n        for (i = numTakeOrders; i > 0; i--) {\r\n            \r\n            // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n            (offerId, , ) = getNextBestOffer(dstToken, srcToken, remainingAmount / i, offerId);\r\n            \r\n            require(offerId > 0);\r\n            \r\n            destAmount = takeMatchingOffer(remainingAmount / i, offerId);\r\n            userTotalDestAmount += destAmount;\r\n            remainingAmount -= (remainingAmount / i);\r\n        }\r\n    }\r\n    \r\n    function getNextBestOffer(\r\n        ERC20 offerSellGem,\r\n        ERC20 offerBuyGem,\r\n        uint payAmount,\r\n        uint prevOfferId\r\n    )\r\n        internal\r\n        view\r\n        returns(\r\n            uint offerId,\r\n            uint offerPayAmount,\r\n            uint offerBuyAmount\r\n        )\r\n    {\r\n        if (prevOfferId == INVALID_ID) {\r\n            offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\r\n        } else {\r\n            offerId = otc.getWorseOffer(prevOfferId);\r\n        }\r\n\r\n        (offerPayAmount, , offerBuyAmount, ) = otc.getOffer(offerId);\r\n\r\n        while (payAmount > offerBuyAmount) {\r\n            offerId = otc.getWorseOffer(offerId); // next best offer\r\n            if (offerId == 0) {\r\n                offerId = 0;\r\n                offerPayAmount = 0;\r\n                offerBuyAmount = 0;\r\n                break;\r\n            }\r\n            (offerPayAmount, , offerBuyAmount, ) = otc.getOffer(offerId);\r\n        }\r\n    }\r\n    \r\n    function takeOffer(uint payAmount, uint buyAmount, uint offerId) internal {\r\n        require(payAmount <= MAX_QTY);\r\n        otc.take(bytes32(offerId), uint128(buyAmount));  // Take the portion of the offer that we need\r\n        return;\r\n    }\r\n\r\n    function takeMatchingOffer(\r\n        uint srcAmount, \r\n        uint offerId\r\n    )\r\n        internal\r\n        returns(uint actualDestAmount)\r\n    {\r\n        uint offerPayAmt;\r\n        uint offerBuyAmt;\r\n\r\n        // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n        (offerPayAmt, , offerBuyAmt, ) = otc.getOffer(offerId);\r\n        \r\n        actualDestAmount = srcAmount * offerPayAmt / offerBuyAmt;\r\n\r\n        require(uint128(actualDestAmount) == actualDestAmount);\r\n        otc.take(bytes32(offerId), uint128(actualDestAmount));  // Take the portion of the offer that we need\r\n        return(actualDestAmount);\r\n    }\r\n    \r\n    function getEthToDaiOrders(uint numOrders) public view\r\n        returns(uint [] memory ethAmtTokens, uint [] memory daiAmtTokens, uint [] memory rateDaiDivEthx10, uint [] memory Ids) \r\n    {\r\n        uint offerId = INVALID_ID;\r\n        ethAmtTokens = new uint[](numOrders);\r\n        daiAmtTokens = new uint[](numOrders);    \r\n        rateDaiDivEthx10 = new uint[](numOrders);\r\n        Ids = new uint[](numOrders);\r\n        \r\n        uint offerBuyAmt;\r\n        uint offerPayAmt;\r\n        \r\n        for (uint i = 0; i < numOrders; i++) {\r\n            \r\n            (offerId, offerPayAmt, offerBuyAmt) = getNextBestOffer(DAIToken, wethToken, 1, offerId);\r\n            \r\n            ethAmtTokens[i] = offerBuyAmt / 10 ** 18;\r\n            daiAmtTokens[i] = offerPayAmt / 10 ** 18;\r\n            rateDaiDivEthx10[i] = (offerPayAmt * 10) / offerBuyAmt;\r\n            Ids[i] = offerId;\r\n            \r\n            if(offerId == 0) break;\r\n        }\r\n    }\r\n    \r\n    function getDaiToEthOrders(uint numOrders) public view\r\n        returns(uint [] memory daiAmtTokens, uint [] memory ethAmtTokens, uint [] memory rateDaiDivEthx10, uint [] memory Ids)\r\n    {\r\n        uint offerId = INVALID_ID;\r\n        daiAmtTokens = new uint[](numOrders);\r\n        ethAmtTokens = new uint[](numOrders);\r\n        rateDaiDivEthx10 = new uint[](numOrders);\r\n        Ids = new uint[](numOrders);\r\n        \r\n        uint offerBuyAmt;\r\n        uint offerPayAmt;\r\n\r\n        for (uint i = 0; i < numOrders; i++) {\r\n\r\n            (offerId, offerPayAmt, offerBuyAmt) = getNextBestOffer(wethToken, DAIToken, 1, offerId);\r\n\r\n            daiAmtTokens[i] = offerBuyAmt / 10 ** 18;\r\n            ethAmtTokens[i] = offerPayAmt / 10 ** 18;\r\n            rateDaiDivEthx10[i] = (offerPayAmt * 10) / offerBuyAmt;\r\n            Ids[i] = offerId;\r\n            \r\n            if(offerId == 0) break;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numOrders\",\"type\":\"uint256\"}],\"name\":\"getEthToDaiOrders\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ethAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"daiAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rateDaiDivEthx10\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Ids\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmountTokenx10\",\"type\":\"uint256\"}],\"name\":\"showBestOffers1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmountTokenx10\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTaken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTraversed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTakeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"calcDaiAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTakeOrders\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTraverseOrders\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"tradeEthVsDAI\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAIToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"otc\",\"outputs\":[{\"internalType\":\"contract OtcInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethToken\",\"outputs\":[{\"internalType\":\"contract WethInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factor\",\"type\":\"uint256\"}],\"name\":\"setOfferDAIFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prevOfferId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"}],\"name\":\"getNextOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerBuyAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmountTokenx10\",\"type\":\"uint256\"}],\"name\":\"showBestOffers2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmountTokenx10\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTaken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTraversed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTakeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmountTokenx10\",\"type\":\"uint256\"}],\"name\":\"showBestOffers3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmountTokenx10\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTaken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTraversed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxTakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTakeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"offerDAIFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numOrders\",\"type\":\"uint256\"}],\"name\":\"getDaiToEthOrders\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"daiAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ethAmtTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rateDaiDivEthx10\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Ids\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEthToDai\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destAddress\",\"type\":\"address\"}],\"name\":\"TradeExecute\",\"type\":\"event\"}]","ContractName":"TradeEth2DAI","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f6d7eed832e76e1314c28f33792bd726b0155df83652b27ff15030525b48aea2"}]}