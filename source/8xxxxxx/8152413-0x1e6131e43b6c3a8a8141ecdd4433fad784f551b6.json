{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract GMAMICO is Owned {\r\n    using SafeMath for uint256;\r\n    \r\n    constructor() public {\r\n        owner = 0xb636a5A167b603d4f75E485E4657e1dD5C2372aa;\r\n        contractAddress = address(this);\r\n    }\r\n    \r\n    address internal contractAddress;\r\n    \r\n    // Token Addresses'\r\n    address public GMAMAddress = 0x1e22C2bb045e032833D6EC3c7f3CAf5a8D74f137;\r\n    uint256 public GMAMDecimals = 5;\r\n    address public DAIAddress = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    address public TUSDAddress = 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\r\n\r\n    // If ICO is on\r\n    bool ICOActive;\r\n    \r\n    // Set ICO status\r\n    function setICOActve(bool _status) public onlyOwner {\r\n        ICOActive = _status;\r\n    }\r\n    \r\n    // Cost per token\r\n    uint256 public etherCost;\r\n    uint256 public stablecoinCost;\r\n    \r\n    // Update token Cost\r\n    function setCost(uint256 _etherCost, uint256 _stablecoinCost) public onlyOwner {\r\n        require(_stablecoinCost > 0 && _etherCost > 0);\r\n        etherCost = _etherCost;\r\n        stablecoinCost = _stablecoinCost;\r\n    }\r\n    \r\n    // Pay With Ether, uses fallback function\r\n    function () external payable {\r\n        require(ICOActive == true);\r\n        uint256 amount = msg.value.mul(10 ** GMAMDecimals).div(etherCost); \r\n        require(amount <= IERC20(GMAMAddress).allowance(owner, contractAddress));\r\n        IERC20(GMAMAddress).transferFrom(owner, contractAddress, amount);\r\n        IERC20(GMAMAddress).transfer(msg.sender, amount);\r\n    }\r\n    \r\n    // Pay With stablecoin\r\n    function payWithStablecoin(uint256 amountOfStablecoin, bool trueDaiFalseTUSD) public {\r\n        require(ICOActive == true);\r\n        uint256 amount = amountOfStablecoin.mul(10 ** GMAMDecimals).div(stablecoinCost);\r\n        require(amount <= IERC20(GMAMAddress).allowance(owner, address(this)));\r\n        address stablecoinAddress;\r\n        if (trueDaiFalseTUSD == true) {\r\n            stablecoinAddress = DAIAddress;\r\n        } else {\r\n            stablecoinAddress = TUSDAddress;\r\n        }\r\n        require(amountOfStablecoin <= IERC20(stablecoinAddress).allowance(msg.sender, address(this)));\r\n        IERC20(stablecoinAddress).transferFrom(msg.sender, address(this), amountOfStablecoin);\r\n        IERC20(stablecoinAddress).transfer(owner, amountOfStablecoin);\r\n        IERC20(GMAMAddress).transferFrom(owner, address(this), amount);\r\n        IERC20(GMAMAddress).transfer(msg.sender, amount);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setICOActve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherCost\",\"type\":\"uint256\"},{\"name\":\"_stablecoinCost\",\"type\":\"uint256\"}],\"name\":\"setCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TUSDAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GMAMDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfStablecoin\",\"type\":\"uint256\"},{\"name\":\"trueDaiFalseTUSD\",\"type\":\"bool\"}],\"name\":\"payWithStablecoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAIAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GMAMAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stablecoinCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"GMAMICO","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e3fc86f55ec81c75a8492ea285517987c179295cd669ae24ff6bc4e6a6e3bb40"}]}