{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\nlibrary BytesUtil {\n    function bytesToBytes32(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return bytes32(bytesToUintX(b, offset, 32));\n    }\n\n    function bytesToUint(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        return bytesToUintX(b, offset, 32);\n    }\n\n    function bytesToAddress(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (address)\n    {\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    }\n\n    function bytesToUint16(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (uint16)\n    {\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\n    }\n\n    function bytesToUintX(\n        bytes memory b,\n        uint  offset,\n        uint  numBytes\n        )\n        private\n        pure\n        returns (uint data)\n    {\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\n        assembly {\n            data := mload(add(add(b, numBytes), offset))\n        }\n    }\n\n    function subBytes(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\n        assembly {\n            data := add(add(b, 32), offset)\n        }\n    }\n\n    function fastSHA256(\n        bytes memory data\n        )\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32[] memory result = new bytes32[](1);\n        bool success;\n        assembly {\n             let ptr := add(data, 32)\n             success := staticcall(sub(gas, 2000), 2, ptr, mload(data), add(result, 32), 32)\n        }\n        require(success, \"SHA256_FAILED\");\n        return result[0];\n    }\n}\n\nlibrary MathUint {\n    function mul(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n    }\n\n    function sub(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        require(b <= a, \"SUB_UNDERFLOW\");\n        return a - b;\n    }\n\n    function add(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n    }\n\n    function decodeFloat(\n        uint f\n        )\n        internal\n        pure\n        returns (uint value)\n    {\n        uint numBitsMantissa = 23;\n        uint exponent = f >> numBitsMantissa;\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n        value = mantissa * (10 ** exponent);\n    }\n}\n\ncontract IBlockVerifier {\n    \n\n    event CircuitRegistered(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    event CircuitDisabled(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function registerCircuit(\n        uint8    blockType,\n        bool     onchainDataAvailability,\n        uint16   blockSize,\n        uint8    blockVersion,\n        uint[18] calldata vk\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function disableCircuit(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function verifyProofs(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion,\n        uint[] calldata publicInputs,\n        uint[] calldata proofs\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitRegistered(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitEnabled(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n}\n\ncontract IDecompressor {\n    \n    \n    \n    function decompress(\n        bytes calldata data\n        )\n        external\n        pure\n        returns (bytes memory decompressedData);\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract ILoopring is Claimable, ReentrancyGuard\n{\n    string  constant public version = \"\"; \n\n    uint    public exchangeCreationCostLRC;\n    address public universalRegistry;\n    address public lrcAddress;\n\n    event ExchangeInitialized(\n        uint    indexed exchangeId,\n        address indexed exchangeAddress,\n        address indexed owner,\n        address         operator,\n        bool            onchainDataAvailability\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initializeExchange(\n        address exchangeAddress,\n        uint    exchangeId,\n        address owner,\n        address payable operator,\n        bool    onchainDataAvailability\n        )\n        external;\n}\n\ncontract ILoopringV3 is ILoopring\n{\n    \n\n    event ExchangeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeBurned(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event SettingsUpdated(\n        uint            time\n    );\n\n    \n    struct Exchange\n    {\n        address exchangeAddress;\n        uint    exchangeStake;\n        uint    protocolFeeStake;\n    }\n\n    mapping (uint => Exchange) internal exchanges;\n\n    string  constant public version = \"3.0\";\n\n    address public wethAddress;\n    uint    public totalStake;\n    address public blockVerifierAddress;\n    address public downtimeCostCalculator;\n    uint    public maxWithdrawalFee;\n    uint    public withdrawalFineLRC;\n    uint    public tokenRegistrationFeeLRCBase;\n    uint    public tokenRegistrationFeeLRCDelta;\n    uint    public minExchangeStakeWithDataAvailability;\n    uint    public minExchangeStakeWithoutDataAvailability;\n    uint    public revertFineLRC;\n    uint8   public minProtocolTakerFeeBips;\n    uint8   public maxProtocolTakerFeeBips;\n    uint8   public minProtocolMakerFeeBips;\n    uint8   public maxProtocolMakerFeeBips;\n    uint    public targetProtocolTakerFeeStake;\n    uint    public targetProtocolMakerFeeStake;\n\n    address payable public protocolFeeVault;\n\n    \n    \n    \n    \n    \n    \n    function updateSettings(\n        address payable _protocolFeeVault,   \n        address _blockVerifierAddress,       \n        address _downtimeCostCalculator,     \n        uint    _exchangeCreationCostLRC,\n        uint    _maxWithdrawalFee,\n        uint    _tokenRegistrationFeeLRCBase,\n        uint    _tokenRegistrationFeeLRCDelta,\n        uint    _minExchangeStakeWithDataAvailability,\n        uint    _minExchangeStakeWithoutDataAvailability,\n        uint    _revertFineLRC,\n        uint    _withdrawalFineLRC\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function updateProtocolFeeSettings(\n        uint8 _minProtocolTakerFeeBips,\n        uint8 _maxProtocolTakerFeeBips,\n        uint8 _minProtocolMakerFeeBips,\n        uint8 _maxProtocolMakerFeeBips,\n        uint  _targetProtocolTakerFeeStake,\n        uint  _targetProtocolMakerFeeStake\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function canExchangeCommitBlocks(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    function getExchangeStake(\n        uint exchangeId\n        )\n        public\n        view\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function burnExchangeStake(\n        uint exchangeId,\n        uint amount\n        )\n        external\n        returns (uint burnedLRC);\n\n    \n    \n    \n    \n    function depositExchangeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    \n    function withdrawExchangeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    requestedAmount\n        )\n        external\n        returns (uint amount);\n\n    \n    \n    \n    \n    function depositProtocolFeeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function withdrawProtocolFeeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    function getProtocolFeeValues(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (\n            uint8 takerFeeBips,\n            uint8 makerFeeBips\n        );\n\n    \n    \n    \n    function getProtocolFeeStake(\n        uint exchangeId\n        )\n        external\n        view\n        returns (uint protocolFeeStake);\n}\n\nlibrary ExchangeData {\n    \n    enum BlockType\n    {\n        RING_SETTLEMENT,\n        DEPOSIT,\n        ONCHAIN_WITHDRAWAL,\n        OFFCHAIN_WITHDRAWAL,\n        ORDER_CANCELLATION,\n        TRANSFER\n    }\n\n    enum BlockState\n    {\n        \n        \n        NEW,            \n\n        \n        COMMITTED,      \n\n        \n        \n        VERIFIED        \n    }\n\n    \n    struct Account\n    {\n        address owner;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        uint    pubKeyX;\n        uint    pubKeyY;\n    }\n\n    struct Token\n    {\n        address token;\n        bool    depositDisabled;\n    }\n\n    struct ProtocolFeeData\n    {\n        uint32 timestamp;\n        uint8 takerFeeBips;\n        uint8 makerFeeBips;\n        uint8 previousTakerFeeBips;\n        uint8 previousMakerFeeBips;\n    }\n\n    \n    \n    struct Block\n    {\n        \n        \n        bytes32 merkleRoot;\n\n        \n        \n        \n        \n        \n        \n        bytes32 publicDataHash;\n\n        \n        BlockState state;\n\n        \n        \n        BlockType blockType;\n\n        \n        \n        \n        \n        uint16 blockSize;\n\n        \n        uint8  blockVersion;\n\n        \n        uint32 timestamp;\n\n        \n        \n        uint32 numDepositRequestsCommitted;\n\n        \n        \n        uint32 numWithdrawalRequestsCommitted;\n\n        \n        \n        bool   blockFeeWithdrawn;\n\n        \n        uint16 numWithdrawalsDistributed;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        bytes  withdrawals;\n    }\n\n    \n    \n    \n    struct Request\n    {\n        bytes32 accumulatedHash;\n        uint    accumulatedFee;\n        uint32  timestamp;\n    }\n\n    \n    struct Deposit\n    {\n        uint24 accountID;\n        uint16 tokenID;\n        uint96 amount;\n    }\n\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n        \n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    }\n\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 14 days; }\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 1000; }\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 21 days; }\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 14 days; }\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 30 days; }\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 1 seconds; }\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 14 days; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS_SHUTDOWN_MODE() internal pure returns (uint32) {\n        return MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() * 10;\n    }\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 6 hours; }\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 6 hours; }\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 150000; }\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 60000; }\n\n    \n    struct State\n    {\n        uint    id;\n        uint    exchangeCreationTimestamp;\n        address payable operator; \n        bool    onchainDataAvailability;\n\n        ILoopringV3    loopring;\n        IBlockVerifier blockVerifier;\n\n        address lrcAddress;\n\n        uint    totalTimeInMaintenanceSeconds;\n        uint    numDowntimeMinutes;\n        uint    downtimeStart;\n\n        address addressWhitelist;\n        uint    accountCreationFeeETH;\n        uint    accountUpdateFeeETH;\n        uint    depositFeeETH;\n        uint    withdrawalFeeETH;\n\n        Block[]     blocks;\n        Token[]     tokens;\n        Account[]   accounts;\n        Deposit[]   deposits;\n        Request[]   depositChain;\n        Request[]   withdrawalChain;\n\n        \n        mapping (address => uint24) ownerToAccountId;\n        mapping (address => uint16) tokenToTokenId;\n\n        \n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\n\n        \n        mapping (address => uint) tokenBalances;\n\n        \n        \n        \n        uint numBlocksFinalized;\n\n        \n        ProtocolFeeData protocolFeeData;\n\n        \n        uint shutdownStartTime;\n    }\n}\n\nlibrary ExchangeMode {\n    using MathUint  for uint;\n\n    function isInWithdrawalMode(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool result)\n    {\n        result = false;\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\n\n        \n        if (currentBlock.numDepositRequestsCommitted < S.depositChain.length) {\n            uint32 requestTimestamp = S.depositChain[currentBlock.numDepositRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false && currentBlock.numWithdrawalRequestsCommitted < S.withdrawalChain.length) {\n            uint32 requestTimestamp = S.withdrawalChain[currentBlock.numWithdrawalRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false) {\n            result = isAnyUnfinalizedBlockTooOld(S);\n        }\n\n        \n        if (result == false && isShutdown(S) && !isInInitialState(S)) {\n            \n            \n            uint maxTimeInShutdown = ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE();\n            maxTimeInShutdown = maxTimeInShutdown.add(S.accounts.length.mul(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()));\n            result = now > S.shutdownStartTime.add(maxTimeInShutdown);\n        }\n    }\n\n    function isShutdown(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.shutdownStartTime > 0;\n    }\n\n    function isInMaintenance(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.downtimeStart != 0 && getNumDowntimeMinutesLeft(S) > 0;\n    }\n\n    function isInInitialState(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        ExchangeData.Block storage firstBlock = S.blocks[0];\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\n        return (S.blocks.length == S.numBlocksFinalized) &&\n            (lastBlock.numDepositRequestsCommitted == S.depositChain.length) &&\n            (lastBlock.merkleRoot == firstBlock.merkleRoot);\n    }\n\n    function areUserRequestsEnabled(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        \n        \n        return !isInMaintenance(S) && !isShutdown(S) && !isInWithdrawalMode(S);\n    }\n\n    function isAnyUnfinalizedBlockTooOld(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        if (S.numBlocksFinalized < S.blocks.length) {\n            uint32 blockTimestamp = S.blocks[S.numBlocksFinalized].timestamp;\n            return blockTimestamp < now.sub(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE());\n        } else {\n            return false;\n        }\n    }\n\n    function getNumDowntimeMinutesLeft(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (uint)\n    {\n        if (S.downtimeStart == 0) {\n            return S.numDowntimeMinutes;\n        } else {\n            \n            uint numDowntimeMinutesUsed = now.sub(S.downtimeStart) / 60;\n            if (S.numDowntimeMinutes > numDowntimeMinutesUsed) {\n                return S.numDowntimeMinutes.sub(numDowntimeMinutesUsed);\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\nlibrary ExchangeBlocks {\n    using BytesUtil         for bytes;\n    using MathUint          for uint;\n    using ExchangeMode      for ExchangeData.State;\n\n    event BlockCommitted(\n        uint    indexed blockIdx,\n        bytes32 indexed publicDataHash\n    );\n\n    event BlockFinalized(\n        uint    indexed blockIdx\n    );\n\n    event BlockVerified(\n        uint    indexed blockIdx\n    );\n\n    event Revert(\n        uint    indexed blockIdx\n    );\n\n    event ProtocolFeesUpdated(\n        uint8 takerFeeBips,\n        uint8 makerFeeBips,\n        uint8 previousTakerFeeBips,\n        uint8 previousMakerFeeBips\n    );\n\n    function commitBlock(\n        ExchangeData.State storage S,\n        uint8  blockType,\n        uint16 blockSize,\n        uint8  blockVersion,\n        bytes  calldata data,\n        bytes  calldata \n        )\n        external\n    {\n        commitBlockInternal(\n            S,\n            ExchangeData.BlockType(blockType),\n            blockSize,\n            blockVersion,\n            data\n        );\n    }\n\n    function verifyBlocks(\n        ExchangeData.State storage S,\n        uint[] calldata blockIndices,\n        uint[] calldata proofs\n        )\n        external\n    {\n        \n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        \n        require(blockIndices.length > 0, \"INVALID_INPUT_ARRAYS\");\n        require(proofs.length % 8 == 0, \"INVALID_PROOF_ARRAY\");\n        require(proofs.length / 8 == blockIndices.length, \"INVALID_INPUT_ARRAYS\");\n\n        uint[] memory publicInputs = new uint[](blockIndices.length);\n        uint16 blockSize;\n        ExchangeData.BlockType blockType;\n        uint8 blockVersion;\n\n        for (uint i = 0; i < blockIndices.length; i++) {\n            uint blockIdx = blockIndices[i];\n\n            require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\n            ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\n            require(\n                specifiedBlock.state == ExchangeData.BlockState.COMMITTED,\n                \"BLOCK_VERIFIED_ALREADY\"\n            );\n\n            \n            \n            \n            require(\n                blockIdx < S.numBlocksFinalized + ExchangeData.MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS(),\n                \"PROOF_TOO_EARLY\"\n            );\n\n            \n            require(\n                now <= specifiedBlock.timestamp + ExchangeData.MAX_PROOF_GENERATION_TIME_IN_SECONDS(),\n                \"PROOF_TOO_LATE\"\n            );\n\n            \n            \n            publicInputs[i] = uint(specifiedBlock.publicDataHash) >> 3;\n            if (i == 0) {\n                blockSize = specifiedBlock.blockSize;\n                blockType = specifiedBlock.blockType;\n                blockVersion = specifiedBlock.blockVersion;\n            } else {\n                \n                require(blockType == specifiedBlock.blockType, \"INVALID_BATCH_BLOCK_TYPE\");\n                require(blockSize == specifiedBlock.blockSize, \"INVALID_BATCH_BLOCK_SIZE\");\n                require(blockVersion == specifiedBlock.blockVersion, \"INVALID_BATCH_BLOCK_VERSION\");\n            }\n        }\n\n        \n        require(\n            S.blockVerifier.verifyProofs(\n                uint8(blockType),\n                S.onchainDataAvailability,\n                blockSize,\n                blockVersion,\n                publicInputs,\n                proofs\n            ),\n            \"INVALID_PROOF\"\n        );\n\n        \n        for (uint i = 0; i < blockIndices.length; i++) {\n            uint blockIdx = blockIndices[i];\n            ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\n            \n            require(\n                specifiedBlock.state == ExchangeData.BlockState.COMMITTED,\n                \"BLOCK_VERIFIED_ALREADY\"\n            );\n            specifiedBlock.state = ExchangeData.BlockState.VERIFIED;\n            emit BlockVerified(blockIdx);\n        }\n\n        \n        \n        \n        \n        uint idx = S.numBlocksFinalized;\n        while (idx < S.blocks.length &&\n            S.blocks[idx].state == ExchangeData.BlockState.VERIFIED) {\n            emit BlockFinalized(idx);\n            idx++;\n        }\n        S.numBlocksFinalized = idx;\n    }\n\n    function revertBlock(\n        ExchangeData.State storage S,\n        uint blockIdx\n        )\n        external\n    {\n        \n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\n        ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\n        require(specifiedBlock.state == ExchangeData.BlockState.COMMITTED, \"INVALID_BLOCK_STATE\");\n\n        \n        require(blockIdx >= S.numBlocksFinalized, \"FINALIZED_BLOCK_REVERT_PROHIBITED\");\n\n        \n        uint fine = S.loopring.revertFineLRC();\n        S.loopring.burnExchangeStake(S.id, fine);\n\n        \n        S.blocks.length = blockIdx;\n\n        emit Revert(blockIdx);\n    }\n\n    \n    function commitBlockInternal(\n        ExchangeData.State storage S,\n        ExchangeData.BlockType blockType,\n        uint16 blockSize,\n        uint8  blockVersion,\n        bytes  memory data  \n                            \n                            \n                            \n        )\n        private\n    {\n        \n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        \n        require(\n            S.loopring.canExchangeCommitBlocks(S.id, S.onchainDataAvailability),\n            \"INSUFFICIENT_EXCHANGE_STAKE\"\n        );\n\n        \n        require(\n            S.blockVerifier.isCircuitEnabled(\n                uint8(blockType),\n                S.onchainDataAvailability,\n                blockSize,\n                blockVersion\n            ),\n            \"CANNOT_VERIFY_BLOCK\"\n        );\n\n        \n        uint32 exchangeIdInData = 0;\n        assembly {\n            exchangeIdInData := and(mload(add(data, 4)), 0xFFFFFFFF)\n        }\n        require(exchangeIdInData == S.id, \"INVALID_EXCHANGE_ID\");\n\n        \n        ExchangeData.Block storage prevBlock = S.blocks[S.blocks.length - 1];\n\n        \n        bytes32 merkleRootBefore;\n        bytes32 merkleRootAfter;\n        assembly {\n            merkleRootBefore := mload(add(data, 36))\n            merkleRootAfter := mload(add(data, 68))\n        }\n        require(merkleRootBefore == prevBlock.merkleRoot, \"INVALID_MERKLE_ROOT\");\n        require(uint256(merkleRootAfter) < ExchangeData.SNARK_SCALAR_FIELD(), \"INVALID_MERKLE_ROOT\");\n\n        uint32 numDepositRequestsCommitted = uint32(prevBlock.numDepositRequestsCommitted);\n        uint32 numWithdrawalRequestsCommitted = uint32(prevBlock.numWithdrawalRequestsCommitted);\n\n        \n        \n        \n        \n        if (S.isShutdown()) {\n            if (numDepositRequestsCommitted < S.depositChain.length) {\n                require(blockType == ExchangeData.BlockType.DEPOSIT, \"SHUTDOWN_DEPOSIT_BLOCK_FORCED\");\n            } else {\n                require(blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL, \"SHUTDOWN_WITHDRAWAL_BLOCK_FORCED\");\n            }\n        }\n\n        \n        \n        \n        if (isWithdrawalRequestForced(S, numWithdrawalRequestsCommitted)) {\n            require(blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL, \"WITHDRAWAL_BLOCK_FORCED\");\n        } else if (isDepositRequestForced(S, numDepositRequestsCommitted)) {\n            require(blockType == ExchangeData.BlockType.DEPOSIT, \"DEPOSIT_BLOCK_FORCED\");\n        }\n\n        if (blockType == ExchangeData.BlockType.RING_SETTLEMENT) {\n            require(S.areUserRequestsEnabled(), \"SETTLEMENT_SUSPENDED\");\n            uint32 inputTimestamp;\n            uint8 protocolTakerFeeBips;\n            uint8 protocolMakerFeeBips;\n            assembly {\n                inputTimestamp := and(mload(add(data, 72)), 0xFFFFFFFF)\n                protocolTakerFeeBips := and(mload(add(data, 73)), 0xFF)\n                protocolMakerFeeBips := and(mload(add(data, 74)), 0xFF)\n            }\n            require(\n                inputTimestamp > now - ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() &&\n                inputTimestamp < now + ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS(),\n                \"INVALID_TIMESTAMP\"\n            );\n            require(\n                validateAndUpdateProtocolFeeValues(S, protocolTakerFeeBips, protocolMakerFeeBips),\n                \"INVALID_PROTOCOL_FEES\"\n            );\n        } else if (blockType == ExchangeData.BlockType.DEPOSIT) {\n            uint startIdx = 0;\n            uint count = 0;\n            assembly {\n                startIdx := and(mload(add(data, 136)), 0xFFFFFFFF)\n                count := and(mload(add(data, 140)), 0xFFFFFFFF)\n            }\n            require (startIdx == numDepositRequestsCommitted, \"INVALID_REQUEST_RANGE\");\n            require (count <= blockSize, \"INVALID_REQUEST_RANGE\");\n            require (startIdx + count <= S.depositChain.length, \"INVALID_REQUEST_RANGE\");\n\n            bytes32 startingHash = S.depositChain[startIdx - 1].accumulatedHash;\n            bytes32 endingHash = S.depositChain[startIdx + count - 1].accumulatedHash;\n            \n            for (uint i = count; i < blockSize; i++) {\n                endingHash = sha256(\n                    abi.encodePacked(\n                        endingHash,\n                        uint24(0),\n                        uint(0),\n                        uint(0),\n                        uint8(0),\n                        uint96(0)\n                    )\n                );\n            }\n            bytes32 inputStartingHash = 0x0;\n            bytes32 inputEndingHash = 0x0;\n            assembly {\n                inputStartingHash := mload(add(data, 100))\n                inputEndingHash := mload(add(data, 132))\n            }\n            require(inputStartingHash == startingHash, \"INVALID_STARTING_HASH\");\n            require(inputEndingHash == endingHash, \"INVALID_ENDING_HASH\");\n\n            numDepositRequestsCommitted += uint32(count);\n        } else if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL) {\n            uint startIdx = 0;\n            uint count = 0;\n            assembly {\n                startIdx := and(mload(add(data, 136)), 0xFFFFFFFF)\n                count := and(mload(add(data, 140)), 0xFFFFFFFF)\n            }\n            require (startIdx == numWithdrawalRequestsCommitted, \"INVALID_REQUEST_RANGE\");\n            require (count <= blockSize, \"INVALID_REQUEST_RANGE\");\n            require (startIdx + count <= S.withdrawalChain.length, \"INVALID_REQUEST_RANGE\");\n\n            if (S.isShutdown()) {\n                require (count == 0, \"INVALID_WITHDRAWAL_COUNT\");\n                \n                \n            } else {\n                require (count > 0, \"INVALID_WITHDRAWAL_COUNT\");\n                bytes32 startingHash = S.withdrawalChain[startIdx - 1].accumulatedHash;\n                bytes32 endingHash = S.withdrawalChain[startIdx + count - 1].accumulatedHash;\n                \n                for (uint i = count; i < blockSize; i++) {\n                    endingHash = sha256(\n                        abi.encodePacked(\n                            endingHash,\n                            uint24(0),\n                            uint8(0),\n                            uint96(0)\n                        )\n                    );\n                }\n                bytes32 inputStartingHash = 0x0;\n                bytes32 inputEndingHash = 0x0;\n                assembly {\n                    inputStartingHash := mload(add(data, 100))\n                    inputEndingHash := mload(add(data, 132))\n                }\n                require(inputStartingHash == startingHash, \"INVALID_STARTING_HASH\");\n                require(inputEndingHash == endingHash, \"INVALID_ENDING_HASH\");\n                numWithdrawalRequestsCommitted += uint32(count);\n            }\n        } else if (\n            blockType != ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL &&\n            blockType != ExchangeData.BlockType.ORDER_CANCELLATION &&\n            blockType != ExchangeData.BlockType.TRANSFER) {\n            revert(\"UNSUPPORTED_BLOCK_TYPE\");\n        }\n\n        \n        bytes32 publicDataHash = data.fastSHA256();\n\n        \n        bytes memory withdrawals = new bytes(0);\n        if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL ||\n            blockType == ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL) {\n            uint start = 4 + 32 + 32;\n            if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL) {\n                start += 32 + 32 + 4 + 4;\n            }\n            uint length = 7 * blockSize;\n            assembly {\n                withdrawals := add(data, start)\n                mstore(withdrawals, length)\n            }\n        }\n\n        \n        ExchangeData.Block memory newBlock = ExchangeData.Block(\n            merkleRootAfter,\n            publicDataHash,\n            ExchangeData.BlockState.COMMITTED,\n            blockType,\n            blockSize,\n            blockVersion,\n            uint32(now),\n            numDepositRequestsCommitted,\n            numWithdrawalRequestsCommitted,\n            false,\n            0,\n            withdrawals\n        );\n\n        S.blocks.push(newBlock);\n\n        emit BlockCommitted(S.blocks.length - 1, publicDataHash);\n    }\n\n    function validateAndUpdateProtocolFeeValues(\n        ExchangeData.State storage S,\n        uint8 takerFeeBips,\n        uint8 makerFeeBips\n        )\n        private\n        returns (bool)\n    {\n        ExchangeData.ProtocolFeeData storage data = S.protocolFeeData;\n        if (now > data.timestamp + ExchangeData.MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED()) {\n            \n            data.previousTakerFeeBips = data.takerFeeBips;\n            data.previousMakerFeeBips = data.makerFeeBips;\n            \n            (data.takerFeeBips, data.makerFeeBips) = S.loopring.getProtocolFeeValues(\n                S.id,\n                S.onchainDataAvailability\n            );\n            data.timestamp = uint32(now);\n\n            bool feeUpdated = (data.takerFeeBips != data.previousTakerFeeBips) ||\n                (data.makerFeeBips != data.previousMakerFeeBips);\n\n            if (feeUpdated) {\n                emit ProtocolFeesUpdated(\n                    data.takerFeeBips,\n                    data.makerFeeBips,\n                    data.previousTakerFeeBips,\n                    data.previousMakerFeeBips\n                );\n            }\n        }\n        \n        return (takerFeeBips == data.takerFeeBips && makerFeeBips == data.makerFeeBips) ||\n            (takerFeeBips == data.previousTakerFeeBips && makerFeeBips == data.previousMakerFeeBips);\n    }\n\n    function isDepositRequestForced(\n        ExchangeData.State storage S,\n        uint numRequestsCommitted\n        )\n        private\n        view\n        returns (bool)\n    {\n        if (numRequestsCommitted == S.depositChain.length) {\n            return false;\n        } else {\n            return S.depositChain[numRequestsCommitted].timestamp < now.sub(\n                ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED());\n        }\n    }\n\n    function isWithdrawalRequestForced(\n        ExchangeData.State storage S,\n        uint numRequestsCommitted\n        )\n        private\n        view\n        returns (bool)\n    {\n        if (numRequestsCommitted == S.withdrawalChain.length) {\n            return false;\n        } else {\n            return S.withdrawalChain[numRequestsCommitted].timestamp < now.sub(\n                ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED());\n        }\n    }\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"publicDataHash\",\"type\":\"bytes32\"}],\"name\":\"BlockCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"BlockFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"BlockVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"Revert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"takerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"makerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousTakerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousMakerFeeBips\",\"type\":\"uint8\"}],\"name\":\"ProtocolFeesUpdated\",\"type\":\"event\"}]","ContractName":"ExchangeBlocks","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://4df922d784c9c674fc0a3d8a9a259a83844df63a709ebc77dd0348ef4d6fe777"}]}