{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract SportCrypt {\r\n    address private owner;\r\n    mapping(address => bool) private admins;\r\n\r\n    function SportCrypt() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n\r\n    // Events\r\n\r\n    event LogBalanceChange(address indexed account, uint oldAmount, uint newAmount);\r\n    event LogDeposit(address indexed account);\r\n    event LogWithdraw(address indexed account);\r\n    event LogTrade(address indexed takerAccount, address indexed makerAccount, uint indexed matchId, uint orderHash, uint8 orderDirection, uint8 price, uint longAmount, int newLongPosition, uint shortAmount, int newShortPosition);\r\n    event LogTradeError(address indexed takerAccount, address indexed makerAccount, uint indexed matchId, uint orderHash, uint16 status);\r\n    event LogOrderCancel(address indexed account, uint indexed matchId, uint orderHash);\r\n    event LogFinalizeMatch(uint indexed matchId, uint8 finalPrice);\r\n    event LogClaim(address indexed account, uint indexed matchId, uint amount);\r\n\r\n\r\n    // Storage\r\n\r\n    struct Match {\r\n        mapping(address => int) positions;\r\n        uint64 firstTradeTimestamp;\r\n        bool finalized;\r\n        uint8 finalPrice;\r\n    }\r\n\r\n    mapping(address => uint) private balances;\r\n    mapping(uint => Match) private matches;\r\n    mapping(uint => uint) private filledAmounts;\r\n\r\n\r\n    // Memory\r\n\r\n    uint constant MAX_SANE_AMOUNT = 2**128;\r\n\r\n    enum Status {\r\n        OK,\r\n        MATCH_FINALIZED,\r\n        ORDER_EXPIRED,\r\n        ORDER_MALFORMED,\r\n        ORDER_BAD_SIG,\r\n        AMOUNT_MALFORMED,\r\n        SELF_TRADE,\r\n        ZERO_VALUE_TRADE\r\n    }\r\n\r\n    struct Order {\r\n        uint orderHash;\r\n        uint matchId;\r\n        uint amount;\r\n        uint expiry;\r\n        address addr;\r\n        uint8 price;\r\n        uint8 direction;\r\n    }\r\n\r\n    // [0]: match hash\r\n    // [1]: amount\r\n    // [2]: 5-byte expiry, 5-byte nonce, 1-byte price, 1-byte direction, 20-byte address\r\n\r\n    function parseOrder(uint[3] memory rawOrder) private constant returns(Order memory o) {\r\n        o.orderHash = uint(keccak256(this, rawOrder));\r\n\r\n        o.matchId = rawOrder[0];\r\n        o.amount = rawOrder[1];\r\n\r\n        uint packed = rawOrder[2];\r\n        o.expiry = packed >> (8*27);\r\n        o.addr = address(packed & 0x00ffffffffffffffffffffffffffffffffffffffff);\r\n        o.price = uint8((packed >> (8*21)) & 0xff);\r\n        o.direction = uint8((packed >> (8*20)) & 0xff);\r\n    }\r\n\r\n    function validateOrderParams(Order memory o) private pure returns(bool) {\r\n        if (o.amount > MAX_SANE_AMOUNT) return false;\r\n        if (o.price == 0 || o.price > 99) return false;\r\n        if (o.direction > 1) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateOrderSig(Order memory o, bytes32 r, bytes32 s, uint8 v) private pure returns(bool) {\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", o.orderHash), v, r, s) != o.addr) return false;\r\n        return true;\r\n    }\r\n\r\n    struct Trade {\r\n        Status status;\r\n        address longAddr;\r\n        address shortAddr;\r\n        int newLongPosition;\r\n        int newShortPosition;\r\n        int longBalanceDelta;\r\n        int shortBalanceDelta;\r\n        uint shortAmount;\r\n        uint longAmount;\r\n    }\r\n\r\n\r\n    // User methods\r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    function deposit() external payable {\r\n        if (msg.value > 0) {\r\n            uint origAmount = balances[msg.sender];\r\n            uint newAmount = safeAdd(origAmount, msg.value);\r\n            balances[msg.sender] = newAmount;\r\n\r\n            LogDeposit(msg.sender);\r\n            LogBalanceChange(msg.sender, origAmount, newAmount);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint amount) external {\r\n        uint origAmount = balances[msg.sender];\r\n        uint amountToWithdraw = minu256(origAmount, amount);\r\n\r\n        if (amountToWithdraw > 0) {\r\n            uint newAmount = origAmount - amountToWithdraw;\r\n            balances[msg.sender] = newAmount;\r\n\r\n            LogWithdraw(msg.sender);\r\n            LogBalanceChange(msg.sender, origAmount, newAmount);\r\n\r\n            msg.sender.transfer(amountToWithdraw);\r\n        }\r\n    }\r\n\r\n    function cancelOrder(uint[3] order, bytes32 r, bytes32 s, uint8 v) external {\r\n        Order memory o = parseOrder(order);\r\n\r\n        // Don't bother validating order params.\r\n        require(validateOrderSig(o, r, s, v));\r\n        require(o.addr == msg.sender);\r\n\r\n        if (block.timestamp < o.expiry) {\r\n            filledAmounts[o.orderHash] = o.amount;\r\n            LogOrderCancel(msg.sender, o.matchId, o.orderHash);\r\n        }\r\n    }\r\n\r\n    function trade(uint amount, uint[3] order, bytes32 r, bytes32 s, uint8 v) external {\r\n        Order memory o = parseOrder(order);\r\n\r\n        if (!validateOrderParams(o)) {\r\n            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(Status.ORDER_MALFORMED));\r\n            return;\r\n        }\r\n\r\n        if (!validateOrderSig(o, r, s, v)) {\r\n            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(Status.ORDER_BAD_SIG));\r\n            return;\r\n        }\r\n\r\n        Trade memory t = tradeCore(amount, o);\r\n\r\n        if (t.status != Status.OK) {\r\n            LogTradeError(msg.sender, o.addr, o.matchId, o.orderHash, uint16(t.status));\r\n            return;\r\n        }\r\n\r\n        // Modify storage to reflect trade:\r\n\r\n        var m = matches[o.matchId];\r\n\r\n        if (m.firstTradeTimestamp == 0) {\r\n            assert(block.timestamp > 0);\r\n            m.firstTradeTimestamp = uint64(block.timestamp);\r\n        }\r\n\r\n        m.positions[t.longAddr] = t.newLongPosition;\r\n        m.positions[t.shortAddr] = t.newShortPosition;\r\n\r\n        adjustBalance(t.longAddr, t.longBalanceDelta);\r\n        adjustBalance(t.shortAddr, t.shortBalanceDelta);\r\n\r\n        filledAmounts[o.orderHash] += (o.direction == 0 ? t.shortAmount : t.longAmount);\r\n\r\n        LogTrade(msg.sender, o.addr, o.matchId, o.orderHash, o.direction, o.price, t.longAmount, t.newLongPosition, t.shortAmount, t.newShortPosition);\r\n    }\r\n\r\n    function claim(uint matchId, uint8 finalPrice, bytes32 r, bytes32 s, uint8 v) external {\r\n        var m = matches[matchId];\r\n\r\n        if (m.finalized) {\r\n            require(m.finalPrice == finalPrice);\r\n        } else {\r\n            uint messageHash = uint(keccak256(this, matchId, finalPrice));\r\n            address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", messageHash), v, r, s);\r\n            require(admins[signer]);\r\n            require(finalPrice <= 100);\r\n\r\n            m.finalized = true;\r\n            m.finalPrice = finalPrice;\r\n            LogFinalizeMatch(matchId, finalPrice);\r\n        }\r\n\r\n        // NOTE: final prices other than 0 and 100 may leave very small amounts of unrecoverable dust in the contract due to rounding.\r\n\r\n        int delta = 0;\r\n        int senderPosition = m.positions[msg.sender];\r\n\r\n        if (senderPosition > 0) {\r\n            delta = priceDivide(senderPosition, finalPrice);\r\n        } else if (senderPosition < 0) {\r\n            delta = priceDivide(-senderPosition, 100 - finalPrice);\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        assert(delta >= 0);\r\n\r\n        m.positions[msg.sender] = 0;\r\n        adjustBalance(msg.sender, delta);\r\n\r\n        LogClaim(msg.sender, matchId, uint(delta));\r\n    }\r\n\r\n    function recoverFunds(uint matchId) external {\r\n        var m = matches[matchId];\r\n\r\n        if (m.finalized || m.firstTradeTimestamp == 0) {\r\n            return;\r\n        }\r\n\r\n        uint recoveryTimestamp = uint(m.firstTradeTimestamp) + ((matchId & 0xFF) * 7 * 86400);\r\n\r\n        if (uint(block.timestamp) > recoveryTimestamp) {\r\n            uint8 finalPrice = uint8((matchId & 0xFF00) >> 8);\r\n            require(finalPrice <= 100);\r\n\r\n            m.finalized = true;\r\n            m.finalPrice = finalPrice;\r\n            LogFinalizeMatch(matchId, finalPrice);\r\n        }\r\n    }\r\n\r\n\r\n    // Private utilities\r\n\r\n    function adjustBalance(address addr, int delta) private {\r\n        uint origAmount = balances[addr];\r\n        uint newAmount = delta >= 0 ? safeAdd(origAmount, uint(delta)) : safeSub(origAmount, uint(-delta));\r\n        balances[addr] = newAmount;\r\n\r\n        LogBalanceChange(addr, origAmount, newAmount);\r\n    }\r\n\r\n    function priceDivide(int amount, uint8 price) private pure returns(int) {\r\n        assert(amount >= 0);\r\n        return int(safeMul(uint(amount), price) / 100);\r\n    }\r\n\r\n    function computeEffectiveBalance(uint balance, int position, uint8 price, bool isLong) private pure returns(uint) {\r\n        uint effectiveBalance = balance;\r\n\r\n        if (isLong) {\r\n            if (position < 0) effectiveBalance += uint(priceDivide(-position, price));\r\n        } else {\r\n            if (position > 0) effectiveBalance += uint(priceDivide(position, 100 - price));\r\n        }\r\n\r\n        return effectiveBalance;\r\n    }\r\n\r\n    function computePriceWeightedAmounts(uint longAmount, uint shortAmount, uint price) private pure returns(uint, uint) {\r\n        uint totalLongAmount;\r\n        uint totalShortAmount;\r\n\r\n        totalLongAmount = longAmount + (safeMul(longAmount, 100 - price) / price);\r\n        totalShortAmount = shortAmount + (safeMul(shortAmount, price) / (100 - price));\r\n\r\n        if (totalLongAmount > totalShortAmount) {\r\n            return (totalShortAmount - shortAmount, shortAmount);\r\n        } else {\r\n            return (longAmount, totalLongAmount - longAmount);\r\n        }\r\n    }\r\n\r\n    function computeExposureDelta(int longBalanceDelta, int shortBalanceDelta, int oldLongPosition, int newLongPosition, int oldShortPosition, int newShortPosition) private pure returns(int) {\r\n        int positionDelta = 0;\r\n        if (newLongPosition > 0) positionDelta += newLongPosition - max256(0, oldLongPosition);\r\n        if (oldShortPosition > 0) positionDelta -= oldShortPosition - max256(0, newShortPosition);\r\n\r\n        return positionDelta + longBalanceDelta + shortBalanceDelta;\r\n    }\r\n\r\n    function tradeCore(uint amount, Order memory o) private constant returns(Trade t) {\r\n        var m = matches[o.matchId];\r\n\r\n        if (block.timestamp >= o.expiry) {\r\n            t.status = Status.ORDER_EXPIRED;\r\n            return;\r\n        }\r\n\r\n        if (m.finalized) {\r\n            t.status = Status.MATCH_FINALIZED;\r\n            return;\r\n        }\r\n\r\n        if (msg.sender == o.addr) {\r\n            t.status = Status.SELF_TRADE;\r\n            return;\r\n        }\r\n\r\n        if (amount > MAX_SANE_AMOUNT) {\r\n            t.status = Status.AMOUNT_MALFORMED;\r\n            return;\r\n        }\r\n\r\n        t.status = Status.OK;\r\n\r\n\r\n        uint longAmount;\r\n        uint shortAmount;\r\n\r\n        if (o.direction == 0) {\r\n            // maker short, taker long\r\n            t.longAddr = msg.sender;\r\n            longAmount = amount;\r\n\r\n            t.shortAddr = o.addr;\r\n            shortAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n        } else {\r\n            // maker long, taker short \r\n            t.longAddr = o.addr;\r\n            longAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n\r\n            t.shortAddr = msg.sender;\r\n            shortAmount = amount;\r\n        }\r\n\r\n        int oldLongPosition = m.positions[t.longAddr];\r\n        int oldShortPosition = m.positions[t.shortAddr];\r\n\r\n        longAmount = minu256(longAmount, computeEffectiveBalance(balances[t.longAddr], oldLongPosition, o.price, true));\r\n        shortAmount = minu256(shortAmount, computeEffectiveBalance(balances[t.shortAddr], oldShortPosition, o.price, false));\r\n\r\n        (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\r\n\r\n        if (longAmount == 0 || shortAmount == 0) {\r\n            t.status = Status.ZERO_VALUE_TRADE;\r\n            return;\r\n        }\r\n\r\n\r\n        int newLongPosition = oldLongPosition + (int(longAmount) + int(shortAmount));\r\n        int newShortPosition = oldShortPosition - (int(longAmount) + int(shortAmount));\r\n\r\n\r\n        t.longBalanceDelta = 0;\r\n        t.shortBalanceDelta = 0;\r\n\r\n        if (oldLongPosition < 0) t.longBalanceDelta += priceDivide(-oldLongPosition + min256(0, newLongPosition), 100 - o.price);\r\n        if (newLongPosition > 0) t.longBalanceDelta -= priceDivide(newLongPosition - max256(0, oldLongPosition), o.price);\r\n\r\n        if (oldShortPosition > 0) t.shortBalanceDelta += priceDivide(oldShortPosition - max256(0, newShortPosition), o.price);\r\n        if (newShortPosition < 0) t.shortBalanceDelta -= priceDivide(-newShortPosition + min256(0, oldShortPosition), 100 - o.price);\r\n\r\n        int exposureDelta = computeExposureDelta(t.longBalanceDelta, t.shortBalanceDelta, oldLongPosition, newLongPosition, oldShortPosition, newShortPosition);\r\n\r\n        if (exposureDelta != 0) {\r\n            if (exposureDelta == 1) {\r\n                newLongPosition--;\r\n                newShortPosition++;\r\n            } else if (exposureDelta == -1) {\r\n                t.longBalanceDelta++; // one left-over wei: arbitrarily give it to long\r\n            } else {\r\n                assert(false);\r\n            }\r\n\r\n            exposureDelta = computeExposureDelta(t.longBalanceDelta, t.shortBalanceDelta, oldLongPosition, newLongPosition, oldShortPosition, newShortPosition);\r\n            assert(exposureDelta == 0);\r\n        }\r\n\r\n\r\n        t.newLongPosition = newLongPosition;\r\n        t.newShortPosition = newShortPosition;\r\n        t.shortAmount = shortAmount;\r\n        t.longAmount = longAmount;\r\n    }\r\n\r\n\r\n    // External views\r\n\r\n    function getOwner() external view returns(address) {\r\n        return owner;\r\n    }\r\n\r\n    function isAdmin(address addr) external view returns(bool) {\r\n        return admins[addr];\r\n    }\r\n\r\n    function getBalance(address addr) external view returns(uint) {\r\n        return balances[addr];\r\n    }\r\n\r\n    function getMatchInfo(uint matchId) external view returns(uint64, bool, uint8) {\r\n        var m = matches[matchId];\r\n        return (m.firstTradeTimestamp, m.finalized, m.finalPrice);\r\n    }\r\n\r\n    function getPosition(uint matchId, address addr) external view returns(int) {\r\n        return matches[matchId].positions[addr];\r\n    }\r\n\r\n    function getFilledAmount(uint orderHash) external view returns(uint) {\r\n        return filledAmounts[orderHash];\r\n    }\r\n\r\n    function checkMatchBatch(address myAddr, uint[16] matchIds) external view returns(int[16] myPosition, bool[16] finalized, uint8[16] finalPrice) {\r\n        for (uint i = 0; i < 16; i++) {\r\n            if (matchIds[i] == 0) break;\r\n\r\n            var m = matches[matchIds[i]];\r\n\r\n            myPosition[i] = m.positions[myAddr];\r\n            finalized[i] = m.finalized;\r\n            finalPrice[i] = m.finalPrice;\r\n        }\r\n    }\r\n\r\n    function checkOrderBatch(uint[48] input) external view returns(uint16[16] status, uint[16] amount) {\r\n        for (uint i = 0; i < 16; i++) {\r\n            uint[3] memory rawOrder;\r\n            rawOrder[0] = input[(i*3)];\r\n            rawOrder[1] = input[(i*3) + 1];\r\n            rawOrder[2] = input[(i*3) + 2];\r\n\r\n            if (rawOrder[0] == 0) break;\r\n\r\n            Order memory o = parseOrder(rawOrder);\r\n\r\n            if (!validateOrderParams(o)) {\r\n                status[i] = uint16(Status.ORDER_MALFORMED);\r\n                amount[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            // Not validating order signatures or timestamps: should be done by clients\r\n\r\n            var m = matches[o.matchId];\r\n\r\n            if (m.finalized) {\r\n                status[i] = uint16(Status.MATCH_FINALIZED);\r\n                amount[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            uint longAmount;\r\n            uint shortAmount;\r\n\r\n            if (o.direction == 0) {\r\n                shortAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n                longAmount = safeMul(shortAmount, 100);\r\n                shortAmount = minu256(shortAmount, computeEffectiveBalance(balances[o.addr], m.positions[o.addr], o.price, false));\r\n                (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\r\n                status[i] = uint16(Status.OK);\r\n                amount[i] = shortAmount;\r\n            } else {\r\n                longAmount = safeSub(o.amount, filledAmounts[o.orderHash]);\r\n                shortAmount = safeMul(longAmount, 100);\r\n                longAmount = minu256(longAmount, computeEffectiveBalance(balances[o.addr], m.positions[o.addr], o.price, true));\r\n                (longAmount, shortAmount) = computePriceWeightedAmounts(longAmount, shortAmount, o.price);\r\n                status[i] = uint16(Status.OK);\r\n                amount[i] = longAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Math utilities\r\n\r\n    function safeMul(uint a, uint b) private pure returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) private pure returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) private pure returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    function minu256(uint a, uint b) private pure returns(uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(int a, int b) private pure returns(int) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(int a, int b) private pure returns(int) {\r\n        return a < b ? a : b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myAddr\",\"type\":\"address\"},{\"name\":\"matchIds\",\"type\":\"uint256[16]\"}],\"name\":\"checkMatchBatch\",\"outputs\":[{\"name\":\"myPosition\",\"type\":\"int256[16]\"},{\"name\":\"finalized\",\"type\":\"bool[16]\"},{\"name\":\"finalPrice\",\"type\":\"uint8[16]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getMatchInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"finalPrice\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"order\",\"type\":\"uint256[3]\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"getFilledAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"order\",\"type\":\"uint256[3]\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"input\",\"type\":\"uint256[48]\"}],\"name\":\"checkOrderBatch\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint16[16]\"},{\"name\":\"amount\",\"type\":\"uint256[16]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"takerAccount\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"makerAccount\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderDirection\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"longAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newLongPosition\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"shortAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newShortPosition\",\"type\":\"int256\"}],\"name\":\"LogTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"takerAccount\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"makerAccount\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint16\"}],\"name\":\"LogTradeError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"LogOrderCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finalPrice\",\"type\":\"uint8\"}],\"name\":\"LogFinalizeMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogClaim\",\"type\":\"event\"}]","ContractName":"SportCrypt","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://bfd4321cd89f9a55d3e5a24c1474acb3f13e17e77ef9445e0b0647cfad375b4a"}]}