{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\n/**\n * @title Spawn\n * @author 0age\n * @notice This contract provides creation code that is used by Spawner in order\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\n */\ncontract Spawn {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d73),\n      logicContract,\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n    }\n  }\n}\n\n/**\n * @title Spawner\n * @author 0age\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts. The logic contracts need to have an\n * intitializer function that should only callable when no contract exists at\n * their current address (i.e. it is being `DELEGATECALL`ed from a constructor).\n */\ncontract Spawner {\n  /**\n   * @notice Internal function for spawning an eip-1167 minimal proxy using\n   * `CREATE2`.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawn(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get salt to use during deployment using the supplied initialization code.\n    (bytes32 salt, address target) = _getSaltAndTarget(initCode);\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode, salt, target);\n  }\n\n  /**\n   * @notice Internal function for spawning an eip-1167 minimal proxy using\n   * `CREATE2`.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @param salt bytes32 A random salt\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawnSalty(\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    address target = _computeTargetAddress(logicContract, initializationCalldata, salt);\n\n    uint256 codeSize;\n    assembly { codeSize := extcodesize(target) }\n    require(codeSize == 0, \"contract already deployed with supplied salt\");\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode, salt, target);\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n   * and initialization calldata payload.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _getNextAddress(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get target address using the constructed initialization code.\n    (, target) = _getSaltAndTarget(initCode);\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n   * salt, and initialization calldata payload.\n   * @param initCodeHash bytes32 The encoded hash of initCode\n   * @param salt bytes32 A random salt\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _computeTargetAddress(\n    bytes32 initCodeHash,\n    bytes32 salt\n  ) internal view returns (address target) {\n    target = address(    // derive the target deployment address.\n      uint160(                   // downcast to match the address type.\n        uint256(                 // cast to uint to truncate upper digits.\n          keccak256(             // compute CREATE2 hash using 4 inputs.\n            abi.encodePacked(    // pack all inputs to the hash together.\n              bytes1(0xff),      // pass in the control character.\n              address(this),     // pass in the address of this contract.\n              salt,              // pass in the salt from above.\n              initCodeHash       // pass in hash of contract creation code.\n            )\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n   * and initialization calldata payload.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @param salt bytes32 A random salt\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _computeTargetAddress(\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal view returns (address target) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n    // get the keccak256 hash of the init code for address derivation.\n    bytes32 initCodeHash = keccak256(initCode);\n\n    target = _computeTargetAddress(initCodeHash, salt);\n  }\n\n  /**\n   * @notice Private function for spawning a compact eip-1167 minimal proxy\n   * using `CREATE2`. Provides logic that is reused by internal functions. A\n   * salt will also be chosen based on the calling address and a computed nonce\n   * that prevents deployments to existing addresses.\n   * @param initCode bytes The contract creation code.\n   * @param salt bytes32 A random salt\n   * @param target address The expected address of the new contract\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawnCreate2(\n    bytes memory initCode,\n    bytes32 salt,\n    address target\n  ) private returns (address spawnedContract) {\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create2(             // call `CREATE2` w/ 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    require(spawnedContract == target, \"attempted deployment to unexpected address\");\n  }\n\n  /**\n   * @notice Private function for determining the salt and the target deployment\n   * address for the next spawned contract (using create2) based on the contract\n   * creation code.\n   */\n  function _getSaltAndTarget(\n    bytes memory initCode\n  ) private view returns (bytes32 salt, address target) {\n    // get the keccak256 hash of the init code for address derivation.\n    bytes32 initCodeHash = keccak256(initCode);\n\n    // set the initial nonce to be provided when constructing the salt.\n    uint256 nonce = 0;\n\n    // declare variable for code size of derived address.\n    uint256 codeSize;\n\n    while (true) {\n      // derive `CREATE2` salt using `msg.sender` and nonce.\n      salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n      target = _computeTargetAddress(initCodeHash, salt);\n\n      // determine if a contract is already deployed to the target address.\n      assembly { codeSize := extcodesize(target) }\n\n      // exit the loop if no contract is deployed to the target address.\n      if (codeSize == 0) {\n        break;\n      }\n\n      // otherwise, increment the nonce and derive a new salt.\n      nonce++;\n    }\n  }\n}\n\n\n\ninterface iRegistry {\n\n    enum FactoryStatus { Unregistered, Registered, Retired }\n\n    event FactoryAdded(address owner, address factory, uint256 factoryID, bytes extraData);\n    event FactoryRetired(address owner, address factory, uint256 factoryID);\n    event InstanceRegistered(address instance, uint256 instanceIndex, address indexed creator, address indexed factory, uint256 indexed factoryID);\n\n    // factory state functions\n\n    function addFactory(address factory, bytes calldata extraData ) external;\n    function retireFactory(address factory) external;\n\n    // factory view functions\n\n    function getFactoryCount() external view returns (uint256 count);\n    function getFactoryStatus(address factory) external view returns (FactoryStatus status);\n    function getFactoryID(address factory) external view returns (uint16 factoryID);\n    function getFactoryData(address factory) external view returns (bytes memory extraData);\n    function getFactoryAddress(uint16 factoryID) external view returns (address factory);\n    function getFactory(address factory) external view returns (FactoryStatus state, uint16 factoryID, bytes memory extraData);\n    function getFactories() external view returns (address[] memory factories);\n    function getPaginatedFactories(uint256 startIndex, uint256 endIndex) external view returns (address[] memory factories);\n\n    // instance state functions\n\n    function register(address instance, address creator, uint80 extraData) external;\n\n    // instance view functions\n\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n\ncontract EventMetadata {\n\n    event MetadataSet(bytes metadata);\n\n    // state functions\n\n    function _setMetadata(bytes memory metadata) internal {\n        emit MetadataSet(metadata);\n    }\n}\n\n\n\ncontract Operated {\n\n    address private _operator;\n    bool private _status;\n\n    event OperatorUpdated(address operator, bool status);\n\n    // state functions\n\n    function _setOperator(address operator) internal {\n        require(_operator != operator, \"cannot set same operator\");\n        _operator = operator;\n        emit OperatorUpdated(operator, hasActiveOperator());\n    }\n\n    function _transferOperator(address operator) internal {\n        // transferring operator-ship implies there was an operator set before this\n        require(_operator != address(0), \"operator not set\");\n        _setOperator(operator);\n    }\n\n    function _renounceOperator() internal {\n        require(hasActiveOperator(), \"only when operator active\");\n        _operator = address(0);\n        _status = false;\n        emit OperatorUpdated(address(0), false);\n    }\n\n    function _activateOperator() internal {\n        require(!hasActiveOperator(), \"only when operator not active\");\n        _status = true;\n        emit OperatorUpdated(_operator, true);\n    }\n\n    function _deactivateOperator() internal {\n        require(hasActiveOperator(), \"only when operator active\");\n        _status = false;\n        emit OperatorUpdated(_operator, false);\n    }\n\n    // view functions\n\n    function getOperator() public view returns (address operator) {\n        operator = _operator;\n    }\n\n    function isOperator(address caller) public view returns (bool ok) {\n        return (caller == getOperator());\n    }\n\n    function hasActiveOperator() public view returns (bool ok) {\n        return _status;\n    }\n\n    function isActiveOperator(address caller) public view returns (bool ok) {\n        return (isOperator(caller) && hasActiveOperator());\n    }\n\n}\n\n\n\n/**\n * @title MultiHashWrapper\n * @dev Contract that handles multi hash data structures and encoding/decoding\n *   Learn more here: https://github.com/multiformats/multihash\n */\ncontract MultiHashWrapper {\n\n    // bytes32 hash first to fill the first storage slot\n    struct MultiHash {\n        bytes32 hash;\n        uint8 hashFunction;\n        uint8 digestSize;\n    }\n\n    /**\n    * @dev Given a multihash struct, returns the full base58-encoded hash\n    * @param multihash MultiHash struct that has the hashFunction, digestSize and the hash\n    * @return the base58-encoded full hash\n    */\n    function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {\n        bytes memory out = new bytes(34);\n\n        out[0] = byte(multihash.hashFunction);\n        out[1] = byte(multihash.digestSize);\n\n        uint8 i;\n        for (i = 0; i < 32; i++) {\n          out[i+2] = multihash.hash[i];\n        }\n\n        return out;\n    }\n\n    /**\n    * @dev Given a base58-encoded  hash, divides into its individual parts and returns a struct\n    * @param source base58-encoded  hash\n    * @return MultiHash that has the hashFunction, digestSize and the hash\n    */\n    function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {\n        require(source.length == 34, \"length of source must be 34\");\n\n        uint8 hashFunction = uint8(source[0]);\n        uint8 digestSize = uint8(source[1]);\n        bytes32 hash;\n\n        assembly {\n          hash := mload(add(source, 34))\n        }\n\n        return (MultiHash({\n          hashFunction: hashFunction,\n          digestSize: digestSize,\n          hash: hash\n        }));\n    }\n}\n\n\n/* TODO: Update eip165 interface\n *  bytes4(keccak256('create(bytes)')) == 0xcf5ba53f\n *  bytes4(keccak256('getInstanceType()')) == 0x18c2f4cf\n *  bytes4(keccak256('getInstanceRegistry()')) == 0xa5e13904\n *  bytes4(keccak256('getImplementation()')) == 0xaaf10f42\n *\n *  => 0xcf5ba53f ^ 0x18c2f4cf ^ 0xa5e13904 ^ 0xaaf10f42 == 0xd88967b6\n */\n interface iFactory {\n\n     event InstanceCreated(address indexed instance, address indexed creator, string initABI, bytes initData);\n\n     function create(bytes calldata initData) external returns (address instance);\n     function createSalty(bytes calldata initData, bytes32 salt) external returns (address instance);\n     function getInitSelector() external view returns (bytes4 initSelector);\n     function getInstanceRegistry() external view returns (address instanceRegistry);\n     function getTemplate() external view returns (address template);\n     function getSaltyInstance(bytes calldata, bytes32 salt) external view returns (address instance);\n     function getNextInstance(bytes calldata) external view returns (address instance);\n\n     function getInstanceCreator(address instance) external view returns (address creator);\n     function getInstanceType() external view returns (bytes4 instanceType);\n     function getInstanceCount() external view returns (uint256 count);\n     function getInstance(uint256 index) external view returns (address instance);\n     function getInstances() external view returns (address[] memory instances);\n     function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n }\n\n\n\n\ncontract Factory is Spawner {\n\n    address[] private _instances;\n    mapping (address => address) private _instanceCreator;\n\n    /* NOTE: The following items can be hardcoded as constant to save ~200 gas/create */\n    address private _templateContract;\n    bytes4 private _initSelector;\n    address private _instanceRegistry;\n    bytes4 private _instanceType;\n\n    event InstanceCreated(address indexed instance, address indexed creator, bytes callData);\n\n    function _initialize(address instanceRegistry, address templateContract, bytes4 instanceType, bytes4 initSelector) internal {\n        // set instance registry\n        _instanceRegistry = instanceRegistry;\n        // set logic contract\n        _templateContract = templateContract;\n        // set initSelector\n        _initSelector = initSelector;\n        // validate correct instance registry\n        require(instanceType == iRegistry(instanceRegistry).getInstanceType(), 'incorrect instance type');\n        // set instanceType\n        _instanceType = instanceType;\n    }\n\n    // IFactory methods\n\n    function create(bytes memory callData) public returns (address instance) {\n        // deploy new contract: initialize it & write minimal proxy to runtime.\n        instance = Spawner._spawn(getTemplate(), callData);\n\n        _createHelper(instance, callData);\n    }\n\n    function createSalty(bytes memory callData, bytes32 salt) public returns (address instance) {\n        // deploy new contract: initialize it & write minimal proxy to runtime.\n        instance = Spawner._spawnSalty(getTemplate(), callData, salt);\n\n        _createHelper(instance, callData);\n    }\n\n    function _createHelper(address instance, bytes memory callData) private {\n        // add the instance to the array\n        _instances.push(instance);\n        // set instance creator\n        _instanceCreator[instance] = msg.sender;\n        // add the instance to the instance registry\n        iRegistry(getInstanceRegistry()).register(instance, msg.sender, uint80(0));\n        // emit event\n        emit InstanceCreated(instance, msg.sender, callData);\n    }\n\n    function getSaltyInstance(\n        bytes memory callData,\n        bytes32 salt\n    ) public view returns (address target) {\n        return Spawner._computeTargetAddress(getTemplate(), callData, salt);\n    }\n\n    function getNextInstance(\n        bytes memory callData\n    ) public view returns (address target) {\n        return Spawner._getNextAddress(getTemplate(), callData);\n    }\n\n    function getInstanceCreator(address instance) public view returns (address creator) {\n        creator = _instanceCreator[instance];\n    }\n\n    function getInstanceType() public view returns (bytes4 instanceType) {\n        instanceType = _instanceType;\n    }\n\n    function getInitSelector() public view returns (bytes4 initSelector) {\n        initSelector = _initSelector;\n    }\n\n    function getInstanceRegistry() public view returns (address instanceRegistry) {\n        instanceRegistry = _instanceRegistry;\n    }\n\n    function getTemplate() public view returns (address template) {\n        template = _templateContract;\n    }\n\n    function getInstanceCount() public view returns (uint256 count) {\n        count = _instances.length;\n    }\n\n    function getInstance(uint256 index) public view returns (address instance) {\n        require(index < _instances.length, \"index out of range\");\n        instance = _instances[index];\n    }\n\n    function getInstances() public view returns (address[] memory instances) {\n        instances = _instances;\n    }\n\n    // Note: startIndex is inclusive, endIndex exclusive\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) public view returns (address[] memory instances) {\n        require(startIndex < endIndex, \"startIndex must be less than endIndex\");\n        require(endIndex <= _instances.length, \"end index out of range\");\n\n        // initialize fixed size memory array\n        address[] memory range = new address[](endIndex - startIndex);\n\n        // Populate array with addresses in range\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            range[i - startIndex] = _instances[i];\n        }\n\n        // return array of addresses\n        instances = range;\n    }\n\n}\n\n\n\ncontract ProofHash is MultiHashWrapper {\n\n    MultiHash private _proofHash;\n\n    event ProofHashSet(address caller, bytes proofHash);\n\n    // state functions\n\n    function _setProofHash(bytes memory proofHash) internal {\n        _proofHash = MultiHashWrapper._splitMultiHash(proofHash);\n        emit ProofHashSet(msg.sender, proofHash);\n    }\n\n    // view functions\n\n    function getProofHash() public view returns (bytes memory proofHash) {\n        proofHash = MultiHashWrapper._combineMultiHash(_proofHash);\n    }\n\n}\n\n\n\ncontract Template {\n\n    address private _factory;\n\n    // modifiers\n\n    modifier initializeTemplate() {\n        // set factory\n        _factory = msg.sender;\n\n        // only allow function to be delegatecalled from within a constructor.\n        uint32 codeSize;\n        assembly { codeSize := extcodesize(address) }\n        require(codeSize == 0, \"must be called within contract constructor\");\n        _;\n    }\n\n    // view functions\n\n    function getCreator() public view returns (address creator) {\n        // iFactory(...) would revert if _factory address is not actually a factory contract\n        creator = iFactory(_factory).getInstanceCreator(address(this));\n    }\n\n    function isCreator(address caller) public view returns (bool ok) {\n        ok = (caller == getCreator());\n    }\n\n    function getFactory() public view returns (address factory) {\n        factory = _factory;\n    }\n\n}\n\n\n\n\n\n\ncontract Post is ProofHash, Operated, EventMetadata, Template {\n\n    event Initialized(address operator, bytes multihash, bytes metadata);\n\n    function initialize(\n        address operator,\n        bytes memory multihash,\n        bytes memory metadata\n    ) public initializeTemplate() {\n\n        // set storage variables\n        if (multihash.length != 0) {\n            ProofHash._setProofHash(multihash);\n        }\n\n        // set operator\n        if (operator != address(0)) {\n            Operated._setOperator(operator);\n            Operated._activateOperator();\n        }\n\n        // set metadata\n        if (metadata.length != 0) {\n            EventMetadata._setMetadata(metadata);\n        }\n\n        // log initialization params\n        emit Initialized(operator, multihash, metadata);\n    }\n\n    // state functions\n\n    function setMetadata(bytes memory metadata) public {\n        // only active operator or creator\n        require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), \"only active operator or creator\");\n\n        // set metadata\n        EventMetadata._setMetadata(metadata);\n    }\n\n    function transferOperator(address operator) public {\n        // restrict access\n        require(Operated.isActiveOperator(msg.sender), \"only active operator\");\n\n        // transfer operator\n        Operated._transferOperator(operator);\n    }\n\n    function renounceOperator() public {\n        // restrict access\n        require(Operated.isActiveOperator(msg.sender), \"only active operator\");\n\n        // transfer operator\n        Operated._renounceOperator();\n    }\n\n}\n\n\n\n\ncontract Post_Factory is Factory {\n\n    constructor(address instanceRegistry, address templateContract) public {\n        // declare template in memory\n        Post template;\n\n        // set instance type\n        bytes4 instanceType = bytes4(keccak256(bytes('Post')));\n        // set initSelector\n        bytes4 initSelector = template.initialize.selector;\n        // initialize factory params\n        Factory._initialize(instanceRegistry, templateContract, instanceType, initSelector);\n    }\n\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceType\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"instanceType\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTemplate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitSelector\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"initSelector\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createSalty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"getInstanceCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"getNextInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instanceRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getPaginatedInstances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"instances\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"instances\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getSaltyInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"instanceRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"templateContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"InstanceCreated\",\"type\":\"event\"}]","ContractName":"Post_Factory","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000348fa9dcff507b81c7a1d7981244ea92e8c6af290000000000000000000000007f858f0726af676e00cb76459d984463ee1307c2","Library":"","LicenseType":"","SwarmSource":"bzzr://2b5efd74abb7fa64943d5c27055a6413ddde49ecd8100ef702ce3f659eab7d09"}]}