{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC721.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic interface\\r\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ncontract IERC721 {\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    function balanceOf(address owner) public view returns (uint256 balance);\\r\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\r\\n\\r\\n    function approve(address to, uint256 tokenId) public;\\r\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool _approved) public;\\r\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\r\\n}\"},\"IERC721Receiver.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ncontract IERC721Receiver {\\r\\n    /**\\r\\n     * @notice Handle the receipt of an NFT\\r\\n     * @dev The ERC721 smart contract calls this function on the recipient\\r\\n     * after a `safeTransfer`. This function MUST return the function selector,\\r\\n     * otherwise the caller will revert the transaction. The selector to be\\r\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\r\\n     * function MAY throw to revert and reject the transfer.\\r\\n     * Note: the ERC721 contract address is always the message sender.\\r\\n     * @param operator The address which called `safeTransferFrom` function\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param tokenId The NFT identifier which is being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return bytes4 `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n     */\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\\r\\n}\"},\"IRobe.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n  * @title Robe\\r\\n  * @dev An open standard based on Ethereum ERC 721 to build unique NFT with XML information\\r\\n  * \\r\\n  * @dev This is the main Inteface that identifies a Robe NFT\\r\\n  * \\r\\n  * @author Marco Vasapollo \\u003cceo@metaring.com\\u003e\\r\\n  * @author Alessandro Mario Lagana Toschi \\u003calet@risepic.com\\u003e\\r\\n*/\\r\\ncontract IRobe is IERC721 {\\r\\n\\r\\n    /**\\r\\n      * Creates a new ERC 721 NFT\\r\\n      * @return a unique tokenId\\r\\n      */\\r\\n    function mint(bytes calldata payload) external returns(uint256);\\r\\n\\r\\n    /**\\r\\n      * Attaches a new ERC 721 NFT to an already-existing Token\\r\\n      * to create a composed NFT\\r\\n      * @return a unique tokenId\\r\\n      */\\r\\n    function mint(uint256 previousTokenId, bytes calldata payload) external returns(uint256);\\r\\n\\r\\n    /**\\r\\n      * @return all the tokenIds that composes the givend NFT\\r\\n      */\\r\\n    function getChain(uint256 tokenId) external view returns(uint256[] memory);\\r\\n\\r\\n    /**\\r\\n      * @return the root NFT of this tokenId\\r\\n      */\\r\\n    function getRoot(uint256 tokenId) external view returns(uint256);\\r\\n\\r\\n    /**\\r\\n     * @return the content of a NFT\\r\\n     */\\r\\n    function getContent(uint256 tokenId) external view returns(bytes memory);\\r\\n\\r\\n    /**\\r\\n     * @return the position in the chain of this NFT\\r\\n     */\\r\\n    function getPositionOf(uint256 tokenId) external view returns(uint256);\\r\\n\\r\\n    /**\\r\\n     * @return the tokenId of the passed NFT at the given position\\r\\n     */\\r\\n    function getTokenIdAt(uint256 tokenId, uint256 position) external view returns(uint256);\\r\\n\\r\\n    /**\\r\\n     * Syntactic sugar\\r\\n     * @return the position in the chain, the owner\\u0027s address and content of the given NFT\\r\\n     */\\r\\n    function getCompleteInfo(uint256 tokenId) external view returns(uint256, address, bytes memory);\\r\\n}\"},\"IRobeSyntaxChecker.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n  * @title Syntax Checker for Robe-based NFT contract\\r\\n  * \\r\\n  * @author Marco Vasapollo \\u003cceo@metaring.com\\u003e\\r\\n  * @author Alessandro Mario Lagana Toschi \\u003calet@risepic.com\\u003e\\r\\n*/\\r\\ninterface IRobeSyntaxChecker {\\r\\n\\r\\n    /**\\r\\n     * @return true if the given payload respects the syntax of the Robe NFT reachable at the given robeAddress, false otherwhise\\r\\n     */\\r\\n    function check(uint256 rootTokenId, uint256 newTokenId, address owner, bytes calldata payload, address robeAddress) external view returns(bool);\\r\\n}\"},\"Robe.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./IRobe.sol\\\";\\r\\nimport \\\"./IRobeSyntaxChecker.sol\\\";\\r\\nimport \\\"./IERC721Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n  * @title General Purpose implementation of the Robe Interface\\r\\n  * @author Marco Vasapollo \\u003cceo@metaring.com\\u003e\\r\\n  * @author Alessandro Mario Lagana Toschi \\u003calet@risepic.com\\u003e\\r\\n  * @author The OpenZeppelin ERC721 Implementation for the safeTransferFrom method. Thank you guys!\\r\\n*/\\r\\ncontract Robe is IRobe {\\r\\n\\r\\n    address private _voidAddress = address(0);\\r\\n\\r\\n    address private _myAddress;\\r\\n\\r\\n    address private _syntaxCheckerAddress;\\r\\n    IRobeSyntaxChecker private _syntaxChecker;\\r\\n\\r\\n    //Registers the owner of each NFT\\r\\n    mapping(uint256 =\\u003e address) private _owner;\\r\\n\\r\\n    //Registers the balance for each owner\\r\\n    mapping(address =\\u003e uint256) private _balance;\\r\\n\\r\\n    //Registers the approved operators that can transfer the ownership of a specific NFT\\r\\n    mapping(uint256 =\\u003e address) private _tokenOperator;\\r\\n\\r\\n    //Registers the approved operators that can transfer the ownership of all the NFTs of a specific owner\\r\\n    mapping(address =\\u003e address) private _ownerOperator;\\r\\n\\r\\n    //Registers the chain of composed NFT\\r\\n    mapping(uint256 =\\u003e uint256[]) private _chain;\\r\\n\\r\\n    //Registers the position of the NFT in its chain\\r\\n    mapping(uint256 =\\u003e uint256) private _positionInChain;\\r\\n\\r\\n    //Registers the root NFT of each NFT\\r\\n    mapping(uint256 =\\u003e uint256) private _root;\\r\\n\\r\\n    //The content of each NFT\\r\\n    bytes[] private _data;\\r\\n\\r\\n    constructor(address syntaxCheckerAddress) public {\\r\\n        _myAddress = address(this);\\r\\n        if(syntaxCheckerAddress != _voidAddress) {\\r\\n            _syntaxCheckerAddress = syntaxCheckerAddress;\\r\\n            _syntaxChecker = IRobeSyntaxChecker(_syntaxCheckerAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function() external payable {\\r\\n        revert(\\\"ETH not accepted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * Creates a new ERC 721 NFT\\r\\n      * @return a unique tokenId\\r\\n      */\\r\\n    function mint(bytes memory payload) public returns(uint256) {\\r\\n        return _mintAndOrAttach(_data.length, payload, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * Attaches a new ERC 721 NFT to an already-existing Token\\r\\n      * to create a composed NFT\\r\\n      * @return a unique tokenId\\r\\n      */\\r\\n    function mint(uint256 rootTokenId, bytes memory payload) public returns(uint256) {\\r\\n        return _mintAndOrAttach(rootTokenId, payload, msg.sender);\\r\\n    }\\r\\n\\r\\n    function _mintAndOrAttach(uint256 rootTokenId, bytes memory payload, address owner) private returns(uint256) {\\r\\n        uint256 newTokenId = _data.length;\\r\\n        if(rootTokenId != newTokenId) {\\r\\n            require(_owner[rootTokenId] == owner, \\\"Extend an already-existing chain of someone else is forbidden\\\");\\r\\n        }\\r\\n        if(_syntaxCheckerAddress != _voidAddress) {\\r\\n            require(_syntaxChecker.check(rootTokenId, newTokenId, owner, payload, _myAddress), \\\"Invalid payload Syntax\\\");\\r\\n        }\\r\\n        _data.push(payload);\\r\\n        if(rootTokenId == newTokenId) {\\r\\n            _owner[rootTokenId] = owner;\\r\\n        }\\r\\n        _balance[owner] = _balance[owner] + 1;\\r\\n        _root[newTokenId] = rootTokenId;\\r\\n        _positionInChain[newTokenId] = _chain[rootTokenId].length;\\r\\n        _chain[rootTokenId].push(newTokenId);\\r\\n        return newTokenId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @return all the tokenIds that composes the givend NFT\\r\\n      */\\r\\n    function getChain(uint256 tokenId) public view returns(uint256[] memory) {\\r\\n        return _chain[_root[tokenId]];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @return the root NFT of this tokenId\\r\\n      */\\r\\n    function getRoot(uint256 tokenId) public view returns(uint256) {\\r\\n        return _root[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the content of a NFT\\r\\n     */\\r\\n    function getContent(uint256 tokenId) public view returns(bytes memory) {\\r\\n        return _data[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the position in the chain of this NFT\\r\\n     */\\r\\n    function getPositionOf(uint256 tokenId) public view returns(uint256) {\\r\\n        return _positionInChain[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the tokenId of the passed NFT at the given position\\r\\n     */\\r\\n    function getTokenIdAt(uint256 tokenId, uint256 position) public view returns(uint256) {\\r\\n        return _chain[tokenId][position];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Syntactic sugar\\r\\n     * @return the position in the chain, the owner\\u0027s address and content of the given NFT\\r\\n     */\\r\\n    function getCompleteInfo(uint256 tokenId) public view returns(uint256, address, bytes memory) {\\r\\n        return (_positionInChain[tokenId], _owner[_root[tokenId]], _data[tokenId]);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address owner) public view returns (uint256 balance) {\\r\\n        return _balance[owner];\\r\\n    }\\r\\n\\r\\n    function ownerOf(uint256 tokenId) public view returns (address owner) {\\r\\n        return _owner[_root[tokenId]];\\r\\n    }\\r\\n\\r\\n    function approve(address to, uint256 tokenId) public {\\r\\n        require(_root[tokenId] == tokenId, \\\"Only root NFTs can be approved\\\");\\r\\n        require(msg.sender == _owner[tokenId], \\\"Only owner can approve operators\\\");\\r\\n        _tokenOperator[tokenId] = to;\\r\\n        emit Approval(msg.sender, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function getApproved(uint256 tokenId) public view returns (address operator) {\\r\\n        require(_root[tokenId] == tokenId, \\\"Only root NFTs can be approved\\\");\\r\\n        operator = _tokenOperator[tokenId];\\r\\n        if(operator == _voidAddress) {\\r\\n            operator = _ownerOperator[_owner[tokenId]];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address operator, bool _approved) public {\\r\\n        if(!_approved \\u0026\\u0026 operator == _ownerOperator[msg.sender]) {\\r\\n            _ownerOperator[msg.sender] = _voidAddress;\\r\\n        }\\r\\n        if(_approved) {\\r\\n            _ownerOperator[msg.sender] = operator;\\r\\n        }\\r\\n        emit ApprovalForAll(msg.sender, operator, _approved);\\r\\n    }\\r\\n\\r\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\r\\n        return _ownerOperator[owner] == operator;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\r\\n        _transferFrom(msg.sender, from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\r\\n        _safeTransferFrom(msg.sender, from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\\r\\n        _safeTransferFrom(msg.sender, from, to, tokenId, data);\\r\\n    }\\r\\n\\r\\n    function _transferFrom(address sender, address from, address to, uint256 tokenId) private {\\r\\n        require(_root[tokenId] == tokenId, \\\"Only root NFTs can be transfered\\\");\\r\\n        require(_owner[tokenId] == from, \\\"Given from is not the owner of given tokenId\\\");\\r\\n        require(from == sender || getApproved(tokenId) == sender, \\\"Sender not allowed to transfer this tokenId\\\");\\r\\n        _owner[tokenId] = to;\\r\\n        _balance[from] = _balance[from] - 1;\\r\\n        _balance[to] = _balance[to] + 1;\\r\\n        _tokenOperator[tokenId] = _voidAddress;\\r\\n        emit Transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _safeTransferFrom(address sender, address from, address to, uint256 tokenId, bytes memory data) public {\\r\\n        _transferFrom(sender, from, to, tokenId);\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(to) }\\r\\n        require(size \\u003c= 0, \\\"Receiver address is not a contract\\\");\\r\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);\\r\\n        require(retval == 0x150b7a02, \\\"Receiver address does not support the onERC721Received method\\\");\\r\\n    }\\r\\n}\"},\"RobeHTMLWrapper.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./Robe.sol\\\";\\r\\nimport \\\"./IRobeSyntaxChecker.sol\\\";\\r\\n\\r\\n/**\\r\\n  * @title A simple HTML syntax checker\\r\\n  * @author Marco Vasapollo \\u003cceo@metaring.com\\u003e\\r\\n  * @author Alessandro Mario Lagana Toschi \\u003calet@risepic.com\\u003e\\r\\n*/\\r\\ncontract RobeHTMLSyntaxChecker is IRobeSyntaxChecker {\\r\\n\\r\\n    function check(uint256 rootTokenId, uint256 newTokenId, address owner, bytes memory payload, address robeAddress) public view returns(bool) {\\r\\n       //Extremely trivial and simplistic control coded in less than 30 seconds. We will make a more accurate one later\\r\\n        require(payload[0] == \\\"\\u003c\\\");\\r\\n        require(payload[1] == \\\"h\\\");\\r\\n        require(payload[2] == \\\"t\\\");\\r\\n        require(payload[3] == \\\"m\\\");\\r\\n        require(payload[4] == \\\"l\\\");\\r\\n        require(payload[5] == \\\"\\u003e\\\");\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n  * @title A simple HTML-based Robe NFT\\r\\n  * \\r\\n  * @author Marco Vasapollo \\u003cceo@metaring.com\\u003e\\r\\n  * @author Alessandro Mario Lagana Toschi \\u003calet@risepic.com\\u003e\\r\\n*/\\r\\ncontract RobeHTMLWrapper is Robe {\\r\\n\\r\\n    constructor() Robe(address(new RobeHTMLSyntaxChecker())) public {\\r\\n    }\\r\\n\\r\\n    function mint(string memory html) public returns(uint256) {\\r\\n        return super.mint(bytes(html));\\r\\n    }\\r\\n\\r\\n    function mint(uint256 tokenId, string memory html) public returns(uint256) {\\r\\n        return super.mint(tokenId, bytes(html));\\r\\n    }\\r\\n\\r\\n    function getHTML(uint256 tokenId) public view returns(string memory) {\\r\\n        return string(super.getContent(tokenId));\\r\\n    }\\r\\n\\r\\n    function getCompleteInfoInHTML(uint256 tokenId) public view returns(uint256, address, string memory) {\\r\\n        (uint256 position, address owner, bytes memory payload) = super.getCompleteInfo(tokenId);\\r\\n        return (position, owner, string(payload));\\r\\n    }\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getContent\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getHTML\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCompleteInfoInHTML\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCompleteInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"html\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getChain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPositionOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"html\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rootTokenId\",\"type\":\"uint256\"},{\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"getTokenIdAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"RobeHTMLWrapper","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2a31758ea76e7968d2ec4823ab0e01294f8948007a370133d29e6ad385fd7b1d"}]}