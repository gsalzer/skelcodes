{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ninterface KyberReserveIf {\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\n\r\ncontract KyberNetworkIf { \r\n    mapping(address=>address[]) public reservesPerTokenSrc; //reserves supporting token to eth\r\n    mapping(address=>address[]) public reservesPerTokenDest;//reserves support eth to token\r\n}\r\n\r\n\r\ncontract CheckReserveSplit {\r\n    \r\n    ERC20 constant ETH = ERC20(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));\r\n    KyberNetworkIf constant kyber = KyberNetworkIf(0x9ae49C0d7F8F9EF4B864e004FE86Ac8294E20950);\r\n    ERC20 constant dai = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    ERC20 constant usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    \r\n    uint public numSplitRateIteration = 9;\r\n    \r\n    mapping(address=>address[]) reservesPerTokenDest;//reserves supporting eth to token\r\n\r\n    constructor () public {\r\n    }\r\n    \r\n    function setNumSplitRateCalls (uint num) public {\r\n        numSplitRateIteration = num;\r\n    }\r\n    \r\n    function copyReserves(ERC20 token) public {\r\n        \r\n        KyberReserveIf reserve;\r\n        uint index;\r\n        \r\n        while(true) {\r\n            reserve = KyberReserveIf(getReserveTokenDest(address(token), index));\r\n            if (reserve == KyberReserveIf(address(0x0))) break;\r\n            reservesPerTokenDest[address(token)].push(address(reserve));\r\n            index++;\r\n        }        \r\n    }\r\n\r\n    function getBestReservesEthToToken(ERC20 token, uint tradeSizeEth) internal view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        \r\n        KyberReserveIf reserve;\r\n        uint rate;\r\n        index = 0;\r\n        \r\n        // fetch resereves find reserve with best rate and with 2nd best.\r\n        for(uint i = 0; i < reservesPerTokenDest[address(token)].length; i++) {\r\n        \r\n            reserve = KyberReserveIf(reservesPerTokenDest[address(token)][i]);\r\n            if (reserve == KyberReserveIf(address(0x0))) continue;\r\n            rate = reserve.getConversionRate(ETH, token, tradeSizeEth * 10 ** 18, block.number);\r\n            \r\n            if(rate > bestRate) {\r\n                \r\n                if (bestRate > secondRate) {\r\n                    secondRate = bestRate;\r\n                    second = best;\r\n                }\r\n                \r\n                bestRate = rate;\r\n                best = reserve;\r\n            } else if (rate > secondRate) {\r\n                secondRate = rate;\r\n                second = reserve;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getReserveTokenDest (address token, uint index) \r\n        internal view returns (address reserve) \r\n    {\r\n\r\n        (bool success, bytes memory returnData) = \r\n            address(kyber).staticcall(\r\n                abi.encodePacked( // This encodes the function to call and the parameters to pass to that function\r\n                        kyber.reservesPerTokenDest.selector, \r\n                        abi.encode(token, index) \r\n                    )\r\n                );\r\n        \r\n        if (success) {\r\n            reserve = abi.decode(returnData, (address));\r\n        } else { // transferFrom reverted. However, the complete tx did not revert and we can handle the case here.\r\n            reserve = address(0x0);\r\n        }\r\n    }\r\n\r\n    function getBestEthToDaiReserves10Eth() public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        return getBestReservesEthToToken(dai, 10);\r\n    }\r\n    \r\n    function getBestEthToUsdcReserves10Eth() public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        return getBestReservesEthToToken(usdc, 10);\r\n    }\r\n    \r\n    // which eth trade value 2nd best reserve has better rate then best reserve\r\n    function getSplitThresholdEthToToken(ERC20 token, uint tradeSizeEth) internal view \r\n        returns(uint splitThresholdEth, KyberReserveIf best, KyberReserveIf second, uint rateBest, uint rate2nd) \r\n    {\r\n        uint rate;\r\n        \r\n        (best, second, rateBest, rate2nd, ) = getBestReservesEthToToken(token, 55 * tradeSizeEth / 100);\r\n   \r\n        (uint stepSizeWei, uint splitThresholdEthWei) = getBasicStepSizes(token, tradeSizeEth);\r\n        \r\n        uint numSplitCalls = numSplitRateIteration;\r\n\r\n        while (numSplitCalls-- > 0) {\r\n            rate = best.getConversionRate(ETH, token, splitThresholdEthWei, block.number);\r\n            \r\n            stepSizeWei /= 2;\r\n            splitThresholdEthWei += rate < rate2nd ? (- stepSizeWei) : stepSizeWei;\r\n        }\r\n        \r\n        while (rate == 0) {\r\n            splitThresholdEthWei -= (stepSizeWei * 2);\r\n            rate = best.getConversionRate(ETH, token, splitThresholdEthWei, block.number);\r\n        }\r\n        \r\n        splitThresholdEth = splitThresholdEthWei / 10 ** 18;\r\n    }\r\n    \r\n    function getSplitValueEthToToken(ERC20 token, uint tradeSizeEth) internal view \r\n        returns(uint splitValueEth, uint splitThresholdEth, KyberReserveIf best, KyberReserveIf second) \r\n    {\r\n        \r\n        (splitThresholdEth, best, second, , )  = getSplitThresholdEthToToken(token, tradeSizeEth);\r\n        \r\n        if (tradeSizeEth < splitThresholdEth) return (0, splitThresholdEth, best, second);\r\n        \r\n        uint stepSizeEth = (tradeSizeEth - splitThresholdEth) / 2;\r\n        \r\n        uint numSplitCalls = numSplitRateIteration;\r\n        \r\n        uint prevSplitValueEth = splitThresholdEth;\r\n        splitValueEth = splitThresholdEth + stepSizeEth;\r\n        uint refSplitRate = calcCombinedRate(token, best, second, splitThresholdEth, tradeSizeEth);\r\n        uint newSplitRate;\r\n    \r\n\r\n        while (numSplitCalls-- > 0) {\r\n            newSplitRate = calcCombinedRate(token, best, second, splitValueEth, tradeSizeEth);\r\n        \r\n            stepSizeEth /= 2;\r\n            bool isCurrentSplitAmountBigger = splitValueEth > prevSplitValueEth ? true : false;\r\n            prevSplitValueEth = splitValueEth;\r\n            \r\n            if (newSplitRate > refSplitRate) {\r\n                refSplitRate = newSplitRate;\r\n                //if current split value is bigger the previous. and new rate > prev rate, we sould continue positive direction.\r\n                splitValueEth += isCurrentSplitAmountBigger ? stepSizeEth : (-stepSizeEth);\r\n            } else {\r\n                splitValueEth += isCurrentSplitAmountBigger ? (-stepSizeEth) : stepSizeEth;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getBasicStepSizes (ERC20 token, uint tradeSizeEth) internal pure returns(uint stepSizeWei, uint initialSplitValueEthWei) {\r\n        uint minSplitValueEth = 5;\r\n        uint maxSplitValueEth = tradeSizeEth;\r\n        token;\r\n        \r\n        stepSizeWei = (maxSplitValueEth - minSplitValueEth) * 10 ** 18 / 2;\r\n        initialSplitValueEthWei = minSplitValueEth * 10 ** 18 + stepSizeWei;\r\n    }\r\n\r\n    function getDaiSplitThreshold50Eth() public view returns (uint splitThresholdEth) {\r\n        (splitThresholdEth, , , ,) = getSplitThresholdEthToToken(dai, 50);\r\n    }\r\n   \r\n    function getDaiSplitValues(uint tradeSizeEth) public view \r\n        returns (KyberReserveIf bestReserve, uint bestRate, KyberReserveIf secondBest, uint secondRate, uint splitThresholdEth, uint splitValueEth, uint rateBestAfterSplitValue) \r\n    {\r\n        (splitValueEth, splitThresholdEth, bestReserve, secondBest) = getSplitValueEthToToken(dai, tradeSizeEth);\r\n        bestRate = bestReserve.getConversionRate(ETH, dai, 1 ether, block.number);\r\n        secondRate = secondBest.getConversionRate(ETH, dai, 1 ether, block.number);\r\n        rateBestAfterSplitValue = bestReserve.getConversionRate(ETH, dai, (splitValueEth + 1) * 10 ** 18, block.number);\r\n    }\r\n    \r\n    function getUsdcSplitThreshold50Eth() public view returns (uint splitThresholdEth) {\r\n        (splitThresholdEth, , , ,) = getSplitThresholdEthToToken(usdc, 50);\r\n    }\r\n    \r\n    function getUsdcSplitValues(uint tradeSizeEth) public view \r\n        returns (KyberReserveIf bestReserve, uint rate1, KyberReserveIf secondBest, uint rate2, uint splitThresholdEth, uint splitValueEth, uint rateBestAfterSplitValue) \r\n    {\r\n        (splitValueEth, splitThresholdEth, bestReserve, secondBest) = getSplitValueEthToToken(usdc, tradeSizeEth);\r\n        rate1 = bestReserve.getConversionRate(ETH, usdc, 1 ether, block.number);\r\n        rate2 = secondBest.getConversionRate(ETH, usdc, 1 ether, block.number);\r\n        rateBestAfterSplitValue = bestReserve.getConversionRate(ETH, usdc, (splitValueEth + 1) *10 ** 18, block.number);\r\n    }\r\n    \r\n    function compareSplitTrade(ERC20 token, uint tradeValueEth) internal view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint amountSingleReserve, uint amountTwoRes, uint splitValueEth, uint splitThresholdEth) \r\n    {\r\n        KyberReserveIf reserveBest;\r\n        KyberReserveIf reseve2nd;\r\n        \r\n        (splitValueEth, splitThresholdEth, reserveBest, reseve2nd) = getSplitValueEthToToken(token, tradeValueEth);\r\n        if (splitValueEth > tradeValueEth) return(0, 0, 0, 0, splitValueEth, splitThresholdEth);\r\n        \r\n        rateSingleReserve = reserveBest.getConversionRate(ETH, token, splitValueEth * 10 ** 18, block.number);\r\n        rateTwoReserves = calcCombinedRate(token, reserveBest, reseve2nd, splitValueEth, tradeValueEth);\r\n        \r\n        amountSingleReserve = (rateSingleReserve / 10 ** 18) * tradeValueEth;\r\n        amountTwoRes = (rateTwoReserves / 10 ** 18) * tradeValueEth;\r\n    }\r\n    \r\n    function getDaiSplitValueGas() public \r\n        returns (KyberReserveIf bestReserve, uint bestRate, KyberReserveIf secondBest, uint secondRate, uint splitThresholdEth, uint splitValueEth, uint rateBestAfterSplitValue) \r\n    {\r\n        return getDaiSplitValues(120);\r\n    }\r\n    \r\n    function viewSplitTradeEthToDai(uint tradeValueEth)\r\n        public view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint amountSingleReserve, uint amountTwoRes, uint splitValueEth, uint splitThresholdEth) \r\n    {\r\n        return compareSplitTrade(dai, tradeValueEth);\r\n    }\r\n    \r\n    function viewSplitTradeEthToUsdc(uint tradeValueEth)\r\n        public view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint amountSingleReserve, uint amountTwoRes, uint splitValueEth, uint splitThresholdEth) \r\n    {\r\n        return compareSplitTrade(usdc, tradeValueEth);\r\n    }\r\n    \r\n    function calcCombinedRate(ERC20 token, KyberReserveIf best, KyberReserveIf second, uint splitValueEth, uint tradeValueEth)\r\n        internal view returns(uint rate)\r\n    {\r\n        uint rate1 = best.getConversionRate(ETH, token, splitValueEth * 10 ** 18, block.number);\r\n        uint rate2 = second.getConversionRate(ETH, token, (tradeValueEth - splitValueEth) * 10 ** 18, block.number);\r\n        rate = (rate1 * splitValueEth + rate2 * (tradeValueEth - splitValueEth)) / tradeValueEth;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeValueEth\",\"type\":\"uint256\"}],\"name\":\"viewSplitTradeEthToDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateTwoReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTwoRes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setNumSplitRateCalls\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeValueEth\",\"type\":\"uint256\"}],\"name\":\"viewSplitTradeEthToUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateTwoReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTwoRes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numSplitRateIteration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeSizeEth\",\"type\":\"uint256\"}],\"name\":\"getUsdcSplitValues\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"bestReserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate1\",\"type\":\"uint256\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"secondBest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBestAfterSplitValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUsdcSplitThreshold50Eth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBestEthToUsdcReserves10Eth\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"best\",\"type\":\"address\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"second\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDaiSplitThreshold50Eth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBestEthToDaiReserves10Eth\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"best\",\"type\":\"address\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"second\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeSizeEth\",\"type\":\"uint256\"}],\"name\":\"getDaiSplitValues\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"bestReserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"secondBest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBestAfterSplitValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDaiSplitValueGas\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"bestReserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"secondBest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBestAfterSplitValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"copyReserves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CheckReserveSplit","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://c481c7d5d8888b10b8222b1f254cd83133af424ea45f395faefd064010abe063"}]}