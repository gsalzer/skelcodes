{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-07-08\r\n*/\r\n\r\npragma solidity ^0.5.5;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two unsigned integers, reverts on overflow.\r\n  */\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) return 0;\r\n    uint c = a * b;\r\n    require(c / a == b, \"SM: mul error\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SM: div error\");\r\n    uint c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a, \"SM: sub error\");\r\n    uint c = a - b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two unsigned integers, reverts on overflow.\r\n  */\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a, \"SM: add error\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint a, uint b) internal pure returns (uint) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\nlibrary DaoLib {\r\n  struct Daoist {\r\n    address daoist;\r\n    uint64 shares;\r\n  }\r\n\r\n  struct DaoistOutput {\r\n    address daoist;\r\n    uint64 shares;\r\n    uint248 index;\r\n  }\r\n\r\n  struct TokenValue {\r\n    address tokenAddress;\r\n    uint256 value;\r\n  }\r\n\r\n  struct Application {\r\n    bytes32 metaHash;\r\n    uint256 weiTribute;\r\n    address applicant;\r\n    address[] tokenTributes;\r\n    uint256[] tokenTributeValues;\r\n    uint64 shares;\r\n  }\r\n}\r\n\r\nlibrary Indices {\r\n  struct Index {\r\n    bool exists;\r\n    uint248 index;\r\n  }\r\n}\r\n\r\n/**\r\n * @title BaseDAOStorage\r\n * @author Dillon Kellar, Raymond Pulver\r\n * @dev Storage and getters for BaseDao.sol\r\n * @notice Makes the contract less cluttered by separating getters and storage setup into a separate contract.\r\n */\r\ncontract BaseDAOStorage {\r\n  using SafeMath for uint64;\r\n  using SafeMath for uint256;\r\n\r\n  uint256 internal _multiplier = 2 finney;\r\n  uint64 internal _totalShares;\r\n  DaoLib.Daoist[] internal _daoists;\r\n  mapping(address => Indices.Index) internal _daoistIndices;\r\n  IERC20[] internal _tokens;\r\n  mapping(address => Indices.Index) internal _tokenIndices;\r\n\r\n  function getTotalShares() external view returns (uint64 totalShares) {\r\n    totalShares = _totalShares;\r\n  }\r\n\r\n  function getDaoist(address daoistAddress) public view returns (DaoLib.DaoistOutput memory daoist) {\r\n    Indices.Index memory index = _daoistIndices[daoistAddress];\r\n    require(index.exists, \"ExeDAO: Daoist not found\");\r\n    DaoLib.Daoist memory _daoist = _daoists[index.index];\r\n    daoist = DaoLib.DaoistOutput(_daoist.daoist, _daoist.shares, index.index);\r\n  }\r\n\r\n  function getDaoists() external view returns (DaoLib.Daoist[] memory daoists) {\r\n    uint256 size = _daoists.length;\r\n    daoists = new DaoLib.Daoist[](size);\r\n    for (uint256 i = 0; i < size; i++) daoists[i] = _daoists[i];\r\n  }\r\n\r\n  function getToken(address tokenAddress) external view returns (DaoLib.TokenValue memory tokenValue) {\r\n    IERC20 _token = _getToken(tokenAddress);\r\n    uint256 balance = _token.balanceOf(address(this));\r\n    tokenValue = DaoLib.TokenValue(address(_token), balance);\r\n  }\r\n\r\n  function getTokens() external view returns (DaoLib.TokenValue[] memory tokenBalances) {\r\n    uint256 size = _tokens.length;\r\n    tokenBalances = new DaoLib.TokenValue[](size);\r\n    for (uint256 i = 0; i < size; i++) {\r\n      uint256 balance = _tokens[i].balanceOf(address(this));\r\n      tokenBalances[i] = DaoLib.TokenValue(address(_tokens[i]), balance);\r\n    }\r\n  }\r\n\r\n  function _getToken(address tokenAddress) internal view returns (IERC20 token) {\r\n    Indices.Index memory index = _tokenIndices[tokenAddress];\r\n    require(index.exists, \"ExeDAO: Token not found\");\r\n    token = _tokens[index.index];\r\n  }\r\n}\r\n\r\ninterface IBaseDAO {\r\n  function getDaoist(address daoistAddress) external view returns (DaoLib.DaoistOutput memory daoist);\r\n  function getDaoists() external view returns (DaoLib.Daoist[] memory daoists);\r\n  function getToken(address tokenAddress) external view returns (DaoLib.TokenValue memory token);\r\n  function getTokens() external view returns (DaoLib.TokenValue[] memory tokens);\r\n  function burnShares(uint64 amount) external returns(uint256 weiValue, DaoLib.TokenValue[] memory tokenBurnValues);\r\n}\r\n\r\n/**\r\n * @title BaseDAO\r\n * @author Dillon Kellar, Raymond Pulver\r\n * @notice Keeps track of who owns shares in a DAO and provides a method for burning shares in exchange for ether owned by the contract.\r\n * @dev Does not expose any external methods for giving shares, must be handled by child\r\n */\r\ncontract BaseDAO is IBaseDAO, BaseDAOStorage {\r\n  event SharesBurned(address indexed daoist, uint64 shares);\r\n  event SharesMinted(address indexed daoist, uint64 shares);\r\n  event TokenAdded(address indexed tokenAddress);\r\n  event TokenRemoved(address indexed tokenAddress);\r\n  event TokenTransferred(address indexed tokenAddress, address indexed recipient, uint256 amount);\r\n  event TokenReceived(address indexed tokenAddress, address indexed sender, uint256 amount);\r\n\r\n\r\n  constructor(uint64 shares) public payable {\r\n    _mintShares(msg.sender, shares);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of shares owned by the sender. Reverts if the user has no shares.\r\n   */\r\n  function _getShares() internal view returns (uint64 shares) {\r\n    shares = getDaoist(msg.sender).shares;\r\n    require(shares > 0, \"ExeDAO: Not a daoist\");\r\n  }\r\n\r\n  function burnShares(uint64 amount) external\r\n  returns(uint256 weiValue, DaoLib.TokenValue[] memory tokenBurnValues) {\r\n    DaoLib.DaoistOutput memory _daoist = getDaoist(msg.sender);\r\n    require(_daoist.shares >= amount, \"Not enough shares\");\r\n    // use large multiplier to avoid rounding errors\r\n    uint256 relativeShare = _multiplier.mul(amount).div(_totalShares);\r\n    // subtract shares prior to sending anything to prevent reentrance\r\n    _daoists[_daoist.index].shares = uint64(_daoist.shares.sub(amount));\r\n    _totalShares = uint64(_totalShares.sub(amount));\r\n    uint256 numTokens = _tokens.length;\r\n    tokenBurnValues = new DaoLib.TokenValue[](numTokens);\r\n    uint256 shareValue;\r\n    uint256 balance;\r\n    for (uint256 i = 0; i < numTokens; i++) {\r\n      IERC20 token = _tokens[i];\r\n      balance = token.balanceOf(address(this));\r\n      shareValue = relativeShare.mul(balance).div(_multiplier);\r\n      token.transfer(msg.sender, shareValue);\r\n      tokenBurnValues[i] = DaoLib.TokenValue(address(token), shareValue);\r\n    }\r\n    weiValue = address(this).balance.mul(relativeShare).div(_multiplier);\r\n    msg.sender.transfer(weiValue);\r\n    emit SharesBurned(msg.sender, amount);\r\n  }\r\n\r\n  function _mintShares(address recipient, uint64 amount) internal {\r\n    Indices.Index memory index = _daoistIndices[recipient];\r\n    if (!index.exists) {\r\n      _daoistIndices[recipient] = Indices.Index(true, uint248(_daoists.length));\r\n      _daoists.push(DaoLib.Daoist(recipient, amount));\r\n    } else {\r\n      _daoists[index.index].shares = uint64(_daoists[index.index].shares.add(amount));\r\n    }\r\n    _totalShares = uint64(_totalShares.add(amount));\r\n    emit SharesMinted(recipient, amount);\r\n  }\r\n\r\n  function _addToken(address tokenAddress) internal {\r\n    Indices.Index memory index = _tokenIndices[tokenAddress];\r\n    require(!index.exists, \"ExeDAO: Token already exists\");\r\n    _tokenIndices[tokenAddress] = Indices.Index(true, uint248(_tokens.length));\r\n    _tokens.push(IERC20(tokenAddress));\r\n    emit TokenAdded(tokenAddress);\r\n  }\r\n\r\n  function _removeToken(address tokenAddress) internal {\r\n    Indices.Index memory index = _tokenIndices[tokenAddress];\r\n    require(index.exists, \"ExeDAO: Token not found\");\r\n    delete _tokenIndices[tokenAddress];\r\n    delete _tokens[index.index];\r\n    emit TokenRemoved(tokenAddress);\r\n  }\r\n\r\n  function _approveTokenTransfer(address tokenAddress, address spender, uint256 amount) internal {\r\n    IERC20 token = _getToken(tokenAddress);\r\n    require(token.approve(spender, amount), \"ExeDAO: Approve transfer failed\");\r\n  }\r\n\r\n  function _receiveToken(address tokenAddress, address sender, uint256 amount) internal {\r\n    IERC20 token = _getToken(tokenAddress);\r\n    require(token.transferFrom(sender, address(this), amount), \"exeDAO: transferFrom failed.\");\r\n    emit TokenReceived(tokenAddress, sender, amount);\r\n  }\r\n\r\n  function _transferToken(address tokenAddress, address recipient, uint256 amount) internal {\r\n    IERC20 token = _getToken(tokenAddress);\r\n    require(token.transfer(recipient, amount), \"ExeDAO: Transfer failed\");\r\n    emit TokenTransferred(tokenAddress, recipient, amount);\r\n  }\r\n}\r\n\r\nlibrary Proposals {\r\n  struct Proposal {\r\n    bytes32 proposalHash;\r\n    uint64 votes;\r\n    uint64 expiryBlock;\r\n    mapping(address => bool) voters;\r\n  }\r\n\r\n  struct ProposalOutput {\r\n    bytes32 proposalHash;\r\n    bytes32 metaHash;\r\n    uint64 votes;\r\n    uint64 expiryBlock;\r\n    uint256 proposalIndex;\r\n  }\r\n\r\n  function votesRemaining (uint64 totalShares, uint64 votes, uint8 approvalRequirement)\r\n  internal pure returns (uint64) {\r\n    uint64 totalNeeded = totalShares * approvalRequirement / 100;\r\n    if (votes >= totalNeeded) return 0;\r\n    else return totalNeeded - votes;\r\n  }\r\n}\r\n\r\n/**\r\n * @title PermissionedStorage\r\n * @author Dillon Kellar, Raymond Pulver\r\n * @dev Storage and getters for Permissioned.sol\r\n * @notice Makes the contract less cluttered by separating getters and storage setup into a separate contract.\r\n */\r\ncontract PermissionedStorage {\r\n  uint64 internal _proposalDuration;\r\n  Indices.Index internal _lastExpiredProposal;\r\n  Proposals.Proposal[] internal _proposals;\r\n  mapping(bytes32 => Indices.Index) internal _proposalIndices;\r\n  mapping(bytes4 => uint8) internal _approvalRequirements;\r\n  mapping(bytes32 => bytes32) internal _proposalMetaHashes;\r\n  // mapping(address => mapping(uint256 => bool)) internal _offlineNonces;\r\n\r\n  function getApprovalRequirement(bytes4 funcSig) external view returns (uint8 requirement) {\r\n    requirement = _approvalRequirements[funcSig];\r\n  }\r\n\r\n  function getApprovalRequirements(bytes4[] calldata funcSigs) external view\r\n  returns (uint8[] memory requirements) {\r\n    uint256 size = funcSigs.length;\r\n    requirements = new uint8[](size);\r\n    for (uint256 i = 0; i < size; i++) requirements[i] = _approvalRequirements[funcSigs[i]];\r\n  }\r\n\r\n  /** @dev allows clients to retrieve index and proposal data in one call */\r\n  function getProposal(bytes32 proposalHash) external view\r\n  returns (Proposals.ProposalOutput memory ret) {\r\n    Indices.Index memory index = _proposalIndices[proposalHash];\r\n    require(index.exists, \"ExeDAO: Proposal not found\");\r\n    Proposals.Proposal memory proposal = _proposals[index.index];\r\n    ret = Proposals.ProposalOutput(\r\n      proposalHash, _proposalMetaHashes[proposalHash],\r\n      proposal.votes, proposal.expiryBlock, index.index\r\n    );\r\n  }\r\n\r\n  function getOpenProposals() external view\r\n  returns (Proposals.ProposalOutput[] memory proposals) {\r\n    Indices.Index memory lastExpired = _lastExpiredProposal;\r\n    uint256 startIndex = lastExpired.exists ? lastExpired.index + 1 : 0;\r\n    uint256 size = _proposals.length - startIndex;\r\n    proposals = new Proposals.ProposalOutput[](size);\r\n    for (uint256 i = 0; i < size; i++) {\r\n      uint256 index = startIndex + i;\r\n      Proposals.Proposal memory proposal = _proposals[index];\r\n      bytes32 proposalHash = proposal.proposalHash;\r\n      proposals[i] = Proposals.ProposalOutput(\r\n        proposalHash, _proposalMetaHashes[proposalHash],\r\n        proposal.votes, proposal.expiryBlock, index\r\n      );\r\n    }\r\n  }\r\n\r\n  function getProposalMetaHash(bytes32 proposalHash)\r\n  external view returns(bytes32 metaHash) {\r\n    return _proposalMetaHashes[proposalHash];\r\n  }\r\n}\r\n\r\ncontract IPermissioned is IBaseDAO {\r\n  function transferEther(address payable recipient, uint256 weiToSend) external;\r\n  function getApprovalRequirement(bytes4 funcSig) external view returns (uint8 requirement);\r\n  function getApprovalRequirements(bytes4[] calldata funcSigs) external view returns (uint8[] memory requirements);\r\n  function getOpenProposals() external view returns (Proposals.ProposalOutput[] memory proposals);\r\n  function getProposal(bytes32 proposalHash) external view returns (Proposals.ProposalOutput memory ret);\r\n  function setProposalDuration(uint64 duration) external;\r\n  function mintShares(address recipient, uint64 amount) external;\r\n  function setApprovalRequirement(bytes4 funcSig, uint8 approvalRequirement) external;\r\n  function submitOrVote(bytes32 proposalHash) external returns(uint, uint);\r\n  function submitWithMetaHash(bytes32 proposalHash, bytes32 metaHash) external returns(uint256 index);\r\n  function closeProposal(bytes32 proposalHash) external;\r\n  /* function supplyOfflineVotesWithCall(\r\n    bytes calldata wrappedCalldata,\r\n    bytes[] calldata sigs,\r\n    uint256[] calldata nonces,\r\n    bytes32[] calldata proposalHashes\r\n  ) external returns (bytes memory); */\r\n  function addToken(address tokenAddress) external;\r\n  function removeToken(address tokenAddress) external;\r\n  function approveTokenTransfer(address tokenAddress, address spender, uint256 amount) external;\r\n  function transferToken(address tokenAddress, address recipient, uint256 amount) external;\r\n  function receiveToken(address tokenAddress, address sender, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title Permissioned\r\n * @notice Generic contract for creating, cancelling and processing _proposals to execute functions.\r\n * @dev Approval requirements are set per function signature.\r\n */\r\ncontract Permissioned is IPermissioned, BaseDAO, PermissionedStorage {\r\n  // using SignatureUnpack for bytes;\r\n\r\n  event ProposalSubmission(address indexed submitter, bytes32 indexed proposalHash, bytes32 metaHash, uint64 votesCast);\r\n  event ProposalVote(address indexed voter, bytes32 indexed proposalHash, uint64 votesCast);\r\n  event ProposalApproval(address indexed voter, bytes32 indexed proposalHash);\r\n  event ProposalExpiration(bytes32 indexed proposalHash);\r\n\r\n  constructor(\r\n    uint64 shares, uint64 proposalDuration,\r\n    bytes4[] memory funcSigs, uint8[] memory requirements\r\n  ) public payable BaseDAO(shares) {\r\n    require(funcSigs.length == requirements.length, \"Inconsistent inputs\");\r\n    for (uint256 i = 0; i < funcSigs.length; i++) {\r\n      uint8 approvalRequirement = requirements[i];\r\n      require(\r\n        approvalRequirement < 101 || approvalRequirement == 255,\r\n        \"Can not set empty requirement\"\r\n      );\r\n      _approvalRequirements[funcSigs[i]] = approvalRequirement;\r\n    }\r\n    _proposalDuration = proposalDuration;\r\n  }\r\n\r\n  function setProposalDuration(uint64 duration) external {\r\n    if (_voteAndContinue()) _proposalDuration = duration;\r\n  }\r\n\r\n  function mintShares(address recipient, uint64 amount) external {\r\n    if (_voteAndContinue()) _mintShares(recipient, amount);\r\n  }\r\n\r\n  function addToken(address tokenAddress) external {\r\n    if (_voteAndContinue()) _addToken(tokenAddress);\r\n  }\r\n\r\n  function removeToken(address tokenAddress) external {\r\n    if (_voteAndContinue()) _removeToken(tokenAddress);\r\n  }\r\n\r\n  function approveTokenTransfer(address tokenAddress, address spender, uint256 amount) external {\r\n    if (_voteAndContinue()) _approveTokenTransfer(tokenAddress, spender, amount);\r\n  }\r\n\r\n  function transferToken(address tokenAddress, address recipient, uint256 amount) external {\r\n    if (_voteAndContinue()) _transferToken(tokenAddress, recipient, amount);\r\n  }\r\n\r\n  function receiveToken(address tokenAddress, address sender, uint256 amount) external {\r\n    if (_voteAndContinue()) _receiveToken(tokenAddress, sender, amount);\r\n  }\r\n\r\n  function transferEther(address payable recipient, uint256 weiToSend) external {\r\n    if (_voteAndContinue()) recipient.transfer(weiToSend);\r\n  }\r\n\r\n  /**\r\n   * @dev Set the requirement for execution of a function.\r\n   * @param funcSig The signature of the function which approval is being set for.\r\n   * funcSig can not be the signature for setApprovalRequirement.\r\n   * @param approvalRequirement Percentage of shares which must be met for an approval to be accepted.\r\n   * If approvalRequirement is 0, the function can not be called by anyone. If it is 255, it does not require approval.\r\n   */\r\n  function setApprovalRequirement(bytes4 funcSig, uint8 approvalRequirement) external {\r\n    require(funcSig != msg.sig, \"ExeDAO: Can not modify requirement for setApprovalRequirement\");\r\n    require(approvalRequirement < 101 || approvalRequirement == 255, \"ExeDAO: Bad approvalRequirement\");\r\n    if (_voteAndContinue()) _approvalRequirements[funcSig] = approvalRequirement;\r\n  }\r\n\r\n  function submitOrVote(bytes32 proposalHash) external returns(uint, uint) {\r\n    uint64 shares = _getShares();\r\n    Indices.Index memory index = _proposalIndices[proposalHash];\r\n    _submitOrVote(msg.sender, proposalHash, shares, index);\r\n    Proposals.Proposal memory proposal = _proposals[index.index];\r\n    return(proposal.votes, proposal.expiryBlock);\r\n  }\r\n\r\n  /**\r\n   * @notice Create a proposal and set an ipfs hash for finding data about it.\r\n   * @dev The calldata for a proposal can be uploaded to IPFS with keccak-sha256 as the hash algorithm.\r\n   * For proposals to execute code or add extensions, it is useful to be able to share the raw code which compiles\r\n   * to the contract bytecode for easy verification of what is being executed without needing to audit the bytecode.\r\n   * For private proposals, the IPFS hash could point to ciphertext which only daoists can decrypt via some key exchange.\r\n   */\r\n  function submitWithMetaHash(bytes32 proposalHash, bytes32 metaHash) external returns(uint256 index) {\r\n    uint64 shares = _getShares();\r\n    Indices.Index memory _index = _proposalIndices[proposalHash];\r\n    require(!_index.exists, \"ExeDAO: Proposal already exists\");\r\n    index = _index.index;\r\n    _submitOrVote(msg.sender, proposalHash, shares, _index);\r\n    _proposalMetaHashes[proposalHash] = metaHash;\r\n  }\r\n\r\n  /** @dev Cancel a proposal if it has expired. */\r\n  function closeProposal(bytes32 proposalHash) external {\r\n    Indices.Index memory index = _proposalIndices[proposalHash];\r\n    Proposals.Proposal memory proposal = _proposals[index.index];\r\n    if (proposal.expiryBlock <= block.number) {\r\n      delete _proposals[index.index];\r\n      delete _proposalIndices[proposalHash];\r\n      if (_proposalMetaHashes[proposalHash] != 0) delete _proposalMetaHashes[proposalHash];\r\n      if (index.index > _lastExpiredProposal.index) _lastExpiredProposal = index;\r\n      emit ProposalExpiration(proposalHash);\r\n    }\r\n  }\r\n\r\n  /* function supplyOfflineVotesWithCall(\r\n    bytes calldata wrappedCalldata,\r\n    bytes[] calldata sigs,\r\n    uint256[] calldata nonces,\r\n    bytes32[] calldata proposalHashes\r\n  ) external returns (bytes memory) {\r\n    for (uint256 i = 0; i < sigs.length; i++) {\r\n      address voter = sigs[i].recoverOffline(nonces[i], proposalHashes[i]);\r\n      require(!_offlineNonces[voter][nonces[i]], \"ExeDAO: Nonce already used\");\r\n      _offlineNonces[voter][nonces[i]] = true;\r\n      DaoLib.DaoistOutput memory daoist = getDaoist(voter);\r\n      require(daoist.shares > 0, \"ExeDAO: Signature supplied from non-daoist\");\r\n      uint64 shares = daoist.shares;\r\n      Indices.Index memory index = _proposalIndices[proposalHashes[i]];\r\n      _submitOrVote(voter, proposalHashes[i], shares, index);\r\n    }\r\n    (, bytes memory retval) = address(this).delegatecall(wrappedCalldata);\r\n    // if this call throws it doesn't matter, allow anyone to pay the gas to submit offline signatures even in the absence of valid calldata\r\n    return retval;\r\n  } */\r\n\r\n  /**\r\n   * @dev Call _submitOrVote() and return true if the proposal is approved, false if not.\r\n   */\r\n  function _voteAndContinue() internal returns (bool) {\r\n    bytes32 proposalHash = keccak256(msg.data);\r\n    (uint64 shares, Indices.Index memory index, bool approved) = _preProcessProposal(proposalHash);\r\n    if (approved) {\r\n      if (index.exists) {\r\n        delete _proposals[index.index];\r\n        delete _proposalIndices[proposalHash];\r\n        if (_proposalMetaHashes[proposalHash] != 0) delete _proposalMetaHashes[proposalHash];\r\n      }\r\n      emit ProposalApproval(msg.sender, proposalHash);\r\n    } else _submitOrVote(msg.sender, proposalHash, shares, index);\r\n    return approved;\r\n  }\r\n\r\n  /**\r\n   * @dev Determines whether a proposal would be accepted given the caller's votes.\r\n   */\r\n  function _preProcessProposal(bytes32 proposalHash) internal view\r\n  returns (uint64 shares, Indices.Index memory index, bool approved) {\r\n    uint8 approvalRequirement = _approvalRequirements[msg.sig];\r\n    index = _proposalIndices[proposalHash];\r\n    if (approvalRequirement == 255) return (0, index, true);\r\n    shares = _getShares();\r\n    uint64 totalNeeded = Proposals.votesRemaining(_totalShares, 0, approvalRequirement);\r\n    if (!index.exists) approved = shares >= totalNeeded;\r\n    else {\r\n      uint64 votes = _proposals[index.index].votes;\r\n      if (votes >= totalNeeded) approved = true;\r\n      else approved = shares >= (totalNeeded - votes);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Create a proposal if it does not exist, vote on it otherwise.\r\n   */\r\n  function _submitOrVote(address voter, bytes32 proposalHash, uint64 shares, Indices.Index memory index) internal {\r\n    if (!index.exists) {\r\n      Indices.Index memory _index = Indices.Index(true, uint248(_proposals.length));\r\n      _proposalIndices[proposalHash] = _index;\r\n      _proposals.push(Proposals.Proposal(proposalHash, shares, uint64(block.number + _proposalDuration)));\r\n      _proposals[_index.index].voters[voter] = true;\r\n      emit ProposalSubmission(voter, proposalHash, _proposalMetaHashes[proposalHash], shares);\r\n    } else {\r\n      Proposals.Proposal storage proposal = _proposals[index.index];\r\n      require(proposal.expiryBlock > block.number, \"ExeDAO: Proposal expired\");\r\n      if (!proposal.voters[voter]) {\r\n        proposal.voters[voter] = true;\r\n        proposal.votes = uint64(proposal.votes.add(shares));\r\n        emit ProposalVote(voter, proposalHash, shares);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlibrary ExeLib {\r\n  struct Extension {\r\n    bytes32 metaHash; // used to share abi and function descriptions\r\n    address extensionAddress;\r\n    bool useDelegate;\r\n    bytes bytecode;\r\n    bytes4[] functionSignatures;\r\n  }\r\n\r\n  function isPermissible (bytes memory bytecode)\r\n  internal pure returns (bool) {\r\n    uint256 size = bytecode.length;\r\n    uint256 permissible = 1;\r\n    assembly {\r\n      let ptr := add(bytecode, 0x20)\r\n      for { let i := 0 } and(lt(i, size), permissible) { i := add(i, 0x1) } {\r\n        let op := shr(0xf8, mload(add(ptr, i)))\r\n        switch op\r\n        case 0xf2 { permissible := 0 } // callcode\r\n        case 0xf4 { permissible := 0 } // delegatecall\r\n        case 0x55 { permissible := 0 } // sstore\r\n        case 0xff { permissible := 0 } // selfdestruct\r\n        default {\r\n          let isPush := and(lt(op, 0x80), gt(op, 0x5f))\r\n          if eq(isPush, 0x1) { i := add(i, sub(op, 0x5f)) }\r\n        }\r\n      }\r\n    }\r\n    return permissible == 1;\r\n  }\r\n\r\n  function deploy(bytes memory bytecode) internal returns (address extAddress) {\r\n    uint256 size = bytecode.length;\r\n    assembly {\r\n      let start := add(bytecode, 0x20)\r\n      extAddress := create(0, start, size)\r\n    }\r\n  }\r\n\r\n  function delegateExecute(bytes memory bytecode) internal {\r\n    uint256 size = bytecode.length;\r\n    assembly {\r\n      let retptr := mload(0x40)\r\n      let start := add(bytecode, 0x20)\r\n      let delegateTo := create(0, start, size)\r\n      if iszero(delegateTo) {\r\n        returndatacopy(retptr, 0, returndatasize)\r\n        revert(retptr, returndatasize)\r\n      }\r\n      let delegateSuccess := delegatecall(gas, delegateTo, 0, 0, retptr, 0)\r\n      returndatacopy(retptr, 0, returndatasize)\r\n      if iszero(delegateSuccess) { revert(retptr, returndatasize) }\r\n      return (retptr, returndatasize)\r\n    }\r\n  }\r\n\r\n  function delegateExecute(address delegateTo) internal {\r\n    assembly {\r\n      let startCalldata := mload(0x40)\r\n      calldatacopy(startCalldata, 0, calldatasize)\r\n      let retptr := add(startCalldata, calldatasize)\r\n      let delegateSuccess := delegatecall(gas, delegateTo, startCalldata, calldatasize, retptr, 0)\r\n      returndatacopy(retptr, 0, returndatasize)\r\n      if delegateSuccess { return (retptr, returndatasize) }\r\n      revert(retptr, returndatasize)\r\n    }\r\n  }\r\n\r\n  function doCall(address callAddress) internal {\r\n    assembly {\r\n      let startCalldata := mload(0x40)\r\n      calldatacopy(startCalldata, 0, calldatasize)\r\n      let retptr := add(startCalldata, calldatasize)\r\n      let callSuccess := call(gas, callAddress, callvalue, startCalldata, calldatasize, retptr, 0)\r\n      returndatacopy(retptr, 0, returndatasize)\r\n      if callSuccess { return (retptr, returndatasize) }\r\n      revert(retptr, returndatasize)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title ExtendableStorage\r\n * @author Dillon Kellar, Raymond Pulver\r\n * @dev Storage and getters for Extendable.sol\r\n * @notice Makes the contract less cluttered by separating getters and storage setup into a separate contract.\r\n */\r\ncontract ExtendableStorage {\r\n  using ExeLib for address;\r\n  using ExeLib for bytes;\r\n\r\n  ExeLib.Extension[] internal _extensions;\r\n  mapping(bytes4 => Indices.Index) internal _extensionFor;\r\n\r\n  function getExtension(uint256 index) external view returns (ExeLib.Extension memory) {\r\n    return _extensions[index];\r\n  }\r\n\r\n  function getExtensions() external view\r\n  returns (ExeLib.Extension[] memory) { return _extensions; }\r\n\r\n  function getExtensionFor(bytes4 funcSig) external view\r\n  returns (ExeLib.Extension memory extension) {\r\n    Indices.Index memory index = _extensionFor[funcSig];\r\n    require(index.exists, \"ExeDAO: Extension not found\");\r\n    return _extensions[index.index];\r\n  }\r\n}\r\n\r\ncontract IExtendable is IPermissioned {\r\n  function getExtension(uint256 index) external view returns (ExeLib.Extension memory);\r\n  function getExtensionFor(bytes4 funcSig) external view returns (ExeLib.Extension memory extension);\r\n  function getExtensions() external view returns (ExeLib.Extension[] memory);\r\n  function removeExtension(uint256 extIndex) external;\r\n  function addExtension(ExeLib.Extension memory extension) public;\r\n}\r\n\r\ncontract Extendable is IExtendable, Permissioned, ExtendableStorage {\r\n  event ExtensionAdded(uint256 extensionIndex, bytes32 metaHash);\r\n\r\n  constructor(\r\n    uint64 shares, uint64 _proposalDuration,\r\n    bytes4[] memory funcSigs, uint8[] memory requirements\r\n  ) public payable Permissioned(shares, _proposalDuration, funcSigs, requirements) {}\r\n\r\n  function () external payable {\r\n    Indices.Index memory index = _extensionFor[msg.sig];\r\n    if (index.exists) {\r\n      if (_voteAndContinue()) {\r\n        ExeLib.Extension memory extension = _extensions[index.index];\r\n        if (extension.useDelegate) extension.extensionAddress.delegateExecute();\r\n        else extension.extensionAddress.doCall();\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeExtension(uint256 extIndex) external {\r\n    if (_voteAndContinue()) {\r\n      ExeLib.Extension memory ext = _extensions[extIndex];\r\n      for (uint256 i = 0; i < ext.functionSignatures.length; i++) {\r\n        bytes4 funcSig = ext.functionSignatures[i];\r\n        delete _extensionFor[funcSig];\r\n        if (_approvalRequirements[funcSig] != 0) delete _approvalRequirements[funcSig];\r\n      }\r\n      delete _extensions[extIndex];\r\n    }\r\n  }\r\n\r\n  function addExtension(ExeLib.Extension memory extension) public {\r\n    if (extension.useDelegate) require(\r\n      extension.bytecode.length > 0 && extension.bytecode.isPermissible(),\r\n      \"ExeDAO: Bytecode not allowed\"\r\n    );\r\n    if (_voteAndContinue()) {\r\n      if (extension.useDelegate) {\r\n        extension.extensionAddress = extension.bytecode.deploy();\r\n        delete extension.bytecode;\r\n      }\r\n      uint256 index = _extensions.length;\r\n      _extensions.push(extension);\r\n      bytes4[] memory funcSigs = extension.functionSignatures;\r\n      for (uint256 i = 0; i < funcSigs.length; i++) {\r\n        require(!_extensionFor[funcSigs[i]].exists, \"ExeDAO: Approval already set for function\");\r\n        _extensionFor[funcSigs[i]] = Indices.Index(true, uint248(index));\r\n      }\r\n      emit ExtensionAdded(index, extension.metaHash);\r\n    }\r\n  }\r\n}\r\n\r\ncontract ExeDAOStorage {\r\n  uint256 internal _minimumTribute;\r\n  Indices.Index internal _lastExpiredApplication;\r\n  DaoLib.Application[] internal _applications;\r\n  mapping(address => Indices.Index) internal _applicationIndices;\r\n\r\n  function getMinimumTribute() external view returns (uint256 minimum) {\r\n    minimum = _minimumTribute;\r\n  }\r\n\r\n  function getApplication(address applicant) external view\r\n  returns (DaoLib.Application memory application) {\r\n    Indices.Index memory index = _applicationIndices[applicant];\r\n    require(index.exists, \"ExeDAO: Application not found\");\r\n    return _applications[index.index];\r\n  }\r\n\r\n  function getOpenApplications() external view\r\n  returns (DaoLib.Application[] memory applications) {\r\n    Indices.Index memory lastExpired = _lastExpiredApplication;\r\n    uint256 startIndex = lastExpired.exists ? lastExpired.index + 1 : 0;\r\n    uint256 size = _applications.length - startIndex;\r\n    applications = new DaoLib.Application[](size);\r\n    for (uint256 i = 0; i < size; i++) {\r\n      uint256 index = startIndex + i;\r\n      applications[i] = _applications[index];\r\n    }\r\n  }\r\n}\r\n\r\ncontract IExeDAO is IExtendable {\r\n  function getApplication(address applicant) external view returns (DaoLib.Application memory application);\r\n  function getOpenApplications() external view returns (DaoLib.Application[] memory applications);\r\n  function getMinimumTribute() external view returns (uint256 minimum);\r\n  function setMinimumTribute(uint256 minimum) external;\r\n  function safeExecute(bytes calldata bytecode) external;\r\n  function submitApplication(bytes32 metaHash, uint64 shares, DaoLib.TokenValue[] calldata tokenTributes) external payable;\r\n  function executeApplication(address applicant) external;\r\n}\r\n\r\ncontract ExeDAO is IExeDAO, Extendable, ExeDAOStorage {\r\n  event ApplicationAdded(address applicant, uint64 shares);\r\n  event ApplicationCanceled(address applicant);\r\n\r\n  constructor(\r\n    uint64 shares, uint64 _proposalDuration,\r\n    bytes4[] memory funcSigs, uint8[] memory requirements\r\n  ) public payable Extendable(shares, _proposalDuration, funcSigs, requirements) {}\r\n\r\n  function setMinimumTribute(uint256 minimum) external {\r\n    if (_voteAndContinue()) _minimumTribute = minimum;\r\n  }\r\n\r\n  function safeExecute(bytes calldata bytecode) external {\r\n    require(bytecode.isPermissible(), \"ExeDAO: Bytecode not allowed\");\r\n    if (_voteAndContinue()) bytecode.delegateExecute();\r\n  }\r\n\r\n  /**\r\n   * @dev Apply to join the DAO and lock some wei/tokens.\r\n   */\r\n  function submitApplication(bytes32 metaHash, uint64 shares, DaoLib.TokenValue[] calldata tokenTributes) external payable {\r\n    require(!_daoistIndices[msg.sender].exists, \"ExeDAO: Already a daoist\");\r\n    Indices.Index memory index = _applicationIndices[msg.sender];\r\n    require(!index.exists, \"ExeDAO: Application pending\");\r\n    require(shares > 0, \"ExeDAO: Can not apply for 0 shares\");\r\n    require(msg.value >= _minimumTribute, \"ExeDAO: Insufficient wei tribute for application\");\r\n    uint256 tokenCount = tokenTributes.length;\r\n    address[] memory lockedTokens = new address[](tokenCount);\r\n    uint256[] memory lockedTokenValues = new uint256[](tokenCount);\r\n    for (uint256 i = 0; i < tokenCount; i++) {\r\n      DaoLib.TokenValue memory tokenTribute = tokenTributes[i];\r\n      _receiveToken(tokenTribute.tokenAddress, msg.sender, tokenTribute.value);\r\n      lockedTokens[i] = tokenTribute.tokenAddress;\r\n      lockedTokenValues[i] = tokenTribute.value;\r\n    }\r\n    DaoLib.Application memory application = DaoLib.Application(metaHash, msg.value, msg.sender, lockedTokens, lockedTokenValues, shares);\r\n    index = Indices.Index(true, uint248(_applications.length));\r\n    _applicationIndices[msg.sender] = index;\r\n    _applications.push(application);\r\n    emit ApplicationAdded(msg.sender, shares);\r\n  }\r\n\r\n  /**\r\n   * @dev For buyer, cancel the offer and reclaim wei if a proposal has not been\r\n   * started by a daoist or has expired. For daoists, vote to accept the offer.\r\n   */\r\n  function executeApplication(address applicant) external {\r\n    Indices.Index memory index = _applicationIndices[applicant];\r\n    require(index.exists, \"ExeDAO: Application not found\");\r\n    DaoLib.Application memory application = _applications[index.index];\r\n    if (msg.sender == applicant) {\r\n      Indices.Index memory proposalIndex = _proposalIndices[keccak256(msg.data)];\r\n      if (proposalIndex.exists) {\r\n        require(\r\n          block.number >= _proposals[index.index].expiryBlock,\r\n          \"ExeDAO: Must wait for proposal to finish\"\r\n        );\r\n        if (index.index > _lastExpiredApplication.index) _lastExpiredApplication = index;\r\n      }\r\n      delete _applications[index.index];\r\n      delete _applicationIndices[applicant];\r\n      emit ApplicationCanceled(applicant);\r\n      msg.sender.transfer(application.weiTribute);\r\n      for (uint256 i = 0; i < application.tokenTributes.length; i++) {\r\n        _transferToken(application.tokenTributes[i], msg.sender, application.tokenTributeValues[i]);\r\n      }\r\n    }\r\n    else if (_voteAndContinue()) {\r\n      delete _applications[index.index];\r\n      delete _applicationIndices[applicant];\r\n      _mintShares(applicant, application.shares);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"setProposalDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"weiToSend\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"closeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"daoistAddress\",\"type\":\"address\"}],\"name\":\"getDaoist\",\"outputs\":[{\"components\":[{\"name\":\"daoist\",\"type\":\"address\"},{\"name\":\"shares\",\"type\":\"uint64\"},{\"name\":\"index\",\"type\":\"uint248\"}],\"name\":\"daoist\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"getProposalMetaHash\",\"outputs\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"funcSig\",\"type\":\"bytes4\"}],\"name\":\"getExtensionFor\",\"outputs\":[{\"components\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"extensionAddress\",\"type\":\"address\"},{\"name\":\"useDelegate\",\"type\":\"bool\"},{\"name\":\"bytecode\",\"type\":\"bytes\"},{\"name\":\"functionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"extension\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bytecode\",\"type\":\"bytes\"}],\"name\":\"safeExecute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"votes\",\"type\":\"uint64\"},{\"name\":\"expiryBlock\",\"type\":\"uint64\"},{\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"ret\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receiveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"extensionAddress\",\"type\":\"address\"},{\"name\":\"useDelegate\",\"type\":\"bool\"},{\"name\":\"bytecode\",\"type\":\"bytes\"},{\"name\":\"functionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"extension\",\"type\":\"tuple\"}],\"name\":\"addExtension\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getToken\",\"outputs\":[{\"components\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenValue\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"funcSig\",\"type\":\"bytes4\"},{\"name\":\"approvalRequirement\",\"type\":\"uint8\"}],\"name\":\"setApprovalRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDaoists\",\"outputs\":[{\"components\":[{\"name\":\"daoist\",\"type\":\"address\"},{\"name\":\"shares\",\"type\":\"uint64\"}],\"name\":\"daoists\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExtensions\",\"outputs\":[{\"components\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"extensionAddress\",\"type\":\"address\"},{\"name\":\"useDelegate\",\"type\":\"bool\"},{\"name\":\"bytecode\",\"type\":\"bytes\"},{\"name\":\"functionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"applicant\",\"type\":\"address\"}],\"name\":\"getApplication\",\"outputs\":[{\"components\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"weiTribute\",\"type\":\"uint256\"},{\"name\":\"applicant\",\"type\":\"address\"},{\"name\":\"tokenTributes\",\"type\":\"address[]\"},{\"name\":\"tokenTributeValues\",\"type\":\"uint256[]\"},{\"name\":\"shares\",\"type\":\"uint64\"}],\"name\":\"application\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"shares\",\"type\":\"uint64\"},{\"components\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenTributes\",\"type\":\"tuple[]\"}],\"name\":\"submitApplication\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenProposals\",\"outputs\":[{\"components\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"votes\",\"type\":\"uint64\"},{\"name\":\"expiryBlock\",\"type\":\"uint64\"},{\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"funcSigs\",\"type\":\"bytes4[]\"}],\"name\":\"getApprovalRequirements\",\"outputs\":[{\"name\":\"requirements\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinimumTribute\",\"outputs\":[{\"name\":\"minimum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"metaHash\",\"type\":\"bytes32\"}],\"name\":\"submitWithMetaHash\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenBalances\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"extIndex\",\"type\":\"uint256\"}],\"name\":\"removeExtension\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint64\"}],\"name\":\"burnShares\",\"outputs\":[{\"name\":\"weiValue\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenBurnValues\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"name\":\"totalShares\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint64\"}],\"name\":\"mintShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"submitOrVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"applicant\",\"type\":\"address\"}],\"name\":\"executeApplication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimum\",\"type\":\"uint256\"}],\"name\":\"setMinimumTribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenApplications\",\"outputs\":[{\"components\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"weiTribute\",\"type\":\"uint256\"},{\"name\":\"applicant\",\"type\":\"address\"},{\"name\":\"tokenTributes\",\"type\":\"address[]\"},{\"name\":\"tokenTributeValues\",\"type\":\"uint256[]\"},{\"name\":\"shares\",\"type\":\"uint64\"}],\"name\":\"applications\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getExtension\",\"outputs\":[{\"components\":[{\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"name\":\"extensionAddress\",\"type\":\"address\"},{\"name\":\"useDelegate\",\"type\":\"bool\"},{\"name\":\"bytecode\",\"type\":\"bytes\"},{\"name\":\"functionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"funcSig\",\"type\":\"bytes4\"}],\"name\":\"getApprovalRequirement\",\"outputs\":[{\"name\":\"requirement\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"shares\",\"type\":\"uint64\"},{\"name\":\"_proposalDuration\",\"type\":\"uint64\"},{\"name\":\"funcSigs\",\"type\":\"bytes4[]\"},{\"name\":\"requirements\",\"type\":\"uint8[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint64\"}],\"name\":\"ApplicationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"applicant\",\"type\":\"address\"}],\"name\":\"ApplicationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"extensionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metaHash\",\"type\":\"bytes32\"}],\"name\":\"ExtensionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"metaHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votesCast\",\"type\":\"uint64\"}],\"name\":\"ProposalSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votesCast\",\"type\":\"uint64\"}],\"name\":\"ProposalVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalExpiration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"daoist\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint64\"}],\"name\":\"SharesBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"daoist\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint64\"}],\"name\":\"SharesMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReceived\",\"type\":\"event\"}]","ContractName":"ExeDAO","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000000d05b1137b00000000000000000000000000000000000000000000000000000000f024a95a00000000000000000000000000000000000000000000000000000000345a22cd00000000000000000000000000000000000000000000000000000000e033f73c0000000000000000000000000000000000000000000000000000000053f45e9c00000000000000000000000000000000000000000000000000000000b920ef7100000000000000000000000000000000000000000000000000000000daa0853900000000000000000000000000000000000000000000000000000000701c3c280000000000000000000000000000000000000000000000000000000002e4879d00000000000000000000000000000000000000000000000000000000d48bfca70000000000000000000000000000000000000000000000000000000052a23bbb00000000000000000000000000000000000000000000000000000000f5537ede000000000000000000000000000000000000000000000000000000004ec109f400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000033000000000000000000000000000000000000000000000000000000000000004b00000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000000000000000000000000000004b000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000210000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000ff","Library":"","SwarmSource":"bzzr://577d557e1d0675846940f64014c45410265329f90c3de6b3e4baa804d7961733"}]}