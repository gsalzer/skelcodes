{"status":"1","message":"OK","result":[{"SourceCode":"/**\n\nDeployed by Ren Project, https://renproject.io\n\nCommit hash: ca69adf\nRepository: https://github.com/renproject/darknode-sol\nIssues: https://github.com/renproject/darknode-sol/issues\n\nLicenses\nopenzeppelin-solidity: (MIT) https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/LICENSE\ndarknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE\n\n*/\n\npragma solidity ^0.5.8;\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary ECDSA {\n    \n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        \n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        \n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        \n        \n        \n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        \n        return ecrecover(hash, v, r, s);\n    }\n\n    \n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        \n        \n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\nlibrary String {\n\n    \n    function fromBytes32(bytes32 _value) internal pure returns(string memory) {\n        bytes32 value = bytes32(uint256(_value));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(32 * 2 + 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint i = 0; i < 32; i++) {\n            str[2+i*2] = alphabet[uint(uint8(value[i] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(value[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    \n    function fromAddress(address _addr) internal pure returns(string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(20 * 2 + 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint i = 0; i < 20; i++) {\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    \n    function add4(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b, c, d));\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    \n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract Claimable {\n    address private _pendingOwner;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"caller is not the owner\");\n        _;\n    }\n\n    \n    modifier onlyPendingOwner() {\n      require(msg.sender == _pendingOwner, \"caller is not the pending owner\");\n      _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n      _pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership() public onlyPendingOwner {\n      emit OwnershipTransferred(_owner, _pendingOwner);\n      _owner = _pendingOwner;\n      _pendingOwner = address(0);\n    }\n}\n\ncontract ERC20Shifted is ERC20, ERC20Detailed, Claimable {\n\n    \n    constructor(string memory _name, string memory _symbol, uint8 _decimals) public ERC20Detailed(_name, _symbol, _decimals) {}\n\n    function burn(address _from, uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n    }\n}\n\ncontract zBTC is ERC20Shifted(\"Shifted BTC\", \"zBTC\", 8) {}\n\ncontract zZEC is ERC20Shifted(\"Shifted ZEC\", \"zZEC\", 8) {}\n\ncontract Shifter is Ownable {\n    using SafeMath for uint256;\n\n    uint8 public version = 2;\n\n    uint256 constant BIPS_DENOMINATOR = 10000;\n    uint256 public minShiftAmount;\n\n    \n    ERC20Shifted public token;\n\n    \n    address public mintAuthority;\n\n    \n    \n    \n    \n    address public feeRecipient;\n\n    \n    uint16 public fee;\n\n    \n    mapping (bytes32=>bool) public status;\n\n    \n    \n    uint256 public nextShiftID = 0;\n\n    event LogShiftIn(\n        address indexed _to,\n        uint256 _amount,\n        uint256 indexed _shiftID\n    );\n    event LogShiftOut(\n        bytes _to,\n        uint256 _amount,\n        uint256 indexed _shiftID,\n        bytes indexed _indexedTo\n    );\n\n    \n    \n    \n    \n    \n    \n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _fee, uint256 _minShiftOutAmount) public {\n        minShiftAmount = _minShiftOutAmount;\n        token = _token;\n        mintAuthority = _mintAuthority;\n        fee = _fee;\n        updateFeeRecipient(_feeRecipient);\n    }\n\n    \n\n    \n    \n    \n    function claimTokenOwnership() public {\n        token.claimOwnership();\n    }\n\n    \n    function transferTokenOwnership(Shifter _nextTokenOwner) public onlyOwner {\n        token.transferOwnership(address(_nextTokenOwner));\n        _nextTokenOwner.claimTokenOwnership();\n    }\n\n    \n    \n    \n    function updateMintAuthority(address _nextMintAuthority) public onlyOwner {\n        mintAuthority = _nextMintAuthority;\n    }\n\n    \n    \n    \n    function updateMinimumShiftOutAmount(uint256 _minShiftOutAmount) public onlyOwner {\n        minShiftAmount = _minShiftOutAmount;\n    }\n\n    \n    \n    \n    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {\n        \n        require(_nextFeeRecipient != address(0x0), \"fee recipient cannot be 0x0\");\n\n        feeRecipient = _nextFeeRecipient;\n    }\n\n    \n    \n    \n    function updateFee(uint16 _nextFee) public onlyOwner {\n        fee = _nextFee;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\n        \n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n        require(status[signedMessageHash] == false, \"nonce hash already spent\");\n        if (!verifySignature(signedMessageHash, _sig)) {\n            \n            \n            \n            revert(\n                String.add4(\n                    \"invalid signature - hash: \",\n                    String.fromBytes32(signedMessageHash),\n                    \", signer: \",\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n                )\n            );\n        }\n        status[signedMessageHash] = true;\n\n        \n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n        token.mint(msg.sender, receivedAmount);\n        token.mint(feeRecipient, absoluteFee);\n\n        \n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID);\n        nextShiftID += 1;\n\n        return receivedAmount;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function shiftOut(bytes memory _to, uint256 _amount) public returns (uint256) {\n        \n        \n        require(_to.length != 0, \"to address is empty\");\n        require(_amount >= minShiftAmount, \"amount is less than the minimum shiftOut amount\");\n\n        \n        uint256 absoluteFee = (_amount.mul(fee)).div(BIPS_DENOMINATOR);\n        token.burn(msg.sender, _amount);\n        token.mint(feeRecipient, absoluteFee);\n\n        \n        uint256 receivedValue = _amount.sub(absoluteFee);\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n        nextShiftID += 1;\n\n        return receivedValue;\n    }\n\n    \n    \n    function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\n    }\n\n    \n    function hashForSignature(bytes32 _pHash, uint256 _amount, address _to, bytes32 _nHash) public view returns (bytes32) {\n        return keccak256(abi.encode(_pHash, _amount, address(token), _to, _nHash));\n    }\n}\n\ncontract BTCShifter is Shifter {\n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _fee, uint256 _minShiftOutAmount)\n        Shifter(_token, _feeRecipient, _mintAuthority, _fee, _minShiftOutAmount) public {\n        }\n}\n\ncontract ZECShifter is Shifter {\n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _fee, uint256 _minShiftOutAmount)\n        Shifter(_token, _feeRecipient, _mintAuthority, _fee, _minShiftOutAmount) public {\n        }\n}\n\ncontract DEXReserve is ERC20 {\n    uint256 FeeInBIPS;\n    ERC20 public BaseToken;\n    ERC20 public Token;\n    event LogAddLiquidity(address _liquidityProvider, uint256 _tokenAmount, uint256 _baseTokenAmount);\n    event LogDebug(uint256 _rcvAmount);\n\n    constructor (ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public {\n        BaseToken = _baseToken;\n        Token = _token;\n        FeeInBIPS = _feeInBIPS;\n    }\n\n    function buy(address _to, address _from, uint256 _baseTokenAmount) external returns (uint256)  {\n        require(totalSupply() != 0, \"reserve has no funds\");\n        uint256 rcvAmount = calculateBuyRcvAmt(_baseTokenAmount);\n        BaseToken.transferFrom(_from, address(this), _baseTokenAmount);\n        require(rcvAmount < Token.balanceOf(address(this)), \"insufficient balance\");\n        require(Token.transfer(_to, rcvAmount), \"failed to transfer quote token\");\n        return rcvAmount;\n    }\n\n    function sell(address _to, address _from, uint256 _tokenAmount) external returns (uint256) {\n        require(totalSupply() != 0, \"reserve has no funds\");\n        uint256 rcvAmount = calculateSellRcvAmt(_tokenAmount);\n        Token.transferFrom(_from, address(this), _tokenAmount);\n        require(BaseToken.transfer(_to, rcvAmount), \"failed to transfer base token\");\n        return rcvAmount;\n    }\n\n    function calculateBuyRcvAmt(uint256 _sendAmt) public view returns (uint256) {\n        uint256 daiReserve = BaseToken.balanceOf(address(this));\n        uint256 tokenReserve = Token.balanceOf(address(this));\n        uint256 finalQuoteTokenAmount = (daiReserve.mul(tokenReserve)).div(daiReserve.add(_sendAmt));\n        uint256 rcvAmt = tokenReserve.sub(finalQuoteTokenAmount);\n        return _removeFees(rcvAmt);\n    }\n\n    function calculateSellRcvAmt(uint256 _sendAmt) public view returns (uint256) {\n        uint256 daiReserve = BaseToken.balanceOf(address(this));\n        uint256 tokenReserve = Token.balanceOf(address(this));\n        uint256 finalBaseTokenAmount = (daiReserve.mul(tokenReserve)).div(tokenReserve.add(_sendAmt));\n        uint256 rcvAmt = daiReserve.sub(finalBaseTokenAmount);\n        return _removeFees(rcvAmt);\n    }\n\n    function removeLiquidity(uint256 _liquidity) external returns (uint256, uint256) {\n        require(balanceOf(msg.sender) >= _liquidity, \"insufficient balance\");\n        uint256 baseTokenAmount = calculateBaseTokenValue(_liquidity);\n        uint256 quoteTokenAmount = calculateQuoteTokenValue(_liquidity);\n        _burn(msg.sender, _liquidity);\n        BaseToken.transfer(msg.sender, baseTokenAmount);\n        Token.transfer(msg.sender, quoteTokenAmount);\n        return (baseTokenAmount, quoteTokenAmount);\n    }\n\n    function addLiquidity(\n        address _liquidiyProvider, uint256 _maxBaseToken, uint256 _tokenAmount, uint256 _deadline\n        ) external returns (uint256) {\n        require(_deadline > block.number, \"addLiquidity request expired\");\n        Token.transferFrom(msg.sender, address(this), _tokenAmount);\n        if (totalSupply() > 0) {\n            require(_tokenAmount > 0, \"token amount is less than allowed min amount\");\n            uint256 daiAmount = expectedBaseTokenAmount(_tokenAmount);\n            require(daiAmount < _maxBaseToken && BaseToken.transferFrom(_liquidiyProvider, address(this), daiAmount), \"failed to transfer base token\");\n            emit LogAddLiquidity(_liquidiyProvider, _tokenAmount, daiAmount);\n        } else {\n            require(BaseToken.transferFrom(_liquidiyProvider, address(this), _maxBaseToken), \"failed to transfer base token\");\n            emit LogAddLiquidity(_liquidiyProvider, _tokenAmount, _maxBaseToken);\n        }\n        _mint(_liquidiyProvider, _tokenAmount*2);\n        return _tokenAmount*2;\n    }\n\n    function calculateBaseTokenValue(uint256 _liquidity) public view returns (uint256) {\n        require(totalSupply() != 0, \"Division by Zero\");\n        uint256 daiReserve = BaseToken.balanceOf(address(this));\n        return (_liquidity * daiReserve)/totalSupply();\n    }\n\n    function calculateQuoteTokenValue(uint256 _liquidity) public view returns (uint256) {\n        require(totalSupply() != 0, \"Division by Zero\");\n        uint256 tokenReserve = Token.balanceOf(address(this));\n        return (_liquidity * tokenReserve)/totalSupply();\n    }\n\n    function expectedBaseTokenAmount(uint256 _quoteTokenAmount) public view returns (uint256) {\n        uint256 daiReserve = BaseToken.balanceOf(address(this));\n        uint256 tokenReserve = Token.balanceOf(address(this));\n        return (_quoteTokenAmount * daiReserve)/tokenReserve;\n    }\n\n    function _removeFees(uint256 _amount) internal view returns (uint256) {\n        return (_amount * (10000 - FeeInBIPS))/10000;\n    }\n}\n\ncontract BTC_DAI_Reserve is DEXReserve {\n    constructor (ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public DEXReserve(_baseToken, _token, _feeInBIPS) {\n    }\n}\n\ncontract ZEC_DAI_Reserve is DEXReserve {\n    constructor (ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public DEXReserve(_baseToken, _token, _feeInBIPS) {\n    }\n}\n\ncontract DEX {\n    mapping (address=>DEXReserve) public reserves;\n    address public BaseToken;\n    address public ethereum = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n\n    event LogTrade(address _src, address _dst, uint256 _sendAmount, uint256 _recvAmount);\n\n    constructor(address _baseToken) public {\n        BaseToken = _baseToken;\n    }\n\n    \n    \n    function recoverTokens(address _token) external {\n        if (_token == address(0x0)) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    function registerReserve(address _erc20, DEXReserve _reserve) external {\n        require(reserves[_erc20] == DEXReserve(0x0), \"token reserve already registered\");\n        reserves[_erc20] = _reserve;\n    }\n\n    function trade(address _to, address _src, address _dst, uint256 _sendAmount) public returns (uint256) {\n        uint256 recvAmount;\n        if (_src == BaseToken) {\n            require(reserves[_dst] != DEXReserve(0x0), \"unsupported token\");\n            recvAmount = reserves[_dst].buy(_to, msg.sender, _sendAmount);\n        } else if (_dst == BaseToken) {\n            require(reserves[_src] != DEXReserve(0x0), \"unsupported token\");\n            recvAmount = reserves[_src].sell(_to, msg.sender, _sendAmount);\n        } else {\n            require(reserves[_src] != DEXReserve(0x0) && reserves[_dst] != DEXReserve(0x0), \"unsupported token\");\n            uint256 intermediteAmount = reserves[_src].sell(address(this), msg.sender, _sendAmount);\n            ERC20(BaseToken).approve(address(reserves[_dst]), intermediteAmount);\n            recvAmount = reserves[_dst].buy(_to, address(this), intermediteAmount);\n        }\n        emit LogTrade(_src, _dst, _sendAmount, recvAmount);\n        return recvAmount;\n    }\n\n    function calculateReceiveAmount(address _src, address _dst, uint256 _sendAmount) public view returns (uint256) {\n        if (_src == BaseToken) {\n            return reserves[_dst].calculateBuyRcvAmt(_sendAmount);\n        }\n        if (_dst == BaseToken) {\n            return reserves[_src].calculateSellRcvAmt(_sendAmount);\n        }\n        return reserves[_dst].calculateBuyRcvAmt(reserves[_src].calculateSellRcvAmt(_sendAmount));\n    }\n}\n\nlibrary LinkedList {\n\n    \n    address public constant NULL = address(0);\n\n    \n    struct Node {\n        bool inList;\n        address previous;\n        address next;\n    }\n\n    \n    struct List {\n        mapping (address => Node) list;\n    }\n\n    \n    function insertBefore(List storage self, address target, address newNode) internal {\n        require(!isInList(self, newNode), \"already in list\");\n        require(isInList(self, target) || target == NULL, \"not in list\");\n\n        \n        address prev = self.list[target].previous;\n\n        self.list[newNode].next = target;\n        self.list[newNode].previous = prev;\n        self.list[target].previous = newNode;\n        self.list[prev].next = newNode;\n\n        self.list[newNode].inList = true;\n    }\n\n    \n    function insertAfter(List storage self, address target, address newNode) internal {\n        require(!isInList(self, newNode), \"already in list\");\n        require(isInList(self, target) || target == NULL, \"not in list\");\n\n        \n        address n = self.list[target].next;\n\n        self.list[newNode].previous = target;\n        self.list[newNode].next = n;\n        self.list[target].next = newNode;\n        self.list[n].previous = newNode;\n\n        self.list[newNode].inList = true;\n    }\n\n    \n    function remove(List storage self, address node) internal {\n        require(isInList(self, node), \"not in list\");\n        if (node == NULL) {\n            return;\n        }\n        address p = self.list[node].previous;\n        address n = self.list[node].next;\n\n        self.list[p].next = n;\n        self.list[n].previous = p;\n\n        \n        \n        self.list[node].inList = false;\n        delete self.list[node];\n    }\n\n    \n    function prepend(List storage self, address node) internal {\n        \n\n        insertBefore(self, begin(self), node);\n    }\n\n    \n    function append(List storage self, address node) internal {\n        \n\n        insertAfter(self, end(self), node);\n    }\n\n    function swap(List storage self, address left, address right) internal {\n        \n\n        address previousRight = self.list[right].previous;\n        remove(self, right);\n        insertAfter(self, left, right);\n        remove(self, left);\n        insertAfter(self, previousRight, left);\n    }\n\n    function isInList(List storage self, address node) internal view returns (bool) {\n        return self.list[node].inList;\n    }\n\n    \n    function begin(List storage self) internal view returns (address) {\n        return self.list[NULL].next;\n    }\n\n    \n    function end(List storage self) internal view returns (address) {\n        return self.list[NULL].previous;\n    }\n\n    function next(List storage self, address node) internal view returns (address) {\n        require(isInList(self, node), \"not in list\");\n        return self.list[node].next;\n    }\n\n    function previous(List storage self, address node) internal view returns (address) {\n        require(isInList(self, node), \"not in list\");\n        return self.list[node].previous;\n    }\n\n}\n\ninterface IShifter {\n    function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\n    function shiftOut(bytes calldata _to, uint256 _amount) external returns (uint256);\n}\n\ncontract ShifterRegistry is Claimable {\n\n    \n    \n    event LogShifterRegistered(string _symbol, string indexed _indexedSymbol, address indexed _tokenAddress, address indexed _shifterAddress);\n    event LogShifterDeregistered(string _symbol, string indexed _indexedSymbol, address indexed _tokenAddress, address indexed _shifterAddress);\n    event LogShifterUpdated(address indexed _tokenAddress, address indexed _currentShifterAddress, address indexed _newShifterAddress);\n\n    \n    uint256 numShifters = 0;\n\n    \n    LinkedList.List private shifterList;\n\n    \n    LinkedList.List private shiftedTokenList;\n\n    \n    mapping (address=>address) private shifterByToken;\n\n    \n    mapping (string=>address) private tokenBySymbol;\n\n    \n    \n    \n    \n    \n    function setShifter(address _tokenAddress, address _shifterAddress) external onlyOwner {\n        \n        require(!LinkedList.isInList(shifterList, _shifterAddress), \"shifter already registered\");\n        require(shifterByToken[_tokenAddress] == address(0x0), \"token already registered\");\n        string memory symbol = ERC20Shifted(_tokenAddress).symbol();\n        require(tokenBySymbol[symbol] == address(0x0), \"symbol already registered\");\n\n        \n        LinkedList.append(shifterList, _shifterAddress);\n\n        \n        LinkedList.append(shiftedTokenList, _tokenAddress);\n\n        tokenBySymbol[symbol] = _tokenAddress;\n        shifterByToken[_tokenAddress] = _shifterAddress;\n        numShifters += 1;\n\n        emit LogShifterRegistered(symbol, symbol, _tokenAddress, _shifterAddress);\n    }\n\n    \n    \n    \n    \n    \n    function updateShifter(address _tokenAddress, address _newShifterAddress) external onlyOwner {\n        \n        address currentShifter = shifterByToken[_tokenAddress];\n        require(shifterByToken[_tokenAddress] != address(0x0), \"token not registered\");\n\n        \n        LinkedList.remove(shifterList, currentShifter);\n\n        \n        LinkedList.append(shifterList, _newShifterAddress);\n\n        shifterByToken[_tokenAddress] = _newShifterAddress;\n\n        emit LogShifterUpdated(_tokenAddress, currentShifter, _newShifterAddress);\n    }\n\n    \n    \n    \n    \n    function removeShifter(string calldata _symbol) external onlyOwner {\n        \n        address tokenAddress = tokenBySymbol[_symbol];\n        require(tokenAddress != address(0x0), \"symbol not registered\");\n\n        \n        address shifterAddress = shifterByToken[tokenAddress];\n\n        \n        shifterByToken[tokenAddress] = address(0x0);\n        tokenBySymbol[_symbol] = address(0x0);\n        LinkedList.remove(shifterList, shifterAddress);\n        LinkedList.remove(shiftedTokenList, tokenAddress);\n        numShifters -= 1;\n\n        emit LogShifterDeregistered(_symbol, _symbol, tokenAddress, shifterAddress);\n    }\n\n    \n    function getShifters(address _start, uint256 _count) external view returns (address[] memory) {\n        uint256 count;\n        if (_count == 0) {\n            count = numShifters;\n        } else {\n            count = _count;\n        }\n\n        address[] memory shifters = new address[](count);\n\n        \n        uint256 n = 0;\n        address next = _start;\n        if (next == address(0)) {\n            next = LinkedList.begin(shifterList);\n        }\n\n        while (n < count) {\n            if (next == address(0)) {\n                break;\n            }\n            shifters[n] = next;\n            next = LinkedList.next(shifterList, next);\n            n += 1;\n        }\n        return shifters;\n    }\n\n    \n    function getShiftedTokens(address _start, uint256 _count) external view returns (address[] memory) {\n        uint256 count;\n        if (_count == 0) {\n            count = numShifters;\n        } else {\n            count = _count;\n        }\n\n        address[] memory shiftedTokens = new address[](count);\n\n        \n        uint256 n = 0;\n        address next = _start;\n        if (next == address(0)) {\n            next = LinkedList.begin(shiftedTokenList);\n        }\n\n        while (n < count) {\n            if (next == address(0)) {\n                break;\n            }\n            shiftedTokens[n] = next;\n            next = LinkedList.next(shiftedTokenList, next);\n            n += 1;\n        }\n        return shiftedTokens;\n    }\n\n    \n    \n    \n    \n    function getShifterByToken(address _tokenAddress) external view returns (IShifter) {\n        return IShifter(shifterByToken[_tokenAddress]);\n    }\n\n    \n    \n    \n    \n    function getShifterBySymbol(string calldata _tokenSymbol) external view returns (IShifter) {\n        return IShifter(shifterByToken[tokenBySymbol[_tokenSymbol]]);\n    }\n\n    \n    \n    \n    \n    function getTokenBySymbol(string calldata _tokenSymbol) external view returns (address) {\n        return tokenBySymbol[_tokenSymbol];\n    }\n}\n\ncontract DEXAdapter {\n    DEX public dex;\n    ShifterRegistry public shifterRegistry;\n\n    event LogTransferIn(address src, uint256 amount);\n    event LogTransferOut(address dst, uint256 amount);\n\n    constructor(DEX _dex, ShifterRegistry _shifterRegistry) public {\n        shifterRegistry = _shifterRegistry;\n        dex = _dex;\n    }\n\n    \n    \n    function recoverTokens(address _token) external {\n        if (_token == address(0x0)) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\n        }\n    }\n\n    \n    uint256 transferredAmt;\n\n    function trade(\n        \n         address _src, address _dst, uint256 _minDstAmt, bytes calldata _to,\n        uint256 _refundBN, bytes calldata _refundAddress,\n        \n        uint256 _amount, bytes32 _nHash, bytes calldata _sig\n    ) external {\n        transferredAmt;\n        bytes32 pHash = hashTradePayload(_src, _dst, _minDstAmt, _to, _refundBN, _refundAddress);\n        \n        if (block.number >= _refundBN) {\n            IShifter shifter = shifterRegistry.getShifterByToken(address(_src));\n            if (shifter != IShifter(0x0)) {\n                transferredAmt = shifter.shiftIn(pHash, _amount, _nHash, _sig);\n                shifter.shiftOut(_refundAddress, transferredAmt);\n            }\n            return;\n        }\n\n        transferredAmt = _transferIn(_src, _amount, _nHash, pHash, _sig);\n        emit LogTransferIn(_src, transferredAmt);\n        _doTrade(_src, _dst, _minDstAmt, _to, transferredAmt);\n    }\n\n    function hashTradePayload(\n         address _src, address _dst, uint256 _minDstAmt, bytes memory _to,\n        uint256 _refundBN, bytes memory _refundAddress\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_src, _dst, _minDstAmt, _to, _refundBN, _refundAddress));\n    }\n\n    function hashLiquidityPayload(\n        address _liquidityProvider,  uint256 _maxBaseToken, address _token, uint256 _amount,\n        uint256 _refundBN, bytes memory _refundAddress\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(_liquidityProvider, _maxBaseToken, _token, _amount, _refundBN, _refundAddress));\n    }\n\n    function encodePayload(\n         ERC20 _src, ERC20 _dst, uint256 _minDstAmt, bytes memory _to,\n        uint256 _refundBN, bytes memory _refundAddress\n    ) public pure returns (bytes memory) {\n        return abi.encode(_src, _dst, _minDstAmt, _to, _refundBN, _refundAddress);\n    }\n\n    function addLiquidity(\n        address _liquidityProvider,  uint256 _maxBaseToken, address _token, uint256 _deadline, bytes calldata _refundAddress,\n        uint256 _amount, bytes32 _nHash, bytes calldata _sig\n        ) external returns (uint256) {\n            DEXReserve reserve = dex.reserves(_token);\n            require(reserve != DEXReserve(0x0), \"unsupported token\");\n            bytes32 lpHash = hashLiquidityPayload(_liquidityProvider, _maxBaseToken, _token, _amount, _deadline, _refundAddress);\n            if (block.number > _deadline) {\n                uint256 shiftedAmount = shifterRegistry.getShifterByToken(_token).shiftIn(lpHash, _amount, _nHash, _sig);\n                shifterRegistry.getShifterByToken(_token).shiftOut(_refundAddress, shiftedAmount);\n                return 0;\n            }\n            require(ERC20(dex.BaseToken()).allowance(_liquidityProvider, address(reserve)) >= _maxBaseToken,\n                \"insufficient base token allowance\");\n            uint256 transferredAmount = _transferIn(_token, _amount, _nHash, lpHash, _sig);\n            ERC20(_token).approve(address(reserve), transferredAmount);\n            return reserve.addLiquidity(_liquidityProvider, _maxBaseToken, transferredAmount, _deadline);\n    }\n\n    function removeLiquidity(address _token, uint256 _liquidity, bytes calldata _tokenAddress) external {\n        DEXReserve reserve = dex.reserves(_token);\n        require(reserve != DEXReserve(0x0), \"unsupported token\");\n        reserve.transferFrom(msg.sender, address(this), _liquidity);\n        (uint256 baseTokenAmount, uint256 quoteTokenAmount) = reserve.removeLiquidity(_liquidity);\n        reserve.BaseToken().transfer(msg.sender, baseTokenAmount);\n        shifterRegistry.getShifterByToken(address(reserve.Token())).shiftOut(_tokenAddress, quoteTokenAmount);\n    }\n\n    function _doTrade(\n        address _src, address _dst, uint256 _minDstAmt, bytes memory _to, uint256 _amount\n    ) internal {\n        uint256 recvAmt;\n        address to;\n        IShifter shifter = shifterRegistry.getShifterByToken(address(_dst));\n\n        if (shifter != IShifter(0x0)) {\n            to = address(this);\n        } else {\n            to = _bytesToAddress(_to);\n        }\n\n        if (_src == dex.BaseToken()) {\n            ERC20(_src).approve(address(dex.reserves(_dst)), _amount);\n        } else {\n            ERC20(_src).approve(address(dex.reserves(_src)), _amount);\n        }\n        recvAmt = dex.trade(to, _src, _dst, _amount);\n\n        require(recvAmt > 0 && recvAmt >= _minDstAmt, \"invalid receive amount\");\n        if (shifter != IShifter(0x0)) {\n            shifter.shiftOut(_to, recvAmt);\n        }\n        emit LogTransferOut(_dst, recvAmt);\n    }\n\n    function _transferIn(\n         address _src, uint256 _amount,\n        bytes32 _nHash, bytes32 _pHash, bytes memory _sig\n    ) internal returns (uint256) {\n        IShifter shifter = shifterRegistry.getShifterByToken(address(_src));\n        if (shifter != IShifter(0x0)) {\n            return shifter.shiftIn(_pHash, _amount, _nHash, _sig);\n        } else if (_src == dex.ethereum()) {\n            require(msg.value >= _amount, \"insufficient eth amount\");\n            return msg.value;\n        } else {\n            require(ERC20(_src).transferFrom(msg.sender, address(this), _amount), \"source token transfer failed\");\n            return _amount;\n        }\n    }\n\n    function _bytesToAddress(bytes memory _addr) internal pure returns (address) {\n        address addr;\n         \n        assembly {\n            addr := mload(add(_addr, 20))\n        }\n        return addr;\n    }\n\n    function calculateReceiveAmount(address _src, address _dst, uint256 _sendAmount) public view returns (uint256) {\n        return dex.calculateReceiveAmount(_src, _dst, _sendAmount);\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"name\":\"_maxBaseToken\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_refundAddress\",\"type\":\"bytes\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_dst\",\"type\":\"address\"},{\"name\":\"_minDstAmt\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"bytes\"},{\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"name\":\"_refundAddress\",\"type\":\"bytes\"}],\"name\":\"encodePayload\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_dst\",\"type\":\"address\"},{\"name\":\"_minDstAmt\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"bytes\"},{\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"name\":\"_refundAddress\",\"type\":\"bytes\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_dst\",\"type\":\"address\"},{\"name\":\"_sendAmount\",\"type\":\"uint256\"}],\"name\":\"calculateReceiveAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"bytes\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"name\":\"_maxBaseToken\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"name\":\"_refundAddress\",\"type\":\"bytes\"}],\"name\":\"hashLiquidityPayload\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_src\",\"type\":\"address\"},{\"name\":\"_dst\",\"type\":\"address\"},{\"name\":\"_minDstAmt\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"bytes\"},{\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"name\":\"_refundAddress\",\"type\":\"bytes\"}],\"name\":\"hashTradePayload\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shifterRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dex\",\"type\":\"address\"},{\"name\":\"_shifterRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTransferIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTransferOut\",\"type\":\"event\"}]","ContractName":"DEXAdapter","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e4ec27bc47f006a1b79da8e3e35051fed5a00f800000000000000000000000001d4713b74e79a3696722aebe05de976979876cac","Library":"","LicenseType":"","SwarmSource":"bzzr://4d4fc163d1970b9e6e41b2faa4f90e79c559b9c1b764df2dfbb63684e8d150c2"}]}