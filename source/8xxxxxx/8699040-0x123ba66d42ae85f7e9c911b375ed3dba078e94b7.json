{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\ncontract LuckUtils{\r\n    struct User{\r\n        address raddr;\r\n        uint8 valid;\r\n        uint recode;\r\n    }\r\n    struct Wallet{\r\n        uint last_invest;\r\n        uint profit_d;\r\n        uint index;\r\n        uint8 status;\r\n        uint profit_s;\r\n        uint profit;\r\n        uint amount;\r\n        uint rn;\r\n    }\r\n    struct Invset{\r\n        uint amount;\r\n        uint8 lv;\r\n        uint8 day;\r\n        uint8 share;\r\n        address addr;\r\n        uint8 notDone;\r\n        uint time;\r\n    }\r\n    struct Journal{\r\n        uint amount;\r\n        uint8 tag;\r\n        uint time;\r\n    }\r\n    address private owner = 0x008C35450C696a9312Aef0f45d0813056Cc57759;\r\n    uint private uinwei = 1 ether;\r\n    uint private minAmount = 1;\r\n    uint private maxAmount1 = 5;\r\n    uint private maxAmount2 = 10;\r\n    uint private maxAmount3 = 50;\r\n    constructor()public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier IsOwner{\r\n        require(msg.sender==owner,\"not owner\");\r\n        _;\r\n    }\r\n\r\n    function pstatic(uint256 amount,uint8 lv) public pure returns(uint256){\r\n        if(lv==1){\r\n            return amount*5/1000;\r\n        }else if(lv==2){\r\n            return amount/100;\r\n        }else if(lv==3){\r\n            return amount*12/1000;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function pdynamic(uint256 uinam,uint8 uLv,uint256 rei,uint8 riL2,uint remRn,uint256 layer) public pure returns(uint256){\r\n        uint256 samount = 0;\r\n        if(uinam<=0){\r\n            return 0;\r\n        }else if(rei<=0){\r\n            return 0;\r\n        }else if(riL2==3||rei>uinam){\r\n            samount = pstatic(uinam,uLv);\r\n        }else{\r\n            samount = pstatic(rei,uLv);\r\n        }\r\n\r\n        if(riL2 == 1){\r\n            if(layer==1){\r\n                return samount/2;\r\n            }else if(layer==2){\r\n                return samount/5;\r\n            }else if(layer==3){\r\n                return samount/10;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }else if(riL2 == 2||riL2 == 3){\r\n            if(layer==1){\r\n                return samount;\r\n            }else if(layer==2){\r\n                return samount*70/100;\r\n            }else if(layer==3){\r\n                return samount/2;\r\n            }else if(layer>=4&&layer<=10){\r\n                return samount/10;\r\n            }else if(layer>=11&&layer<=20){\r\n                return samount*5/100;\r\n            }else if(layer>=21&&remRn>=2){\r\n                return samount/100;\r\n            }else{\r\n                return 0;\r\n            }\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function check(uint amount,uint open3)public view returns (bool,uint8){\r\n\r\n        if(amount%uinwei != 0){\r\n            return (false,0);\r\n        }\r\n\r\n        uint amountEth = amount/uinwei;\r\n\r\n        if(amountEth>=minAmount&&amountEth<=maxAmount1){\r\n            return (true,1);\r\n        }else if(amountEth>maxAmount1&&amountEth<=maxAmount2){\r\n            return (true,2);\r\n        }else if(open3==1&&amountEth>maxAmount2&&amountEth<=maxAmount3){\r\n            return (true,3);\r\n        }else{\r\n            return (false,0);\r\n        }\r\n    }\r\n\r\n    function isSufficient(uint amount,uint betPool,uint riskPool,uint thisBln) public pure returns(bool,uint256){\r\n        if(amount>0&&betPool>amount){\r\n            if(thisBln>riskPool){\r\n                uint256 balance = thisBln-riskPool;\r\n                if(balance>=amount){\r\n                    return (true,amount);\r\n                }\r\n                return (false,balance);\r\n            }\r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function currTimeInSeconds() public view returns (uint256){\r\n        return block.timestamp;\r\n    }\r\n}\r\ncontract Luck100 {\r\n    LuckUtils utils = LuckUtils(0x89DB21870d8b0520cc793dE78923B6beaaa321Df);\r\n    mapping(address => mapping (uint => LuckUtils.Wallet)) private wallet;\r\n    mapping(uint => LuckUtils.Invset) private invsets;\r\n    mapping(address => LuckUtils.User) private accounts;\r\n    mapping(address =>uint) private manage;\r\n    mapping(uint =>address) private CodeMapAddr;\r\n    mapping(address =>address[]) private RemAddrs;\r\n    mapping(address =>LuckUtils.Journal[]) private IncomeRecord;\r\n\r\n    address private owner = 0x008C35450C696a9312Aef0f45d0813056Cc57759;\r\n    uint256 private InvsetIndex = 10000;\r\n    uint256 private UserCount = 0;\r\n    uint256 private betPool = 0;\r\n    uint256 private riskPool = 0;\r\n    uint256 private invest_total = 0;\r\n    uint256 private revert_last_invest = 0;\r\n    uint256 private revert_each_amount = 0;\r\n\r\n    uint private uinwei = 1 ether;\r\n    uint private open3 = 0;\r\n    uint8 private online = 0;\r\n    uint private reVer = 1;\r\n    uint private isRestart = 0;\r\n    uint private start_time;\r\n\r\n    constructor()public {\r\n        owner = msg.sender;\r\n        start_time = utils.currTimeInSeconds();\r\n    }\r\n\r\n    modifier IsOwner{\r\n        require(msg.sender==owner,\"not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier IsManage{\r\n        require(msg.sender==owner||manage[msg.sender]==1,\"not manage\");\r\n        _;\r\n    }\r\n\r\n    event Entry(address addr,address raddr, uint amount,uint ver, uint index,uint time,uint8 status);\r\n    event Extract(address addr,uint amount,uint8 etype);\r\n    event ResetLog(uint reVer,uint time,uint nowIndex);\r\n\r\n    function () external payable{\r\n    }\r\n    function entry(address reAddr) public payable{\r\n        require(reAddr!=owner,\"Can't be the contract address\");\r\n        require(isRestart==0,\"Currently restarting\");\r\n        uint256  payamount = msg.value;\r\n        (bool isverify,uint8 lv) = utils.check(payamount,open3);\r\n        require(isverify,\"amount error\");\r\n        require(wallet[msg.sender][reVer].status==0||wallet[msg.sender][reVer].status==1,\"Assets already in investment\");\r\n\r\n        if(accounts[msg.sender].valid == 0){\r\n            require(accounts[reAddr].valid==1,\"Recommended address is invalid\");\r\n            require(msg.sender!=reAddr,\"Invitation address is invalid\");\r\n            handel(msg.sender,payamount,reAddr,lv,0);\r\n        }else{\r\n            handel(msg.sender,payamount,accounts[msg.sender].raddr,lv,1);\r\n        }\r\n        sendRisk(payamount);\r\n    }\r\n    function reInvest() public {\r\n        require(isRestart==0,\"Currently restarting\");\r\n        require(wallet[msg.sender][reVer].status==1,\"No Reinvestment\");\r\n\r\n        uint payamount = wallet[msg.sender][reVer].amount;\r\n        (bool isverify,uint8 lv) = utils.check(payamount,open3);\r\n        require(isverify,\"amount error\");\r\n        wallet[msg.sender][reVer].amount = 0;\r\n\r\n        handel(msg.sender,payamount,accounts[msg.sender].raddr,lv,1);\r\n        sendRisk(payamount);\r\n    }\r\n    function handel(address addr,uint amount,address reAddr,uint8 lv,uint8 status) private{\r\n        uint last_inv_profit = wallet[addr][reVer].profit_d;\r\n        if(last_inv_profit>0){\r\n            require(amount>=wallet[addr][reVer].last_invest,\"Assets already in investment\");\r\n        }\r\n        InvsetIndex = InvsetIndex+1;\r\n        uint256 nowIndex = InvsetIndex;\r\n        if(accounts[addr].valid == 0){\r\n            uint remCode = 4692475*nowIndex;\r\n            accounts[addr].recode = remCode;\r\n            accounts[addr].valid = 1;\r\n            accounts[addr].raddr = reAddr;\r\n            CodeMapAddr[remCode] = addr;\r\n            RemAddrs[reAddr].push(addr);\r\n        }\r\n\r\n        wallet[addr][reVer].index = nowIndex;\r\n        wallet[addr][reVer].status = 2;\r\n        wallet[addr][reVer].profit_s = 0;\r\n        wallet[addr][reVer].profit_d = 0;\r\n        wallet[addr][reVer].last_invest = amount;\r\n\r\n        if(lv>=2){\r\n            wallet[reAddr][reVer].rn = wallet[reAddr][reVer].rn+1;\r\n        }\r\n        uint time = utils.currTimeInSeconds();\r\n        invsets[nowIndex] = LuckUtils.Invset(amount,lv,0,0,addr,1,time);\r\n        emit Entry(addr,reAddr,amount,reVer,nowIndex,time,status);\r\n\r\n        if(last_inv_profit>0){\r\n            (bool isCan,uint avail_profit) = utils.isSufficient(last_inv_profit,betPool,riskPool,address(this).balance);\r\n            if((!isCan)&&avail_profit>0){\r\n                EventRestart();\r\n            }\r\n            if(avail_profit>0){\r\n                if(last_inv_profit>avail_profit){\r\n                    wallet[addr][reVer].profit_d = last_inv_profit-avail_profit;\r\n                }else{\r\n                    wallet[addr][reVer].profit_d = 0;\r\n                }\r\n                IncomeRecord[addr].push(LuckUtils.Journal(avail_profit,2,time));\r\n                address payable DynamicAddr = address(uint160(addr));\r\n                DynamicAddr.transfer(avail_profit);\r\n            }\r\n        }\r\n    }\r\n    function profit(uint256 start,uint time)public IsManage returns(uint){\r\n        require(isRestart==0,\"Currently restarting\");\r\n        uint nowtime = time;\r\n        if(nowtime<=0){\r\n            nowtime = utils.currTimeInSeconds();\r\n        }\r\n        if(open3==0&&time-start_time >= 2592000){\r\n            open3 = 1;\r\n        }\r\n        if(!itemProfit(start,nowtime)){\r\n            return 0;\r\n        }\r\n        address addr = invsets[start].addr;\r\n        if(wallet[addr][reVer].profit>=0.1 ether){\r\n            (bool isCan,uint myProfit) = utils.isSufficient(wallet[addr][reVer].profit,betPool,riskPool,address(this).balance);\r\n            if(isCan){\r\n                wallet[addr][reVer].profit = 0;\r\n                address payable StaticAddr = address(uint160(addr));\r\n                StaticAddr.transfer(myProfit);\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n    function itemProfit(uint256 arrayIndex,uint time) private returns(bool){\r\n        LuckUtils.Invset memory inv = invsets[arrayIndex];\r\n        if(time-inv.time < 86400){\r\n            return false;\r\n        }\r\n        if(inv.day<5&&wallet[inv.addr][reVer].status==2){\r\n            uint8 day = invsets[arrayIndex].day + 1;\r\n            uint256 profit_s = utils.pstatic(inv.amount,inv.lv);\r\n            wallet[inv.addr][reVer].profit_s = wallet[inv.addr][reVer].profit_s + profit_s;\r\n            wallet[inv.addr][reVer].profit = wallet[inv.addr][reVer].profit + profit_s;\r\n            invsets[arrayIndex].day = day;\r\n            invsets[arrayIndex].time = time;\r\n\r\n            if(day>=5){\r\n                invsets[arrayIndex].notDone = 0;\r\n                wallet[inv.addr][reVer].status = 1;\r\n                wallet[inv.addr][reVer].amount = wallet[inv.addr][reVer].amount + inv.amount;\r\n\r\n                if(inv.lv>=2){\r\n                    if(wallet[accounts[inv.addr].raddr][reVer].rn>0){\r\n                        wallet[accounts[inv.addr].raddr][reVer].rn = wallet[accounts[inv.addr].raddr][reVer].rn-1;\r\n                    }\r\n                }\r\n            }\r\n            IncomeRecord[inv.addr].push(LuckUtils.Journal(profit_s,1,utils.currTimeInSeconds()));\r\n            return true;\r\n        }else{\r\n            invsets[arrayIndex].notDone = 0;\r\n        }\r\n        return false;\r\n    }\r\n    function shareProfit(uint index) public IsManage{\r\n        require(invsets[index].share>=0&&invsets[index].share<5,\"Settlement completed\");\r\n        require(invsets[index].share<invsets[index].day,\"Unable to release dynamic revenue\");\r\n        LuckUtils.Invset memory inv = invsets[index];\r\n        invsets[index].share = invsets[index].share+1;\r\n        remProfit(accounts[inv.addr].raddr,inv.amount,inv.lv);\r\n    }\r\n    function remProfit(address raddr,uint256 amount,uint8 inv_lv) private{\r\n        address nowRaddr = raddr;\r\n        LuckUtils.Wallet memory remWallet = wallet[nowRaddr][reVer];\r\n        uint256 layer = 1;\r\n        while(accounts[nowRaddr].valid>0&&layer<=100){\r\n            if(remWallet.status==2){\r\n                uint256 profit_d = utils.pdynamic(amount,inv_lv,invsets[remWallet.index].amount,invsets[remWallet.index].lv,remWallet.rn,layer);\r\n                if(profit_d>0){\r\n                    wallet[nowRaddr][reVer].profit_d = wallet[nowRaddr][reVer].profit_d + profit_d;\r\n                }\r\n            }\r\n            nowRaddr = accounts[nowRaddr].raddr;\r\n            remWallet = wallet[nowRaddr][reVer];\r\n            layer = layer+1;\r\n        }\r\n    }\r\n    function reset_sett()public{\r\n        require(isRestart==1,\"Can't restart\");\r\n        isRestart = 2;\r\n        uint amountTotal = riskPool - 16000000000000000000;\r\n        if(amountTotal<address(this).balance){\r\n            amountTotal = address(this).balance;\r\n        }\r\n        uint256 startIndex = InvsetIndex-99;\r\n        revert_last_invest = 0;\r\n        for(uint256 nowIndex = 0;nowIndex<100&&startIndex+nowIndex<=InvsetIndex;nowIndex = nowIndex+1){\r\n            revert_last_invest = revert_last_invest + invsets[nowIndex+startIndex].amount;\r\n        }\r\n        revert_last_invest = revert_last_invest/uinwei;\r\n        revert_each_amount = amountTotal/revert_last_invest;\r\n        resetSend(startIndex,InvsetIndex-80);\r\n    }\r\n    function reset()public{\r\n        require(isRestart==2,\"Can't restart\");\r\n        isRestart = 0;\r\n        uint256 startIndex = InvsetIndex-79;\r\n        uint256 endIndex = InvsetIndex;\r\n        InvsetIndex = InvsetIndex + 100;\r\n        reVer = reVer+1;\r\n        betPool = 0;\r\n        riskPool = 0;\r\n        open3 = 0;\r\n        UserCount = 0;\r\n        invest_total = 0;\r\n        start_time = utils.currTimeInSeconds();\r\n        resetSend(startIndex,endIndex);\r\n    }\r\n    function resetSend(uint startIndex,uint endIndex)private{\r\n        uint256 userAmount = 0;\r\n        LuckUtils.Invset memory inv;\r\n        for(uint256 sendUserIndex = startIndex;sendUserIndex<=endIndex;sendUserIndex = sendUserIndex+1){\r\n            inv = invsets[sendUserIndex];\r\n            userAmount = inv.amount/uinwei*revert_each_amount;\r\n            emit Extract(inv.addr,userAmount,10);\r\n            if(userAmount>0){\r\n                if(userAmount>address(this).balance){\r\n                    userAmount = address(this).balance;\r\n                }\r\n                address payable InvAddr = address(uint160(inv.addr));\r\n                InvAddr.transfer(userAmount);\r\n            }\r\n        }\r\n        uint RewardAmount = 8000000000000000000;\r\n        if(address(this).balance<RewardAmount){\r\n            RewardAmount = address(this).balance;\r\n        }\r\n        msg.sender.transfer(RewardAmount);\r\n    }\r\n    function iline()public IsOwner{\r\n        online = 1;\r\n        open3 = 0;\r\n    }\r\n    function EventRestart() private {\r\n        if(UserCount>=100){\r\n           isRestart = 1;\r\n           emit ResetLog(reVer,utils.currTimeInSeconds(),InvsetIndex);\r\n        }\r\n    }\r\n    function test(address addr,address reAddr,uint amount) public IsOwner{\r\n        require(online==0,\"exit\");\r\n        (bool isverify,uint8 lv) = utils.check(amount,open3);\r\n        require(isverify,\"amount error\");\r\n        require(wallet[addr][reVer].status==0||wallet[addr][reVer].status==1,\"Assets already in investment\");\r\n        if(accounts[addr].valid == 0){\r\n            handel(addr,amount,reAddr,lv,0);\r\n        }else{\r\n            handel(addr,amount,accounts[addr].raddr,lv,1);\r\n        }\r\n    }\r\n    function withdraw(uint8 withtype) public{\r\n        require(accounts[msg.sender].valid>0&&isRestart==0&&withtype>=2&&withtype<=3, \"Invalid operation\");\r\n        uint balance = 0;\r\n        if(withtype==2){\r\n            balance = wallet[msg.sender][reVer].amount;\r\n        }else if(withtype==3){\r\n            balance = wallet[msg.sender][reVer].profit;\r\n        }\r\n        (bool isCan,uint amount) = utils.isSufficient(balance,betPool,riskPool,address(this).balance);\r\n        require(amount>0&&balance>=amount, \"Insufficient withdrawable amount\");\r\n        if(withtype==2){\r\n            wallet[msg.sender][reVer].amount = wallet[msg.sender][reVer].amount-amount;\r\n        }else if(withtype==3){\r\n            wallet[msg.sender][reVer].profit = wallet[msg.sender][reVer].profit-amount;\r\n        }\r\n        if(!isCan){\r\n            EventRestart();\r\n        }\r\n        emit Extract(msg.sender,amount,withtype);\r\n        msg.sender.transfer(amount);\r\n    }\r\n    function sendRisk(uint payamount) private{\r\n        invest_total = invest_total+payamount;\r\n        UserCount = UserCount+1;\r\n        uint riskAmount = payamount*6/100;\r\n        uint adminMoeny = payamount/25;\r\n        riskPool = riskPool+riskAmount;\r\n        betPool = betPool+(payamount-riskPool-adminMoeny);\r\n        if(address(this).balance>=adminMoeny){\r\n            address payable SendCommunity = 0x493601dAFE2D6c6937df3f0AD13Fa6bAF12dFa00;\r\n            SendCommunity.transfer(adminMoeny);\r\n        }\r\n    }\r\n    function getInfo() public view returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256){\r\n        uint256 blance = address(this).balance;\r\n        return (InvsetIndex,betPool,riskPool,invest_total,UserCount,online,reVer,open3,isRestart,start_time,blance,revert_last_invest);\r\n    }\r\n    function getInv(uint arrayIndex) public view IsManage returns(uint,uint8,uint8,address,uint8,uint,address,uint,uint8,uint){\r\n        LuckUtils.Invset memory inv = invsets[arrayIndex];\r\n        return (inv.amount,inv.lv,inv.day,inv.addr,inv.notDone,inv.time,accounts[inv.addr].raddr,isRestart,inv.share,reVer);\r\n    }\r\n    function lastInvest() public view returns(address[] memory){\r\n        if(UserCount<=100){\r\n            address[] memory notLastAssr = new address[](0);\r\n            return notLastAssr;\r\n        }\r\n        uint lastIndex = InvsetIndex;\r\n        address[] memory lastAddr = new address[](100);\r\n        for(uint i = 0;i<100;i = i+1){\r\n            if(invsets[lastIndex-i].amount<=0){\r\n                return (lastAddr);\r\n            }\r\n            lastAddr[i] = invsets[lastIndex-i].addr;\r\n        }\r\n        return (lastAddr);\r\n    }\r\n    function remAddr(address addr,uint page) public view returns(address[] memory,uint[] memory,uint[] memory){\r\n        require(page>0,\"Invalid page number\");\r\n        if(RemAddrs[addr].length<=0){\r\n            return (new address[](0),new uint[](0),new uint[](0));\r\n        }\r\n        address[] memory rAddr = new address[](10);\r\n        uint[] memory rInvAm = new uint[](10);\r\n        uint[] memory rNum = new uint[](10);\r\n        uint startIdx = (page-1)*10;\r\n        for(uint i = 0;i<=10&&i+startIdx<RemAddrs[addr].length;i = i+1){\r\n            address  itemAddr = RemAddrs[addr][startIdx+i];\r\n            rAddr[i] = itemAddr;\r\n            if(wallet[itemAddr][reVer].status==2){\r\n                rInvAm[i] = wallet[itemAddr][reVer].last_invest;\r\n            }\r\n            rNum[i] = RemAddrs[itemAddr].length;\r\n        }\r\n        return (rAddr,rInvAm,rNum);\r\n    }\r\n    function journal()public view returns(uint[] memory,uint[] memory){\r\n        uint[] memory amount = new uint[](20);\r\n        uint[] memory time = new uint[](20);\r\n        uint data_index = 0;\r\n        for(uint i = IncomeRecord[msg.sender].length+10;i>10&&data_index<20;i = i-1){\r\n            LuckUtils.Journal memory jrnal = IncomeRecord[msg.sender][i-11];\r\n            amount[data_index] = jrnal.amount;\r\n            time[data_index] = jrnal.time;\r\n            data_index = data_index+1;\r\n        }\r\n        return (amount,time);\r\n    }\r\n    function GetCode(uint code)public view returns(address){\r\n        return CodeMapAddr[code];\r\n    }\r\n    function userInfo(address addr) public view returns(uint256[] memory){\r\n        require(msg.sender==addr||manage[msg.sender]==1||msg.sender==owner,\"not found\");\r\n        LuckUtils.Wallet memory myWalt = wallet[addr][reVer];\r\n        uint256[] memory lastAddr = new uint256[](14);\r\n        lastAddr[0] = myWalt.amount;\r\n        lastAddr[1] = myWalt.profit_s;\r\n        lastAddr[2] = myWalt.last_invest;\r\n        lastAddr[3] = myWalt.profit_d;\r\n        lastAddr[4] = myWalt.profit;\r\n        lastAddr[5] = invsets[myWalt.index].amount;\r\n        lastAddr[6] = myWalt.status;\r\n        lastAddr[7] = invsets[myWalt.index].day;\r\n        lastAddr[8] = invsets[myWalt.index].lv;\r\n        lastAddr[9] = invsets[myWalt.index].time;\r\n        lastAddr[10] = myWalt.rn;\r\n        lastAddr[11] = myWalt.index;\r\n        lastAddr[12] = accounts[addr].valid;\r\n        lastAddr[13] = accounts[addr].recode;\r\n\r\n        return lastAddr;\r\n    }\r\n    function setManage(address addr,uint status) public IsOwner{\r\n        if(status==1){\r\n            manage[addr] = 1;\r\n        }else{\r\n            manage[addr] = 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"arrayIndex\",\"type\":\"uint256\"}],\"name\":\"getInv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"iline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reset_sett\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"GetCode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"journal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"profit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"shareProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reAddr\",\"type\":\"address\"}],\"name\":\"entry\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"withtype\",\"type\":\"uint8\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setManage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"reAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"test\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"remAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"raddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ver\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"Entry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etype\",\"type\":\"uint8\"}],\"name\":\"Extract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reVer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nowIndex\",\"type\":\"uint256\"}],\"name\":\"ResetLog\",\"type\":\"event\"}]","ContractName":"Luck100","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://39201736ea15cb1b2709963b931eeaf58e40c5227c4ae1a7d34910b900aa200c"}]}