{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface INMR {\r\n\r\n    /* ERC20 Interface */\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /* NMR Special Interface */\r\n\r\n    // used for user balance management\r\n    function withdraw(address _from, address _to, uint256 _value) external returns(bool ok);\r\n\r\n    // used for migrating active stakes\r\n    function destroyStake(address _staker, bytes32 _tag, uint256 _tournamentID, uint256 _roundID) external returns (bool ok);\r\n\r\n    // used for disabling token upgradability\r\n    function createRound(uint256, uint256, uint256, uint256) external returns (bool ok);\r\n\r\n    // used for upgrading the token delegate logic\r\n    function createTournament(uint256 _newDelegate) external returns (bool ok);\r\n\r\n    // used like burn(uint256)\r\n    function mint(uint256 _value) external returns (bool ok);\r\n\r\n    // used like burnFrom(address, uint256)\r\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\r\n\r\n    // used to check if upgrade completed\r\n    function contractUpgradable() external view returns (bool);\r\n\r\n    function getTournament(uint256 _tournamentID) external view returns (uint256, uint256[] memory);\r\n\r\n    function getRound(uint256 _tournamentID, uint256 _roundID) external view returns (uint256, uint256, uint256);\r\n\r\n    function getStake(uint256 _tournamentID, uint256 _roundID, address _staker, bytes32 _tag) external view returns (uint256, uint256, bool, bool);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\ncontract Manageable is Initializable, Ownable {\r\n    address private _manager;\r\n\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    /**\r\n     * @dev The Managable constructor sets the original `manager` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) initializer public {\r\n        Ownable.initialize(sender);\r\n        _manager = sender;\r\n        emit ManagementTransferred(address(0), _manager);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the manager.\r\n     */\r\n    function manager() public view returns (address) {\r\n        return _manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner or manager.\r\n     */\r\n    modifier onlyManagerOrOwner() {\r\n        require(isManagerOrOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner or manager of the contract.\r\n     */\r\n    function isManagerOrOwner() public view returns (bool) {\r\n        return (msg.sender == _manager || isOwner());\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\r\n     * @param newManager The address to transfer management to.\r\n     */\r\n    function transferManagement(address newManager) public onlyOwner {\r\n        require(newManager != address(0));\r\n        emit ManagementTransferred(_manager, newManager);\r\n        _manager = newManager;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *      Modified from openzeppelin Pausable to simplify access control.\r\n */\r\ncontract Pausable is Initializable, Manageable {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /// @notice Initializer function called at time of deployment\r\n    /// @param sender The address of the wallet to handle permission control\r\n    function initialize(address sender) public initializer {\r\n        Manageable.initialize(sender);\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyManagerOrOwner whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyManagerOrOwner whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Numerai Tournament logic contract version 1\r\ncontract NumeraiTournamentV1 is Initializable, Pausable {\r\n\r\n    uint256 public totalStaked;\r\n\r\n    mapping (uint256 => Tournament) public tournaments;\r\n\r\n    struct Tournament {\r\n        uint256 creationTime;\r\n        uint256[] roundIDs;\r\n        mapping (uint256 => Round) rounds;\r\n    }\r\n\r\n    struct Round {\r\n        uint128 creationTime;\r\n        uint128 stakeDeadline;\r\n        mapping (address => mapping (bytes32 => Stake)) stakes;\r\n    }\r\n\r\n    struct Stake {\r\n        uint128 amount;\r\n        uint32 confidence;\r\n        uint128 burnAmount;\r\n        bool resolved;\r\n    }\r\n\r\n    /* /////////////////// */\r\n    /* Do not modify above */\r\n    /* /////////////////// */\r\n\r\n    // define an event for tracking the progress of stake initalization.\r\n    event StakeInitializationProgress(\r\n        bool initialized, // true if stake initialization complete, else false.\r\n        uint256 firstUnprocessedStakeItem // index of the skipped stake, if any.\r\n    );\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint128;\r\n\r\n    // set the address of the NMR token as a constant (stored in runtime code)\r\n    address private constant _TOKEN = address(\r\n        0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671\r\n    );\r\n\r\n    /// @notice constructor function, used to enforce implementation address\r\n    constructor() public {\r\n        require(\r\n            address(this) == address(0xb2C4DbB78c7a34313600aD2e6E35d188ab4381a8),\r\n            \"Incorrect deployment address - check submitting account & nonce.\"\r\n        );\r\n    }\r\n\r\n    /// @notice Initializer function called at time of deployment\r\n    /// @param _owner The address of the wallet to handle permission control\r\n    function initialize(\r\n        address _owner\r\n    ) public initializer {\r\n        // initialize the contract's ownership.\r\n        Pausable.initialize(_owner);\r\n    }\r\n\r\n    /// @notice Initializer function to set data for tournaments and the active\r\n    ///         rounds (i.e. the four most recent) on each of the tournaments.\r\n    /// @param _startingRoundID The most recent round ID to initialize - this\r\n    ///        assumes that each round has a higher roundID than the last and\r\n    ///        that each active round will have the same roundID as other rounds\r\n    ///        that are started at approximately the same time.\r\n    function initializeTournamentsAndActiveRounds(\r\n        uint256 _startingRoundID\r\n    ) public onlyManagerOrOwner {\r\n        // set up the NMR token interface.\r\n        INMR nmr = INMR(_TOKEN);\r\n\r\n        // initialize tournament one through seven with four most recent rounds.\r\n        for (uint256 tournamentID = 1; tournamentID <= 7; tournamentID++) {\r\n            // determine the creation time and the round IDs for the tournament.\r\n            (\r\n                uint256 tournamentCreationTime,\r\n                uint256[] memory roundIDs\r\n            ) = nmr.getTournament(tournamentID);\r\n\r\n            // update the creation time of the tournament in storage.\r\n            tournaments[tournamentID].creationTime = tournamentCreationTime;\r\n\r\n            // skip round initialization if there are no rounds.\r\n            if (roundIDs.length == 0) {\r\n                continue;\r\n            }\r\n\r\n            // find the most recent roundID.\r\n            uint256 mostRecentRoundID = roundIDs[roundIDs.length - 1];\r\n\r\n            // skip round initialization if mostRecentRoundID < _startingRoundID\r\n            if (mostRecentRoundID < _startingRoundID) {\r\n                continue;\r\n            }\r\n\r\n            // track how many rounds are initialized.\r\n            uint256 initializedRounds = 0;\r\n\r\n            // iterate through and initialize each round.\r\n            for (uint256 j = 0; j < roundIDs.length; j++) {               \r\n                // get the current round ID.\r\n                uint256 roundID = roundIDs[j];\r\n\r\n                // skip this round initialization if roundID < _startingRoundID\r\n                if (roundID < _startingRoundID) {\r\n                    continue;\r\n                }\r\n\r\n                // add the roundID to roundIDs in storage.\r\n                tournaments[tournamentID].roundIDs.push(roundID);\r\n\r\n                // get more information on the round.\r\n                (\r\n                    uint256 creationTime,\r\n                    uint256 endTime,\r\n                ) = nmr.getRound(tournamentID, roundID);\r\n\r\n                // set that information in storage.\r\n                tournaments[tournamentID].rounds[roundID] = Round({\r\n                    creationTime: uint128(creationTime),\r\n                    stakeDeadline: uint128(endTime)\r\n                });\r\n\r\n                // increment the number of initialized rounds.\r\n                initializedRounds++;\r\n            }\r\n\r\n            // delete the initialized rounds from the old tournament.\r\n            require(\r\n                nmr.createRound(tournamentID, initializedRounds, 0, 0),\r\n                \"Could not delete round from legacy tournament.\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Initializer function to set the data of the active stakes\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    function initializeStakes(\r\n        uint256[] memory tournamentID,\r\n        uint256[] memory roundID,\r\n        address[] memory staker,\r\n        bytes32[] memory tag\r\n    ) public onlyManagerOrOwner {\r\n        // set and validate the size of the dynamic array arguments.\r\n        uint256 num = tournamentID.length;\r\n        require(\r\n            roundID.length == num &&\r\n            staker.length == num &&\r\n            tag.length == num,\r\n            \"Input data arrays must all have same length.\"\r\n        );\r\n\r\n        // start tracking the total stake amount.\r\n        uint256 stakeAmt = 0;\r\n\r\n        // set up the NMR token interface.\r\n        INMR nmr = INMR(_TOKEN);\r\n\r\n        // track completed state; this will be set to false if we exit early.\r\n        bool completed = true;\r\n\r\n        // track progress; set to the first skipped item if we exit early.\r\n        uint256 progress;\r\n\r\n        // iterate through each supplied stake.\r\n        for (uint256 i = 0; i < num; i++) {\r\n            // check gas and break if we're starting to run low.\r\n            if (gasleft() < 100000) {\r\n                completed = false;\r\n                progress = i;\r\n                break;\r\n            }\r\n\r\n            // get the amount and confidence\r\n            (uint256 confidence, uint256 amount, , bool resolved) = nmr.getStake(\r\n                tournamentID[i],\r\n                roundID[i],\r\n                staker[i],\r\n                tag[i]\r\n            );\r\n\r\n            // only set it if the stake actually exists on the old tournament.\r\n            if (amount > 0 || resolved) {\r\n                uint256 currentTournamentID = tournamentID[i];\r\n                uint256 currentRoundID = roundID[i];\r\n\r\n                // destroy the stake on the token contract.\r\n                require(\r\n                    nmr.destroyStake(\r\n                        staker[i], tag[i], currentTournamentID, currentRoundID\r\n                    ),\r\n                    \"Could not destroy stake from legacy tournament.\"\r\n                );\r\n\r\n                // get the stake object.\r\n                Stake storage stakeObj = tournaments[currentTournamentID]\r\n                                           .rounds[currentRoundID]\r\n                                           .stakes[staker[i]][tag[i]];\r\n\r\n                // only set stake if it isn't already set on new tournament.\r\n                if (stakeObj.amount == 0 && !stakeObj.resolved) {\r\n\r\n                    // increase the total stake amount by the retrieved amount.\r\n                    stakeAmt = stakeAmt.add(amount);\r\n\r\n                    // set the amount on the stake object.\r\n                    if (amount > 0) {\r\n                        stakeObj.amount = uint128(amount);\r\n                    }\r\n\r\n                    // set the confidence on the stake object.\r\n                    stakeObj.confidence = uint32(confidence);\r\n\r\n                    // set returned to true if the round was resolved early.\r\n                    if (resolved) {\r\n                        stakeObj.resolved = true;\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        // increase the total stake by the sum of each imported stake amount.\r\n        totalStaked = totalStaked.add(stakeAmt);\r\n\r\n        // log the success status and the first skipped item if not completed.\r\n        emit StakeInitializationProgress(completed, progress);\r\n    }\r\n\r\n    /// @notice Function to transfer tokens once intialization is completed.\r\n    function settleStakeBalance() public onlyManagerOrOwner {\r\n        // send the stake amount from the caller to this contract.\r\n        require(INMR(_TOKEN).withdraw(address(0), address(0), totalStaked),\r\n            \"Stake balance was not successfully set on new tournament.\");\r\n    }\r\n\r\n    /// @notice Get the state of a tournament in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @return creationTime The UNIX timestamp of the tournament creation\r\n    /// @return roundIDs The array of index of the tournament rounds\r\n    function getTournamentV2(uint256 tournamentID) public view returns (\r\n        uint256 creationTime,\r\n        uint256[] memory roundIDs\r\n    ) {\r\n        Tournament storage tournament = tournaments[tournamentID];\r\n        return (tournament.creationTime, tournament.roundIDs);\r\n    }\r\n\r\n    /// @notice Get the state of a round in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @return creationTime The UNIX timestamp of the round creation\r\n    /// @return stakeDeadline The UNIX timestamp of the round deadline for staked submissions\r\n    function getRoundV2(uint256 tournamentID, uint256 roundID) public view returns (\r\n        uint256 creationTime,\r\n        uint256 stakeDeadline\r\n    ) {\r\n        Round storage round = tournaments[tournamentID].rounds[roundID];\r\n        return (uint256(round.creationTime), uint256(round.stakeDeadline));\r\n    }\r\n\r\n    /// @notice Get the state of a staked submission in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @return amount The amount of NMR in wei staked with this submission\r\n    /// @return confidence The confidence threshold attached to this submission\r\n    /// @return burnAmount The amount of NMR in wei burned by the resolution\r\n    /// @return resolved True if the staked submission has been resolved\r\n    function getStakeV2(uint256 tournamentID, uint256 roundID, address staker, bytes32 tag) public view returns (\r\n        uint256 amount,\r\n        uint256 confidence,\r\n        uint256 burnAmount,\r\n        bool resolved\r\n    ) {\r\n        Stake storage stakeObj = tournaments[tournamentID].rounds[roundID].stakes[staker][tag];\r\n        return (stakeObj.amount, stakeObj.confidence, stakeObj.burnAmount, stakeObj.resolved);\r\n    }\r\n\r\n    /// @notice Get the state of a tournament in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @return creationTime The UNIX timestamp of the tournament creation\r\n    /// @return roundIDs The array of index of the tournament rounds\r\n    function getTournamentV1(uint256 tournamentID) public view returns (\r\n        uint256 creationTime,\r\n        uint256[] memory roundIDs\r\n    ) {\r\n        return INMR(_TOKEN).getTournament(tournamentID);\r\n    }\r\n\r\n    /// @notice Get the state of a round in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @return creationTime The UNIX timestamp of the round creation\r\n    /// @return endTime The UNIX timestamp of the round deadline for staked submissions\r\n    /// @return resolutionTime The UNIX timestamp of the round start time for resolutions\r\n    function getRoundV1(uint256 tournamentID, uint256 roundID) public view returns (\r\n        uint256 creationTime,\r\n        uint256 endTime,\r\n        uint256 resolutionTime\r\n    ) {\r\n        return INMR(_TOKEN).getRound(tournamentID, roundID);\r\n    }\r\n\r\n    /// @notice Get the state of a staked submission in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @return confidence The confidence threshold attached to this submission\r\n    /// @return amount The amount of NMR in wei staked with this submission\r\n    /// @return successful True if the staked submission beat the threshold\r\n    /// @return resolved True if the staked submission has been resolved\r\n    function getStakeV1(uint256 tournamentID, uint256 roundID, address staker, bytes32 tag) public view returns (\r\n        uint256 confidence,\r\n        uint256 amount,\r\n        bool successful,\r\n        bool resolved\r\n    ) {\r\n        return INMR(_TOKEN).getStake(tournamentID, roundID, staker, tag);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256[]\"},{\"name\":\"roundID\",\"type\":\"uint256[]\"},{\"name\":\"staker\",\"type\":\"address[]\"},{\"name\":\"tag\",\"type\":\"bytes32[]\"}],\"name\":\"initializeStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"getRoundV1\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"resolutionTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"getTournamentV1\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"roundIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"bytes32\"}],\"name\":\"getStakeV2\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"confidence\",\"type\":\"uint256\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"},{\"name\":\"resolved\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleStakeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"getRoundV2\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"stakeDeadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManagerOrOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournaments\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"bytes32\"}],\"name\":\"getStakeV1\",\"outputs\":[{\"name\":\"confidence\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"successful\",\"type\":\"bool\"},{\"name\":\"resolved\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"getTournamentV2\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"roundIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startingRoundID\",\"type\":\"uint256\"}],\"name\":\"initializeTournamentsAndActiveRounds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initialized\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"firstUnprocessedStakeItem\",\"type\":\"uint256\"}],\"name\":\"StakeInitializationProgress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NumeraiTournamentV1","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"65535","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://492736ffc76f62303ff24ef0100a8f8faf431e28d6b64932df5d9eba8d7d8447"}]}