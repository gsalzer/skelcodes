{"status":"1","message":"OK","result":[{"SourceCode":"// File: localhost/contracts/sign/ISign.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface ISign {\r\n    function signed(bytes32 hash) external view returns (bool);\r\n}\r\n\r\n// File: localhost/contracts/migrate/Migratable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface Migratable {\r\n    function migrateTo(address user, address token, uint256 amount) payable external;\r\n}\r\n\r\n// File: localhost/contracts/SerializableTransferral.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title Serializable Transferral\r\n * @author Ben Huang\r\n * @notice Let transferral support serialization and deserialization\r\n */\r\ncontract SerializableTransferral {\r\n    using SafeMath for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    uint constant public TRANSFERRAL_1_SIZE = 25;\r\n    uint constant public RECEIVER_SIZE = 86;\r\n    uint8 constant internal _MASK_IS_ETH = 0x01;\r\n\r\n    /**\r\n     * @notice Get from address from the serialized transferral data\r\n     * @param ser_data Serialized transferral data\r\n     * @return from User address\r\n     */\r\n    function _getTransferralFrom(bytes memory ser_data) internal pure returns (address from) {\r\n        from = ser_data.toAddress(ser_data.length - 20);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the fee is paid by transferral token\r\n     * @param ser_data Serialized transferral data\r\n     * @return fETH Is the fee paid in transferral token or DGO\r\n     */\r\n    function _isTransferralFeeMain(bytes memory ser_data) internal pure returns (bool fFeeETH) {\r\n        fFeeETH = (ser_data.toUint8(ser_data.length - 21) & _MASK_IS_ETH != 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Get nonce from the serialized transferral data\r\n     * @param ser_data Serialized transferral data\r\n     * @return nonce Nonce\r\n     */\r\n    function _getTransferralNonce(bytes memory ser_data) internal pure returns (uint256 nonce) {\r\n        nonce = ser_data.toUint32(ser_data.length - 25);\r\n    }\r\n\r\n    /**\r\n     * @notice Get receiver count\r\n     * @param ser_data Serialized transferral data\r\n     * @return n The transferral receiver amount\r\n     */\r\n    function _getTransferralCount(bytes memory ser_data) internal pure returns (uint256 n) {\r\n        n = (ser_data.length - TRANSFERRAL_1_SIZE) / RECEIVER_SIZE;\r\n    }\r\n\r\n    /**\r\n     * @notice Get receiver address to be transferred to\r\n     * @param ser_data Serialized transferral data\r\n     * @param index The index of receiver address to be transferred to\r\n     * @return to The address to be transferred to\r\n     */\r\n    function _getTransferralTo(bytes memory ser_data, uint index) internal pure returns (address to) {\r\n        require(index < _getTransferralCount(ser_data));\r\n        to = ser_data.toAddress(ser_data.length - TRANSFERRAL_1_SIZE - (RECEIVER_SIZE.mul(index)) - 20);\r\n    }\r\n\r\n    /**\r\n     * @notice Get token address to be transferred\r\n     * @param ser_data Serialized transferral data\r\n     * @param index The index of token address to be transferred to\r\n     * @return token The token address to be transferred\r\n     */\r\n    function _getTransferralTokenID(bytes memory ser_data, uint index) internal pure returns (uint256 token) {\r\n        require(index < _getTransferralCount(ser_data));\r\n        token = ser_data.toUint16(ser_data.length - TRANSFERRAL_1_SIZE - (RECEIVER_SIZE.mul(index)) - 22);\r\n    }\r\n\r\n    /**\r\n     * @notice Get token amount to be transferred\r\n     * @param ser_data Serialized transferral data\r\n     * @param index The index of token amount to be transferred to\r\n     * @return amount The amount to be transferred\r\n     */\r\n    function _getTransferralAmount(bytes memory ser_data, uint index) internal pure returns (uint256 amount) {\r\n        require(index < _getTransferralCount(ser_data));\r\n        amount = ser_data.toUint(ser_data.length - TRANSFERRAL_1_SIZE - (RECEIVER_SIZE.mul(index)) - 54);\r\n    }\r\n\r\n    /**\r\n     * @notice Get token amount to be transferred\r\n     * @param ser_data Serialized transferral data\r\n     * @param index The index of token amount to be transferred to\r\n     * @return fee The fee amount\r\n     */\r\n    function _getTransferralFee(bytes memory ser_data, uint index) internal pure returns (uint256 fee) {\r\n        require(index < _getTransferralCount(ser_data));\r\n        fee = ser_data.toUint(ser_data.length - TRANSFERRAL_1_SIZE - (RECEIVER_SIZE.mul(index)) - 86);\r\n    }\r\n\r\n    /**\r\n     * @notice Get hash from the serialized transferral data\r\n     * @param ser_data Serialized transferral data\r\n     * @return hash Transferral hash without signature\r\n     */\r\n    function _getTransferralHash(bytes memory ser_data) internal pure returns (bytes32 hash) {\r\n        hash = keccak256(ser_data);\r\n    }\r\n\r\n    /**\r\n     * @notice Get hash from the transferral parameters\r\n     */\r\n    function getTransferralHash(\r\n        address from,\r\n        uint8 config,\r\n        uint32 nonce,\r\n        address[] memory tos,\r\n        uint16[] memory tokenIDs,\r\n        uint256[] memory amounts,\r\n        uint256[] memory fees\r\n    ) public pure returns (bytes32 hash) {\r\n        uint256 count = tos.length;\r\n        bytes memory ser;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            ser = abi.encodePacked(fees[i], amounts[i], tokenIDs[i], tos[i], ser);\r\n        }\r\n        ser = abi.encodePacked(ser, nonce, config, from);\r\n        hash = _getTransferralHash(ser);\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/SerializableMigration.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title Serializable Migration\r\n * @author Ben Huang\r\n * @notice Let migration support serialization and deserialization\r\n */\r\ncontract SerializableMigration {\r\n    using SafeMath for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    uint constant public MIGRATION_1_SIZE = 24;\r\n    uint constant public TOKENID_SIZE = 2;\r\n    uint8 constant internal _MASK_IS_ETH = 0x01;\r\n\r\n    /**\r\n     * @notice Get target address from the serialized migration data\r\n     * @param ser_data Serialized migration data\r\n     * @return target Target contract address\r\n     */\r\n    function _getMigrationTarget(bytes memory ser_data) internal pure returns (address target) {\r\n        target = ser_data.toAddress(ser_data.length - 20);\r\n    }\r\n\r\n    /**\r\n     * @notice Get user ID from the serialized migration data\r\n     * @param ser_data Serialized migration data\r\n     * @return userID User ID\r\n     */\r\n    function _getMigrationUserID(bytes memory ser_data) internal pure returns (uint256 userID) {\r\n        userID = ser_data.toUint32(ser_data.length - 24);\r\n    }\r\n\r\n    /**\r\n     * @notice Get token count\r\n     * @param ser_data Serialized migration data\r\n     * @return n The migrate token amount\r\n     */\r\n    function _getMigrationCount(bytes memory ser_data) internal pure returns (uint256 n) {\r\n        n = (ser_data.length - MIGRATION_1_SIZE) / TOKENID_SIZE;\r\n    }\r\n\r\n    /**\r\n     * @notice Get token ID to be migrated\r\n     * @param ser_data Serialized migration data\r\n     * @param index The index of token ID to be migrated\r\n     * @return tokenID The token ID to be migrated\r\n     */\r\n    function _getMigrationTokenID(bytes memory ser_data, uint index) internal pure returns (uint256 tokenID) {\r\n        require(index < _getMigrationCount(ser_data));\r\n        tokenID = ser_data.toUint16(ser_data.length - MIGRATION_1_SIZE - (TOKENID_SIZE.mul(index + 1)));\r\n    }\r\n\r\n    /**\r\n     * @notice Get hash from the serialized migration data\r\n     * @param ser_data Serialized migration data\r\n     * @return hash Migration hash without signature\r\n     */\r\n    function _getMigrationHash(bytes memory ser_data) internal pure returns (bytes32 hash) {\r\n        hash = keccak256(ser_data);\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/SerializableWithdrawal.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title Serializable Withdrawal\r\n * @author Ben Huang\r\n * @notice Let withdrawal support serialization and deserialization\r\n */\r\ncontract SerializableWithdrawal {\r\n    using SafeMath for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    uint constant public WITHDRAWAL_SIZE = 75;\r\n    uint8 constant internal _MASK_IS_MAIN = 0x01;\r\n\r\n    /**\r\n     * @notice Get user ID from the serialized withdrawal data\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return userID User ID\r\n     */\r\n    function _getWithdrawalUserID(bytes memory ser_data) internal pure returns (uint256 userID) {\r\n        userID = ser_data.toUint32(WITHDRAWAL_SIZE - 4);\r\n    }\r\n\r\n    /**\r\n     * @notice Get token ID from the serialized withdrawal data\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return tokenID Withdrawal token ID\r\n     */\r\n    function _getWithdrawalTokenID(bytes memory ser_data) internal pure returns (uint256 tokenID) {\r\n        tokenID = ser_data.toUint16(WITHDRAWAL_SIZE - 6);\r\n    }\r\n\r\n    /**\r\n     * @notice Get amount from the serialized withdrawal data\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return amount Withdrawal token amount\r\n     */\r\n    function _getWithdrawalAmount(bytes memory ser_data) internal pure returns (uint256 amount) {\r\n        amount = ser_data.toUint(WITHDRAWAL_SIZE - 38);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the fee is paid by main token\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return fFeeMain Is the fee paid in withdraw token or DGO\r\n     */\r\n    function _isWithdrawalFeeMain(bytes memory ser_data) internal pure returns (bool fFeeMain) {\r\n        fFeeMain = (ser_data.toUint8(WITHDRAWAL_SIZE - 39) & _MASK_IS_MAIN != 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Get nonce from the serialized withrawal data\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return nonce Nonce\r\n     */\r\n    function _getWithdrawalNonce(bytes memory ser_data) internal pure returns (uint256 nonce) {\r\n        nonce = ser_data.toUint32(WITHDRAWAL_SIZE - 43);\r\n    }\r\n\r\n    /**\r\n     * @notice Get fee amount from the serialized withdrawal data\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return fee Fee amount\r\n     */\r\n    function _getWithdrawalFee(bytes memory ser_data) internal pure returns (uint256 fee) {\r\n        fee = ser_data.toUint(WITHDRAWAL_SIZE - 75);\r\n    }\r\n\r\n    /**\r\n     * @notice Get hash from the serialized withdrawal data\r\n     * @param ser_data Serialized withdrawal data\r\n     * @return hash Withdrawal hash without signature\r\n     */\r\n    function _getWithdrawalHash(bytes memory ser_data) internal pure returns (bytes32 hash) {\r\n        hash = keccak256(ser_data);\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/SerializableOrder.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title Serializable Order\r\n * @author Ben Huang\r\n * @notice Let order support serialization and deserialization\r\n */\r\ncontract SerializableOrder {\r\n    using SafeMath for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    uint constant public ORDER_SIZE = 141;\r\n    uint8 constant internal _MASK_IS_BUY = 0x01;\r\n    uint8 constant internal _MASK_IS_MAIN = 0x02;\r\n\r\n    /**\r\n     * @notice Get user ID from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return userID User ID\r\n     */\r\n    function _getOrderUserID(bytes memory ser_data) internal pure returns (uint256 userID) {\r\n        userID = ser_data.toUint32(ORDER_SIZE - 4);\r\n    }\r\n\r\n    /**\r\n     * @notice Get base token ID from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return tokenBase Base token ID\r\n     */\r\n    function _getOrderTokenIDBase(bytes memory ser_data) internal pure returns (uint256 tokenBase) {\r\n        tokenBase = ser_data.toUint16(ORDER_SIZE - 6);\r\n    }\r\n\r\n    /**\r\n     * @notice Get base token amount from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return amountBase Base token amount\r\n     */\r\n    function _getOrderAmountBase(bytes memory ser_data) internal pure returns (uint256 amountBase) {\r\n        amountBase = ser_data.toUint(ORDER_SIZE - 38);\r\n    }\r\n\r\n    /**\r\n     * @notice Get quote token ID from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return tokenQuote Quote token ID\r\n     */\r\n    function _getOrderTokenIDQuote(bytes memory ser_data) internal pure returns (uint256 tokenQuote) {\r\n        tokenQuote = ser_data.toUint16(ORDER_SIZE - 40);\r\n    }\r\n\r\n    /**\r\n     * @notice Get quote token amount from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return amountQuote Quote token amount\r\n     */\r\n    function _getOrderAmountQuote(bytes memory ser_data) internal pure returns (uint256 amountQuote) {\r\n        amountQuote = ser_data.toUint(ORDER_SIZE - 72);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the order is a buy order\r\n     * @param ser_data Serialized order data\r\n     * @return fBuy Is buy order or not\r\n     */\r\n    function _isOrderBuy(bytes memory ser_data) internal pure returns (bool fBuy) {\r\n        fBuy = (ser_data.toUint8(ORDER_SIZE - 73) & _MASK_IS_BUY != 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the fee is paid by main token\r\n     * @param ser_data Serialized order data\r\n     * @return fMain Is the fee paid in main token or not\r\n     */\r\n    function _isOrderFeeMain(bytes memory ser_data) internal pure returns (bool fMain) {\r\n        fMain = (ser_data.toUint8(ORDER_SIZE - 73) & _MASK_IS_MAIN != 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Get nonce from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return nonce Nonce\r\n     */\r\n    function _getOrderNonce(bytes memory ser_data) internal pure returns (uint256 nonce) {\r\n        nonce = ser_data.toUint32(ORDER_SIZE - 77);\r\n    }\r\n\r\n    /**\r\n     * @notice Get handling fee from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return fee Fee amount\r\n     */\r\n    function _getOrderHandleFee(bytes memory ser_data) internal pure returns (uint256 handleFee) {\r\n        handleFee = ser_data.toUint(ORDER_SIZE - 109);\r\n    }\r\n\r\n    /**\r\n     * @notice Get gas fee from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return fee Fee amount\r\n     */\r\n    function _getOrderGasFee(bytes memory ser_data) internal pure returns (uint256 gasFee) {\r\n        gasFee = ser_data.toUint(ORDER_SIZE - 141);\r\n    }\r\n\r\n    /**\r\n     * @notice Get hash from the serialized order data\r\n     * @param ser_data Serialized order data\r\n     * @return hash Order hash without signature\r\n     */\r\n    function _getOrderHash(bytes memory ser_data) internal pure returns (bytes32 hash) {\r\n        hash = keccak256(ser_data);\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch the serialized order data with the given index\r\n     * @param ser_data Serialized order data\r\n     * @param index The index of order to be fetched\r\n     * @return order_data The fetched order data\r\n     */\r\n    function _getOrder(bytes memory ser_data, uint index) internal pure returns (bytes memory order_data) {\r\n        require(index < _getOrderCount(ser_data));\r\n        order_data = ser_data.slice(ORDER_SIZE.mul(index), ORDER_SIZE);\r\n    }\r\n\r\n    /**\r\n     * @notice Count the order amount\r\n     * @param ser_data Serialized order data\r\n     * @return amount Order amount\r\n     */\r\n    function _getOrderCount(bytes memory ser_data) internal pure returns (uint256 amount) {\r\n        amount = ser_data.length.div(ORDER_SIZE);\r\n    }\r\n}\r\n\r\n// File: bytes/BytesLib.sol\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add \r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n                \r\n                for { \r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory) {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\r\n     * JSON-RPC method.\r\n     *\r\n     * See `recover`.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/Dinngo.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Dinngo\r\n * @author Ben Huang\r\n * @notice Main exchange contract for Dinngo\r\n */\r\ncontract Dinngo is\r\n    SerializableOrder,\r\n    SerializableWithdrawal,\r\n    SerializableMigration,\r\n    SerializableTransferral\r\n{\r\n    // Storage alignment\r\n    address private _owner;\r\n    mapping (address => bool) private admins;\r\n    uint256 private _nAdmin;\r\n    uint256 private _nLimit;\r\n    // end\r\n    using ECDSA for bytes32;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    uint256 public processTime;\r\n\r\n    mapping (address => mapping (address => uint256)) public balances;\r\n    mapping (bytes32 => uint256) public orderFills;\r\n    mapping (uint256 => address payable) public userID_Address;\r\n    mapping (uint256 => address) public tokenID_Address;\r\n    mapping (address => uint256) public nonces;\r\n    mapping (address => uint256) public ranks;\r\n    mapping (address => uint256) public lockTimes;\r\n\r\n    address public walletOwner;\r\n    address public DGOToken;\r\n    uint8 public eventConf;\r\n\r\n    // On/Off by _isEventUserOn()\r\n    event AddUser(uint256 userID, address indexed user);\r\n    // On/Off by _isEventTokenOn()\r\n    event AddToken(uint256 tokenID, address indexed token);\r\n    // On/Off by _isEventFundsOn()\r\n    event Deposit(address token, address indexed user, uint256 amount, uint256 balance);\r\n    event Withdraw(\r\n        address token,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 balance,\r\n        address tokenFee,\r\n        uint256 amountFee\r\n    );\r\n    event Trade(\r\n        address indexed user,\r\n        bool isBuy,\r\n        address indexed tokenBase,\r\n        uint256 amountBase,\r\n        address indexed tokenQuote,\r\n        uint256 amountQuote,\r\n        address tokenFee,\r\n        uint256 amountFee\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        address token,\r\n        uint256 amount,\r\n        address feeToken,\r\n        uint256 feeAmount\r\n    );\r\n    // On/Off by _isEventUserOn()\r\n    event Lock(address indexed user, uint256 lockTime);\r\n    event Unlock(address indexed user);\r\n\r\n    uint256 constant public version = 2;\r\n\r\n    uint8 constant internal _MASK_EVENT_USER = 0x01;\r\n    uint8 constant internal _MASK_EVENT_TOKEN = 0x02;\r\n    uint8 constant internal _MASK_EVENT_FUNDS = 0x04;\r\n\r\n    /**\r\n     * @dev bit 0: user event\r\n     *      bit 1: token event\r\n     *      bit 2: funds event\r\n     * @notice Set the event switch configuration.\r\n     * @param conf Event configuration\r\n     */\r\n    function setEvent(uint8 conf) external {\r\n        require(eventConf != conf);\r\n        eventConf = conf;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the address to the user list. Event AddUser will be emitted\r\n     * after execution.\r\n     * @dev Record the user list to map the user address to a specific user ID, in\r\n     * order to compact the data size when transferring user address information\r\n     * @dev id should be less than 2**32\r\n     * @param id The user id to be assigned\r\n     * @param user The user address to be added\r\n     */\r\n    function addUser(uint256 id, address payable user) external {\r\n        require(user != address(0));\r\n        require(ranks[user] == 0);\r\n        require(id < 2**32);\r\n        if (userID_Address[id] == address(0))\r\n            userID_Address[id] = user;\r\n        else\r\n            require(userID_Address[id] == user);\r\n        ranks[user] = 1;\r\n        if (_isEventUserOn())\r\n            emit AddUser(id, user);\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token to the token list. Event AddToken will be emitted\r\n     * after execution.\r\n     * @dev Record the token list to map the token contract address to a specific\r\n     * token ID, in order to compact the data size when transferring token contract\r\n     * address information\r\n     * @dev id should be less than 2**16\r\n     * @param id The token id to be assigned\r\n     * @param token The token contract address to be added\r\n     */\r\n    function addToken(uint256 id, address token) external {\r\n        require(token != address(0));\r\n        require(ranks[token] == 0);\r\n        require(id < 2**16);\r\n        if (tokenID_Address[id] == address(0))\r\n            tokenID_Address[id] = token;\r\n        else\r\n            require(tokenID_Address[id] == token);\r\n        ranks[token] = 1;\r\n        if (_isEventTokenOn())\r\n            emit AddToken(id, token);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the rank of user or token.\r\n     * @param addr The address to be updated.\r\n     * @param rank The rank to be assigned.\r\n     */\r\n    function updateRank(address addr, uint256 rank) external {\r\n        require(addr != address(0));\r\n        require(rank != 0);\r\n        require(ranks[addr] != 0);\r\n        require(ranks[addr] != rank);\r\n        ranks[addr] = rank;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the user or token.\r\n     * @dev The rank is set to 0 to remove.\r\n     * @param addr The address to be removed.\r\n     */\r\n    function remove(address addr) external {\r\n        require(addr != address(0));\r\n        require(ranks[addr] != 0);\r\n        ranks[addr] = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice The deposit function for ether. The ether that is sent with the function\r\n     * call will be deposited. The first time user will be added to the user list.\r\n     * Event Deposit will be emitted after execution.\r\n     */\r\n    function deposit() external payable {\r\n        require(!_isLocking(msg.sender));\r\n        require(msg.value > 0);\r\n        balances[address(0)][msg.sender] = balances[address(0)][msg.sender].add(msg.value);\r\n        if (_isEventFundsOn())\r\n            emit Deposit(address(0), msg.sender, msg.value, balances[address(0)][msg.sender]);\r\n    }\r\n\r\n    /**\r\n     * @notice The deposit function for tokens. The first time user will be added to\r\n     * the user list. Event Deposit will be emitted after execution.\r\n     * @param token Address of the token contract to be deposited\r\n     * @param amount Amount of the token to be depositied\r\n     */\r\n    function depositToken(address token, uint256 amount) external {\r\n        require(token != address(0));\r\n        require(!_isLocking(msg.sender));\r\n        require(_isValid(token));\r\n        require(amount > 0);\r\n        balances[token][msg.sender] = balances[token][msg.sender].add(amount);\r\n        if (_isEventFundsOn())\r\n            emit Deposit(token, msg.sender, amount, balances[token][msg.sender]);\r\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The withdraw function for ether. Event Withdraw will be emitted\r\n     * after execution. User needs to be locked before calling withdraw.\r\n     * @param amount The amount to be withdrawn.\r\n     */\r\n    function withdraw(uint256 amount) external {\r\n        require(_isLocked(msg.sender));\r\n        require(_isValid(msg.sender));\r\n        require(amount > 0);\r\n        balances[address(0)][msg.sender] = balances[address(0)][msg.sender].sub(amount);\r\n        if (_isEventFundsOn())\r\n            emit Withdraw(address(0), msg.sender, amount, balances[address(0)][msg.sender], address(0), 0);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The withdraw function for tokens. Event Withdraw will be emitted\r\n     * after execution. User needs to be locked before calling withdraw.\r\n     * @param token The token contract address to be withdrawn.\r\n     * @param amount The token amount to be withdrawn.\r\n     */\r\n    function withdrawToken(address token, uint256 amount) external {\r\n        require(token != address(0));\r\n        require(_isLocked(msg.sender));\r\n        require(_isValid(msg.sender));\r\n        require(_isValid(token));\r\n        require(amount > 0);\r\n        balances[token][msg.sender] = balances[token][msg.sender].sub(amount);\r\n        if (_isEventFundsOn())\r\n            emit Withdraw(token, msg.sender, amount, balances[token][msg.sender], address(0), 0);\r\n        IERC20(token).safeTransfer(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The extract function for fee in ether. Can only be triggered by\r\n     * the dinngo wallet owner.\r\n     * @param amount The amount to be withdrawn\r\n     */\r\n    function extractFee(uint256 amount) external {\r\n        require(amount > 0);\r\n        require(msg.sender == walletOwner);\r\n        balances[address(0)][address(0)] = balances[address(0)][address(0)].sub(amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The extract function for fee in token. Can only be triggered by\r\n     * the dinngo wallet owner.\r\n     * @param token The token contract address to be withdrawn\r\n     * @param amount The amount to be withdrawn\r\n     */\r\n    function extractTokenFee(address token, uint256 amount) external {\r\n        require(amount > 0);\r\n        require(msg.sender ==  walletOwner);\r\n        require(token != address(0));\r\n        balances[token][address(0)] = balances[token][address(0)].sub(amount);\r\n        IERC20(token).safeTransfer(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The function to get the balance from fee account.\r\n     * @param token The token of the balance to be queried\r\n     */\r\n    function getWalletBalance(address token) external view returns (uint256) {\r\n        return balances[token][address(0)];\r\n    }\r\n\r\n    /**\r\n     * @notice The function to change the owner of fee wallet.\r\n     * @param newOwner The new wallet owner to be assigned\r\n     */\r\n    function changeWalletOwner(address newOwner) external {\r\n        require(newOwner != address(0));\r\n        require(newOwner != walletOwner);\r\n        walletOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice The withdraw function that can only be triggered by owner.\r\n     * Event Withdraw will be emitted after execution.\r\n     * @param withdrawal The serialized withdrawal data\r\n     */\r\n    function withdrawByAdmin(bytes calldata withdrawal, bytes calldata signature) external {\r\n        address payable user = userID_Address[_getWithdrawalUserID(withdrawal)];\r\n        require(_isValid(user), \"user invalid\");\r\n        uint256 nonce = _getWithdrawalNonce(withdrawal);\r\n        require(nonce > nonces[user], \"nonce invalid\");\r\n        nonces[user] = nonce;\r\n        _verifySig(user, _getWithdrawalHash(withdrawal), signature);\r\n        uint256 tokenID = _getWithdrawalTokenID(withdrawal);\r\n        address token = tokenID == 0? address(0) : tokenID_Address[tokenID];\r\n        uint256 amount = _getWithdrawalAmount(withdrawal);\r\n        uint256 amountFee = _getWithdrawalFee(withdrawal);\r\n        uint256 balance = balances[token][user];\r\n        bool fFeeMain = _isWithdrawalFeeMain(withdrawal);\r\n\r\n        if (fFeeMain) {\r\n            balance = balance.sub(amount).sub(amountFee);\r\n            balances[token][address(0)] = balances[token][address(0)].add(amountFee);\r\n        } else {\r\n            balance = balance.sub(amount);\r\n            balances[DGOToken][user] = balances[DGOToken][user].sub(amountFee);\r\n            balances[DGOToken][address(0)] = balances[DGOToken][address(0)].add(amountFee);\r\n        }\r\n        balances[token][user] = balance;\r\n\r\n        if (_isEventFundsOn()) {\r\n            if (fFeeMain)\r\n                emit Withdraw(token, user, amount, balance, token, amountFee);\r\n            else\r\n                emit Withdraw(token, user, amount, balance, DGOToken, amountFee);\r\n        }\r\n\r\n        if (token == address(0)) {\r\n            user.transfer(amount);\r\n        } else {\r\n            IERC20(token).safeTransfer(user, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The migrate function the can only triggered by admin.\r\n     * Event Migrate will be emitted after execution.\r\n     * @param migration The serialized migration data\r\n     */\r\n    function migrateByAdmin(bytes calldata migration, bytes calldata signature) external {\r\n        address target = _getMigrationTarget(migration);\r\n        address user = userID_Address[_getMigrationUserID(migration)];\r\n        uint256 nToken = _getMigrationCount(migration);\r\n        require(_isValid(user), \"user invalid\");\r\n        _verifySig(user, _getWithdrawalHash(migration), signature);\r\n        for (uint i = 0; i < nToken; i++) {\r\n            address token = tokenID_Address[_getMigrationTokenID(migration, i)];\r\n            uint256 balance = balances[token][user];\r\n            require(balance != 0, \"0 amount\");\r\n            balances[token][user] = 0;\r\n            if (token == address(0)) {\r\n                Migratable(target).migrateTo.value(balance)(user, token, balance);\r\n            } else {\r\n                IERC20(token).safeApprove(target, balance);\r\n                Migratable(target).migrateTo(user, token, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The migration handler\r\n     * @param user The user address to receive the migrated amount.\r\n     * @param token The token address to be migrated.\r\n     * @param amount The amount to be migrated.\r\n     */\r\n    function migrateTo(address user, address token, uint256 amount) payable external {\r\n        balances[token][user] = balances[token][user].add(amount);\r\n        if (token == address(0)) {\r\n            require(msg.value == amount);\r\n        } else {\r\n            _isValid(token);\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The transfer function that can only be triggered by admin.\r\n     * Event transfer will be emitted after execution.\r\n     * @param transferral The serialized transferral data.\r\n     */\r\n    function transferByAdmin(bytes calldata transferral, bytes calldata signature) external {\r\n        address from = _getTransferralFrom(transferral);\r\n        bool fFeeMain = _isTransferralFeeMain(transferral);\r\n        uint256 feeDGO = 0;\r\n        uint256 nTransferral = _getTransferralCount(transferral);\r\n        uint256 nonce = _getTransferralNonce(transferral);\r\n        require(nonce > nonces[from], \"nonce invalid\");\r\n        nonces[from] = nonce;\r\n        for (uint256 i = 0; i < nTransferral; i++) {\r\n            address to = _getTransferralTo(transferral, i);\r\n            address token = tokenID_Address[_getTransferralTokenID(transferral, i)];\r\n            uint256 amount = _getTransferralAmount(transferral, i);\r\n            uint256 fee = _getTransferralFee(transferral, i);\r\n            if (fFeeMain) {\r\n                balances[token][from] = balances[token][from].sub(amount).sub(fee);\r\n                balances[token][to] = balances[token][to].add(amount);\r\n                balances[token][address(0)] = balances[token][address(0)].add(fee);\r\n                if (_isEventFundsOn())\r\n                    emit Transfer(from, to, token, amount, token, fee);\r\n            } else {\r\n                balances[token][from] = balances[token][from].sub(amount);\r\n                balances[token][to] = balances[token][to].add(amount);\r\n                feeDGO = feeDGO.add(fee);\r\n                if (_isEventFundsOn())\r\n                    emit Transfer(from, to, token, amount, DGOToken, fee);\r\n            }\r\n        }\r\n        if (!fFeeMain) {\r\n            balances[DGOToken][from] = balances[DGOToken][from].sub(feeDGO);\r\n            balances[DGOToken][address(0)] = balances[DGOToken][address(0)].add(feeDGO);\r\n        }\r\n        bytes32 hash = _getTransferralHash(transferral);\r\n        if (signature.length == 65) {\r\n            _verifySig(from, hash, signature);\r\n            require(_isValid(from), \"user invalid\");\r\n        } else {\r\n            require(ISign(from).signed(hash), 'contract sign failed');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The settle function for orders. First order is taker order and the followings\r\n     * are maker orders.\r\n     * @param orders The serialized orders.\r\n     */\r\n    function settle(bytes calldata orders, bytes calldata signatures) external {\r\n        // Deal with the order list\r\n        uint256 nOrder = _getOrderCount(orders);\r\n        // Get the first order as the taker order\r\n        bytes memory takerOrder = _getOrder(orders, 0);\r\n        uint256[4] memory takerAmounts; //[takerAmountBase, restAmountBase, fillAmountBase, fillAmountQuote]\r\n        takerAmounts[0] = _getOrderAmountBase(takerOrder);\r\n        takerAmounts[1] = takerAmounts[0].sub(orderFills[_getOrderHash(takerOrder)]);\r\n        takerAmounts[2] = takerAmounts[1];\r\n        takerAmounts[3] = 0;\r\n        bool fBuy = _isOrderBuy(takerOrder);\r\n        // Parse maker orders\r\n        for (uint256 i = 1; i < nOrder; i++) {\r\n            // Get ith order as the maker order\r\n            bytes memory makerOrder = _getOrder(orders, i);\r\n            require(fBuy != _isOrderBuy(makerOrder), \"buy/buy or sell/sell\");\r\n            uint256 makerAmountBase = _getOrderAmountBase(makerOrder);\r\n            uint256 makerAmountQuote = _getOrderAmountQuote(makerOrder);\r\n            if (fBuy) {\r\n                require(\r\n                    makerAmountQuote <= _getOrderAmountQuote(takerOrder).mul(makerAmountBase).div(takerAmounts[0]),\r\n                    \"buy high\"\r\n                );\r\n            } else {\r\n                require(\r\n                    makerAmountQuote >= _getOrderAmountQuote(takerOrder).mul(makerAmountBase).div(takerAmounts[0]),\r\n                    \"sell low\"\r\n                );\r\n            }\r\n            uint256 amountBase = makerAmountBase.sub(orderFills[_getOrderHash(makerOrder)]);\r\n            amountBase = (amountBase <= takerAmounts[1])? amountBase : takerAmounts[1];\r\n            uint256 amountQuote = makerAmountQuote.mul(amountBase).div(makerAmountBase);\r\n            takerAmounts[1] = takerAmounts[1].sub(amountBase);\r\n            takerAmounts[3] = takerAmounts[3].add(amountQuote);\r\n            // Trade amountBase and amountQuote for maker order\r\n            bytes memory sig = signatures.slice(i.mul(65), 65);\r\n            _trade(amountBase, amountQuote, makerOrder, sig);\r\n        }\r\n        // Sum the trade amount\r\n        takerAmounts[2] = takerAmounts[2].sub(takerAmounts[1]);\r\n        // Trade amountBase and amountQuote for taker order\r\n        bytes memory sig = signatures.slice(0, 65);\r\n        _trade(takerAmounts[2], takerAmounts[3], takerOrder, sig);\r\n    }\r\n\r\n    /**\r\n     * @notice Announce lock of the sender\r\n     */\r\n    function lock() external {\r\n        require(!_isLocking(msg.sender));\r\n        lockTimes[msg.sender] = now.add(processTime);\r\n        if (_isEventUserOn())\r\n            emit Lock(msg.sender, lockTimes[msg.sender]);\r\n    }\r\n\r\n    /**\r\n     * @notice Unlock the sender\r\n     */\r\n    function unlock() external {\r\n        require(_isLocking(msg.sender));\r\n        lockTimes[msg.sender] = 0;\r\n        if (_isEventUserOn())\r\n            emit Unlock(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the processing time of locking the user address\r\n     */\r\n    function changeProcessTime(uint256 time) external {\r\n        require(processTime != time);\r\n        processTime = time;\r\n    }\r\n\r\n    /**\r\n     * @notice Process the trade by the providing information\r\n     * @param amountBase The provided amount to be traded\r\n     * @param amountQuote The amount to be requested\r\n     * @param order The order that triggered the trading\r\n     */\r\n    function _trade(uint256 amountBase, uint256 amountQuote, bytes memory order, bytes memory signature) internal {\r\n        require(amountBase != 0, \"0 amount base\");\r\n        // Get parameters\r\n        address user = userID_Address[_getOrderUserID(order)];\r\n        bytes32 hash = _getOrderHash(order);\r\n        address tokenQuote = tokenID_Address[_getOrderTokenIDQuote(order)];\r\n        address tokenBase = tokenID_Address[_getOrderTokenIDBase(order)];\r\n        address tokenFee;\r\n        uint256 amountFee =\r\n            _getOrderHandleFee(order).mul(amountBase).div(_getOrderAmountBase(order));\r\n        require(_isValid(user), \"user invalid\");\r\n        // Trade and fee setting\r\n        if (orderFills[hash] == 0) {\r\n            _verifySig(user, hash, signature);\r\n            amountFee = amountFee.add(_getOrderGasFee(order));\r\n        }\r\n        bool fBuy = _isOrderBuy(order);\r\n        if (fBuy) {\r\n            balances[tokenQuote][user] = balances[tokenQuote][user].sub(amountQuote);\r\n            if (_isOrderFeeMain(order)) {\r\n                tokenFee = tokenBase;\r\n                balances[tokenBase][user] = balances[tokenBase][user].add(amountBase).sub(amountFee);\r\n                balances[tokenBase][address(0)] = balances[tokenBase][address(0)].add(amountFee);\r\n            } else {\r\n                tokenFee = DGOToken;\r\n                balances[tokenBase][user] = balances[tokenBase][user].add(amountBase);\r\n                balances[tokenFee][user] = balances[tokenFee][user].sub(amountFee);\r\n                balances[tokenFee][address(0)] = balances[tokenFee][address(0)].add(amountFee);\r\n            }\r\n        } else {\r\n            balances[tokenBase][user] = balances[tokenBase][user].sub(amountBase);\r\n            if (_isOrderFeeMain(order)) {\r\n                tokenFee = tokenQuote;\r\n                balances[tokenQuote][user] = balances[tokenQuote][user].add(amountQuote).sub(amountFee);\r\n                balances[tokenQuote][address(0)] = balances[tokenQuote][address(0)].add(amountFee);\r\n            } else {\r\n                tokenFee = DGOToken;\r\n                balances[tokenQuote][user] = balances[tokenQuote][user].add(amountQuote);\r\n                balances[tokenFee][user] = balances[tokenFee][user].sub(amountFee);\r\n                balances[tokenFee][address(0)] = balances[tokenFee][address(0)].add(amountFee);\r\n            }\r\n        }\r\n        // Order fill\r\n        orderFills[hash] = orderFills[hash].add(amountBase);\r\n        if (_isEventFundsOn())\r\n            emit Trade\r\n            (\r\n                user,\r\n                fBuy,\r\n                tokenBase,\r\n                amountBase,\r\n                tokenQuote,\r\n                amountQuote,\r\n                tokenFee,\r\n                amountFee\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the user or token is valid\r\n     * @param addr The address to be checked.\r\n     */\r\n    function _isValid(address addr) internal view returns (bool) {\r\n        return ranks[addr] != 0;\r\n    }\r\n\r\n    function _verifySig(address user, bytes32 hash, bytes memory signature) internal pure {\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0);\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        require(v == 27 || v == 28);\r\n\r\n        address sigAddr = ecrecover(hash.toEthSignedMessageHash(), v, r, s);\r\n        require(user == sigAddr, \"sig failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Return if the give user has announced lock\r\n     * @param user The user address to be queried\r\n     * @return Query result\r\n     */\r\n    function _isLocking(address user) internal view returns (bool) {\r\n        return lockTimes[user] > 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Return if the user is locked\r\n     * @param user The user address to be queried\r\n     */\r\n    function _isLocked(address user) internal view returns (bool) {\r\n        return _isLocking(user) && lockTimes[user] < now;\r\n    }\r\n\r\n    function _isEventUserOn() internal view returns (bool) {\r\n        return (eventConf & _MASK_EVENT_USER != 0);\r\n    }\r\n\r\n    function _isEventTokenOn() internal view returns (bool) {\r\n        return (eventConf & _MASK_EVENT_TOKEN != 0);\r\n    }\r\n\r\n    function _isEventFundsOn() internal view returns (bool) {\r\n        return (eventConf & _MASK_EVENT_FUNDS != 0);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AddToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenBase\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBase\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenQuote\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountQuote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenFee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFee\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenFee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DGOToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIGRATION_1_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORDER_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RECEIVER_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENID_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TRANSFERRAL_1_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"changeProcessTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeWalletOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventConf\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"extractFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"extractTokenFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"config\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIDs\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"}],\"name\":\"getTransferralHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getWalletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"migration\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"migrateByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ranks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"conf\",\"type\":\"uint8\"}],\"name\":\"setEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"orders\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenID_Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transferral\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"updateRank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userID_Address\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"withdrawal\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Dinngo","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://e656b4ddf13b2677d6ccdd07920546c60ffd42d3821ff032947154909676d084"}]}