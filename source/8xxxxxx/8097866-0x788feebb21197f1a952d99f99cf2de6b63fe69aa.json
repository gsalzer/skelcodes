{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\ncontract CompressedCaller {\r\n\r\n    function compressedCall(\r\n        address target,\r\n        uint256 totalLength,\r\n        bytes memory zipped\r\n    )\r\n        public\r\n        payable\r\n        returns (bytes memory result)\r\n    {\r\n        (bytes memory data, uint decompressedLength) = decompress(totalLength, zipped);\r\n        require(decompressedLength == totalLength, \"Uncompress error\");\r\n\r\n        bool success;\r\n        (success, result) = target.call.value(msg.value)(data);\r\n        require(success, \"Decompressed call failed\");\r\n    }\r\n\r\n    function decompress(\r\n        uint256 totalLength,\r\n        bytes memory zipped\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            bytes memory data,\r\n            uint256 index\r\n        )\r\n    {\r\n        bytes memory zeros = new bytes(127);\r\n        data = new bytes(totalLength);\r\n\r\n        for (uint i = 0; i < zipped.length; i++) {\r\n\r\n            uint len = uint(uint8(zipped[i]) & 0x7F);\r\n\r\n            if ((zipped[i] & 0x80) == 0) {\r\n                memcpy(data, index, zipped, i, len);\r\n                i += len;\r\n            } else {\r\n                memcpy(data, index, zeros, 0, len);\r\n            }\r\n\r\n            index += len;\r\n        }\r\n    }\r\n\r\n    function memcpy(\r\n        bytes memory destMem,\r\n        uint dest,\r\n        bytes memory srcMem,\r\n        uint src,\r\n        uint len\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        assembly {\r\n            dest := add(add(destMem, 32), dest)\r\n            src := add(add(srcMem, 32), src)\r\n\r\n            // Copy word-length chunks while possible\r\n            for { } not(lt(len, 32)) { len := sub(len, 32) } { // (!<) is the same as (>=)\r\n                mstore(dest, mload(src))\r\n                dest := add(dest, 32)\r\n                src := add(src, 32)\r\n            }\r\n\r\n            // Copy remaining bytes\r\n            let mask := sub(shl(1, mul(8, sub(32, len))), 1) // 256**(32-len) == 1<<(8*(32-len))\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"totalLength\",\"type\":\"uint256\"},{\"name\":\"zipped\",\"type\":\"bytes\"}],\"name\":\"compressedCall\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"totalLength\",\"type\":\"uint256\"},{\"name\":\"zipped\",\"type\":\"bytes\"}],\"name\":\"decompress\",\"outputs\":[{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompressedCaller","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5782fb2f97ec3c4e4bbb0c56f778a8dd1c9802342d5b7f29ce3cc52c8c883ac8"}]}