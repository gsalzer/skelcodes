{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\nlibrary MathUint {\n    function mul(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n    }\n\n    function sub(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        require(b <= a, \"SUB_UNDERFLOW\");\n        return a - b;\n    }\n\n    function add(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n    }\n\n    function decodeFloat(\n        uint f\n        )\n        internal\n        pure\n        returns (uint value)\n    {\n        uint numBitsMantissa = 23;\n        uint exponent = f >> numBitsMantissa;\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n        value = mantissa * (10 ** exponent);\n    }\n}\n\ncontract IBlockVerifier {\n    \n\n    event CircuitRegistered(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    event CircuitDisabled(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function registerCircuit(\n        uint8    blockType,\n        bool     onchainDataAvailability,\n        uint16   blockSize,\n        uint8    blockVersion,\n        uint[18] calldata vk\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function disableCircuit(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function verifyProofs(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion,\n        uint[] calldata publicInputs,\n        uint[] calldata proofs\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitRegistered(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitEnabled(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract ILoopring is Claimable, ReentrancyGuard\n{\n    string  constant public version = \"\"; \n\n    uint    public exchangeCreationCostLRC;\n    address public universalRegistry;\n    address public lrcAddress;\n\n    event ExchangeInitialized(\n        uint    indexed exchangeId,\n        address indexed exchangeAddress,\n        address indexed owner,\n        address         operator,\n        bool            onchainDataAvailability\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initializeExchange(\n        address exchangeAddress,\n        uint    exchangeId,\n        address owner,\n        address payable operator,\n        bool    onchainDataAvailability\n        )\n        external;\n}\n\ncontract ILoopringV3 is ILoopring\n{\n    \n\n    event ExchangeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeBurned(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event SettingsUpdated(\n        uint            time\n    );\n\n    \n    struct Exchange\n    {\n        address exchangeAddress;\n        uint    exchangeStake;\n        uint    protocolFeeStake;\n    }\n\n    mapping (uint => Exchange) internal exchanges;\n\n    string  constant public version = \"3.0\";\n\n    address public wethAddress;\n    uint    public totalStake;\n    address public blockVerifierAddress;\n    address public downtimeCostCalculator;\n    uint    public maxWithdrawalFee;\n    uint    public withdrawalFineLRC;\n    uint    public tokenRegistrationFeeLRCBase;\n    uint    public tokenRegistrationFeeLRCDelta;\n    uint    public minExchangeStakeWithDataAvailability;\n    uint    public minExchangeStakeWithoutDataAvailability;\n    uint    public revertFineLRC;\n    uint8   public minProtocolTakerFeeBips;\n    uint8   public maxProtocolTakerFeeBips;\n    uint8   public minProtocolMakerFeeBips;\n    uint8   public maxProtocolMakerFeeBips;\n    uint    public targetProtocolTakerFeeStake;\n    uint    public targetProtocolMakerFeeStake;\n\n    address payable public protocolFeeVault;\n\n    \n    \n    \n    \n    \n    \n    function updateSettings(\n        address payable _protocolFeeVault,   \n        address _blockVerifierAddress,       \n        address _downtimeCostCalculator,     \n        uint    _exchangeCreationCostLRC,\n        uint    _maxWithdrawalFee,\n        uint    _tokenRegistrationFeeLRCBase,\n        uint    _tokenRegistrationFeeLRCDelta,\n        uint    _minExchangeStakeWithDataAvailability,\n        uint    _minExchangeStakeWithoutDataAvailability,\n        uint    _revertFineLRC,\n        uint    _withdrawalFineLRC\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function updateProtocolFeeSettings(\n        uint8 _minProtocolTakerFeeBips,\n        uint8 _maxProtocolTakerFeeBips,\n        uint8 _minProtocolMakerFeeBips,\n        uint8 _maxProtocolMakerFeeBips,\n        uint  _targetProtocolTakerFeeStake,\n        uint  _targetProtocolMakerFeeStake\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function canExchangeCommitBlocks(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    function getExchangeStake(\n        uint exchangeId\n        )\n        public\n        view\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function burnExchangeStake(\n        uint exchangeId,\n        uint amount\n        )\n        external\n        returns (uint burnedLRC);\n\n    \n    \n    \n    \n    function depositExchangeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    \n    function withdrawExchangeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    requestedAmount\n        )\n        external\n        returns (uint amount);\n\n    \n    \n    \n    \n    function depositProtocolFeeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function withdrawProtocolFeeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    function getProtocolFeeValues(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (\n            uint8 takerFeeBips,\n            uint8 makerFeeBips\n        );\n\n    \n    \n    \n    function getProtocolFeeStake(\n        uint exchangeId\n        )\n        external\n        view\n        returns (uint protocolFeeStake);\n}\n\ncontract IAddressWhitelist {\n    \n    \n    \n    \n    function isAddressWhitelisted(\n        address addr,\n        bytes   memory permission\n        )\n        public\n        view\n        returns (bool);\n}\n\nlibrary Poseidon {\n    function hash_t5f6p52(\n        uint t0,\n        uint t1,\n        uint t2,\n        uint t3,\n        uint t4\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        uint q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n        \n        require(t0 < q, \"INVALID_INPUT\");\n        require(t1 < q, \"INVALID_INPUT\");\n        require(t2 < q, \"INVALID_INPUT\");\n        require(t3 < q, \"INVALID_INPUT\");\n        require(t4 < q, \"INVALID_INPUT\");\n\n        assembly {\n            function mix(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\n                nt0 := mulmod(t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, q)\n                nt0 := addmod(nt0, mulmod(t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, q), q)\n                nt0 := addmod(nt0, mulmod(t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q), q)\n                nt0 := addmod(nt0, mulmod(t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q)\n                nt0 := addmod(nt0, mulmod(t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q)\n                nt1 := mulmod(t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, q)\n                nt1 := addmod(nt1, mulmod(t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, q), q)\n                nt1 := addmod(nt1, mulmod(t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q), q)\n                nt1 := addmod(nt1, mulmod(t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q)\n                nt1 := addmod(nt1, mulmod(t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q)\n                nt2 := mulmod(t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, q)\n                nt2 := addmod(nt2, mulmod(t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, q), q)\n                nt2 := addmod(nt2, mulmod(t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q), q)\n                nt2 := addmod(nt2, mulmod(t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q)\n                nt2 := addmod(nt2, mulmod(t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q)\n                nt3 := mulmod(t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, q)\n                nt3 := addmod(nt3, mulmod(t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, q), q)\n                nt3 := addmod(nt3, mulmod(t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q), q)\n                nt3 := addmod(nt3, mulmod(t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q)\n                nt3 := addmod(nt3, mulmod(t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q)\n                nt4 := mulmod(t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, q)\n                nt4 := addmod(nt4, mulmod(t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, q), q)\n                nt4 := addmod(nt4, mulmod(t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q), q)\n                nt4 := addmod(nt4, mulmod(t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q)\n                nt4 := addmod(nt4, mulmod(t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q)\n            }\n\n            function ark(t0, t1, t2, t3, t4, q, c) -> nt0, nt1, nt2, nt3, nt4 {\n                nt0 := addmod(t0, c, q)\n                nt1 := addmod(t1, c, q)\n                nt2 := addmod(t2, c, q)\n                nt3 := addmod(t3, c, q)\n                nt4 := addmod(t4, c, q)\n            }\n\n            function sbox_full(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\n                nt0 := mulmod(t0, t0, q)\n                nt0 := mulmod(nt0, nt0, q)\n                nt0 := mulmod(t0, nt0, q)\n                nt1 := mulmod(t1, t1, q)\n                nt1 := mulmod(nt1, nt1, q)\n                nt1 := mulmod(t1, nt1, q)\n                nt2 := mulmod(t2, t2, q)\n                nt2 := mulmod(nt2, nt2, q)\n                nt2 := mulmod(t2, nt2, q)\n                nt3 := mulmod(t3, t3, q)\n                nt3 := mulmod(nt3, nt3, q)\n                nt3 := mulmod(t3, nt3, q)\n                nt4 := mulmod(t4, t4, q)\n                nt4 := mulmod(nt4, nt4, q)\n                nt4 := mulmod(t4, nt4, q)\n            }\n\n            function sbox_partial(t, q) -> nt {\n                nt := mulmod(t, t, q)\n                nt := mulmod(nt, nt, q)\n                nt := mulmod(t, nt, q)\n            }\n\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n        }\n        return t0;\n    }\n}\n\nlibrary ExchangeBalances {\n    using MathUint  for uint;\n\n    function verifyAccountBalance(\n        uint     merkleRoot,\n        uint24   accountID,\n        uint16   tokenID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountMerkleProof,\n        uint[12] calldata balanceMerkleProof\n        )\n        external\n        pure\n    {\n        bool isCorrect = isAccountBalanceCorrect(\n            merkleRoot,\n            accountID,\n            tokenID,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            balance,\n            tradeHistoryRoot,\n            accountMerkleProof,\n            balanceMerkleProof\n        );\n        require(isCorrect, \"INVALID_MERKLE_TREE_DATA\");\n    }\n\n    function isAccountBalanceCorrect(\n        uint     merkleRoot,\n        uint24   accountID,\n        uint16   tokenID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] memory accountMerkleProof,\n        uint[12] memory balanceMerkleProof\n        )\n        public\n        pure\n        returns (bool isCorrect)\n    {\n        \n        uint calculatedRoot = getBalancesRoot(\n            tokenID,\n            balance,\n            tradeHistoryRoot,\n            balanceMerkleProof\n        );\n        calculatedRoot = getAccountInternalsRoot(\n            accountID,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            calculatedRoot,\n            accountMerkleProof\n        );\n        isCorrect = (calculatedRoot == merkleRoot);\n    }\n\n    function getBalancesRoot(\n        uint16   tokenID,\n        uint     balance,\n        uint     tradeHistoryRoot,\n        uint[12] memory balanceMerkleProof\n        )\n        private\n        pure\n        returns (uint)\n    {\n        uint balanceItem = hashImpl(balance, tradeHistoryRoot, 0, 0);\n        uint _id = tokenID;\n        for (uint depth = 0; depth < 4; depth++) {\n            if (_id & 3 == 0) {\n                balanceItem = hashImpl(\n                    balanceItem,\n                    balanceMerkleProof[depth * 3],\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 1) {\n                balanceItem = hashImpl(\n                    balanceMerkleProof[depth * 3],\n                    balanceItem,\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 2) {\n                balanceItem = hashImpl(\n                    balanceMerkleProof[depth * 3],\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceItem,\n                    balanceMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 3) {\n                balanceItem = hashImpl(\n                    balanceMerkleProof[depth * 3],\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceMerkleProof[depth * 3 + 2],\n                    balanceItem\n                );\n            }\n            _id = _id >> 2;\n        }\n        return balanceItem;\n    }\n\n    function getAccountInternalsRoot(\n        uint24   accountID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint     nonce,\n        uint     balancesRoot,\n        uint[30] memory accountMerkleProof\n        )\n        private\n        pure\n        returns (uint)\n    {\n        uint accountItem = hashImpl(pubKeyX, pubKeyY, nonce, balancesRoot);\n        uint _id = accountID;\n        for (uint depth = 0; depth < 10; depth++) {\n            if (_id & 3 == 0) {\n                accountItem = hashImpl(\n                    accountItem,\n                    accountMerkleProof[depth * 3],\n                    accountMerkleProof[depth * 3 + 1],\n                    accountMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 1) {\n                accountItem = hashImpl(\n                    accountMerkleProof[depth * 3],\n                    accountItem,\n                    accountMerkleProof[depth * 3 + 1],\n                    accountMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 2) {\n                accountItem = hashImpl(\n                    accountMerkleProof[depth * 3],\n                    accountMerkleProof[depth * 3 + 1],\n                    accountItem,\n                    accountMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 3) {\n                accountItem = hashImpl(\n                    accountMerkleProof[depth * 3],\n                    accountMerkleProof[depth * 3 + 1],\n                    accountMerkleProof[depth * 3 + 2],\n                    accountItem\n                );\n            }\n            _id = _id >> 2;\n        }\n        return accountItem;\n    }\n\n    function hashImpl(\n        uint t0,\n        uint t1,\n        uint t2,\n        uint t3\n        )\n        private\n        pure\n        returns (uint)\n    {\n        return Poseidon.hash_t5f6p52(t0, t1, t2, t3, 0);\n    }\n}\n\nlibrary ExchangeData {\n    \n    enum BlockType\n    {\n        RING_SETTLEMENT,\n        DEPOSIT,\n        ONCHAIN_WITHDRAWAL,\n        OFFCHAIN_WITHDRAWAL,\n        ORDER_CANCELLATION,\n        TRANSFER\n    }\n\n    enum BlockState\n    {\n        \n        \n        NEW,            \n\n        \n        COMMITTED,      \n\n        \n        \n        VERIFIED        \n    }\n\n    \n    struct Account\n    {\n        address owner;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        uint    pubKeyX;\n        uint    pubKeyY;\n    }\n\n    struct Token\n    {\n        address token;\n        bool    depositDisabled;\n    }\n\n    struct ProtocolFeeData\n    {\n        uint32 timestamp;\n        uint8 takerFeeBips;\n        uint8 makerFeeBips;\n        uint8 previousTakerFeeBips;\n        uint8 previousMakerFeeBips;\n    }\n\n    \n    \n    struct Block\n    {\n        \n        \n        bytes32 merkleRoot;\n\n        \n        \n        \n        \n        \n        \n        bytes32 publicDataHash;\n\n        \n        BlockState state;\n\n        \n        \n        BlockType blockType;\n\n        \n        \n        \n        \n        uint16 blockSize;\n\n        \n        uint8  blockVersion;\n\n        \n        uint32 timestamp;\n\n        \n        \n        uint32 numDepositRequestsCommitted;\n\n        \n        \n        uint32 numWithdrawalRequestsCommitted;\n\n        \n        \n        bool   blockFeeWithdrawn;\n\n        \n        uint16 numWithdrawalsDistributed;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        bytes  withdrawals;\n    }\n\n    \n    \n    \n    struct Request\n    {\n        bytes32 accumulatedHash;\n        uint    accumulatedFee;\n        uint32  timestamp;\n    }\n\n    \n    struct Deposit\n    {\n        uint24 accountID;\n        uint16 tokenID;\n        uint96 amount;\n    }\n\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n        \n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    }\n\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 14 days; }\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 1000; }\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 21 days; }\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 14 days; }\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 30 days; }\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 1 seconds; }\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 14 days; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS_SHUTDOWN_MODE() internal pure returns (uint32) {\n        return MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() * 10;\n    }\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 6 hours; }\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 6 hours; }\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 150000; }\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 60000; }\n\n    \n    struct State\n    {\n        uint    id;\n        uint    exchangeCreationTimestamp;\n        address payable operator; \n        bool    onchainDataAvailability;\n\n        ILoopringV3    loopring;\n        IBlockVerifier blockVerifier;\n\n        address lrcAddress;\n\n        uint    totalTimeInMaintenanceSeconds;\n        uint    numDowntimeMinutes;\n        uint    downtimeStart;\n\n        address addressWhitelist;\n        uint    accountCreationFeeETH;\n        uint    accountUpdateFeeETH;\n        uint    depositFeeETH;\n        uint    withdrawalFeeETH;\n\n        Block[]     blocks;\n        Token[]     tokens;\n        Account[]   accounts;\n        Deposit[]   deposits;\n        Request[]   depositChain;\n        Request[]   withdrawalChain;\n\n        \n        mapping (address => uint24) ownerToAccountId;\n        mapping (address => uint16) tokenToTokenId;\n\n        \n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\n\n        \n        mapping (address => uint) tokenBalances;\n\n        \n        \n        \n        uint numBlocksFinalized;\n\n        \n        ProtocolFeeData protocolFeeData;\n\n        \n        uint shutdownStartTime;\n    }\n}\n\nlibrary ExchangeAccounts {\n    using MathUint          for uint;\n    using ExchangeBalances  for ExchangeData.State;\n\n    event AccountCreated(\n        address indexed owner,\n        uint24  indexed id,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    event AccountUpdated(\n        address indexed owner,\n        uint24  indexed id,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    \n    function getAccount(\n        ExchangeData.State storage S,\n        address owner\n        )\n        external\n        view\n        returns (\n            uint24 accountID,\n            uint   pubKeyX,\n            uint   pubKeyY\n        )\n    {\n        accountID = getAccountID(S, owner);\n        ExchangeData.Account storage account = S.accounts[accountID];\n        pubKeyX = account.pubKeyX;\n        pubKeyY = account.pubKeyY;\n    }\n\n    function createOrUpdateAccount(\n        ExchangeData.State storage S,\n        uint  pubKeyX,\n        uint  pubKeyY,\n        bytes calldata permission\n        )\n        external\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        )\n    {\n        isAccountNew = (S.ownerToAccountId[msg.sender] == 0);\n        if (isAccountNew) {\n            if (S.addressWhitelist != address(0)) {\n                require(\n                    IAddressWhitelist(S.addressWhitelist)\n                        .isAddressWhitelisted(msg.sender, permission),\n                    \"ADDRESS_NOT_WHITELISTED\"\n                );\n            }\n            accountID = createAccount(S, pubKeyX, pubKeyY);\n            isAccountUpdated = false;\n        } else {\n            (accountID, isAccountUpdated) = updateAccount(S, pubKeyX, pubKeyY);\n        }\n    }\n\n    function getAccountID(\n        ExchangeData.State storage S,\n        address owner\n        )\n        public\n        view\n        returns (uint24 accountID)\n    {\n        accountID = S.ownerToAccountId[owner];\n        require(accountID != 0, \"ADDRESS_HAS_NO_ACCOUNT\");\n\n        accountID = accountID - 1;\n    }\n\n    function createAccount(\n        ExchangeData.State storage S,\n        uint pubKeyX,\n        uint pubKeyY\n        )\n        private\n        returns (uint24 accountID)\n    {\n        require(S.accounts.length < ExchangeData.MAX_NUM_ACCOUNTS(), \"ACCOUNTS_FULL\");\n        require(S.ownerToAccountId[msg.sender] == 0, \"ACCOUNT_EXISTS\");\n\n        accountID = uint24(S.accounts.length);\n        ExchangeData.Account memory account = ExchangeData.Account(\n            msg.sender,\n            pubKeyX,\n            pubKeyY\n        );\n\n        S.accounts.push(account);\n        S.ownerToAccountId[msg.sender] = accountID + 1;\n\n        emit AccountCreated(\n            msg.sender,\n            accountID,\n            pubKeyX,\n            pubKeyY\n        );\n    }\n\n    function updateAccount(\n        ExchangeData.State storage S,\n        uint pubKeyX,\n        uint pubKeyY\n        )\n        private\n        returns (\n            uint24 accountID,\n            bool   isAccountUpdated\n        )\n    {\n        require(S.ownerToAccountId[msg.sender] != 0, \"ACCOUNT_NOT_EXIST\");\n\n        accountID = S.ownerToAccountId[msg.sender] - 1;\n        ExchangeData.Account storage account = S.accounts[accountID];\n\n        isAccountUpdated = (account.pubKeyX != pubKeyX || account.pubKeyY != pubKeyY);\n        if (isAccountUpdated) {\n            account.pubKeyX = pubKeyX;\n            account.pubKeyY = pubKeyY;\n\n            emit AccountUpdated(\n                msg.sender,\n                accountID,\n                pubKeyX,\n                pubKeyY\n            );\n        }\n    }\n}\n\ncontract ERC20 {\n    function totalSupply()\n        public\n        view\n        returns (uint);\n\n    function balanceOf(\n        address who\n        )\n        public\n        view\n        returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n        )\n        public\n        view\n        returns (uint);\n\n    function transfer(\n        address to,\n        uint value\n        )\n        public\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint    value\n        )\n        public\n        returns (bool);\n\n    function approve(\n        address spender,\n        uint    value\n        )\n        public\n        returns (bool);\n}\n\ncontract BurnableERC20 is ERC20\n{\n    function burn(\n        uint value\n        )\n        public\n        returns (bool);\n\n    function burnFrom(\n        address from,\n        uint value\n        )\n        public\n        returns (bool);\n}\n\nlibrary ERC20SafeTransfer {\n    function safeTransferAndVerify(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferWithGasLimitAndVerify(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferWithGasLimit(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferWithGasLimitAndVerify(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        require(\n            safeTransferWithGasLimit(token, to, value, gasLimit),\n            \"TRANSFER_FAILURE\"\n        );\n    }\n\n    function safeTransferWithGasLimit(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0xa9059cbb),\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function safeTransferFromAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferFromWithGasLimitAndVerify(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFromWithGasLimitAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        bool result = safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasLimit\n        );\n        require(result, \"TRANSFER_FAILURE\");\n    }\n\n    function safeTransferFromWithGasLimit(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0x23b872dd),\n            from,\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function checkReturnValue(\n        bool success\n        )\n        internal\n        pure\n        returns (bool)\n    {\n        \n        \n        \n        if (success) {\n            assembly {\n                switch returndatasize()\n                \n                case 0 {\n                    success := 1\n                }\n                \n                case 32 {\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                \n                default {\n                    success := 0\n                }\n            }\n        }\n        return success;\n    }\n}\n\nlibrary ExchangeMode {\n    using MathUint  for uint;\n\n    function isInWithdrawalMode(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool result)\n    {\n        result = false;\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\n\n        \n        if (currentBlock.numDepositRequestsCommitted < S.depositChain.length) {\n            uint32 requestTimestamp = S.depositChain[currentBlock.numDepositRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false && currentBlock.numWithdrawalRequestsCommitted < S.withdrawalChain.length) {\n            uint32 requestTimestamp = S.withdrawalChain[currentBlock.numWithdrawalRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false) {\n            result = isAnyUnfinalizedBlockTooOld(S);\n        }\n\n        \n        if (result == false && isShutdown(S) && !isInInitialState(S)) {\n            \n            \n            uint maxTimeInShutdown = ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE();\n            maxTimeInShutdown = maxTimeInShutdown.add(S.accounts.length.mul(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()));\n            result = now > S.shutdownStartTime.add(maxTimeInShutdown);\n        }\n    }\n\n    function isShutdown(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.shutdownStartTime > 0;\n    }\n\n    function isInMaintenance(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.downtimeStart != 0 && getNumDowntimeMinutesLeft(S) > 0;\n    }\n\n    function isInInitialState(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        ExchangeData.Block storage firstBlock = S.blocks[0];\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\n        return (S.blocks.length == S.numBlocksFinalized) &&\n            (lastBlock.numDepositRequestsCommitted == S.depositChain.length) &&\n            (lastBlock.merkleRoot == firstBlock.merkleRoot);\n    }\n\n    function areUserRequestsEnabled(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        \n        \n        return !isInMaintenance(S) && !isShutdown(S) && !isInWithdrawalMode(S);\n    }\n\n    function isAnyUnfinalizedBlockTooOld(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        if (S.numBlocksFinalized < S.blocks.length) {\n            uint32 blockTimestamp = S.blocks[S.numBlocksFinalized].timestamp;\n            return blockTimestamp < now.sub(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE());\n        } else {\n            return false;\n        }\n    }\n\n    function getNumDowntimeMinutesLeft(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (uint)\n    {\n        if (S.downtimeStart == 0) {\n            return S.numDowntimeMinutes;\n        } else {\n            \n            uint numDowntimeMinutesUsed = now.sub(S.downtimeStart) / 60;\n            if (S.numDowntimeMinutes > numDowntimeMinutesUsed) {\n                return S.numDowntimeMinutes.sub(numDowntimeMinutesUsed);\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\nlibrary ExchangeTokens {\n    using MathUint          for uint;\n    using ExchangeMode      for ExchangeData.State;\n\n    event TokenRegistered(\n        address indexed token,\n        uint16  indexed tokenId\n    );\n\n    function registerToken(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n        returns (uint16 tokenID)\n    {\n        tokenID = registerToken(\n            S,\n            tokenAddress,\n            getLRCFeeForRegisteringOneMoreToken(S)\n        );\n    }\n\n    function getTokenAddress(\n        ExchangeData.State storage S,\n        uint16 tokenID\n        )\n        external\n        view\n        returns (address)\n    {\n        require(tokenID < S.tokens.length, \"INVALID_TOKEN_ID\");\n        return S.tokens[tokenID].token;\n    }\n\n    function getLRCFeeForRegisteringOneMoreToken(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint feeLRC)\n    {\n        return S.loopring.tokenRegistrationFeeLRCBase().add(\n            S.loopring.tokenRegistrationFeeLRCDelta().mul(S.tokens.length)\n        );\n    }\n\n    function registerToken(\n        ExchangeData.State storage S,\n        address tokenAddress,\n        uint    amountToBurn\n        )\n        public\n        returns (uint16 tokenID)\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(S.tokenToTokenId[tokenAddress] == 0, \"TOKEN_ALREADY_EXIST\");\n        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), \"TOKEN_REGISTRY_FULL\");\n\n        if (amountToBurn > 0) {\n            require(BurnableERC20(S.lrcAddress).burnFrom(msg.sender, amountToBurn), \"BURN_FAILURE\");\n        }\n\n        ExchangeData.Token memory token = ExchangeData.Token(tokenAddress, false);\n        S.tokens.push(token);\n        tokenID = uint16(S.tokens.length - 1);\n        S.tokenToTokenId[tokenAddress] = tokenID + 1;\n\n        emit TokenRegistered(tokenAddress, tokenID);\n    }\n\n    function getTokenID(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        public\n        view\n        returns (uint16 tokenID)\n    {\n        tokenID = S.tokenToTokenId[tokenAddress];\n        require(tokenID != 0, \"TOKEN_NOT_FOUND\");\n        tokenID = tokenID - 1;\n    }\n\n    function disableTokenDeposit(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        require(tokenAddress != address(0), \"ETHER_CANNOT_BE_DISABLED\");\n        require(tokenAddress != S.loopring.wethAddress(), \"WETH_CANNOT_BE_DISABLED\");\n        require(tokenAddress != S.loopring.lrcAddress(), \"LRC_CANNOT_BE_DISABLED\");\n\n        uint16 tokenID = getTokenID(S, tokenAddress);\n        ExchangeData.Token storage token = S.tokens[tokenID];\n        require(!token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_DISABLED\");\n        token.depositDisabled = true;\n    }\n\n    function enableTokenDeposit(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        uint16 tokenID = getTokenID(S, tokenAddress);\n        ExchangeData.Token storage token = S.tokens[tokenID];\n        require(token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_ENABLED\");\n        token.depositDisabled = false;\n    }\n}\n\nlibrary ExchangeGenesis {\n    using ExchangeAccounts  for ExchangeData.State;\n    using ExchangeTokens    for ExchangeData.State;\n\n    function initializeGenesisBlock(\n        ExchangeData.State storage S,\n        uint    _id,\n        address _loopringAddress,\n        address payable _operator,\n        bool    _onchainDataAvailability,\n        bytes32 _genesisBlockHash\n        )\n        external\n    {\n        require(0 != _id, \"INVALID_ID\");\n        require(address(0) != _loopringAddress, \"ZERO_ADDRESS\");\n        require(address(0) != _operator, \"ZERO_ADDRESS\");\n        require(_genesisBlockHash != 0, \"ZERO_GENESIS_BLOCK_HASH\");\n        require(S.id == 0, \"INITIALIZED_ALREADY\");\n\n        S.id = _id;\n        S.exchangeCreationTimestamp = now;\n        S.loopring = ILoopringV3(_loopringAddress);\n        S.operator = _operator;\n        S.onchainDataAvailability = _onchainDataAvailability;\n\n        ILoopringV3 loopring = ILoopringV3(_loopringAddress);\n        S.blockVerifier = IBlockVerifier(loopring.blockVerifierAddress());\n        S.lrcAddress = loopring.lrcAddress();\n\n        ExchangeData.Block memory genesisBlock = ExchangeData.Block(\n            _genesisBlockHash,\n            0x0,\n            ExchangeData.BlockState.VERIFIED,\n            ExchangeData.BlockType(0),\n            0,\n            0,\n            uint32(now),\n            1,\n            1,\n            true,\n            0,\n            new bytes(0)\n        );\n        S.blocks.push(genesisBlock);\n        S.numBlocksFinalized = 1;\n\n        ExchangeData.Request memory genesisRequest = ExchangeData.Request(\n            0,\n            0,\n            0xFFFFFFFF\n        );\n        S.depositChain.push(genesisRequest);\n        S.withdrawalChain.push(genesisRequest);\n\n        \n        \n        ExchangeData.Account memory protocolFeePoolAccount = ExchangeData.Account(\n            address(0),\n            uint(0),\n            uint(0)\n        );\n\n        S.accounts.push(protocolFeePoolAccount);\n        S.ownerToAccountId[protocolFeePoolAccount.owner] = uint24(S.accounts.length);\n\n        \n        S.protocolFeeData.timestamp = uint32(0);\n        S.protocolFeeData.takerFeeBips = S.loopring.maxProtocolTakerFeeBips();\n        S.protocolFeeData.makerFeeBips = S.loopring.maxProtocolMakerFeeBips();\n        S.protocolFeeData.previousTakerFeeBips = S.protocolFeeData.takerFeeBips;\n        S.protocolFeeData.previousMakerFeeBips = S.protocolFeeData.makerFeeBips;\n\n        \n        S.registerToken(address(0), 0);\n        S.registerToken(loopring.wethAddress(), 0);\n        S.registerToken(S.lrcAddress, 0);\n    }\n}","ABI":"[]","ContractName":"ExchangeGenesis","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"ExchangeTokens:a3ac9be46eb0f39b772908b5a5b16eae188fc765","LicenseType":"","SwarmSource":"bzzr://50d12206a7864f58c3b71d3e737ebd97f10a0c5c9d8a004f1d09ab14cb5757b2"}]}