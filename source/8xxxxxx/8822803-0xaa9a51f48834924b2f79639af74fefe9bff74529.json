{"status":"1","message":"OK","result":[{"SourceCode":"// GoToken is an open community aims to explore a decentralized collaboration network incentived and well-governed through blockchain. Learn more about gotoken @ forum.gotoken.io\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract TrustListInterface{\r\n  function is_trusted(address addr) public returns(bool);\r\n}\r\ncontract TrustListTools{\r\n  TrustListInterface public list;\r\n  constructor(address _list) public {\r\n    require(_list != address(0x0));\r\n    list = TrustListInterface(_list);\r\n  }\r\n\r\n  modifier is_trusted(address addr){\r\n    require(list.is_trusted(addr), \"not a trusted issuer\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract GTTokenInterface is TransferableToken{\r\n    function destroyTokens(address _owner, uint _amount) public returns (bool);\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n}\r\n\r\n\r\ncontract FundAndDistribute is TokenClaimer, MultiSigTools, TrustListTools{\r\n  using SafeMath for uint;\r\n\r\n  string public name;\r\n  string public desc;\r\n  address public token_contract;\r\n  uint public tokens_per_k_gt;\r\n  uint public exchange_ratio; //actual is 10/exchange_ratio\r\n  GTTokenInterface public gt_token;\r\n  bool public paused;\r\n\r\n  event Fund(address addr, address token, uint cost_amount, uint remain, uint got_amount);\r\n  event Exchange(address addr, address token, uint cost_amout, uint remain, uint got_amount);\r\n\r\n  constructor(address _gt_token,\r\n              string memory _name,\r\n              string memory _desc,\r\n              address _token_contract,\r\n              address _multisig,\r\n              address _tlist)  public MultiSigTools(_multisig) TrustListTools(_tlist){\r\n    gt_token = GTTokenInterface(_gt_token);\r\n    name = _name;\r\n    desc = _desc;\r\n    token_contract = _token_contract;\r\n    tokens_per_k_gt = 1000;\r\n    exchange_ratio = 20; //1/2\r\n    paused = false;\r\n  }\r\n\r\n  function balance() public returns(uint){\r\n      TransferableToken token = TransferableToken(address(gt_token));\r\n      return token.balanceOf(address(this));\r\n  }\r\n  function transfer(uint64 id, address to, uint amount)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \"transfer\")\r\n  returns (bool success){\r\n      TransferableToken token = TransferableToken(address(gt_token));\r\n      token.transfer(to, amount);\r\n      return true;\r\n  }\r\n\r\n    function claimStdTokens(uint64 id, address _token, address payable to) public only_signer is_majority_sig(id, \"claimStdTokens\"){\r\n      _claimStdTokens(_token, to);\r\n    }\r\n  modifier when_paused(){\r\n    require(paused == true, \"require paused\");\r\n    _;\r\n  }\r\n  modifier when_not_paused(){\r\n    require(paused == false, \"require not paused\");\r\n    _;\r\n  }\r\n\r\n    function pause(uint64 id) public only_signer is_majority_sig(id, \"pause\"){\r\n      paused = true;\r\n    }\r\n    function unpause(uint64 id) public only_signer is_majority_sig(id, \"unpause\"){\r\n      paused = false;\r\n    }\r\n\r\n    function set_param(uint64 id, uint _tokens_per_k_gt, uint _exchange_ratio) public only_signer is_majority_sig(id, \"set_param\"){\r\n      require(_tokens_per_k_gt > 0);\r\n      require(_exchange_ratio > 0);\r\n      tokens_per_k_gt = _tokens_per_k_gt;\r\n      exchange_ratio = _exchange_ratio;\r\n    }\r\n\r\n    /* @_amount: in token_contract unit, like USDT\r\n     */\r\n    function _fund(uint _amount) internal returns(uint remain){\r\n      uint v = SafeMath.safeDiv(_amount, tokens_per_k_gt);\r\n      uint cost = SafeMath.safeMul(v, tokens_per_k_gt);\r\n      remain = SafeMath.safeSub(_amount, cost);\r\n      v = SafeMath.safeMul(v, 1000);\r\n      gt_token.generateTokens(msg.sender, v);\r\n      gt_token.generateTokens(address(this), v);\r\n      emit Fund(msg.sender, token_contract, cost, remain, v);\r\n    }\r\n\r\n    /* @_amount: in GTToken unit\r\n     * @remain_token: in token_contract unit, like USDT\r\n     */\r\n    function _exchange(uint _amount) internal returns(uint remain_token){\r\n      require(_amount > 0, \"fund should be > 0\");\r\n      GTTokenInterface token = GTTokenInterface(address(gt_token));\r\n      uint old_balance = token.balanceOf(msg.sender);\r\n      require(old_balance >= _amount, \"not enough amout\");\r\n\r\n      uint k_gts = SafeMath.safeDiv(_amount, 1000);\r\n      uint cost = SafeMath.safeMul(k_gts, 1000);\r\n      uint r = SafeMath.safeSub(_amount, cost);\r\n      uint burn = SafeMath.safeSub(_amount, r);\r\n      if(burn > 0){\r\n        token.destroyTokens(msg.sender, burn);\r\n      }\r\n      remain_token = SafeMath.safeMul(k_gts, tokens_per_k_gt);\r\n      remain_token = SafeMath.safeDiv(SafeMath.safeMul(remain_token, 10), exchange_ratio);\r\n      emit Exchange(msg.sender, token_contract,cost, r, remain_token);\r\n    }\r\n\r\n  function fund(uint amount) public when_not_paused is_trusted(msg.sender) returns (bool){\r\n    require(amount > 0, \"fund should be > 0\");\r\n    TransferableToken token = TransferableToken(token_contract);\r\n    uint old_balance = token.balanceOf(address(this));\r\n    (bool ret, ) = token_contract.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), amount));\r\n    require(ret, \"FundAndDistribute:fund, transferFrom return false\");\r\n    uint new_balance = token.balanceOf(address(this));\r\n    require(new_balance == old_balance + amount, \"StdFundAndDistribute:fund, invalid transfer\");\r\n    uint remain = _fund(amount);\r\n    if(remain > 0){\r\n      token.transfer(msg.sender, remain);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function exchange(uint amount) public when_not_paused returns(bool){\r\n    uint ret_token_amount = _exchange(amount);\r\n    if(ret_token_amount > 0){\r\n      (bool ret, ) = token_contract.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, ret_token_amount));\r\n      require(ret, \"FundAndDistribute:fund, transferFrom return false\");\r\n    }\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimStdTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"list\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transfer_multisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange_ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokens_per_k_gt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_tokens_per_k_gt\",\"type\":\"uint256\"},{\"name\":\"_exchange_ratio\",\"type\":\"uint256\"}],\"name\":\"set_param\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"desc\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"}],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gt_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_gt_token\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_desc\",\"type\":\"string\"},{\"name\":\"_token_contract\",\"type\":\"address\"},{\"name\":\"_multisig\",\"type\":\"address\"},{\"name\":\"_tlist\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cost_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remain\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"got_amount\",\"type\":\"uint256\"}],\"name\":\"Fund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cost_amout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remain\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"got_amount\",\"type\":\"uint256\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"TransferMultiSig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"}]","ContractName":"FundAndDistribute","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000353214343ee192ad8a58c62961b972f4d5a6877e00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000009fdb24df185b4e6c42846c2f1355ca0a2bb7e043000000000000000000000000735451974a28f63b0593cce91696659c1b900380000000000000000000000000000000000000000000000000000000000000000c5553445420666f7220474f4f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104f6e6c7920666f722046756e6465727300000000000000000000000000000000","Library":"SafeMath:a37426cdca2be3d52c950d5ca1ffac842b89b06a","LicenseType":"MIT","SwarmSource":"bzzr://5ab24957c07000d5e12b1058e51f18997dfd5275818b5dfb9ff466fa3a7141ce"}]}