{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract Modifiable {\r\n    \r\n    \r\n    \r\n    modifier notNullAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier notThisAddress(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notNullOrThisAddress(address _address) {\r\n        require(_address != address(0));\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notSameAddresses(address _address1, address _address2) {\r\n        if (_address1 != _address2)\r\n            _;\r\n    }\r\n}\r\n\r\ncontract SelfDestructible {\r\n    \r\n    \r\n    \r\n    bool public selfDestructionDisabled;\r\n\r\n    \r\n    \r\n    \r\n    event SelfDestructionDisabledEvent(address wallet);\r\n    event TriggerSelfDestructionEvent(address wallet);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address);\r\n\r\n    \r\n    \r\n    function disableSelfDestruction()\r\n    public\r\n    {\r\n        \r\n        require(destructor() == msg.sender);\r\n\r\n        \r\n        selfDestructionDisabled = true;\r\n\r\n        \r\n        emit SelfDestructionDisabledEvent(msg.sender);\r\n    }\r\n\r\n    \r\n    function triggerSelfDestruction()\r\n    public\r\n    {\r\n        \r\n        require(destructor() == msg.sender);\r\n\r\n        \r\n        require(!selfDestructionDisabled);\r\n\r\n        \r\n        emit TriggerSelfDestructionEvent(msg.sender);\r\n\r\n        \r\n        selfdestruct(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable is Modifiable, SelfDestructible {\r\n    \r\n    \r\n    \r\n    address public deployer;\r\n    address public operator;\r\n\r\n    \r\n    \r\n    \r\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\r\n    event SetOperatorEvent(address oldOperator, address newOperator);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\r\n        deployer = _deployer;\r\n        operator = _deployer;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return deployer;\r\n    }\r\n\r\n    \r\n    \r\n    function setDeployer(address newDeployer)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(newDeployer)\r\n    {\r\n        if (newDeployer != deployer) {\r\n            \r\n            address oldDeployer = deployer;\r\n            deployer = newDeployer;\r\n\r\n            \r\n            emit SetDeployerEvent(oldDeployer, newDeployer);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function setOperator(address newOperator)\r\n    public\r\n    onlyOperator\r\n    notNullOrThisAddress(newOperator)\r\n    {\r\n        if (newOperator != operator) {\r\n            \r\n            address oldOperator = operator;\r\n            operator = newOperator;\r\n\r\n            \r\n            emit SetOperatorEvent(oldOperator, newOperator);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function isDeployer()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == deployer;\r\n    }\r\n\r\n    \r\n    \r\n    function isOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == operator;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isDeployerOrOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isDeployer() || isOperator();\r\n    }\r\n\r\n    \r\n    \r\n    modifier onlyDeployer() {\r\n        require(isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployer() {\r\n        require(!isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notOperator() {\r\n        require(!isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeployerOrOperator() {\r\n        require(isDeployerOrOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployerOrOperator() {\r\n        require(!isDeployerOrOperator());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Servable is Ownable {\r\n    \r\n    \r\n    \r\n    struct ServiceInfo {\r\n        bool registered;\r\n        uint256 activationTimestamp;\r\n        mapping(bytes32 => bool) actionsEnabledMap;\r\n        bytes32[] actionsList;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    mapping(address => ServiceInfo) internal registeredServicesMap;\r\n    uint256 public serviceActivationTimeout;\r\n\r\n    \r\n    \r\n    \r\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\r\n    event RegisterServiceEvent(address service);\r\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\r\n    event DeregisterServiceEvent(address service);\r\n    event EnableServiceActionEvent(address service, string action);\r\n    event DisableServiceActionEvent(address service, string action);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\r\n    public\r\n    onlyDeployer\r\n    {\r\n        serviceActivationTimeout = timeoutInSeconds;\r\n\r\n        \r\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function registerService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, 0);\r\n\r\n        \r\n        emit RegisterServiceEvent(service);\r\n    }\r\n\r\n    \r\n    \r\n    function registerServiceDeferred(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, serviceActivationTimeout);\r\n\r\n        \r\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\r\n    }\r\n\r\n    \r\n    \r\n    function deregisterService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        registeredServicesMap[service].registered = false;\r\n\r\n        \r\n        emit DeregisterServiceEvent(service);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function enableServiceAction(address service, string memory action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\r\n        registeredServicesMap[service].actionsList.push(actionHash);\r\n\r\n        \r\n        emit EnableServiceActionEvent(service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function disableServiceAction(address service, string memory action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\r\n\r\n        \r\n        emit DisableServiceActionEvent(service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return registeredServicesMap[service].registered;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredActiveService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isEnabledServiceAction(address service, string memory action)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function hashString(string memory _string)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _registerService(address service, uint256 timeout)\r\n    private\r\n    {\r\n        if (!registeredServicesMap[service].registered) {\r\n            registeredServicesMap[service].registered = true;\r\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyActiveService() {\r\n        require(isRegisteredActiveService(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyEnabledServiceAction(string memory action) {\r\n        require(isEnabledServiceAction(msg.sender, action));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CommunityVote is Ownable {\r\n    \r\n    \r\n    \r\n    mapping(address => bool) doubleSpenderByWallet;\r\n    uint256 maxDriipNonce;\r\n    uint256 maxNullNonce;\r\n    bool dataAvailable;\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n        dataAvailable = true;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isDoubleSpenderWallet(address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return doubleSpenderByWallet[wallet];\r\n    }\r\n\r\n    \r\n    \r\n    function getMaxDriipNonce()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return maxDriipNonce;\r\n    }\r\n\r\n    \r\n    \r\n    function getMaxNullNonce()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return maxNullNonce;\r\n    }\r\n\r\n    \r\n    \r\n    function isDataAvailable()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return dataAvailable;\r\n    }\r\n}\r\n\r\ncontract CommunityVotable is Ownable {\r\n    \r\n    \r\n    \r\n    CommunityVote public communityVote;\r\n    bool public communityVoteFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetCommunityVoteEvent(CommunityVote oldCommunityVote, CommunityVote newCommunityVote);\r\n    event FreezeCommunityVoteEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setCommunityVote(CommunityVote newCommunityVote) \r\n    public \r\n    onlyDeployer\r\n    notNullAddress(address(newCommunityVote))\r\n    notSameAddresses(address(newCommunityVote), address(communityVote))\r\n    {\r\n        require(!communityVoteFrozen, \"Community vote frozen [CommunityVotable.sol:41]\");\r\n\r\n        \r\n        CommunityVote oldCommunityVote = communityVote;\r\n        communityVote = newCommunityVote;\r\n\r\n        \r\n        emit SetCommunityVoteEvent(oldCommunityVote, newCommunityVote);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeCommunityVote()\r\n    public\r\n    onlyDeployer\r\n    {\r\n        communityVoteFrozen = true;\r\n\r\n        \r\n        emit FreezeCommunityVoteEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier communityVoteInitialized() {\r\n        require(address(communityVote) != address(0), \"Community vote not initialized [CommunityVotable.sol:67]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Upgradable {\r\n    \r\n    \r\n    \r\n    address public upgradeAgent;\r\n    bool public upgradesFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetUpgradeAgentEvent(address upgradeAgent);\r\n    event FreezeUpgradesEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setUpgradeAgent(address _upgradeAgent)\r\n    public\r\n    onlyWhenUpgradable\r\n    {\r\n        require(address(0) == upgradeAgent, \"Upgrade agent has already been set [Upgradable.sol:37]\");\r\n\r\n        \r\n        upgradeAgent = _upgradeAgent;\r\n\r\n        \r\n        emit SetUpgradeAgentEvent(upgradeAgent);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeUpgrades()\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        upgradesFrozen = true;\r\n\r\n        \r\n        emit FreezeUpgradesEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyWhenUpgrading() {\r\n        require(msg.sender == upgradeAgent, \"Caller is not upgrade agent [Upgradable.sol:63]\");\r\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:64]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenUpgradable() {\r\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:69]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Beneficiary {\r\n    \r\n    \r\n    \r\n    function receiveEthersTo(address wallet, string memory balanceType)\r\n    public\r\n    payable;\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public;\r\n}\r\n\r\nlibrary MonetaryTypesLib {\r\n    \r\n    \r\n    \r\n    struct Currency {\r\n        address ct;\r\n        uint256 id;\r\n    }\r\n\r\n    struct Figure {\r\n        int256 amount;\r\n        Currency currency;\r\n    }\r\n\r\n    struct NoncedAmount {\r\n        uint256 nonce;\r\n        int256 amount;\r\n    }\r\n}\r\n\r\ncontract AccrualBeneficiary is Beneficiary {\r\n    \r\n    \r\n    \r\n    event CloseAccrualPeriodEvent();\r\n\r\n    \r\n    \r\n    \r\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\r\n    public\r\n    {\r\n        emit CloseAccrualPeriodEvent();\r\n    }\r\n}\r\n\r\ncontract Benefactor is Ownable {\r\n    \r\n    \r\n    \r\n    Beneficiary[] public beneficiaries;\r\n    mapping(address => uint256) public beneficiaryIndexByAddress;\r\n\r\n    \r\n    \r\n    \r\n    event RegisterBeneficiaryEvent(Beneficiary beneficiary);\r\n    event DeregisterBeneficiaryEvent(Beneficiary beneficiary);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function registerBeneficiary(Beneficiary beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(beneficiary))\r\n    returns (bool)\r\n    {\r\n        address _beneficiary = address(beneficiary);\r\n\r\n        if (beneficiaryIndexByAddress[_beneficiary] > 0)\r\n            return false;\r\n\r\n        beneficiaries.push(beneficiary);\r\n        beneficiaryIndexByAddress[_beneficiary] = beneficiaries.length;\r\n\r\n        \r\n        emit RegisterBeneficiaryEvent(beneficiary);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    \r\n    function deregisterBeneficiary(Beneficiary beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(beneficiary))\r\n    returns (bool)\r\n    {\r\n        address _beneficiary = address(beneficiary);\r\n\r\n        if (beneficiaryIndexByAddress[_beneficiary] == 0)\r\n            return false;\r\n\r\n        uint256 idx = beneficiaryIndexByAddress[_beneficiary] - 1;\r\n        if (idx < beneficiaries.length - 1) {\r\n            \r\n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\r\n            beneficiaryIndexByAddress[address(beneficiaries[idx])] = idx + 1;\r\n        }\r\n        beneficiaries.length--;\r\n        beneficiaryIndexByAddress[_beneficiary] = 0;\r\n\r\n        \r\n        emit DeregisterBeneficiaryEvent(beneficiary);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredBeneficiary(Beneficiary beneficiary)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return beneficiaryIndexByAddress[address(beneficiary)] > 0;\r\n    }\r\n\r\n    \r\n    \r\n    function registeredBeneficiariesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return beneficiaries.length;\r\n    }\r\n}\r\n\r\nlibrary SafeMathIntLib {\r\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\r\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\r\n\r\n    \r\n    \r\n    \r\n    function div(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    function mul(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != - 1 || b != INT256_MIN);\r\n        \r\n        require(b != - 1 || a != INT256_MIN);\r\n        \r\n        int256 c = a * b;\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function sub(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\r\n        return a - b;\r\n    }\r\n\r\n    function add(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function div_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b > 0);\r\n        return a / b;\r\n    }\r\n\r\n    function mul_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        require(c >= 0);\r\n        return c;\r\n    }\r\n\r\n    function sub_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0 && b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function abs(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return a < 0 ? neg(a) : a;\r\n    }\r\n\r\n    function neg(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return mul(a, - 1);\r\n    }\r\n\r\n    function toNonZeroInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a > 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toUInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n\r\n    function isNonZeroPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a > 0);\r\n    }\r\n\r\n    function isPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a >= 0);\r\n    }\r\n\r\n    function isNonZeroNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a < 0);\r\n    }\r\n\r\n    function isNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a <= 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function clamp(int256 a, int256 min, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        if (a < min)\r\n            return min;\r\n        return (a > max) ? max : a;\r\n    }\r\n\r\n    function clampMin(int256 a, int256 min)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(int256 a, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary ConstantsLib {\r\n    \r\n    function PARTS_PER()\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return 1e18;\r\n    }\r\n}\r\n\r\ncontract AccrualBenefactor is Benefactor {\r\n    using SafeMathIntLib for int256;\r\n\r\n    \r\n    \r\n    \r\n    mapping(address => int256) private _beneficiaryFractionMap;\r\n    int256 public totalBeneficiaryFraction;\r\n\r\n    \r\n    \r\n    \r\n    event RegisterAccrualBeneficiaryEvent(Beneficiary beneficiary, int256 fraction);\r\n    event DeregisterAccrualBeneficiaryEvent(Beneficiary beneficiary);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function registerBeneficiary(Beneficiary beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(beneficiary))\r\n    returns (bool)\r\n    {\r\n        return registerFractionalBeneficiary(AccrualBeneficiary(address(beneficiary)), ConstantsLib.PARTS_PER());\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function registerFractionalBeneficiary(AccrualBeneficiary beneficiary, int256 fraction)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(beneficiary))\r\n    returns (bool)\r\n    {\r\n        require(fraction > 0, \"Fraction not strictly positive [AccrualBenefactor.sol:59]\");\r\n        require(\r\n            totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER(),\r\n            \"Total beneficiary fraction out of bounds [AccrualBenefactor.sol:60]\"\r\n        );\r\n\r\n        if (!super.registerBeneficiary(beneficiary))\r\n            return false;\r\n\r\n        _beneficiaryFractionMap[address(beneficiary)] = fraction;\r\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\r\n\r\n        \r\n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    \r\n    function deregisterBeneficiary(Beneficiary beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(beneficiary))\r\n    returns (bool)\r\n    {\r\n        if (!super.deregisterBeneficiary(beneficiary))\r\n            return false;\r\n\r\n        address _beneficiary = address(beneficiary);\r\n\r\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[_beneficiary]);\r\n        _beneficiaryFractionMap[_beneficiary] = 0;\r\n\r\n        \r\n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function beneficiaryFraction(AccrualBeneficiary beneficiary)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return _beneficiaryFractionMap[address(beneficiary)];\r\n    }\r\n}\r\n\r\ncontract TransferController {\r\n    \r\n    \r\n    \r\n    event CurrencyTransferred(address from, address to, uint256 value,\r\n        address currencyCt, uint256 currencyId);\r\n\r\n    \r\n    \r\n    \r\n    function isFungible()\r\n    public\r\n    view\r\n    returns (bool);\r\n\r\n    function standard()\r\n    public\r\n    view\r\n    returns (string memory);\r\n\r\n    \r\n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    \r\n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    \r\n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    \r\n\r\n    function getReceiveSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\r\n    }\r\n\r\n    function getApproveSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\r\n    }\r\n\r\n    function getDispatchSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\r\n    }\r\n}\r\n\r\ncontract TransferControllerManager is Ownable {\r\n    \r\n    \r\n    \r\n    struct CurrencyInfo {\r\n        bytes32 standard;\r\n        bool blacklisted;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    mapping(bytes32 => address) public registeredTransferControllers;\r\n    mapping(address => CurrencyInfo) public registeredCurrencies;\r\n\r\n    \r\n    \r\n    \r\n    event RegisterTransferControllerEvent(string standard, address controller);\r\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\r\n\r\n    event RegisterCurrencyEvent(address currencyCt, string standard);\r\n    event DeregisterCurrencyEvent(address currencyCt);\r\n    event BlacklistCurrencyEvent(address currencyCt);\r\n    event WhitelistCurrencyEvent(address currencyCt);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function registerTransferController(string calldata standard, address controller)\r\n    external\r\n    onlyDeployer\r\n    notNullAddress(controller)\r\n    {\r\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\r\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n        registeredTransferControllers[standardHash] = controller;\r\n\r\n        \r\n        emit RegisterTransferControllerEvent(standard, controller);\r\n    }\r\n\r\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\r\n    external\r\n    onlyDeployer\r\n    notNullAddress(controller)\r\n    {\r\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\r\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\r\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\r\n\r\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\r\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\r\n\r\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\r\n        registeredTransferControllers[oldStandardHash] = address(0);\r\n\r\n        \r\n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\r\n    }\r\n\r\n    function registerCurrency(address currencyCt, string calldata standard)\r\n    external\r\n    onlyOperator\r\n    notNullAddress(currencyCt)\r\n    {\r\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\r\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\r\n\r\n        registeredCurrencies[currencyCt].standard = standardHash;\r\n\r\n        \r\n        emit RegisterCurrencyEvent(currencyCt, standard);\r\n    }\r\n\r\n    function deregisterCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\r\n\r\n        registeredCurrencies[currencyCt].standard = bytes32(0);\r\n        registeredCurrencies[currencyCt].blacklisted = false;\r\n\r\n        \r\n        emit DeregisterCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    function blacklistCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\r\n\r\n        registeredCurrencies[currencyCt].blacklisted = true;\r\n\r\n        \r\n        emit BlacklistCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    function whitelistCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\r\n\r\n        registeredCurrencies[currencyCt].blacklisted = false;\r\n\r\n        \r\n        emit WhitelistCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    \r\n    function transferController(address currencyCt, string memory standard)\r\n    public\r\n    view\r\n    returns (TransferController)\r\n    {\r\n        if (bytes(standard).length > 0) {\r\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\r\n            return TransferController(registeredTransferControllers[standardHash]);\r\n        }\r\n\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\r\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\r\n\r\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\r\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\r\n\r\n        return TransferController(controllerAddress);\r\n    }\r\n}\r\n\r\ncontract TransferControllerManageable is Ownable {\r\n    \r\n    \r\n    \r\n    TransferControllerManager public transferControllerManager;\r\n\r\n    \r\n    \r\n    \r\n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\r\n        TransferControllerManager newTransferControllerManager);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newTransferControllerManager))\r\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\r\n    {\r\n        \r\n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\r\n        transferControllerManager = newTransferControllerManager;\r\n\r\n        \r\n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\r\n    }\r\n\r\n    \r\n    function transferController(address currencyCt, string memory standard)\r\n    internal\r\n    view\r\n    returns (TransferController)\r\n    {\r\n        return transferControllerManager.transferController(currencyCt, standard);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier transferControllerManagerInitialized() {\r\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SafeMathUintLib {\r\n    function mul(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        \r\n        uint256 c = a / b;\r\n        \r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function clamp(uint256 a, uint256 min, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : ((a < min) ? min : a);\r\n    }\r\n\r\n    function clampMin(uint256 a, uint256 min)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(uint256 a, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary CurrenciesLib {\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    struct Currencies {\r\n        MonetaryTypesLib.Currency[] currencies;\r\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        \r\n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\r\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\r\n        }\r\n    }\r\n\r\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        \r\n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\r\n        if (0 < index)\r\n            removeByIndex(self, index - 1);\r\n    }\r\n\r\n    function removeByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    {\r\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\r\n\r\n        address currencyCt = self.currencies[index].ct;\r\n        uint256 currencyId = self.currencies[index].id;\r\n\r\n        if (index < self.currencies.length - 1) {\r\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\r\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\r\n        }\r\n        self.currencies.length--;\r\n        self.indexByCurrency[currencyCt][currencyId] = 0;\r\n    }\r\n\r\n    function count(Currencies storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencies.length;\r\n    }\r\n\r\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency memory)\r\n    {\r\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\r\n        return self.currencies[index];\r\n    }\r\n\r\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency[] memory)\r\n    {\r\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\r\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\r\n\r\n        up = up.clampMax(self.currencies.length - 1);\r\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _currencies[i - low] = self.currencies[i];\r\n\r\n        return _currencies;\r\n    }\r\n}\r\n\r\nlibrary FungibleBalanceLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    struct Record {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    struct Balance {\r\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\r\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\r\n\r\n        CurrenciesLib.Currencies inUseCurrencies;\r\n        CurrenciesLib.Currencies everUsedCurrencies;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return self.amountByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return amount;\r\n    }\r\n\r\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function setByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function addByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function subByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub(_from, amount, currencyCt, currencyId);\r\n        add(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub_nn(_from, amount, currencyCt, currencyId);\r\n        add_nn(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.recordsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\r\n    }\r\n\r\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.inUseCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\r\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\r\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\r\n            self.inUseCurrencies.add(currencyCt, currencyId);\r\n            self.everUsedCurrencies.add(currencyCt, currencyId);\r\n        }\r\n    }\r\n\r\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return 0;\r\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\r\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\nlibrary TxHistoryLib {\r\n    \r\n    \r\n    \r\n    struct AssetEntry {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n        address currencyCt;      \r\n        uint256 currencyId;\r\n    }\r\n\r\n    struct TxHistory {\r\n        AssetEntry[] deposits;\r\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\r\n\r\n        AssetEntry[] withdrawals;\r\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\r\n        self.deposits.push(deposit);\r\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\r\n    }\r\n\r\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\r\n        self.withdrawals.push(withdrawal);\r\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\r\n    }\r\n\r\n    \r\n\r\n    function deposit(TxHistory storage self, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\r\n\r\n        amount = self.deposits[index].amount;\r\n        blockNumber = self.deposits[index].blockNumber;\r\n        currencyCt = self.deposits[index].currencyCt;\r\n        currencyId = self.deposits[index].currencyId;\r\n    }\r\n\r\n    function depositsCount(TxHistory storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.deposits.length;\r\n    }\r\n\r\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\r\n\r\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\r\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\r\n    }\r\n\r\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencyDeposits[currencyCt][currencyId].length;\r\n    }\r\n\r\n    \r\n\r\n    function withdrawal(TxHistory storage self, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\r\n\r\n        amount = self.withdrawals[index].amount;\r\n        blockNumber = self.withdrawals[index].blockNumber;\r\n        currencyCt = self.withdrawals[index].currencyCt;\r\n        currencyId = self.withdrawals[index].currencyId;\r\n    }\r\n\r\n    function withdrawalsCount(TxHistory storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.withdrawals.length;\r\n    }\r\n\r\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\r\n\r\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\r\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\r\n    }\r\n\r\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\r\n    }\r\n}\r\n\r\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using TxHistoryLib for TxHistoryLib.TxHistory;\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    FungibleBalanceLib.Balance periodAccrual;\r\n    CurrenciesLib.Currencies periodCurrencies;\r\n\r\n    FungibleBalanceLib.Balance aggregateAccrual;\r\n    CurrenciesLib.Currencies aggregateCurrencies;\r\n\r\n    TxHistoryLib.TxHistory private txHistory;\r\n\r\n    \r\n    \r\n    \r\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event CloseAccrualPeriodEvent();\r\n    event RegisterServiceEvent(address service);\r\n    event DeregisterServiceEvent(address service);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function() external payable {\r\n        receiveEthersTo(msg.sender, \"\");\r\n    }\r\n\r\n    \r\n    \r\n    function receiveEthersTo(address wallet, string memory)\r\n    public\r\n    payable\r\n    {\r\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\r\n\r\n        \r\n        periodAccrual.add(amount, address(0), 0);\r\n        aggregateAccrual.add(amount, address(0), 0);\r\n\r\n        \r\n        periodCurrencies.add(address(0), 0);\r\n        aggregateCurrencies.add(address(0), 0);\r\n\r\n        \r\n        txHistory.addDeposit(amount, address(0), 0);\r\n\r\n        \r\n        emit ReceiveEvent(wallet, amount, address(0), 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokensTo(address wallet, string memory, int256 amount,\r\n        address currencyCt, uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [RevenueFund.sol:115]\");\r\n\r\n        \r\n        TransferController controller = transferController(currencyCt, standard);\r\n        (bool success,) = address(controller).delegatecall(\r\n            abi.encodeWithSelector(\r\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\r\n            )\r\n        );\r\n        require(success, \"Reception by controller failed [RevenueFund.sol:124]\");\r\n\r\n        \r\n        periodAccrual.add(amount, currencyCt, currencyId);\r\n        aggregateAccrual.add(amount, currencyCt, currencyId);\r\n\r\n        \r\n        periodCurrencies.add(currencyCt, currencyId);\r\n        aggregateCurrencies.add(currencyCt, currencyId);\r\n\r\n        \r\n        txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        \r\n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return periodAccrual.get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return aggregateAccrual.get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function periodCurrenciesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return periodCurrencies.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function periodCurrenciesByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.Currency[] memory)\r\n    {\r\n        return periodCurrencies.getByIndices(low, up);\r\n    }\r\n\r\n    \r\n    \r\n    function aggregateCurrenciesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return aggregateCurrencies.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.Currency[] memory)\r\n    {\r\n        return aggregateCurrencies.getByIndices(low, up);\r\n    }\r\n\r\n    \r\n    \r\n    function depositsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return txHistory.depositsCount();\r\n    }\r\n\r\n    \r\n    \r\n    function deposit(uint index)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        return txHistory.deposit(index);\r\n    }\r\n\r\n    \r\n    \r\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\r\n    public\r\n    onlyOperator\r\n    {\r\n        require(\r\n            ConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\r\n            \"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\r\n        );\r\n\r\n        \r\n        for (uint256 i = 0; i < currencies.length; i++) {\r\n            MonetaryTypesLib.Currency memory currency = currencies[i];\r\n\r\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\r\n\r\n            if (0 >= remaining)\r\n                continue;\r\n\r\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\r\n                AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\r\n\r\n                if (beneficiaryFraction(beneficiary) > 0) {\r\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\r\n                    .mul(beneficiaryFraction(beneficiary))\r\n                    .div(ConstantsLib.PARTS_PER());\r\n\r\n                    if (transferable > remaining)\r\n                        transferable = remaining;\r\n\r\n                    if (transferable > 0) {\r\n                        \r\n                        if (currency.ct == address(0))\r\n                            beneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\r\n\r\n                        \r\n                        else {\r\n                            TransferController controller = transferController(currency.ct, \"\");\r\n                            (bool success,) = address(controller).delegatecall(\r\n                                abi.encodeWithSelector(\r\n                                    controller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\r\n                                )\r\n                            );\r\n                            require(success, \"Approval by controller failed [RevenueFund.sol:274]\");\r\n\r\n                            beneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\r\n                        }\r\n\r\n                        remaining = remaining.sub(transferable);\r\n                    }\r\n                }\r\n            }\r\n\r\n            \r\n            periodAccrual.set(remaining, currency.ct, currency.id);\r\n        }\r\n\r\n        \r\n        for (uint256 j = 0; j < beneficiaries.length; j++) {\r\n            AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\r\n\r\n            \r\n            if (0 >= beneficiaryFraction(beneficiary))\r\n                continue;\r\n\r\n            \r\n            beneficiary.closeAccrualPeriod(currencies);\r\n        }\r\n\r\n        \r\n        emit CloseAccrualPeriodEvent();\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n\r\n    \r\n    function concat(string memory _base, string memory _value)\r\n        internal\r\n        pure\r\n        returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        assert(_valueBytes.length > 0);\r\n\r\n        string memory _tmpValue = new string(_baseBytes.length +\r\n            _valueBytes.length);\r\n        bytes memory _newValue = bytes(_tmpValue);\r\n\r\n        uint i;\r\n        uint j;\r\n\r\n        for (i = 0; i < _baseBytes.length; i++) {\r\n            _newValue[j++] = _baseBytes[i];\r\n        }\r\n\r\n        for (i = 0; i < _valueBytes.length; i++) {\r\n            _newValue[j++] = _valueBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }\r\n\r\n    \r\n    function indexOf(string memory _base, string memory _value)\r\n        internal\r\n        pure\r\n        returns (int) {\r\n        return _indexOf(_base, _value, 0);\r\n    }\r\n\r\n    \r\n    function _indexOf(string memory _base, string memory _value, uint _offset)\r\n        internal\r\n        pure\r\n        returns (int) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        assert(_valueBytes.length == 1);\r\n\r\n        for (uint i = _offset; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] == _valueBytes[0]) {\r\n                return int(i);\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    \r\n    function length(string memory _base)\r\n        internal\r\n        pure\r\n        returns (uint) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        return _baseBytes.length;\r\n    }\r\n\r\n    \r\n    function substring(string memory _base, int _length)\r\n        internal\r\n        pure\r\n        returns (string memory) {\r\n        return _substring(_base, _length, 0);\r\n    }\r\n\r\n    \r\n    function _substring(string memory _base, int _length, int _offset)\r\n        internal\r\n        pure\r\n        returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n\r\n        assert(uint(_offset + _length) <= _baseBytes.length);\r\n\r\n        string memory _tmp = new string(uint(_length));\r\n        bytes memory _tmpBytes = bytes(_tmp);\r\n\r\n        uint j = 0;\r\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\r\n            _tmpBytes[j++] = _baseBytes[i];\r\n        }\r\n\r\n        return string(_tmpBytes);\r\n    }\r\n\r\n    \r\n    function split(string memory _base, string memory _value)\r\n        internal\r\n        pure\r\n        returns (string[] memory splitArr) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n\r\n        uint _offset = 0;\r\n        uint _splitsCount = 1;\r\n        while (_offset < _baseBytes.length - 1) {\r\n            int _limit = _indexOf(_base, _value, _offset);\r\n            if (_limit == -1)\r\n                break;\r\n            else {\r\n                _splitsCount++;\r\n                _offset = uint(_limit) + 1;\r\n            }\r\n        }\r\n\r\n        splitArr = new string[](_splitsCount);\r\n\r\n        _offset = 0;\r\n        _splitsCount = 0;\r\n        while (_offset < _baseBytes.length - 1) {\r\n\r\n            int _limit = _indexOf(_base, _value, _offset);\r\n            if (_limit == - 1) {\r\n                _limit = int(_baseBytes.length);\r\n            }\r\n\r\n            string memory _tmp = new string(uint(_limit) - _offset);\r\n            bytes memory _tmpBytes = bytes(_tmp);\r\n\r\n            uint j = 0;\r\n            for (uint i = _offset; i < uint(_limit); i++) {\r\n                _tmpBytes[j++] = _baseBytes[i];\r\n            }\r\n            _offset = uint(_limit) + 1;\r\n            splitArr[_splitsCount++] = string(_tmpBytes);\r\n        }\r\n        return splitArr;\r\n    }\r\n\r\n    \r\n    function compareTo(string memory _base, string memory _value)\r\n        internal\r\n        pure\r\n        returns (bool) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        if (_baseBytes.length != _valueBytes.length) {\r\n            return false;\r\n        }\r\n\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] != _valueBytes[i]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    function compareToIgnoreCase(string memory _base, string memory _value)\r\n        internal\r\n        pure\r\n        returns (bool) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        if (_baseBytes.length != _valueBytes.length) {\r\n            return false;\r\n        }\r\n\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] != _valueBytes[i] &&\r\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    function upper(string memory _base)\r\n        internal\r\n        pure\r\n        returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _upper(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    \r\n    function lower(string memory _base)\r\n        internal\r\n        pure\r\n        returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _lower(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    \r\n    function _upper(bytes1 _b1)\r\n        private\r\n        pure\r\n        returns (bytes1) {\r\n\r\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\r\n            return bytes1(uint8(_b1) - 32);\r\n        }\r\n\r\n        return _b1;\r\n    }\r\n\r\n    \r\n    function _lower(bytes1 _b1)\r\n        private\r\n        pure\r\n        returns (bytes1) {\r\n\r\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\r\n            return bytes1(uint8(_b1) + 32);\r\n        }\r\n\r\n        return _b1;\r\n    }\r\n}\r\n\r\ncontract PartnerFund is Ownable, Beneficiary, TransferControllerManageable {\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using TxHistoryLib for TxHistoryLib.TxHistory;\r\n    using SafeMathIntLib for int256;\r\n    using Strings for string;\r\n\r\n    \r\n    \r\n    \r\n    struct Partner {\r\n        bytes32 nameHash;\r\n\r\n        uint256 fee;\r\n        address wallet;\r\n        uint256 index;\r\n\r\n        bool operatorCanUpdate;\r\n        bool partnerCanUpdate;\r\n\r\n        FungibleBalanceLib.Balance active;\r\n        FungibleBalanceLib.Balance staged;\r\n\r\n        TxHistoryLib.TxHistory txHistory;\r\n        FullBalanceHistory[] fullBalanceHistory;\r\n    }\r\n\r\n    struct FullBalanceHistory {\r\n        uint256 listIndex;\r\n        int256 balance;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    Partner[] private partners;\r\n\r\n    mapping(bytes32 => uint256) private _indexByNameHash;\r\n    mapping(address => uint256) private _indexByWallet;\r\n\r\n    \r\n    \r\n    \r\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event RegisterPartnerByNameEvent(string name, uint256 fee, address wallet);\r\n    event RegisterPartnerByNameHashEvent(bytes32 nameHash, uint256 fee, address wallet);\r\n    event SetFeeByIndexEvent(uint256 index, uint256 oldFee, uint256 newFee);\r\n    event SetFeeByNameEvent(string name, uint256 oldFee, uint256 newFee);\r\n    event SetFeeByNameHashEvent(bytes32 nameHash, uint256 oldFee, uint256 newFee);\r\n    event SetFeeByWalletEvent(address wallet, uint256 oldFee, uint256 newFee);\r\n    event SetPartnerWalletByIndexEvent(uint256 index, address oldWallet, address newWallet);\r\n    event SetPartnerWalletByNameEvent(string name, address oldWallet, address newWallet);\r\n    event SetPartnerWalletByNameHashEvent(bytes32 nameHash, address oldWallet, address newWallet);\r\n    event SetPartnerWalletByWalletEvent(address oldWallet, address newWallet);\r\n    event StageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function() external payable {\r\n        _receiveEthersTo(\r\n            indexByWallet(msg.sender) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    function receiveEthersTo(address tag, string memory)\r\n    public\r\n    payable\r\n    {\r\n        _receiveEthersTo(\r\n            uint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokens(string memory, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        _receiveTokensTo(\r\n            indexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        _receiveTokensTo(\r\n            uint256(tag) - 1, amount, currencyCt, currencyId, standard\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function hashName(string memory name)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(name.upper()));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function depositByIndices(uint256 partnerIndex, uint256 depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        \r\n        require(0 < partnerIndex && partnerIndex <= partners.length, \"Some error message when require fails [PartnerFund.sol:160]\");\r\n\r\n        return _depositByIndices(partnerIndex - 1, depositIndex);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function depositByName(string memory name, uint depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        \r\n        return _depositByIndices(indexByName(name) - 1, depositIndex);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function depositByNameHash(bytes32 nameHash, uint depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        \r\n        return _depositByIndices(indexByNameHash(nameHash) - 1, depositIndex);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function depositByWallet(address wallet, uint depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        \r\n        return _depositByIndices(indexByWallet(wallet) - 1, depositIndex);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function depositsCountByIndex(uint256 index)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:213]\");\r\n\r\n        return _depositsCountByIndex(index - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function depositsCountByName(string memory name)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        return _depositsCountByIndex(indexByName(name) - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function depositsCountByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        return _depositsCountByIndex(indexByNameHash(nameHash) - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function depositsCountByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        return _depositsCountByIndex(indexByWallet(wallet) - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:265]\");\r\n\r\n        return _activeBalanceByIndex(index - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        return _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function activeBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        return _activeBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function activeBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        return _activeBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:323]\");\r\n\r\n        return _stagedBalanceByIndex(index - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        return _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function stagedBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        return _stagedBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function stagedBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        \r\n        return _stagedBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function partnersCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return partners.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function registerByName(string memory name, uint256 fee, address wallet,\r\n        bool partnerCanUpdate, bool operatorCanUpdate)\r\n    public\r\n    onlyOperator\r\n    {\r\n        \r\n        require(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\r\n\r\n        \r\n        bytes32 nameHash = hashName(name);\r\n\r\n        \r\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\r\n\r\n        \r\n        emit RegisterPartnerByNameEvent(name, fee, wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\r\n        bool partnerCanUpdate, bool operatorCanUpdate)\r\n    public\r\n    onlyOperator\r\n    {\r\n        \r\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\r\n\r\n        \r\n        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function indexByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = _indexByNameHash[nameHash];\r\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:431]\");\r\n        return index;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function indexByName(string memory name)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return indexByNameHash(hashName(name));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function indexByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = _indexByWallet[wallet];\r\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:455]\");\r\n        return index;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredByName(string memory name)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (0 < _indexByNameHash[hashName(name)]);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (0 < _indexByNameHash[nameHash]);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (0 < _indexByWallet[wallet]);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function feeByIndex(uint256 index)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:501]\");\r\n\r\n        return _partnerFeeByIndex(index - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function feeByName(string memory name)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        return _partnerFeeByIndex(indexByName(name) - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function feeByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        return _partnerFeeByIndex(indexByNameHash(nameHash) - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function feeByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        return _partnerFeeByIndex(indexByWallet(wallet) - 1);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setFeeByIndex(uint256 index, uint256 newFee)\r\n    public\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:549]\");\r\n\r\n        \r\n        uint256 oldFee = _setPartnerFeeByIndex(index - 1, newFee);\r\n\r\n        \r\n        emit SetFeeByIndexEvent(index, oldFee, newFee);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setFeeByName(string memory name, uint256 newFee)\r\n    public\r\n    {\r\n        \r\n        uint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\r\n\r\n        \r\n        emit SetFeeByNameEvent(name, oldFee, newFee);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setFeeByNameHash(bytes32 nameHash, uint256 newFee)\r\n    public\r\n    {\r\n        \r\n        uint256 oldFee = _setPartnerFeeByIndex(indexByNameHash(nameHash) - 1, newFee);\r\n\r\n        \r\n        emit SetFeeByNameHashEvent(nameHash, oldFee, newFee);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setFeeByWallet(address wallet, uint256 newFee)\r\n    public\r\n    {\r\n        \r\n        uint256 oldFee = _setPartnerFeeByIndex(indexByWallet(wallet) - 1, newFee);\r\n\r\n        \r\n        emit SetFeeByWalletEvent(wallet, oldFee, newFee);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function walletByIndex(uint256 index)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:606]\");\r\n\r\n        return partners[index - 1].wallet;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function walletByName(string memory name)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        \r\n        return partners[indexByName(name) - 1].wallet;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function walletByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        \r\n        return partners[indexByNameHash(nameHash) - 1].wallet;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setWalletByIndex(uint256 index, address newWallet)\r\n    public\r\n    {\r\n        \r\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:642]\");\r\n\r\n        \r\n        address oldWallet = _setPartnerWalletByIndex(index - 1, newWallet);\r\n\r\n        \r\n        emit SetPartnerWalletByIndexEvent(index, oldWallet, newWallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setWalletByName(string memory name, address newWallet)\r\n    public\r\n    {\r\n        \r\n        address oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\r\n\r\n        \r\n        emit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setWalletByNameHash(bytes32 nameHash, address newWallet)\r\n    public\r\n    {\r\n        \r\n        address oldWallet = _setPartnerWalletByIndex(indexByNameHash(nameHash) - 1, newWallet);\r\n\r\n        \r\n        emit SetPartnerWalletByNameHashEvent(nameHash, oldWallet, newWallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setWalletByWallet(address oldWallet, address newWallet)\r\n    public\r\n    {\r\n        \r\n        _setPartnerWalletByIndex(indexByWallet(oldWallet) - 1, newWallet);\r\n\r\n        \r\n        emit SetPartnerWalletByWalletEvent(oldWallet, newWallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function stage(int256 amount, address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        \r\n        uint256 index = indexByWallet(msg.sender);\r\n\r\n        \r\n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:701]\");\r\n\r\n        \r\n        amount = amount.clampMax(partners[index - 1].active.get(currencyCt, currencyId));\r\n\r\n        partners[index - 1].active.sub(amount, currencyCt, currencyId);\r\n        partners[index - 1].staged.add(amount, currencyCt, currencyId);\r\n\r\n        partners[index - 1].txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        \r\n        partners[index - 1].fullBalanceHistory.push(\r\n            FullBalanceHistory(\r\n                partners[index - 1].txHistory.depositsCount() - 1,\r\n                partners[index - 1].active.get(currencyCt, currencyId),\r\n                block.number\r\n            )\r\n        );\r\n\r\n        \r\n        emit StageEvent(msg.sender, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        \r\n        uint256 index = indexByWallet(msg.sender);\r\n\r\n        \r\n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\r\n\r\n        \r\n        amount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\r\n\r\n        partners[index - 1].staged.sub(amount, currencyCt, currencyId);\r\n\r\n        \r\n        if (address(0) == currencyCt && 0 == currencyId)\r\n            msg.sender.transfer(uint256(amount));\r\n\r\n        else {\r\n            TransferController controller = transferController(currencyCt, standard);\r\n            (bool success,) = address(controller).delegatecall(\r\n                abi.encodeWithSelector(\r\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\r\n                )\r\n            );\r\n            require(success, \"Some error message when require fails [PartnerFund.sol:754]\");\r\n        }\r\n\r\n        \r\n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function _receiveEthersTo(uint256 index, int256 amount)\r\n    private\r\n    {\r\n        \r\n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:769]\");\r\n\r\n        \r\n        partners[index].active.add(amount, address(0), 0);\r\n        partners[index].txHistory.addDeposit(amount, address(0), 0);\r\n\r\n        \r\n        partners[index].fullBalanceHistory.push(\r\n            FullBalanceHistory(\r\n                partners[index].txHistory.depositsCount() - 1,\r\n                partners[index].active.get(address(0), 0),\r\n                block.number\r\n            )\r\n        );\r\n\r\n        \r\n        emit ReceiveEvent(msg.sender, amount, address(0), 0);\r\n    }\r\n\r\n    \r\n    function _receiveTokensTo(uint256 index, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    private\r\n    {\r\n        \r\n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:794]\");\r\n\r\n        require(amount.isNonZeroPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:796]\");\r\n\r\n        \r\n        TransferController controller = transferController(currencyCt, standard);\r\n        (bool success,) = address(controller).delegatecall(\r\n            abi.encodeWithSelector(\r\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\r\n            )\r\n        );\r\n        require(success, \"Some error message when require fails [PartnerFund.sol:805]\");\r\n\r\n        \r\n        partners[index].active.add(amount, currencyCt, currencyId);\r\n        partners[index].txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        \r\n        partners[index].fullBalanceHistory.push(\r\n            FullBalanceHistory(\r\n                partners[index].txHistory.depositsCount() - 1,\r\n                partners[index].active.get(currencyCt, currencyId),\r\n                block.number\r\n            )\r\n        );\r\n\r\n        \r\n        emit ReceiveEvent(msg.sender, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    function _depositByIndices(uint256 partnerIndex, uint256 depositIndex)\r\n    private\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(depositIndex < partners[partnerIndex].fullBalanceHistory.length, \"Some error message when require fails [PartnerFund.sol:830]\");\r\n\r\n        FullBalanceHistory storage entry = partners[partnerIndex].fullBalanceHistory[depositIndex];\r\n        (,, currencyCt, currencyId) = partners[partnerIndex].txHistory.deposit(entry.listIndex);\r\n\r\n        balance = entry.balance;\r\n        blockNumber = entry.blockNumber;\r\n    }\r\n\r\n    \r\n    function _depositsCountByIndex(uint256 index)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return partners[index].fullBalanceHistory.length;\r\n    }\r\n\r\n    \r\n    function _activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256)\r\n    {\r\n        return partners[index].active.get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    function _stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256)\r\n    {\r\n        return partners[index].staged.get(currencyCt, currencyId);\r\n    }\r\n\r\n    function _registerPartnerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\r\n        bool partnerCanUpdate, bool operatorCanUpdate)\r\n    private\r\n    {\r\n        \r\n        require(0 == _indexByNameHash[nameHash], \"Some error message when require fails [PartnerFund.sol:871]\");\r\n\r\n        \r\n        require(partnerCanUpdate || operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:874]\");\r\n\r\n        \r\n        partners.length++;\r\n\r\n        \r\n        uint256 index = partners.length;\r\n\r\n        \r\n        partners[index - 1].nameHash = nameHash;\r\n        partners[index - 1].fee = fee;\r\n        partners[index - 1].wallet = wallet;\r\n        partners[index - 1].partnerCanUpdate = partnerCanUpdate;\r\n        partners[index - 1].operatorCanUpdate = operatorCanUpdate;\r\n        partners[index - 1].index = index;\r\n\r\n        \r\n        _indexByNameHash[nameHash] = index;\r\n\r\n        \r\n        _indexByWallet[wallet] = index;\r\n    }\r\n\r\n    \r\n    function _setPartnerFeeByIndex(uint256 index, uint256 fee)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        uint256 oldFee = partners[index].fee;\r\n\r\n        \r\n        if (isOperator())\r\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:906]\");\r\n\r\n        else {\r\n            \r\n            require(msg.sender == partners[index].wallet, \"Some error message when require fails [PartnerFund.sol:910]\");\r\n\r\n            \r\n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:913]\");\r\n        }\r\n\r\n        \r\n        partners[index].fee = fee;\r\n\r\n        return oldFee;\r\n    }\r\n\r\n    \r\n    function _setPartnerWalletByIndex(uint256 index, address newWallet)\r\n    private\r\n    returns (address)\r\n    {\r\n        address oldWallet = partners[index].wallet;\r\n\r\n        \r\n        if (oldWallet == address(0))\r\n            require(isOperator(), \"Some error message when require fails [PartnerFund.sol:931]\");\r\n\r\n        \r\n        else if (isOperator())\r\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:935]\");\r\n\r\n        else {\r\n            \r\n            require(msg.sender == oldWallet, \"Some error message when require fails [PartnerFund.sol:939]\");\r\n\r\n            \r\n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:942]\");\r\n\r\n            \r\n            require(partners[index].operatorCanUpdate || newWallet != address(0), \"Some error message when require fails [PartnerFund.sol:945]\");\r\n        }\r\n\r\n        \r\n        partners[index].wallet = newWallet;\r\n\r\n        \r\n        if (oldWallet != address(0))\r\n            _indexByWallet[oldWallet] = 0;\r\n        if (newWallet != address(0))\r\n            _indexByWallet[newWallet] = index;\r\n\r\n        return oldWallet;\r\n    }\r\n\r\n    \r\n    function _partnerFeeByIndex(uint256 index)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return partners[index].fee;\r\n    }\r\n}\r\n\r\nlibrary NahmiiTypesLib {\r\n    \r\n    \r\n    \r\n    enum ChallengePhase {Dispute, Closed}\r\n\r\n    \r\n    \r\n    \r\n    struct OriginFigure {\r\n        uint256 originId;\r\n        MonetaryTypesLib.Figure figure;\r\n    }\r\n\r\n    struct IntendedConjugateCurrency {\r\n        MonetaryTypesLib.Currency intended;\r\n        MonetaryTypesLib.Currency conjugate;\r\n    }\r\n\r\n    struct SingleFigureTotalOriginFigures {\r\n        MonetaryTypesLib.Figure single;\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct TotalOriginFigures {\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct CurrentPreviousInt256 {\r\n        int256 current;\r\n        int256 previous;\r\n    }\r\n\r\n    struct SingleTotalInt256 {\r\n        int256 single;\r\n        int256 total;\r\n    }\r\n\r\n    struct IntendedConjugateCurrentPreviousInt256 {\r\n        CurrentPreviousInt256 intended;\r\n        CurrentPreviousInt256 conjugate;\r\n    }\r\n\r\n    struct IntendedConjugateSingleTotalInt256 {\r\n        SingleTotalInt256 intended;\r\n        SingleTotalInt256 conjugate;\r\n    }\r\n\r\n    struct WalletOperatorHashes {\r\n        bytes32 wallet;\r\n        bytes32 operator;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    struct Seal {\r\n        bytes32 hash;\r\n        Signature signature;\r\n    }\r\n\r\n    struct WalletOperatorSeal {\r\n        Seal wallet;\r\n        Seal operator;\r\n    }\r\n}\r\n\r\nlibrary DriipSettlementTypesLib {\r\n    \r\n    \r\n    \r\n    enum SettlementRole {Origin, Target}\r\n\r\n    struct SettlementParty {\r\n        uint256 nonce;\r\n        address wallet;\r\n        uint256 doneBlockNumber;\r\n    }\r\n\r\n    struct Settlement {\r\n        string settledKind;\r\n        bytes32 settledHash;\r\n        SettlementParty origin;\r\n        SettlementParty target;\r\n    }\r\n}\r\n\r\ncontract DriipSettlementState is Ownable, Servable, CommunityVotable, Upgradable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    string constant public INIT_SETTLEMENT_ACTION = \"init_settlement\";\r\n    string constant public COMPLETE_SETTLEMENT_ACTION = \"complete_settlement\";\r\n    string constant public SET_MAX_NONCE_ACTION = \"set_max_nonce\";\r\n    string constant public ADD_SETTLED_AMOUNT_ACTION = \"add_settled_amount\";\r\n    string constant public SET_TOTAL_FEE_ACTION = \"set_total_fee\";\r\n\r\n    \r\n    \r\n    \r\n    uint256 public maxDriipNonce;\r\n\r\n    DriipSettlementTypesLib.Settlement[] public settlements;\r\n    mapping(address => uint256[]) public walletSettlementIndices;\r\n    mapping(address => mapping(uint256 => uint256)) public walletNonceSettlementIndex;\r\n\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyMaxNonce;\r\n\r\n    mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => int256)))) public walletCurrencyBlockNumberSettledAmount;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256[]))) public walletCurrencySettledBlockNumbers;\r\n\r\n    mapping(address => mapping(address => mapping(address => mapping(address => mapping(uint256 => MonetaryTypesLib.NoncedAmount))))) public totalFeesMap;\r\n\r\n    \r\n    \r\n    \r\n    event InitSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\r\n    event CompleteSettlementPartyEvent(address wallet, uint256 nonce, DriipSettlementTypesLib.SettlementRole settlementRole,\r\n        uint256 doneBlockNumber);\r\n    event SetMaxDriipNonceEvent(uint256 maxDriipNonce);\r\n    event UpdateMaxDriipNonceFromCommunityVoteEvent(uint256 maxDriipNonce);\r\n    event SetMaxNonceByWalletAndCurrencyEvent(address wallet, MonetaryTypesLib.Currency currency,\r\n        uint256 maxNonce);\r\n    event AddSettledAmountEvent(address wallet, int256 amount, MonetaryTypesLib.Currency currency,\r\n        uint256 blockNumber);\r\n    event SetTotalFeeEvent(address wallet, Beneficiary beneficiary, address destination,\r\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount totalFee);\r\n    event UpgradeSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\r\n    event UpgradeSettledAmountEvent(address wallet, int256 amount, MonetaryTypesLib.Currency currency,\r\n        uint256 blockNumber);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function settlementsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return settlements.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function settlementsCountByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletSettlementIndices[wallet].length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function settlementByWalletAndIndex(address wallet, uint256 index)\r\n    public\r\n    view\r\n    returns (DriipSettlementTypesLib.Settlement memory)\r\n    {\r\n        require(walletSettlementIndices[wallet].length > index, \"Index out of bounds [DriipSettlementState.sol:114]\");\r\n        return settlements[walletSettlementIndices[wallet][index] - 1];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\r\n    public\r\n    view\r\n    returns (DriipSettlementTypesLib.Settlement memory)\r\n    {\r\n        require(0 != walletNonceSettlementIndex[wallet][nonce], \"No settlement found for wallet and nonce [DriipSettlementState.sol:127]\");\r\n        return settlements[walletNonceSettlementIndex[wallet][nonce] - 1];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\r\n        uint256 originNonce, address targetWallet, uint256 targetNonce)\r\n    public\r\n    onlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\r\n    {\r\n        if (\r\n            0 == walletNonceSettlementIndex[originWallet][originNonce] &&\r\n            0 == walletNonceSettlementIndex[targetWallet][targetNonce]\r\n        ) {\r\n            \r\n            settlements.length++;\r\n\r\n            \r\n            uint256 index = settlements.length - 1;\r\n\r\n            \r\n            settlements[index].settledKind = settledKind;\r\n            settlements[index].settledHash = settledHash;\r\n            settlements[index].origin.nonce = originNonce;\r\n            settlements[index].origin.wallet = originWallet;\r\n            settlements[index].target.nonce = targetNonce;\r\n            settlements[index].target.wallet = targetWallet;\r\n\r\n            \r\n            emit InitSettlementEvent(settlements[index]);\r\n\r\n            \r\n            index++;\r\n            walletSettlementIndices[originWallet].push(index);\r\n            walletSettlementIndices[targetWallet].push(index);\r\n            walletNonceSettlementIndex[originWallet][originNonce] = index;\r\n            walletNonceSettlementIndex[targetWallet][targetNonce] = index;\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function completeSettlement(address wallet, uint256 nonce,\r\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done)\r\n    public\r\n    onlyEnabledServiceAction(COMPLETE_SETTLEMENT_ACTION)\r\n    {\r\n        \r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        \r\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:188]\");\r\n\r\n        \r\n        DriipSettlementTypesLib.SettlementParty storage party =\r\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\r\n        settlements[index - 1].origin :\r\n        settlements[index - 1].target;\r\n\r\n        \r\n        party.doneBlockNumber = done ? block.number : 0;\r\n\r\n        \r\n        emit CompleteSettlementPartyEvent(wallet, nonce, settlementRole, party.doneBlockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function isSettlementPartyDone(address wallet, uint256 nonce)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        \r\n        if (0 == index)\r\n            return false;\r\n\r\n        \r\n        return (\r\n        wallet == settlements[index - 1].origin.wallet ?\r\n        0 != settlements[index - 1].origin.doneBlockNumber :\r\n        0 != settlements[index - 1].target.doneBlockNumber\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isSettlementPartyDone(address wallet, uint256 nonce,\r\n        DriipSettlementTypesLib.SettlementRole settlementRole)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        \r\n        if (0 == index)\r\n            return false;\r\n\r\n        \r\n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\r\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\r\n        settlements[index - 1].origin : settlements[index - 1].target;\r\n\r\n        \r\n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:252]\");\r\n\r\n        \r\n        return 0 != settlementParty.doneBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        \r\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:271]\");\r\n\r\n        \r\n        return (\r\n        wallet == settlements[index - 1].origin.wallet ?\r\n        settlements[index - 1].origin.doneBlockNumber :\r\n        settlements[index - 1].target.doneBlockNumber\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce,\r\n        DriipSettlementTypesLib.SettlementRole settlementRole)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        \r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        \r\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:296]\");\r\n\r\n        \r\n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\r\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\r\n        settlements[index - 1].origin : settlements[index - 1].target;\r\n\r\n        \r\n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:304]\");\r\n\r\n        \r\n        return settlementParty.doneBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    function setMaxDriipNonce(uint256 _maxDriipNonce)\r\n    public\r\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\r\n    {\r\n        maxDriipNonce = _maxDriipNonce;\r\n\r\n        \r\n        emit SetMaxDriipNonceEvent(maxDriipNonce);\r\n    }\r\n\r\n    \r\n    function updateMaxDriipNonceFromCommunityVote()\r\n    public\r\n    {\r\n        uint256 _maxDriipNonce = communityVote.getMaxDriipNonce();\r\n        if (0 == _maxDriipNonce)\r\n            return;\r\n\r\n        maxDriipNonce = _maxDriipNonce;\r\n\r\n        \r\n        emit UpdateMaxDriipNonceFromCommunityVoteEvent(maxDriipNonce);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\r\n        uint256 maxNonce)\r\n    public\r\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\r\n    {\r\n        \r\n        walletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\r\n\r\n        \r\n        emit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\r\n        uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\r\n        return walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\r\n        uint256 blockNumber)\r\n    public\r\n    onlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\r\n    {\r\n        \r\n        uint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\r\n\r\n        \r\n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\r\n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\r\n\r\n        \r\n        walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\r\n\r\n        \r\n        emit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function totalFee(address wallet, Beneficiary beneficiary, address destination,\r\n        MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.NoncedAmount memory)\r\n    {\r\n        return totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\r\n        MonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\r\n    public\r\n    onlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\r\n    {\r\n        \r\n        totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\r\n\r\n        \r\n        emit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\r\n    }\r\n\r\n    \r\n    \r\n    function upgradeSettlement(DriipSettlementTypesLib.Settlement memory settlement)\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        require(\r\n            0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\r\n            \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\r\n        );\r\n        require(\r\n            0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\r\n            \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\r\n        );\r\n\r\n        \r\n        settlements.push(settlement);\r\n\r\n        \r\n        uint256 index = settlements.length;\r\n\r\n        \r\n        walletSettlementIndices[settlement.origin.wallet].push(index);\r\n        walletSettlementIndices[settlement.target.wallet].push(index);\r\n        walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\r\n        walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\r\n\r\n        \r\n        emit UpgradeSettlementEvent(settlement);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\r\n        uint256 blockNumber)\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        require(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\r\n\r\n        \r\n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\r\n\r\n        \r\n        walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\r\n\r\n        \r\n        emit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _walletSettledBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\r\n        uint256 blockNumber)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        for (uint256 i = walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].length; i > 0; i--)\r\n            if (walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id][i - 1] <= blockNumber)\r\n                return walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id][i - 1];\r\n        return 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletCurrencySettledBlockNumbers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"upgradeSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settlements\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_MAX_NONCE_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxNonce\",\"type\":\"uint256\"}],\"name\":\"setMaxNonceByWalletAndCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeUpgrades\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"maxNonceByWalletAndCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalFeesMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"setMaxDriipNonce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"settlementPartyDoneBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMaxDriipNonceFromCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradesFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"contract Beneficiary\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"totalFee\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"internalType\":\"struct MonetaryTypesLib.NoncedAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"contract Beneficiary\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"internalType\":\"struct MonetaryTypesLib.NoncedAmount\",\"name\":\"_totalFee\",\"type\":\"tuple\"}],\"name\":\"setTotalFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"upgradeSettledAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADD_SETTLED_AMOUNT_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"originWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originNonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetNonce\",\"type\":\"uint256\"}],\"name\":\"initSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDriipNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVoteFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletSettlementIndices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"enum DriipSettlementTypesLib.SettlementRole\",\"name\":\"settlementRole\",\"type\":\"uint8\"}],\"name\":\"isSettlementPartyDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"enum DriipSettlementTypesLib.SettlementRole\",\"name\":\"settlementRole\",\"type\":\"uint8\"}],\"name\":\"settlementPartyDoneBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_TOTAL_FEE_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"settledAmountByBlockNumber\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVote\",\"outputs\":[{\"internalType\":\"contract CommunityVote\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPLETE_SETTLEMENT_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"isSettlementPartyDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletCurrencyBlockNumberSettledAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndNonce\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletNonceSettlementIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upgradeAgent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INIT_SETTLEMENT_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract CommunityVote\",\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"setCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletCurrencyMaxNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"settlementsCountByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"enum DriipSettlementTypesLib.SettlementRole\",\"name\":\"settlementRole\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"completeSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"addSettledAmountByBlockNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"InitSettlementEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum DriipSettlementTypesLib.SettlementRole\",\"name\":\"settlementRole\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"CompleteSettlementPartyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"SetMaxDriipNonceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxDriipNonceFromCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNonce\",\"type\":\"uint256\"}],\"name\":\"SetMaxNonceByWalletAndCurrencyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"AddSettledAmountEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Beneficiary\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.NoncedAmount\",\"name\":\"totalFee\",\"type\":\"tuple\"}],\"name\":\"SetTotalFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"UpgradeSettlementEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"UpgradeSettledAmountEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"upgradeAgent\",\"type\":\"address\"}],\"name\":\"SetUpgradeAgentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeUpgradesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract CommunityVote\",\"name\":\"oldCommunityVote\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract CommunityVote\",\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"SetCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementState","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"","SwarmSource":"bzzr://b8e323376f652b9b73c705e3b6dd1e5bb29d404e9cdf52b050a44c600e702a80"}]}