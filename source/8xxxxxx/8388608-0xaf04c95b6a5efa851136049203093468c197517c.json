{"status":"1","message":"OK","result":[{"SourceCode":"{\"SwipeTimeLock.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./SwipeToken.sol\\\";\\n\\n// ----------------------------------------------------------------------------\\n\\n// Swipe Tokens Time Lock Contract\\n\\n// ----------------------------------------------------------------------------\\n\\ncontract SwipeTimeLock is Owned {\\n    using SafeMath for uint;\\n    SwipeToken token;\\n    uint tokenslocked;\\n    \\n    // Release 10M tokens time period\\n    uint[] unlockTimestamps = [\\n        1596240000,             // 08/01/2020\\n        1627776000,             // 08/01/2021 \\n        1659312000,             // 08/01/2022 \\n        1690848000,             // 08/01/2023 \\n        1722470400,             // 08/01/2024 \\n        1754006400              // 08/01/2025\\n    ];\\n\\n    constructor(address payable addrToken) public {\\n        token = SwipeToken(addrToken);\\n    }\\n    \\n    function getLockCount() public view returns (uint) {\\n        uint lock = 60000000000000000000000000;\\n        for (uint i = 0; i \\u003c 6; i ++) {\\n            if (now \\u003c unlockTimestamps[i]) break;\\n            lock = lock.sub(10000000000000000000000000);\\n        }\\n        \\n        return lock;\\n    }\\n    \\n    function getLockedTokenAmount() public view returns (uint) {\\n        return token.balanceOf(address(this));\\n    }\\n    \\n    function withdraw() public onlyOwner returns (uint withdrawed) {\\n        uint tokenLocked = getLockedTokenAmount();\\n        uint lockCount = getLockCount();\\n        \\n        require(tokenLocked \\u003e= lockCount, \\u0027no unlocked tokens\\u0027);\\n        uint allowed = tokenLocked.sub(lockCount);\\n        \\n        if (token.transfer(msg.sender, allowed)) {\\n            return allowed;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n        // ------------------------------------------------------------------------\\n\\n    // Don\\u0027t accept ETH\\n\\n    // ------------------------------------------------------------------------\\n\\n    function () external payable {\\n\\n        revert();\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\\n        require(tokenAddress != address(token), \\u0027SXP token is not allowed\\u0027);\\n\\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\\n\\n    }\\n}\\n\"},\"SwipeToken.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// \\u0027SXP\\u0027 \\u0027Swipe\\u0027 token contract\\n\\n//\\n\\n// Symbol      : SXP\\n\\n// Name        : Swipe\\n\\n// Total supply: 300,000,000.000000000000000000\\n\\n// Decimals    : 18\\n\\n// Website     : https://swipe.io\\n\\n\\n//\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// Safe maths\\n\\n// ----------------------------------------------------------------------------\\n\\nlibrary SafeMath {\\n\\n    function add(uint a, uint b) internal pure returns (uint c) {\\n\\n        c = a + b;\\n\\n        require(c \\u003e= a);\\n\\n    }\\n\\n    function sub(uint a, uint b) internal pure returns (uint c) {\\n\\n        require(b \\u003c= a);\\n\\n        c = a - b;\\n\\n    }\\n\\n    function mul(uint a, uint b) internal pure returns (uint c) {\\n\\n        c = a * b;\\n\\n        require(a == 0 || c / a == b);\\n\\n    }\\n\\n    function div(uint a, uint b) internal pure returns (uint c) {\\n\\n        require(b \\u003e 0);\\n\\n        c = a / b;\\n\\n    }\\n\\n}\\n\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// ERC Token Standard #20 Interface\\n\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n\\n// ----------------------------------------------------------------------------\\n\\ncontract ERC20Interface {\\n\\n    function totalSupply() public view returns (uint);\\n\\n    function balanceOf(address tokenOwner) public view returns (uint balance);\\n\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\n\\n    function transfer(address to, uint tokens) public returns (bool success);\\n\\n    function approve(address spender, uint tokens) public returns (bool success);\\n\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\\n\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n}\\n\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// Contract function to receive approval and execute function in one call\\n\\n//\\n\\n// Borrowed from MiniMeToken\\n\\n// ----------------------------------------------------------------------------\\n\\ncontract ApproveAndCallFallBack {\\n\\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\\n\\n}\\n\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// Owned contract\\n\\n// ----------------------------------------------------------------------------\\n\\ncontract Owned {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n\\n    constructor() public {\\n\\n        owner = msg.sender;\\n\\n    }\\n\\n\\n    modifier onlyOwner {\\n\\n        require(msg.sender == owner);\\n\\n        _;\\n\\n    }\\n\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n\\n        owner = newOwner;\\n        emit OwnershipTransferred(owner, newOwner);\\n\\n    }\\n\\n}\\n\\n// ----------------------------------------------------------------------------\\n\\n// Tokenlock contract\\n\\n// ----------------------------------------------------------------------------\\ncontract Tokenlock is Owned {\\n    \\n    uint8 isLocked = 0;       //flag indicates if token is locked\\n\\n    event Freezed();\\n    event UnFreezed();\\n\\n    modifier validLock {\\n        require(isLocked == 0);\\n        _;\\n    }\\n    \\n    function freeze() public onlyOwner {\\n        isLocked = 1;\\n        \\n        emit Freezed();\\n    }\\n\\n    function unfreeze() public onlyOwner {\\n        isLocked = 0;\\n        \\n        emit UnFreezed();\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n\\n// Limit users in blacklist\\n\\n// ----------------------------------------------------------------------------\\ncontract UserLock is Owned {\\n    \\n    mapping(address =\\u003e bool) blacklist;\\n        \\n    event LockUser(address indexed who);\\n    event UnlockUser(address indexed who);\\n\\n    modifier permissionCheck {\\n        require(!blacklist[msg.sender]);\\n        _;\\n    }\\n    \\n    function lockUser(address who) public onlyOwner {\\n        blacklist[who] = true;\\n        \\n        emit LockUser(who);\\n    }\\n\\n    function unlockUser(address who) public onlyOwner {\\n        blacklist[who] = false;\\n        \\n        emit UnlockUser(who);\\n    }\\n}\\n\\n\\n// ----------------------------------------------------------------------------\\n\\n// ERC20 Token, with the addition of symbol, name and decimals and a\\n\\n// fixed supply\\n\\n// ----------------------------------------------------------------------------\\n\\ncontract SwipeToken is ERC20Interface, Tokenlock, UserLock {\\n\\n    using SafeMath for uint;\\n\\n\\n    string public symbol;\\n\\n    string public  name;\\n\\n    uint8 public decimals;\\n\\n    uint _totalSupply;\\n\\n\\n    mapping(address =\\u003e uint) balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Constructor\\n\\n    // ------------------------------------------------------------------------\\n\\n    constructor() public {\\n\\n        symbol = \\\"SXP\\\";\\n\\n        name = \\\"Swipe\\\";\\n\\n        decimals = 18;\\n\\n        _totalSupply = 300000000 * 10**uint(decimals);\\n\\n        balances[owner] = _totalSupply;\\n\\n        emit Transfer(address(0), owner, _totalSupply);\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Total supply\\n\\n    // ------------------------------------------------------------------------\\n\\n    function totalSupply() public view returns (uint) {\\n\\n        return _totalSupply.sub(balances[address(0)]);\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Get the token balance for account `tokenOwner`\\n\\n    // ------------------------------------------------------------------------\\n\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\n\\n        return balances[tokenOwner];\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n\\n    // - 0 value transfers are allowed\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transfer(address to, uint tokens) public validLock permissionCheck returns (bool success) {\\n\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\n\\n        balances[to] = balances[to].add(tokens);\\n\\n        emit Transfer(msg.sender, to, tokens);\\n\\n        return true;\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n\\n    // from the token owner\\u0027s account\\n\\n    //\\n\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n\\n    // recommends that there are no checks for the approval double-spend attack\\n\\n    // as this should be implemented in user interfaces\\n\\n    // ------------------------------------------------------------------------\\n\\n    function approve(address spender, uint tokens) public validLock permissionCheck returns (bool success) {\\n\\n        allowed[msg.sender][spender] = tokens;\\n\\n        emit Approval(msg.sender, spender, tokens);\\n\\n        return true;\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Transfer `tokens` from the `from` account to the `to` account\\n\\n    //\\n\\n    // The calling account must already have sufficient tokens approve(...)-d\\n\\n    // for spending from the `from` account and\\n\\n    // - From account must have sufficient balance to transfer\\n\\n    // - Spender must have sufficient allowance to transfer\\n\\n    // - 0 value transfers are allowed\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transferFrom(address from, address to, uint tokens) public validLock permissionCheck returns (bool success) {\\n\\n        balances[from] = balances[from].sub(tokens);\\n\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\n\\n        balances[to] = balances[to].add(tokens);\\n\\n        emit Transfer(from, to, tokens);\\n\\n        return true;\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Returns the amount of tokens approved by the owner that can be\\n\\n    // transferred to the spender\\u0027s account\\n\\n    // ------------------------------------------------------------------------\\n\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\n\\n        return allowed[tokenOwner][spender];\\n\\n    }\\n\\n\\n     // ------------------------------------------------------------------------\\n     // Destroys `amount` tokens from `account`, reducing the\\n     // total supply.\\n     \\n     // Emits a `Transfer` event with `to` set to the zero address.\\n     \\n     // Requirements\\n     \\n     // - `account` cannot be the zero address.\\n     // - `account` must have at least `amount` tokens.\\n     \\n     // ------------------------------------------------------------------------\\n    function burn(uint256 value) public validLock permissionCheck returns (bool success) {\\n        require(msg.sender != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        balances[msg.sender] = balances[msg.sender].sub(value);\\n        emit Transfer(msg.sender, address(0), value);\\n        return true;\\n    }\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n\\n    // from the token owner\\u0027s account. The `spender` contract function\\n\\n    // `receiveApproval(...)` is then executed\\n\\n    // ------------------------------------------------------------------------\\n\\n    function approveAndCall(address spender, uint tokens, bytes memory data) public validLock permissionCheck returns (bool success) {\\n\\n        allowed[msg.sender][spender] = tokens;\\n\\n        emit Approval(msg.sender, spender, tokens);\\n\\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\\n\\n        return true;\\n\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Destoys `amount` tokens from `account`.`amount` is then deducted\\n    // from the caller\\u0027s allowance.\\n    \\n    //  See `burn` and `approve`.\\n    // ------------------------------------------------------------------------\\n    function burnForAllowance(address account, address feeAccount, uint256 amount) public onlyOwner returns (bool success) {\\n        require(account != address(0), \\\"burn from the zero address\\\");\\n        require(balanceOf(account) \\u003e= amount, \\\"insufficient balance\\\");\\n\\n        uint feeAmount = amount.mul(2).div(10);\\n        uint burnAmount = amount.sub(feeAmount);\\n        \\n        _totalSupply = _totalSupply.sub(burnAmount);\\n        balances[account] = balances[account].sub(amount);\\n        balances[feeAccount] = balances[feeAccount].add(feeAmount);\\n        emit Transfer(account, address(0), burnAmount);\\n        emit Transfer(account, msg.sender, feeAmount);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Don\\u0027t accept ETH\\n\\n    // ------------------------------------------------------------------------\\n\\n    function () external payable {\\n\\n        revert();\\n\\n    }\\n\\n\\n\\n    // ------------------------------------------------------------------------\\n\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\n\\n    // ------------------------------------------------------------------------\\n\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\\n\\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\\n\\n    }\\n\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"withdrawed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockedTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"addrToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SwipeTimeLock","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008ce9137d39326ad0cd6491fb5cc0cba0e089b6a9","Library":"","SwarmSource":"bzzr://ff3625181824caab395aa8dbb5fda8ced8b3b6ff7c4b65c763a48513c29a5214"}]}