{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.7 <0.6.0;\r\n\r\ncontract SmartLockerRegistrar {\r\n\r\n    // forward registrar\r\n    mapping(address=>bytes32) registrar;\r\n\r\n    // reverse registrar\r\n    mapping(bytes32=>address) reverseRegistrar;\r\n\r\n    // fallback function (external non-payable)\r\n    function() external {}\r\n\r\n    // events\r\n    event SmartLockerCreated(bytes32 name, address smartLockerAddress);\r\n\r\n    // create new smart locker with given name and keyname (external payable)\r\n    function createSmartLocker(bytes32 name, bytes32 keyname) external payable\r\n        returns (address) {\r\n\r\n        // require name not null\r\n        require(name != bytes32(0));\r\n\r\n        // require name not already exist\r\n        require(reverseRegistrar[name] == address(0));\r\n\r\n        // require keyname not null\r\n        require(keyname != bytes32(0));\r\n\r\n        // deploy a new smart locker and send all value\r\n        SmartLocker smartLocker = (new SmartLocker).value(msg.value)(msg.sender, keyname);\r\n\r\n        // register the smart locker address with the given name\r\n        address smartLockerAddress = address(smartLocker);\r\n        registrar[smartLockerAddress] = name;\r\n\r\n        // add corresponding entry to the reverse registrar\r\n        reverseRegistrar[name] = smartLockerAddress;\r\n\r\n        // emit event\r\n        emit SmartLockerCreated(name, smartLockerAddress);\r\n\r\n        // return the smart locker address\r\n        return smartLockerAddress;\r\n    }\r\n\r\n    // get the name of the smart locker with given address (external view)\r\n    function getName(address smartLockerAddress) external view\r\n        returns (bytes32) {\r\n\r\n        return registrar[smartLockerAddress];\r\n    }\r\n\r\n    // get the address of the smart locker with given name (external view)\r\n    function getAddress(bytes32 name) external view\r\n        returns (address) {\r\n\r\n        return reverseRegistrar[name];\r\n    }\r\n}\r\n\r\ncontract SmartLocker {\r\n\r\n    // use ECDSA library for recovering signatures of hashes\r\n    using ECDSA for bytes32;\r\n\r\n    // Key\r\n    struct Key {\r\n        uint256 index;\r\n        bool authorised;\r\n        bytes32 keyname;\r\n        // TODO: other attributes here, e.g. management flag, threshold\r\n    }\r\n\r\n    // keys\r\n    mapping(address=>Key) keys;\r\n\r\n    // authorised key count\r\n    uint256 authorisedKeyCount;\r\n\r\n    // key list\r\n    address[] keyList;\r\n\r\n    // next transaction nonce\r\n    uint256 nextNonce;\r\n\r\n    // events\r\n    event KeyAdded(address key, bytes32 keyname);\r\n    event KeyRemoved(address key);\r\n    event KeyUpdated(address key, bytes32 keyname);\r\n    event SignedExecuted(address from, address to, uint value, bytes data, uint256 nonce, uint gasPrice, uint gasLimit, bytes result);\r\n\r\n    // only authorised keys or self modifier\r\n    modifier onlyAuthorisedKeysOrSelf(address sender) {\r\n\r\n        require(keys[sender].authorised || sender == address(this));\r\n        _;\r\n    }\r\n\r\n    // fallback function (payable)\r\n    function() external payable {}\r\n\r\n    // constructor with given key and keyname (public payable)\r\n    constructor(address key, bytes32 keyname) public payable {\r\n\r\n        // require key not null\r\n        require(key != address(0));\r\n\r\n        // require keyname not null\r\n        require(keyname != bytes32(0));\r\n\r\n        // add the key\r\n        _addKey(key, keyname);\r\n    }\r\n\r\n    // add authorisation for given key and keyname (external)\r\n    function addKey(address key, bytes32 keyname) external\r\n        onlyAuthorisedKeysOrSelf(msg.sender) {\r\n\r\n        // require key not null\r\n        require(key != address(0));\r\n\r\n        // require key not already authorised\r\n        require(!keys[key].authorised);\r\n\r\n        // require keyname not null\r\n        require(keyname != bytes32(0));\r\n\r\n        // add the key\r\n        _addKey(key, keyname);\r\n    }\r\n\r\n    // add authorisation for given key and keyname (internal)\r\n    function _addKey(address key, bytes32 keyname) internal {\r\n\r\n        // add the key as an authorised key\r\n        keys[key].index = keyList.length;\r\n        keys[key].authorised = true;\r\n        keys[key].keyname = keyname;\r\n        authorisedKeyCount++;\r\n\r\n        // add to the key list\r\n        keyList.push(key);\r\n\r\n        // emit event\r\n        emit KeyAdded(key, keyname);\r\n    }\r\n\r\n    // remove authorisation for given key (external)\r\n    function removeKey(address key) external\r\n        onlyAuthorisedKeysOrSelf(msg.sender) {\r\n\r\n        // require key already authorised\r\n        require(keys[key].authorised);\r\n\r\n        // require key not the only authorised key\r\n        require(authorisedKeyCount > 1);\r\n\r\n        // remove the key as an authorised key\r\n        keys[key].authorised = false;\r\n        authorisedKeyCount--;\r\n\r\n        // delete from the key list\r\n        delete keyList[keys[key].index];\r\n\r\n        // emit event\r\n        emit KeyRemoved(key);\r\n    }\r\n\r\n    // update the given key (external)\r\n    function updateKey(address key, bytes32 keyname) external\r\n        onlyAuthorisedKeysOrSelf(msg.sender) {\r\n\r\n        // require keyname not null\r\n        require(keyname != bytes32(0));\r\n\r\n        // update the key\r\n        keys[key].keyname = keyname;\r\n        // TODO: other attributes here, e.g. management flag, threshold\r\n\r\n        // emit event\r\n        emit KeyUpdated(key, keyname);\r\n    }\r\n\r\n    // execute transactions if signed by authorised keys (external)\r\n    function executeSigned(address to, uint value, bytes calldata data, uint gasPrice, uint gasLimit, bytes calldata signature) external\r\n        onlyAuthorisedKeysOrSelf(_recoverSigner(address(this), to, value, data, nextNonce, gasPrice, gasLimit, signature))\r\n        returns (bytes memory) {\r\n\r\n        // measure initial gas\r\n        uint256 gasUsed = gasleft();\r\n\r\n        // execute the transaction\r\n        (bool success, bytes memory result) = to.call.value(value)(data);\r\n\r\n        // calculate gas used\r\n        gasUsed = gasUsed - gasleft();\r\n\r\n        // require success\r\n        require(success);\r\n\r\n        // require gas used not over gas limit\r\n        require(gasUsed <= gasLimit);\r\n\r\n        // emit event\r\n        emit SignedExecuted(address(this), to, value, data, nextNonce, gasPrice, gasLimit, result);\r\n\r\n        // update the nonce\r\n        nextNonce++;\r\n\r\n        // refund the gas used plus overhead of 40,000 and 68 for each input byte\r\n        msg.sender.transfer((gasUsed + 40000 + (msg.data.length * 68)) * gasPrice);\r\n\r\n        // return the result\r\n        return result;\r\n    }\r\n\r\n    // recover the signer of a signed message (internal pure)\r\n    function _recoverSigner(address from, address to, uint value, bytes memory data, uint256 nonce, uint gasPrice, uint gasLimit, bytes memory signature) internal pure\r\n        returns (address) {\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(from, to, value, data, nonce, gasPrice, gasLimit));\r\n        return hash.toEthSignedMessageHash().recover(signature);\r\n    }\r\n\r\n    // is the given key an authorised key (external view)\r\n    function isAuthorisedKey(address key) external view\r\n        returns (bool) {\r\n\r\n        return keys[key].authorised;\r\n    }\r\n\r\n    // get the given key (external view)\r\n    function getKey(address key) external view\r\n        returns (bytes32) {\r\n\r\n        return keys[key].keyname;\r\n        // TODO: other attributes here, e.g. management flag, threshold\r\n    }\r\n\r\n    // get the count of keys (external view)\r\n    function getAuthorisedKeyCount() external view\r\n        returns (uint256) {\r\n\r\n        return authorisedKeyCount;\r\n    }\r\n\r\n    // get the key list (external view)\r\n    function getKeyList() external view\r\n        returns (address[] memory) {\r\n\r\n        return keyList;\r\n    }\r\n\r\n    // get the next execution nonce (external view)\r\n    function getNextNonce() external view\r\n        returns (uint256) {\r\n\r\n        return nextNonce;\r\n    }\r\n}\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"smartLockerAddress\",\"type\":\"address\"}],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"keyname\",\"type\":\"bytes32\"}],\"name\":\"createSmartLocker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"smartLockerAddress\",\"type\":\"address\"}],\"name\":\"SmartLockerCreated\",\"type\":\"event\"}]","ContractName":"SmartLockerRegistrar","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://43270a57dc1aab031c1f316135f3688a95f4f9f7a709ccb8ad3a7b1a1ecdd44e"}]}