{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.9;\r\n\r\n// See: https://github.com/ricmoo/Takoyaki\r\n\r\n/////////////////////////////\r\n// ENS Interfaces\r\n\r\ninterface Resolver {\r\n    function addr(bytes32 node) external view returns (address);\r\n    function setAddr(bytes32 node, address addr) external;\r\n}\r\n\r\ninterface ReverseRegistrar {\r\n    function claim(address owner) external returns (bytes32 node);\r\n}\r\n\r\ninterface AbstractENS {\r\n    function owner(bytes32 node) external view returns(address);\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function resolver(bytes32 node) view external returns (address);\r\n}\r\n\r\n\r\n/////////////////////////////\r\n// ERC-721 Interfaces\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator,\r\n                              address from,\r\n                              uint256 tokenId,\r\n                              bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n\r\n/////////////////////////////\r\n// Takoyaki Registrar\r\n\r\ncontract TakoyakiRegistrar {\r\n\r\n    /////////////////////////////\r\n    // Constants\r\n\r\n    // namehash('addr.reverse')\r\n    bytes32 constant NODE_RR = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    // Must commit between (inclusive) 4 blocks (1 minute) and 5760 blocks (1 day)\r\n    // Cancelling must wait for 1 hour after the commitment expired\r\n    uint48 constant MIN_COMMIT_BLOCKS   = (60 / 15);             /*!Test: MIN_COMMIT_BLOCKS = \"(60 / 15)\" */\r\n    uint48 constant MAX_COMMIT_BLOCKS   = (24 * 60 * 60 / 15);   /*!Test: MAX_COMMIT_BLOCKS = \"(24 * 60 * 60 / 15)\" */\r\n    uint48 constant WAIT_CANCEL_BLOCKS  = (60 * 60 / 15);        /*!Test: WAIT_CANCEL_BLOCKS = \"(60 * 60 / 15)\" */\r\n\r\n\r\n    // A registration lasts for 1 year (a little extra for leap years) and\r\n    // once expired is available to ONLY to the owner for an additional 30 days\r\n    uint48 constant REGISTRATION_PERIOD    = (366 days);         /*!Test: REGISTRATION_PERIOD = \"(366 days)\" */\r\n    uint48 constant GRACE_PERIOD           = (30 days);          /*!Test: GRACE_PERIOD = \"(30 days)\" */\r\n\r\n\r\n    /////////////////////////////\r\n    // Structs\r\n\r\n    struct Commitment {\r\n        // The block number this commitment was made\r\n        uint48 blockNumber;\r\n\r\n        // These are used only for refunds\r\n        address payable payer;\r\n        uint256 feePaid;\r\n    }\r\n\r\n    struct Takoyaki {\r\n        uint48 expires;\r\n        uint48 commitBlockNumber;\r\n        uint48 revealBlockNumber;\r\n        address owner;\r\n        address approved;\r\n        uint256 upkeepFee;\r\n        bytes32 revealedSalt;\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    // Events\r\n\r\n    // Registrar\r\n    event Committed(address indexed funder, bytes32 commitment);\r\n    event Cancelled(address indexed funder, bytes32 commitment);\r\n    event Registered(address indexed owner, uint256 indexed tokenId, string label, uint48 expires);\r\n    event Renewed(address indexed owner, uint256 indexed tokenId, uint48 expires);\r\n\r\n    // ERC-721\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\r\n    /////////////////////////////\r\n    // State Variables\r\n\r\n    // Admin address\r\n    address payable private _admin;\r\n\r\n    // ENS Configuration\r\n    AbstractENS private _ens;\r\n    bytes32 private _nodehash;\r\n    Resolver private _defaultResolver;\r\n\r\n    // The fee per registration period\r\n    uint256 private _fee = (0.1 ether);\r\n\r\n    // The commitments\r\n    mapping (bytes32 => Commitment) private _commitments;\r\n\r\n    // Each Takoyaki by its labelHash (id)\r\n    mapping (uint256 => Takoyaki) private _takoyaki;\r\n\r\n    // Balances (token count) for each owner\r\n    mapping (address => uint256) private _balances;\r\n\r\n    // Approval All approvals\r\n    mapping (address => mapping (address => bool)) private _approveAll;\r\n\r\n    uint256 private _totalSupply = 0;\r\n\r\n\r\n    /////////////////////////////\r\n    // Constructor\r\n\r\n    constructor(address ens, bytes32 nodehash, address defaultResolver) public {\r\n        _ens = AbstractENS(ens);\r\n        _nodehash = nodehash;\r\n        _defaultResolver = Resolver(defaultResolver);\r\n\r\n        _admin = msg.sender;\r\n\r\n        // Give the admin access to the reverse entry\r\n        ReverseRegistrar(_ens.owner(NODE_RR)).claim(_admin);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Admin functions\r\n\r\n    function setAdmin(address payable newAdmin) external {\r\n        require(msg.sender == _admin);\r\n        _admin = newAdmin;\r\n\r\n        // Give the admin access to the reverse entry\r\n        ReverseRegistrar(_ens.owner(NODE_RR)).claim(_admin);\r\n    }\r\n\r\n    function setFee(uint newFee) external {\r\n        require(msg.sender == _admin);\r\n        _fee = newFee;\r\n    }\r\n\r\n    function setResolver(address newResolver) external {\r\n        require(msg.sender == _admin);\r\n        _defaultResolver = Resolver(newResolver);\r\n    }\r\n\r\n    function withdraw(uint256 amount) external {\r\n        require(msg.sender == _admin);\r\n        _admin.transfer(amount);\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    // Getters for internal variables\r\n\r\n    function ens() external view returns (address) { return address(_ens); }\r\n    function nodehash() external view returns (bytes32) { return _nodehash; }\r\n\r\n    function admin() external view returns (address) { return _admin; }\r\n    function defaultResolver() external view returns (address) { return address(_defaultResolver); }\r\n    function fee() external view returns (uint256) { return _fee; }\r\n\r\n    // ERC-721\r\n    function totalSupply() external view returns (uint256) { return _totalSupply; }\r\n    function name() external pure returns (string memory) { return \"Takoyaki\"; }\r\n    function symbol() external pure returns (string memory) { return \"TAKO\"; }\r\n    function decimals() external pure returns (uint8) { return 0; }\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n        Takoyaki memory takoyaki = _takoyaki[_tokenId];\r\n        require(takoyaki.expires > now);\r\n\r\n        string memory uri = \"https://takoyaki.cafe/json/_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\";\r\n\r\n        // Offset into the URI to replace. Skips\r\n        //  - the length prefix (32 bytes)\r\n        //  - the \"https://takoyaki.cafe/json/\" (27 bytes)\r\n        uint offset = 0;\r\n        assembly { offset := add(uri, 59) }\r\n\r\n        // ASCII hexidecimal character lookup table\r\n        uint hexLut = 0x3031323334353637383961626364656667000000000000000000000000000000;\r\n\r\n        for (uint i = 0; i < 32; i++) {\r\n            assembly {\r\n                let value := byte(i, _tokenId)\r\n\r\n                mstore8(offset, byte(shr(4, value), hexLut))\r\n                offset := add(offset, 1)\r\n\r\n                mstore8(offset, byte(and(value, 0x0f), hexLut))\r\n                offset := add(offset, 1)\r\n            }\r\n        }\r\n\r\n        return uri;\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Label functions\r\n\r\n    function fee(string calldata label) external view returns (uint256) {\r\n        require(isValidLabel(label));\r\n        return _fee;\r\n    }\r\n\r\n    // A label is measured in bytes (not characters). A label must not begin\r\n    // with a \"0x\" prefix (in either lowercase or uppercase).\r\n    // Otherwise, valid UTF-8 data and namehash normalization (i.e. lowercase pnly)\r\n    // is expected to be verified by the client.\r\n    function isValidLabel(string memory label) public pure returns (bool) {\r\n        bytes memory data = bytes(label);\r\n\r\n        // Names MUST be between 1 byte and 20 bytes (inclusive)\r\n        if (data.length < 1 || data.length > 20) { return false; }\r\n\r\n        // Names MUST NOT start with \"0x\" or \"0X\"\r\n        if (data.length >= 2 && data[0] == 0x30 && (data[1] | 0x20) == 0x78) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    // Commit/Reveal functions\r\n\r\n    function makeBlindedCommitment(string memory label, address owner, bytes32 salt) public view returns (bytes32) {\r\n        return keccak256(abi.encode(label, owner, salt));\r\n    }\r\n\r\n    function getBlindedCommit(bytes32 blindedCommit) public view returns (uint48 blockNumber, address payer, uint256 feePaid) {\r\n        Commitment memory commitment = _commitments[blindedCommit];\r\n        return (commitment.blockNumber, commitment.payer, commitment.feePaid);\r\n    }\r\n\r\n    function commit(bytes32 blindedCommit, address payable prefundRevealer, uint prefundAmount) external payable {\r\n        require(msg.value == _fee + prefundAmount);\r\n\r\n        Commitment storage commitment = _commitments[blindedCommit];\r\n        require(commitment.payer == address(0));\r\n\r\n        commitment.blockNumber = uint48(block.number);\r\n\r\n        commitment.payer = msg.sender;\r\n        commitment.feePaid = _fee;\r\n\r\n        if (prefundAmount > 0) {\r\n            prefundRevealer.transfer(prefundAmount);\r\n        }\r\n\r\n        emit Committed(msg.sender, blindedCommit);\r\n    }\r\n\r\n    // A commitment may be cancelled and the committed funds will be returned.\r\n    // If the registrar was recently withdrawn from (by the admin) the balance\r\n    // may be too low, so we revert, allowing them to try in the future once\r\n    // more funds have been accumulated (if this happens to you, you may also\r\n    // e-mail us to help out; support@ethers.io).\r\n    function cancelCommitment(bytes32 blindedCommit) external {\r\n        Commitment memory commitment = _commitments[blindedCommit];\r\n        require(commitment.feePaid <= address(this).balance);\r\n        require(commitment.payer == msg.sender);\r\n        require(block.number >= commitment.blockNumber + MAX_COMMIT_BLOCKS + WAIT_CANCEL_BLOCKS);\r\n\r\n        delete _commitments[blindedCommit];\r\n\r\n        commitment.payer.transfer(commitment.feePaid);\r\n\r\n        emit Cancelled(msg.sender, blindedCommit);\r\n    }\r\n\r\n    function reveal(string calldata label, address owner, bytes32 salt) external {\r\n        require(owner != address(0));\r\n\r\n        bytes32 blindedCommit = makeBlindedCommitment(label, owner, salt);\r\n\r\n        Commitment memory commitment = _commitments[blindedCommit];\r\n        require(block.number <= commitment.blockNumber + MAX_COMMIT_BLOCKS);\r\n        require(block.number >= commitment.blockNumber + MIN_COMMIT_BLOCKS);\r\n\r\n        // Name must be valid\r\n        require(isValidLabel(label));\r\n\r\n        // Clear the precommit\r\n        delete _commitments[blindedCommit];\r\n\r\n        uint256 tokenId = uint256(keccak256(bytes(label)));\r\n        Takoyaki storage takoyaki = _takoyaki[tokenId];\r\n\r\n        if (takoyaki.expires == 0) {\r\n            // Never registered; increase the total supply\r\n            _totalSupply += 1;\r\n        } else {\r\n            // Was previously owned, but has expired (incuding grace period)\r\n            require(takoyaki.expires < now - GRACE_PERIOD);\r\n\r\n            // Was previously owned by the another address; adjust balances\r\n            _balances[takoyaki.owner] -= 1;\r\n        }\r\n\r\n        // Update the takoyaki info; note: registering an expired takoyaki\r\n        // obliterates its former existance and it is reborn\r\n        takoyaki.expires = uint48(now + REGISTRATION_PERIOD);\r\n        takoyaki.commitBlockNumber = commitment.blockNumber;\r\n        takoyaki.revealBlockNumber = uint48(block.number);\r\n        takoyaki.revealedSalt = keccak256(abi.encode(tokenId, salt));\r\n        takoyaki.owner = owner;\r\n        takoyaki.upkeepFee = commitment.feePaid;\r\n        takoyaki.approved = address(0);\r\n\r\n        _balances[owner] += 1;\r\n\r\n        // ENS node\r\n        bytes32 nodehash = keccak256(abi.encode(_nodehash, tokenId));\r\n\r\n        // Make this registrar the owner (so we can set it up before giving it away)\r\n        _ens.setSubnodeOwner(_nodehash, bytes32(tokenId), address(this));\r\n\r\n        // Set up the default resolver and point to the sender\r\n        _ens.setResolver(nodehash, address(_defaultResolver));\r\n        _defaultResolver.setAddr(nodehash, owner);\r\n\r\n        // Now give it to the new owner\r\n        _ens.setOwner(nodehash, owner);\r\n\r\n        emit Registered(owner, tokenId, label, takoyaki.expires);\r\n        emit Transfer(address(0), owner, tokenId);\r\n    }\r\n\r\n    // Not really necessary, but maybe someone wants to keep totalSupply correct\r\n    // or really hates a specific Takoyaki\r\n    function destroy(uint256 tokenId) external {\r\n        Takoyaki memory takoyaki = _takoyaki[tokenId];\r\n        require(takoyaki.owner != address(0));\r\n        require(takoyaki.expires < now - GRACE_PERIOD);\r\n\r\n        _balances[takoyaki.owner] -= 1;\r\n\r\n        delete _takoyaki[tokenId];\r\n\r\n        _totalSupply -= 1;\r\n        _ens.setSubnodeOwner(_nodehash, bytes32(tokenId), address(0));\r\n\r\n        emit Transfer(takoyaki.owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     *  Allow a Takoyaki owner to lock-in the current upkeep fee, if it\r\n     *  is lower than their current upkeep fee.\r\n     *\r\n     *  Anyone may call this.\r\n     */\r\n    function syncUpkeepFee(uint256 tokenId) external {\r\n        Takoyaki storage takoyaki = _takoyaki[tokenId];\r\n        require(takoyaki.owner != address(0));\r\n        require(takoyaki.expires > now);\r\n\r\n        // If the fee has decreased, set this Takoyyaki as the new lower fee\r\n        if (_fee < takoyaki.upkeepFee) { takoyaki.upkeepFee = _fee; }\r\n    }\r\n\r\n\r\n    // A Takoyaki has an upkeep cost. The upkeep will never be more than the\r\n    // fee originally paid for a takoyaki, but if the fee has decreased, the\r\n    // new (lower) fee is set as the new fee.\r\n    function renew(uint256 tokenId) external payable {\r\n\r\n        Takoyaki storage takoyaki = _takoyaki[tokenId];\r\n        require(takoyaki.owner != address(0));\r\n\r\n        // Must not be expired or outside of grace period\r\n        require(takoyaki.expires > (now - GRACE_PERIOD));\r\n\r\n        // If the fee has decreased, set this Takoyaki upkeep fee as the new lower fee\r\n        if (_fee < takoyaki.upkeepFee) { takoyaki.upkeepFee = _fee; }\r\n\r\n        require(msg.value == takoyaki.upkeepFee);\r\n\r\n        // Prevent super long registration; upkeep must be semi-periodic\r\n        require(takoyaki.expires < now + (2 * REGISTRATION_PERIOD));\r\n\r\n        // Extend by the registration period\r\n        takoyaki.expires += REGISTRATION_PERIOD;\r\n\r\n        emit Renewed(takoyaki.owner, tokenId, takoyaki.expires);\r\n    }\r\n\r\n    // Reset the registrant as the controller\r\n    function reclaim(uint256 tokenId, address owner) external {\r\n        Takoyaki memory takoyaki = _takoyaki[tokenId];\r\n        require(msg.sender == takoyaki.owner && takoyaki.expires > now);\r\n\r\n        _ens.setSubnodeOwner(_nodehash, bytes32(tokenId), owner);\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    // Takoyaki functions\r\n\r\n    // Used to derive the appearance and metadata of the Takoyaki\r\n    // - The revealedSalt + blockhash(commitBlockNumber + X) is used for the appearance\r\n    // - The revealBlockNumber simplifies clients attempting to lookup the unhashed label\r\n    // - The expires date is useful for UI\r\n    // - The status has more information about the current registration status\r\n    function getTakoyaki(uint256 tokenId) external view returns (bytes32 revealSeed, address owner, uint256 upkeepFee, uint48 commitBlock, uint48 revealBlock, uint48 expires, uint8 status) {\r\n\r\n        // Status:\r\n        //  0: Available\r\n        //  1: Grace period\r\n        //  2: Registered\r\n        uint8 status = 2;\r\n        if (_takoyaki[tokenId].expires < now - GRACE_PERIOD) {\r\n            status = 0;\r\n        } else if (_takoyaki[tokenId].expires < now) {\r\n            status = 1;\r\n        }\r\n\r\n        Takoyaki storage takoyaki = _takoyaki[tokenId];\r\n        return (takoyaki.revealedSalt,\r\n                takoyaki.owner,\r\n                takoyaki.upkeepFee,\r\n                takoyaki.commitBlockNumber,\r\n                takoyaki.revealBlockNumber,\r\n                takoyaki.expires,\r\n                status);\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    // ERC-721 Implementation\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        Takoyaki memory takoyaki = _takoyaki[tokenId];\r\n        require(takoyaki.expires > now);\r\n        return takoyaki.owner;\r\n    }\r\n\r\n    // Note: Expired tokens will still count towards the balance; use destroy to sync\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _balances[owner];\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) external {\r\n        Takoyaki storage takoyaki = _takoyaki[tokenId];\r\n        //require(takoyaki.owner != to);  Why does the OpenZepplin implementation assert this?\r\n        require(msg.sender == takoyaki.owner || isApprovedForAll(takoyaki.owner, msg.sender));\r\n        require(takoyaki.expires > now);\r\n\r\n        takoyaki.approved = to;\r\n\r\n        emit Approval(takoyaki.owner, to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address) {\r\n        Takoyaki memory takoyaki = _takoyaki[tokenId];\r\n        // I think there is a bug in the OpenZepplin implt; it throws if the address is\r\n        // zero, but the ERC-721 spec speficies 0 is valid to indicate no approved...\r\n        require(takoyaki.expires > now);\r\n        return takoyaki.approved;\r\n    }\r\n\r\n    function setApprovalForAll(address to, bool approved) external {\r\n        //require(to != msg.sender);  Why does OpenZepplin enforce this?\r\n        _approveAll[msg.sender][to] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _approveAll[owner][operator];\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(to != address(0));\r\n\r\n        Takoyaki storage takoyaki = _takoyaki[tokenId];\r\n        require(takoyaki.owner == from);\r\n        require(takoyaki.expires > now);\r\n        require(msg.sender == takoyaki.owner ||\r\n                msg.sender == takoyaki.approved ||\r\n                isApprovedForAll(takoyaki.owner, msg.sender));\r\n\r\n        if (takoyaki.owner != to) {\r\n            _balances[takoyaki.owner] -= 1;\r\n            _balances[to] += 1;\r\n        }\r\n\r\n        emit Transfer(takoyaki.owner, to, tokenId);\r\n\r\n        takoyaki.owner = to;\r\n        takoyaki.approved = address(0);\r\n\r\n        // @TODO: Should we do this for a transfer??\r\n\r\n        bytes32 nodehash = keccak256(abi.encode(_nodehash, tokenId));\r\n\r\n        // Make this registrar the owner (so we can set it up before giving it away)\r\n        _ens.setSubnodeOwner(_nodehash, bytes32(tokenId), address(this));\r\n\r\n        // Set up the default resolver and point to the sender\r\n        _ens.setResolver(nodehash, address(_defaultResolver));\r\n        _defaultResolver.setAddr(nodehash, to);\r\n\r\n        // Now give it to the new owner\r\n        _ens.setOwner(nodehash, to);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    // ERC-721 Safe Transfer: 0x150b7a02\r\n    bytes4 constant private ERC721_TOKEN_RECEIVER_ID = bytes4(\r\n        keccak256(\"onERC721Received(address,address,uint256,bytes)\")\r\n    );\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n\r\n        // If there is a contract currently at this address, call its\r\n        // onERC721Received method and make sure it returns\r\n        uint256 codeSize;\r\n        assembly { codeSize := extcodesize(to) }\r\n        if (codeSize > 0) {\r\n            bytes4 result = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n\r\n            // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\r\n            require(result == ERC721_TOKEN_RECEIVER_ID);\r\n        }\r\n    }\r\n\r\n    /////////////////////////////\r\n    // ERC-165\r\n\r\n    // ERC-165: 0x01ffc9a7\r\n    bytes4 constant private INTERFACE_META_ID = bytes4(\r\n        keccak256(\"supportsInterface(bytes4)\")\r\n    );\r\n\r\n    // ERC-721: 0x80ac58cd\r\n    bytes4 constant private ERC721_ID = bytes4(\r\n        keccak256(\"balanceOf(address)\") ^\r\n        keccak256(\"ownerOf(uint256)\") ^\r\n        keccak256(\"approve(address,uint256)\") ^\r\n        keccak256(\"getApproved(uint256)\") ^\r\n        keccak256(\"setApprovalForAll(address,bool)\") ^\r\n        keccak256(\"isApprovedForAll(address,address)\") ^\r\n        keccak256(\"transferFrom(address,address,uint256)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\r\n    );\r\n\r\n    // ERC-721 Metadata Extension: 0x5b5e139f\r\n    bytes4 constant private ERC721_METAEXT_ID = bytes4(\r\n        keccak256(\"name()\") ^\r\n        keccak256(\"symbol()\") ^\r\n        keccak256(\"tokenURI(uint256)\")\r\n    );\r\n\r\n    // ENS Registrar Extension: 0x28ed4f6c\r\n    // See: https://github.com/ensdomains/ethregistrar/blob/master/contracts/BaseRegistrarImplementation.sol#L27\r\n    bytes4 constant private RECLAIM_ID = bytes4(\r\n        keccak256(\"reclaim(uint256,address)\")\r\n    );\r\n\r\n    // ERC-165\r\n    function supportsInterface(bytes4 interfaceID) public view returns (bool) {\r\n        return (\r\n            interfaceID == INTERFACE_META_ID     ||\r\n            interfaceID == ERC721_ID             ||\r\n            interfaceID == ERC721_METAEXT_ID     ||\r\n            interfaceID == RECLAIM_ID\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"string\"}],\"name\":\"isValidLabel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"reclaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTakoyaki\",\"outputs\":[{\"name\":\"revealSeed\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"upkeepFee\",\"type\":\"uint256\"},{\"name\":\"commitBlock\",\"type\":\"uint48\"},{\"name\":\"revealBlock\",\"type\":\"uint48\"},{\"name\":\"expires\",\"type\":\"uint48\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"string\"}],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blindedCommit\",\"type\":\"bytes32\"}],\"name\":\"getBlindedCommit\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint48\"},{\"name\":\"payer\",\"type\":\"address\"},{\"name\":\"feePaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newResolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blindedCommit\",\"type\":\"bytes32\"},{\"name\":\"prefundRevealer\",\"type\":\"address\"},{\"name\":\"prefundAmount\",\"type\":\"uint256\"}],\"name\":\"commit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"renew\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultResolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nodehash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blindedCommit\",\"type\":\"bytes32\"}],\"name\":\"cancelCommitment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"syncUpkeepFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"makeBlindedCommitment\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"reveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ens\",\"type\":\"address\"},{\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"name\":\"defaultResolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"Committed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"label\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint48\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint48\"}],\"name\":\"Renewed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"TakoyakiRegistrar","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b47e2429823c52aeceeb1d837af43ce401f8edd68eb87d2637c71556d8eda87fc000000000000000000000000d3ddccdd3b25a8a7423b5bee360a42146eb4baf3","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://024e1fea542e6b83bc4d7c5f00ffbee8ac778f34500fcbe8e3c94d2c05bed5cf"}]}