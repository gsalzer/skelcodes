{"status":"1","message":"OK","result":[{"SourceCode":"// File: zos-lib/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: zos-lib/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\r\n */\r\ncontract ZOSLibOwnable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/AvatarNameStorage.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ERC20Interface {\r\n    function balanceOf(address from) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function burn(uint256 amount) public;\r\n}\r\n\r\ncontract AvatarNameStorage {\r\n    // Storage\r\n    ERC20Interface public manaToken;\r\n    uint256 public price;\r\n\r\n    struct Data {\r\n        string username;\r\n        string metadata;\r\n    }\r\n\r\n    // Stores usernames used\r\n    mapping (string => address) usernames;\r\n    // Stores account data\r\n    mapping (address => Data) public user;\r\n    // Stores account roles\r\n    mapping (address => bool) public allowed;\r\n\r\n    // Events\r\n    event Register(\r\n        address indexed _owner,\r\n        string _username,\r\n        string _metadata,\r\n        address indexed _caller\r\n    );\r\n    event MetadataChanged(address indexed _owner, string _metadata);\r\n    event Allow(address indexed _caller, address indexed _account, bool _allowed);\r\n}\r\n\r\n// File: contracts/AvatarNameRegistry.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract AvatarNameRegistry is ZOSLibOwnable, Initializable, AvatarNameStorage {\r\n\r\n    /**\r\n    * @dev Initializer of the contract\r\n    * @param _mana - address of the mana token\r\n    * @param _owner - address of the owner allowed to register usernames and assign the role\r\n    */\r\n    function initialize(\r\n        ERC20Interface _mana,\r\n        address _owner\r\n    )\r\n    public initializer\r\n    {\r\n        manaToken = _mana;\r\n        price = 100000000000000000000; // 100 in wei\r\n\r\n        // Allow owner to register usernames\r\n        allowed[_owner] = true;\r\n\r\n        // Owner\r\n        _transferOwnership(_owner);\r\n    }\r\n\r\n    /**\r\n    * @dev Check if the sender is an allowed account\r\n    */\r\n    modifier onlyAllowed() {\r\n        require(\r\n            allowed[msg.sender] == true,\r\n            \"The sender is not allowed to register a username\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Manage role for an account\r\n    * @param _account - address of the account to be managed\r\n    * @param _allowed - bool whether the account should be allowed or not\r\n    */\r\n    function setAllowed(address _account, bool _allowed) external onlyOwner {\r\n        require(_account != msg.sender, \"You can not manage your role\");\r\n        allowed[_account] = _allowed;\r\n        emit Allow(msg.sender, _account, _allowed);\r\n    }\r\n\r\n    /**\r\n    * @dev Register a usename\r\n    * @notice that the username should be less than or equal 32 bytes and blanks are not allowed\r\n    * @param _beneficiary - address of the account to be managed\r\n    * @param _username - string for the username\r\n    * @param _metadata - string for the metadata\r\n    */\r\n    function _registerUsername(\r\n        address _beneficiary,\r\n        string memory _username,\r\n        string memory _metadata\r\n    )\r\n    internal\r\n    {\r\n        _requireBalance(_beneficiary);\r\n        _requireUsernameValid(_username);\r\n        require(isUsernameAvailable(_username), \"The username was already taken\");\r\n\r\n        manaToken.transferFrom(_beneficiary, address(this), price);\r\n        manaToken.burn(price);\r\n\r\n        // Save username\r\n        usernames[_username] = _beneficiary;\r\n\r\n        Data storage data = user[_beneficiary];\r\n\r\n        // Free previous username\r\n        delete usernames[data.username];\r\n\r\n        // Set data\r\n        data.username = _username;\r\n\r\n        bytes memory metadata = bytes(_metadata);\r\n        if (metadata.length > 0) {\r\n            data.metadata = _metadata;\r\n        }\r\n\r\n        emit Register(\r\n            _beneficiary,\r\n            _username,\r\n            data.metadata,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Register a usename\r\n    * @notice that the username can only be registered by an allowed account\r\n    * @param _beneficiary - address of the account to be managed\r\n    * @param _username - string for the username\r\n    * @param _metadata - string for the metadata\r\n    */\r\n    function registerUsername(\r\n        address _beneficiary,\r\n        string calldata _username,\r\n        string calldata _metadata\r\n    )\r\n    external\r\n    onlyAllowed\r\n    {\r\n        _registerUsername(_beneficiary, _username, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @dev Set metadata for an existing user\r\n    * @param _metadata - string for the metadata\r\n    */\r\n    function setMetadata(string calldata _metadata) external {\r\n        require(userExists(msg.sender), \"The user does not exist\");\r\n\r\n        user[msg.sender].metadata = _metadata;\r\n        emit MetadataChanged(msg.sender, _metadata);\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether a user exist or not\r\n    * @param _user - address for the user\r\n    * @return bool - whether the user exist or not\r\n    */\r\n    function userExists(address _user) public view returns (bool) {\r\n        Data memory data = user[_user];\r\n        bytes memory username = bytes(data.username);\r\n        return username.length > 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether a username is available or not\r\n    * @param _username - string for the username\r\n    * @return bool - whether the username is available or not\r\n    */\r\n    function isUsernameAvailable(string memory _username) public view returns (bool) {\r\n        return usernames[_username] == address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Validate a username\r\n    * @param _username - string for the username\r\n    */\r\n    function _requireUsernameValid(string memory _username) internal pure {\r\n        bytes memory tempUsername = bytes(_username);\r\n        require(tempUsername.length <= 15, \"Username should be less than or equal 15 characters\");\r\n        for(uint256 i = 0; i < tempUsername.length; i++) {\r\n            require(tempUsername[i] > 0x20, \"Invalid Character\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Validate if a user has balance and the contract has enough allowance\r\n    * to use user MANA on his belhalf\r\n    * @param _user - address of the user\r\n    */\r\n    function _requireBalance(address _user) internal view {\r\n        require(\r\n            manaToken.balanceOf(_user) >= price,\r\n            \"Insufficient funds\"\r\n        );\r\n        require(\r\n            manaToken.allowance(_user, address(this)) >= price,\r\n            \"The contract is not authorized to use MANA on sender behalf\"\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mana\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manaToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"name\":\"username\",\"type\":\"string\"},{\"name\":\"metadata\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"registerUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"isUsernameAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_username\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_metadata\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_metadata\",\"type\":\"string\"}],\"name\":\"MetadataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"Allow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AvatarNameRegistry","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7f5cb20377aa9c321788a927e625d4ad6cabb710ae2233704a08a0f491a2cb06"}]}