{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaEscapeHatchRegistryInterface {\r\n  // Fire an event when an escape hatch is set or removed.\r\n  event EscapeHatchModified(\r\n    address indexed smartWallet, address oldEscapeHatch, address newEscapeHatch\r\n  );\r\n\r\n  // Fire an event when an escape hatch is permanently disabled.\r\n  event EscapeHatchDisabled(address smartWallet);\r\n\r\n  // Store the escape hatch account, as well as a flag indicating if the escape\r\n  // hatch has been disabled, for each smart wallet that elects to set one.\r\n  struct EscapeHatch {\r\n    address escapeHatch;\r\n    bool disabled;\r\n  }\r\n\r\n  function setEscapeHatch(address newEscapeHatch) external;\r\n\r\n  function removeEscapeHatch() external;\r\n\r\n  function permanentlyDisableEscapeHatch() external;\r\n\r\n  function getEscapeHatch() external view returns (\r\n    bool exists, address escapeHatch\r\n  );\r\n\r\n  function getEscapeHatchForSmartWallet(\r\n    address smartWallet\r\n  ) external view returns (bool exists, address escapeHatch);\r\n\r\n  function hasDisabledEscapeHatchForSmartWallet(\r\n    address smartWallet\r\n  ) external view returns (bool disabled);\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaEscapeHatchRegistry\r\n * @author 0age\r\n * @notice The Dharma Escape Hatch Registry is an autonomous contract to store\r\n * opt-in \"escape hatch\" accounts for Dharma Smart Wallets. A designated escape\r\n * hatch account can bypass all controls on the smart wallet and directly access\r\n * funds. Furthermore, the Adharma Smart Wallet implementation will give full\r\n * control to the escape hatch account, rather than the user's key ring, if one\r\n * is currently set on the registry. Smart wallets can register an escape hatch\r\n * account by calling `setEscapeHatch` on the registry from a given smart wallet\r\n * or remove a registered escape hatch account by calling `removeEscapeHatch`.\r\n * Smart wallets can also be permanently disable the escape hatch mechanism by\r\n * calling `permanentlyDisableEscapeHatch`. The escape hatch registry will emit\r\n * `EscapeHatchModified` events whenever an escape hatch has been altered, and\r\n * `EscapeHatchDisabled` whenever a smart wallet disables the escape hatch\r\n * mechanism.\r\n */\r\ncontract DharmaEscapeHatchRegistry is DharmaEscapeHatchRegistryInterface {\r\n  // Track escape hatches for each account.\r\n  mapping(address => EscapeHatch) private _escapeHatches;\r\n\r\n  /**\r\n   * @notice Enable a fallback that will return the escape hatch address for the\r\n   * caller in instances where improved efficiency is desired. The null address\r\n   * will be returned in the event that no escape hatch is set for the caller,\r\n   * and so the caller must appropriately handle this outcome if they elect to\r\n   * use the fallback in place of the `getEscapeHatch` view function.\r\n   * @return The address of the escape hatch or the null address if none is set.\r\n   */\r\n  function () external {\r\n    // Get the caller's escape hatch account or the null address if none is set.\r\n    address escapeHatch = _escapeHatches[msg.sender].escapeHatch;\r\n\r\n    // Solidity does not natively support returning values from the fallback.\r\n    assembly {\r\n      // Store the escape hatch address in the first word of scratch space.\r\n      mstore(0, escapeHatch)\r\n\r\n      // Return the first word of scratch space containing escape hatch account.\r\n      return(0, 32)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Register an account as the designated escape hatch for the caller.\r\n   * The attempt will revert if escape hatch functionality has been disabled. An\r\n   * `EscapeHatchModified` event will be emitted if the escape hatch account was\r\n   * modified.\r\n   * @param escapeHatch address The account to set as the escape hatch.\r\n   */\r\n  function setEscapeHatch(address escapeHatch) external {\r\n    // Ensure that an escape hatch address has been supplied.\r\n    require(escapeHatch != address(0), \"Must supply an escape hatch address.\");\r\n\r\n    // Store the escape hatch (do not disable it) and emit an event if modified.\r\n    _modifyEscapeHatch(escapeHatch, false);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove the caller's escape hatch account if one is currently set.\r\n   * This call will revert if escape hatch functionality has been disabled, but\r\n   * in that case the account will already have no escape hatch assigned. An\r\n   * `EscapeHatchModified` event will be emitted if an escape hatch account was\r\n   * currently assigned.\r\n   */\r\n  function removeEscapeHatch() external {\r\n    // Remove escape hatch (do not disable it) and emit an event if modified.\r\n    _modifyEscapeHatch(address(0), false);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove the caller's escape hatch account if one is currently set\r\n   * and irrevocably opt them out of the escape hatch mechanism. This call will\r\n   * revert if escape hatch functionality has already been disabled, which also\r\n   * means that no escape hatch is currently assigned. An `EscapeHatchDisabled`\r\n   * event will be emitted, as well as an `EscapeHatchModified` event if an\r\n   * escape hatch account was currently assigned.\r\n   */\r\n  function permanentlyDisableEscapeHatch() external {\r\n    // Remove the escape hatch and disable it, emitting corresponding events.\r\n    _modifyEscapeHatch(address(0), true);\r\n  }\r\n\r\n   /**\r\n   * @notice View function to determine whether a caller has an escape hatch\r\n   * account set, and if so to get the address of the escape hatch in question.\r\n   * @return A boolean signifying whether the caller has an escape hatch set, as\r\n   * well as the address of the escape hatch if one exists.\r\n   */\r\n  function getEscapeHatch() external view returns (\r\n    bool exists, address escapeHatch\r\n  ) {\r\n    escapeHatch = _escapeHatches[msg.sender].escapeHatch;\r\n    exists = escapeHatch != address(0);\r\n  }\r\n\r\n   /**\r\n   * @notice View function to determine whether a particular smart wallet has an\r\n   * escape hatch account set, and if so to get the address of the escape hatch\r\n   * in question.\r\n   * @param smartWallet address The smart wallet to check for an escape hatch.\r\n   * @return A boolean signifying whether the designated smart wallet has an\r\n   * escape hatch set, as well as the address of the escape hatch if one exists.\r\n   */\r\n  function getEscapeHatchForSmartWallet(\r\n    address smartWallet\r\n  ) external view returns (bool exists, address escapeHatch) {\r\n    // Ensure that a smart wallet address has been supplied.\r\n    require(smartWallet != address(0), \"Must supply a smart wallet address.\");\r\n\r\n    escapeHatch = _escapeHatches[smartWallet].escapeHatch;\r\n    exists = escapeHatch != address(0);\r\n  }\r\n\r\n   /**\r\n   * @notice View function to determine whether a particular smart wallet has\r\n   * permanently opted out of the escape hatch mechanism.\r\n   * @param smartWallet address The smart wallet to check for escape hatch\r\n   * mechanism disablement.\r\n   * @return A boolean signifying whether the designated smart wallet has\r\n   * disabled the escape hatch mechanism or not.\r\n   */\r\n  function hasDisabledEscapeHatchForSmartWallet(\r\n    address smartWallet\r\n  ) external view returns (bool disabled) {\r\n    // Ensure that a smart wallet address has been supplied.\r\n    require(smartWallet != address(0), \"Must supply a smart wallet address.\");\r\n\r\n    disabled = _escapeHatches[smartWallet].disabled;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to update an escape hatch and/or disable it, and\r\n   * to emit corresponding events.\r\n   * @param escapeHatch address The account to set as the escape hatch.\r\n   * @param disable bool A flag indicating whether the escape hatch will be\r\n   * permanently disabled.\r\n   */\r\n  function _modifyEscapeHatch(address escapeHatch, bool disable) internal {\r\n    // Retrieve the storage region of the escape hatch in question.\r\n    EscapeHatch storage escape = _escapeHatches[msg.sender];\r\n\r\n    // Ensure that the escape hatch mechanism has not been disabled.\r\n    require(!escape.disabled, \"Escape hatch has been disabled by this account.\");\r\n\r\n    // Emit an event if the escape hatch account has been modified.\r\n    if (escape.escapeHatch != escapeHatch) {\r\n      // Include calling smart wallet, old escape hatch, and new escape hatch.\r\n      emit EscapeHatchModified(msg.sender, escape.escapeHatch, escapeHatch);\r\n    }\r\n\r\n    // Emit an event if the escape hatch mechanism has been disabled.\r\n    if (disable) {\r\n      // Include the calling smart wallet account.\r\n      emit EscapeHatchDisabled(msg.sender);\r\n    }\r\n\r\n    // Update the storage region for the escape hatch with the new information.\r\n    escape.escapeHatch = escapeHatch;\r\n    escape.disabled = disable;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"escapeHatch\",\"type\":\"address\"}],\"name\":\"setEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"}],\"name\":\"hasDisabledEscapeHatchForSmartWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEscapeHatch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"escapeHatch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"}],\"name\":\"getEscapeHatchForSmartWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"escapeHatch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"permanentlyDisableEscapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldEscapeHatch\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newEscapeHatch\",\"type\":\"address\"}],\"name\":\"EscapeHatchModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"smartWallet\",\"type\":\"address\"}],\"name\":\"EscapeHatchDisabled\",\"type\":\"event\"}]","ContractName":"DharmaEscapeHatchRegistry","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://202020446861726d614573636170654861746368526567697374727920202020"}]}