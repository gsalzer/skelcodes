{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n/**\r\n * Copyright Â© 2017-2019 Ramp Network sp. z o.o. All rights reserved (MIT License).\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\r\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\r\n * is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all copies\r\n * or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\r\n * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/**\r\n * A standard, simple transferrable contract ownership.\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n\r\n    constructor() internal {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only the owner can call this\");\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnerChanged(msg.sender, _newOwner);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * A contract that can be stopped/restarted by its owner.\r\n */\r\ncontract Stoppable is Ownable {\r\n\r\n    bool public isActive = true;\r\n\r\n    event IsActiveChanged(bool _isActive);\r\n\r\n    modifier onlyActive() {\r\n        require(isActive, \"contract is stopped\");\r\n        _;\r\n    }\r\n\r\n    function setIsActive(bool _isActive) external onlyOwner {\r\n        if (_isActive == isActive) return;\r\n        isActive = _isActive;\r\n        emit IsActiveChanged(_isActive);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A simple interface used by the escrows contract (precisely AssetAdapters) to interact\r\n * with the liquidity pools.\r\n */\r\ncontract RampInstantPoolInterface {\r\n\r\n    uint16 public ASSET_TYPE;\r\n\r\n    function sendFundsToSwap(uint256 _amount)\r\n        public /*onlyActive onlySwapsContract isWithinLimits*/ returns(bool success);\r\n\r\n}\r\n\r\ncontract RampInstantTokenPoolInterface is RampInstantPoolInterface {\r\n\r\n    address public token;\r\n\r\n}\r\n\r\n/**\r\n * An interface of the RampInstantEscrows functions that are used by the liquidity pool contracts.\r\n * See RampInstantEscrows.sol for more comments.\r\n */\r\ncontract RampInstantEscrowsPoolInterface {\r\n\r\n    uint16 public ASSET_TYPE;\r\n\r\n    function release(\r\n        address _pool,\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    )\r\n        external; /*statusAtLeast(Status.FINALIZE_ONLY) onlyOracleOrPool(_pool, _oracle)*/\r\n\r\n    function returnFunds(\r\n        address payable _pool,\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    )\r\n        external; /*statusAtLeast(Status.RETURN_ONLY) onlyOracleOrPool(_pool, _oracle)*/\r\n\r\n}\r\n\r\n/**\r\n * An abstract Ramp Instant Liquidity Pool. A liquidity provider deploys an instance of this\r\n * contract, and sends his funds to it. The escrows contract later withdraws portions of these\r\n * funds to be locked. The owner can withdraw any part of the funds at any time, or temporarily\r\n * block creating new escrows by stopping the contract.\r\n *\r\n * The pool owner can set and update min/max swap amounts, with an upper limit of 2^240 wei/units\r\n * (see `AssetAdapterWithFees` for more info).\r\n *\r\n * The paymentDetailsHash parameters works the same as in the `RampInstantEscrows` contract, only\r\n * with 0 value and empty transfer title. It describes the bank account where the pool owner expects\r\n * to be paid, and can be used to validate that a created swap indeed uses the same account.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract RampInstantPool is Ownable, Stoppable, RampInstantPoolInterface {\r\n\r\n    uint256 constant private MAX_SWAP_AMOUNT_LIMIT = 1 << 240;\r\n    uint16 public ASSET_TYPE;\r\n\r\n    address payable public swapsContract;\r\n    uint256 public minSwapAmount;\r\n    uint256 public maxSwapAmount;\r\n    bytes32 public paymentDetailsHash;\r\n\r\n    /**\r\n     * Triggered when the pool receives new funds, either a topup, or a returned escrow from an old\r\n     * swaps contract if it was changed. Avilable for ETH, ERC-223 and ERC-777 token pools.\r\n     * Doesn't work for plain ERC-20 tokens, since they don't provide such an interface.\r\n     */\r\n    event ReceivedFunds(address _from, uint256 _amount);\r\n    event LimitsChanged(uint256 _minAmount, uint256 _maxAmount);\r\n    event SwapsContractChanged(address _oldAddress, address _newAddress);\r\n\r\n    constructor(\r\n        address payable _swapsContract,\r\n        uint256 _minSwapAmount,\r\n        uint256 _maxSwapAmount,\r\n        bytes32 _paymentDetailsHash,\r\n        uint16 _assetType\r\n    )\r\n        public\r\n        validateLimits(_minSwapAmount, _maxSwapAmount)\r\n        validateSwapsContract(_swapsContract, _assetType)\r\n    {\r\n        swapsContract = _swapsContract;\r\n        paymentDetailsHash = _paymentDetailsHash;\r\n        minSwapAmount = _minSwapAmount;\r\n        maxSwapAmount = _maxSwapAmount;\r\n        ASSET_TYPE = _assetType;\r\n    }\r\n\r\n    function availableFunds() public view returns (uint256);\r\n\r\n    function withdrawFunds(address payable _to, uint256 _amount)\r\n        public /*onlyOwner*/ returns (bool success);\r\n\r\n    function withdrawAllFunds(address payable _to) public onlyOwner returns (bool success) {\r\n        return withdrawFunds(_to, availableFunds());\r\n    }\r\n\r\n    function setLimits(\r\n        uint256 _minAmount,\r\n        uint256 _maxAmount\r\n    ) public onlyOwner validateLimits(_minAmount, _maxAmount) {\r\n        minSwapAmount = _minAmount;\r\n        maxSwapAmount = _maxAmount;\r\n        emit LimitsChanged(_minAmount, _maxAmount);\r\n    }\r\n\r\n    function setSwapsContract(\r\n        address payable _swapsContract\r\n    ) public onlyOwner validateSwapsContract(_swapsContract, ASSET_TYPE) {\r\n        address oldSwapsContract = swapsContract;\r\n        swapsContract = _swapsContract;\r\n        emit SwapsContractChanged(oldSwapsContract, _swapsContract);\r\n    }\r\n\r\n    function sendFundsToSwap(uint256 _amount)\r\n        public /*onlyActive onlySwapsContract isWithinLimits*/ returns(bool success);\r\n\r\n    function releaseSwap(\r\n        address payable _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external onlyOwner {\r\n        RampInstantEscrowsPoolInterface(swapsContract).release(\r\n            address(this),\r\n            _receiver,\r\n            _oracle,\r\n            _assetData,\r\n            _paymentDetailsHash\r\n        );\r\n    }\r\n\r\n    function returnSwap(\r\n        address _receiver,\r\n        address _oracle,\r\n        bytes calldata _assetData,\r\n        bytes32 _paymentDetailsHash\r\n    ) external onlyOwner {\r\n        RampInstantEscrowsPoolInterface(swapsContract).returnFunds(\r\n            address(this),\r\n            _receiver,\r\n            _oracle,\r\n            _assetData,\r\n            _paymentDetailsHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Needed for address(this) to be payable in call to returnFunds.\r\n     * The Eth pool overrides this to not throw.\r\n     */\r\n    function () external payable {\r\n        revert(\"this pool cannot receive ether\");\r\n    }\r\n\r\n    modifier onlySwapsContract() {\r\n        require(msg.sender == swapsContract, \"only the swaps contract can call this\");\r\n        _;\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 _amount) {\r\n        require(_amount >= minSwapAmount && _amount <= maxSwapAmount, \"amount outside swap limits\");\r\n        _;\r\n    }\r\n\r\n    modifier validateLimits(uint256 _minAmount, uint256 _maxAmount) {\r\n        require(_minAmount <= _maxAmount, \"min limit over max limit\");\r\n        require(_maxAmount <= MAX_SWAP_AMOUNT_LIMIT, \"maxAmount too high\");\r\n        _;\r\n    }\r\n\r\n    modifier validateSwapsContract(address payable _swapsContract, uint16 _assetType) {\r\n        require(_swapsContract != address(0), \"null swaps contract address\");\r\n        require(\r\n            RampInstantEscrowsPoolInterface(_swapsContract).ASSET_TYPE() == _assetType,\r\n            \"pool asset type doesn't match swap contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title partial ERC-20 Token interface according to official documentation:\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n */\r\ninterface Erc20Token {\r\n\r\n    /**\r\n     * Send `_value` of tokens from `msg.sender` to `_to`\r\n     *\r\n     * @param _to The recipient address\r\n     * @param _value The amount of tokens to be transferred\r\n     * @return Indication if the transfer was successful\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * Approve `_spender` to withdraw from sender's account multiple times, up to `_value`\r\n     * amount. If this function is called again it overwrites the current allowance with _value.\r\n     *\r\n     * @param _spender The address allowed to operate on sender's tokens\r\n     * @param _value The amount of tokens allowed to be transferred\r\n     * @return Indication if the approval was successful\r\n     */\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * Transfer tokens on behalf of `_from`, provided it was previously approved.\r\n     *\r\n     * @param _from The transfer source address (tokens owner)\r\n     * @param _to The transfer destination address\r\n     * @param _value The amount of tokens to be transferred\r\n     * @return Indication if the approval was successful\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * Returns the account balance of another account with address `_owner`.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * Partial ERC-1820 registry\r\n * https://github.com/0xjac/ERC1820/blob/master/contracts/ERC1820Client.sol\r\n */\r\ncontract ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n}\r\n\r\n\r\n/**\r\n * https://github.com/0xjac/ERC777/blob/devel/contracts/examples/ExampleTokensRecipient.sol\r\n */\r\ncontract ERC777TokenRecipient {\r\n\r\n    ERC1820Registry internal constant ERC1820REGISTRY = ERC1820Registry(\r\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n    );\r\n    bytes32 internal constant ERC777TokenRecipientERC1820Hash = keccak256(\r\n        abi.encodePacked(\"ERC777TokensRecipient\")\r\n    );\r\n    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(\r\n        abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")\r\n    );\r\n\r\n    constructor(bool _doSetErc1820Registry) internal {\r\n        if (_doSetErc1820Registry) {\r\n            ERC1820REGISTRY.setInterfaceImplementer(\r\n                address(this),\r\n                ERC777TokenRecipientERC1820Hash,\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    function canImplementInterfaceForAddress(\r\n        bytes32 _interfaceHash,\r\n        address _addr\r\n    ) external view returns(bytes32) {\r\n        if (_interfaceHash == ERC777TokenRecipientERC1820Hash && _addr == address(this)) {\r\n            return ERC1820_ACCEPT_MAGIC;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function tokensReceived(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData) external;\r\n\r\n}\r\n\r\n/**\r\n * A pool that implements handling of ERC-20-compatible token assets. See `RampInstantPool`.\r\n *\r\n * For ERC-777 tokens, enable `_doSetErc1820Registry` on deployment, if you want to receive the\r\n * `ReceivedFunds` events. For ERC-223 tokens no actions are needed. For plain ERC-20 tokens, that\r\n * event is not available.\r\n *\r\n * @author Ramp Network sp. z o.o.\r\n */\r\ncontract RampInstantTokenPool is RampInstantPool, ERC777TokenRecipient {\r\n\r\n    uint16 internal constant TOKEN_TYPE_ID = 2;\r\n    Erc20Token public token;\r\n\r\n    constructor(\r\n        address payable _swapsContract,\r\n        uint256 _minSwapAmount,\r\n        uint256 _maxSwapAmount,\r\n        bytes32 _paymentDetailsHash,\r\n        address _tokenAddress,\r\n        bool _doSetErc1820Registry\r\n    )\r\n        public\r\n        RampInstantPool(\r\n            _swapsContract, _minSwapAmount, _maxSwapAmount, _paymentDetailsHash, TOKEN_TYPE_ID\r\n        )\r\n        ERC777TokenRecipient(_doSetErc1820Registry)\r\n    {\r\n        token = Erc20Token(_tokenAddress);\r\n    }\r\n\r\n    function availableFunds() public view returns(uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function withdrawFunds(\r\n        address payable _to,\r\n        uint256 _amount\r\n    ) public onlyOwner returns (bool success) {\r\n        return token.transfer(_to, _amount);\r\n    }\r\n\r\n    function sendFundsToSwap(\r\n        uint256 _amount\r\n    ) public onlyActive onlySwapsContract isWithinLimits(_amount) returns(bool success) {\r\n        return token.transfer(swapsContract, _amount);\r\n    }\r\n\r\n    /** ERC-223 token fallback function */\r\n    function tokenFallback(address _from, uint _value, bytes memory _data) public {\r\n        require(_data.length == 0, \"tokens with data not supported\");\r\n        if (_from != swapsContract) {\r\n            emit ReceivedFunds(_from, _value);\r\n        }\r\n    }\r\n\r\n    /** ERC-777 token received hook */\r\n    function tokensReceived(\r\n        address /*_operator*/,\r\n        address _from,\r\n        address /*_to*/,\r\n        uint256 _amount,\r\n        bytes calldata _data,\r\n        bytes calldata /*_operatorData*/\r\n    ) external {\r\n        require(_data.length == 0, \"tokens with data not supported\");\r\n        if (_from != swapsContract) {\r\n            emit ReceivedFunds(_from, _amount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"returnSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceHash\",\"type\":\"bytes32\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setIsActive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawAllFunds\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSwapAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentDetailsHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendFundsToSwap\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSwapAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapsContract\",\"type\":\"address\"}],\"name\":\"setSwapsContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapsContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_oracle\",\"type\":\"address\"},{\"name\":\"_assetData\",\"type\":\"bytes\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"}],\"name\":\"releaseSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_swapsContract\",\"type\":\"address\"},{\"name\":\"_minSwapAmount\",\"type\":\"uint256\"},{\"name\":\"_maxSwapAmount\",\"type\":\"uint256\"},{\"name\":\"_paymentDetailsHash\",\"type\":\"bytes32\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_doSetErc1820Registry\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"LimitsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"SwapsContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"IsActiveChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"RampInstantTokenPool","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"420","ConstructorArguments":"00000000000000000000000082a24d3e69faefe23a6094b49262a77d20b47a0800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056bc75e2d63100000dc3de9c97a65d3a897fc4a4fc2da891002838a6922fa9b2921c3362defcb950700000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a232603590000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://003d4a30c7662ef4bafe5333701e2f0e5b3376eb302ed3f73820b0bdcf887be8"}]}