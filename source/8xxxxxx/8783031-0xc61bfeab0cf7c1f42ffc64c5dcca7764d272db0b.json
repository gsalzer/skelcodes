{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ncontract IERC20 {\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract Auth {\r\n  address internal mainAdmin;\r\n\r\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n  constructor(address _mainAdmin) internal {\r\n    mainAdmin = _mainAdmin;\r\n  }\r\n\r\n  modifier onlyMainAdmin() {\r\n    require(msg.sender == mainAdmin, \"onlyMainAdmin\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) onlyMainAdmin internal {\r\n    require(_newOwner != address(0x0));\r\n    mainAdmin = _newOwner;\r\n    emit OwnershipTransferred(msg.sender, _newOwner);\r\n  }\r\n\r\n  function isMainAdmin() public view returns (bool) {\r\n    return msg.sender == mainAdmin;\r\n  }\r\n}\r\n\r\ncontract DABLocker is Auth {\r\n  using SafeMath for uint;\r\n\r\n  IERC20 public dabToken = IERC20(0x5E7Ebea68ab05198F771d77a875480314f1d0aae);\r\n  mapping(address => bool) lockAccounts;\r\n  mapping(address => bool) withdrew;\r\n  mapping(address => uint) lockTimes;\r\n  mapping(address => uint) funds;\r\n  address[] public holders;\r\n\r\n  constructor (address _admin)\r\n  public\r\n  Auth(_admin) {\r\n  }\r\n\r\n  // ADMIN-FUNCTIONS\r\n\r\n  function lockAccount(address _address, bool _locked) onlyMainAdmin public {\r\n    require(_address != address(0x0), \"Invalid address\");\r\n    lockAccounts[_address] = _locked;\r\n  }\r\n\r\n  function end(uint _fromIndex, uint _toIndex) onlyMainAdmin public {\r\n    require(_fromIndex <= _toIndex && _toIndex < getTotalHolders(), 'Invalid index');\r\n    for(uint i = _fromIndex; i <= _toIndex; i++) {\r\n      uint holderFund = funds[holders[i]];\r\n      if (holderFund > 0) {\r\n        funds[holders[i]] = 0;\r\n        require(dabToken.transfer(holders[i], holderFund), 'Transfer token failed');\r\n      }\r\n    }\r\n  }\r\n\r\n  function adminWithdraw() onlyMainAdmin public {\r\n    dabToken.transfer(mainAdmin, dabToken.balanceOf(address(this)));\r\n  }\r\n\r\n  function updateMainAdmin(address _newAdmin) onlyMainAdmin public {\r\n    transferOwnership(_newAdmin);\r\n  }\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  function deposit(uint _amount) public {\r\n    require(_amount > 0, 'Invalid amount');\r\n    require(dabToken.allowance(msg.sender, address(this)) >= _amount, 'You have to call approve() function first');\r\n    require(dabToken.transferFrom(msg.sender, address(this), _amount), 'Transfer token to contract failed');\r\n    if (funds[msg.sender] == 0) {\r\n      holders.push(msg.sender);\r\n    }\r\n    funds[msg.sender] = funds[msg.sender].add(_amount);\r\n    if (lockTimes[msg.sender] == 0) {\r\n      lockTimes[msg.sender] = now + 90 days;\r\n    }\r\n  }\r\n\r\n  function withdraw() public {\r\n    require(!lockAccounts[msg.sender], 'You get locked');\r\n    require(!withdrew[msg.sender], 'You have had withdrew');\r\n    require(now >= lockTimes[msg.sender], 'You need to wait more time for withdrawal');\r\n    require(funds[msg.sender] > 0, 'Your fund is empty');\r\n    uint withdrawAmount = funds[msg.sender];\r\n    funds[msg.sender] = 0;\r\n    require(dabToken.transfer(msg.sender, withdrawAmount), 'Transfer token to user failed');\r\n    withdrew[msg.sender] = true;\r\n  }\r\n\r\n  function getTotalHolders() public view returns (uint) {\r\n    return holders.length;\r\n  }\r\n\r\n  function getUserFund(address _address) public view returns (uint) {\r\n    return funds[_address];\r\n  }\r\n\r\n  function getUserUnLockTime(address _address) public view returns (uint) {\r\n    return lockTimes[_address];\r\n  }\r\n\r\n  function isLocked(address _address) public view returns (bool) {\r\n    return lockAccounts[_address];\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isMainAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dabToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"lockAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserUnLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"updateMainAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DABLocker","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000118c11862150f130121d5fe1d4c9f02263fa079c","Library":"","LicenseType":"None","SwarmSource":"bzzr://e65ec5faba4dcb5e4e313ebcd5a8b650dd1b3193379e0259b11b4d57c5fd6bdc"}]}