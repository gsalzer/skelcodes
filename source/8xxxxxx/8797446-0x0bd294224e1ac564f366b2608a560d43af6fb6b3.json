{"status":"1","message":"OK","result":[{"SourceCode":"// File: @laborx/solidity-shared-contracts/contracts/ERC20Interface.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/// @title Defines an interface for EIP20 token smart contract\r\ncontract ERC20Interface {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n// File: @laborx/solidity-shared-contracts/contracts/Owned.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/// @title Owned contract with safe ownership pass.\r\n///\r\n/// Note: all the non constant functions return false instead of throwing in case if state change\r\n/// didn't happen yet.\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /// @notice Prepares ownership pass.\r\n    /// Can only be called by current owner.\r\n    /// @param _to address of the next owner.\r\n    /// @return success.\r\n    function changeContractOwnership(address _to)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (_to == 0x0) {\r\n            return false;\r\n        }\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Finalize ownership pass.\r\n    /// Can only be called by pending owner.\r\n    /// @return success.\r\n    function claimContractOwnership()\r\n    public\r\n    returns (bool)\r\n    {\r\n        if (msg.sender != pendingContractOwner) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, pendingContractOwner);\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (newOwner == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @dev Backward compatibility only.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferContractOwnership(address newOwner)\r\n    public\r\n    returns (bool)\r\n    {\r\n        return transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @notice Withdraw given tokens from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawTokens(address[] tokens)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        address _contractOwner = contractOwner;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20Interface token = ERC20Interface(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            if (balance > 0) {\r\n                token.transfer(_contractOwner, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw ether from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawEther()\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        uint balance = address(this).balance;\r\n        if (balance > 0)  {\r\n            contractOwner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers ether to another address.\r\n    /// Allowed only for contract owners.\r\n    /// @param _to recepient address\r\n    /// @param _value wei to transfer; must be less or equal to total balance on the contract\r\n    function transferEther(address _to, uint256 _value)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\r\n        if (_value > address(this).balance) {\r\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\r\n        }\r\n\r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/Storage.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract Manager {\r\n    function isAllowed(address _actor, bytes32 _role) public view returns (bool);\r\n    function hasAccess(address _actor) public view returns (bool);\r\n}\r\n\r\n\r\ncontract Storage is Owned {\r\n    struct Crate {\r\n        mapping(bytes32 => uint) uints;\r\n        mapping(bytes32 => address) addresses;\r\n        mapping(bytes32 => bool) bools;\r\n        mapping(bytes32 => int) ints;\r\n        mapping(bytes32 => uint8) uint8s;\r\n        mapping(bytes32 => bytes32) bytes32s;\r\n        mapping(bytes32 => AddressUInt8) addressUInt8s;\r\n        mapping(bytes32 => string) strings;\r\n        mapping(bytes32 => bytes) bytesSequences;\r\n    }\r\n\r\n    struct AddressUInt8 {\r\n        address _address;\r\n        uint8 _uint8;\r\n    }\r\n\r\n    mapping(bytes32 => Crate) internal crates;\r\n    Manager public manager;\r\n\r\n    modifier onlyAllowed(bytes32 _role) {\r\n        if (!(msg.sender == address(this) || manager.isAllowed(msg.sender, _role))) {\r\n            revert(\"STORAGE_FAILED_TO_ACCESS_PROTECTED_FUNCTION\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function setManager(Manager _manager)\r\n    external\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        manager = _manager;\r\n        return true;\r\n    }\r\n\r\n    function setUInt(bytes32 _crate, bytes32 _key, uint _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setUInt(_crate, _key, _value);\r\n    }\r\n\r\n    function _setUInt(bytes32 _crate, bytes32 _key, uint _value)\r\n    internal\r\n    {\r\n        crates[_crate].uints[_key] = _value;\r\n    }\r\n\r\n\r\n    function getUInt(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (uint)\r\n    {\r\n        return crates[_crate].uints[_key];\r\n    }\r\n\r\n    function setAddress(bytes32 _crate, bytes32 _key, address _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setAddress(_crate, _key, _value);\r\n    }\r\n\r\n    function _setAddress(bytes32 _crate, bytes32 _key, address _value)\r\n    internal\r\n    {\r\n        crates[_crate].addresses[_key] = _value;\r\n    }\r\n\r\n    function getAddress(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return crates[_crate].addresses[_key];\r\n    }\r\n\r\n    function setBool(bytes32 _crate, bytes32 _key, bool _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBool(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBool(bytes32 _crate, bytes32 _key, bool _value)\r\n    internal\r\n    {\r\n        crates[_crate].bools[_key] = _value;\r\n    }\r\n\r\n    function getBool(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return crates[_crate].bools[_key];\r\n    }\r\n\r\n    function setInt(bytes32 _crate, bytes32 _key, int _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setInt(_crate, _key, _value);\r\n    }\r\n\r\n    function _setInt(bytes32 _crate, bytes32 _key, int _value)\r\n    internal\r\n    {\r\n        crates[_crate].ints[_key] = _value;\r\n    }\r\n\r\n    function getInt(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (int)\r\n    {\r\n        return crates[_crate].ints[_key];\r\n    }\r\n\r\n    function setUInt8(bytes32 _crate, bytes32 _key, uint8 _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setUInt8(_crate, _key, _value);\r\n    }\r\n\r\n    function _setUInt8(bytes32 _crate, bytes32 _key, uint8 _value)\r\n    internal\r\n    {\r\n        crates[_crate].uint8s[_key] = _value;\r\n    }\r\n\r\n    function getUInt8(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (uint8)\r\n    {\r\n        return crates[_crate].uint8s[_key];\r\n    }\r\n\r\n    function setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBytes32(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value)\r\n    internal\r\n    {\r\n        crates[_crate].bytes32s[_key] = _value;\r\n    }\r\n\r\n    function getBytes32(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        return crates[_crate].bytes32s[_key];\r\n    }\r\n\r\n    function setAddressUInt8(\r\n        bytes32 _crate,\r\n        bytes32 _key,\r\n        address _value,\r\n        uint8 _value2\r\n    )\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setAddressUInt8(_crate, _key, _value, _value2);\r\n    }\r\n\r\n    function _setAddressUInt8(\r\n        bytes32 _crate,\r\n        bytes32 _key,\r\n        address _value,\r\n        uint8 _value2\r\n    )\r\n    internal\r\n    {\r\n        crates[_crate].addressUInt8s[_key] = AddressUInt8(_value, _value2);\r\n    }\r\n\r\n    function getAddressUInt8(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (address, uint8)\r\n    {\r\n        return (crates[_crate].addressUInt8s[_key]._address, crates[_crate].addressUInt8s[_key]._uint8);\r\n    }\r\n\r\n    function setString(bytes32 _crate, bytes32 _key, string _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setString(_crate, _key, _value);\r\n    }\r\n\r\n    function _setString(bytes32 _crate, bytes32 _key, string _value)\r\n    internal\r\n    {\r\n        crates[_crate].strings[_key] = _value;\r\n    }\r\n\r\n    function getString(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (string)\r\n    {\r\n        return crates[_crate].strings[_key];\r\n    }\r\n\r\n    function setBytesSequence(bytes32 _crate, bytes32 _key, bytes _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBytesSequence(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBytesSequence(bytes32 _crate, bytes32 _key, bytes _value)\r\n    internal\r\n    {\r\n        crates[_crate].bytesSequences[_key] = _value;\r\n    }\r\n\r\n    function getBytesSequence(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bytes)\r\n    {\r\n        return crates[_crate].bytesSequences[_key];\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/StorageInterface.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\nlibrary StorageInterface {\r\n    struct Config {\r\n        Storage store;\r\n        bytes32 crate;\r\n    }\r\n\r\n    struct UInt {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct UInt8 {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Int {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Address {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Bool {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Bytes32 {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct String {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct BytesSequence {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Mapping {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct StringMapping {\r\n        String id;\r\n    }\r\n\r\n    struct BytesSequenceMapping {\r\n        BytesSequence id;\r\n    }\r\n\r\n    struct UIntBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct UIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntEnumMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUInt8Mapping {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct AddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UInt8Mapping {\r\n        UInt8 innerMapping;\r\n    }\r\n\r\n    struct Bytes32BoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct Bytes32Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32AddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct AddressAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressAddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes32Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes4BoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes4Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressBoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressAddressBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct UIntUIntUIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    bytes32 constant SET_IDENTIFIER = \"set\";\r\n\r\n    struct Set {\r\n        UInt count;\r\n        Mapping indexes;\r\n        Mapping values;\r\n    }\r\n\r\n    struct AddressesSet {\r\n        Set innerSet;\r\n    }\r\n\r\n    struct CounterSet {\r\n        Set innerSet;\r\n    }\r\n\r\n    bytes32 constant ORDERED_SET_IDENTIFIER = \"ordered_set\";\r\n\r\n    struct OrderedSet {\r\n        UInt count;\r\n        Bytes32 first;\r\n        Bytes32 last;\r\n        Mapping nextValues;\r\n        Mapping previousValues;\r\n    }\r\n\r\n    struct OrderedUIntSet {\r\n        OrderedSet innerSet;\r\n    }\r\n\r\n    struct OrderedAddressesSet {\r\n        OrderedSet innerSet;\r\n    }\r\n\r\n    struct Bytes32SetMapping {\r\n        Set innerMapping;\r\n    }\r\n\r\n    struct AddressesSetMapping {\r\n        Bytes32SetMapping innerMapping;\r\n    }\r\n\r\n    struct UIntSetMapping {\r\n        Bytes32SetMapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32OrderedSetMapping {\r\n        OrderedSet innerMapping;\r\n    }\r\n\r\n    struct UIntOrderedSetMapping {\r\n        Bytes32OrderedSetMapping innerMapping;\r\n    }\r\n\r\n    struct AddressOrderedSetMapping {\r\n        Bytes32OrderedSetMapping innerMapping;\r\n    }\r\n\r\n    // Can't use modifier due to a Solidity bug.\r\n    function sanityCheck(bytes32 _currentId, bytes32 _newId) internal pure {\r\n        if (_currentId != 0 || _newId == 0) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function init(Config storage self, Storage _store, bytes32 _crate) internal {\r\n        self.store = _store;\r\n        self.crate = _crate;\r\n    }\r\n\r\n    function init(UInt8 storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(UInt storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Int storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Address storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Bool storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Bytes32 storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(String storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(BytesSequence storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Mapping storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(StringMapping storage self, bytes32 _id) internal {\r\n        init(self.id, _id);\r\n    }\r\n\r\n    function init(BytesSequenceMapping storage self, bytes32 _id) internal {\r\n        init(self.id, _id);\r\n    }\r\n\r\n    function init(UIntAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntEnumMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes32Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressAddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntUIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(AddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes4BoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes4Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32BoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32AddressMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntBoolMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Set storage self, bytes32 _id) internal {\r\n        init(self.count, keccak256(abi.encodePacked(_id, \"count\")));\r\n        init(self.indexes, keccak256(abi.encodePacked(_id, \"indexes\")));\r\n        init(self.values, keccak256(abi.encodePacked(_id, \"values\")));\r\n    }\r\n\r\n    function init(AddressesSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(CounterSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(OrderedSet storage self, bytes32 _id) internal {\r\n        init(self.count, keccak256(abi.encodePacked(_id, \"uint/count\")));\r\n        init(self.first, keccak256(abi.encodePacked(_id, \"uint/first\")));\r\n        init(self.last, keccak256(abi.encodePacked(_id, \"uint/last\")));\r\n        init(self.nextValues, keccak256(abi.encodePacked(_id, \"uint/next\")));\r\n        init(self.previousValues, keccak256(abi.encodePacked(_id, \"uint/prev\")));\r\n    }\r\n\r\n    function init(OrderedUIntSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(OrderedAddressesSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(Bytes32SetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressesSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32OrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntOrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressOrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    /** `set` operation */\r\n\r\n    function set(Config storage self, UInt storage item, uint _value) internal {\r\n        self.store.setUInt(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt storage item, bytes32 _salt, uint _value) internal {\r\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt8 storage item, uint8 _value) internal {\r\n        self.store.setUInt8(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt8 storage item, bytes32 _salt, uint8 _value) internal {\r\n        self.store.setUInt8(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Int storage item, int _value) internal {\r\n        self.store.setInt(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Int storage item, bytes32 _salt, int _value) internal {\r\n        self.store.setInt(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Address storage item, address _value) internal {\r\n        self.store.setAddress(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Address storage item, bytes32 _salt, address _value) internal {\r\n        self.store.setAddress(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bool _value) internal {\r\n        self.store.setBool(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bytes32 _salt, bool _value) internal {\r\n        self.store.setBool(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32 storage item, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32 storage item, bytes32 _salt, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, String storage item, string _value) internal {\r\n        self.store.setString(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, String storage item, bytes32 _salt, string _value) internal {\r\n        self.store.setString(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequence storage item,  bytes _value) internal {\r\n        self.store.setBytesSequence(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequence storage item, bytes32 _salt, bytes _value) internal {\r\n        self.store.setBytesSequence(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, uint _key, uint _value) internal {\r\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\r\n    }\r\n\r\n    function set(Config storage self, StringMapping storage item, bytes32 _key, string _value) internal {\r\n        set(self, item.id, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequenceMapping storage item, bytes32 _key, bytes _value) internal {\r\n        set(self, item.id, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressUInt8Mapping storage item, bytes32 _key, address _value1, uint8 _value2) internal {\r\n        self.store.setAddressUInt8(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value1, _value2);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bytes32 _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bool _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressMapping storage item, uint _key, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntMapping storage item, uint _key, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntBoolMapping storage item, uint _key, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntEnumMapping storage item, uint _key, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntBytes32Mapping storage item, uint _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntMapping storage item, bytes32 _key, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UInt8Mapping storage item, bytes32 _key, uint8 _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32BoolMapping storage item, bytes32 _key, bool _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32Bytes32Mapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32AddressMapping storage item, bytes32 _key, address _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntBoolMapping storage item, bytes32 _key, uint _key2, bool _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)), _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntMapping storage item, address _key, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBoolMapping storage item, address _key, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes32Mapping storage item, address _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressMapping storage item, address _key, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _key2, _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressBoolMapping storage item, uint _key, address _key2, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntAddressMapping storage item, uint _key, uint _key2, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntUIntMapping storage item, uint _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressAddressBoolMapping storage item, uint _key, address _key2, address _key3, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2,  uint _key3, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntUIntMapping storage item, bytes32 _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntUIntUIntMapping storage item, bytes32 _key, uint _key2,  uint _key3, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_key2), bytes32(_key3), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2,  uint _key3, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, uint _key5, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _key5, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\r\n    }\r\n\r\n\r\n    /** `add` operation */\r\n\r\n    function add(Config storage self, Set storage item, bytes32 _value) internal {\r\n        add(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function add(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (includes(self, item, _salt, _value)) {\r\n            return;\r\n        }\r\n        uint newCount = count(self, item, _salt) + 1;\r\n        set(self, item.values, _salt, bytes32(newCount), _value);\r\n        set(self, item.indexes, _salt, _value, bytes32(newCount));\r\n        set(self, item.count, _salt, newCount);\r\n    }\r\n\r\n    function add(Config storage self, AddressesSet storage item, address _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, CounterSet storage item) internal {\r\n        add(self, item.innerSet, bytes32(count(self, item) + 1));\r\n    }\r\n\r\n    function add(Config storage self, OrderedSet storage item, bytes32 _value) internal {\r\n        add(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function add(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (_value == 0x0) { revert(); }\r\n\r\n        if (includes(self, item, _salt, _value)) { return; }\r\n\r\n        if (count(self, item, _salt) == 0x0) {\r\n            set(self, item.first, _salt, _value);\r\n        }\r\n\r\n        if (get(self, item.last, _salt) != 0x0) {\r\n            _setOrderedSetLink(self, item.nextValues, _salt, get(self, item.last, _salt), _value);\r\n            _setOrderedSetLink(self, item.previousValues, _salt, _value, get(self, item.last, _salt));\r\n        }\r\n\r\n        _setOrderedSetLink(self, item.nextValues, _salt,  _value, 0x0);\r\n        set(self, item.last, _salt, _value);\r\n        set(self, item.count, _salt, get(self, item.count, _salt) + 1);\r\n    }\r\n\r\n    function add(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        add(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function add(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        add(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function add(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, OrderedUIntSet storage item, uint _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, OrderedAddressesSet storage item, address _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Set storage item, bytes32 _oldValue, bytes32 _newValue) internal {\r\n        set(self, item, SET_IDENTIFIER, _oldValue, _newValue);\r\n    }\r\n\r\n    function set(Config storage self, Set storage item, bytes32 _salt, bytes32 _oldValue, bytes32 _newValue) private {\r\n        if (!includes(self, item, _salt, _oldValue)) {\r\n            return;\r\n        }\r\n        uint index = uint(get(self, item.indexes, _salt, _oldValue));\r\n        set(self, item.values, _salt, bytes32(index), _newValue);\r\n        set(self, item.indexes, _salt, _newValue, bytes32(index));\r\n        set(self, item.indexes, _salt, _oldValue, bytes32(0));\r\n    }\r\n\r\n    function set(Config storage self, AddressesSet storage item, address _oldValue, address _newValue) internal {\r\n        set(self, item.innerSet, bytes32(_oldValue), bytes32(_newValue));\r\n    }\r\n\r\n    /** `remove` operation */\r\n\r\n    function remove(Config storage self, Set storage item, bytes32 _value) internal {\r\n        remove(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function remove(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (!includes(self, item, _salt, _value)) {\r\n            return;\r\n        }\r\n        uint lastIndex = count(self, item, _salt);\r\n        bytes32 lastValue = get(self, item.values, _salt, bytes32(lastIndex));\r\n        uint index = uint(get(self, item.indexes, _salt, _value));\r\n        if (index < lastIndex) {\r\n            set(self, item.indexes, _salt, lastValue, bytes32(index));\r\n            set(self, item.values, _salt, bytes32(index), lastValue);\r\n        }\r\n        set(self, item.indexes, _salt, _value, bytes32(0));\r\n        set(self, item.values, _salt, bytes32(lastIndex), bytes32(0));\r\n        set(self, item.count, _salt, lastIndex - 1);\r\n    }\r\n\r\n    function remove(Config storage self, AddressesSet storage item, address _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, CounterSet storage item, uint _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, OrderedSet storage item, bytes32 _value) internal {\r\n        remove(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function remove(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (!includes(self, item, _salt, _value)) { return; }\r\n\r\n        _setOrderedSetLink(self, item.nextValues, _salt, get(self, item.previousValues, _salt, _value), get(self, item.nextValues, _salt, _value));\r\n        _setOrderedSetLink(self, item.previousValues, _salt, get(self, item.nextValues, _salt, _value), get(self, item.previousValues, _salt, _value));\r\n\r\n        if (_value == get(self, item.first, _salt)) {\r\n            set(self, item.first, _salt, get(self, item.nextValues, _salt, _value));\r\n        }\r\n\r\n        if (_value == get(self, item.last, _salt)) {\r\n            set(self, item.last, _salt, get(self, item.previousValues, _salt, _value));\r\n        }\r\n\r\n        _deleteOrderedSetLink(self, item.nextValues, _salt, _value);\r\n        _deleteOrderedSetLink(self, item.previousValues, _salt, _value);\r\n\r\n        set(self, item.count, _salt, get(self, item.count, _salt) - 1);\r\n    }\r\n\r\n    function remove(Config storage self, OrderedUIntSet storage item, uint _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, OrderedAddressesSet storage item, address _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        remove(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function remove(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        remove(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function remove(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    /** 'copy` operation */\r\n\r\n    function copy(Config storage self, Set storage source, Set storage dest) internal {\r\n        uint _destCount = count(self, dest);\r\n        bytes32[] memory _toRemoveFromDest = new bytes32[](_destCount);\r\n        uint _idx;\r\n        uint _pointer = 0;\r\n        for (_idx = 0; _idx < _destCount; ++_idx) {\r\n            bytes32 _destValue = get(self, dest, _idx);\r\n            if (!includes(self, source, _destValue)) {\r\n                _toRemoveFromDest[_pointer++] = _destValue;\r\n            }\r\n        }\r\n\r\n        uint _sourceCount = count(self, source);\r\n        for (_idx = 0; _idx < _sourceCount; ++_idx) {\r\n            add(self, dest, get(self, source, _idx));\r\n        }\r\n\r\n        for (_idx = 0; _idx < _pointer; ++_idx) {\r\n            remove(self, dest, _toRemoveFromDest[_idx]);\r\n        }\r\n    }\r\n\r\n    function copy(Config storage self, AddressesSet storage source, AddressesSet storage dest) internal {\r\n        copy(self, source.innerSet, dest.innerSet);\r\n    }\r\n\r\n    function copy(Config storage self, CounterSet storage source, CounterSet storage dest) internal {\r\n        copy(self, source.innerSet, dest.innerSet);\r\n    }\r\n\r\n    /** `get` operation */\r\n\r\n    function get(Config storage self, UInt storage item) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, UInt storage item, bytes32 salt) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, UInt8 storage item) internal view returns (uint8) {\r\n        return self.store.getUInt8(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, UInt8 storage item, bytes32 salt) internal view returns (uint8) {\r\n        return self.store.getUInt8(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Int storage item) internal view returns (int) {\r\n        return self.store.getInt(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Int storage item, bytes32 salt) internal view returns (int) {\r\n        return self.store.getInt(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Address storage item) internal view returns (address) {\r\n        return self.store.getAddress(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Address storage item, bytes32 salt) internal view returns (address) {\r\n        return self.store.getAddress(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item) internal view returns (bool) {\r\n        return self.store.getBool(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item, bytes32 salt) internal view returns (bool) {\r\n        return self.store.getBool(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32 storage item) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32 storage item, bytes32 salt) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, String storage item) internal view returns (string) {\r\n        return self.store.getString(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, String storage item, bytes32 salt) internal view returns (string) {\r\n        return self.store.getString(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, BytesSequence storage item) internal view returns (bytes) {\r\n        return self.store.getBytesSequence(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, BytesSequence storage item, bytes32 salt) internal view returns (bytes) {\r\n        return self.store.getBytesSequence(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, uint _key) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, StringMapping storage item, bytes32 _key) internal view returns (string) {\r\n        return get(self, item.id, _key);\r\n    }\r\n\r\n    function get(Config storage self, BytesSequenceMapping storage item, bytes32 _key) internal view returns (bytes) {\r\n        return get(self, item.id, _key);\r\n    }\r\n\r\n    function get(Config storage self, AddressUInt8Mapping storage item, bytes32 _key) internal view returns (address, uint8) {\r\n        return self.store.getAddressUInt8(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2) internal view returns (bytes32) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns (bytes32) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns (bool) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, UIntBoolMapping storage item, uint _key) internal view returns (bool) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, UIntEnumMapping storage item, uint _key) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntMapping storage item, uint _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressMapping storage item, uint _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32AddressMapping storage item, bytes32 _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UInt8Mapping storage item, bytes32 _key) internal view returns (uint8) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32BoolMapping storage item, bytes32 _key) internal view returns (bool) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32Bytes32Mapping storage item, bytes32 _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntBoolMapping storage item, bytes32 _key, uint _key2) internal view returns (bool) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntBytes32Mapping storage item, uint _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntMapping storage item, address _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBoolMapping storage item, address _key) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressMapping storage item, address _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes32Mapping storage item, address _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntAddressMapping storage item, uint _key, uint _key2) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntUIntMapping storage item, uint _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntUIntMapping storage item, bytes32 _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntUIntUIntMapping storage item, bytes32 _key, uint _key2, uint _key3) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, bytes32(_key2), bytes32(_key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2) internal view returns (uint) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), _key2);\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressBoolMapping storage item, uint _key, address _key2) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressAddressBoolMapping storage item, uint _key, address _key2, address _key3) internal view returns (bool) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2, uint _key3) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2, uint _key3) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntStructAddressUInt8Mapping storage item, address _key, uint _key2) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, uint _key5) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3))));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4))));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, address _key5) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5))));\r\n    }\r\n\r\n    /** `includes` operation */\r\n\r\n    function includes(Config storage self, Set storage item, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function includes(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) internal view returns (bool) {\r\n        return get(self, item.indexes, _salt, _value) != 0;\r\n    }\r\n\r\n    function includes(Config storage self, AddressesSet storage item, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, CounterSet storage item, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function includes(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bool) {\r\n        return _value != 0x0 && (get(self, item.nextValues, _salt, _value) != 0x0 || get(self, item.last, _salt) == _value);\r\n    }\r\n\r\n    function includes(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function includes(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function includes(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, Set storage item, bytes32 _value) internal view returns (uint) {\r\n        return getIndex(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getIndex(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private view returns (uint) {\r\n        return uint(get(self, item.indexes, _salt, _value));\r\n    }\r\n\r\n    function getIndex(Config storage self, AddressesSet storage item, address _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, CounterSet storage item, uint _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function getIndex(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    /** `count` operation */\r\n\r\n    function count(Config storage self, Set storage item) internal view returns (uint) {\r\n        return count(self, item, SET_IDENTIFIER);\r\n    }\r\n\r\n    function count(Config storage self, Set storage item, bytes32 _salt) internal view returns (uint) {\r\n        return get(self, item.count, _salt);\r\n    }\r\n\r\n    function count(Config storage self, AddressesSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, CounterSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, OrderedSet storage item) internal view returns (uint) {\r\n        return count(self, item, ORDERED_SET_IDENTIFIER);\r\n    }\r\n\r\n    function count(Config storage self, OrderedSet storage item, bytes32 _salt) private view returns (uint) {\r\n        return get(self, item.count, _salt);\r\n    }\r\n\r\n    function count(Config storage self, OrderedUIntSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, OrderedAddressesSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, Bytes32SetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, AddressesSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, UIntSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item) internal view returns (bytes32[] result) {\r\n        result = get(self, item, SET_IDENTIFIER);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, bytes32 _salt) private view returns (bytes32[] result) {\r\n        uint valuesCount = count(self, item, _salt);\r\n        result = new bytes32[](valuesCount);\r\n        for (uint i = 0; i < valuesCount; i++) {\r\n            result[i] = get(self, item, _salt, i);\r\n        }\r\n    }\r\n\r\n    function get(Config storage self, AddressesSet storage item) internal view returns (address[]) {\r\n        return toAddresses(get(self, item.innerSet));\r\n    }\r\n\r\n    function get(Config storage self, CounterSet storage item) internal view returns (uint[]) {\r\n        return toUInt(get(self, item.innerSet));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32SetMapping storage item, bytes32 _key) internal view returns (bytes32[]) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, AddressesSetMapping storage item, bytes32 _key) internal view returns (address[]) {\r\n        return toAddresses(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, UIntSetMapping storage item, bytes32 _key) internal view returns (uint[]) {\r\n        return toUInt(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, uint _index) internal view returns (bytes32) {\r\n        return get(self, item, SET_IDENTIFIER, _index);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, bytes32 _salt, uint _index) private view returns (bytes32) {\r\n        return get(self, item.values, _salt, bytes32(_index+1));\r\n    }\r\n\r\n    function get(Config storage self, AddressesSet storage item, uint _index) internal view returns (address) {\r\n        return address(get(self, item.innerSet, _index));\r\n    }\r\n\r\n    function get(Config storage self, CounterSet storage item, uint _index) internal view returns (uint) {\r\n        return uint(get(self, item.innerSet, _index));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32SetMapping storage item, bytes32 _key, uint _index) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, _key, _index);\r\n    }\r\n\r\n    function get(Config storage self, AddressesSetMapping storage item, bytes32 _key, uint _index) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, _key, _index));\r\n    }\r\n\r\n    function get(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _index) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, _index));\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bytes32) {\r\n        return getNextValue(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bytes32) {\r\n        return get(self, item.nextValues, _salt, _value);\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (uint) {\r\n        return uint(getNextValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (address) {\r\n        return address(getNextValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bytes32) {\r\n        return getPreviousValue(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bytes32) {\r\n        return get(self, item.previousValues, _salt, _value);\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (uint) {\r\n        return uint(getPreviousValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (address) {\r\n        return address(getPreviousValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function toBool(bytes32 self) internal pure returns (bool) {\r\n        return self != bytes32(0);\r\n    }\r\n\r\n    function toBytes32(bool self) internal pure returns (bytes32) {\r\n        return bytes32(self ? 1 : 0);\r\n    }\r\n\r\n    function toAddresses(bytes32[] memory self) internal pure returns (address[]) {\r\n        address[] memory result = new address[](self.length);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            result[i] = address(self[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function toUInt(bytes32[] memory self) internal pure returns (uint[]) {\r\n        uint[] memory result = new uint[](self.length);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            result[i] = uint(self[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _setOrderedSetLink(Config storage self, Mapping storage link, bytes32 _salt, bytes32 from, bytes32 to) private {\r\n        if (from != 0x0) {\r\n            set(self, link, _salt, from, to);\r\n        }\r\n    }\r\n\r\n    function _deleteOrderedSetLink(Config storage self, Mapping storage link, bytes32 _salt, bytes32 from) private {\r\n        if (from != 0x0) {\r\n            set(self, link, _salt, from, 0x0);\r\n        }\r\n    }\r\n\r\n    /** @title Structure to incapsulate and organize iteration through different kinds of collections */\r\n    struct Iterator {\r\n        uint limit;\r\n        uint valuesLeft;\r\n        bytes32 currentValue;\r\n        bytes32 anchorKey;\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey, bytes32 startValue, uint limit) internal view returns (Iterator) {\r\n        if (startValue == 0x0) {\r\n            return listIterator(self, item, anchorKey, limit);\r\n        }\r\n\r\n        return createIterator(anchorKey, startValue, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey, uint startValue, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, bytes32(startValue), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, bytes32 anchorKey, address startValue, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, bytes32(startValue), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item, ORDERED_SET_IDENTIFIER, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey, uint limit) internal view returns (Iterator) {\r\n        return createIterator(anchorKey, get(self, item.first, anchorKey), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, uint limit, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item, ORDERED_SET_IDENTIFIER);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item, anchorKey, get(self, item.count, anchorKey));\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey);\r\n    }\r\n\r\n    function listIterator(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function listIterator(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function listIterator(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function createIterator(bytes32 anchorKey, bytes32 startValue, uint limit) internal pure returns (Iterator) {\r\n        return Iterator({\r\n            currentValue: startValue,\r\n            limit: limit,\r\n            valuesLeft: limit,\r\n            anchorKey: anchorKey\r\n        });\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedSet storage item, Iterator iterator) internal view returns (bytes32 _nextValue) {\r\n        if (!canGetNextWithIterator(self, item, iterator)) { revert(); }\r\n\r\n        _nextValue = iterator.currentValue;\r\n\r\n        iterator.currentValue = getNextValue(self, item, iterator.anchorKey, iterator.currentValue);\r\n        iterator.valuesLeft -= 1;\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedUIntSet storage item, Iterator iterator) internal view returns (uint _nextValue) {\r\n        return uint(getNextWithIterator(self, item.innerSet, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedAddressesSet storage item, Iterator iterator) internal view returns (address _nextValue) {\r\n        return address(getNextWithIterator(self, item.innerSet, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, Bytes32OrderedSetMapping storage item, Iterator iterator) internal view returns (bytes32 _nextValue) {\r\n        return getNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, UIntOrderedSetMapping storage item, Iterator iterator) internal view returns (uint _nextValue) {\r\n        return uint(getNextWithIterator(self, item.innerMapping, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, AddressOrderedSetMapping storage item, Iterator iterator) internal view returns (address _nextValue) {\r\n        return address(getNextWithIterator(self, item.innerMapping, iterator));\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedSet storage item, Iterator iterator) internal view returns (bool) {\r\n        if (iterator.valuesLeft == 0 || !includes(self, item, iterator.anchorKey, iterator.currentValue)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedUIntSet storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerSet, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedAddressesSet storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerSet, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, Bytes32OrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, UIntOrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, AddressOrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function count(Iterator iterator) internal pure returns (uint) {\r\n        return iterator.valuesLeft;\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/StorageAdapter.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract StorageAdapter {\r\n\r\n    using StorageInterface for *;\r\n\r\n    StorageInterface.Config internal store;\r\n\r\n    constructor(Storage _store, bytes32 _crate) public {\r\n        store.init(_store, _crate);\r\n    }\r\n}\r\n\r\n// File: contracts/common/initializable/InitializableStorageAdapter.sol\r\n\r\n/**\r\n* Copyright 2017–2019, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ncontract InitializableStorageAdapter is StorageAdapter {\r\n\r\n    function _initStorageAdapter(Storage _storage, bytes32 _crate) internal {\r\n        require(address(store.store) == 0x0);\r\n        store.init(_storage, _crate);\r\n    }\r\n}\r\n\r\n// File: contracts/workflow/WorkflowCore.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract WorkflowCore is InitializableStorageAdapter {\r\n\r\n    uint constant internal OK = 1;\r\n    uint constant internal UPFRONT_PERCENT_PRECISION = 10000;\r\n    uint constant internal TASK_PENALTY_PERCENT_PRECISION = 10000;\r\n\r\n\t/// @dev Indices for task details return values\r\n\r\n\tuint constant internal TASK_DETAILS_BUDGET_IDX = 0;\r\n\tuint constant internal TASK_DETAILS_PAID_AMOUNT_IDX = 1;\r\n\tuint constant internal TASK_DETAILS_UPFRONT_AMOUNT_IDX = 2;\r\n\tuint constant internal TASK_DETAILS_WITHDRAW_FEE_AMOUNT = 3;\r\n\tuint constant internal TASK_DETAILS_LENGTH = 4;\r\n\r\n\r\n    enum TaskState {\r\n        NOT_STARTED,\r\n        STARTED,\r\n        PAUSED,\r\n        COMPLETION_REQUESTED,\r\n        COMPLETION_DECLINED,  ///deprecated\r\n        REWORK_REQUESTED,     ///deprecated\r\n        COMPLETED\r\n    }\r\n\r\n    /// @dev hash(contractId, contract host address) => boolean\r\n    StorageInterface.Bytes32BoolMapping internal contractRegistrationsStorage;\r\n    /// @dev hash(contractId, contract host address) => set of task ids\r\n    StorageInterface.UIntSetMapping internal taskIdsStorage;\r\n    /// @dev hash(contractId, contract host address) => total upfront value of all uncompleted tasks in a contract\r\n    StorageInterface.Bytes32UIntMapping internal tasksUnspentUpfrontStorage;\r\n\r\n    /** TASK  */\r\n\r\n    /// @dev hash(contractId, contract host address, taskId) => TaskState\r\n    StorageInterface.Bytes32UInt8Mapping internal taskStateStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => timestamp\r\n    StorageInterface.Bytes32UIntMapping internal taskStartedAtStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => timestamp\r\n    StorageInterface.Bytes32UIntMapping internal taskPausedAtStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => block when task completion was requested\r\n    StorageInterface.Bytes32UIntMapping internal taskCompletedAtBlockStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => duration\r\n    StorageInterface.Bytes32UIntMapping internal taskPausedForStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => timestamp\r\n    StorageInterface.Bytes32UIntMapping internal taskFinishedStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => upfront payment\r\n    StorageInterface.Bytes32UIntMapping internal taskUpfrontValueStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => budget to pay (left amount after upfront payment)\r\n    StorageInterface.Bytes32UIntMapping internal taskBudgetLeftValueStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => paid budget (amount that has already been paid)\r\n    StorageInterface.Bytes32UIntMapping internal taskBudgetPaidValueStorage;\r\n    /// @dev hash(contractId, contract host address, taskId) => timestamp\r\n    StorageInterface.Bytes32UIntMapping internal taskDeadlineStorage;\r\n\r\n    /** TASK PENALTY */\r\n\r\n    /// @dev hash(contractId, contract host address, taskId) => set of penalty ids\r\n    StorageInterface.UIntSetMapping internal penaltyIdsStorage;\r\n    /// @dev hash(hash(contractId, contract host address, taskId), penaltyId) => PenaltyApplicationType\r\n    StorageInterface.Bytes32UInt8Mapping internal taskPenaltyApplicationTypeStorage;\r\n    /// @dev hash(hash(contractId, contract host address, taskId), penaltyId) => amount to penalize\r\n    StorageInterface.Bytes32UIntMapping internal taskPenaltyValueStorage;\r\n    /// @dev hash(hash(contractId, contract host address, taskId), penaltyId) => number of blocks after task finishing until penalty is activated\r\n    StorageInterface.Bytes32UIntMapping internal taskPenaltyPaymentWindowValueStorage;\r\n\r\n\r\n\r\n    function _initCore() internal {\r\n        contractRegistrationsStorage.init(\"contractRegistrations\");\r\n        taskIdsStorage.init(\"taskIds\");\r\n        tasksUnspentUpfrontStorage.init(\"tasksUnspentUpfront\");\r\n        taskStateStorage.init(\"taskState\");\r\n        taskStartedAtStorage.init(\"taskStartedAt\");\r\n        taskPausedAtStorage.init(\"taskPausedAt\");\r\n        taskCompletedAtBlockStorage.init(\"taskCompletedAtBlock\");\r\n        taskPausedForStorage.init(\"taskPausedFor\");\r\n        taskFinishedStorage.init(\"taskFinished\");\r\n\t\ttaskUpfrontValueStorage.init(\"taskUpfrontValue\");\r\n        taskBudgetLeftValueStorage.init(\"taskBudgetLeftValue\");\r\n        taskBudgetPaidValueStorage.init(\"taskBudgetPaidValue\");\r\n        taskDeadlineStorage.init(\"taskDeadline\");\r\n        penaltyIdsStorage.init(\"penaltyIds\");\r\n        taskPenaltyApplicationTypeStorage.init(\"taskPenaltyApplicationType\");\r\n        taskPenaltyValueStorage.init(\"taskPenaltyValue\");\r\n        taskPenaltyPaymentWindowValueStorage.init(\"taskPenaltyPaymentWindowValue\");\r\n    }\r\n}\r\n\r\n// File: contracts/workflow/WorkflowBase.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface WorkflowBase {\r\n\r\n    /// @param _contractHost smart contract address that will be requested for payments\r\n    function registerContract(bytes32 _contractId, address _contractHost) external returns (uint);\r\n    function addWorkflowData(\r\n        bytes32 _contractId,\r\n        address _contractHost,\r\n        bytes _data\r\n        ) external returns (uint _budget, uint _upfront);\r\n\r\n    function precalculateWorkflowData(\r\n        bytes32 _contractId,\r\n        address _contractHost,\r\n        bytes _data\r\n        ) external view returns (uint _budget, uint _upfront);\r\n\r\n    /// @notice Gets upfront amount from tasks that have not been finished (completed) yet\r\n    /// @param _contractId contract identifier\r\n    /// @param _contractHost contract smart contract address\r\n    function getUnspentUpfrontAmount(bytes32 _contractId, address _contractHost) external view returns (uint);\r\n}\r\n\r\n\r\ninterface WorkflowContractBlacklistable {\r\n    function isAllowedContractHost(address _contractHost) external view returns (bool);\r\n    function addContractHost(address _contractHost) external returns (uint);\r\n    function removeContractHost(address _contractHost) external returns (uint);\r\n}\r\n\r\n\r\ninterface WorkflowCheckpointBase {\r\n    /// @notice Gets numbers of how much employer will pay for a task `_taskId` in contract `_contractId` at `_contract`\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID to confirm to\r\n    /// @param _skippedPenalties penalty IDs that will be skipped during payment calculations\r\n    /// @return _totalValue how much task costs\r\n    /// @return _paymentValue how much should be paid immediately\r\n    /// @return _depositValue how much should be additionally deposited\r\n    function getTaskCompletionReward(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint _totalValue,\r\n        uint _paymentValue,\r\n        uint _depositValue,\r\n        uint _paidValue\r\n    );\r\n\r\n    /// @dev Gets task details.\r\n    /// @return\r\n    /// @return _values[0] budget amount\r\n    /// @return _values[1] paid amount\r\n    /// @return _values[2] upfront amount\r\n    /// @return _values[3] withdraw fee amount of paid amount\r\n    function getTaskDetails(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    external\r\n    view\r\n    returns (uint[] _values);\r\n\r\n    function getTaskCompletionRewardWithoutPenalties(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint _totalValue,\r\n        uint _paymentValue,\r\n        uint _depositValue,\r\n        uint _paidValue\r\n    );\r\n\r\n    /// @notice Gets numbers of how much should be additionally deposited to the assignee received `_value`\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _value how much should be paid immediately\r\n    /// @return _paymentValue how much should be paid immediately\r\n    /// @return _depositValue how much should be additionally deposited\r\n    function getTaskSinglePaymentReward(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _value\r\n    )\r\n    public\r\n    view\r\n    returns (uint _paymentValue, uint _depositValue);\r\n\r\n    function startTask(bytes32 _contractId, address _contract,  uint32 _taskId) external returns (uint);\r\n    function pauseTask(bytes32 _contractId, address _contract, uint32 _taskId) external returns (uint);\r\n    function resumeTask(bytes32 _contractId, address _contract, uint32 _taskId) external returns (uint);\r\n\r\n    /// @notice Prepaid expense to the assignee for task `_taskId` in context of contract `_contractId`.\r\n    ///     Assignee's penalties will not be applied to payment value.\r\n    ///     Employer should provide signature for releasing buyer's value from 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID for payment\r\n    /// @param _expireAtBlock bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _salt bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _signature signature for releasing blocked amount. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @return result code of an operation\r\n    function payPartialTaskExpenses(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n\r\n    /// @notice Confirms task `_taskId` completion in context of contract `_contractId` and frees\r\n    ///     budget to be send to the assignee.\r\n    ///     Assignee's penalties will not be applied to the final paycheck.\r\n    ///     Employer should provide signature for releasing buyer's value from 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID to confirm to\r\n    /// @param _expireAtBlock bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _salt bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _signature signature for releasing blocked amount. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @return result code of an operation\r\n    function completeTaskAndPay(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n\r\n    function completeTask(bytes32 _contractId, address _contract, uint32 _taskId) external returns (uint);\r\n\r\n    /// @notice Confirms task `_taskId` completion in context of contract `_contractId` and frees\r\n    ///     budget to be send to the assignee.\r\n    ///     Assignee's penalties could be skipped and they will not be applied to the final paycheck.\r\n    ///     Employer should provide signature for releasing buyer's value from 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID to confirm to\r\n    /// @param _skippedPenalties penalty IDs that will be skipped during payment calculations\r\n    /// @param _expireAtBlock bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _salt bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _signature signature for releasing blocked amount. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @return result code of an operation\r\n    function confirmTaskCompletion(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n\r\n    function declineTaskAndSendToRework(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        string _reason\r\n        ) external returns (uint);\r\n}\r\n\r\n// File: contracts/common/initializable/InitializableOwned.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ncontract InitializableOwned is Owned {\r\n\r\n\tfunction _initOwned(address _owner) internal {\r\n\t\trequire(_owner != 0x0);\r\n\t\trequire(contractOwner == 0x0);\r\n\t\tcontractOwner = _owner;\r\n\t}\r\n}\r\n\r\n// File: contracts/workflow/WorkflowBlacklistableBase.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract WorkflowContractBlacklistableBase is InitializableOwned {\r\n\r\n    uint constant internal OK = 1;\r\n\r\n    mapping(address => bool) internal allowedHostContracts;\r\n\r\n    modifier onlyAllowedContractHost(address _contractHost) {\r\n        require(isAllowedContractHost(_contractHost), \"WORKFLOW_ONLY_ALLOWED_HOST\");\r\n        _;\r\n    }\r\n\r\n    function isAllowedContractHost(address _contractHost) public view returns (bool) {\r\n        return allowedHostContracts[_contractHost];\r\n    }\r\n\r\n    function addContractHost(address _contractHost) external onlyContractOwner returns (uint) {\r\n        allowedHostContracts[_contractHost] = true;\r\n        return OK;\r\n    }\r\n\r\n    function removeContractHost(address _contractHost) external returns (uint) {\r\n        delete allowedHostContracts[_contractHost];\r\n        return OK;\r\n    }\r\n}\r\n\r\n// File: contracts/common/upgradeability/Delegatable.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/// @title Delegatable\r\n/// @notice Implements delegation of calls to other contracts, with proper\r\n/// \tforwarding of return values and bubbling of failures.\r\ncontract Delegatable {\r\n\r\n    /// @dev Delegates execution to an implementation contract.\r\n    /// \tThis is a low level function that doesn't return to its internal call site.\r\n    /// \tIt will return to the external caller whatever the implementation returns.\r\n    /// @param implementation Address to delegate.\r\n    function _delegate(address implementation) internal {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowBaseInterface.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface EscrowBaseInterface {\r\n\r\n\tfunction hasCurrencySupport(bytes32 _symbol) public view returns (bool);\r\n\r\n\tfunction getServiceFeeInfo() external view returns (address, uint16, uint);\r\n\tfunction setServiceFee(uint16 _feeValue) external returns (uint);\r\n\tfunction setServiceFeeAddress(address _feeReceiver) external returns (uint);\r\n\r\n\t/// @notice Gets balance locked on escrow.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @return currency symbol\r\n    /// @return currence balance on escrow\r\n    function getBalanceOf(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external view returns (bytes32, uint);\r\n\r\n\t/// @notice Creates an escrow record for provided symbol \"`_symbol`\"\r\n\t/// @dev Escrow is reusable so the same tradeRecordId could be reused after an escrow\r\n\t///\t\twith the same identifier is resolved.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _symbol symbol of payment currency\r\n\t/// @param _value amount to initially deposit to escrow; could be 0\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction createEscrow(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tbytes32 _symbol,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount,\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Deposits to an escrow provided amount `_value`\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to deposit\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction deposit(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount, // transfers _transferImmediatelyToBuyerAmount directly to _buyer.\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _sellerSignature signature produced by seller\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseBuyerPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _sellerSignature,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Buyer shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _buyerSignature signature produced by buyer\r\n\t/// @return result code of an operation\r\n\tfunction sendSellerPayback(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _buyerSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller` and buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _sellerValue, _buyerValue, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _sellerValue amount to withdraw from escrow to the seller\r\n\t/// @param _buyerValue amount to withdraw from escrow to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signatures concatenated signatures produced by seller and buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseNegotiatedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _sellerValue,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signatures,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Starts a dispute process between seller `_seller` and buyer `_buyer`.\r\n\t/// \tCould start only if an arbiter was specified.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction initiateDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Cancels an initiated dispute process\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction cancelDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n\t/// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _buyerValue value that will be transferred to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _arbiterSignature signature of an arbiter\r\n\t/// @return result code of an operation\r\n\tfunction releaseDisputedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tbytes _arbiterSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Deletes escrow record when it is no more needed.\r\n    ///     Escrow should be empty to be deleted.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    function deleteEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external returns (uint);\r\n\r\n\tfunction getArbiter(bytes32 _tradeRecordId, address _seller, address _buyer) external view returns (address);\r\n\r\n\t/// @notice Sets a new arbiter `_arbiter`. His address should be approved by both parties.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _arbiter, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _bothSignatures signatures of seller and buyer\r\n\tfunction setArbiter(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\taddress _arbiter,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _bothSignatures\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Performs transfer of a currency `_symbol`\r\n\t///\t\tfrom a `msg.sender` to service fee recepient\r\n\t/// @param _symbol target currency symbol\r\n\t/// @param _from holder address of the `_symbol`\r\n\t/// @param _amount amount to retransfer\r\n\t/// @return result code of an operation\r\n\tfunction retranslateToFeeRecipient(bytes32 _symbol, address _from, uint _amount) external payable returns (uint);\r\n}\r\n\r\n// File: contracts/labor-contract/LaborContractBase.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ninterface LaborContractBaseInitializable {\r\n\r\n    function initLaborContract(\r\n        address _owner,\r\n        address _storage,\r\n        bytes32 _crate\r\n        ) external;\r\n\r\n    function setExtensionContracts(\r\n        address _signable,\r\n        address _terminatable,\r\n        address _disputable,\r\n        address _completable,\r\n        address _tasksProposable\r\n    ) external;\r\n}\r\n\r\n\r\ninterface LaborContractBaseGeneralizable {\r\n    function getPaymentRequirements(bytes32 _contractId) external view returns (bool _lockFullBudget, uint8 _paymentTimeline);\r\n    function getContractParties(bytes32 _contractId) external view returns (address _employer, address _assignee);\r\n    function getContractState(bytes32 _contractId) external view returns (uint8 _state);\r\n}\r\n\r\n\r\ninterface LaborContractBase {\r\n\r\n    /// @notice Registers contract by an assignee that was negotiated by both parties and now is ready\r\n    ///\t\tfor the next step - financial relationships. Then signs registered contract.\r\n    /// If job contract is taking place then `_signature` should be based on arbiter setting\r\n    ///     (see EscrowBaseInterface#setArbiter).\r\n    /// If dispute contract is taking place then `_expireAtBlock`, `_salt`, `_signature` should skipped.\r\n    /// @param _workflow workflow smart contract address that could be used for time tracking; workflow specific\r\n    /// @param _escrow escrow smart contract for locking contract budget\r\n    /// @param _data initialization data for a contract\r\n    /// @param _expireAtBlock signature's expiration block\r\n    /// @param _salt signature's unique identifier\r\n    /// @param _signature signature of signed data\r\n    /// @return result code of an operation\r\n    function createContractAndSign(\r\n        bytes32 _contractId,\r\n        EscrowBaseInterface _escrow,\r\n        WorkflowBase _workflow,\r\n        bytes _data,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseOperationable {\r\n\r\n    /// @notice Callback function that is supposed to be called from associated workflow.\r\n    ///     Should be called on key operations that do not require any payment during execution.\r\n    /// @param _contractId contract identifier\r\n    /// @param _operationCode code of performed operation\r\n    function onOperation(bytes32 _contractId, string _operationCode) external;\r\n\r\n    /// @notice Callback function that is supposed to be called from associated workflow.\r\n    ///     Should be called on payable operations, for example, task completion confirmation.\r\n    /// @param _contractId contract identifier\r\n    /// @param _operationCode code of performed operation\r\n    /// @param _depositValue value to deposit (if needed, should include surchange percent)\r\n    /// @param _value value to be withdrawn from escrow\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signature signature provided by employer\r\n    function onWithdrawOperation(\r\n        bytes32 _contractId,\r\n        string _operationCode,\r\n        uint _depositValue,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable;\r\n}\r\n\r\n\r\ninterface LaborContractBaseSignable {\r\n\r\n    /// @notice Calculates how much is needed to start a contract.\r\n    /// @param _contractId contract identifier\r\n    function getLockingDepositBalance(bytes32 _contractId) external view returns (uint);\r\n\r\n    /// @dev Calculates how much is needed to start a contract.\r\n    /// @return\r\n    /// @return _values[0] tasks budget\r\n    /// @return _values[1] deposit fee amount\r\n    /// @return _values[2] locked termination amount\r\n    /// @return _values[3] initial (upfront) payment amount\r\n    /// @return _values[4] upfront withdraw fee amount\r\n    function getLockingContractDetails(bytes32 _contractId) external view returns (uint[] _values);\r\n\r\n    /// @notice Signs registered contract by an assignee. This operation precedes any other\r\n    ///     sign methods of other parties.\r\n    /// If job contract is taking place then `_signature` should be based on arbiter setting\r\n    ///     (see EscrowBaseInterface#setArbiter).\r\n    /// If dispute contract is taking place then `_expireAtBlock`, `_salt`, `_signature` should skipped.\r\n    /// @param _contractId contract identifier\r\n    /// @param _documentHash hash of a document on which parties have an agreement\r\n    /// @param _expireAtBlock signature's expiration block\r\n    /// @param _salt signature's unique identifier\r\n    /// @param _signature signature of signed data\r\n    /// @return result code of an operation\r\n    function sign(\r\n        bytes32 _contractId,\r\n        bytes32 _documentHash,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    ) external returns (uint);\r\n\r\n    /// @notice Allows an assignee to revoke her sign when the contract `_contractId` has not started yet.\r\n    /// @return result code of an operation\r\n    function revokeSign(bytes32 _contractId) external returns (uint);\r\n\r\n    /// @notice Signs contract and deposits to it, so it becomes ready for work.\r\n    ///     Should be done as the latest sign among all signs because it locks currency\r\n    /// If job contract is taking place then `_signature` should be based on artibter setting\r\n    ///     (see EscrowBaseInterface#setArbiter).\r\n    /// If dispute contract is taking place then `_signature` should be based on initiating escrow dispute\r\n    ///     (see EscrowBaseInterface#initiateDispute).\r\n    /// @param _contractId contract identifier\r\n    /// @param _documentHash hash of a document on which parties have an agreement\r\n    /// @param _value amount of deposited currency\r\n    /// @param _expireAtBlock signature's expiration block (the same as it was in assignee's sign)\r\n    /// @param _salt signature's unique identifier (the same as it was in assignee's sign)\r\n    /// @param _signature signature of signed data (signed data should be the same as it was in assignee's sign)\r\n    /// @return result code of an operation\r\n    function signAndDeposit(\r\n        bytes32 _contractId,\r\n        bytes32 _documentHash,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseCompletable {\r\n\r\n    /// @notice Calculates how much is needed to complete a contract\r\n    ///     (in cases when payment is performed after all tasks and no escrow locked balance exists).\r\n    /// @param _contractId contract identifier\r\n    /// @return _depositValue how much should be deposited by employer to resolve contract completion\r\n    /// @return _employerPaybackValue how much an employer gets back\r\n    /// @return _assigneeResolveValue how much an assignee will be paid\r\n    function getCompletionContractDepositBalance(\r\n        bytes32 _contractId\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        uint _depositValue,\r\n        uint _employerPaybackValue,\r\n        uint _assigneeResolveValue\r\n    );\r\n\r\n    /// @dev Calculates how much is needed to complete a contract.\r\n    /// @return\r\n    /// @return _values[0] already completed and paid amount\r\n    /// @return _values[1] completed but not paid (means it will be paid eventually)\r\n    /// @return _values[2] unpaid (left) tasks budget amount (not completed)\r\n    /// @return _values[3] escrow current balance\r\n    /// @return _values[4] need to deposit amount\r\n    /// @return _values[5] deposit fee value\r\n    /// @return _values[6] returned amount to employer\r\n    /// @return _values[7] paid amount to assignee\r\n    /// @return _values[8] locked termination amount\r\n    /// @return _values[9] withdraw fee amount\r\n    function getCompletionContractDetails(bytes32 _contractId) external view returns (uint[] _values);\r\n\r\n    /// @notice Completes the contract and resolves debts for both parties.\r\n    ///     No actions with contract will be available after that.\r\n    ///     Signature should present data for releasing termination escrow to the assignee and\r\n    ///     termination remainder + budget escrow to the employer. Escrow balance should be empty\r\n    ///     after execution - escrow will be flushed after that.\r\n    ///     See EscrowBaseInterface#releaseNegotiatedPayment for more details.\r\n    /// @param _contractId contract identifier\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signatures concatenated signatures produced by employer and assignee\r\n    /// @return result code of an operation\r\n    function completeContract(\r\n        bytes32 _contractId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signatures\r\n        ) external payable returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseTerminatable {\r\n\r\n    /// @notice Gets details about depositing amount that is required to initiate termination process.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier\r\n    /// @return amount that is required to deposit by termination initiator\r\n    function getTerminationInitiateDepositDetails(bytes32 _contractId, uint _terminationId) external view returns (uint);\r\n\r\n    /// @notice Gets details about depositing amount that is required to cancel termination process.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier\r\n    /// @return amount that is required to deposit by termination confirmator\r\n    function getTerminationCancelDepositDetails(bytes32 _contractId, uint _terminationId) external view returns (uint);\r\n\r\n    /// @notice Gets details about depositing amount that is required to confirm termination process.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier\r\n    /// @return amount that is required to deposit by termination confirmator\r\n    function getTerminationConfirmDepositDetails(bytes32 _contractId, uint _terminationId) external view returns (uint);\r\n\r\n    /// @notice Calculates requested termination conditions for the contract `_contractId`.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination condition identifier\r\n    /// @return _employerValue amount that will return back to the employer\r\n    /// @return _assigneeValue amount that will go to the assignee\r\n    function getTerminationPaymentAmounts(\r\n        bytes32 _contractId,\r\n        uint _terminationId\r\n    )\r\n    external\r\n    view\r\n    returns (uint _employerValue, uint _assigneeValue);\r\n\r\n    /// @dev Calculates requested termination conditions for the contract `_contractId`.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination condition identifier\r\n    /// @return _values[0] termination amount\r\n    /// @return _values[1] employer's amount\r\n    /// @return _values[2] assignee's amount\r\n    /// @return _values[3] initiator type\r\n    /// @return _values[4] receiver type\r\n    /// @return _values[5] unspent upfront amount that would be returned to an employer\r\n    /// @return _values[6] need to deposit amount on termination initiation\r\n    /// @return _values[7] need to deposit amount on termination confirmation\r\n    /// @return _values[8] need to pay for tasks in case if they are competed but not paid\r\n    /// @return _values[9] withdraw assignee fee amount\r\n    function getTerminationContractDetails(bytes32 _contractId, uint _terminationId) external view returns (uint[] _values);\r\n\r\n    /// @notice Starts termination negotiations by any party (employer or assignee)\r\n    ///     Is not applicable for disputes.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier; type of termination condition should\r\n    ///     be assosiated with the initiator\r\n    /// @param _value value to deposit, duplicated as a parameter to secure from unintended deposits\r\n    /// @param _comment additional comments about termination reason or other notes\r\n    /// @return result code of an operation\r\n    function initiateTermination(\r\n        bytes32 _contractId,\r\n        uint32 _terminationId,\r\n        uint _value,\r\n        string _comment\r\n        ) external payable returns (uint);\r\n\r\n    /// @notice Cancels termination request that has not confirmed yet.\r\n    ///     Should be called by the termination initiator\r\n    ///     Is not applicable for disputes.\r\n    /// @param _contractId contract identifier\r\n    /// @return result code of an operation\r\n    function cancelTerminationRequest(bytes32 _contractId) external returns (uint);\r\n\r\n    /// @notice Cancels termination request that has not confirmed yet.\r\n    ///     Should be called by the termination initiator.\r\n    ///     Is not applicable for disputes.\r\n    ///\r\n    ///     If a deposit was made during termination initiation stage and\r\n    ///     'getTerminationCancelDepositDetails()' returns non-zero result then the opposite\r\n    ///     party should sign that amount for withdrawal and pass to termination's\r\n    ///     initiator.\r\n    ///     When initiator is an assignee then an employer should sign a message for\r\n    ///     EscrowBaseInterface#releaseBuyerPayment method.\r\n    ///     When initiator is an employer then an assignee should sign a message for\r\n    ///     EscrowBaseInterface#sendSellerPayback method.\r\n    ///     Otherwise expireAtBlock, salt and signature should be skipped.\r\n    /// @param _contractId contract identifier\r\n    /// @param _expireAtBlock contract identifier\r\n    /// @param _salt contract identifier\r\n    /// @param _signature contract identifier\r\n    /// @return result code of an operation\r\n    function cancelTerminationRequestWithApproval(\r\n        bytes32 _contractId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external returns (uint);\r\n\r\n    /// @notice Performs confirmation of requested termination and terminates contract.\r\n    ///     Is not applicable for disputes.\r\n    ///     Should be signed by both parties that means they are both aware and agreed on conditions.\r\n    ///     Signature should present data for releasing termination escrow to the assignee and\r\n    ///     termination remainder + budget escrow to the employer. Escrow balance should be empty\r\n    ///     after execution - escrow will be flushed after that.\r\n    ///     See EscrowBaseInterface#releaseNegotiatedPayment for more details.\r\n    /// @param _contractId contract identifier\r\n    /// @param _value value to deposit, duplicated as a parameter to secure from unintended withdrawals\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid. Should be the same for\r\n    ///     tasks payment and for negotiated payment.\r\n    /// @param _tasksSalt tasks random bytes to identify signed data\r\n    ///     Skip when no payment is required.\r\n    /// @param _tasksSignature signature of EscrowBaseInterface#releaseBuyerPayment message\r\n    ///     Skip when no payment is required.\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signatures concatenated signatures produced by employer and assignee\r\n    /// @return result code of an operation\r\n    function confirmTermination(\r\n        bytes32 _contractId,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _tasksSalt,\r\n        bytes _tasksSignature,\r\n        uint _salt,\r\n        bytes _signatures\r\n        ) external payable returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseDisputable {\r\n\r\n    /// @notice Gets details about contract resolvement by an arbiter.\r\n    /// @param _contractId contract identifier\r\n    /// @param _assigneeValue value that will go to an assignee\r\n    /// @return _values[0] employer's amount\r\n    /// @return _values[1] withdraw fee amount (for assignee)\r\n    function getResolvingContractDetails(bytes32 _contractId, uint _assigneeValue) external view returns (uint[] _values);\r\n\r\n    /// @notice Resolves the dispute in contract (if such exists).\r\n    ///     Sends provided percent `_assigneePercent` to the underlying\r\n    ///     contract assignee, the remainder - to contract employer.\r\n    ///     No actions with contract will be available after that.\r\n    ///     Signature should present data for releasing full escrow balance and split\r\n    ///     it amont parties in a dispute. Escrow balance should be empty\r\n    ///     after execution - escrow will be flushed after that.\r\n    ///     See EscrowBaseInterface#releaseDisputedPayment for more details.\r\n    /// @param _contractId contract identifier\r\n    /// @param _assigneeValue part of the escrow balance that will go to the assignee\r\n    ///     of disputed contract\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _signature signature provided by dispute assignee (base contract's arbiter)\r\n    /// @return result code of an operation\r\n    function resolveContract(\r\n        bytes32 _contractId,\r\n        uint _assigneeValue,\r\n        uint _expireAtBlock,\r\n        bytes _signature\r\n        ) external returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseTasksProposable {\r\n\r\n    /// @notice Gets details about proposed tasks for contract `_contractId`.\r\n    /// @param _contractId contract identifier\r\n    /// @return _values[0] proposed tasks budget\r\n    /// @return _values[1] amount needed to be deposited\r\n    /// @return _values[2] employer's fee amount included into deposit\r\n    /// @return _values[3] termination amount needed to be locked additionally\r\n    /// @return _values[4] upfront amount\r\n    /// @return _values[5] assignee's fee amount that will be taken fron upfront amount\r\n    function getContractProposedTasksDetails(bytes32 _contractId) external view returns (uint[] _values);\r\n\r\n    /// @notice Puts new tasks of a contract `_contractId` to an approval state for an employer.\r\n    ///     Should be called by an assignee.\r\n    /// @param _contractId contract identifier\r\n    /// @param _updatedDocumentHash document hash of the updated contract\r\n    /// @param _data tasks and task penalty that are going to be added\r\n    /// @return result code of an operation\r\n    function proposeTasks(\r\n        bytes32 _contractId,\r\n        bytes32 _updatedDocumentHash,\r\n        bytes _data\r\n        ) external returns (uint);\r\n\r\n    /// @notice Accepts proposed tasks for a contract `_contractId`\r\n    ///     and adds tasks to a contract's workflow.\r\n    ///     Should be called by an employer.\r\n    /// @param _contractId contract identifier\r\n    /// @param _updatedDocumentHash document hash of the updated contract\r\n    /// @param _value value to be deposited for provided tasks\r\n    /// @return result code of an operation\r\n    function acceptProposedTasksAndDeposit(\r\n        bytes32 _contractId,\r\n        bytes32 _updatedDocumentHash,\r\n        uint _value\r\n        ) external payable returns (uint);\r\n}\r\n\r\n// File: contracts/libs/Bits.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\nlibrary Bits {\r\n\r\n    uint constant internal ONE = uint(1);\r\n    uint constant internal ONES = uint(~0);\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '1'.\r\n    // Returns the modified value.\r\n    function setBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self | ONE << index;\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '0'.\r\n    // Returns the modified value.\r\n    function clearBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self & ~(ONE << index);\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to:\r\n    //  '1' - if the bit is '0'\r\n    //  '0' - if the bit is '1'\r\n    // Returns the modified value.\r\n    function toggleBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self ^ ONE << index;\r\n    }\r\n\r\n    // Get the value of the bit at the given 'index' in 'self'.\r\n    function bit(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(self >> index & 1);\r\n    }\r\n\r\n    // Check if the bit at the given 'index' in 'self' is set.\r\n    // Returns:\r\n    //  'true' - if the value of the bit is '1'\r\n    //  'false' - if the value of the bit is '0'\r\n    function bitSet(uint self, uint8 index) internal pure returns (bool) {\r\n        return self >> index & 1 == 1;\r\n    }\r\n\r\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\r\n    // bit in 'other'.\r\n    // Returns:\r\n    //  'true' - if both bits are '0' or both bits are '1'\r\n    //  'false' - otherwise\r\n    function bitEqual(uint self, uint other, uint8 index) internal pure returns (bool) {\r\n        return (self ^ other) >> index & 1 == 0;\r\n    }\r\n\r\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\r\n    function bitNot(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(1 - (self >> index & 1));\r\n    }\r\n\r\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitAnd(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self & other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitOr(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self | other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitXor(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self ^ other) >> index & 1);\r\n    }\r\n\r\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\r\n    // Returns the bits as a 'uint'.\r\n    // Requires that:\r\n    //  - '0 < numBits <= 256'\r\n    //  - 'startIndex < 256'\r\n    //  - 'numBits + startIndex <= 256'\r\n    function bits(uint self, uint8 startIndex, uint16 numBits) internal pure returns (uint) {\r\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\r\n        return self >> startIndex & ONES >> 256 - numBits;\r\n    }\r\n\r\n    // Computes the index of the highest bit set in 'self'.\r\n    // Returns the highest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function highestBitSet(uint self) internal pure returns (uint8 highest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 << i != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Computes the index of the lowest bit set in 'self'.\r\n    // Returns the lowest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function lowestBitSet(uint self) internal pure returns (uint8 lowest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 == 0) {\r\n                lowest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/common/FeeConstants.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract FeeConstants {\r\n\r\n    using Bits for uint8;\r\n\r\n    uint8 constant SELLER_FLAG_BIT_IDX = 0;\r\n    uint8 constant BUYER_FLAG_BIT_IDX = 1;\r\n\r\n    function _getSellerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(SELLER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getBuyerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getAllFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(uint8(_feeStatus\r\n            .setBit(SELLER_FLAG_BIT_IDX))\r\n            .setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getNoFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return 0;\r\n    }\r\n\r\n    function _isFeeFlagAppliedFor(uint8 _feeStatus, uint8 _userBit) internal pure returns (bool) {\r\n        return _feeStatus.bitSet(_userBit);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"SAFE_MATH_MUL\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SAFE_MATH_SUB\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SAFE_MATH_ADD\");\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/PercentCalculator.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\nlibrary PercentCalculator {\r\n\r\n    using SafeMath for uint;\r\n\r\n    function getPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_percent).div(_precision);\r\n    }\r\n\r\n    function getValueWithPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.add(getPercent(_value, _percent, _precision));\r\n    }\r\n\r\n    function getFullValueFromPercentedValue(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_precision).div(_percent);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/DataParser.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n/// @title Provides functions to parse and copy input data stream for LX Contract module.\r\nlibrary DataParser {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // constant uint CONTRACT_DATA_STRUCT_LENGTH = 232;\r\n    // constant uint TASK_DATA_STRUCT_LENGTH = 102;\r\n    // constant uint PENALTY_DATA_STRUCT_LENGTH = 74;\r\n    // constant uint TERMINATION_DATA_STRUCT_LENGTH = 70;\r\n\r\n    /** @dev DATA_STRUCTURE_TYPE {\r\n            CONTRACT = 1,\r\n            TASK = 2,\r\n            PENALTY = 3,\r\n            TERMINATION = 4\r\n        }\r\n    */\r\n    /// @dev CONTRACT_TYPE { JOB = 1, DISPUTE = 2 }\r\n    /// @dev PAYMENT_TIMELINE { PAY_BY_TASK = 1, PAY_BY_PROJECT = 2 }\r\n    /// @dev PAYMENT_VALUE_TYPE { CURRENCY = 1; PERCENT = 2 }\r\n    /// @dev PENALTY_APPLICATION_TYPE { MISS_DEADLINE = 1, LATE_PAYMENT = 2 }\r\n    /// @dev TERMINATION_PARTY { TERMINATION_EMPLOYER = 1, TERMINATION_ASSIGNEE = 2 }\r\n\r\n    enum ContractType { INVALID, JOB, DISPUTE }\r\n    enum PaymentValueType { INVALID, CURRENCY, PERCENT }\r\n    enum PaymentTimeline { INVALID, PAY_BY_TASK, PAY_BY_PROJECT }\r\n    enum TerminationParty { INVALID, TERMINATION_EMPLOYER, TERMINATION_ASSIGNEE }\r\n    enum PenaltyApplicationType { INVALID, MISS_DEADLINE, LATE_PAYMENT }\r\n\r\n    enum DataStructureType {\r\n        INVALID,\r\n        CONTRACT,\r\n        TASK,\r\n        PENALTY,\r\n        TERMINATION\r\n    }\r\n\r\n    /// @dev Contract data structure\r\n    struct ContractData {\r\n        /// @dev CONTRACT_TYPE type\r\n        uint8 contractType;\r\n        bytes32 documentHash;\r\n        /// @dev for dispute contracts\r\n        bytes32 linkedContractId;\r\n        address employer;\r\n        address assignee;\r\n        address arbiter;\r\n        address participant;\r\n        /// @dev timestamp\r\n        uint256 beginDate;\r\n        bytes32 paymentCurrencySymbol;\r\n        address paymentCurrencyAddress; // @deprecated\r\n        bool lockFullBudget;\r\n        /// @dev PAYMENT_TIMELINE type\r\n        uint8 paymentTimeline;\r\n        bool refundUpfrontOnTermination;\r\n        bool allowDynamicTasks;\r\n    }\r\n\r\n    /// @dev Task data structure\r\n    struct TaskData {\r\n        uint32 id;\r\n        bool isUpfront;\r\n        /// @dev PAYMENT_VALUE_TYPE type\r\n        uint8 upfrontValueType;\r\n        /// @dev interpretation is based on valueType\r\n        uint256 upfrontValue;\r\n        /// @dev total amount to pay\r\n        uint256 budget;\r\n        /// @dev timestamp\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct TaskPenaltyData {\r\n        uint32 id;\r\n        /// @dev penalized task id\r\n        uint32 taskId;\r\n        /// @dev PENALTY_APPLICATION_TYPE type\r\n        uint8 applicationType;\r\n        /// @dev PAYMENT_VALUE_TYPE type\r\n        uint8 valueType;\r\n        /// @dev interpretation is based on valueType\r\n        uint256 value;\r\n        /// @dev reserved for future purposes\r\n        bytes32 reserved1;\r\n    }\r\n\r\n    struct TerminationData {\r\n        uint32 id;\r\n        /// @dev TERMINATION_PARTY\r\n        uint8 initiatorType;\r\n        /// @dev TERMINATION_PARTY\r\n        uint8 payToType;\r\n        bytes32 description;\r\n        /// @dev PAYMENT_VALUE_TYPE type\r\n        uint8 valueType;\r\n        /// @dev interpretation is based on valueType\r\n        uint256 value;\r\n    }\r\n\r\n    function _getRawLengthForDataStructure(uint8 _dataStructureType) internal pure returns (uint _length) {\r\n        assembly {\r\n            switch _dataStructureType\r\n            case 1 { _length := 233 } // CONTRACT_DATA_STRUCT_LENGTH\r\n            case 2 { _length := 102 } // TASK_DATA_STRUCT_LENGTH\r\n            case 3 { _length := 74 } // PENALTY_DATA_STRUCT_LENGTH\r\n            case 4 { _length := 71 } // TERMINATION_DATA_STRUCT_LENGTH\r\n            default { revert(0,0) }\r\n        }\r\n    }\r\n\r\n    function _getFieldsNumberForDataStructure(uint8 _dataStructureType) private pure returns (uint _fields) {\r\n        assembly {\r\n            switch _dataStructureType\r\n            case 1 { _fields := 14 } // CONTRACT_DATA_STRUCT_LENGTH\r\n            case 2 { _fields := 6 } // TASK_DATA_STRUCT_LENGTH\r\n            case 3 { _fields := 6 } // PENALTY_DATA_STRUCT_LENGTH\r\n            case 4 { _fields := 6 } // TERMINATION_DATA_STRUCT_LENGTH\r\n            default { revert(0,0) }\r\n        }\r\n    }\r\n\r\n    function _countRawInputStructures(bytes memory _inputData, uint8 _dataStructureType) private pure returns (uint _counter) {\r\n        uint _pointerOffset;\r\n        while (_pointerOffset < _inputData.length) {\r\n            uint8 header;\r\n            assembly {\r\n                let pointer := add(_inputData, add(_pointerOffset, 0x1))\r\n                header := and(mload(pointer), 0xff)\r\n                if eq(header, _dataStructureType) {\r\n                    _counter := add(_counter, 1)\r\n                }\r\n            }\r\n\r\n            _pointerOffset += _getRawLengthForDataStructure(header) + 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Copies data from `_input` by length of `_cutLength` and pastes into\r\n    ///     `_output` with offset `_outputPointer`\r\n    function _cutDataFromInput(\r\n        bytes memory _input,\r\n        uint _cutLength,\r\n        bytes memory _output,\r\n        uint _outputPointer\r\n    )\r\n    private\r\n    pure\r\n    {\r\n        assembly {\r\n            let dataPointer := add(_output, _outputPointer)\r\n            let end := add(dataPointer, _cutLength)\r\n\r\n            for {\r\n                let cc := _input\r\n            } lt(dataPointer, end) {\r\n                dataPointer := add(dataPointer, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(dataPointer, mload(cc))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Allocates bytes array for keeping a struct data by providing number of struct items\r\n    ///     and number of fields in a struct.\r\n    ///     Reserves prefix memory slots for future struct casting.\r\n    function _allocUnpackedMemoryBytesArray(uint _structCount, uint _structFieldsNumber) private pure returns (bytes memory _arr) {\r\n        assembly {\r\n            _arr := add(mload(0x40), mul(_structCount, 0x20)) // prepend new memory area with _structCount more empty slots (for structure item references)\r\n            let _length := mul(mul(_structFieldsNumber, 0x20), _structCount)\r\n            mstore(_arr, _length)\r\n\r\n            mstore(0x40, add(_arr, add(_length, 0x20)))\r\n        }\r\n    }\r\n\r\n    /// @dev Allocates bytes array for keeping data\r\n    function _allocMemoryBytesArray(uint _structCount, uint _structDataLength) private pure returns (bytes memory _arr) {\r\n        assembly {\r\n            _arr := mload(0x40)\r\n            let _length := mul(_structDataLength, _structCount)\r\n            mstore(_arr, _length)\r\n\r\n            mstore(0x40, add(_arr, add(_length, 0x20)))\r\n        }\r\n    }\r\n\r\n    /// @dev Transforms provided array to have struct-like array presentation.\r\n    ///     Should provide array with preserved memory slots.\r\n    function _castMemoryArrayToStructureArray(\r\n        bytes memory _arr,\r\n        uint _structFieldsNumber\r\n    )\r\n    private\r\n    pure\r\n    returns (\r\n        bytes memory _castedArr\r\n    ) {\r\n        /**\r\n         * Transform raw bytes array into array of structures.\r\n         * It should have the following structure:\r\n         * - first byte: number of structures\r\n         * - n-bytes (n - number of structures): references into memory to structures' items ()\r\n         * - n+m-bytes: data\r\n         */\r\n        assembly {\r\n            let _structLength := mul(_structFieldsNumber, 0x20)\r\n            let _structuresCount := div(mload(_arr), _structLength)\r\n            _castedArr := sub(_arr, mul(_structuresCount, 0x20)) // set offset in opposite way to expand memory with structures' refs\r\n            mstore(_castedArr, _structuresCount)\r\n\r\n            let _writePointer := add(_castedArr, 0x20)\r\n            for { let _offsetIdx := 0 } lt(_offsetIdx, _structuresCount) { _offsetIdx := add(_offsetIdx, 1) } {\r\n                mstore(_writePointer, add(_arr, add(0x20, mul(_offsetIdx, _structLength))))\r\n                _writePointer := add(_writePointer, 0x20)\r\n            }\r\n        }\r\n    }\r\n\r\n    function cutCleanArrayFromRawInput(bytes memory _inputData, uint8 _dataStructureType)\r\n    internal\r\n    pure\r\n    returns (\r\n        bytes memory _packedData\r\n    ) {\r\n        uint _dataLength = _getRawLengthForDataStructure(_dataStructureType);\r\n        uint _structuresCount = _countRawInputStructures(_inputData, _dataStructureType);\r\n        _packedData = _allocMemoryBytesArray(_structuresCount, _dataLength);\r\n\r\n        bytes memory _offsetInputData;\r\n        uint _counter;\r\n        uint _pointerOffset;\r\n        while ((_pointerOffset < _inputData.length) && (_counter < _structuresCount)) {\r\n            uint8 header;\r\n            assembly {\r\n                let pointer := add(_inputData, add(_pointerOffset, 0x1))\r\n                header := and(mload(pointer), 0xff)\r\n                if eq(header, _dataStructureType) {\r\n                    _offsetInputData := add(pointer, 0x20)\r\n                }\r\n            }\r\n\r\n            if (header == _dataStructureType) {\r\n                _cutDataFromInput(_offsetInputData, _dataLength, _packedData, 0x20 + _counter * _dataLength);\r\n                _counter += 1;\r\n            }\r\n            _pointerOffset += _getRawLengthForDataStructure(header) + 1; // +1 for DATA_STRUCTURE_TYPE header byte\r\n        }\r\n    }\r\n\r\n    function unpackRawInputIntoMemoryArray(\r\n        bytes memory _inputData,\r\n        uint8 _dataStructureType,\r\n        function (bytes memory, bytes memory) internal pure _unpack\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        bytes memory _unpackedData\r\n    ) {\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(_dataStructureType);\r\n        uint _structCount = _countRawInputStructures(_inputData, _dataStructureType);\r\n        _unpackedData = _allocUnpackedMemoryBytesArray(_structCount, _fieldsNumber);\r\n\r\n        bytes memory _offsetInputData;\r\n        bytes memory _unpackDataPointer;\r\n        uint _pointerOffset;\r\n        uint _structCounter;\r\n        while ((_pointerOffset < _inputData.length) && (_structCounter < _structCount)) {\r\n            uint8 header;\r\n            assembly {\r\n                // read the first byte - DATA_STRUCTURE_TYPE\r\n                let pointer := add(_inputData, add(_pointerOffset, 0x1))\r\n                header := and(mload(pointer), 0xff)\r\n                if eq(header, _dataStructureType) {\r\n                    _offsetInputData := pointer\r\n                    _unpackDataPointer := add(_unpackedData, add(0x20, mul(mul(_structCounter, _fieldsNumber), 0x20)))\r\n                    _structCounter := add(_structCounter, 1)\r\n                }\r\n            }\r\n\r\n            if (header == _dataStructureType) {\r\n                _unpack(_offsetInputData, _unpackDataPointer);\r\n            }\r\n\r\n            _pointerOffset += _getRawLengthForDataStructure(header) + 1;\r\n        }\r\n    }\r\n\r\n    function unpackCleanArrayIntoMemoryArray(\r\n        bytes memory _inputData,\r\n        uint8 _dataStructureType,\r\n        function (bytes memory, bytes memory) internal pure _unpack\r\n    ) internal pure returns (bytes memory _unpackedData) {\r\n        uint _dataStructureLength = _getRawLengthForDataStructure(_dataStructureType);\r\n        require(_inputData.length % _dataStructureLength == 0, \"PARSER_INVALID_DATA_PADDING\");\r\n\r\n        bytes memory _offsetInputPointer;\r\n        bytes memory _offsetOutputPointer;\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(_dataStructureType);\r\n        uint _unpackedDataItemLength = _fieldsNumber * 32;\r\n\r\n        _unpackedData = _allocUnpackedMemoryBytesArray(_inputData.length / _dataStructureLength, _fieldsNumber);\r\n        assembly {\r\n            _offsetOutputPointer := add(_unpackedData, 0x20)\r\n        }\r\n        for (uint _inputOffset = 0; _inputOffset < _inputData.length; _inputOffset += _dataStructureLength) {\r\n            assembly {\r\n                _offsetInputPointer := add(_inputData, _inputOffset)\r\n            }\r\n\r\n            _unpack(_offsetInputPointer, _offsetOutputPointer);\r\n\r\n            assembly {\r\n                _offsetOutputPointer := add(_offsetOutputPointer, _unpackedDataItemLength)\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unpackContractIntoMemory(bytes memory _inputData, bytes memory _unpackedData) private pure {\r\n        assembly {\r\n            mstore(_unpackedData, and(mload(add(_inputData, 0x1)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x20), and(mload(add(_inputData, 0x21)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x40), and(mload(add(_inputData, 0x41)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x60), and(mload(add(_inputData, 0x55)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0x80), and(mload(add(_inputData, 0x69)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0xa0), and(mload(add(_inputData, 0x7d)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0xc0), and(mload(add(_inputData, 0x91)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0xe0), and(mload(add(_inputData, 0xb1)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x100), and(mload(add(_inputData, 0xd1)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x120), and(mload(add(_inputData, 0xe5)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0x140), and(mload(add(_inputData, 0xe6)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x160), and(mload(add(_inputData, 0xe7)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x180), and(mload(add(_inputData, 0xe8)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x1a0), and(mload(add(_inputData, 0xe9)), 0xff)) // 1 byte\r\n        }\r\n    }\r\n\r\n    function _unpackTaskIntoMemory(bytes memory _inputData, bytes memory _taskData) private pure {\r\n        assembly {\r\n            mstore(_taskData, and(mload(add(_inputData, 0x4)), 0xffffffff)) // 4 byte\r\n            mstore(add(_taskData, 0x20), and(mload(add(_inputData, 0x5)), 0xff)) // 1 byte\r\n            mstore(add(_taskData, 0x40), and(mload(add(_inputData, 0x6)), 0xff)) // 1 byte\r\n            mstore(add(_taskData, 0x60), and(mload(add(_inputData, 0x26)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_taskData, 0x80), and(mload(add(_inputData, 0x46)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_taskData, 0xa0), and(mload(add(_inputData, 0x66)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n        }\r\n    }\r\n\r\n    function _unpackTaskPenaltyIntoMemory(bytes memory _inputData, bytes memory _penaltyData) private pure {\r\n        assembly {\r\n            mstore(_penaltyData, and(mload(add(_inputData, 0x4)), 0xffffffff)) // 4 byte\r\n            mstore(add(_penaltyData, 0x20), and(mload(add(_inputData, 0x8)), 0xffffffff)) // 4 byte\r\n            mstore(add(_penaltyData, 0x40), and(mload(add(_inputData, 0x9)), 0xff)) // 1 byte\r\n            mstore(add(_penaltyData, 0x60), and(mload(add(_inputData, 0xa)), 0xff)) // 1 byte\r\n            mstore(add(_penaltyData, 0x80), and(mload(add(_inputData, 0x2a)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_penaltyData, 0xa0), and(mload(add(_inputData, 0x4a)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n        }\r\n    }\r\n\r\n    function _unpackTerminationIntoMemory(bytes memory _inputData, bytes memory _terminationData) private pure {\r\n        assembly {\r\n            mstore(_terminationData, and(mload(add(_inputData, 0x4)), 0xffffffff)) // 4 byte\r\n            mstore(add(_terminationData, 0x20), and(mload(add(_inputData, 0x5)), 0xff)) // 1 byte\r\n            mstore(add(_terminationData, 0x40), and(mload(add(_inputData, 0x6)), 0xff)) // 1 byte\r\n            mstore(add(_terminationData, 0x60), and(mload(add(_inputData, 0x26)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_terminationData, 0x80), and(mload(add(_inputData, 0x27)), 0xff)) // 1 byte\r\n            mstore(add(_terminationData, 0xa0), and(mload(add(_inputData, 0x47)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n        }\r\n    }\r\n\r\n    /** RAW INPUT PARSING */\r\n\r\n    function parseContractDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        ContractData memory _entity\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 1, _unpackContractIntoMemory); // DATA_STRUCTURE_TYPE = CONTRACT\r\n\r\n        assembly {\r\n            _entity := add(_data, 0x20)\r\n        }\r\n    }\r\n\r\n    function parseTaskDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 2, _unpackTaskIntoMemory); // DATA_STRUCTURE_TYPE = TASK\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(2);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTaskPenaltyDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskPenaltyData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 3, _unpackTaskPenaltyIntoMemory); // DATA_STRUCTURE_TYPE = PENALTY\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(3);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTerminationDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TerminationData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 4, _unpackTerminationIntoMemory); // DATA_STRUCTURE_TYPE = TERMINATION\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(4);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    /** CLEAN INPUT PARSING */\r\n\r\n    function parseContractDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        ContractData memory _entity\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 1, _unpackContractIntoMemory); // DATA_STRUCTURE_TYPE = CONTRACT\r\n\r\n        assembly {\r\n            _entity := add(_data, 0x20)\r\n        }\r\n    }\r\n\r\n    function parseTaskDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 2, _unpackTaskIntoMemory); // DATA_STRUCTURE_TYPE = TASK\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(2);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTaskPenaltyDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskPenaltyData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 3, _unpackTaskPenaltyIntoMemory); // DATA_STRUCTURE_TYPE = PENALTY\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(3);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTerminationDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TerminationData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 4, _unpackTerminationIntoMemory); // DATA_STRUCTURE_TYPE = TERMINATION\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(4);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    /** ASSERTIONS */\r\n\r\n    function assertContractData(ContractData memory _contract) internal view {\r\n        require(\r\n            _contract.contractType == uint8(ContractType.JOB) ||\r\n            _contract.contractType == uint8(ContractType.DISPUTE)\r\n        );\r\n        require(_contract.documentHash != bytes32(0));\r\n        require(_contract.employer != 0x0);\r\n        require(_contract.assignee != 0x0);\r\n        require(_contract.assignee != _contract.employer);\r\n        require(_contract.arbiter != _contract.assignee && _contract.arbiter != _contract.employer); // still allow _contract.arbiter to be 0x0\r\n        require(_contract.beginDate > block.timestamp);\r\n        require(_contract.paymentCurrencySymbol != bytes32(0)); // TODO: check if escrow supports this symbol\r\n        require(\r\n            _contract.paymentTimeline == uint8(PaymentTimeline.PAY_BY_TASK) ||\r\n            _contract.paymentTimeline == uint8(PaymentTimeline.PAY_BY_PROJECT)\r\n        );\r\n\r\n        if (_contract.contractType == 2) {\r\n            assertDisputeContractData(_contract);\r\n        }\r\n    }\r\n\r\n    function assertDisputeContractData(ContractData memory _contract) internal pure {\r\n        require(_contract.contractType == uint8(ContractType.DISPUTE));\r\n        require(_contract.linkedContractId != 0); // TODO: check linked contract for existance; check it is started, not under_dispute\r\n        require(_contract.participant != 0x0);\r\n        require(\r\n            _contract.participant != _contract.employer &&\r\n            _contract.participant != _contract.assignee &&\r\n            _contract.participant != _contract.arbiter\r\n        );\r\n    }\r\n\r\n    function assertDisputeContractWithLinkedContract(\r\n        ContractData memory _linkedContract,\r\n        ContractData memory _disputeContract\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        require(_disputeContract.arbiter == 0x0, \"PARSER_DISPUTE_SHOULD_NOT_PROVIDE_ARBITER\");\r\n        require(_linkedContract.arbiter == _disputeContract.assignee, \"PARSER_ARBITER_SHOULD_BE_ASSIGNEE_IN_DISPUTE\");\r\n        require(\r\n            _linkedContract.assignee == _disputeContract.employer ||\r\n            _linkedContract.assignee == _disputeContract.participant,\r\n            \"PARSER_ASSIGNEE_SHOULD_BE_EMPLOYER_OR_PARTICIPANT_IN_DISPUTE\"\r\n        );\r\n        require(\r\n            _linkedContract.employer == _disputeContract.employer ||\r\n            _linkedContract.employer == _disputeContract.participant,\r\n            \"PARSER_EMPLOYER_SHOULD_BE_EMPLOYER_OR_PARTICIPANT_IN_DISPUTE\"\r\n        );\r\n    }\r\n\r\n    function assertTaskPenalty(TaskPenaltyData memory _penalty) internal pure {\r\n        require(\r\n            _penalty.applicationType == uint8(PenaltyApplicationType.MISS_DEADLINE),/*  ||\r\n            _penalty.applicationType == uint8(DataParser.PenaltyApplicationType.LATE_PAYMENT) */\r\n            \"PARSER_PENALTY_INVALID_APPLICATION_TYPE\"\r\n        );\r\n    }\r\n\r\n    /** SEARCH */\r\n\r\n    function getTerminationResultValue(\r\n        TerminationData memory _terminationInfo,\r\n        uint _baseBudget,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _fullTerminationAmount)\r\n    {\r\n        if (_terminationInfo.valueType == uint(PaymentValueType.CURRENCY)) {\r\n            _fullTerminationAmount = _terminationInfo.value;\r\n        } else if (_terminationInfo.valueType == uint(PaymentValueType.PERCENT)) {\r\n            require(_terminationInfo.value <= _precision, \"PARSER_INVALID_TERMINATION_PERCENT_VALUE\");\r\n            _fullTerminationAmount = PercentCalculator.getPercent(_baseBudget, _terminationInfo.value, _precision);\r\n        } else {\r\n            revert(\"PARSER_INVALID_TERMINATION_PAYMENT_VALUE_TYPE\");\r\n        }\r\n    }\r\n\r\n    function getTaskPenaltyResultValue(\r\n        TaskPenaltyData memory _penalty,\r\n        uint _baseBudget,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _penaltyValue)\r\n    {\r\n        if (_penalty.valueType == uint(PaymentValueType.CURRENCY)) {\r\n            _penaltyValue = _penalty.value;\r\n        } else if (_penalty.valueType == uint(PaymentValueType.PERCENT)) {\r\n            require(_penalty.value <= _precision, \"PARSER_INVALID_TASK_PENALTY_PERCENT_VALUE\");\r\n            _penaltyValue = PercentCalculator.getPercent(_baseBudget, _penalty.value, _precision);\r\n        } else {\r\n            revert(\"PARSER_INVALID_TASK_PENALTY_PAYMENT_VALUE_TYPE\");\r\n        }\r\n    }\r\n\r\n    function getTaskUpfrontResultValue(\r\n        TaskData memory _task,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _upfrontValue)\r\n    {\r\n        if (_task.upfrontValueType == uint(PaymentValueType.CURRENCY)) {\r\n            require(_task.upfrontValue <= _task.budget, \"PARSER_INVALID_TASK_UPFRONT_CURRENCY_VALUE\");\r\n            _upfrontValue = _task.upfrontValue;\r\n        } else if (_task.upfrontValueType == uint(PaymentValueType.PERCENT)) {\r\n            require(_task.upfrontValue <= _precision, \"PARSER_INVALID_TASK_UPFRONT_PERCENT_VALUE\");\r\n            _upfrontValue = PercentCalculator.getPercent(_task.budget, _task.upfrontValue, _precision);\r\n        } else {\r\n            revert(\"PARSER_INVALID_TASK_UPFRONT_PAYMENT_VALUE_TYPE\");\r\n        }\r\n    }\r\n\r\n    function getTerminationById(\r\n        uint _terminationId,\r\n        bytes memory _clearData\r\n    )\r\n    internal\r\n    pure\r\n    returns (TerminationData memory)\r\n    {\r\n        TerminationData[] memory _terminations = parseTerminationDataCleanInput(_clearData);\r\n\r\n        for (uint _idx = 0; _idx < _terminations.length; ++_idx) {\r\n            if (_terminations[_idx].id == _terminationId) {\r\n                return _terminations[_idx];\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTerminationParty(ContractData memory _contractInfo, address _account) internal pure returns (TerminationParty) {\r\n        if (_account == _contractInfo.employer) {\r\n            return TerminationParty.TERMINATION_EMPLOYER;\r\n        } else if (_account == _contractInfo.assignee) {\r\n            return TerminationParty.TERMINATION_ASSIGNEE;\r\n        }\r\n\r\n        revert(\"PARSER_INVALID_INITIATOR_PARTY_ACCOUNT\");\r\n    }\r\n\r\n    function getOppositeTerminationParty(TerminationParty _terminationParty) internal pure returns (TerminationParty) {\r\n        if (_terminationParty == TerminationParty.TERMINATION_EMPLOYER) {\r\n            return TerminationParty.TERMINATION_ASSIGNEE;\r\n        } else if (_terminationParty == TerminationParty.TERMINATION_ASSIGNEE) {\r\n            return TerminationParty.TERMINATION_EMPLOYER;\r\n        }\r\n\r\n        revert(\"PARSER_UNHANDLED_INITIATOR_PARTY\");\r\n    }\r\n}\r\n\r\n// File: contracts/labor-contract/LaborContractCore.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LaborContractCore is\r\n    InitializableStorageAdapter,\r\n    FeeConstants\r\n{\r\n    StorageInterface.Bytes32AddressMapping internal escrowStorage;\r\n    StorageInterface.Bytes32AddressMapping internal workflowStorage;\r\n\r\n    /// @dev keccak(contractId, signer address) => boolean\r\n    StorageInterface.Bytes32BoolMapping internal signsStorage;\r\n    /// @dev keccak(contractId, signer address) => salt (from #sign)\r\n    StorageInterface.Bytes32UIntMapping internal signsSaltStorage;\r\n    /// @dev keccak(contractId, signer address) => signature (from #sign)\r\n    StorageInterface.BytesSequenceMapping internal signsSignatureStorage;\r\n    /// @dev contractId => set of salts\r\n    StorageInterface.UIntSetMapping internal signsInvalidatedSaltsStorage;\r\n\r\n    // StorageInterface.Bytes32Bytes32Mapping internal baseContractStorage;\r\n    // StorageInterface.Bytes32SetMapping internal linkedContractsStorage;\r\n\r\n    StorageInterface.Bytes32UInt8Mapping internal contractStateStorage;\r\n    StorageInterface.Bytes32Bytes32Mapping internal contractDocumentHashStorage;\r\n    StorageInterface.BytesSequenceMapping internal contractInfoStorage;\r\n    StorageInterface.BytesSequenceMapping internal terminationsStorage;\r\n\r\n    StorageInterface.BytesSequenceMapping internal proposedTasksStorage;\r\n    StorageInterface.Bytes32Bytes32Mapping internal proposedDocumentHashStorage;\r\n\r\n    /// @dev proposition to store ID of termination with the highest termination budget\r\n    /// contractId => max locked termination value\r\n    StorageInterface.Bytes32UIntMapping internal terminationLockedBalanceStorage;\r\n\r\n    /// @dev contractId => upfront balance\r\n    StorageInterface.Bytes32UIntMapping internal budgetUpfrontPaymentAmountStorage;\r\n    // StorageInterface.Bytes32UIntMapping internal totalLockBudgetAmountStorage;\r\n    StorageInterface.Bytes32UIntMapping internal totalBudgetAmountStorage;\r\n    /// @dev contractId => sum of total completed (of future) payments\r\n    StorageInterface.Bytes32UIntMapping internal completedPaymentsBalanceStorage;\r\n    /// @dev contractId => sum of total completed and transferred payments\r\n    StorageInterface.Bytes32UIntMapping internal transferredPaymentsBalanceStorage;\r\n\r\n    StorageInterface.Bytes32UIntMapping internal terminationRequestIdStorage;\r\n    StorageInterface.StringMapping internal terminationReasonStorage;\r\n\r\n    StorageInterface.Address internal terminatableStorage;\r\n    StorageInterface.Address internal disputableStorage;\r\n    StorageInterface.Address internal signableStorage;\r\n    StorageInterface.Address internal completableStorage;\r\n    StorageInterface.Address internal tasksProposableStorage;\r\n\r\n\r\n    function _initCore() internal {\r\n        escrowStorage.init(\"escrow\");\r\n        workflowStorage.init(\"workflow\");\r\n        signsStorage.init(\"signs\");\r\n        signsSaltStorage.init(\"signsSalt\");\r\n        signsSignatureStorage.init(\"signsSignature\");\r\n        signsInvalidatedSaltsStorage.init(\"signsInvalidatedSalts\");\r\n        // baseContractStorage.init(\"baseContract\");\r\n        // linkedContractsStorage.init(\"linkedContracts\");\r\n        contractStateStorage.init(\"contractState\");\r\n        contractDocumentHashStorage.init(\"contractDocumentHash\");\r\n        contractInfoStorage.init(\"contractInfo\");\r\n        terminationsStorage.init(\"terminations\");\r\n        proposedTasksStorage.init(\"proposedTasks\");\r\n        proposedDocumentHashStorage.init(\"proposedDocumentHash\");\r\n        terminationLockedBalanceStorage.init(\"terminationLockedBalance\");\r\n        budgetUpfrontPaymentAmountStorage.init(\"budgetUpfrontPaymentAmount\");\r\n        // totalLockBudgetAmountStorage.init(\"totalLockBudgetAmount\");\r\n        totalBudgetAmountStorage.init(\"totalBudgetAmount\");\r\n        terminationRequestIdStorage.init(\"terminationRequestId\");\r\n        terminationReasonStorage.init(\"terminationReason\");\r\n        completedPaymentsBalanceStorage.init(\"completedPaymentsBalance\");\r\n        transferredPaymentsBalanceStorage.init(\"transferredPaymentsBalance\");\r\n        terminatableStorage.init(\"terminatable\");\r\n        disputableStorage.init(\"disputable\");\r\n        signableStorage.init(\"signable\");\r\n        completableStorage.init(\"completable\");\r\n        tasksProposableStorage.init(\"tasksProposable\");\r\n    }\r\n}\r\n\r\n\r\ncontract LaborContractEventEmitter {\r\n\r\n    event ContractCreated(bytes32 indexed contractId, bytes32 documentHash);\r\n    event ContractSigned(bytes32 indexed contractId, bytes32 documentHash, address signer, uint expireAtBlock, uint salt);\r\n    event ContractSignRevoked(bytes32 indexed contractId, address signer);\r\n    event ContractStarted(bytes32 indexed contractId, uint _depositValue);\r\n    event ContractTasksProposed(bytes32 indexed contractId, bytes32 documentHash);\r\n    event ContractTasksAccepted(bytes32 indexed contractId, bytes32 documentHash);\r\n    event ContractDisputeResolved(bytes32 indexed contractId);\r\n    event ContractTerminationRequested(bytes32 indexed contractId, uint terminationId, address initiator, string comment);\r\n    event ContractTerminationRequestCancelled(bytes32 indexed contractId, uint terminationId);\r\n    event ContractTerminated(bytes32 indexed contractId, uint terminationId);\r\n    event ContractStateTransitioned(bytes32 indexed contractId, uint8 indexed previousState, uint8 indexed currentState);\r\n    event ContractOperationLogged(bytes32 indexed contractId, string indexed operationAction);\r\n    event ContractWithdrawOperationLogged(bytes32 indexed contractId, string indexed operationAction, uint depositValue, uint paymentAmount);\r\n}\r\n\r\n\r\ncontract LaborContractAbstract is\r\n    LaborContractCore,\r\n    LaborContractEventEmitter\r\n{\r\n    using SafeMath for uint;\r\n\r\n    enum State { NOT_INITIALIZED, CREATED, SIGNED, STARTED, TERMINATION_REQUESTED, TERMINATED, UNDER_DISPUTE, COMPLETED }\r\n\r\n    uint constant internal OK = 1;\r\n    uint constant internal TERMINATION_PERCENT_PRECISION = 10000;\r\n\r\n    modifier onlyInState(bytes32 _contractId, State _state) {\r\n        require(_getContractState(_contractId) == _state, \"C_S\");\r\n        _;\r\n    }\r\n\r\n    function getEscrow(bytes32 _contractId) public view returns (EscrowBaseInterface) {\r\n        return EscrowBaseInterface(store.get(escrowStorage, _contractId));\r\n    }\r\n\r\n    function getWorkflow(bytes32 _contractId) public view returns (WorkflowBase) {\r\n        return WorkflowBase(store.get(workflowStorage, _contractId));\r\n    }\r\n\r\n    function getServiceSurchargePercent(bytes32 _contractId) public view returns (uint _percent, uint _precision) {\r\n        (, _percent, _precision) = getEscrow(_contractId).getServiceFeeInfo();\r\n    }\r\n\r\n    function version() public pure returns (string);\r\n\r\n    /** INTERNAL */\r\n\r\n    function _setContractStateTo(bytes32 _contractId, State _newState) internal {\r\n        require(_newState != State.NOT_INITIALIZED, \"C_NI\");\r\n\r\n        State _currentState = _getContractState(_contractId);\r\n        if (_currentState == _newState) {\r\n            return;\r\n        }\r\n\r\n        store.set(contractStateStorage, _contractId, uint8(_newState));\r\n\r\n        emit ContractStateTransitioned(_contractId, uint8(_currentState), uint8(_newState));\r\n    }\r\n\r\n    function _getContractState(bytes32 _contractId) internal view returns (State) {\r\n        return State(store.get(contractStateStorage, _contractId));\r\n    }\r\n\r\n    function _getContractDocumentHash(\r\n        bytes32 _contractId,\r\n        DataParser.ContractData memory _contractInfo\r\n    )\r\n    internal\r\n    view\r\n    returns (bytes32 _documentHash)\r\n    {\r\n        _documentHash = store.get(contractDocumentHashStorage, _contractId);\r\n        if (_documentHash == bytes32(0)) {\r\n            _documentHash = _contractInfo.documentHash;\r\n        }\r\n    }\r\n\r\n    function _getContractInfoBytes(bytes32 _contractId) internal view returns (bytes memory _data) {\r\n        return store.get(contractInfoStorage, _contractId);\r\n    }\r\n\r\n    function _getTerminationsInfoBytes(bytes32 _contractId) internal view returns (bytes memory _data) {\r\n        return store.get(terminationsStorage, _contractId);\r\n    }\r\n\r\n    function _getContractAccumulatedPaymentAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(completedPaymentsBalanceStorage, _contractId);\r\n    }\r\n\r\n    function _getContractTransferredPaymentAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(transferredPaymentsBalanceStorage, _contractId);\r\n    }\r\n\r\n    function _getContractTotalBudgetAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(totalBudgetAmountStorage, _contractId);\r\n    }\r\n\r\n    function _getContractLockedTerminationAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(terminationLockedBalanceStorage, _contractId);\r\n    }\r\n\r\n    function _getLeftToPayAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return _getContractAccumulatedPaymentAmount(_contractId).sub(_getContractTransferredPaymentAmount(_contractId));\r\n    }\r\n\r\n    function _incrementTransferredBalance(bytes32 _contractId, uint _value) internal {\r\n        store.set(transferredPaymentsBalanceStorage, _contractId, _getContractTransferredPaymentAmount(_contractId).add(_value));\r\n    }\r\n\r\n    function _decrementTransferredBalance(bytes32 _contractId, uint _value) internal {\r\n        store.set(transferredPaymentsBalanceStorage, _contractId, _getContractTransferredPaymentAmount(_contractId).sub(_value));\r\n    }\r\n\r\n    function _incrementLockedTerminationAmount(bytes32 _contractId, uint _value) internal {\r\n        store.set(terminationLockedBalanceStorage, _contractId, _getContractLockedTerminationAmount(_contractId).add(_value));\r\n\r\n    }\r\n\r\n    function _incrementUpfrontPaymentAmount(bytes32 _contractId, uint _value) internal {\r\n        if (_value > 0) {\r\n            uint _currentUpfrontPaymentAmount = store.get(budgetUpfrontPaymentAmountStorage, _contractId);\r\n            store.set(budgetUpfrontPaymentAmountStorage, _contractId, _currentUpfrontPaymentAmount.add(_value));\r\n        }\r\n    }\r\n\r\n    function _decrementLockedTerminationAmount(bytes32 _contractId, uint _value) internal {\r\n        store.set(terminationLockedBalanceStorage, _contractId, _getContractLockedTerminationAmount(_contractId).sub(_value));\r\n    }\r\n\r\n    function _incrementCompletedPaymentValue(bytes32 _contractId, uint _value) internal {\r\n        uint _completedPaymentsBalance = _getContractAccumulatedPaymentAmount(_contractId);\r\n        store.set(completedPaymentsBalanceStorage, _contractId, _completedPaymentsBalance.add(_value));\r\n    }\r\n\r\n    function _decrementCompletedPaymentValue(bytes32 _contractId, uint _value) internal {\r\n        uint _completedPaymentsBalance = _getContractAccumulatedPaymentAmount(_contractId);\r\n        store.set(completedPaymentsBalanceStorage, _contractId, _completedPaymentsBalance.sub(_value));\r\n    }\r\n}\r\n\r\n// File: contracts/labor-contract/LaborContract.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LaborContractInterface is\r\n    LaborContractBase,\r\n    LaborContractBaseInitializable,\r\n    LaborContractBaseGeneralizable,\r\n    LaborContractBaseSignable,\r\n    LaborContractBaseCompletable,\r\n    LaborContractBaseTasksProposable,\r\n    LaborContractBaseTerminatable,\r\n    LaborContractBaseDisputable,\r\n    LaborContractBaseOperationable,\r\n    InitializableOwned,\r\n    LaborContractAbstract\r\n{\r\n}\r\n\r\n\r\ncontract LaborContract is\r\n    Delegatable,\r\n    LaborContractBaseInitializable,\r\n    LaborContractBaseGeneralizable,\r\n    LaborContractBaseOperationable,\r\n    InitializableOwned,\r\n    LaborContractAbstract\r\n{\r\n\r\n    /// @dev LaborContractBaseSignable\r\n\r\n    /// @dev getLockingDepositBalance(bytes32)\r\n    bytes4 constant private SIG_GET_LOCKING_DEPOSIT_BALANCE = hex\"ff13a302\";\r\n    /// @dev getLockingContractDetails(bytes32)\r\n    bytes4 constant private SIG_GET_LOCKING_CONTRACT_DETAILS = hex\"59198fab\";\r\n    /// @dev createContractAndSign(bytes32,address,address,bytes,uint256,uint256,bytes)\r\n    bytes4 constant private SIG_CREATE_CONTRACT_AND_SIGN = hex\"f9988ce7\";\r\n    /// @dev sign(bytes32,bytes32,uint256,uint256,bytes)\r\n    bytes4 constant private SIG_SIGN = hex\"f5b32e74\";\r\n    /// @dev revokeSign(bytes32)\r\n    bytes4 constant private SIG_REVOKE_SIGN = hex\"3c565c71\";\r\n    /// @dev signAndDeposit(bytes32,bytes32,uint256,uint256,uint256,bytes)\r\n    bytes4 constant private SIG_SIGN_AND_DEPOSIT = hex\"87791ff9\";\r\n\r\n    /// @dev LaborContractBaseCompletable\r\n\r\n    /// @dev getCompletionContractDepositBalance(bytes32)\r\n    bytes4 constant private SIG_GET_COMPLETION_CONTRACT_DEPOSIT_BALANCE = hex\"2b82952b\";\r\n    /// @dev getCompletionContractDetails(bytes32)\r\n    bytes4 constant private SIG_GET_COMPLETION_CONTRACT_DETAILS = hex\"d633e835\";\r\n    /// @dev completeContract(bytes32,uint256,uint256,bytes)\r\n    bytes4 constant private SIG_COMPLETE_CONTRACT = hex\"27e6c58c\";\r\n\r\n    /// @dev LaborContractBaseTasksProposable\r\n\r\n    /// @dev getContractProposedTasksDetails(bytes32)\r\n    bytes4 constant private SIG_GET_CONTRACT_PROPOSED_TASKS_DETAILS = hex\"347cedbe\";\r\n    /// @dev proposeTasks(bytes32,bytes32,bytes)\r\n    bytes4 constant private SIG_PROPOSE_TASKS = hex\"bb86de8c\";\r\n    /// @dev acceptProposedTasksAndDeposit(bytes32,bytes32,uint256)\r\n    bytes4 constant private SIG_ACCEPT_PROPOSED_TASKS_AND_DEPOSIT = hex\"f1574848\";\r\n\r\n    /// @dev LaborContractBaseTerminatable\r\n\r\n    /// @dev getTerminationInitiateDepositDetails(bytes32,uint256)\r\n    bytes4 constant private SIG_GET_TERMINATION_INITIATE_DEPOSIT_DETAILS = hex\"376f72d6\";\r\n    /// @dev getTerminationCancelDepositDetails(bytes32,uint256)\r\n    bytes4 constant private SIG_GET_TERMINATION_CANCEL_DEPOSIT_DETAILS = hex\"e0e70cae\";\r\n    /// @dev getTerminationConfirmDepositDetails(bytes32,uint256)\r\n    bytes4 constant private SIG_GET_TERMINATION_CONFIRM_DEPOSIT_DETAILS = hex\"42d6c779\";\r\n    /// @dev getTerminationPaymentAmounts(bytes32,uint256)\r\n    bytes4 constant private SIG_GET_TERMINATION_PAYMENT_AMOUNTS = hex\"d1089d36\";\r\n    /// @dev getTerminationContractDetails(bytes32,uint256)\r\n    bytes4 constant private SIG_GET_TERMINATION_CONTRACT_DETAILS = hex\"5dacca44\";\r\n    /// @dev initiateTermination(bytes32,uint32,uint256,string)\r\n    bytes4 constant private SIG_INITIATE_TERMINATION = hex\"6c62e81a\";\r\n    /// @dev cancelTerminationRequest(bytes32)\r\n    bytes4 constant private SIG_CANCEL_TERMINATION_REQUEST = hex\"91044a22\";\r\n    /// @dev cancelTerminationRequestWithApproval(bytes32,uint256,uint256,bytes)\r\n    bytes4 constant private SIG_CANCEL_TERMINATION_REQUEST_WITH_APPROVAL = hex\"ac933bc0\";\r\n    /// @dev confirmTermination(bytes32,uint256,uint256,uint256,bytes,uint256,bytes)\r\n    bytes4 constant private SIG_CONFIRM_TERMINATION = hex\"6ac2584c\";\r\n\r\n    /// @dev LaborContractBaseDisputable\r\n\r\n    /// @dev getResolvingContractDetails(bytes32,uint256)\r\n    bytes4 constant private SIG_GET_RESOLVING_CONTRACT_DETAILS = hex\"5461e24c\";\r\n    /// @dev resolveContract(bytes32,uint256,uint256,bytes)\r\n    bytes4 constant private SIG_RESOLVE_CONTRACT = hex\"7416d14e\";\r\n\r\n    modifier onlyOnWorkflowOperation(bytes32 _contractId) {\r\n        require(msg.sender == address(getWorkflow(_contractId)), \"C_OW\"); // C_OW == only workflow allowed\r\n        _;\r\n    }\r\n\r\n    constructor(address _storage, bytes32 _crate) StorageAdapter(Storage(_storage), _crate) public {\r\n        _initCore();\r\n    }\r\n\r\n    function () external payable {\r\n        if (\r\n            msg.sig == SIG_GET_CONTRACT_PROPOSED_TASKS_DETAILS ||\r\n            msg.sig == SIG_PROPOSE_TASKS ||\r\n            msg.sig == SIG_ACCEPT_PROPOSED_TASKS_AND_DEPOSIT\r\n        ) {\r\n            _delegate(store.get(tasksProposableStorage));\r\n        } else if (\r\n            msg.sig == SIG_CREATE_CONTRACT_AND_SIGN ||\r\n            msg.sig == SIG_SIGN ||\r\n            msg.sig == SIG_REVOKE_SIGN ||\r\n            msg.sig == SIG_SIGN_AND_DEPOSIT ||\r\n            msg.sig == SIG_GET_LOCKING_DEPOSIT_BALANCE ||\r\n            msg.sig == SIG_GET_LOCKING_CONTRACT_DETAILS\r\n        ) {\r\n            _delegate(store.get(signableStorage));\r\n        } else if (\r\n            msg.sig == SIG_GET_COMPLETION_CONTRACT_DEPOSIT_BALANCE ||\r\n            msg.sig == SIG_GET_COMPLETION_CONTRACT_DETAILS ||\r\n            msg.sig == SIG_COMPLETE_CONTRACT\r\n        ) {\r\n            _delegate(store.get(completableStorage));\r\n        } else if (\r\n            msg.sig == SIG_GET_TERMINATION_INITIATE_DEPOSIT_DETAILS ||\r\n            msg.sig == SIG_GET_TERMINATION_CANCEL_DEPOSIT_DETAILS ||\r\n            msg.sig == SIG_GET_TERMINATION_CONFIRM_DEPOSIT_DETAILS ||\r\n            msg.sig == SIG_GET_TERMINATION_PAYMENT_AMOUNTS ||\r\n            msg.sig == SIG_GET_TERMINATION_CONTRACT_DETAILS ||\r\n            msg.sig == SIG_INITIATE_TERMINATION ||\r\n            msg.sig == SIG_CANCEL_TERMINATION_REQUEST ||\r\n            msg.sig == SIG_CANCEL_TERMINATION_REQUEST_WITH_APPROVAL ||\r\n            msg.sig == SIG_CONFIRM_TERMINATION\r\n        ) {\r\n            _delegate(store.get(terminatableStorage));\r\n        } else if (\r\n            msg.sig == SIG_GET_RESOLVING_CONTRACT_DETAILS ||\r\n            msg.sig == SIG_RESOLVE_CONTRACT\r\n        ) {\r\n            _delegate(store.get(disputableStorage));\r\n        }\r\n\r\n        revert(\"C_ETH\");\r\n    }\r\n\r\n    function version() public pure returns (string) {\r\n        return \"0.1.0\";\r\n    }\r\n\r\n    function initLaborContract(\r\n        address _owner,\r\n        address _storage,\r\n        bytes32 _crate\r\n    ) external {\r\n        _initOwned(_owner);\r\n        _initStorageAdapter(Storage(_storage), _crate);\r\n        _initCore();\r\n    }\r\n\r\n    function setExtensionContracts(\r\n        address _signable,\r\n        address _terminatable,\r\n        address _disputable,\r\n        address _completable,\r\n        address _tasksProposable\r\n    )\r\n    external\r\n    onlyContractOwner\r\n    {\r\n        _initLaborSignableExtensions(_signable);\r\n        _initLaborTerminatableExtensions(_terminatable);\r\n        _initLaborDisputableExtensions(_disputable);\r\n        _initLaborCompletableExtensions(_completable);\r\n        _initLaborTasksProposableExtensions(_tasksProposable);\r\n    }\r\n\r\n    function _initLaborSignableExtensions(address _signable) internal {\r\n        if (store.get(signableStorage) != _signable) {\r\n            store.set(signableStorage, _signable);\r\n        }\r\n    }\r\n\r\n    function _initLaborTerminatableExtensions(address _terminatable) internal {\r\n        if (store.get(terminatableStorage) != _terminatable) {\r\n            store.set(terminatableStorage, _terminatable);\r\n        }\r\n    }\r\n\r\n    function _initLaborDisputableExtensions(address _disputable) internal {\r\n        if (store.get(disputableStorage) != _disputable) {\r\n            store.set(disputableStorage, _disputable);\r\n        }\r\n    }\r\n\r\n    function _initLaborCompletableExtensions(address _completable) internal {\r\n        if (store.get(completableStorage) != _completable) {\r\n            store.set(completableStorage, _completable);\r\n        }\r\n    }\r\n\r\n    function _initLaborTasksProposableExtensions(address _tasksProposable) internal {\r\n        if (store.get(tasksProposableStorage) != _tasksProposable) {\r\n            store.set(tasksProposableStorage, _tasksProposable);\r\n        }\r\n    }\r\n\r\n    function getPaymentRequirements(bytes32 _contractId) external view returns (bool _lockFullBudget, uint8 _paymentTimeline) {\r\n        DataParser.ContractData memory _contractInfo = DataParser.parseContractDataCleanInput(_getContractInfoBytes(_contractId));\r\n        return (_contractInfo.lockFullBudget, _contractInfo.paymentTimeline);\r\n    }\r\n\r\n    function getContractState(bytes32 _contractId) external view returns (uint8 _state) {\r\n        return uint8(_getContractState(_contractId));\r\n    }\r\n\r\n    function getContractParties(bytes32 _contractId) public view returns (address _employer, address _assignee) {\r\n        DataParser.ContractData memory _contractInfo = DataParser.parseContractDataCleanInput(_getContractInfoBytes(_contractId));\r\n        return (_contractInfo.employer, _contractInfo.assignee);\r\n    }\r\n\r\n    function onOperation(\r\n        bytes32 _contractId,\r\n        string _operationAction\r\n    )\r\n    external\r\n    onlyInState(_contractId, State.STARTED)\r\n    onlyOnWorkflowOperation(_contractId)\r\n    {\r\n        emit ContractOperationLogged(_contractId, _operationAction);\r\n    }\r\n\r\n    function onWithdrawOperation(\r\n        bytes32 _contractId,\r\n        string _operationAction,\r\n        uint _depositValue,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    payable\r\n    onlyInState(_contractId, State.STARTED)\r\n    onlyOnWorkflowOperation(_contractId)\r\n    {\r\n        emit ContractWithdrawOperationLogged(_contractId, _operationAction, _depositValue, _value);\r\n\r\n        _incrementCompletedPaymentValue(_contractId, _value);\r\n\r\n        DataParser.ContractData memory _contractInfo = DataParser.parseContractDataCleanInput(_getContractInfoBytes(_contractId));\r\n\r\n        if (_contractInfo.paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_TASK)) {\r\n            _doWithdrawOperationToEscrow(\r\n                _contractId,\r\n                _depositValue,\r\n                _value,\r\n                _expireAtBlock,\r\n                _salt,\r\n                _signature,\r\n                _contractInfo\r\n            );\r\n            _incrementTransferredBalance(_contractId, _value);\r\n            return;\r\n        } else if (_contractInfo.paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_PROJECT)) {\r\n            /**\r\n                save provided payment info with `_incrementCompletedPaymentValue`. See above\r\n             */\r\n            return;\r\n        }\r\n\r\n        revert(\"C_PI\"); // C_PI == invalid payment timeline\r\n    }\r\n\r\n    /** PRIVATE */\r\n\r\n    function _doWithdrawOperationToEscrow(\r\n        bytes32 _contractId,\r\n        uint _depositValue,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature,\r\n        DataParser.ContractData memory _contractInfo\r\n    )\r\n    private\r\n    {\r\n        EscrowBaseInterface _escrow = getEscrow(_contractId);\r\n\r\n        if (_depositValue > 0) {\r\n            require(\r\n                OK == _escrow.deposit.value(msg.value)\r\n                (\r\n                    _contractId,\r\n                    _contractInfo.employer,\r\n                    _contractInfo.assignee,\r\n                    _depositValue,\r\n                    0,\r\n                    _getNoFeeFlag()\r\n                ),\r\n                \"C_DE\" // C_DE == invalid deposit operation on escrow\r\n            );\r\n        }\r\n\r\n        require(\r\n            OK == _escrow.releaseBuyerPayment\r\n            (\r\n                _contractId,\r\n                _contractInfo.employer,\r\n                _contractInfo.assignee,\r\n                _value,\r\n                _expireAtBlock,\r\n                _salt,\r\n                _signature,\r\n                _getAllFeeFlag()\r\n            ),\r\n            \"C_RBE\" // C_RBE == invalid release buyer payment on escrow\r\n        );\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/libs/Arrays.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\nlibrary Arrays {\r\n\r\n    function contains(\r\n        uint32[] _array,\r\n        uint32 _tryItem\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        for (uint _idx = 0; _idx < _array.length; ++_idx) {\r\n            if (_array[_idx] == _tryItem) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTaskById(\r\n        DataParser.TaskData[] memory _tasks,\r\n        uint32 _tryTaskId\r\n    )\r\n    internal\r\n    pure\r\n    returns (DataParser.TaskData memory)\r\n    {\r\n        for (uint _taskIdx = 0; _taskIdx < _tasks.length; ++_taskIdx) {\r\n            if (_tasks[_taskIdx].id == _tryTaskId) {\r\n                return _tasks[_taskIdx];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/workflow/Workflow.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract WorkflowEventEmitter {\r\n\r\n    event TaskStateChanged(\r\n        bytes32 indexed _contractKey,\r\n        bytes32 contractId,\r\n        uint indexed taskId,\r\n        uint8 indexed newState,\r\n        uint8 previousState\r\n    );\r\n}\r\n\r\n\r\ncontract Workflow is\r\n    WorkflowBase,\r\n    WorkflowEventEmitter,\r\n    InitializableOwned,\r\n    WorkflowContractBlacklistableBase,\r\n    WorkflowCore\r\n{\r\n    using SafeMath for uint;\r\n\r\n    modifier onlyContractAssignee(bytes32 _contractId, address _contract) {\r\n        (,address _assignee) = LaborContract(_contract).getContractParties(_contractId);\r\n        require(msg.sender == _assignee, \"WORKFLOW_ASSIGNEE_SHOULD_CALL\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyContractEmployer(bytes32 _contractId, address _contract) {\r\n        (address _employer,) = LaborContract(_contract).getContractParties(_contractId);\r\n        require(msg.sender == _employer, \"WORKFLOW_EMPLOYER_SHOULD_CALL\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyContractProxy(address _contract) {\r\n        require(msg.sender == _contract, \"WORKFLOW_CONTRACT_SHOULD_CALL\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyExistedContract(bytes32 _contractId, address _contract) {\r\n        require(\r\n            store.get(contractRegistrationsStorage, _getContractRecordKey(_contractId, _contract)),\r\n            \"WORKFLOW_CONTRACT_SHOULD_EXIST\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyTaskInState(bytes32 _contractId, address _contract, uint _taskId, TaskState _state) {\r\n        require(_getTaskState(_contractId, _contract, _taskId) == _state, \"WORKFLOW_INVALID_STATE\");\r\n        _;\r\n    }\r\n\r\n    constructor(Storage _storage, bytes32 _crate) public StorageAdapter(_storage, _crate) {\r\n        _initCore();\r\n    }\r\n\r\n    function () external payable {\r\n        revert(\"W_ETH\");\r\n    }\r\n\r\n    function version() public pure returns (string) {\r\n        return \"0.1.0\";\r\n    }\r\n\r\n    function initWorkflow(\r\n        address _owner,\r\n        address _storage,\r\n        bytes32 _crate\r\n    ) public {\r\n        _initOwned(_owner);\r\n        _initStorageAdapter(Storage(_storage), _crate);\r\n        _initCore();\r\n    }\r\n\r\n    function getTaskDetails(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    external\r\n    view\r\n    returns (uint[] _values)\r\n    {\r\n        _values = new uint[](TASK_DETAILS_LENGTH);\r\n\r\n        uint _upfrontAmount = _getUpfrontValue(_contractId, _contract, _taskId);\r\n        _values[TASK_DETAILS_BUDGET_IDX] = _getTotalValue(_contractId, _contract, _taskId).add(_upfrontAmount);\r\n        _values[TASK_DETAILS_PAID_AMOUNT_IDX] = _getPaidValue(_contractId, _contract, _taskId).add(_upfrontAmount);\r\n        _values[TASK_DETAILS_UPFRONT_AMOUNT_IDX] = _upfrontAmount;\r\n\r\n        (uint _percent, uint _percentPrecision) = LaborContract(_contract).getServiceSurchargePercent(_contractId);\r\n        if (_values[TASK_DETAILS_PAID_AMOUNT_IDX] > 0) {\r\n            _values[TASK_DETAILS_WITHDRAW_FEE_AMOUNT] = PercentCalculator.getPercent(\r\n                _values[TASK_DETAILS_PAID_AMOUNT_IDX],\r\n                _percent,\r\n                _percentPrecision\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Gets numbers of how much employer will pay for a task `_taskId` in contract `_contractId` at `_contract`\r\n    /// @return\r\n    /// @param _totalValue how much task costs\r\n    /// @param _paymentValue how much should be paid immediately\r\n    /// @param _depositValue how much should be additionally deposited\r\n    function getTaskCompletionReward(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint _totalValue,\r\n        uint _paymentValue,\r\n        uint _depositValue,\r\n        uint _paidValue\r\n    ) {\r\n        _totalValue = _calculateTotalValue(_contractId, _contract, _taskId, _skippedPenalties);\r\n        _paidValue = _getPaidValue(_contractId, _contract, _taskId);\r\n        (_paymentValue, _depositValue) = _calculatePaymentAndDepositValuesForTaskCompletion(\r\n            _contractId,\r\n            _contract,\r\n            _taskId,\r\n            _totalValue,\r\n            _paidValue\r\n        );\r\n    }\r\n\r\n    function getTaskCompletionRewardWithoutPenalties(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint _totalValue,\r\n        uint _paymentValue,\r\n        uint _depositValue,\r\n        uint _paidValue\r\n    ) {\r\n        _totalValue = _getTotalValue(_contractId, _contract, _taskId);\r\n        _paidValue = _getPaidValue(_contractId, _contract, _taskId);\r\n        (_paymentValue, _depositValue) = _calculatePaymentAndDepositValuesForTaskCompletion(\r\n            _contractId,\r\n            _contract,\r\n            _taskId,\r\n            _totalValue,\r\n            _paidValue\r\n        );\r\n    }\r\n\r\n    function _calculateTotalValue(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties\r\n    )\r\n    private\r\n    view\r\n    returns (uint _totalValue)\r\n    {\r\n        uint _assigneePenaltyValue = _getPenaltyValue(\r\n            _contractId,\r\n            _contract,\r\n            _taskId,\r\n            _skippedPenalties,\r\n            DataParser.PenaltyApplicationType.MISS_DEADLINE\r\n        );\r\n        // TODO: version 2: take into account LATE_PAYMENT skipped penalties\r\n\r\n        _totalValue = _getTotalValue(_contractId, _contract, _taskId);\r\n        _totalValue = _totalValue.sub(SafeMath.min(_assigneePenaltyValue, _totalValue));\r\n    }\r\n\r\n    function _calculatePaymentAndDepositValuesForTaskCompletion(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 /* _taskId */,\r\n        uint _totalValue,\r\n        uint _paidValue\r\n    )\r\n    private\r\n    view\r\n    returns (uint _paymentValue, uint _depositValue)\r\n    {\r\n        // TODO: add calculating deposit value: EP > AP then (EP.- AP) else 0\r\n        (bool _lockFullBudget, uint8 _paymentTimeline) = LaborContract(_contract).getPaymentRequirements(_contractId);\r\n\r\n        if (_paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_TASK)) {\r\n            _paymentValue = _totalValue.sub(_paidValue);\r\n\r\n            if (!_lockFullBudget) {\r\n                _depositValue = _paymentValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUnspentUpfrontAmount(bytes32 _contractId, address _contractHost) external view returns (uint) {\r\n        return store.get(tasksUnspentUpfrontStorage, _getContractRecordKey(_contractId, _contractHost));\r\n    }\r\n\r\n    function registerContract(\r\n        bytes32 _contractId,\r\n        address _contractHost\r\n    )\r\n    external\r\n    onlyContractProxy(_contractHost)\r\n    onlyAllowedContractHost(_contractHost)\r\n    returns (uint)\r\n    {\r\n        store.set(contractRegistrationsStorage, _getContractRecordKey(_contractId, _contractHost), true);\r\n        return OK;\r\n    }\r\n\r\n    function precalculateWorkflowData(\r\n        bytes32 _contractId,\r\n        address _contractHost,\r\n        bytes _data\r\n    )\r\n    external\r\n    view\r\n    onlyExistedContract(_contractId, _contractHost)\r\n    onlyContractProxy(_contractHost)\r\n    returns (\r\n        uint _budget,\r\n        uint _upfront\r\n    ) {\r\n        DataParser.TaskData[] memory _tasks = DataParser.parseTaskDataRawInput(_data);\r\n        require(_isUniqueTasks(_tasks), \"WORKFLOW_TASKS_NOT_UNIQUE\");\r\n\r\n        (_budget, _upfront) = _iterateOverTasks(_contractId, _contractHost, _tasks, _checkTask);\r\n    }\r\n\r\n    function addWorkflowData(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        bytes _data\r\n    )\r\n    external\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractProxy(_contract)\r\n    returns (\r\n        uint _totalBudget,\r\n        uint _upfrontBudget\r\n    ) {\r\n        DataParser.TaskData[] memory _tasks = DataParser.parseTaskDataRawInput(_data);\r\n        require(_isUniqueTasks(_tasks), \"WORKFLOW_TASKS_NOT_UNIQUE\");\r\n\r\n        (_totalBudget, _upfrontBudget) = _iterateOverTasks(_contractId, _contract, _tasks, _saveTaskToStorage);\r\n        _incrementUnspentUpfrontAmount(_contractId, _contract, _upfrontBudget);\r\n\r\n        _handleTasksPenalties(_contractId, _contract, _tasks, _data);\r\n    }\r\n\r\n    function _assertExistedTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        DataParser.TaskData memory _task\r\n    )\r\n    private\r\n    view\r\n    {\r\n        require(\r\n            !store.includes(taskIdsStorage, _getContractRecordKey(_contractId, _contract), _task.id),\r\n            \"WORKFLOW_TASK_ID_SHOULD_BE_UNIQUE\"\r\n        );\r\n    }\r\n\r\n    function _assetTaskState(\r\n        DataParser.TaskData memory _task\r\n    )\r\n    private\r\n    view\r\n    {\r\n        require(_task.id > 0, \"WORKFLOW_INVALID_TASK_ID\");\r\n        require(_task.deadline > block.timestamp, \"CONTRACT_TASK_DEADLINE_IS_OUTDATED\");\r\n    }\r\n\r\n    function _iterateOverTasks(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        DataParser.TaskData[] memory _tasks,\r\n        function (bytes32, address, DataParser.TaskData memory, uint) internal _applyFunc\r\n    )\r\n    private\r\n    returns (\r\n        uint _tasksBudget,\r\n        uint _upfrontBudget\r\n    ) {\r\n        for (uint _taskIndex = 0; _taskIndex < _tasks.length; ++_taskIndex) {\r\n            DataParser.TaskData memory _task = _tasks[_taskIndex];\r\n            _assetTaskState(_task);\r\n\r\n            uint _upfrontValue = 0;\r\n            if (_task.isUpfront) {\r\n                _upfrontValue = DataParser.getTaskUpfrontResultValue(_task, UPFRONT_PERCENT_PRECISION);\r\n            }\r\n\r\n            _tasksBudget = _tasksBudget.add(_task.budget);\r\n            _upfrontBudget = _upfrontBudget.add(_upfrontValue);\r\n\r\n            _applyFunc(_contractId, _contract, _task, _upfrontValue);\r\n        }\r\n\r\n        assert(_tasksBudget >= _upfrontBudget);\r\n    }\r\n\r\n    function _saveTaskToStorage(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        DataParser.TaskData memory _task,\r\n        uint _upfrontValue\r\n    )\r\n    internal\r\n    {\r\n        _checkTask(_contractId, _contract, _task, _upfrontValue);\r\n\r\n        bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _task.id);\r\n        store.set(taskUpfrontValueStorage, _taskRecordKey, _upfrontValue);\r\n        store.set(taskBudgetLeftValueStorage, _taskRecordKey, _task.budget.sub(_upfrontValue));\r\n        store.set(taskDeadlineStorage, _taskRecordKey, _task.deadline);\r\n\r\n        store.add(taskIdsStorage, _getContractRecordKey(_contractId, _contract), _task.id);\r\n    }\r\n\r\n    function _checkTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        DataParser.TaskData memory _task,\r\n        uint /* _upfrontValue */\r\n    )\r\n    internal\r\n    {\r\n        _assertExistedTask(_contractId, _contract, _task);\r\n    }\r\n\r\n\r\n    function _handleTasksPenalties(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        DataParser.TaskData[] memory _tasks,\r\n        bytes _data\r\n    )\r\n    private\r\n    {\r\n        DataParser.TaskPenaltyData[] memory _penalties = DataParser.parseTaskPenaltyDataRawInput(_data);\r\n\r\n        for (uint _penaltyIdx = 0; _penaltyIdx < _penalties.length; ++_penaltyIdx) {\r\n            DataParser.TaskPenaltyData memory _penalty = _penalties[_penaltyIdx];\r\n            DataParser.TaskData memory _task = Arrays.getTaskById(_tasks, _penalty.taskId);\r\n\r\n            require(_task.id > 0, \"WORKFLOW_LINKED_PENALTY_TASK_NOT_FOUND\");\r\n            DataParser.assertTaskPenalty(_penalty);\r\n            require(\r\n                store.includes(taskIdsStorage, _getContractRecordKey(_contractId, _contract), _task.id),\r\n                \"WORKFLOW_TASK_ID_SHOULD_EXIST\"\r\n            );\r\n            require(\r\n                !store.includes(penaltyIdsStorage, _getTaskRecordKey(_contractId, _contract, _penalty.taskId), _penalty.id),\r\n                \"WORKFLOW_TASK_PENALTY_ID_SHOULD_BE_UNIQUE\"\r\n            );\r\n\r\n            /**\r\n                1. Store penalty id in a list of penalties for the task\r\n             */\r\n            store.add(penaltyIdsStorage, _getTaskRecordKey(_contractId, _contract, _penalty.taskId), _penalty.id);\r\n\r\n\r\n            /**\r\n                2. Save penalty info\r\n             */\r\n            bytes32 _penaltyRecordKey = _getTaskPenaltyRecordKey(_contractId, _contract, _task.id, _penalty.id);\r\n            store.set(taskPenaltyApplicationTypeStorage, _penaltyRecordKey, _penalty.applicationType);\r\n            store.set(\r\n                taskPenaltyValueStorage,\r\n                _penaltyRecordKey,\r\n                DataParser.getTaskPenaltyResultValue(_penalty, _task.budget, TASK_PENALTY_PERCENT_PRECISION)\r\n            );\r\n\r\n            /**\r\n                2.1 Handle applicationType == PenaltyApplicationType.LATE_PAYMENT\r\n             */\r\n            if (\r\n                _penalty.applicationType == uint8(DataParser.PenaltyApplicationType.LATE_PAYMENT) &&\r\n                uint256(_penalty.reserved1) != 0\r\n            ) {\r\n                store.set(\r\n                    taskPenaltyPaymentWindowValueStorage,\r\n                    _penaltyRecordKey,\r\n                    uint256(_penalty.reserved1)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function startTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    external\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractAssignee(_contractId, _contract)\r\n    onlyTaskInState(_contractId, _contract, _taskId, TaskState.NOT_STARTED)\r\n    returns (uint)\r\n    {\r\n        return _doStartTask(_contractId, _contract, _taskId);\r\n    }\r\n\r\n    function _doStartTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    private\r\n    returns (uint)\r\n    {\r\n        bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n        store.set(taskStartedAtStorage, _taskRecordKey, block.timestamp);\r\n\r\n        _transitionTaskToState(_contractId, _contract, _taskId, TaskState.STARTED);\r\n\r\n        LaborContract(_contract).onOperation(_contractId, \"OP_TASK_START\");\r\n        return OK;\r\n    }\r\n\r\n    // function pauseTask(\r\n    //     bytes32 _contractId,\r\n    //     address _contract,\r\n    //     uint32 _taskId\r\n    // )\r\n    // external\r\n    // onlyExistedContract(_contractId, _contract)\r\n    // onlyContractAssignee(_contractId, _contract)\r\n    // onlyTaskInState(_contractId, _contract, _taskId, TaskState.STARTED)\r\n    // returns (uint)\r\n    // {\r\n    //     return _doPauseTask(_contractId, _contract, _taskId);\r\n    // }\r\n\r\n    // function _doPauseTask(\r\n    //     bytes32 _contractId,\r\n    //     address _contract,\r\n    //     uint32 _taskId\r\n    // )\r\n    // private\r\n    // returns (uint)\r\n    // {\r\n    //     bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n\r\n    //     _startTrackingPause(_taskRecordKey);\r\n    //     _transitionTaskToState(_contractId, _contract, _taskId, TaskState.PAUSED);\r\n\r\n    //     LaborContract(_contract).onOperation(_contractId, \"OP_TASK_PAUSE\");\r\n    //     return OK;\r\n    // }\r\n\r\n    // function resumeTask(\r\n    //     bytes32 _contractId,\r\n    //     address _contract,\r\n    //     uint32 _taskId\r\n    // )\r\n    // external\r\n    // onlyExistedContract(_contractId, _contract)\r\n    // onlyContractAssignee(_contractId, _contract)\r\n    // onlyTaskInState(_contractId, _contract, _taskId, TaskState.PAUSED)\r\n    // returns (uint)\r\n    // {\r\n    //     return _doResumeTask(_contractId, _contract, _taskId);\r\n    // }\r\n\r\n    // function _doResumeTask(\r\n    // bytes32 _contractId,\r\n    //     address _contract,\r\n    //     uint32 _taskId\r\n    // )\r\n    // private\r\n    // returns (uint)\r\n    // {\r\n    //     bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n\r\n    //     _updatePausedInterval(_taskRecordKey);\r\n    //     _transitionTaskToState(_contractId, _contract, _taskId, TaskState.STARTED);\r\n\r\n    //     LaborContract(_contract).onOperation(_contractId, \"OP_TASK_RESUME\");\r\n    //     return OK;\r\n    // }\r\n\r\n    function payPartialTaskExpenses(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    payable\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractEmployer(_contractId, _contract)\r\n    returns (uint)\r\n    {\r\n        require(_isTaskStarted(_contractId, _contract, _taskId), \"WORKFLOW_INVALID_STATE\");\r\n\r\n        _withdrawOnPartialTaskExpenses(_contractId, _contract, _taskId, _value, _expireAtBlock, _salt, _signature);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _withdrawOnPartialTaskExpenses(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    ) private {\r\n        uint _paidValue = _getPaidValue(_contractId, _contract, _taskId);\r\n        (, uint _depositValue) = getTaskSinglePaymentReward(_contractId, _contract, _value);\r\n\r\n        uint _totalValue = _getTotalValue(_contractId, _contract, _taskId);\r\n        require(_totalValue >= _paidValue.add(_value), \"WORKFLOW_INCORRECT_VALUE\");\r\n\r\n        LaborContract(_contract).onWithdrawOperation.value(msg.value)\r\n            (\r\n                _contractId,\r\n                \"OP_TASK_PAYMENT\",\r\n                _depositValue,\r\n                _value,\r\n                _expireAtBlock,\r\n                _salt,\r\n                _signature\r\n            );\r\n\r\n        store.set(taskBudgetPaidValueStorage, _getTaskRecordKey(_contractId, _contract, _taskId), _paidValue.add(_value));\r\n    }\r\n\r\n    function getTaskSinglePaymentReward(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _value\r\n    ) public view returns (uint _paymentValue, uint _depositValue) {\r\n        (bool _lockFullBudget, uint8 _paymentTimeline) = LaborContract(_contract).getPaymentRequirements(_contractId);\r\n        (_paymentValue, _depositValue) = _calculatePaymentAndDepositValuesForTaskPayment(\r\n            DataParser.PaymentTimeline(_paymentTimeline),\r\n            _lockFullBudget,\r\n            _value\r\n        );\r\n    }\r\n\r\n    function _calculatePaymentAndDepositValuesForTaskPayment(\r\n        DataParser.PaymentTimeline _paymentTimeline,\r\n        bool _lockFullBudget,\r\n        uint _value\r\n    )\r\n    private\r\n    pure\r\n    returns (\r\n        uint _paymentValue,\r\n        uint _depositValue\r\n    ) {\r\n        if (_paymentTimeline == DataParser.PaymentTimeline.PAY_BY_TASK) {\r\n            _paymentValue = _value;\r\n\r\n            if (!_lockFullBudget) {\r\n                _depositValue = _value;\r\n            }\r\n        }\r\n    }\r\n\r\n    function completeTaskAndPay(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    payable\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractEmployer(_contractId, _contract)\r\n    returns (uint)\r\n    {\r\n        require(_isTaskStarted(_contractId, _contract, _taskId), \"WORKFLOW_INVALID_STATE\");\r\n\r\n        _withdrawOnTaskCompletionConfirmationWithoutPenalties(\r\n            _contractId,\r\n            _contract,\r\n            _taskId,\r\n            _expireAtBlock,\r\n            _salt,\r\n            _signature\r\n        );\r\n        _setTaskFinishedTime(_contractId, _contract, _taskId);\r\n        _decrementUnspentUpfrontAmountForTask(_contractId, _contract, _taskId);\r\n        _transitionTaskToState(_contractId, _contract, _taskId, TaskState.COMPLETED);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function completeTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    external\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractAssignee(_contractId, _contract)\r\n    returns (uint)\r\n    {\r\n        require(_isTaskStarted(_contractId, _contract, _taskId), \"WORKFLOW_INVALID_STATE\");\r\n\r\n        return _doCompleteTask(_contractId, _contract, _taskId);\r\n    }\r\n\r\n    function _doCompleteTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    private\r\n    returns (uint)\r\n    {\r\n        bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n\r\n        /**\r\n            1. Update 'pausedAt' variable to prevent invalid time track\r\n         */\r\n        // _startTrackingPause(_taskRecordKey);\r\n        store.set(taskCompletedAtBlockStorage, _taskRecordKey, block.number);\r\n        _transitionTaskToState(_contractId, _contract, _taskId, TaskState.COMPLETION_REQUESTED);\r\n\r\n        LaborContract(_contract).onOperation(_contractId, \"OP_TASK_COMPLETION_REQUEST\");\r\n        return OK;\r\n    }\r\n\r\n    function confirmTaskCompletion(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    payable\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractEmployer(_contractId, _contract)\r\n    returns (uint)\r\n    {\r\n        return _confirmTaskCompletion(\r\n            _contractId,\r\n            _contract,\r\n            _taskId,\r\n            _skippedPenalties,\r\n            _expireAtBlock,\r\n            _salt,\r\n            _signature\r\n        );\r\n    }\r\n\r\n    function _confirmTaskCompletion(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    private\r\n    onlyTaskInState(_contractId, _contract, _taskId, TaskState.COMPLETION_REQUESTED)\r\n    returns (uint)\r\n    {\r\n        _withdrawOnTaskCompletionConfirmation(\r\n            _contractId,\r\n            _contract,\r\n            _taskId,\r\n            _skippedPenalties,\r\n            _expireAtBlock,\r\n            _salt,\r\n            _signature\r\n        );\r\n        _setTaskFinishedTime(_contractId, _contract, _taskId);\r\n        _decrementUnspentUpfrontAmountForTask(_contractId, _contract, _taskId);\r\n        _transitionTaskToState(_contractId, _contract, _taskId, TaskState.COMPLETED);\r\n\r\n        // TODO: could probably clean penalties if such exist, so it could save some gas\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _withdrawOnTaskCompletionConfirmation(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    private\r\n    {\r\n        (uint _totalValue,, uint _depositValue, uint _paidValue) = getTaskCompletionReward(_contractId, _contract, _taskId, _skippedPenalties);\r\n\r\n        LaborContract(_contract).onWithdrawOperation.value(msg.value)\r\n        (\r\n            _contractId,\r\n            \"OP_TASK_COMPLETION\",\r\n            _depositValue,\r\n            _totalValue.sub(_paidValue),\r\n            _expireAtBlock,\r\n            _salt,\r\n            _signature\r\n        );\r\n\r\n        store.set(taskBudgetPaidValueStorage, _getTaskRecordKey(_contractId, _contract, _taskId), _totalValue);\r\n\r\n    }\r\n\r\n    function _withdrawOnTaskCompletionConfirmationWithoutPenalties(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    private\r\n    {\r\n        (uint _totalValue,, uint _depositValue, uint _paidValue) = getTaskCompletionRewardWithoutPenalties(_contractId, _contract, _taskId);\r\n\r\n        LaborContract(_contract).onWithdrawOperation.value(msg.value)\r\n        (\r\n            _contractId,\r\n            \"OP_TASK_COMPLETION\",\r\n            _depositValue,\r\n            _totalValue.sub(_paidValue),\r\n            _expireAtBlock,\r\n            _salt,\r\n            _signature\r\n        );\r\n\r\n        store.set(taskBudgetPaidValueStorage, _getTaskRecordKey(_contractId, _contract, _taskId), _totalValue);\r\n    }\r\n\r\n\r\n    function declineTaskAndSendToRework(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        string /* _reason */\r\n    )\r\n    external\r\n    onlyExistedContract(_contractId, _contract)\r\n    onlyContractEmployer(_contractId, _contract)\r\n    onlyTaskInState(_contractId, _contract, _taskId, TaskState.COMPLETION_REQUESTED)\r\n    returns (uint)\r\n    {\r\n        return _doTaskRework(_contractId, _contract, _taskId);\r\n    }\r\n\r\n    function _doTaskRework(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    private\r\n    returns (uint)\r\n    {\r\n        // bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n\r\n        // _updatePausedInterval(_taskRecordKey);\r\n        _transitionTaskToState(_contractId, _contract, _taskId, TaskState.STARTED);\r\n\r\n        LaborContract(_contract).onOperation(_contractId, \"OP_TASK_REWORK\");\r\n        return OK;\r\n    }\r\n\r\n\r\n    /** PRIVATE */\r\n\r\n    function _isUniqueTasks(DataParser.TaskData[] memory _tasks) private pure returns (bool) {\r\n        uint32 _findId = 0;\r\n        for (uint _idx = 0; _idx < _tasks.length; _idx++) {\r\n            _findId = _tasks[_idx].id;\r\n            for (uint _searchIdx = _idx + 1; _searchIdx < _tasks.length; _searchIdx++) {\r\n                if (_tasks[_searchIdx].id == _findId) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _getPenaltyValue(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties,\r\n        DataParser.PenaltyApplicationType _takeOnlyApplicationType\r\n    )\r\n    private\r\n    view\r\n    returns (uint _penaltyValue)\r\n    {\r\n        bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n        uint _penaltiesLength = store.count(penaltyIdsStorage, _taskRecordKey);\r\n        for (uint _penaltyIdx = 0; _penaltyIdx < _penaltiesLength; ++_penaltyIdx) {\r\n            uint32 _penaltyId = uint32(store.get(penaltyIdsStorage, _taskRecordKey, _penaltyIdx));\r\n            bytes32 _penaltyRecordKey = _getTaskPenaltyRecordKey(_contractId, _contract, _taskId, _penaltyId);\r\n\r\n            if (\r\n                DataParser.PenaltyApplicationType(store.get(taskPenaltyApplicationTypeStorage, _penaltyRecordKey)) != _takeOnlyApplicationType ||\r\n                Arrays.contains(_skippedPenalties, _penaltyId)\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            _penaltyValue = _penaltyValue.add(_getPenaltyValueForRecord(_taskRecordKey, _penaltyRecordKey, _takeOnlyApplicationType));\r\n        }\r\n    }\r\n\r\n    function _getPenaltyValueForRecord(\r\n        bytes32 _taskRecordKey,\r\n        bytes32 _penaltyRecordKey,\r\n        DataParser.PenaltyApplicationType _takeOnlyApplicationType\r\n    )\r\n    private\r\n    view\r\n    returns (uint _result)\r\n    {\r\n        if (_takeOnlyApplicationType == DataParser.PenaltyApplicationType.MISS_DEADLINE &&\r\n            store.get(taskDeadlineStorage, _taskRecordKey) < block.timestamp\r\n        ) {\r\n            _result = _result.add(store.get(taskPenaltyValueStorage, _penaltyRecordKey));\r\n        }\r\n\r\n        if (_takeOnlyApplicationType == DataParser.PenaltyApplicationType.LATE_PAYMENT) {\r\n            uint _lastPaymentBlock = store.get(taskCompletedAtBlockStorage, _taskRecordKey).add(\r\n                store.get(taskPenaltyPaymentWindowValueStorage, _penaltyRecordKey)\r\n            );\r\n\r\n            if (_lastPaymentBlock < block.number) {\r\n                _result = _result.add(store.get(taskPenaltyValueStorage, _penaltyRecordKey));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getTaskState(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _taskId\r\n    )\r\n    private\r\n    view\r\n    returns (TaskState)\r\n    {\r\n        return TaskState(store.get(taskStateStorage, _getTaskRecordKey(_contractId, _contract, _taskId)));\r\n    }\r\n\r\n    function _incrementUnspentUpfrontAmount(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _upfrontValue\r\n    )\r\n    private\r\n    {\r\n        uint _unspentUpfrontAmount = store.get(tasksUnspentUpfrontStorage, _getContractRecordKey(_contractId, _contract));\r\n        _unspentUpfrontAmount = _unspentUpfrontAmount.add(_upfrontValue);\r\n        store.set(tasksUnspentUpfrontStorage, _getContractRecordKey(_contractId, _contract), _unspentUpfrontAmount);\r\n    }\r\n\r\n    function _decrementUnspentUpfrontAmountForTask(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    private\r\n    {\r\n        uint _unspentUpfrontAmount = store.get(tasksUnspentUpfrontStorage, _getContractRecordKey(_contractId, _contract));\r\n        uint _upfrontValue = _getUpfrontValue(_contractId, _contract, _taskId);\r\n        _unspentUpfrontAmount = _unspentUpfrontAmount.sub(_upfrontValue);\r\n        store.set(tasksUnspentUpfrontStorage, _getContractRecordKey(_contractId, _contract), _unspentUpfrontAmount);\r\n    }\r\n\r\n    function _updatePausedInterval(bytes32 _taskRecordKey) private {\r\n        uint pausedAt = store.get(taskPausedAtStorage, _taskRecordKey);\r\n\r\n        store.set(taskPausedForStorage, _taskRecordKey, block.timestamp - pausedAt);\r\n    }\r\n\r\n    function _setTaskFinishedTime(bytes32 _contractId, address _contract, uint32 _taskId) private {\r\n        store.set(taskFinishedStorage, _getTaskRecordKey(_contractId, _contract, _taskId), block.timestamp);\r\n    }\r\n\r\n    function _startTrackingPause(bytes32 _taskRecordKey) private {\r\n        store.set(taskPausedAtStorage, _taskRecordKey, block.timestamp);\r\n    }\r\n\r\n    function _transitionTaskToState(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _taskId,\r\n        TaskState _newState\r\n    )\r\n    private\r\n    {\r\n        bytes32 _taskRecordKey = _getTaskRecordKey(_contractId, _contract, _taskId);\r\n        uint8 _previousState = store.get(taskStateStorage, _taskRecordKey);\r\n        store.set(taskStateStorage, _taskRecordKey, uint8(_newState));\r\n\r\n        emit TaskStateChanged(_getContractRecordKey(_contractId, _contract), _contractId, _taskId, uint8(_newState), _previousState);\r\n    }\r\n\r\n    function _getTaskRecordKey(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _taskId\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_contractId, _contract, _taskId));\r\n    }\r\n\r\n    function _getContractRecordKey(\r\n        bytes32 _contractId,\r\n        address _contract\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_contractId, _contract));\r\n    }\r\n\r\n    function _getTaskPenaltyRecordKey(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _taskId,\r\n        uint _taskPenaltyId\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_getTaskRecordKey(_contractId, _contract, _taskId), _taskPenaltyId));\r\n    }\r\n\r\n     function _getTotalValue(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    ) private view returns (uint _totalValue) {\r\n        _totalValue = store.get(taskBudgetLeftValueStorage, _getTaskRecordKey(_contractId, _contract, _taskId));\r\n    }\r\n\r\n    function _getPaidValue(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    ) private view returns (uint _paidValue) {\r\n        _paidValue = store.get(taskBudgetPaidValueStorage, _getTaskRecordKey(_contractId, _contract, _taskId));\r\n    }\r\n\r\n    function _getUpfrontValue(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    ) private view returns (uint _upfrontValue) {\r\n        _upfrontValue = store.get(taskUpfrontValueStorage, _getTaskRecordKey(_contractId, _contract, _taskId));\r\n    }\r\n\r\n\r\n    function _includesState(TaskState _state, TaskState[] memory _statesArray) private pure returns (bool) {\r\n        for (uint _idx = 0; _idx < _statesArray.length; ++_idx) {\r\n            if (_state == _statesArray[_idx]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _isTaskStarted(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _taskId\r\n    )\r\n    private\r\n    view\r\n    returns (bool)\r\n    {\r\n        return _isStartedState(_getTaskState(_contractId, _contract, _taskId));\r\n    }\r\n\r\n    function _isStartedState(TaskState _state) private pure returns (bool) {\r\n        TaskState[] memory _statesArray = __makeTwoItemArray(TaskState.NOT_STARTED, TaskState.STARTED);\r\n        return _includesState(_state, _statesArray);\r\n    }\r\n\r\n    function __makeTwoItemArray(TaskState _state1, TaskState _state2) private pure returns (TaskState[] memory _states) {\r\n        _states = new TaskState[](2);\r\n        _states[0] = _state1;\r\n        _states[1] = _state2;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"}],\"name\":\"getTaskDetails\",\"outputs\":[{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"}],\"name\":\"startTask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addWorkflowData\",\"outputs\":[{\"name\":\"_totalBudget\",\"type\":\"uint256\"},{\"name\":\"_upfrontBudget\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"payPartialTaskExpenses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contractHost\",\"type\":\"address\"}],\"name\":\"registerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getTaskSinglePaymentReward\",\"outputs\":[{\"name\":\"_paymentValue\",\"type\":\"uint256\"},{\"name\":\"_depositValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractHost\",\"type\":\"address\"}],\"name\":\"addContractHost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"}],\"name\":\"getTaskCompletionRewardWithoutPenalties\",\"outputs\":[{\"name\":\"_totalValue\",\"type\":\"uint256\"},{\"name\":\"_paymentValue\",\"type\":\"uint256\"},{\"name\":\"_depositValue\",\"type\":\"uint256\"},{\"name\":\"_paidValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_crate\",\"type\":\"bytes32\"}],\"name\":\"initWorkflow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractHost\",\"type\":\"address\"}],\"name\":\"removeContractHost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"}],\"name\":\"completeTask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"string\"}],\"name\":\"declineTaskAndSendToRework\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"},{\"name\":\"_skippedPenalties\",\"type\":\"uint32[]\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"confirmTaskCompletion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contractHost\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"precalculateWorkflowData\",\"outputs\":[{\"name\":\"_budget\",\"type\":\"uint256\"},{\"name\":\"_upfront\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"},{\"name\":\"_skippedPenalties\",\"type\":\"uint32[]\"}],\"name\":\"getTaskCompletionReward\",\"outputs\":[{\"name\":\"_totalValue\",\"type\":\"uint256\"},{\"name\":\"_paymentValue\",\"type\":\"uint256\"},{\"name\":\"_depositValue\",\"type\":\"uint256\"},{\"name\":\"_paidValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contractHost\",\"type\":\"address\"}],\"name\":\"getUnspentUpfrontAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractHost\",\"type\":\"address\"}],\"name\":\"isAllowedContractHost\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_taskId\",\"type\":\"uint32\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"completeTaskAndPay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_crate\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contractKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"newState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"previousState\",\"type\":\"uint8\"}],\"name\":\"TaskStateChanged\",\"type\":\"event\"}]","ContractName":"Workflow","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000005f5f4c49425f4441544100000000000000000000000000000000000000000000","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://a759e753aa869a50895087d41bdff7ec8b25e72e19914337a4db40c0b09756c3"}]}