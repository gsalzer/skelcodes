{"status":"1","message":"OK","result":[{"SourceCode":"{\"AllowanceChecker.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./IAllowanceChecker.sol\\\";\\n\\n\\ncontract AllowanceChecker is Constants {\\n\\n    modifier requireAllowance(\\n        address _coinAddress,\\n        address _coinHolder,\\n        uint256 _expectedBalance\\n    ) {\\n        require(\\n            getCoinAllowance(\\n                _coinAddress,\\n                _coinHolder\\n            ) \\u003e= _expectedBalance,\\n            ERROR_BALANCE_IS_NOT_ALLOWED\\n        );\\n        _;\\n    }\\n\\n    function getCoinAllowance(\\n        address _coinAddress,\\n        address _coinHolder\\n    )\\n    internal\\n    view\\n    returns (uint256)\\n    {\\n        return IERC20(_coinAddress).allowance(\\n            _coinHolder,\\n            address(this)\\n        );\\n    }\\n}\\n\"},\"BlobCoin.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./LockupContract.sol\\\";\\nimport \\\"./IERC20Mintable.sol\\\";\\n\\n/*solium-disable-next-line*/\\ncontract BlobCoin is LockupContract, IERC20Mintable, ERC20Detailed(\\\"Blob Coin\\\", \\\"BLOB\\\", 18), ERC20Burnable {\\n\\n    event Burn(address indexed burner, uint256 amount);\\n\\n    constructor(address _management)\\n    public\\n    LockupContract(_management)\\n    {}\\n\\n    /**\\n    * @dev Function to mint coins\\n    * @param to The address that will receive the minted tokens.\\n    * @param value The amount of tokens to mint.\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function mint(address to, uint256 value)\\n    public\\n    requirePermission(CAN_MINT_COINS)\\n    returns (bool)\\n    {\\n        _mint(to, value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Internal function that burns an amount of the token of a given\\n    * account, deducting from the sender\\u0027s allowance for said account\\n    * or by address with permission CAN_BURN_COINS. Uses the\\n    * internal burn function.\\n    * Emits an Burn event (reflecting the burned amount).\\n    * Emits an Approval event (reflecting the reduced allowance).\\n    * @param account The account whose tokens will be burnt.\\n    * @param value The amount that will be burned.\\n    */\\n    function _burnFrom(address account, uint256 value) internal {\\n        emit Burn(msg.sender, value);\\n        if (\\n            false == hasPermission(msg.sender, CAN_BURN_COINS)\\n        ) {\\n            super._burnFrom(account, value);\\n        } else {\\n            _burn(account, value);\\n        }\\n    }\\n\\n    /**\\n    * @dev  Overridden Transfer token for a specified addresses\\n    * @param from The address to transfer from.\\n    * @param to The address to transfer to.\\n    * @param value The amount to be transferred.\\n    */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(\\n            isTransferAllowed(from, value, balanceOf(from)) == true,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        return super._transfer(from, to, value);\\n    }\\n}\\n\"},\"CoinExchangeRates.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IManagement.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./ICoinExchangeRates.sol\\\";\\n\\n\\n/*solium-disable-next-line*/\\ncontract CoinExchangeRates is ICoinExchangeRates, IManagement, Constants, Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 private blobCoinPrice_;\\n\\n    address[] private permittedCoinsAddresses_;\\n\\n    mapping(address =\\u003e uint256) public stableCoinsPrices;\\n    mapping(address =\\u003e uint256) public stableCoinsDecimals;\\n    mapping(address =\\u003e uint256) public priceUpdatedAt;\\n    mapping(address =\\u003e uint256) public stableCoinsToProportion;\\n\\n    mapping(address =\\u003e uint256) public permittedTokensToId;\\n\\n    modifier requirePermission(uint256 _permissionBit) {\\n        require(\\n            hasPermission(msg.sender, _permissionBit),\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    event PriceUpdated(uint256 newPrice);\\n\\n    constructor(uint256 _blobCoinPrice)\\n    public\\n    {\\n        blobCoinPrice_ = _blobCoinPrice;\\n        permittedCoinsAddresses_.push(address(0));\\n    }\\n\\n    // 5 00000\\n    function setBlobCoinPrice(uint256 _blobCoinPrice)\\n    public\\n    requirePermission(CAN_REGISTER_COINS)\\n    {\\n        blobCoinPrice_ = _blobCoinPrice;\\n        emit PriceUpdated(_blobCoinPrice);\\n    }\\n\\n    function setCoinsPricesInUSD(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _prices\\n    )\\n    public\\n    requirePermission(CAN_REGISTER_COINS)\\n    returns(bool)\\n    {\\n        require(\\n            _coinsAddresses.length == _prices.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n\\n        for (uint256 i = 0; i \\u003c _coinsAddresses.length; i++) {\\n            setCoinPrice(_coinsAddresses[i], _prices[i]);\\n        }\\n        return true;\\n    }\\n\\n    function setCoinsCoverageProportion(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _percentageProportion\\n    )\\n    public\\n    requirePermission(CAN_REGISTER_COINS)\\n    returns(bool)\\n    {\\n        require(\\n            _coinsAddresses.length == _percentageProportion.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        uint256 totalProportion;\\n        for (uint256 i = 0; i \\u003c _coinsAddresses.length; i++) {\\n            require(\\n                hasPermission(_coinsAddresses[i], PERMITTED_COINS),\\n                ERROR_ACCESS_DENIED\\n            );\\n            stableCoinsToProportion[\\n            _coinsAddresses[i]\\n            ] = _percentageProportion[i];\\n            totalProportion = totalProportion.add(_percentageProportion[i]);\\n        }\\n        require(totalProportion == PERCENTS_ABS_MAX, ERROR_WRONG_AMOUNT);\\n        return true;\\n    }\\n\\n    function calculateUSDByBlobs(uint256 _blobsAmount)\\n    public\\n    view\\n    returns(uint256)\\n    {\\n        uint256 coefficientWithoutFee = PERCENTS_ABS_MAX\\n        .sub(getFeePercentage());\\n\\n        return _blobsAmount\\n        .mul(blobCoinPrice())\\n        .mul(coefficientWithoutFee)\\n        .div(PERCENTS_ABS_MAX);\\n    }\\n\\n    function calculateUsdByCoin(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        uint256 coinDecimals = stableCoinsDecimals[_stableCoinAddress];\\n        uint256 coinsAmount = _coinsAmount;\\n        if (coinDecimals \\u003c 18) {\\n            coinsAmount = _coinsAmount.mul(1e18).div(10 ** coinDecimals);\\n        }\\n        return getCoinPrice(_stableCoinAddress).mul(coinsAmount);\\n    }\\n\\n    function calculateCoinsAmountByUSD(\\n        uint256 _usdAmount\\n    )\\n    public\\n    view\\n    returns (address[] memory, uint256[] memory)\\n    {\\n        uint256[] memory coinsAmount = new uint[](\\n            permittedCoinsAddresses_.length\\n        );\\n        for (uint256 i = 1; i \\u003c permittedCoinsAddresses_.length; i++) {\\n            coinsAmount[i] = _usdAmount\\n            .mul(10**stableCoinsDecimals[permittedCoinsAddresses_[i]])\\n            .mul(stableCoinsToProportion[permittedCoinsAddresses_[i]])\\n            .div(getCoinPrice(permittedCoinsAddresses_[i]))\\n            .div(PERCENTS_ABS_MAX);\\n        }\\n        return (permittedCoinsAddresses_, coinsAmount);\\n    }\\n\\n    function calculateBlobsAmount(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns (uint256)\\n    {\\n\\n        return calculateUsdByCoin(_stableCoinAddress, _coinsAmount)\\n        .div(blobCoinPrice());\\n    }\\n\\n    function coinPriceUpdatedAt(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256)\\n    {\\n        return priceUpdatedAt[_stableCoinAddress];\\n    }\\n\\n    function getCoinPrice(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256)\\n    {\\n        return stableCoinsPrices[_stableCoinAddress];\\n    }\\n\\n    function permittedCoinsAddresses()\\n    public\\n    view\\n    returns (address[] memory)\\n    {\\n        return permittedCoinsAddresses_;\\n    }\\n\\n    function blobCoinPrice()\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        return blobCoinPrice_;\\n    }\\n\\n    function setCoinPrice(address _stableCoinAddress, uint256 _price)\\n    internal\\n    {\\n        require(\\n            hasPermission(_stableCoinAddress, PERMITTED_COINS),\\n            ERROR_ACCESS_DENIED\\n        );\\n        stableCoinsPrices[_stableCoinAddress] = _price;\\n        priceUpdatedAt[_stableCoinAddress] = block.timestamp;\\n    }\\n\\n    function internalSetPermissionsForCoins(\\n        address _address,\\n        bool _value,\\n        uint256 _decimals\\n    )\\n    internal\\n    {\\n        stableCoinsDecimals[_address] = _decimals;\\n        if (true == _value) {\\n            require(permittedTokensToId[_address] == 0, ERROR_COIN_REGISTERED);\\n            permittedTokensToId[_address] = permittedCoinsAddresses_.length;\\n            permittedCoinsAddresses_.push(_address);\\n        }\\n        if (false == _value) {\\n            uint256 coinIndex = permittedTokensToId[_address];\\n            require(coinIndex != 0, ERROR_NO_CONTRACT);\\n            uint256 lastCoinIndex = permittedCoinsAddresses_.length.sub(1);\\n            permittedCoinsAddresses_[coinIndex] = permittedCoinsAddresses_[\\n            lastCoinIndex\\n            ];\\n            permittedTokensToId[permittedCoinsAddresses_[coinIndex]] = coinIndex;\\n            delete permittedCoinsAddresses_[lastCoinIndex];\\n            permittedTokensToId[_address] = 0;\\n            permittedCoinsAddresses_.length = permittedCoinsAddresses_.length.sub(1);\\n        }\\n    }\\n\\n    function hasPermission(\\n        address _subject,\\n        uint256 _permissionBit\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return permissions(_subject, _permissionBit);\\n    }\\n}\\n\"},\"Constants.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ncontract Constants {\\n\\n    // Permissions constants\\n    uint256 public constant CAN_EXCHANGE_COINS = 1;\\n    uint256 public constant CAN_REGISTER_COINS = 2;\\n    uint256 public constant CAN_MINT_COINS = 3;\\n    uint256 public constant CAN_BURN_COINS = 4;\\n    uint256 public constant CAN_LOCK_COINS = 5;\\n    uint256 public constant PERMITTED_COINS = 6;\\n\\n    // Contract Registry keys\\n\\n    //public block-chain\\n    uint256 public constant CONTRACT_TOKEN = 1;\\n    uint256 public constant CONTRACT_EXCHANGE = 2;\\n    uint256 public constant CONTRACT_WITHDRAW = 3;\\n    uint256 public constant COIN_HOLDER = 4;\\n\\n\\n\\n    uint256 public constant PERCENTS_ABS_MAX = 1e4;\\n    uint256 public constant USD_PRECISION = 1e5;\\n\\n    string public constant ERROR_ACCESS_DENIED = \\\"ERROR_ACCESS_DENIED\\\";\\n    string public constant ERROR_NO_CONTRACT = \\\"ERROR_NO_CONTRACT\\\";\\n    string public constant ERROR_NOT_AVAILABLE = \\\"ERROR_NOT_AVAILABLE\\\";\\n    string public constant ERROR_WRONG_AMOUNT = \\\"ERROR_WRONG_AMOUNT\\\";\\n    /*solium-disable-next-line*/\\n    string public constant ERROR_NOT_PERMITTED_COIN = \\\"ERROR_NOT_PERMITTED_COIN\\\";\\n    /*solium-disable-next-line*/\\n    string public constant ERROR_BALANCE_IS_NOT_ALLOWED = \\\"BALANCE_IS_NOT_ALLOWED\\\";\\n    string public constant ERROR_COIN_REGISTERED = \\\"ERROR_COIN_REGISTERED\\\";\\n\\n    // Campaign Sates\\n    enum RequestState{\\n        Pending,\\n        PaidPartially,\\n        FullyPaid,\\n        Rejected,\\n        Refunded,\\n        Undefined,\\n        Canceled\\n    }\\n}\\n\\n\"},\"Dissolve.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Managed.sol\\\";\\nimport \\\"./BlobCoin.sol\\\";\\nimport \\\"./AllowanceChecker.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\nimport \\\"./IDissolve.sol\\\";\\n\\ncontract Dissolve is IDissolve, Managed, AllowanceChecker {\\n\\n    struct Request {\\n        uint256 totalAmount; //100 blobs\\n        uint256 dissolvedAmount; //10 blobs\\n        address requesterAddress;\\n        RequestState dissolveRequestState;\\n    }\\n\\n    Request[] public allDissolvesRequests;\\n\\n    mapping(address =\\u003e uint256[]) public holderToDissolveRequestId;\\n    mapping(uint256  =\\u003e address) public dissolveRequestIdToHolder;\\n\\n    event DissolveRequestCreated(\\n        uint256 _dissolveId,\\n        uint256 coinsAmount,\\n        address requesterAddress\\n    );\\n\\n    event DissolveRequestRemoved(\\n        uint256 _dissolveId,\\n        uint256 coinsAmountUnlocked,\\n        address requesterAddress\\n    );\\n\\n    event CoinsDissolve(\\n        uint256 _dissolveId,\\n        uint256 requestedAmount,\\n        uint256 dissolvedAmount\\n    );\\n\\n    modifier requireDissolveIdExisting(uint256 _dissolveId) {\\n        require(\\n            _dissolveId \\u003c allDissolvesRequests.length,\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier requireHasEnoughBlobs(uint256 _amount) {\\n        BlobCoin blobCoin = BlobCoin(\\n            management.contractRegistry(CONTRACT_TOKEN)\\n        );\\n        uint256 requesterBalance = blobCoin.balanceOf(msg.sender);\\n        require(\\n            requesterBalance \\u003e= _amount \\u0026\\u0026\\n            blobCoin.allowedBalance(msg.sender, requesterBalance) \\u003e= _amount,\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    constructor(address _managementAddress)\\n    public\\n    Managed(_managementAddress)\\n    {}\\n\\n    function externalDissolve(\\n        uint256 _dissolveId,\\n        uint256 _maxAmount\\n    )\\n    external\\n    requirePermission(CAN_EXCHANGE_COINS)\\n    returns (bool)\\n    {\\n        internalDissolve(\\n            _dissolveId,\\n            _maxAmount\\n        );\\n        return true;\\n    }\\n\\n    function externalMultiDissolve(\\n        uint256[] calldata _dissolveIds,\\n        uint256 _maxAmount\\n    )\\n    external\\n    requirePermission(CAN_EXCHANGE_COINS)\\n    {\\n        for (uint256 i = 0; i \\u003c _dissolveIds.length; i++) {\\n            if (\\n                allDissolvesRequests[_dissolveIds[i]].dissolveRequestState != RequestState.PaidPartially \\u0026\\u0026\\n                allDissolvesRequests[_dissolveIds[i]].dissolveRequestState != RequestState.Pending\\n            ) {\\n                continue;\\n            }\\n            internalDissolve(\\n                _dissolveIds[i],\\n                _maxAmount\\n            );\\n        }\\n\\n    }\\n\\n    function removeDissolveRequest(\\n        uint256 _dissolveId\\n    )\\n    public\\n    requireContractExistsInRegistry(CONTRACT_TOKEN)\\n    returns (bool)\\n    {\\n        Request storage request = allDissolvesRequests[\\n        _dissolveId\\n        ];\\n        require(\\n            msg.sender == request.requesterAddress,\\n            ERROR_ACCESS_DENIED\\n        );\\n        require(\\n            request.dissolveRequestState == RequestState.PaidPartially ||\\n            request.dissolveRequestState == RequestState.Pending,\\n            ERROR_NOT_AVAILABLE\\n        );\\n        request.dissolveRequestState = RequestState.Refunded;\\n        uint256 amountToUnlock = request.totalAmount\\n        .sub(request.dissolvedAmount);\\n        request.totalAmount = request.dissolvedAmount;\\n        BlobCoin(management.contractRegistry(CONTRACT_TOKEN)).unlock(\\n            msg.sender,\\n            amountToUnlock\\n        );\\n        emit DissolveRequestRemoved(\\n            _dissolveId,\\n            amountToUnlock,\\n            msg.sender\\n        );\\n        return true;\\n    }\\n\\n    function createDissolveRequest(uint256 _value)\\n    public\\n    requireContractExistsInRegistry(CONTRACT_TOKEN)\\n    requireHasEnoughBlobs(_value)\\n    returns (bool)\\n    {\\n        holderToDissolveRequestId[msg.sender].push(\\n            allDissolvesRequests.length\\n        );\\n        dissolveRequestIdToHolder[\\n        allDissolvesRequests.length\\n        ] = msg.sender;\\n        emit DissolveRequestCreated(\\n            allDissolvesRequests.length,\\n            _value,\\n            msg.sender\\n        );\\n        allDissolvesRequests.push(\\n            Request(\\n                _value,\\n                0,\\n                msg.sender,\\n                RequestState.Pending\\n            )\\n        );\\n\\n        BlobCoin(management.contractRegistry(CONTRACT_TOKEN)).lock(\\n            msg.sender,\\n            _value\\n        );\\n        return true;\\n    }\\n\\n    function internalDissolve(\\n        uint256 _dissolveId,\\n        uint256 _maxAmount\\n    )\\n    internal\\n    requireDissolveIdExisting(_dissolveId)\\n    {\\n        Request storage request = allDissolvesRequests[\\n        _dissolveId\\n        ];\\n        require(\\n            request.dissolveRequestState == RequestState.PaidPartially ||\\n            request.dissolveRequestState == RequestState.Pending,\\n            ERROR_NOT_AVAILABLE\\n        );\\n        uint256 amountToWithdraw = request.totalAmount\\n        .sub(request.dissolvedAmount);\\n        if (_maxAmount \\u003c amountToWithdraw) {\\n            amountToWithdraw = _maxAmount;\\n        }\\n\\n        request.dissolvedAmount = request.dissolvedAmount\\n        .add(amountToWithdraw);\\n\\n        if (request.totalAmount \\u003e request.dissolvedAmount) {\\n            request.dissolveRequestState = RequestState.PaidPartially;\\n        } else {\\n            request.dissolveRequestState = RequestState.FullyPaid;\\n        }\\n        internalBurnCoins(\\n            request.requesterAddress,\\n            amountToWithdraw\\n        );\\n\\n        internalTransferCoinsBack(\\n            amountToWithdraw,\\n            request.requesterAddress\\n        );\\n\\n        emit CoinsDissolve(\\n            _dissolveId,\\n            request.totalAmount,\\n            amountToWithdraw\\n        );\\n    }\\n\\n    function internalBurnCoins(address _address, uint256 _amount) internal {\\n        ERC20Burnable(\\n            management.contractRegistry(CONTRACT_TOKEN)\\n        ).burnFrom(_address, _amount);\\n    }\\n\\n    function internalTransferCoinsBack(\\n        uint256 _blobsAmountToWithdraw,\\n        address _coinsReceiver\\n    )\\n    internal\\n    {\\n        BlobCoin blobCoin = BlobCoin(\\n            management.contractRegistry(CONTRACT_TOKEN)\\n        );\\n        address[] memory permittedCoinsAddresses;\\n        uint256[] memory coinsAmount;\\n        (\\n        permittedCoinsAddresses,\\n        coinsAmount\\n        ) = management.calculateCoinsAmountByUSD(\\n            management.calculateUSDByBlobs(_blobsAmountToWithdraw).div(10**uint256(blobCoin.decimals()))\\n        );\\n        for (uint256 i = 1; i \\u003c permittedCoinsAddresses.length; i++) {\\n            if (\\n                coinsAmount[i] == 0 ||\\n                permittedCoinsAddresses[i] == address(0)\\n            ) {\\n                continue;\\n            }\\n            require(\\n                getCoinAllowance(\\n                    permittedCoinsAddresses[i],\\n                    management.coinsHolder()\\n                ) \\u003e= coinsAmount[i],\\n                ERROR_BALANCE_IS_NOT_ALLOWED\\n            );\\n            IERC20(permittedCoinsAddresses[i]).transferFrom(\\n                management.coinsHolder(),\\n                _coinsReceiver,\\n                coinsAmount[i]\\n            );\\n        }\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn\\u0027t required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param owner The address to query the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param to The address to transfer to.\\n    * @param value The amount to be transferred.\\n    */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        require(spender != address(0));\\n\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Transfer token for a specified addresses\\n    * @param from The address to transfer from.\\n    * @param to The address to transfer to.\\n    * @param value The amount to be transferred.\\n    */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param value The amount that will be created.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender\\u0027s allowance for said account. Uses the\\n     * internal burn function.\\n     * Emits an Approval event (reflecting the reduced allowance).\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\\n        _burn(account, value);\\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\\n    }\\n}\\n\"},\"ERC20Burnable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @title Burnable Token\\n * @dev Token that can be irreversibly burned (destroyed).\\n */\\ncontract ERC20Burnable is ERC20 {\\n    /**\\n     * @dev Burns a specific amount of tokens.\\n     * @param value The amount of token to be burned.\\n     */\\n    function burn(uint256 value) public {\\n        _burn(msg.sender, value);\\n    }\\n\\n    /**\\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\\n     * @param from address The address which you want to send tokens from\\n     * @param value uint256 The amount of token to be burned\\n     */\\n    function burnFrom(address from, uint256 value) public {\\n        _burnFrom(from, value);\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @return the symbol of the token.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @return the number of decimals of the token.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IAllowanceChecker.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract IAllowanceChecker {\\n\\n    /**\\n    * @dev Function to get stable coin allowed amount for originater\\n    * @param _coinAddress address of stable coin\\n    * @param _coinHolderAddress address of coin holder\\n    * @return uint256 that indicates amount of allowed amount for originate address\\n    */\\n    function getCoinAllowance(\\n        address _coinAddress,\\n        address _coinHolderAddress\\n    )\\n    internal\\n    view\\n    returns (uint256);\\n\\n}\\n\"},\"ICoinExchangeRates.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract ICoinExchangeRates {\\n\\n    /**\\n    * @dev Function to set CoinsPrices In USD\\n    * @param _coinsAddresses The array of addresses of stablecoins.\\n    * @param _prices The array of prices for stablecoins.\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function setCoinsPricesInUSD(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _prices\\n    )\\n    public\\n    returns(bool);\\n\\n    /**\\n    * @dev Function to set backed up proportions for permitted coins\\n    * @param _coinsAddresses The array of addresses of stablecoins.\\n    * @param _percentageProportion percents proportions\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function setCoinsCoverageProportion(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _percentageProportion\\n    )\\n    public\\n    returns(bool);\\n\\n    /**\\n       * @dev sets or unset permissions to make some actions\\n       * @param _address address stablecoin which is allowed/disalwed\\n       * @param _decimals adecimals value of stablecoin\\n       * @param _value bool sets/unsets _permission\\n    */\\n    function setPermissionsForCoins(\\n        address _address,\\n        bool _value,\\n        uint256 _decimals\\n    )\\n    public;\\n\\n    /**\\n    * @dev Function to get USD amount from converting blobs\\n    * @param _blobsAmount the amount of blobs to be converted\\n    * @return A number of coins you can receive by converting blobs\\n    */\\n    function calculateUSDByBlobs(uint256 _blobsAmount)\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to get amount of each stable coin based on proportion and price\\n    * which user can receive by blobs dissolveing\\n    * @param _usdAmount the amount to get stable coins\\n    * @return two arrays: stable coins and appropriate balances\\n    */\\n    function calculateCoinsAmountByUSD(\\n        uint256 _usdAmount\\n    )\\n    public\\n    view\\n    returns (address[] memory, uint256[] memory);\\n\\n    /**\\n    * @dev Function to get amount of usd by converting stable coins\\n    * @param _stableCoinAddress stable coin address\\n    * @param _coinsAmount amount of coins to exchange\\n    * @return A usd amount you can receive by exchanging coin\\n    */\\n    function calculateUsdByCoin(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to get amount of blobs by converting stable coins\\n    * @param _stableCoinAddress stable coin address\\n    * @param _coinsAmount amount of coins to exchange\\n    * @return A usd amount you can receive by exchanging coin\\n    */\\n    function calculateBlobsAmount(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns (uint256);\\n\\n    /**\\n    * @dev Function to get timestamp of last price update\\n    * @param _stableCoinAddress stable coin address\\n    * @return A timestamp of last update\\n    */\\n    function coinPriceUpdatedAt(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to get price of stablecoin\\n    * @param _stableCoinAddress stable coin address\\n    * @return A price in usd\\n    */\\n    function getCoinPrice(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to return permitted coins List\\n    * @return An array of coins addresses\\n    */\\n    function permittedCoinsAddresses()\\n    public\\n    view\\n    returns (address[] memory);\\n\\n    /**\\n    * @dev Function to get price of blob coin\\n    * @return A price in usd\\n    */\\n    function blobCoinPrice()\\n    public\\n    view\\n    returns (uint256);\\n\\n    /**\\n    * @dev Function to set price in usd for exact stable coin\\n    * @param _stableCoinAddress stable coin address\\n    * @param _price coin price in usd\\n    */\\n    function setCoinPrice(address _stableCoinAddress, uint256 _price) internal;\\n\\n}\\n\"},\"IDissolve.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ncontract IDissolve {\\n\\n    /**\\n      * @dev Function to perform dissolve and burn Blobs\\n      * @param _dissolveId The id of Dissolve request\\n      * @param _maxAmount of blob coins can be covered by stable coins\\n      * @return A boolean that indicates if the operation was successful.\\n   */\\n    function externalDissolve(\\n        uint256 _dissolveId,\\n        uint256 _maxAmount\\n    )\\n    external\\n    returns (bool);\\n\\n    /**\\n    * @dev Function to get stable coins and burn blobcoins\\n    * @param _value The amount of blobcoins to return .\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function createDissolveRequest(uint256 _value)\\n    public\\n    returns (bool);\\n\\n    /**\\n      * @dev Function to perform dissolve and burn Blobs\\n      * @param _dissolveId The id of Dissolve request\\n      * @param _maxAmount of blob coins can be covered by stable coins\\n    */\\n    function internalDissolve(\\n        uint256 _dissolveId,\\n        uint256 _maxAmount\\n    )\\n    internal;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n/**\\n * @title ERC20Mintable\\n * @dev ERC20 minting logic\\n */\\ncontract IERC20Mintable{\\n    /**\\n     * @dev Function to mint coins\\n     * @param to The address that will receive the minted tokens.\\n     * @param value The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address to, uint256 value)\\n    public\\n    returns (bool);\\n}\\n\"},\"ILockupContract.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ncontract ILockupContract {\\n\\n    /**\\n    * @dev Function to lock blob amount\\n    * @param _address the coin holder address\\n    * @param _amount the coins amount to be locked\\n    */\\n    function lock(\\n        address _address,\\n        uint256 _amount\\n    )\\n    public;\\n\\n    /**\\n    * @dev Function to unlock blob amount\\n    * @param _address the coin holder address\\n    * @param _amount the coins amount to be unlocked\\n    */\\n    function unlock(\\n        address _address,\\n        uint256 _amount\\n    )\\n    public;\\n\\n    /**\\n    * @dev Function to check if the specified balance is allowed to transfer\\n    * @param _address the coin holder address\\n    * @param _value the coins amount to be checked\\n    * @param _holderBalance total holder balance\\n    * @return bool true in case there is enough unlocked coins\\n    */\\n    function isTransferAllowed(\\n        address _address,\\n        uint256 _value,\\n        uint256 _holderBalance\\n    )\\n    public\\n    view\\n    returns(bool);\\n\\n    /**\\n    * @dev Function to get unlocked amount\\n    * @param _address the coin holder address\\n    * @param _holderBalance total holder balance\\n    * @return number of unlocked coins\\n    */\\n    function allowedBalance(\\n        address _address,\\n        uint256 _holderBalance\\n    )\\n    public\\n    view\\n    returns(uint256);\\n}\\n\"},\"IManaged.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract IManaged {\\n\\n    /**\\n       * @dev updates managed contract address\\n       * @param _management address contract address\\n   */\\n    function setManagementContract(address _management) public;\\n\\n    /**\\n       * @dev checks if address is permitted to  make an action\\n       * @param _subject address requested address\\n       * @param _permissionBit uint256 action constant value\\n       * @return true in case when address has a permision\\n   */\\n    function hasPermission(\\n        address _subject,\\n        uint256 _permissionBit\\n    )\\n    internal\\n    view\\n    returns (bool);\\n\\n}\\n\"},\"IManagement.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ncontract IManagement {\\n\\n    /**\\n        * @dev sets or unset permissions to make some actions\\n        * @param _address address Address which  is allowed/disallowed to run function\\n        * @param _permission uint256 constant value describes one of the permission\\n        * @param _value bool sets/unsets _permission\\n    */\\n    function setPermission(\\n        address _address,\\n        uint256 _permission,\\n        bool _value\\n    )\\n    public;\\n\\n    /**\\n      * @dev register contract with ID\\n      * @param _key uint256 constant value, indicates the contract\\n      * @param _target address Address of the contract\\n    */\\n    function registerContract(uint256 _key, address _target) public;\\n\\n    /**\\n     * @dev updates the percentage fee amount for dissolve request\\n     * @param _valueInPercentage uint256 fee amount which  should receive Platform per each dissolve\\n    */\\n    function setFeePercentage(\\n        uint256 _valueInPercentage\\n    )\\n    public;\\n\\n    /**\\n      * @dev gets the fee percentage value for dissolve\\n      * @return uint256 the fee percentage value for dissolve\\n    */\\n    function getFeePercentage()\\n    public\\n    view\\n    returns (uint256);\\n\\n    /**\\n      * @dev checks if permissions is specified for exact address\\n      * @return bool identifier of permissions\\n    */\\n    function permissions(address _subject, uint256 _permissionBit)\\n    public\\n    view\\n    returns (bool);\\n}\\n\"},\"IOriginate.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract IOriginate {\\n\\n\\n    /**\\n       * @dev Function to perform originate and mint Blobs for requester\\n       * @param _originateId The id of Originate request\\n       * @param _stableCoinAddresses coins addresses list to exchange\\n       * @param _maxCoinsAmount max amounts for each coin allowed to exchange\\n       * @return A boolean that indicates if the operation was successful.\\n    */\\n    function externalOriginate(\\n        uint256 _originateId,\\n        address[] calldata _stableCoinAddresses,\\n        uint256[] calldata _maxCoinsAmount\\n    )\\n    external\\n    returns (bool);\\n\\n    /**\\n    * @dev Function to receive stable coin and mint blobcoins\\n    * @param _stableCoinAddresses The addresses of the coins that will be exchanged to originate blobs.\\n    * @param _values The amounts of stable coins to contribute .\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function createOriginateRequest(\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _values\\n    )\\n    public\\n    returns (bool);\\n\\n    /**\\n   * @dev Function to get total and exchanged stable coin amounts per originate request\\n   * @param _originateId The id of Originate request\\n   * @param _stableCoin stable coin address to be checked\\n   * @return uint256[2] array where [0] element indicates total stablecoins to be exchanged\\n    [1] index shows the amount of already exchanged stable coin\\n   */\\n    function getStableCoinAmountsByRequestId(\\n        uint256 _originateId,\\n        address _stableCoin\\n    )\\n    public\\n    view\\n    returns (uint256[2] memory);\\n\\n    /**\\n      * @dev Function to perform originate and mint Blobs for requester\\n       * @param _originateId The id of Originate request\\n       * @param _stableCoinAddresses coins addresses list to exchange\\n       * @param _maxCoinsAmount max amounts for each coin allowed to exchange\\n    */\\n    function internalOriginate(\\n        uint256 _originateId,\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _maxCoinsAmount\\n    )\\n    internal;\\n\\n    /**\\n    * @dev Function to validate stablecoin registry and balance allowance\\n    * @param _stableCoinAddress stable coin address to be checked\\n    * @param _value stable coin amount needs to be allowed\\n    */\\n    function internalValidateCoin(\\n        address _stableCoinAddress,\\n        uint256 _value\\n    )\\n    internal;\\n}\\n\"},\"LockupContract.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ILockupContract.sol\\\";\\nimport \\\"./Managed.sol\\\";\\n\\ncontract LockupContract is ILockupContract, Managed  {\\n\\n    mapping (address =\\u003e uint256) public lockedAmount;\\n    event Lock(address holderAddress, uint256 amount);\\n    event UnLock(address holderAddress, uint256 amount);\\n\\n    constructor(address _management)\\n    public\\n    Managed(_management)\\n    {}\\n\\n    function lock(\\n        address _address,\\n        uint256 _amount\\n    )\\n    public\\n    requirePermission(CAN_LOCK_COINS)\\n    {\\n        lockedAmount[_address] = lockedAmount[_address].add(_amount);\\n        emit Lock(_address, _amount);\\n    }\\n\\n    function unlock(\\n        address _address,\\n        uint256 _amount\\n    )\\n    public\\n    requirePermission(CAN_LOCK_COINS)\\n    {\\n        require(\\n            lockedAmount[_address] \\u003e= _amount,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        lockedAmount[_address] = lockedAmount[_address].sub(_amount);\\n        emit UnLock(_address, _amount);\\n    }\\n\\n    function isTransferAllowed(\\n        address _address,\\n        uint256 _value,\\n        uint256 _holderBalance\\n    )\\n    public\\n    view\\n    returns (bool)\\n    {\\n        if (\\n            lockedAmount[_address] == 0 ||\\n        _holderBalance.sub(lockedAmount[_address]) \\u003e= _value\\n        ) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function allowedBalance(\\n        address _address,\\n        uint256 _holderBalance\\n    )\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        if (lockedAmount[_address] == 0) {\\n            return _holderBalance;\\n        }\\n        return _holderBalance.sub(lockedAmount[_address]);\\n    }\\n}\\n\"},\"Managed.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IManaged.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./Management.sol\\\";\\n\\ncontract Managed is IManaged, Constants, Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    Management public management;\\n\\n    modifier requirePermission(uint256 _permissionBit) {\\n        require(\\n            hasPermission(msg.sender, _permissionBit),\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier canCallOnlyRegisteredContract(uint256 _key) {\\n        require(\\n            msg.sender == management.contractRegistry(_key),\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier requireContractExistsInRegistry(uint256 _key) {\\n        require(\\n            management.contractRegistry(_key) != address(0),\\n            ERROR_NO_CONTRACT\\n        );\\n        _;\\n    }\\n\\n    constructor(address _managementAddress) public {\\n        management = Management(_managementAddress);\\n    }\\n\\n    function setManagementContract(address _management) public onlyOwner {\\n        require(address(0) != _management, ERROR_ACCESS_DENIED);\\n\\n        management = Management(_management);\\n    }\\n\\n    function hasPermission(\\n        address _subject,\\n        uint256 _permissionBit\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return management.permissions(_subject, _permissionBit);\\n    }\\n\\n}\\n\"},\"Management.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IManagement.sol\\\";\\nimport \\\"./CoinExchangeRates.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\ncontract Management is CoinExchangeRates{\\n\\n    uint256 private feeValueInPercentage_;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) private permissions_;\\n\\n    mapping(uint256 =\\u003e address) public contractRegistry;\\n\\n    event PermissionsSet(address subject, uint256 permission, bool value);\\n    event ContractRegistered(uint256 key, address target);\\n    event FeeUpdated(uint256 valueInPercentage);\\n\\n    constructor(uint256 _blobCoinPrice, uint256 _feeInPercentage)\\n    public\\n    CoinExchangeRates(_blobCoinPrice)\\n    {\\n        feeValueInPercentage_ = _feeInPercentage;\\n        permissions_[msg.sender][CAN_EXCHANGE_COINS] = true;\\n        permissions_[msg.sender][CAN_REGISTER_COINS] = true;\\n        permissions_[msg.sender][CAN_MINT_COINS] = true;\\n        permissions_[msg.sender][CAN_BURN_COINS] = true;\\n        permissions_[msg.sender][CAN_LOCK_COINS] = true;\\n    }\\n\\n    function setPermission(\\n        address _address,\\n        uint256 _permission,\\n        bool _value\\n    )\\n    public\\n    onlyOwner\\n    {\\n        require(\\n            PERMITTED_COINS != _permission,\\n            ERROR_ACCESS_DENIED\\n        );\\n        permissions_[_address][_permission] = _value;\\n        emit PermissionsSet(_address, _permission, _value);\\n    }\\n\\n    function setPermissionsForCoins(\\n        address _address,\\n        bool _value,\\n        uint256 _decimals\\n    )\\n    public\\n    onlyOwner\\n    {\\n        permissions_[_address][PERMITTED_COINS] = _value;\\n        internalSetPermissionsForCoins(_address, _value, _decimals);\\n        emit PermissionsSet(_address, PERMITTED_COINS, _value);\\n    }\\n\\n    function registerContract(uint256 _key, address _target) public onlyOwner {\\n        contractRegistry[_key] = _target;\\n        emit ContractRegistered(_key, _target);\\n    }\\n\\n    function setFeePercentage(\\n        uint256 _valueInPercentage\\n    )\\n    public\\n    onlyOwner\\n    {\\n        require(_valueInPercentage \\u003c= PERCENTS_ABS_MAX, ERROR_WRONG_AMOUNT);\\n        feeValueInPercentage_ = _valueInPercentage;\\n        emit FeeUpdated(_valueInPercentage);\\n    }\\n\\n    function getFeePercentage()\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        return feeValueInPercentage_;\\n    }\\n\\n    function coinsHolder()\\n    public\\n    view\\n    returns (address)\\n    {\\n        if (contractRegistry[COIN_HOLDER] != address(0)) {\\n            return contractRegistry[COIN_HOLDER];\\n        }\\n        return owner();\\n    }\\n\\n    function permissions(address _subject, uint256 _permissionBit)\\n    public\\n    view\\n    returns (bool)\\n    {\\n        return permissions_[_subject][_permissionBit];\\n    }\\n}\\n\"},\"Originate.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Managed.sol\\\";\\nimport \\\"./AllowanceChecker.sol\\\";\\nimport \\\"./IERC20Mintable.sol\\\";\\nimport \\\"./IOriginate.sol\\\";\\n\\n/*solium-disable-next-line*/\\ncontract Originate is Managed, IOriginate, AllowanceChecker {\\n\\n    struct Request {\\n        address requesterAddress;\\n        mapping(address =\\u003e uint256[2]) stableCoinAddressToAmount;\\n        address[] stableCoins;\\n        RequestState originateRequestState;\\n    }\\n\\n    Request[] public allOriginatesRequests;\\n\\n    event OriginateRequestCreated(\\n        uint256 _originateId,\\n        address requesterAddress,\\n        address[] stableCoins,\\n        uint256[] coinsAmount\\n    );\\n\\n    event CoinsOriginated(\\n        uint256 _originateId,\\n        address[] stableCoins,\\n        uint256[] exchangedCoinsAmount\\n    );\\n\\n    event OriginateRequestCanceled(\\n        uint256 _originateId,\\n        address requesterAddress\\n    );\\n\\n    modifier requireOriginateIdExisting(uint256 _originateId) {\\n        require(\\n            _originateId \\u003c allOriginatesRequests.length,\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier onlyPermittedCoin(address _stableCoinAddress) {\\n        require(\\n            true == hasPermission(\\n            _stableCoinAddress,\\n            PERMITTED_COINS\\n        ),\\n            ERROR_NOT_PERMITTED_COIN\\n        );\\n        _;\\n    }\\n\\n    constructor(address _managementAddress)\\n    public\\n    Managed(_managementAddress)\\n    {}\\n\\n    function externalOriginate(\\n        uint256 _originateId,\\n        address[] calldata _stableCoinAddresses,\\n        uint256[] calldata _maxCoinsAmount\\n    )\\n    external\\n    requirePermission(CAN_EXCHANGE_COINS)\\n    returns (bool)\\n    {\\n        internalOriginate(\\n            _originateId,\\n            _stableCoinAddresses,\\n            _maxCoinsAmount\\n        );\\n        return true;\\n    }\\n\\n    function externalMultiOriginate(\\n        uint256[] calldata _originateIds,\\n        address[] calldata _stableCoinAddresses,\\n        uint256[] calldata _maxCoinsAmount\\n    )\\n    external\\n    requirePermission(CAN_EXCHANGE_COINS)\\n    {\\n        for (uint256 i = 0; i \\u003c _originateIds.length; i++) {\\n            if (\\n                allOriginatesRequests[_originateIds[i]].originateRequestState != RequestState.PaidPartially \\u0026\\u0026\\n                allOriginatesRequests[_originateIds[i]].originateRequestState != RequestState.Pending\\n            ) {\\n                continue;\\n            }\\n            internalOriginate(\\n                _originateIds[i],\\n                _stableCoinAddresses,\\n                _maxCoinsAmount\\n            );\\n        }\\n    }\\n\\n    function createOriginateRequest(\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _values\\n    )\\n    public\\n    requireContractExistsInRegistry(CONTRACT_TOKEN)\\n    returns (bool)\\n    {\\n        require(\\n            _stableCoinAddresses.length == _values.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        allOriginatesRequests.push(\\n            Request(\\n                {\\n                requesterAddress : msg.sender,\\n                originateRequestState : RequestState.Pending,\\n                stableCoins : _stableCoinAddresses\\n                }\\n            )\\n        );\\n        Request storage request = allOriginatesRequests[\\n        allOriginatesRequests.length.sub(1)\\n        ];\\n        for (uint256 i = 0; i \\u003c _stableCoinAddresses.length; i++) {\\n            internalValidateCoin(_stableCoinAddresses[i], _values[i]);\\n            request.stableCoinAddressToAmount[\\n            _stableCoinAddresses[i]\\n            ] = [\\n            _values[i],\\n            0\\n            ];\\n        }\\n        emit OriginateRequestCreated(\\n            allOriginatesRequests.length.sub(1),\\n            msg.sender,\\n            _stableCoinAddresses,\\n            _values\\n        );\\n        for (uint256 i = 0; i \\u003c _stableCoinAddresses.length; i++) {\\n            IERC20(_stableCoinAddresses[i]).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _values[i]\\n            );\\n        }\\n        return true;\\n    }\\n\\n    function cancelOriginateRequest(\\n        uint256 _originateRequestId\\n    )\\n    public\\n    requireOriginateIdExisting(_originateRequestId)\\n    returns (bool)\\n    {\\n        Request storage request = allOriginatesRequests[_originateRequestId];\\n        require(request.requesterAddress == msg.sender, ERROR_ACCESS_DENIED);\\n        require(\\n            request.originateRequestState == RequestState.Pending,\\n            ERROR_ACCESS_DENIED\\n        );\\n        request.originateRequestState = RequestState.Canceled;\\n\\n        emit OriginateRequestCanceled(\\n            _originateRequestId,\\n            msg.sender\\n        );\\n        for (uint256 i = 0; i \\u003c request.stableCoins.length; i++) {\\n            IERC20(request.stableCoins[i]).transfer(\\n                msg.sender,\\n                request.stableCoinAddressToAmount[request.stableCoins[i]][0]\\n            );\\n        }\\n        return true;\\n    }\\n\\n    function getStableCoinAmountsByRequestId(\\n        uint256 _originateId,\\n        address _stableCoin\\n    )\\n    public\\n    view\\n    returns (uint256[2] memory)\\n    {\\n        Request storage request = allOriginatesRequests[_originateId];\\n        return request.stableCoinAddressToAmount[_stableCoin];\\n    }\\n\\n    function getStableCoinsAddressesByRequestId(\\n        uint256 _originateId\\n    )\\n    public\\n    view\\n    returns (address[] memory)\\n    {\\n        Request storage request = allOriginatesRequests[_originateId];\\n        return request.stableCoins;\\n    }\\n\\n    function internalOriginate(\\n        uint256 _originateId,\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _maxCoinsAmount\\n    )\\n    internal\\n    requireOriginateIdExisting(_originateId)\\n    {\\n        require(\\n            _maxCoinsAmount.length == _stableCoinAddresses.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        Request storage request = allOriginatesRequests[_originateId];\\n        bool originated;\\n        uint256 usdAmount;\\n\\n        for (uint256 i = 0; i \\u003c _stableCoinAddresses.length; i++) {\\n            requirePermittedCoin(_stableCoinAddresses[i]);\\n\\n            uint256[2] memory coinAmounts = request.stableCoinAddressToAmount[\\n            _stableCoinAddresses[i]\\n            ];\\n            uint256 amountToExchange = coinAmounts[0].sub(coinAmounts[1]);\\n            if (_maxCoinsAmount[i] \\u003c amountToExchange) {\\n                amountToExchange = _maxCoinsAmount[i];\\n            }\\n            coinAmounts[1] = coinAmounts[1].add(amountToExchange);\\n            if (\\n                coinAmounts[0] \\u003e coinAmounts[1] ||\\n                (i \\u003e 0 \\u0026\\u0026 false == originated)\\n            ) {\\n                originated = false;\\n            } else {\\n                originated = true;\\n            }\\n\\n            usdAmount = usdAmount.add(\\n                management.calculateUsdByCoin(\\n                    _stableCoinAddresses[i],\\n                    amountToExchange\\n                )\\n            );\\n            IERC20(_stableCoinAddresses[i]).transfer(\\n                management.coinsHolder(),\\n                amountToExchange\\n            );\\n        }\\n        internalMintBlobsByUSD(\\n            request.requesterAddress,\\n            usdAmount\\n        );\\n        if (false == originated) {\\n            request.originateRequestState = RequestState.PaidPartially;\\n        } else {\\n            request.originateRequestState = RequestState.FullyPaid;\\n        }\\n\\n        emit CoinsOriginated(\\n            _originateId,\\n            _stableCoinAddresses,\\n            _maxCoinsAmount\\n        );\\n    }\\n\\n    function internalMintBlobsByUSD(\\n        address _holderAddress,\\n        uint256 _usdAmount\\n    )\\n    internal\\n    {\\n        IERC20Mintable(\\n            management.contractRegistry(CONTRACT_TOKEN)\\n        ).mint(\\n            _holderAddress,\\n            (_usdAmount).div(management.blobCoinPrice())\\n        );\\n    }\\n\\n    function requirePermittedCoin(address _stableCoinAddress)\\n    internal\\n    onlyPermittedCoin(_stableCoinAddress)\\n    {\\n\\n    }\\n\\n    function internalValidateCoin(address _stableCoinAddress, uint256 _value)\\n    internal\\n    requireAllowance(\\n        _stableCoinAddress,\\n        msg.sender,\\n        _value\\n    )\\n    onlyPermittedCoin(_stableCoinAddress)\\n    {}\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WITHDRAW\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMITTED_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"name\":\"setManagementContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_BURN_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_LOCK_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_REGISTER_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USD_PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_BALANCE_IS_NOT_ALLOWED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_MINT_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_NOT_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_holderBalance\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COIN_HOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_EXCHANGE_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_COIN_REGISTERED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_WRONG_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTS_ABS_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_NOT_PERMITTED_COIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_NO_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_holderBalance\",\"type\":\"uint256\"}],\"name\":\"allowedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_ACCESS_DENIED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BlobCoin","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000cfbe8899fd873cb19539b58211a9120dc0306897","Library":"","SwarmSource":"bzzr://ab44cc7d741df0fc9a5b2c3c31361691e44e93c75681edbd0046922bff76bbc2"}]}