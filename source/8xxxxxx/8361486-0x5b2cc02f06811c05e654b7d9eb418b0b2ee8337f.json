{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IERC1620.sol\r\n\r\n/// @title ERC-1620 Money Streaming Standard\r\n/// @author Paul Berg - <paul@sablier.app>\r\n/// @dev See https://github.com/ethereum/eips/issues/1620\r\n\r\ninterface IERC1620 {\r\n    /// @dev This emits when streams are successfully created.\r\n    event Create(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 deposit,\r\n        address tokenAddress,\r\n        uint256 startTime,\r\n        uint256 stopTime\r\n    );\r\n\r\n    /// @dev This emits when the receiver of a stream withdraws a portion or all their available\r\n    ///  funds from an ongoing stream, without stopping it. Note that we don't emit both the\r\n    //   sender and the recipient's balance because only the recipient can withdraw.\r\n    event Withdraw(uint256 indexed streamId, address indexed recipient, uint256 amount);\r\n\r\n    /// @dev This emits when a stream is successfully redeemed and\r\n    ///  all involved parties get their share of the available funds.\r\n    event Cancel(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 senderAmount,\r\n        uint256 recipientAmount\r\n    );\r\n\r\n    /// @notice Creates a new stream between `sender` and `recipient`.\r\n    /// @dev Throws unless the contract is allowed to transfer more than `deposit` tokens.\r\n    ///  Throws if `startTime` is lower or equal to `block.timestamp`.\r\n    ///  Throws if `stopTime` is lower than `startTime`.\r\n    /// @param recipient The stream recipient or the payee.\r\n    /// @param deposit How much money it's streamed from sender to recipient.\r\n    /// @param tokenAddress The token contract.\r\n    /// @param startTime The start time of the stream.\r\n    /// @param stopTime The stop time of the stream.\r\n    function create(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)\r\n        external\r\n        returns (uint256 streamId);\r\n\r\n    /// @notice Withdraws all or a portion of the available funds.\r\n    /// @dev If the stream ended and the recipient withdraws the deposit in full, the stream object\r\n    ///  is deleted after this operation to save gas for the user and optimise contract storage.\r\n    ///  Throws if `streamId` doesn't point to a valid stream.\r\n    ///  Throws if `msg.sender` is not the recipient of the given `streamId`\r\n    /// @param streamId The stream to withdraw from\r\n    /// @param funds The amount of money to withdraw\r\n    function withdraw(uint256 streamId, uint256 funds) external;\r\n\r\n    /// @notice Distributes the funds to the sender and the recipient.\r\n    /// @dev The stream object gets deleted after this operation to save gas\r\n    ///  for the user and optimise contract storage.\r\n    ///  Throws if `streamId` points to an invalid stream.\r\n    ///  Throws if `msg.sender` is not either the sender or the recipient.\r\n    ///  of the given `streamId`.\r\n    /// @param streamId The stream to stop.\r\n    function cancel(uint256 streamId) external;\r\n\r\n    /// @notice Returns available funds for the given stream id and address\r\n    /// @dev Streams assigned to the zero address are considered invalid, and\r\n    ///  this function throws for queries about the zero address.\r\n    /// @param streamId The stream for whom to query the balance\r\n    /// @param who The address for whom to query the balance\r\n    /// @return The total funds available to `who` to withdraw\r\n    function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\r\n\r\n    /// @notice Returns the full stream data\r\n    /// @dev Throws if `streamId` points to an invalid stream.\r\n    /// @param streamId The stream to return data for\r\n    function getStream(uint256 streamId)\r\n        external\r\n        view\r\n        returns (\r\n            address sender,\r\n            address recipient,\r\n            uint256 deposit,\r\n            address token,\r\n            uint256 startTime,\r\n            uint256 stopTime,\r\n            uint256 balance,\r\n            uint256 rate\r\n        );\r\n}\r\n\r\n// File: contracts/Types.sol\r\n\r\nlibrary Types {\r\n    struct Stream {\r\n        uint256 balance;\r\n        uint256 deposit;\r\n        bool isEntity;\r\n        uint256 rate;\r\n        address recipient;\r\n        address sender;\r\n        uint256 startTime;\r\n        uint256 stopTime;\r\n        address tokenAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/Sablier.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Sablier - Money Streaming Implementation\r\n/// @author Paul Berg - <paul@sablier.app>\r\n\r\ncontract Sablier is IERC1620, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(uint256 => Types.Stream) private streams;\r\n    uint256 public nonce;\r\n\r\n    modifier onlyRecipient(uint256 streamId) {\r\n        require(streams[streamId].recipient == msg.sender, \"caller is not the recipient of the stream\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySenderOrRecipient(uint256 streamId) {\r\n        require(\r\n            msg.sender == streams[streamId].sender || msg.sender == streams[streamId].recipient,\r\n            \"caller is not the stream or the recipient of the stream\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier streamExists(uint256 streamId) {\r\n        require(streams[streamId].isEntity, \"stream does not exist\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        nonce = 1;\r\n    }\r\n\r\n    function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {\r\n        Types.Stream memory stream = streams[streamId];\r\n        uint256 delta = deltaOf(streamId);\r\n        uint256 streamed = delta.mul(stream.rate);\r\n        if (stream.balance != stream.deposit) {\r\n            streamed = streamed.sub(stream.deposit.sub(stream.balance));\r\n        }\r\n        if (who == stream.recipient) {\r\n            return streamed;\r\n        } else if (who == stream.sender) {\r\n            return stream.balance.sub(streamed);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function deltaOf(uint256 streamId) public view streamExists(streamId) returns (uint256 delta) {\r\n        Types.Stream memory stream = streams[streamId];\r\n\r\n        // before the start of the stream\r\n        if (block.timestamp <= stream.startTime) return 0;\r\n\r\n        // during the stream\r\n        if (block.timestamp < stream.stopTime) return block.timestamp - stream.startTime;\r\n\r\n        // after the end of the stream\r\n        return stream.stopTime - stream.startTime;\r\n    }\r\n\r\n    function getStream(uint256 streamId)\r\n        external\r\n        view\r\n        streamExists(streamId)\r\n        returns (\r\n            address sender,\r\n            address recipient,\r\n            uint256 deposit,\r\n            address tokenAddress,\r\n            uint256 startTime,\r\n            uint256 stopTime,\r\n            uint256 balance,\r\n            uint256 rate\r\n        )\r\n    {\r\n        Types.Stream memory stream = streams[streamId];\r\n        return (\r\n            stream.sender,\r\n            stream.recipient,\r\n            stream.deposit,\r\n            stream.tokenAddress,\r\n            stream.startTime,\r\n            stream.stopTime,\r\n            stream.balance,\r\n            stream.rate\r\n        );\r\n    }\r\n\r\n    function create(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)\r\n        external\r\n        returns (uint256 streamId)\r\n    {\r\n        require(recipient != address(0x00), \"stream to the zero address\");\r\n        require(recipient != address(this), \"stream to the contract itself\");\r\n        require(recipient != msg.sender, \"stream to the caller\");\r\n        require(deposit > 0, \"deposit is zero\");\r\n        require(startTime >= block.timestamp, \"start time before block.timestamp\");\r\n        require(stopTime > startTime, \"stop time before the start time\");\r\n        require(deposit.mod(stopTime.sub(startTime)) == 0, \"deposit not multiple of time delta\");\r\n\r\n        streamId = nonce;\r\n        address sender = msg.sender;\r\n        uint256 rate = deposit.div(stopTime.sub(startTime));\r\n        streams[streamId] = Types.Stream({\r\n            balance: deposit,\r\n            deposit: deposit,\r\n            isEntity: true,\r\n            rate: rate,\r\n            recipient: recipient,\r\n            sender: sender,\r\n            startTime: startTime,\r\n            stopTime: stopTime,\r\n            tokenAddress: tokenAddress\r\n        });\r\n\r\n        emit Create(streamId, sender, recipient, deposit, tokenAddress, startTime, stopTime);\r\n\r\n        nonce = nonce.add(1);\r\n        require(IERC20(tokenAddress).transferFrom(sender, address(this), deposit), \"token transfer failure\");\r\n    }\r\n\r\n    function withdraw(uint256 streamId, uint256 amount) external streamExists(streamId) onlyRecipient(streamId) {\r\n        require(amount > 0, \"amount is zero\");\r\n        Types.Stream memory stream = streams[streamId];\r\n        uint256 balance = balanceOf(streamId, stream.recipient);\r\n        require(balance >= amount, \"withdrawal exceeds the available balance\");\r\n\r\n        streams[streamId].balance = streams[streamId].balance.sub(amount);\r\n        emit Withdraw(streamId, stream.recipient, amount);\r\n\r\n        // saving gas\r\n        if (streams[streamId].balance == 0) delete streams[streamId];\r\n\r\n        // saving gas by checking beforehand\r\n        require(IERC20(stream.tokenAddress).transfer(stream.recipient, amount), \"token transfer failure\");\r\n    }\r\n\r\n    function cancel(uint256 streamId) external streamExists(streamId) onlySenderOrRecipient(streamId) {\r\n        Types.Stream memory stream = streams[streamId];\r\n        uint256 senderAmount = balanceOf(streamId, stream.sender);\r\n        uint256 recipientAmount = balanceOf(streamId, stream.recipient);\r\n\r\n        emit Cancel(streamId, stream.sender, stream.recipient, senderAmount, recipientAmount);\r\n\r\n        // saving gas\r\n        delete streams[streamId];\r\n\r\n        // saving gas by checking beforehand\r\n        if (recipientAmount > 0)\r\n            require(\r\n                IERC20(stream.tokenAddress).transfer(stream.recipient, recipientAmount),\r\n                \"recipient token transfer failure\"\r\n            );\r\n        if (senderAmount > 0)\r\n            require(IERC20(stream.tokenAddress).transfer(stream.sender, senderAmount), \"sender token transfer failure\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"stopTime\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"streamId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"streamId\",\"type\":\"uint256\"},{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"streamId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"stopTime\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"deltaOf\",\"outputs\":[{\"name\":\"delta\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stopTime\",\"type\":\"uint256\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"senderAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientAmount\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"}]","ContractName":"Sablier","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://24b057e7686e8e9c7e839e67fa15982ba4e94cfc9a0a25345eaf083288541bba"}]}