{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2019 The Hydro Protocol Foundation\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IEth2Dai{\r\n    function isClosed()\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function buyEnabled()\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function matchingEnabled()\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getBuyAmount(\r\n        address buy_gem,\r\n        address pay_gem,\r\n        uint256 pay_amt\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPayAmount(\r\n        address pay_gem,\r\n        address buy_gem,\r\n        uint256 buy_amt\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IMakerDaoOracle{\r\n    function peek()\r\n        external\r\n        view\r\n        returns (bytes32, bool);\r\n}\r\n\r\ninterface IStandardToken {\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /** @dev The Ownable constructor sets the original `owner` of the contract to the sender account. */\r\n    constructor()\r\n        internal\r\n    {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /** @return the address of the owner. */\r\n    function owner()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    /** @dev Throws if called by any account other than the owner. */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /** @return true if `msg.sender` is the owner of the contract. */\r\n    function isOwner()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /** @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /** @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(\r\n        address newOwner\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"INVALID_OWNER\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    // Multiplies two numbers, reverts on overflow.\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    // Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    function div(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    // Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function sub(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b <= 2**255-1, \"INT256_SUB_ERROR\");\r\n        int256 c = a - int256(b);\r\n        require(c <= a, \"INT256_SUB_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    // Adds two numbers, reverts on overflow.\r\n    function add(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function add(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b <= 2**255 - 1, \"INT256_ADD_ERROR\");\r\n        int256 c = a + int256(b);\r\n        require(c >= a, \"INT256_ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    // Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, \"MOD_ERROR\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * Check the amount of precision lost by calculating multiple * (numerator / denominator). To\r\n     * do this, we check the remainder and make sure it's proportionally less than 0.1%. So we have:\r\n     *\r\n     *     ((numerator * multiple) % denominator)     1\r\n     *     -------------------------------------- < ----\r\n     *              numerator * multiple            1000\r\n     *\r\n     * To avoid further division, we can move the denominators to the other sides and we get:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 < numerator * multiple\r\n     *\r\n     * Since we want to return true if there IS a rounding error, we simply flip the sign and our\r\n     * final equation becomes:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 >= numerator * multiple\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return Boolean indicating if there is a rounding error when calculating the proportion\r\n     */\r\n    function isRoundingError(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple)\r\n        return mul(mod(mul(numerator, multiple), denominator), 1000) >= mul(numerator, multiple);\r\n    }\r\n\r\n    /**\r\n     * Takes an amount (multiple) and calculates a proportion of it given a numerator/denominator\r\n     * pair of values. The final value will be rounded down to the nearest integer value.\r\n     *\r\n     * This function will revert the transaction if rounding the final value down would lose more\r\n     * than 0.1% precision.\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return The final proportion of multiple rounded down\r\n     */\r\n    function getPartialAmountFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(!isRoundingError(numerator, denominator, multiple), \"ROUNDING_ERROR\");\r\n        // numerator.mul(multiple).div(denominator)\r\n        return div(mul(numerator, multiple), denominator);\r\n    }\r\n\r\n    /**\r\n     * Returns the smaller integer of the two passed in.\r\n     *\r\n     * @param a Unsigned integer\r\n     * @param b Unsigned integer\r\n     * @return The smaller of the two integers\r\n     */\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract DaiPriceOracle is Ownable{\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public price;\r\n\r\n    uint256 constant ONE = 10**18;\r\n\r\n    IMakerDaoOracle public constant makerDaoOracle = IMakerDaoOracle(0x729D19f657BD0614b4985Cf1D82531c67569197B);\r\n    IStandardToken public constant DAI = IStandardToken(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    IEth2Dai public constant Eth2Dai = IEth2Dai(0x39755357759cE0d7f32dC8dC45414CCa409AE24e);\r\n\r\n    address public constant UNISWAP = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;\r\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    uint256 public constant eth2daiETHAmount = 10 ether;\r\n    uint256 public constant eth2daiMaxSpread = 2 * ONE / 100; // 2.00%\r\n    uint256 public constant uniswapMinETHAmount = 2000 ether;\r\n\r\n    event UpdatePrice(uint256 newPrice);\r\n\r\n    function getPrice(\r\n        address asset\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(asset == address(DAI), \"ASSET_NOT_MATCH\");\r\n        return price;\r\n    }\r\n\r\n    function adminSetPrice(\r\n        uint256 _price\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        if (!updatePrice()){\r\n            price = _price;\r\n        }\r\n\r\n        emit UpdatePrice(price);\r\n    }\r\n\r\n    function updatePrice()\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 _price = peek();\r\n\r\n        if (_price != 0) {\r\n            price = _price;\r\n            emit UpdatePrice(price);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function peek()\r\n        public\r\n        view\r\n        returns (uint256 _price)\r\n    {\r\n        uint256 makerDaoPrice = getMakerDaoPrice();\r\n\r\n        if (makerDaoPrice == 0) {\r\n            return _price;\r\n        }\r\n\r\n        uint256 eth2daiPrice = getEth2DaiPrice();\r\n\r\n        if (eth2daiPrice > 0) {\r\n            _price = makerDaoPrice.mul(ONE).div(eth2daiPrice);\r\n            return _price;\r\n        }\r\n\r\n        uint256 uniswapPrice = getUniswapPrice();\r\n\r\n        if (uniswapPrice > 0) {\r\n            _price = makerDaoPrice.mul(ONE).div(uniswapPrice);\r\n            return _price;\r\n        }\r\n\r\n        return _price;\r\n    }\r\n\r\n    function getEth2DaiPrice()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (Eth2Dai.isClosed() || !Eth2Dai.buyEnabled() || !Eth2Dai.matchingEnabled()) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 bidDai = Eth2Dai.getBuyAmount(address(DAI), WETH, eth2daiETHAmount);\r\n        uint256 askDai = Eth2Dai.getPayAmount(address(DAI), WETH, eth2daiETHAmount);\r\n\r\n        uint256 bidPrice = bidDai.mul(ONE).div(eth2daiETHAmount);\r\n        uint256 askPrice = askDai.mul(ONE).div(eth2daiETHAmount);\r\n\r\n        uint256 spread = askPrice.mul(ONE).div(bidPrice).sub(ONE);\r\n\r\n        if (spread > eth2daiMaxSpread) {\r\n            return 0;\r\n        } else {\r\n            return bidPrice.add(askPrice).div(2);\r\n        }\r\n    }\r\n\r\n    function getUniswapPrice()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 ethAmount = UNISWAP.balance;\r\n        uint256 daiAmount = DAI.balanceOf(UNISWAP);\r\n        uint256 uniswapPrice = daiAmount.mul(10**18).div(ethAmount);\r\n\r\n        if (ethAmount < uniswapMinETHAmount) {\r\n            return 0;\r\n        } else {\r\n            return uniswapPrice;\r\n        }\r\n    }\r\n\r\n    function getMakerDaoPrice()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (bytes32 value, bool has) = makerDaoOracle.peek();\r\n\r\n        if (has) {\r\n            return uint256(value);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"adminSetPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerDaoOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapMinETHAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Eth2Dai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updatePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMakerDaoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth2daiETHAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEth2DaiPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth2daiMaxSpread\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNISWAP\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DaiPriceOracle","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://83c3fc9dd29b06ec54131f192db147b0047f1a6b5d4e802c0fba3abaac910fc6"}]}