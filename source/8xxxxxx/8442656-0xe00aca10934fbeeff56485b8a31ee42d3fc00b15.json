{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2018-09-08\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * \r\n\r\n                                  `.-::::::::::::-.`\r\n                           .:::+:-.`            `.-:+:::.\r\n                      `::::.   `-                  -`   .:::-`\r\n                   .:::`        :         J        :        `:::.\r\n                `:/-            `-        A       -`            -/:`\r\n              ./:`               :        C      `:               `:/.\r\n            .+:                   :       K      :                  `:+.\r\n          `/-`..`                 -`      P     `-                 `..`-/`\r\n         :/`    ..`                :      O     :                `..    `/:\r\n       `+.        ..`              -`     T    `-              `..        .+`\r\n      .+`           ..`             :          :             `..           `+.\r\n     -+               ..`           -.        ..           `..               +-\r\n    .+                 `..`          :        :          `..                  +.\r\n   `o                    `..`        ..      ..        `..`                    o`\r\n   o`                      `..`     `./------/.`     `..`                      `o\r\n  -+``                       `..``-::.````````.::-``..`                       ``+-\r\n  s```....````                 `+:.  ..------..  .:+`                 ````....```o\r\n .+       ````...````         .+. `--``      ``--` .+.         ````...````       +.\r\n +.              ````....`````+` .:`            `:. `o`````....````              ./\r\n o                       ````s` `/                :,  `s````                       o\r\n s                           s  :   WHEEL OF SHUF  ;  s                           s\r\n s                           s  /`                 `/  s                           s\r\n s                        ```s` `/                /` `s```                        o\r\n +.               ````....```.+  .:`            `:.  +.```....````               .+\r\n ./        ```....````        -/` `--`        `--` `/.        ````....```        +.\r\n  s````....```                 .+:` `.--------.` `:+.                 ```....````s\r\n  :/```                       ..`.::-.``    ``.-::.`..                       ```/:\r\n   o`                       ..`     `-/-::::-/-`     `..                       `o\r\n   `o                     ..`        ..      ..        `..                     o`\r\n    -/                  ..`          :        :          `..                  /-\r\n     -/               ..`           ..        ..           `..               /-\r\n      -+`           ..`             :          :             `-.           `+-\r\n       .+.        .-`              -`          ..              `-.        .+.\r\n         /:     .-`                :            :                `-.    `:/\r\n          ./- .-`                 -`            `-                 `-. -/.\r\n            -+-                   :              :                   :+-\r\n              -/-`               -`              `-               `-/-\r\n                .:/.             :                :             ./:.\r\n                   -:/-         :                  :         -/:-\r\n                      .:::-`   `-                  -`   `-:::.\r\n                          `-:::+-.`              `.:+:::-`\r\n                                `.-::::::::::::::-.`\r\n\r\nðŸŽ°ðŸƒ Wheel Of SHUF ðŸŽ°ðŸƒ\r\nhttps://wheelofshuf.io\r\n**/\r\n\r\ncontract ERC20Interface\r\n{\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract WheelOf0xSHUF {\r\n    using SafeMath for uint;\r\n\r\n    //  Modifiers\r\n\r\n    modifier nonContract() {                // contracts pls go\r\n        require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier gameActive() {\r\n        require(gamePaused == false);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin(){\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    // Events\r\n\r\n    event onDeposit(\r\n        address indexed customerAddress,\r\n        uint256 tokensIn,\r\n        uint256 contractBal,\r\n        uint256 devFee,\r\n        uint timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 tokensOut,\r\n        uint256 contractBal,\r\n        uint timestamp\r\n    );\r\n\r\n    event spinResult(\r\n        address indexed customerAddress,\r\n        uint256 wheelNumber,\r\n        uint256 outcome,\r\n        uint256 tokensSpent,\r\n        uint256 tokensReturned,\r\n        uint256 userBalance,\r\n        uint timestamp\r\n    );\r\n\r\n    uint256 _seed;\r\n    address admin;\r\n    bool public gamePaused = false;\r\n    uint256 minBet = 100000000;\r\n    uint256 maxBet = 500000000000;\r\n    uint256 devFeeBalance = 0;\r\n\r\n    uint8[10] brackets = [1,3,6,12,24,40,56,68,76,80];\r\n\r\n    struct playerSpin {\r\n        uint256 betAmount;\r\n        uint48 blockNum;\r\n    }\r\n\r\n    mapping(address => playerSpin) public playerSpins;\r\n    mapping(address => uint256) internal personalFactorLedger_;\r\n    mapping(address => uint256) internal balanceLedger_;\r\n\r\n    uint256 internal globalFactor = 10e21;\r\n    uint256 constant internal constantFactor = 10e21 * 10e21;\r\n    address public tokenAddress = 0x3A9FfF453d50D4Ac52A6890647b823379ba36B9E;\r\n\r\n    constructor()\r\n        public\r\n    {\r\n        admin = msg.sender;\r\n    }\r\n\r\n\r\n    function getBalance()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ERC20Interface(tokenAddress).balanceOf(this);\r\n    }\r\n\r\n\r\n    //deposit needs approval from token contract\r\n    function deposit(address _customerAddress, uint256 amount)\r\n        public\r\n        gameActive\r\n    {\r\n        require(tx.origin == _customerAddress);\r\n        require(amount >= (minBet * 2));\r\n        require(ERC20Interface(tokenAddress).transferFrom(_customerAddress, this, amount), \"token transfer failed\");\r\n        // Add 4% fee of the buy to devFeeBalance\r\n        uint256 devFee = amount / 10;\r\n        devFeeBalance = devFeeBalance.add(devFee);\r\n        // Adjust ledgers while taking the dev fee into account\r\n        balanceLedger_[_customerAddress] = tokenBalanceOf(_customerAddress).add(amount).sub(devFee);\r\n        personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n\r\n        emit onDeposit(_customerAddress, amount, getBalance(), devFee, now);\r\n    }\r\n\r\n\r\n    function receiveApproval(address receiveFrom, uint256 amount, address tknaddr, bytes data)\r\n      public\r\n    {\r\n        if (uint(data[0]) == 0) {\r\n          deposit(receiveFrom, amount);\r\n        } else {\r\n          depositAndSpin(receiveFrom, amount);\r\n        }\r\n    }\r\n\r\n\r\n    //withdraw from contract\r\n    function withdraw(uint256 amount)\r\n      public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(amount <= tokenBalanceOf(_customerAddress));\r\n        require(amount > 0);\r\n        if(!ERC20Interface(tokenAddress).transfer(_customerAddress, amount))\r\n            revert();\r\n        balanceLedger_[_customerAddress] = tokenBalanceOf(_customerAddress).sub(amount);\r\n        personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n        emit onWithdraw(_customerAddress, amount, getBalance(), now);\r\n    }\r\n\r\n\r\n    function withdrawAll()\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        // Set the sell amount to the user's full balance, don't sell if empty\r\n        uint256 amount = tokenBalanceOf(_customerAddress);\r\n        require(amount > 0);\r\n        // Transfer balance and update user ledgers\r\n        if(!ERC20Interface(tokenAddress).transfer(_customerAddress, amount))\r\n            revert();\r\n        balanceLedger_[_customerAddress] = 0;\r\n        personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n        emit onWithdraw(_customerAddress, amount, getBalance(), now);\r\n    }\r\n\r\n\r\n    function tokenBalanceOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Balance ledger * personal factor * globalFactor / constantFactor\r\n        return balanceLedger_[_customerAddress].mul(personalFactorLedger_[_customerAddress]).mul(globalFactor) / constantFactor;\r\n    }\r\n\r\n\r\n    function spinTokens(uint256 betAmount)\r\n        public\r\n        nonContract\r\n        gameActive\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        // User must have enough eth\r\n        require(tokenBalanceOf(_customerAddress) >= betAmount);\r\n        // User must bet at least the minimum\r\n        require(betAmount >= minBet);\r\n        // If the user bets more than maximum...they just bet the maximum\r\n        if (betAmount > maxBet){\r\n            betAmount = maxBet;\r\n        }\r\n        // User cannot bet more than 10% of available pool\r\n        if (betAmount > betPool(_customerAddress)/10) {\r\n            betAmount = betPool(_customerAddress)/10;\r\n        }\r\n        // Execute the bet and return the outcome\r\n        startSpin(betAmount, _customerAddress);\r\n    }\r\n\r\n\r\n    function spinAll()\r\n        public\r\n        nonContract\r\n        gameActive\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        // set the bet amount to the user's full balance\r\n        uint256 betAmount = tokenBalanceOf(_customerAddress);\r\n        // User cannot bet more than 10% of available pool\r\n        if (betAmount > betPool(_customerAddress)/10) {\r\n            betAmount = betPool(_customerAddress)/10;\r\n        }\r\n        // User must bet more than the minimum\r\n        require(betAmount >= minBet);\r\n        // If the user bets more than maximum...they just bet the maximum\r\n        if (betAmount >= maxBet){\r\n            betAmount = maxBet;\r\n        }\r\n        // Execute the bet and return the outcome\r\n        startSpin(betAmount, _customerAddress);\r\n    }\r\n\r\n\r\n    //deposit needs approval from token contract\r\n    function depositAndSpin(address _customerAddress, uint256 betAmount)\r\n        public\r\n        gameActive\r\n    {\r\n        require(tx.origin == _customerAddress);\r\n        require(betAmount >= (minBet * 2));\r\n        require(ERC20Interface(tokenAddress).transferFrom(_customerAddress, this, betAmount), \"token transfer failed\");\r\n        // Add 4% fee of the buy to devFeeBalance\r\n        uint256 devFee = betAmount / 10;\r\n        devFeeBalance = devFeeBalance.add(devFee);\r\n        // Adjust ledgers while taking the dev fee into account\r\n        balanceLedger_[_customerAddress] = tokenBalanceOf(_customerAddress).add(betAmount).sub(devFee);\r\n        personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n\r\n        emit onDeposit(_customerAddress, betAmount, getBalance(), devFee, now);\r\n\r\n        betAmount = betAmount.sub(devFee);\r\n        // If the user bets more than maximum...they just bet the maximum\r\n        if (betAmount >= maxBet){\r\n            betAmount = maxBet;\r\n        }\r\n        // User cannot bet more than 10% of available pool\r\n        if (betAmount > betPool(_customerAddress)/10) {\r\n            betAmount = betPool(_customerAddress)/10;\r\n        }\r\n        // Execute the bet while taking the dev fee into account, and return the outcome\r\n        startSpin(betAmount, _customerAddress);\r\n    }\r\n\r\n\r\n    function betPool(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Balance of contract, minus eth balance of user and accrued dev fees\r\n        return getBalance().sub(tokenBalanceOf(_customerAddress)).sub(devFeeBalance);\r\n    }\r\n\r\n    /*\r\n        panicButton and refundUser are here incase of an emergency, or launch of a new contract\r\n        The game will be frozen, and all token holders will be refunded\r\n    */\r\n\r\n    function panicButton(bool newStatus)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        gamePaused = newStatus;\r\n    }\r\n\r\n\r\n    function refundUser(address _customerAddress)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        uint256 withdrawAmount = tokenBalanceOf(_customerAddress);\r\n        if(!ERC20Interface(tokenAddress).transfer(_customerAddress, withdrawAmount))\r\n            revert();\r\n        balanceLedger_[_customerAddress] = 0;\r\n\t      personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n        emit onWithdraw(_customerAddress, withdrawAmount, getBalance(), now);\r\n    }\r\n\r\n\r\n    function updateMinBet(uint256 newMin)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(newMin > 0);\r\n        minBet = newMin;\r\n    }\r\n\r\n\r\n    function updateMaxBet(uint256 newMax)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(newMax > 0);\r\n        maxBet = newMax;\r\n    }\r\n\r\n\r\n    function getDevBalance()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return devFeeBalance;\r\n    }\r\n\r\n\r\n    function withdrawDevFees()\r\n        public\r\n    {\r\n        address fund = 0xba111Ab673241d8f7C71029e8225529332D76735;\r\n        uint256 initDevBal = devFeeBalance;\r\n        if(!ERC20Interface(tokenAddress).transfer(fund, devFeeBalance/2))\r\n          revert();\r\n        devFeeBalance = devFeeBalance.sub(initDevBal/2);\r\n  }\r\n\r\n\r\n    function finishSpin(address _customerAddress)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return _finishSpin(_customerAddress);\r\n    }\r\n\r\n\r\n    // Internal Functions\r\n\r\n\r\n    function startSpin(uint256 betAmount, address _customerAddress)\r\n        internal\r\n    {\r\n        playerSpin memory spin = playerSpins[_customerAddress];\r\n        require(block.number != spin.blockNum);\r\n\r\n        if (spin.blockNum != 0) {\r\n            _finishSpin(_customerAddress);\r\n        }\r\n        lose(_customerAddress, betAmount);\r\n        playerSpins[_customerAddress] = playerSpin(uint256(betAmount), uint48(block.number));\r\n    }\r\n\r\n\r\n    function _finishSpin(address _customerAddress)\r\n        internal\r\n        returns (uint256 resultNum)\r\n    {\r\n        playerSpin memory spin = playerSpins[_customerAddress];\r\n        require(block.number != spin.blockNum);\r\n\r\n        uint result;\r\n        if (block.number - spin.blockNum > 255) {\r\n            resultNum = 80;\r\n            result = 9; // timed out :(\r\n            return resultNum;\r\n        } else {\r\n            resultNum = random(80, spin.blockNum, _customerAddress);\r\n            result = determinePrize(resultNum);\r\n        }\r\n\r\n        uint256 betAmount = spin.betAmount;\r\n        uint256 returnedAmount;\r\n\r\n        if (result < 5)                                             // < 5 = WIN\r\n        {\r\n            uint256 wonAmount;\r\n            if (result == 0){                                       // Grand Jackpot\r\n                wonAmount = betAmount.mul(9) / 10;                  // +90% of original bet\r\n            } else if (result == 1){                                // Jackpot\r\n                wonAmount = betAmount.mul(8) / 10;                  // +80% of original bet\r\n            } else if (result == 2){                                // Grand Prize\r\n                wonAmount = betAmount.mul(7) / 10;                  // +70% of original bet\r\n            } else if (result == 3){                                // Major Prize\r\n                wonAmount = betAmount.mul(6) / 10;                  // +60% of original bet\r\n            } else if (result == 4){                                // Minor Prize\r\n                wonAmount = betAmount.mul(3) / 10;                  // +30% of original bet\r\n            }\r\n            returnedAmount = betAmount.add(wonAmount);\r\n        } else if (result == 5){                                    // 5 = Refund\r\n            returnedAmount = betAmount;\r\n        } else {                                                    // > 5 = LOSE\r\n            uint256 lostAmount;\r\n            if (result == 6){                                \t    // Minor Loss\r\n                lostAmount = betAmount / 10;                        // -10% of original bet\r\n            } else if (result == 7){                                // Major Loss\r\n                lostAmount = betAmount / 4;                         // -25% of original bet\r\n            } else if (result == 8){                                // Grand Loss\r\n                lostAmount = betAmount / 2;                     \t// -50% of original bet\r\n            } else if (result == 9){                                // Total Loss\r\n                lostAmount = betAmount;                             // -100% of original bet\r\n            }\r\n            returnedAmount = betAmount.sub(lostAmount);\r\n        }\r\n        if (returnedAmount > 0) {\r\n            win(_customerAddress, returnedAmount);                  // Give user their tokens\r\n        }\r\n        uint256 newBal = tokenBalanceOf(_customerAddress);\r\n        emit spinResult(_customerAddress, resultNum, result, betAmount, returnedAmount, newBal, now);\r\n\r\n        playerSpins[_customerAddress] = playerSpin(uint256(0), uint48(0));\r\n\r\n        return resultNum;\r\n    }\r\n\r\n\r\n    function maxRandom(uint blockn, address entropy)\r\n        internal\r\n        returns (uint256 randomNumber)\r\n    {\r\n        return uint256(keccak256(\r\n            abi.encodePacked(\r\n              blockhash(blockn),\r\n              entropy)\r\n        ));\r\n    }\r\n\r\n\r\n    function random(uint256 upper, uint256 blockn, address entropy)\r\n        internal\r\n        returns (uint256 randomNumber)\r\n    {\r\n        return maxRandom(blockn, entropy) % upper + 1;\r\n    }\r\n\r\n\r\n    function determinePrize(uint256 result)\r\n        internal\r\n        returns (uint256 resultNum)\r\n    {\r\n        // Loop until the result bracket is determined\r\n        for (uint8 i=0;i<=9;i++){\r\n            if (result <= brackets[i]){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function lose(address _customerAddress, uint256 lostAmount)\r\n        internal\r\n    {\r\n        uint256 customerBal = tokenBalanceOf(_customerAddress);\r\n        // Increase amount of eth everyone else owns\r\n        uint256 globalIncrease = globalFactor.mul(lostAmount) / betPool(_customerAddress);\r\n        globalFactor = globalFactor.add(globalIncrease);\r\n        // Update user ledgers\r\n        personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n        // User can't lose more than they have\r\n        if (lostAmount > customerBal){\r\n            lostAmount = customerBal;\r\n        }\r\n        balanceLedger_[_customerAddress] = customerBal.sub(lostAmount);\r\n    }\r\n\r\n\r\n    function win(address _customerAddress, uint256 wonAmount)\r\n        internal\r\n    {\r\n        uint256 customerBal = tokenBalanceOf(_customerAddress);\r\n        // Decrease amount of eth everyone else owns\r\n        uint256 globalDecrease = globalFactor.mul(wonAmount) / betPool(_customerAddress);\r\n        globalFactor = globalFactor.sub(globalDecrease);\r\n        // Update user ledgers\r\n        personalFactorLedger_[_customerAddress] = constantFactor / globalFactor;\r\n        balanceLedger_[_customerAddress] = customerBal.add(wonAmount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"spinAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDevFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerSpins\",\"outputs\":[{\"name\":\"betAmount\",\"type\":\"uint256\"},{\"name\":\"blockNum\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"panicButton\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"betPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"finishSpin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"refundUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiveFrom\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"tknaddr\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"depositAndSpin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"updateMaxBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"spinTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDevBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMin\",\"type\":\"uint256\"}],\"name\":\"updateMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractBal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"devFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractBal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wheelNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outcome\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensReturned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"spinResult\",\"type\":\"event\"}]","ContractName":"WheelOf0xSHUF","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b89775227d6a3bfc60c64e336d6e08bffbf707810ad7c808170cfd9416cf4dc2"}]}