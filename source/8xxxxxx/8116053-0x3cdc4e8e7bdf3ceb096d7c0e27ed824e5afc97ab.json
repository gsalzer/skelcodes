{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (`ERC165Checker`).\r\n *\r\n * For an implementation, see `ERC165`.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * \r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either `approve` or `setApproveForAll`.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either `approve` or `setApproveForAll`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC165` interface.\r\n *\r\n * Contracts may inherit from this and call `_registerInterface` to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC165.supportsInterface`.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See `IERC165.supportsInterface`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID.\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender, \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner.\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists.\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID.\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * This function is deprecated.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID.\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name.\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol.\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID.\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token.\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to set its URI\r\n     * @param uri string URI to assign\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is PauserRole {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/eth_superplayer_randomequip.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\ncontract IRandomBuffValue {\r\n    function randomValue(uint keyid,uint random) public view returns(uint);\r\n}\r\n\r\n\r\n\r\n\r\ncontract SuperplayerRandomValueBase is Ownable {\r\n  using SafeMath for uint256;\r\n  struct ValueByWeight {\r\n    uint value;\r\n    uint weight;\r\n  }\r\n\r\n  mapping(uint => ValueByWeight[] ) randomvalueTable  ;\r\n  mapping(uint => uint ) randomvalueTableWeights  ;\r\n\r\n  function randomValue (uint keyid,uint random ) public view returns(uint rv){\r\n      rv = _randomValue(keyid,  random% randomvalueTableWeights[keyid] +1 );\r\n  }\r\n\r\n\r\n  function getRandomValueConf(uint keyid) public view returns( uint[]memory values,uint[] memory weights){\r\n    ValueByWeight[] memory vs  =randomvalueTable[keyid];\r\n    values = new uint[](vs.length);\r\n    weights = new uint[](vs.length);\r\n    for(uint i = 0 ;i < vs.length;++i) {\r\n      values[i]=vs[i].value;\r\n      weights[i]=vs[i].weight;\r\n    }\r\n  }\r\n\r\n  function addRandomValuesforRTable(uint keyid, uint[] memory values,uint[] memory weights) public onlyOwner {\r\n    _addRandomValuesforRTable(keyid,values,weights);\r\n  }\r\n\r\n\r\n  function _randomValue (uint keyid,uint weight ) internal view returns(uint randomValue){\r\n    ValueByWeight[] memory vs  =randomvalueTable[keyid];\r\n    uint sum ;\r\n    for (uint i = 0;i < vs.length ; i++){\r\n      ValueByWeight memory vw  = vs[i];\r\n      sum += vw.weight;\r\n      if( weight  <=  sum ){\r\n        return vw.value;\r\n      }\r\n    }\r\n    return vs[vs.length -1].value ;\r\n  }\r\n\r\n function _addRandomValuesforRTable(uint keyid, uint[] memory values,uint[] memory weights) internal {\r\n    require(randomvalueTableWeights[keyid]  == 0 );\r\n    for( uint i = 0; i < values.length;++i) {\r\n      ValueByWeight memory vw  = ValueByWeight({\r\n        value : values[i],\r\n        weight: weights[i]\r\n      });\r\n      randomvalueTable[keyid].push(vw);\r\n      randomvalueTableWeights[keyid] += weights[i];\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SuperplayerRandomEquipmentBase  is Ownable{\r\n\r\n  using SafeMath for uint256;\r\n\r\n  //enum EquipmentPart {Weapon ,Head,Coat,Pants ,Shoes }\r\n  //enum EquipmentRareness {White,Green,Blue,Purple, Orange,Red }\r\n\r\n  // Equipment in pool\r\n  struct Equipment {\r\n    string key;\r\n    uint weight;\r\n    uint[] randomKeyIds; \r\n    uint maxCnt;\r\n  }\r\n\r\n\r\n\r\n\r\n  mapping(uint256 => uint256 ) equipsCurrCnt;\r\n\r\n  Equipment[] private equips;\r\n  uint256 TotalEquipNum; // for ERC721\r\n\r\n  IRandomBuffValue  insRandomBuff;\r\n  //keyid -> value->weight\r\n\r\n  constructor(address insRandomBuffAddr) public{\r\n    insRandomBuff = IRandomBuffValue(insRandomBuffAddr);\r\n  }\r\n\r\n  function getRandomEquipment(uint256 seed) public view returns(uint blockNo,string memory ekey,uint[] memory randomProps)  {\r\n    uint TotalWeight = _getTotalWeight();\r\n    require(TotalWeight>0);\r\n    uint random = getRandom(seed);\r\n    uint equipIndex = getRandomEquipIndexByWeight(  random % TotalWeight  + 1) ;\r\n    //ensure equipment index\r\n    Equipment memory  equip =  equips[equipIndex];\r\n\r\n    //ensure random values\r\n    randomProps = new uint[](equip.randomKeyIds.length);\r\n    for(uint i=0;i< randomProps.length ; i++) {\r\n      uint keyid = equip.randomKeyIds[i] ;\r\n      uint rv = insRandomBuff.randomValue(keyid,  (random >>i ) );\r\n      randomProps[i] = rv;\r\n    }\r\n    blockNo = block.number;\r\n    ekey = equip.key;\r\n  }\r\n\r\n\r\n  function getRandom(uint256 seed) internal view returns (uint256){\r\n    return uint256(keccak256(abi.encodePacked(block.timestamp, seed,block.difficulty)));\r\n  }\r\n\r\n\r\n\r\n  function addEquipToPool(string memory key,uint[] memory randomKeyIds,uint weight,uint maxCnt) public  onlyOwner{\r\n    _addEquipToPool(key,randomKeyIds,weight,maxCnt);\r\n  }\r\n\r\n\r\n  //config end\r\n  function getCurrentQty() public view returns( uint[] memory ukeys,uint[] memory maxCnt,uint[] memory currentCnt ){\r\n    ukeys = new uint[](TotalEquipNum);\r\n    maxCnt = new uint[](TotalEquipNum);\r\n    currentCnt = new uint[](TotalEquipNum);\r\n\r\n    for (uint i = 0;i < TotalEquipNum ; i++){\r\n      uint ukey = uint256(keccak256(abi.encodePacked(bytes(equips[i].key))));\r\n      ukeys[i] =  ukey;\r\n      maxCnt[i] = equips[i].maxCnt;\r\n      currentCnt[i] = equipsCurrCnt[ukey];\r\n    }\r\n  }\r\n\r\n  //config end\r\n  function getEquipmentConf(uint equipIndex) public view returns( string memory key,uint weight,uint[] memory randomKeyIds){\r\n    Equipment memory  equip =  equips[equipIndex];\r\n    key = equip.key;\r\n    weight = equip.weight;\r\n    randomKeyIds = equip.randomKeyIds;\r\n  }\r\n\r\n\r\n  function getRandomEquipIndexByWeight( uint weight ) internal view returns (uint) {\r\n    uint TotalWeight = _getTotalWeight();\r\n    require( weight <= TotalWeight );\r\n    uint sum ;\r\n    for (uint i = 0;i < TotalEquipNum ; i++){\r\n     uint256 uintkey = uint256(keccak256(abi.encodePacked(bytes(equips[i].key))));\r\n     if (equips[i].maxCnt > equipsCurrCnt[ uintkey ]) {\r\n        sum += equips[i].weight;\r\n        if( weight  <=  sum ){\r\n          return i;\r\n        }\r\n     }\r\n    }\r\n    return TotalEquipNum -1 ;\r\n  }\r\n\r\n\r\n  function _addEquipToPool(string memory key,uint[] memory randomKeyIds,uint weight,uint maxCnt) internal {\r\n    Equipment memory newEquip = Equipment({\r\n      key : key,\r\n      randomKeyIds : randomKeyIds,\r\n      weight : weight,\r\n      maxCnt : maxCnt\r\n    });\r\n    equips.push(newEquip);\r\n    TotalEquipNum = TotalEquipNum.add(1);\r\n  }\r\n\r\n\r\n  function _incrCurrentEquipCnt(string memory key) internal {\r\n     uint256 uintkey = uint256(keccak256(abi.encodePacked(bytes(key))));\r\n     equipsCurrCnt[uintkey] = equipsCurrCnt[uintkey]  + 1;\r\n  }\r\n\r\n  function _getTotalWeight( ) internal view returns(uint) {\r\n    uint res = 0;\r\n    for (uint i = 0;i < TotalEquipNum ; i++){\r\n     uint256 uintkey = uint256(keccak256(abi.encodePacked(bytes(equips[i].key))));\r\n     if (equips[i].maxCnt > equipsCurrCnt[ uintkey ]) {\r\n       res += equips[i].weight;\r\n     }\r\n    }\r\n    return res;\r\n  }\r\n\r\n}\r\n\r\ncontract SuperPlayerGachaWithRecommendReward  is Ownable  {\r\n\r\n  mapping(uint=> address) recommendRecord;\r\n\r\n\r\n  function addRecommend(string memory key,address payable to ) public  onlyOwner{\r\n     uint256 uintkey = uint256(keccak256(abi.encodePacked(bytes(key))));\r\n     recommendRecord[uintkey] = to;\r\n  }\r\n\r\n\r\n  function getRecommendAddress( string memory key ) public view returns(address) {\r\n    return _getRecommendAddress(key);\r\n  }\r\n\r\n  function _getRecommendAddress( string memory key ) internal view returns(address) {\r\n     uint256 uintkey = uint256(keccak256(abi.encodePacked(bytes(key))));\r\n     return recommendRecord[uintkey];\r\n  }\r\n\r\n\r\n\r\n}\r\n\r\ncontract SuperPlayerGachaTest  is SuperplayerRandomEquipmentBase ,SuperPlayerGachaWithRecommendReward{\r\n\r\n  using SafeMath for uint256;\r\n\r\n  uint256 recommendRatio = 3000; //base 10000\r\n  event Draw(string key);\r\n\r\n  constructor(address insRandomBuffAddr) SuperplayerRandomEquipmentBase(insRandomBuffAddr) public{\r\n\r\n    feeForOne = 66 finney ;\r\n    feeForTen = 594 finney;\r\n  }\r\n\r\n  uint256  public feeForOne;\r\n  uint256 public feeForTen;\r\n\r\n\r\n\r\n\r\n  function gacha (uint seed,string memory from) public payable  {\r\n     require( msg.value >= feeForOne );\r\n     uint blockNo;\r\n     string memory key;\r\n     uint[] memory equips;\r\n     (blockNo,  key,  equips)  = this.getRandomEquipment(seed );\r\n   //  spIns.createEquip(msg.sender,key,equips,extraProps);\r\n   emit Draw(key);\r\n     //return back\r\n    _incrCurrentEquipCnt(key);\r\n\r\n\r\n     //return back\r\n     msg.sender.transfer(msg.value.sub(feeForOne));\r\n\r\n     //give recommend reward\r\n     address payable recommendAddress = address(uint160(_getRecommendAddress(from)));\r\n     if(recommendAddress != address(0)) {\r\n       recommendAddress.transfer( feeForOne.mul(recommendRatio).div(10000));\r\n     }\r\n\r\n  }\r\n\r\n  function gacha10 (uint seed,string memory from) public payable  {\r\n     require( msg.value >= feeForTen );\r\n     uint blockNo;\r\n     string memory key;\r\n     uint[] memory equips;\r\n     for (uint i=0 ;i<10;++i) {\r\n      (blockNo,  key,  equips)  = this.getRandomEquipment(seed+i );\r\n     // spIns.createEquip(msg.sender,key,equips,extraProps);\r\n      _incrCurrentEquipCnt(key);\r\n      emit Draw(key);\r\n\r\n     }\r\n     //return back\r\n    // msg.sender.transfer(msg.value.sub(feeForTen));\r\n\r\n     //give recommend reward\r\n     address payable recommendAddress = address(uint160(_getRecommendAddress(from)));\r\n     if(recommendAddress != address(0)) {\r\n       recommendAddress.transfer( feeForTen.mul(recommendRatio).div(10000));\r\n     }\r\n  }\r\n\r\n  function withdraw( address payable to )  public onlyOwner{\r\n    require(to == msg.sender); //to == msg.sender == _owner\r\n    to.transfer((address(this).balance ));\r\n  }\r\n}\r\n\r\n// File: contracts/eth_superplayer_nft.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract EquipGeneratorWhitelist is Ownable {\r\n  mapping(address => string) public whitelist;\r\n  mapping(string => address)  cat2address;\r\n\r\n  event WhitelistedAddressAdded(address addr,string category);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier canGenerate() {\r\n    //require(keccak256(whitelist[msg.sender]) == keccak256(category));\r\n    require(bytes(whitelist[msg.sender]).length >0 );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr,string memory category) onlyOwner internal returns(bool success) {\r\n    require( bytes(category).length > 0 );\r\n    if (bytes(whitelist[addr]).length == 0) {\r\n      require( cat2address[category] == address(0));\r\n      whitelist[addr] = category;\r\n      emit WhitelistedAddressAdded(addr,category);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    string storage category = whitelist[addr];\r\n    if (bytes(category).length != 0) {\r\n      delete cat2address[category] ;\r\n      delete whitelist[addr]  ;\r\n      emit WhitelistedAddressRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract SuperplayerEquipmentInterface {\r\n  function createEquip(address to, string memory key, uint[] memory randomProps )  public returns(uint256);\r\n}\r\n\r\ncontract SuperplayerRandomEquipmentInterface {\r\n  function getRandomEquipment(uint256 seed) public view returns(uint blockNo,string memory ekey,uint[] memory randomProps) ;\r\n}\r\n\r\n   \r\ncontract SuperplayerEquipmentV001 is EquipGeneratorWhitelist,ERC721 ,ERC721Metadata(\"SuperPlayerEquipment\",\"SPE\") {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  enum EquipmentPart {Weapon ,Head,Coat,Pants ,Shoes ,Bag}\r\n  enum EquipmentRareness {Blue,Purple, Orange,Red }\r\n\r\n  struct Equipment {\r\n    string key; //using key to contains part and rareness format : rareness_part_name\r\n//    EquipmentPart part;\r\n //   EquipmentRareness rareness;\r\n    uint[] randomProperties;\r\n    uint[] advancedProperties; //for equipment enhance\r\n  }\r\n\r\n\r\n\r\n  event Birth(address where,uint256 tokenId , string key,  uint[] randomProps);\r\n  event GetAdvancedProperties(address where,uint256 tokenId,uint[] advancedProps);\r\n\r\n\r\n  mapping (uint256 => uint256) private typeLimitsMap;\r\n  mapping (uint256 => uint256) private typeCurrCntMap;\r\n\r\n  uint256 TotalEquipNum; // for ERC721\r\n\r\n\r\n  Equipment[] private equips;\r\n\r\n  constructor() public{\r\n\r\n  }\r\n\r\n  function totalSupply() public view returns (uint) {\r\n    return TotalEquipNum;\r\n  }\r\n\r\n  function addEquipmentGenerator(address addr, string memory category) onlyOwner public returns(bool success){\r\n    return addAddressToWhitelist(addr,category);\r\n  }\r\n\r\n  function removeEquipmentGenerator(address addr) onlyOwner public returns(bool success){\r\n    return removeAddressFromWhitelist(addr);\r\n  }\r\n\r\n  function setLimit(string memory key, uint256 limit) onlyOwner public {\r\n    uint256 uintkey =  uint256(keccak256(abi.encodePacked(bytes(key))));\r\n    //only can set once\r\n    require( typeLimitsMap[uintkey] == uint256(0) ) ;\r\n    typeLimitsMap[ uintkey ] = limit;\r\n  }\r\n\r\n  function setLimits(uint256[] memory uintkeys, uint256[] memory limits) onlyOwner public {\r\n    require(uintkeys.length == limits.length);\r\n    uint len = uintkeys.length;\r\n    for (uint i = 0;i < len ; i++){\r\n    //only can set once\r\n      uint256 uintkey = uintkeys[i];\r\n      if( typeLimitsMap[ uintkey]  == 0 ) {\r\n        typeLimitsMap[ uintkey ] = limits[i];\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  function getLimit(string memory key)  public view returns(uint256 current, uint256 limit){\r\n    uint256 uintkey = uint256(keccak256(abi.encodePacked(bytes(key))));\r\n    current = typeCurrCntMap[uintkey];\r\n    limit = typeLimitsMap[uintkey];\r\n  }\r\n\r\n  /*\r\n   * This privilege should transfer to the community nodes ,but as the beginning,our team control it for game's quickly  iteration\r\n   */\r\n  function createEquip(address to, string memory key, uint[] memory randomProps) canGenerate public returns(uint256){\r\n    uint256 uintkey =  uint256(keccak256(abi.encodePacked(bytes(key))));\r\n    uint256 currentTypCnt = typeCurrCntMap[uintkey]; \r\n\r\n    // limit checkt\r\n    require(currentTypCnt < typeLimitsMap[uintkey]) ;\r\n\r\n    uint[] memory emptyProps = new uint[](0); \r\n    Equipment memory newEquip = Equipment({\r\n      key : key,\r\n      randomProperties : randomProps,\r\n      advancedProperties : emptyProps\r\n    });\r\n    TotalEquipNum = TotalEquipNum.add(1);\r\n    uint256 newEquipId = equips.push(newEquip).sub(1);\r\n    emit Birth(msg.sender,newEquipId,key,randomProps);\r\n    _mint(to,newEquipId);\r\n\r\n    typeCurrCntMap[uintkey] =  currentTypCnt + 1;\r\n\r\n    return newEquipId;\r\n  }\r\n\r\n\r\n  function accquireAdvancedProps(uint256 tokenId,uint[] memory advancedProps) canGenerate public  {\r\n    require(tokenId < TotalEquipNum );\r\n    require( _isApprovedOrOwner( msg.sender,tokenId));\r\n    Equipment storage equip = equips[tokenId];\r\n    equip.advancedProperties = advancedProps;\r\n  }\r\n\r\n  function getEquip(uint256 idx) public view returns(\r\n    string memory key,\r\n    uint[] memory randomProps,\r\n    uint[] memory advancedProperties\r\n  ){\r\n      require(idx < TotalEquipNum);\r\n      Equipment storage equip = equips[idx];\r\n      key = equip.key;\r\n      randomProps = equip.randomProperties;\r\n      advancedProperties = equip.advancedProperties;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n * \r\n */\r\n\r\n// File: contracts/eth_superplayer_v001.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SuperplayerRandomValueV001 is SuperplayerRandomValueBase {\r\n\r\n  // config\r\n  function initRtables1() public  onlyOwner{\r\n    _initRtables1();\r\n  }\r\n  function initRtables2() public  onlyOwner{\r\n    _initRtables2();\r\n  }\r\n  function initRtables3() public  onlyOwner{\r\n    _initRtables3();\r\n  }\r\n\r\n\r\n\r\n  function _initRtables1 () internal {\r\n\r\nuint[] memory v112 = new uint[](7);\r\nuint[] memory w112  = new uint[](7);\r\nv112[0]= 1001; w112[0]=40;\r\nv112[1]= 1005; w112[1]=10;\r\nv112[2]= 1006; w112[2]=10;\r\nv112[3]= 1008; w112[3]=10;\r\nv112[4]= 1009; w112[4]=10;\r\nv112[5]= 1010; w112[5]=10;\r\nv112[6]= 1007; w112[6]=10;\r\n_addRandomValuesforRTable(112,v112,w112);\r\n\r\nuint[] memory v144 = new uint[](7);\r\nuint[] memory w144  = new uint[](7);\r\nv144[0]= 1001; w144[0]=15;\r\nv144[1]= 1005; w144[1]=5;\r\nv144[2]= 1006; w144[2]=5;\r\nv144[3]= 1008; w144[3]=5;\r\nv144[4]= 1009; w144[4]=5;\r\nv144[5]= 1010; w144[5]=60;\r\nv144[6]= 1007; w144[6]=5;\r\n_addRandomValuesforRTable(144,v144,w144);\r\n\r\nuint[] memory v243 = new uint[](8);\r\nuint[] memory w243  = new uint[](8);\r\nv243[0]= 2002; w243[0]=12;\r\nv243[1]= 2003; w243[1]=8;\r\nv243[2]= 2004; w243[2]=5;\r\nv243[3]= 2001; w243[3]=13;\r\nv243[4]= 2008; w243[4]=6;\r\nv243[5]= 2007; w243[5]=6;\r\nv243[6]= 2005; w243[6]=30;\r\nv243[7]= 2006; w243[7]=20;\r\n_addRandomValuesforRTable(243,v243,w243);\r\n\r\nuint[] memory v114 = new uint[](7);\r\nuint[] memory w114  = new uint[](7);\r\nv114[0]= 1001; w114[0]=30;\r\nv114[1]= 1005; w114[1]=10;\r\nv114[2]= 1006; w114[2]=10;\r\nv114[3]= 1008; w114[3]=10;\r\nv114[4]= 1009; w114[4]=10;\r\nv114[5]= 1010; w114[5]=20;\r\nv114[6]= 1007; w114[6]=10;\r\n_addRandomValuesforRTable(114,v114,w114);\r\n\r\nuint[] memory v121 = new uint[](6);\r\nuint[] memory w121  = new uint[](6);\r\nv121[0]= 1001; w121[0]=14;\r\nv121[1]= 1002; w121[1]=40;\r\nv121[2]= 1003; w121[2]=10;\r\nv121[3]= 1008; w121[3]=12;\r\nv121[4]= 1009; w121[4]=12;\r\nv121[5]= 1010; w121[5]=12;\r\n_addRandomValuesforRTable(121,v121,w121);\r\n\r\nuint[] memory v123 = new uint[](7);\r\nuint[] memory w123  = new uint[](7);\r\nv123[0]= 1001; w123[0]=30;\r\nv123[1]= 1005; w123[1]=10;\r\nv123[2]= 1006; w123[2]=10;\r\nv123[3]= 1008; w123[3]=13;\r\nv123[4]= 1009; w123[4]=12;\r\nv123[5]= 1010; w123[5]=13;\r\nv123[6]= 1007; w123[6]=12;\r\n_addRandomValuesforRTable(123,v123,w123);\r\n\r\nuint[] memory v132 = new uint[](7);\r\nuint[] memory w132  = new uint[](7);\r\nv132[0]= 1001; w132[0]=50;\r\nv132[1]= 1005; w132[1]=9;\r\nv132[2]= 1006; w132[2]=9;\r\nv132[3]= 1008; w132[3]=8;\r\nv132[4]= 1009; w132[4]=8;\r\nv132[5]= 1010; w132[5]=8;\r\nv132[6]= 1007; w132[6]=8;\r\n_addRandomValuesforRTable(132,v132,w132);\r\n\r\nuint[] memory v244 = new uint[](7);\r\nuint[] memory w244  = new uint[](7);\r\nv244[0]= 2002; w244[0]=12;\r\nv244[1]= 2003; w244[1]=8;\r\nv244[2]= 2004; w244[2]=5;\r\nv244[3]= 2001; w244[3]=15;\r\nv244[4]= 2008; w244[4]=10;\r\nv244[5]= 2007; w244[5]=10;\r\nv244[6]= 2010; w244[6]=40;\r\n_addRandomValuesforRTable(244,v244,w244);\r\n\r\nuint[] memory v212 = new uint[](8);\r\nuint[] memory w212  = new uint[](8);\r\nv212[0]= 2002; w212[0]=30;\r\nv212[1]= 2003; w212[1]=10;\r\nv212[2]= 2004; w212[2]=10;\r\nv212[3]= 2001; w212[3]=30;\r\nv212[4]= 2008; w212[4]=5;\r\nv212[5]= 2007; w212[5]=5;\r\nv212[6]= 2009; w212[6]=5;\r\nv212[7]= 2005; w212[7]=5;\r\n_addRandomValuesforRTable(212,v212,w212);\r\n\r\nuint[] memory v145 = new uint[](7);\r\nuint[] memory w145  = new uint[](7);\r\nv145[0]= 1001; w145[0]=15;\r\nv145[1]= 1005; w145[1]=5;\r\nv145[2]= 1006; w145[2]=5;\r\nv145[3]= 1008; w145[3]=5;\r\nv145[4]= 1009; w145[4]=60;\r\nv145[5]= 1010; w145[5]=5;\r\nv145[6]= 1007; w145[6]=5;\r\n_addRandomValuesforRTable(145,v145,w145);\r\n\r\n  }\r\n\r\n  function _initRtables2 () internal {\r\n\r\n\r\nuint[] memory v221 = new uint[](6);\r\nuint[] memory w221  = new uint[](6);\r\nv221[0]= 2002; w221[0]=35;\r\nv221[1]= 2003; w221[1]=12;\r\nv221[2]= 2004; w221[2]=13;\r\nv221[3]= 2001; w221[3]=20;\r\nv221[4]= 2008; w221[4]=10;\r\nv221[5]= 2007; w221[5]=10;\r\n_addRandomValuesforRTable(221,v221,w221);\r\n\r\nuint[] memory v232 = new uint[](8);\r\nuint[] memory w232  = new uint[](8);\r\nv232[0]= 2002; w232[0]=15;\r\nv232[1]= 2003; w232[1]=8;\r\nv232[2]= 2004; w232[2]=7;\r\nv232[3]= 2001; w232[3]=34;\r\nv232[4]= 2008; w232[4]=9;\r\nv232[5]= 2007; w232[5]=9;\r\nv232[6]= 2009; w232[6]=9;\r\nv232[7]= 2005; w232[7]=9;\r\n_addRandomValuesforRTable(232,v232,w232);\r\n\r\nuint[] memory v242 = new uint[](8);\r\nuint[] memory w242  = new uint[](8);\r\nv242[0]= 2002; w242[0]=12;\r\nv242[1]= 2003; w242[1]=8;\r\nv242[2]= 2004; w242[2]=5;\r\nv242[3]= 2001; w242[3]=35;\r\nv242[4]= 2008; w242[4]=10;\r\nv242[5]= 2007; w242[5]=10;\r\nv242[6]= 2009; w242[6]=10;\r\nv242[7]= 2005; w242[7]=10;\r\n_addRandomValuesforRTable(242,v242,w242);\r\n\r\nuint[] memory v124 = new uint[](7);\r\nuint[] memory w124  = new uint[](7);\r\nv124[0]= 1001; w124[0]=30;\r\nv124[1]= 1005; w124[1]=10;\r\nv124[2]= 1006; w124[2]=10;\r\nv124[3]= 1008; w124[3]=10;\r\nv124[4]= 1009; w124[4]=10;\r\nv124[5]= 1010; w124[5]=20;\r\nv124[6]= 1007; w124[6]=10;\r\n_addRandomValuesforRTable(124,v124,w124);\r\n\r\nuint[] memory v131 = new uint[](6);\r\nuint[] memory w131  = new uint[](6);\r\nv131[0]= 1001; w131[0]=10;\r\nv131[1]= 1002; w131[1]=40;\r\nv131[2]= 1002; w131[2]=20;\r\nv131[3]= 1008; w131[3]=10;\r\nv131[4]= 1009; w131[4]=10;\r\nv131[5]= 1010; w131[5]=10;\r\n_addRandomValuesforRTable(131,v131,w131);\r\n\r\nuint[] memory v135 = new uint[](7);\r\nuint[] memory w135  = new uint[](7);\r\nv135[0]= 1001; w135[0]=20;\r\nv135[1]= 1005; w135[1]=8;\r\nv135[2]= 1006; w135[2]=8;\r\nv135[3]= 1008; w135[3]=8;\r\nv135[4]= 1009; w135[4]=40;\r\nv135[5]= 1010; w135[5]=8;\r\nv135[6]= 1007; w135[6]=8;\r\n_addRandomValuesforRTable(135,v135,w135);\r\n\r\nuint[] memory v231 = new uint[](6);\r\nuint[] memory w231  = new uint[](6);\r\nv231[0]= 2002; w231[0]=40;\r\nv231[1]= 2003; w231[1]=15;\r\nv231[2]= 2004; w231[2]=15;\r\nv231[3]= 2001; w231[3]=15;\r\nv231[4]= 2008; w231[4]=7;\r\nv231[5]= 2007; w231[5]=8;\r\n_addRandomValuesforRTable(231,v231,w231);\r\n\r\nuint[] memory v141 = new uint[](6);\r\nuint[] memory w141  = new uint[](6);\r\nv141[0]= 1001; w141[0]=10;\r\nv141[1]= 1002; w141[1]=45;\r\nv141[2]= 1002; w141[2]=25;\r\nv141[3]= 1008; w141[3]=7;\r\nv141[4]= 1009; w141[4]=7;\r\nv141[5]= 1010; w141[5]=6;\r\n_addRandomValuesforRTable(141,v141,w141);\r\n\r\nuint[] memory v142 = new uint[](7);\r\nuint[] memory w142  = new uint[](7);\r\nv142[0]= 1001; w142[0]=60;\r\nv142[1]= 1005; w142[1]=7;\r\nv142[2]= 1006; w142[2]=7;\r\nv142[3]= 1008; w142[3]=7;\r\nv142[4]= 1009; w142[4]=7;\r\nv142[5]= 1010; w142[5]=6;\r\nv142[6]= 1007; w142[6]=6;\r\n_addRandomValuesforRTable(142,v142,w142);\r\n\r\nuint[] memory v111 = new uint[](6);\r\nuint[] memory w111  = new uint[](6);\r\nv111[0]= 1001; w111[0]=14;\r\nv111[1]= 1002; w111[1]=40;\r\nv111[2]= 1003; w111[2]=10;\r\nv111[3]= 1008; w111[3]=12;\r\nv111[4]= 1009; w111[4]=12;\r\nv111[5]= 1010; w111[5]=12;\r\n_addRandomValuesforRTable(111,v111,w111);\r\n\r\n  }\r\n\r\n  function _initRtables3 () internal {\r\n\r\n\r\nuint[] memory v113 = new uint[](7);\r\nuint[] memory w113  = new uint[](7);\r\nv113[0]= 1001; w113[0]=30;\r\nv113[1]= 1005; w113[1]=10;\r\nv113[2]= 1006; w113[2]=10;\r\nv113[3]= 1008; w113[3]=13;\r\nv113[4]= 1009; w113[4]=12;\r\nv113[5]= 1010; w113[5]=13;\r\nv113[6]= 1007; w113[6]=12;\r\n_addRandomValuesforRTable(113,v113,w113);\r\n\r\nuint[] memory v115 = new uint[](7);\r\nuint[] memory w115  = new uint[](7);\r\nv115[0]= 1001; w115[0]=30;\r\nv115[1]= 1005; w115[1]=10;\r\nv115[2]= 1006; w115[2]=10;\r\nv115[3]= 1008; w115[3]=20;\r\nv115[4]= 1009; w115[4]=10;\r\nv115[5]= 1010; w115[5]=10;\r\nv115[6]= 1007; w115[6]=10;\r\n_addRandomValuesforRTable(115,v115,w115);\r\n\r\nuint[] memory v222 = new uint[](8);\r\nuint[] memory w222  = new uint[](8);\r\nv222[0]= 2002; w222[0]=20;\r\nv222[1]= 2003; w222[1]=10;\r\nv222[2]= 2004; w222[2]=10;\r\nv222[3]= 2001; w222[3]=32;\r\nv222[4]= 2008; w222[4]=7;\r\nv222[5]= 2007; w222[5]=7;\r\nv222[6]= 2009; w222[6]=7;\r\nv222[7]= 2005; w222[7]=7;\r\n_addRandomValuesforRTable(222,v222,w222);\r\n\r\nuint[] memory v245 = new uint[](7);\r\nuint[] memory w245  = new uint[](7);\r\nv245[0]= 2002; w245[0]=12;\r\nv245[1]= 2003; w245[1]=8;\r\nv245[2]= 2004; w245[2]=5;\r\nv245[3]= 2001; w245[3]=15;\r\nv245[4]= 2008; w245[4]=10;\r\nv245[5]= 2007; w245[5]=10;\r\nv245[6]= 2009; w245[6]=40;\r\n_addRandomValuesforRTable(245,v245,w245);\r\n\r\nuint[] memory v133 = new uint[](7);\r\nuint[] memory w133  = new uint[](7);\r\nv133[0]= 1001; w133[0]=8;\r\nv133[1]= 1005; w133[1]=40;\r\nv133[2]= 1006; w133[2]=20;\r\nv133[3]= 1008; w133[3]=8;\r\nv133[4]= 1009; w133[4]=8;\r\nv133[5]= 1010; w133[5]=8;\r\nv133[6]= 1007; w133[6]=8;\r\n_addRandomValuesforRTable(133,v133,w133);\r\n\r\nuint[] memory v134 = new uint[](7);\r\nuint[] memory w134  = new uint[](7);\r\nv134[0]= 1001; w134[0]=20;\r\nv134[1]= 1005; w134[1]=8;\r\nv134[2]= 1006; w134[2]=8;\r\nv134[3]= 1008; w134[3]=8;\r\nv134[4]= 1009; w134[4]=8;\r\nv134[5]= 1010; w134[5]=40;\r\nv134[6]= 1007; w134[6]=8;\r\n_addRandomValuesforRTable(134,v134,w134);\r\n\r\nuint[] memory v241 = new uint[](6);\r\nuint[] memory w241  = new uint[](6);\r\nv241[0]= 2002; w241[0]=50;\r\nv241[1]= 2003; w241[1]=15;\r\nv241[2]= 2004; w241[2]=15;\r\nv241[3]= 2001; w241[3]=10;\r\nv241[4]= 2008; w241[4]=5;\r\nv241[5]= 2007; w241[5]=5;\r\n_addRandomValuesforRTable(241,v241,w241);\r\n\r\nuint[] memory v122 = new uint[](7);\r\nuint[] memory w122  = new uint[](7);\r\nv122[0]= 1001; w122[0]=40;\r\nv122[1]= 1005; w122[1]=10;\r\nv122[2]= 1006; w122[2]=10;\r\nv122[3]= 1008; w122[3]=10;\r\nv122[4]= 1009; w122[4]=10;\r\nv122[5]= 1010; w122[5]=10;\r\nv122[6]= 1007; w122[6]=1;\r\n_addRandomValuesforRTable(122,v122,w122);\r\n\r\nuint[] memory v125 = new uint[](7);\r\nuint[] memory w125  = new uint[](7);\r\nv125[0]= 1001; w125[0]=30;\r\nv125[1]= 1005; w125[1]=10;\r\nv125[2]= 1006; w125[2]=10;\r\nv125[3]= 1008; w125[3]=20;\r\nv125[4]= 1009; w125[4]=10;\r\nv125[5]= 1010; w125[5]=10;\r\nv125[6]= 1007; w125[6]=10;\r\n_addRandomValuesforRTable(125,v125,w125);\r\n\r\nuint[] memory v211 = new uint[](6);\r\nuint[] memory w211  = new uint[](6);\r\nv211[0]= 2002; w211[0]=30;\r\nv211[1]= 2003; w211[1]=10;\r\nv211[2]= 2004; w211[2]=10;\r\nv211[3]= 2001; w211[3]=30;\r\nv211[4]= 2008; w211[4]=10;\r\nv211[5]= 2007; w211[5]=10;\r\n_addRandomValuesforRTable(211,v211,w211);\r\n\r\nuint[] memory v143 = new uint[](7);\r\nuint[] memory w143  = new uint[](7);\r\nv143[0]= 1001; w143[0]=8;\r\nv143[1]= 1005; w143[1]=45;\r\nv143[2]= 1006; w143[2]=25;\r\nv143[3]= 1008; w143[3]=6;\r\nv143[4]= 1009; w143[4]=6;\r\nv143[5]= 1010; w143[5]=5;\r\nv143[6]= 1007; w143[6]=5;\r\n_addRandomValuesforRTable(143,v143,w143);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract SuperplayerRandomEquipmentV001  is SuperplayerRandomEquipmentBase{\r\n\r\n\r\n  constructor(address insRandomBuffAddr) SuperplayerRandomEquipmentBase(insRandomBuffAddr) public{\r\n\r\n  }\r\n\r\n\r\n\r\n  function initEquipmentPools() public  onlyOwner{\r\n    _initEquipmentPools();\r\n  }\r\n\r\n  function _initEquipmentPools () internal {\r\n\r\n\r\nuint[] memory ppurple_shoes_range_nft = new uint[](6);\r\nppurple_shoes_range_nft[0] = 244;\r\nppurple_shoes_range_nft[1] = 244;\r\nppurple_shoes_range_nft[2] = 244;\r\nppurple_shoes_range_nft[3] = 244;\r\nppurple_shoes_range_nft[4] = 244;\r\nppurple_shoes_range_nft[5] = 244;\r\n_addEquipToPool(\"purple_shoes_range_nft\",ppurple_shoes_range_nft,2300,40);\r\n\r\n\r\nuint[] memory pblue_weapon_gun_gray_shotgun = new uint[](4);\r\npblue_weapon_gun_gray_shotgun[0] = 131;\r\npblue_weapon_gun_gray_shotgun[1] = 131;\r\npblue_weapon_gun_gray_shotgun[2] = 131;\r\npblue_weapon_gun_gray_shotgun[3] = 131;\r\n_addEquipToPool(\"blue_weapon_gun_gray_shotgun\",pblue_weapon_gun_gray_shotgun,5000,100);\r\n\r\n\r\nuint[] memory pblue_leg_hp = new uint[](5);\r\npblue_leg_hp[0] = 231;\r\npblue_leg_hp[1] = 231;\r\npblue_leg_hp[2] = 231;\r\npblue_leg_hp[3] = 231;\r\npblue_leg_hp[4] = 231;\r\n_addEquipToPool(\"blue_leg_hp\",pblue_leg_hp,10000,200);\r\n\r\n\r\nuint[] memory ppurple_weapon_gun_catapult_auto_eth = new uint[](5);\r\nppurple_weapon_gun_catapult_auto_eth[0] = 142;\r\nppurple_weapon_gun_catapult_auto_eth[1] = 142;\r\nppurple_weapon_gun_catapult_auto_eth[2] = 142;\r\nppurple_weapon_gun_catapult_auto_eth[3] = 142;\r\nppurple_weapon_gun_catapult_auto_eth[4] = 142;\r\n_addEquipToPool(\"purple_weapon_gun_catapult_auto_eth\",ppurple_weapon_gun_catapult_auto_eth,1000,20);\r\n\r\n\r\nuint[] memory pblue_weapongun_gun_sniper_laser = new uint[](4);\r\npblue_weapongun_gun_sniper_laser[0] = 134;\r\npblue_weapongun_gun_sniper_laser[1] = 134;\r\npblue_weapongun_gun_sniper_laser[2] = 134;\r\npblue_weapongun_gun_sniper_laser[3] = 134;\r\n_addEquipToPool(\"blue_weapongun_gun_sniper_laser\",pblue_weapongun_gun_sniper_laser,5000,100);\r\n\r\n\r\nuint[] memory pblue_weapongun_gun_black_hand = new uint[](4);\r\npblue_weapongun_gun_black_hand[0] = 135;\r\npblue_weapongun_gun_black_hand[1] = 135;\r\npblue_weapongun_gun_black_hand[2] = 135;\r\npblue_weapongun_gun_black_hand[3] = 135;\r\n_addEquipToPool(\"blue_weapongun_gun_black_hand\",pblue_weapongun_gun_black_hand,5000,100);\r\n\r\n\r\nuint[] memory pblue_leg_damage = new uint[](5);\r\npblue_leg_damage[0] = 232;\r\npblue_leg_damage[1] = 232;\r\npblue_leg_damage[2] = 232;\r\npblue_leg_damage[3] = 232;\r\npblue_leg_damage[4] = 232;\r\n_addEquipToPool(\"blue_leg_damage\",pblue_leg_damage,10000,200);\r\n\r\n\r\nuint[] memory pblue_helmet_hp = new uint[](5);\r\npblue_helmet_hp[0] = 231;\r\npblue_helmet_hp[1] = 231;\r\npblue_helmet_hp[2] = 231;\r\npblue_helmet_hp[3] = 231;\r\npblue_helmet_hp[4] = 231;\r\n_addEquipToPool(\"blue_helmet_hp\",pblue_helmet_hp,10000,200);\r\n\r\n\r\nuint[] memory pblue_helmet_damage = new uint[](5);\r\npblue_helmet_damage[0] = 232;\r\npblue_helmet_damage[1] = 232;\r\npblue_helmet_damage[2] = 232;\r\npblue_helmet_damage[3] = 232;\r\npblue_helmet_damage[4] = 232;\r\n_addEquipToPool(\"blue_helmet_damage\",pblue_helmet_damage,10000,200);\r\n\r\n\r\nuint[] memory ppurple_body_crit_nft = new uint[](6);\r\nppurple_body_crit_nft[0] = 243;\r\nppurple_body_crit_nft[1] = 243;\r\nppurple_body_crit_nft[2] = 243;\r\nppurple_body_crit_nft[3] = 243;\r\nppurple_body_crit_nft[4] = 243;\r\nppurple_body_crit_nft[5] = 243;\r\n_addEquipToPool(\"purple_body_crit_nft\",ppurple_body_crit_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_shoes_crit_nft = new uint[](6);\r\nppurple_shoes_crit_nft[0] = 243;\r\nppurple_shoes_crit_nft[1] = 243;\r\nppurple_shoes_crit_nft[2] = 243;\r\nppurple_shoes_crit_nft[3] = 243;\r\nppurple_shoes_crit_nft[4] = 243;\r\nppurple_shoes_crit_nft[5] = 243;\r\n_addEquipToPool(\"purple_shoes_crit_nft\",ppurple_shoes_crit_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_leg_range_nft = new uint[](6);\r\nppurple_leg_range_nft[0] = 244;\r\nppurple_leg_range_nft[1] = 244;\r\nppurple_leg_range_nft[2] = 244;\r\nppurple_leg_range_nft[3] = 244;\r\nppurple_leg_range_nft[4] = 244;\r\nppurple_leg_range_nft[5] = 244;\r\n_addEquipToPool(\"purple_leg_range_nft\",ppurple_leg_range_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_body_hp_nft = new uint[](6);\r\nppurple_body_hp_nft[0] = 241;\r\nppurple_body_hp_nft[1] = 241;\r\nppurple_body_hp_nft[2] = 241;\r\nppurple_body_hp_nft[3] = 241;\r\nppurple_body_hp_nft[4] = 241;\r\nppurple_body_hp_nft[5] = 241;\r\n_addEquipToPool(\"purple_body_hp_nft\",ppurple_body_hp_nft,2300,40);\r\n\r\n\r\nuint[] memory pblue_weapon_gun_gray_sniper = new uint[](4);\r\npblue_weapon_gun_gray_sniper[0] = 133;\r\npblue_weapon_gun_gray_sniper[1] = 133;\r\npblue_weapon_gun_gray_sniper[2] = 133;\r\npblue_weapon_gun_gray_sniper[3] = 133;\r\n_addEquipToPool(\"blue_weapon_gun_gray_sniper\",pblue_weapon_gun_gray_sniper,5000,100);\r\n\r\n\r\nuint[] memory pblue_shoes_damage = new uint[](5);\r\npblue_shoes_damage[0] = 232;\r\npblue_shoes_damage[1] = 232;\r\npblue_shoes_damage[2] = 232;\r\npblue_shoes_damage[3] = 232;\r\npblue_shoes_damage[4] = 232;\r\n_addEquipToPool(\"blue_shoes_damage\",pblue_shoes_damage,10000,200);\r\n\r\n\r\nuint[] memory pblue_body_hp = new uint[](5);\r\npblue_body_hp[0] = 231;\r\npblue_body_hp[1] = 231;\r\npblue_body_hp[2] = 231;\r\npblue_body_hp[3] = 231;\r\npblue_body_hp[4] = 231;\r\n_addEquipToPool(\"blue_body_hp\",pblue_body_hp,10000,200);\r\n\r\n\r\nuint[] memory pblue_shoes_hp = new uint[](5);\r\npblue_shoes_hp[0] = 231;\r\npblue_shoes_hp[1] = 231;\r\npblue_shoes_hp[2] = 231;\r\npblue_shoes_hp[3] = 231;\r\npblue_shoes_hp[4] = 231;\r\n_addEquipToPool(\"blue_shoes_hp\",pblue_shoes_hp,10000,200);\r\n\r\n\r\nuint[] memory ppurple_leg_hp_nft = new uint[](6);\r\nppurple_leg_hp_nft[0] = 241;\r\nppurple_leg_hp_nft[1] = 241;\r\nppurple_leg_hp_nft[2] = 241;\r\nppurple_leg_hp_nft[3] = 241;\r\nppurple_leg_hp_nft[4] = 241;\r\nppurple_leg_hp_nft[5] = 241;\r\n_addEquipToPool(\"purple_leg_hp_nft\",ppurple_leg_hp_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_shoes_hp_nft = new uint[](6);\r\nppurple_shoes_hp_nft[0] = 241;\r\nppurple_shoes_hp_nft[1] = 241;\r\nppurple_shoes_hp_nft[2] = 241;\r\nppurple_shoes_hp_nft[3] = 241;\r\nppurple_shoes_hp_nft[4] = 241;\r\nppurple_shoes_hp_nft[5] = 241;\r\n_addEquipToPool(\"purple_shoes_hp_nft\",ppurple_shoes_hp_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_leg_crit_nft = new uint[](6);\r\nppurple_leg_crit_nft[0] = 243;\r\nppurple_leg_crit_nft[1] = 243;\r\nppurple_leg_crit_nft[2] = 243;\r\nppurple_leg_crit_nft[3] = 243;\r\nppurple_leg_crit_nft[4] = 243;\r\nppurple_leg_crit_nft[5] = 243;\r\n_addEquipToPool(\"purple_leg_crit_nft\",ppurple_leg_crit_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_helmet_crit_nft = new uint[](6);\r\nppurple_helmet_crit_nft[0] = 243;\r\nppurple_helmet_crit_nft[1] = 243;\r\nppurple_helmet_crit_nft[2] = 243;\r\nppurple_helmet_crit_nft[3] = 243;\r\nppurple_helmet_crit_nft[4] = 243;\r\nppurple_helmet_crit_nft[5] = 243;\r\n_addEquipToPool(\"purple_helmet_crit_nft\",ppurple_helmet_crit_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_body_range_nft = new uint[](6);\r\nppurple_body_range_nft[0] = 244;\r\nppurple_body_range_nft[1] = 244;\r\nppurple_body_range_nft[2] = 244;\r\nppurple_body_range_nft[3] = 244;\r\nppurple_body_range_nft[4] = 244;\r\nppurple_body_range_nft[5] = 244;\r\n_addEquipToPool(\"purple_body_range_nft\",ppurple_body_range_nft,2300,40);\r\n\r\n\r\nuint[] memory pblue_body_damage = new uint[](5);\r\npblue_body_damage[0] = 232;\r\npblue_body_damage[1] = 232;\r\npblue_body_damage[2] = 232;\r\npblue_body_damage[3] = 232;\r\npblue_body_damage[4] = 232;\r\n_addEquipToPool(\"blue_body_damage\",pblue_body_damage,10000,200);\r\n\r\n\r\nuint[] memory ppurple_weapon_gun_fire_eth = new uint[](5);\r\nppurple_weapon_gun_fire_eth[0] = 141;\r\nppurple_weapon_gun_fire_eth[1] = 141;\r\nppurple_weapon_gun_fire_eth[2] = 141;\r\nppurple_weapon_gun_fire_eth[3] = 141;\r\nppurple_weapon_gun_fire_eth[4] = 141;\r\n_addEquipToPool(\"purple_weapon_gun_fire_eth\",ppurple_weapon_gun_fire_eth,1000,20);\r\n\r\n\r\nuint[] memory ppurple_helmet_hp_nft = new uint[](6);\r\nppurple_helmet_hp_nft[0] = 241;\r\nppurple_helmet_hp_nft[1] = 241;\r\nppurple_helmet_hp_nft[2] = 241;\r\nppurple_helmet_hp_nft[3] = 241;\r\nppurple_helmet_hp_nft[4] = 241;\r\nppurple_helmet_hp_nft[5] = 241;\r\n_addEquipToPool(\"purple_helmet_hp_nft\",ppurple_helmet_hp_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_helmet_range_nft = new uint[](6);\r\nppurple_helmet_range_nft[0] = 244;\r\nppurple_helmet_range_nft[1] = 244;\r\nppurple_helmet_range_nft[2] = 244;\r\nppurple_helmet_range_nft[3] = 244;\r\nppurple_helmet_range_nft[4] = 244;\r\nppurple_helmet_range_nft[5] = 244;\r\n_addEquipToPool(\"purple_helmet_range_nft\",ppurple_helmet_range_nft,2300,40);\r\n\r\n\r\nuint[] memory ppurple_weapon_gun_rocket_eth = new uint[](5);\r\nppurple_weapon_gun_rocket_eth[0] = 144;\r\nppurple_weapon_gun_rocket_eth[1] = 144;\r\nppurple_weapon_gun_rocket_eth[2] = 144;\r\nppurple_weapon_gun_rocket_eth[3] = 144;\r\nppurple_weapon_gun_rocket_eth[4] = 144;\r\n_addEquipToPool(\"purple_weapon_gun_rocket_eth\",ppurple_weapon_gun_rocket_eth,1000,20);\r\n\r\n\r\nuint[] memory pblue_weapon_gun_gray_auto = new uint[](4);\r\npblue_weapon_gun_gray_auto[0] = 132;\r\npblue_weapon_gun_gray_auto[1] = 132;\r\npblue_weapon_gun_gray_auto[2] = 132;\r\npblue_weapon_gun_gray_auto[3] = 132;\r\n_addEquipToPool(\"blue_weapon_gun_gray_auto\",pblue_weapon_gun_gray_auto,5000,100);\r\n\r\n\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\ncontract SuperPlayerGachaPresell  is SuperplayerRandomEquipmentV001 ,SuperPlayerGachaWithRecommendReward {\r\n\r\n  using SafeMath for uint256;\r\n  SuperplayerEquipmentInterface spIns;\r\n\r\n  uint256 recommendRatio = 3000; //base 10000\r\n\r\n  constructor(address equipAddr, address randomAddr) SuperplayerRandomEquipmentV001(randomAddr) public{\r\n    spIns = SuperplayerEquipmentInterface(equipAddr);\r\n\r\n    feeForOne = 66 finney ;\r\n    feeForTen = 594 finney;\r\n  }\r\n\r\n  uint256  public feeForOne;\r\n  uint256 public feeForTen;\r\n\r\n\r\n\r\n\r\n  function gacha (uint seed,string memory from) public payable  {\r\n     require( msg.value >= feeForOne );\r\n     uint blockNo;\r\n     string memory key;\r\n     uint[] memory equips;\r\n     (blockNo,  key,  equips)  = this.getRandomEquipment(seed );\r\n     _incrCurrentEquipCnt(key);\r\n     spIns.createEquip(msg.sender,key,equips);\r\n     //return back\r\n     msg.sender.transfer(msg.value.sub(feeForOne));\r\n     //give recommend reward\r\n     address payable recommendAddress = address(uint160(_getRecommendAddress(from)));\r\n     if(recommendAddress != address(0)) {\r\n       recommendAddress.transfer( feeForOne.mul(recommendRatio).div(10000));\r\n     }\r\n\r\n  }\r\n\r\n  function gacha10 (uint seed,string memory from) public payable  {\r\n     require( msg.value >= feeForTen );\r\n     uint blockNo;\r\n     string memory key;\r\n     uint[] memory equips;\r\n     for (uint i=0 ;i<10;++i) {\r\n      (blockNo,  key,  equips)  = this.getRandomEquipment(seed+i );\r\n      _incrCurrentEquipCnt(key);\r\n      spIns.createEquip(msg.sender,key,equips);\r\n     }\r\n     msg.sender.transfer(msg.value.sub(feeForTen));\r\n     //give recommend reward\r\n     address payable recommendAddress = address(uint160(_getRecommendAddress(from)));\r\n     if(recommendAddress != address(0)) {\r\n       recommendAddress.transfer( feeForTen.mul(recommendRatio).div(10000));\r\n     }\r\n  }\r\n\r\n\r\n  function withdraw( address payable to )  public onlyOwner{\r\n    require(to == msg.sender); //to == msg.sender == _owner\r\n    to.transfer((address(this).balance ));\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"initRtables3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keyid\",\"type\":\"uint256\"}],\"name\":\"getRandomValueConf\",\"outputs\":[{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"weights\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initRtables1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keyid\",\"type\":\"uint256\"},{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"weights\",\"type\":\"uint256[]\"}],\"name\":\"addRandomValuesforRTable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keyid\",\"type\":\"uint256\"},{\"name\":\"random\",\"type\":\"uint256\"}],\"name\":\"randomValue\",\"outputs\":[{\"name\":\"rv\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initRtables2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SuperplayerRandomValueV001","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://007e9d04f56e4f89ea928e24a0a1521fe505a7a28567ccffe859e25cbacb60c5"}]}