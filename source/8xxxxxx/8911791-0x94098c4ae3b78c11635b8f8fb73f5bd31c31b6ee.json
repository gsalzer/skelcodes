{"status":"1","message":"OK","result":[{"SourceCode":"{\"gameLib.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nlibrary gameLib{\\n\\n  enum mark { blank, pX, pO }\\n  struct game{\\n    address playerX;\\n    address playerO;\\n    uint bet;\\n    uint wager;\\n    uint turn;\\n    uint deadline;\\n    uint8 numMoves;\\n    mark[9] moves;    \\n  }\\n\\n  function join( game storage gm, address playerO, uint8 move) public returns (bool){\\n    gm.numMoves++;\\n    gm.deadline = block.timestamp + gm.turn;\\n    gm.moves[move] = mark.pO;\\n    gm.playerO = playerO;\\n    return true;\\n  }\\n\\n  function newMove( game storage gm, uint8 move) public returns (bool){\\n    gm.numMoves++;\\n    gm.moves[move] = mark( 2 - ( gm.numMoves % 2 ) );\\n    gm.deadline = block.timestamp + gm.turn;\\n    return true;\\n  }\\n\\n  function isWin( game storage gm ) public view returns( bool ){\\n    if( gm.numMoves \\u003c 5 ) return false;\\n\\n    mark player = mark( 2 - ( gm.numMoves % 2 ) );\\n    if( ((gm.moves[0] == player) \\u0026\\u0026 (gm.moves[3] == player) \\u0026\\u0026 (gm.moves[6] == player) )\\n      ||((gm.moves[1] == player) \\u0026\\u0026 (gm.moves[4] == player) \\u0026\\u0026 (gm.moves[7] == player) ) \\n      ||((gm.moves[2] == player) \\u0026\\u0026 (gm.moves[5] == player) \\u0026\\u0026 (gm.moves[8] == player) ) \\n      ||((gm.moves[0] == player) \\u0026\\u0026 (gm.moves[1] == player) \\u0026\\u0026 (gm.moves[2] == player) )\\n      ||((gm.moves[3] == player) \\u0026\\u0026 (gm.moves[4] == player) \\u0026\\u0026 (gm.moves[5] == player) )\\n      ||((gm.moves[6] == player) \\u0026\\u0026 (gm.moves[7] == player) \\u0026\\u0026 (gm.moves[8] == player) )\\n      ||((gm.moves[0] == player) \\u0026\\u0026 (gm.moves[4] == player) \\u0026\\u0026 (gm.moves[8] == player) )\\n      ||((gm.moves[2] == player) \\u0026\\u0026 (gm.moves[4] == player) \\u0026\\u0026 (gm.moves[6] == player) ) \\n      ) return true;\\n    return false;\\n  }\\n\\n  function isOver( game storage gm ) public view returns(bool){\\n    return 8 \\u003c gm.numMoves;\\n  }\\n\\n  function isPlayerTurn( game storage gm, address player ) public view returns(bool){\\n    return (gm.numMoves % 2 == 0 \\u0026\\u0026 player == gm.playerX )\\n            || (gm.numMoves % 2 == 1 \\u0026\\u0026 player == gm.playerO );\\n  }\\n\\n  function isTimeout( game storage gm ) public view returns(bool){\\n    return (1 \\u003c gm.numMoves) \\u0026\\u0026 (gm.deadline \\u003c block.timestamp);\\n  }\\n\\n  function isValidMove( game storage gm, uint8 move ) public view returns(bool){\\n    return move \\u003c 9 \\u0026\\u0026 gm.moves[move] == mark.blank;\\n  }\\n\\n  function isValidGame( game storage gm ) public view returns(bool){\\n    return 0 \\u003c gm.turn;\\n  }\\n\\n  function end( game storage gm, uint8 code) public{\\n    gm.turn = 0;\\n    gm.deadline = code;\\n  }\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"tictactoeth.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./gameLib.sol\\\";\\n\\ncontract tictactoeth is Ownable{\\n\\n  uint public fees;\\n  function collectFees() external onlyOwner(){\\n    owner().transfer( fees );\\n    fees = 0;\\n  }\\n  uint constant feeDivisor = 100;\\n  uint constant minBet = 100;\\n  uint constant minTurn = 280; // approx. 5 minutes\\n  uint constant maxTurn = 864020; // approx. 10 days \\n\\n  uint public numGames;\\n  gameLib.game[] public games;\\n  using gameLib for gameLib.game;\\n  event gameEvent(\\n      uint indexed id\\n  );\\n  modifier validGame(uint id){\\n    require( games[id].isValidGame() );\\n    _;\\n  }\\n  modifier playerTurn(uint id){\\n    require( games[id].isPlayerTurn(msg.sender) );\\n    _;\\n  }\\n  modifier validMove(uint id, uint8 move){\\n    require( games[id].isValidMove(move) );\\n    _;\\n  }\\n  function getMoves(uint id) external view returns (uint8[9] moves){\\n    for(uint8 i=0; i \\u003c 9; i++){\\n      moves[i] = uint8( games[id].moves[i] );\\n    }\\n  }\\n\\n  function newGame( uint wager, uint turn, uint8 move ) payable external returns( uint ){\\n    require( minBet \\u003c msg.value ); \\n    require( minBet \\u003c wager );\\n    require( minTurn \\u003c turn \\u0026\\u0026 turn \\u003c maxTurn );\\n    require( move \\u003c 9 );\\n\\n    gameLib.mark[9] memory moves;\\n    moves[move]=gameLib.mark.pX;\\n\\n    games.push( gameLib.game( msg.sender, 0, msg.value, wager, turn, 0, 1, moves ) );\\n    numGames++;\\n    emit gameEvent( numGames - 1 );\\n    return( numGames - 1 );\\n  }\\n\\n  function cancelGame(uint id) external validGame(id) returns (bool){\\n    require( 1 == games[id].numMoves \\u0026\\u0026 msg.sender == games[id].playerX );\\n    return endGame( id, 0 );\\n  }\\n\\n  function joinGame( uint id, uint8 move ) payable external validGame(id) validMove(id,move) returns (bool){\\n    require( 1 == games[id].numMoves \\u0026\\u0026 games[id].wager \\u003c= msg.value );\\n\\n    require( games[id].join( msg.sender, move ) );\\n    emit gameEvent( id );\\n\\n    if( games[id].wager \\u003c msg.value ) msg.sender.transfer( msg.value - games[id].wager );\\n    return true;\\n  }\\n\\n  function newMove( uint id, uint8 move ) external validGame(id) validMove(id,move) playerTurn(id) returns(bool){\\n    if( games[id].isTimeout() ) return endGame(id,3);\\n\\n    require( games[id].newMove( move ) );\\n\\n    if( games[id].isWin() ) return endGame(id,1);\\n    else if( games[id].isOver() ) return endGame(id,2);\\n\\n    emit gameEvent(id);\\n    return true;\\n  }\\n\\n  function endGame(uint id, uint8 code) private returns (bool){\\n    uint vig;\\n    uint payX;\\n    uint payO;\\n    gameLib.game memory gm = games[id];\\n\\n    if(code==0){ // Cancel\\n      payX = gm.bet; \\n    }\\n    else if(code==1){ // Win\\n      if( gm.numMoves % 2 == 1 ) payX = gm.bet + gm.wager;\\n      else payO = gm.bet + gm.wager;\\n    }\\n    else if(code==2){ //  Stalemate\\n      vig = (gm.bet / feeDivisor) + (gm.wager / feeDivisor);\\n      payX = gm.bet - (gm.bet / feeDivisor);\\n      payO = gm.wager - (gm.wager / feeDivisor); \\n    }\\n    else if(code==3){ // Timeout\\n      vig = (gm.bet + gm.wager) / feeDivisor;\\n      if( gm.numMoves % 2 == 1 ) payX = gm.bet + gm.wager - vig;\\n      else payO = gm.bet + gm.wager - vig;\\n    }\\n\\n    games[id].end(code); \\n    fees += vig;\\n    gm.playerX.transfer(payX);\\n    gm.playerO.transfer(payO);\\n    emit gameEvent(id);\\n    return true;\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"}],\"name\":\"isWin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"},{\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"newMove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"},{\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"isValidMove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"}],\"name\":\"isOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"},{\"name\":\"playerO\",\"type\":\"address\"},{\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"join\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"}],\"name\":\"isValidGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"},{\"name\":\"code\",\"type\":\"uint8\"}],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"isPlayerTurn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gm\",\"type\":\"gameLib.game storage\"}],\"name\":\"isTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"gameLib","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://1db8d7cdb359c6990c18e439bd1cba57b54f30a396ee9593a1b3d6c4b1e7eaa2"}]}