{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-07-19\r\n*/\r\n\r\npragma solidity ^0.5.7;\r\n\r\n// File: contracts/AllocationToken/IAllocationToken.sol\r\n\r\n/**\r\n@title IAllocationToken\r\n@notice This contract provides an interface for AllocationToken\r\n */\r\ncontract IAllocationToken {\r\n    /**\r\n    @dev fired on exchange contract's updation\r\n    @param exchangeContract the address of exchange contract\r\n     */\r\n    event ExchangeContractUpdated(address exchangeContract);\r\n\r\n    /**\r\n    @dev fired on investment contract's updation\r\n    @param investmentContract the address of investment contract\r\n     */\r\n    event InvestmentContractUpdated(address investmentContract);\r\n\r\n    /**\r\n    @dev updates exchange contract's address\r\n    @param _exchangeContract the address of updated exchange contract\r\n     */\r\n    function updateExchangeContract(address _exchangeContract) external;\r\n\r\n    /**\r\n    @dev updates the investment contract's address\r\n    @param _investmentContract the address of updated innvestment contract\r\n     */\r\n    function updateInvestmentContract(address _investmentContract) external;\r\n\r\n    /**\r\n    @notice Allows to mint new AT tokens\r\n    @dev Only owner or exchange contract can call this function\r\n    @param _holder The address to mint the tokens to\r\n    @param _tokens The amount of tokens to mint\r\n     */\r\n    function mint(address _holder, uint256 _tokens) public;\r\n\r\n    /**\r\n    @notice Allows to burn AT tokens\r\n    @dev Only Investment contract contract can call this function\r\n    @param _address The address to burn the tokens from\r\n    @param _value The amount of tokens to burn\r\n    */\r\n    function burn(address _address, uint256 _value) public;\r\n}\r\n\r\n// File: contracts/Ownable/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/Math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/KYC/IKYC.sol\r\n\r\n/// @title IKYC\r\n/// @notice This contract represents interface for KYC contract\r\ncontract IKYC {\r\n    // Fired after the status for a manager is updated\r\n    event ManagerStatusUpdated(address KYCManager, bool managerStatus);\r\n\r\n    // Fired after the status for a user is updated\r\n    event UserStatusUpdated(address user, bool status);\r\n\r\n    /// @notice Sets status for a manager\r\n    /// @param KYCManager The address of manager for which the status is to be updated\r\n    /// @param managerStatus The status for the manager\r\n    /// @return status of the transaction\r\n    function setKYCManagerStatus(address KYCManager, bool managerStatus)\r\n        public\r\n        returns (bool);\r\n\r\n    /// @notice Sets status for a user\r\n    /// @param userAddress The address of user for which the status is to be updated\r\n    /// @param passedKYC The status for the user\r\n    /// @return status of the transaction\r\n    function setUserAddressStatus(address userAddress, bool passedKYC)\r\n        public\r\n        returns (bool);\r\n\r\n    /// @notice returns the status of a user\r\n    /// @param userAddress The address of user for which the status is to be returned\r\n    /// @return status of the user\r\n    function getAddressStatus(address userAddress) public view returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/ERC20/IERC20.sol\r\n\r\ncontract IERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address tokenOwner)\r\n        public\r\n        view\r\n        returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender)\r\n        public\r\n        view\r\n        returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n    function approve(address spender, uint256 tokens)\r\n        public\r\n        returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens)\r\n        public\r\n        returns (bool success);\r\n    function mint(address account, uint256 amount) public returns (bool);\r\n    function burn(address account, uint256 amount) public;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(\r\n        address indexed tokenOwner,\r\n        address indexed spender,\r\n        uint256 tokens\r\n    );\r\n}\r\n\r\n// File: contracts/Exchange/Exchange/IExchange.sol\r\n\r\n/**\r\n@title IExchange\r\n@dev This contract represents an Interface to Exchange contract\r\n */\r\ncontract IExchange {\r\n   \r\n    /**\r\n    @dev fired on allocationToken rate set\r\n     */\r\n    event AllocationTokenRateSet(uint256 rate);\r\n\r\n    /**\r\n    @dev fired on exchange state change\r\n    */\r\n    event StateChanged(uint256 state);\r\n\r\n    /**\r\n    @dev fired on exchange of tokenns\r\n     */\r\n    event TokensExchanged(\r\n        uint256 _operationId,\r\n        address userAddress,\r\n        address erc20Token,\r\n        address allocationToken,\r\n        uint256 erc20Tokens,\r\n        uint256 allocationTokens\r\n    );\r\n\r\n    /**\r\n    @notice function exchanges chellecoin tokens to allocation tokens\r\n    @param tokens the amount of chellecoin tokens to be exchanged for allocation tokens\r\n     */\r\n    function exchange(uint256 tokens) public returns (bool);\r\n\r\n     /**\r\n    @notice this function sets/changes state of this smart contract and only exchange manager/owner can call it\r\n    @param state it can be either 0 (Inactive) or 1 (Active)\r\n     */\r\n    function setState(uint256 state) external;\r\n\r\n    /**\r\n    @dev it updates  update exchange rate of ERC-20 tokens to AT tokens\r\n    @param  _allocationTokensPerErc20Token the exchange rate\r\n    */\r\n    function setExchangeRate(uint256 _allocationTokensPerErc20Token)\r\n        external;\r\n    \r\n    /**\r\n    @notice function to get the current state of the exchange contract\r\n    @return current state\r\n    */\r\n    function getCurrentState() public view returns (uint256);\r\n\r\n\r\n}\r\n\r\n// File: contracts/Exchange/Exchange/Exchange.sol\r\n\r\n/**\r\n@notice Exchange smart contract for ChelleCoin to AllocationTokens\r\n */\r\ncontract Exchange is IExchange, Ownable {\r\n    enum State {INACTIVE, ACTIVE}\r\n\r\n    IERC20 public erc20Token; // address of ERC-20 token allowed to be exchanged.\r\n    IAllocationToken public allocationToken; // address of Allocation Token Smart Contract.\r\n    IKYC public kyc; // KYC contract\r\n\r\n    uint256 public allocationTokensPerErc20Token; // exchange rate of ERC-20 tokens to AT tokens.\r\n\r\n    State exchangeState; // current state of the exchange contract\r\n\r\n    /**\r\n    @dev constructor for the Exchange contract\r\n    @param _erc20Token address of ERC-20 token allowed to be exchanged.\r\n    @param _allocationToken address of Allocation Token Smart Contract.\r\n    @param _allocationTokensPerErc20Token exchange rate of ERC-20 tokens to AT tokens.\r\n     */\r\n    constructor(\r\n        IERC20 _erc20Token,\r\n        IAllocationToken _allocationToken,\r\n        IKYC _kyc,\r\n        uint256 _allocationTokensPerErc20Token\r\n    ) public {\r\n        erc20Token = _erc20Token;\r\n        allocationToken = _allocationToken;\r\n        allocationTokensPerErc20Token = _allocationTokensPerErc20Token;\r\n        kyc = _kyc;\r\n\r\n        exchangeState = State.ACTIVE;\r\n\r\n        emit AllocationTokenRateSet(allocationTokensPerErc20Token);\r\n        emit StateChanged(uint256(exchangeState));\r\n    }\r\n\r\n    /**\r\n    @notice call is only allowed to pass when exchange is in ACTIVE state\r\n     */\r\n    modifier isStateActive() {\r\n        require(exchangeState == State.ACTIVE, \"Exchange state is INACTIVE.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice function exchanges chellecoin tokens to allocation tokens\r\n    @param tokens the amount of chellecoin tokens to be exchanged for allocation tokens\r\n     */\r\n    function exchange(uint256 tokens) public isStateActive returns (bool) {\r\n        require(tokens > 0, \"tokens amount is not valid.\");\r\n        require(\r\n            kyc.getAddressStatus(msg.sender),\r\n            \"msg.sender is not whiteliisted in KYC\"\r\n        );\r\n\r\n        uint256 AT_tokens_to_mint = calculateAllocationTokens(tokens);\r\n\r\n        require(\r\n            erc20Token.transferFrom(msg.sender, address(0x0), tokens),\r\n            \"transferFrom failed.\"\r\n        );\r\n        allocationToken.mint(msg.sender, AT_tokens_to_mint);\r\n\r\n        emit TokensExchanged(\r\n            0,\r\n            msg.sender,\r\n            address(erc20Token),\r\n            address(allocationToken),\r\n            tokens,\r\n            AT_tokens_to_mint\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice this function sets/changes state of this smart contract and only exchange manager/owner can call it\r\n    @param state it can be either 0 (Inactive) or 1 (Active)\r\n     */\r\n    function setState(uint256 state) external onlyOwner {\r\n        require(state == 0 || state == 1, \"Provided state is invalid.\");\r\n        require(\r\n            state != uint256(exchangeState),\r\n            \"Provided state is already set.\"\r\n        );\r\n\r\n        exchangeState = State(state);\r\n        emit StateChanged(uint256(exchangeState));\r\n    }\r\n\r\n    /**\r\n    @dev it updates  update exchange rate of ERC-20 tokens to AT tokens\r\n    @param  _allocationTokensPerErc20Token the exchange rate\r\n    */\r\n    function setExchangeRate(uint256 _allocationTokensPerErc20Token)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _allocationTokensPerErc20Token > 0,\r\n            \"_allocationTokensPerErc20Token should be greater than 0.\"\r\n        );\r\n\r\n        allocationTokensPerErc20Token = _allocationTokensPerErc20Token;\r\n        emit AllocationTokenRateSet(allocationTokensPerErc20Token);\r\n    }\r\n\r\n    /**\r\n    @notice function to get the current state of the exchange contract\r\n    @return current state\r\n    */\r\n    function getCurrentState() public view returns (uint256) {\r\n        return uint256(exchangeState);\r\n    }\r\n\r\n    /**\r\n    @dev an internal function to calculate allocation rate\r\n    @param tokens the amount of chellecoin tokens\r\n     */\r\n    function calculateAllocationTokens(uint256 tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tokens * allocationTokensPerErc20Token;\r\n    }\r\n}\r\n\r\n// File: contracts/Exchange/ExchangeWithManualApproval/IExchangeWithManualApproval.sol\r\n\r\n/**\r\n@title IExchangeWithManualApproval\r\n@dev This contract represents an Interface to ExchangeWithManualApproval contract\r\n */\r\ncontract IExchangeWithManualApproval {\r\n    /**\r\n    @notice fire when an approver's state is changed\r\n     */\r\n    event ApproverStateChanged(bool newState);\r\n\r\n     /**\r\n    @notice fired when an approval is requested\r\n     */\r\n    event ManualApprovalRequired(\r\n        uint256 exchangeOperationId,\r\n        uint256 tokensAmountToExchange\r\n    );\r\n\r\n    /**\r\n    @notice fired when an exchange operation is approved\r\n     */\r\n    event ExchangeOperationApproved(uint256 exchangeOperationid, bool approved);\r\n\r\n\r\n    /**\r\n    @notice function is called to change the state of an approver\r\n    @param approver the address of approver to which the state is changed\r\n    @param newState the state of the approver\r\n     */\r\n    function changeApproverState(address approver, bool newState)\r\n        external;\r\n\r\n    function confirmExchangeOperation(\r\n        uint256 exchangeOperationId,\r\n        bool status,\r\n        uint256 purchasedTokens,\r\n        uint256 bountyTokens\r\n    ) external;\r\n\r\n    /**\r\n    @notice get an exchange operation by its ID\r\n    @param  exchangeOperationId the ID of exchange operation\r\n    @return the address of receiver\r\n    @return the amount of chelle tokens\r\n    @return the amoount of AT tokens\r\n    @return the state of this particular operation\r\n     */\r\n    function getExchangeOperationByID(uint256 exchangeOperationId)\r\n        public\r\n        view\r\n        returns (address, uint256, uint256, uint8);\r\n}\r\n\r\n// File: contracts/Exchange/ExchangeWithManualApproval/ExchangeWithManualApproval.sol\r\n\r\n/**\r\n@notice Contract inherits the exchange contract and implements mannager functionality\r\n */\r\ncontract ExchangeWithManualApproval is IExchangeWithManualApproval, Exchange {\r\n    mapping(address => bool) public approvers; // mapping is used to store managers addresses that are allowed to approve or decline exchange operation.\r\n\r\n    uint256 public exchangeOperationsCount = 0; //number of exchange operations registered in contract.\r\n\r\n    enum OperationState {PENDING, ACCEPTED, DISCARDED} // state of an operation\r\n\r\n    struct ExchangeOperation {\r\n        address receiver; // address who would be receiving the exchanged AT tokens\r\n        uint256 chelleTokensAmount; // amount of chelle tokens that are up for exchange\r\n        uint256 ATTokensAmount; // amount of AT tokens exchanged\r\n        OperationState state; // state of the operation\r\n    }\r\n\r\n    mapping(uint256 => ExchangeOperation) exchangeOperations; // mapping is used to store exchange operation info.\r\n\r\n    /**\r\n    @notice constructor of the contract\r\n     */\r\n    constructor(\r\n        IERC20 _erc20Token,\r\n        IAllocationToken _allocationToken,\r\n        IKYC _kyc,\r\n        uint256 _allocationTokensPerErc20Token\r\n    )\r\n        public\r\n        Exchange(\r\n            _erc20Token,\r\n            _allocationToken,\r\n            _kyc,\r\n            _allocationTokensPerErc20Token\r\n        )\r\n    {}\r\n\r\n    /**\r\n    @notice only approver should be able to pass this modifier\r\n     */\r\n    modifier onlyApprover() {\r\n        require(\r\n            approvers[msg.sender],\r\n            \"only an approver can call this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice function is called to change the state of an approver\r\n    @param approver the address of approver to which the state is changed\r\n    @param newState the state of the approver\r\n     */\r\n    function changeApproverState(address approver, bool newState)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(approver != address(0), \"approver address is not valid\");\r\n        require(\r\n            approvers[approver] != newState,\r\n            \"the provided approver's state is already set\"\r\n        );\r\n\r\n        approvers[approver] = newState;\r\n\r\n        emit ApproverStateChanged(newState);\r\n    }\r\n\r\n    /**\r\n    @notice function exchanges chellecoin tokens to allocation tokens\r\n    @param tokens the amount of chellecoin tokens to be exchanged for allocation tokens\r\n     */\r\n    function exchange(uint256 tokens) public isStateActive returns (bool) {\r\n        require(tokens > 0, \"tokens amount is not valid.\");\r\n        require(\r\n            kyc.getAddressStatus(msg.sender),\r\n            \"msg.sender is not whiteliisted in KYC\"\r\n        );\r\n\r\n        require(\r\n            erc20Token.transferFrom(msg.sender, address(this), tokens),\r\n            \"transferFrom failed\"\r\n        );\r\n\r\n        ExchangeOperation memory new_op = ExchangeOperation(\r\n            msg.sender,\r\n            tokens,\r\n            uint256(0),\r\n            OperationState.PENDING\r\n        );\r\n\r\n        exchangeOperationsCount = exchangeOperationsCount + 1;\r\n\r\n        exchangeOperations[exchangeOperationsCount] = new_op;\r\n\r\n        emit ManualApprovalRequired(exchangeOperationsCount, tokens);\r\n    }\r\n\r\n    /**\r\n    @notice fired when an exchange operation is approved\r\n     */\r\n    event ExchangeOperationApproved(uint256 exchangeOperationid, bool approved);\r\n\r\n    function confirmExchangeOperation(\r\n        uint256 exchangeOperationId,\r\n        bool status,\r\n        uint256 purchasedTokens,\r\n        uint256 bountyTokens\r\n    ) external onlyApprover {\r\n        require(exchangeOperationId > 0, \"operation Id is invalid\");\r\n\r\n        ExchangeOperation storage current_op = exchangeOperations[exchangeOperationId];\r\n        require(\r\n            current_op.state == OperationState.PENDING,\r\n            \"Operation is already completed\"\r\n        );\r\n\r\n        uint256 tokens = current_op.chelleTokensAmount;\r\n        address receiver = current_op.receiver;\r\n\r\n        if (status) {\r\n            uint256 AT_tokens_to_mint = calculateAllocationTokens(tokens);\r\n            current_op.state = OperationState.ACCEPTED;\r\n            current_op.ATTokensAmount = AT_tokens_to_mint;\r\n\r\n            require(\r\n                erc20Token.transfer(address(0), tokens),\r\n                \"transfer failed.\"\r\n            );\r\n            allocationToken.mint(receiver, AT_tokens_to_mint);\r\n        } else {\r\n            current_op.state = OperationState.DISCARDED;\r\n\r\n            require(\r\n                erc20Token.transfer(receiver, tokens),\r\n                \"ERC20 transfer was not successfull\"\r\n            );\r\n        }\r\n\r\n        emit ExchangeOperationApproved(exchangeOperationId, status);\r\n    }\r\n\r\n    /**\r\n    @notice get an exchange operation by its ID\r\n    @param  exchangeOperationId the ID of exchange operation\r\n    @return the address of receiver\r\n    @return the amount of chelle tokens\r\n    @return the amoount of AT tokens\r\n    @return the state of this particular operation\r\n     */\r\n    function getExchangeOperationByID(uint256 exchangeOperationId)\r\n        public\r\n        view\r\n        returns (address, uint256, uint256, uint8)\r\n    {\r\n        require(exchangeOperationId > 0, \"operation Id is invalid\");\r\n\r\n        ExchangeOperation memory op = exchangeOperations[exchangeOperationId];\r\n\r\n        return (\r\n            op.receiver,\r\n            op.chelleTokensAmount,\r\n            op.ATTokensAmount,\r\n            uint8(op.state)\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approver\",\"type\":\"address\"},{\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"changeApproverState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exchangeOperationId\",\"type\":\"uint256\"}],\"name\":\"getExchangeOperationByID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchangeOperationId\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"bool\"},{\"name\":\"purchasedTokens\",\"type\":\"uint256\"},{\"name\":\"bountyTokens\",\"type\":\"uint256\"}],\"name\":\"confirmExchangeOperation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20Token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationTokensPerErc20Token\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeOperationsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allocationTokensPerErc20Token\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_erc20Token\",\"type\":\"address\"},{\"name\":\"_allocationToken\",\"type\":\"address\"},{\"name\":\"_kyc\",\"type\":\"address\"},{\"name\":\"_allocationTokensPerErc20Token\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchangeOperationid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ExchangeOperationApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"AllocationTokenRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_operationId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allocationToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"erc20Tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"allocationTokens\",\"type\":\"uint256\"}],\"name\":\"TokensExchanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"ApproverStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchangeOperationId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensAmountToExchange\",\"type\":\"uint256\"}],\"name\":\"ManualApprovalRequired\",\"type\":\"event\"}]","ContractName":"ExchangeWithManualApproval","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008a793406d4e191e11286d0f9aaee2be2b22364a500000000000000000000000017652192a1f5b3fc0c9d332f23109ce19a6c7706000000000000000000000000d97234a022750fa2cde897d8653e7daaf53bbbf90000000000000000000000000000000000000000000000000000000000000003","Library":"","LicenseType":"None","SwarmSource":"bzzr://f7cc8ce3fa91317564ab7a2adf8c9ea1e760020f7adb9a46463d3981b4c27671"}]}