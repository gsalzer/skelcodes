{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\ncontract UserProfile is MultiSigTools, TokenClaimer{\r\n  struct UProfileData{\r\n    bool exists;\r\n    string name;\r\n    string email;\r\n    string avatar;\r\n    string intro;\r\n  }\r\n\r\n  mapping (address => UProfileData) public user_data;\r\n  uint public total_user_number;\r\n  uint public removed_user_number;\r\n\r\n  bool public on_service;\r\n\r\n  event AddUser(address _addr, string _name, string _email, string _avatar, string _intro);\r\n  event RemoveUser(address _addr);\r\n  event ChangeItem(address _addr, string _item, string _old, string _new);\r\n  event Pause();\r\n  event Unpause();\r\n\r\n\r\n  constructor(address _multisig) MultiSigTools(_multisig) public {\r\n    total_user_number = 0;\r\n    on_service = true;\r\n  }\r\n\r\n  function addUser(string memory _name,\r\n                  string memory _email,\r\n                  string memory _avatar,\r\n                  string memory _intro) public returns(bool){\r\n    require(on_service, \"not on service\");\r\n    require(!user_data[msg.sender].exists, \"already exist\");\r\n\r\n    UProfileData storage upd = user_data[msg.sender];\r\n    upd.name = _name;\r\n    upd.email = _email;\r\n    upd.avatar = _avatar;\r\n    upd.intro = _intro;\r\n    upd.exists = true;\r\n\r\n    emit AddUser(msg.sender, _name, _email, _avatar, _intro);\r\n    total_user_number += 1;\r\n    return true;\r\n  }\r\n\r\n  function removeUser() public returns(bool){\r\n    require(user_data[msg.sender].exists, \"not exist\");\r\n    emit RemoveUser(msg.sender);\r\n    delete user_data[msg.sender];\r\n    total_user_number -= 1;\r\n    removed_user_number += 1;\r\n    return true;\r\n  }\r\n\r\n  function changeName(string memory _name) public returns(bool){\r\n    require(on_service, \"not on service\");\r\n    require(user_data[msg.sender].exists, \"not exist\");\r\n    UProfileData storage upd = user_data[msg.sender];\r\n    string memory oldName = upd.name;\r\n    upd.name = _name;\r\n    emit ChangeItem(msg.sender, \"name\", oldName, _name);\r\n    return true;\r\n  }\r\n\r\n  function changeEmail(string memory _email) public returns(bool){\r\n    require(on_service, \"not on service\");\r\n    require(user_data[msg.sender].exists, \"not exist\");\r\n\r\n    UProfileData storage upd = user_data[msg.sender];\r\n    string memory oldEmail = upd.email;\r\n    upd.email= _email;\r\n    emit ChangeItem(msg.sender, \"email\", oldEmail, _email);\r\n    return true;\r\n  }\r\n  function changeAvatar(string memory _avatar) public returns(bool){\r\n    require(on_service, \"not on service\");\r\n    require(user_data[msg.sender].exists, \"not exist\");\r\n\r\n    UProfileData storage upd = user_data[msg.sender];\r\n    string memory oldAvatar = upd.avatar;\r\n    upd.avatar = _avatar;\r\n    emit ChangeItem(msg.sender, \"avatar\", oldAvatar, _avatar);\r\n    return true;\r\n  }\r\n  function changeIntro(string memory _intro) public returns(bool){\r\n    require(on_service, \"not on service\");\r\n    require(user_data[msg.sender].exists, \"not exist\");\r\n\r\n    UProfileData storage upd = user_data[msg.sender];\r\n    string memory oldIntro = upd.intro;\r\n    upd.intro= _intro;\r\n    emit ChangeItem(msg.sender, \"intro\", oldIntro, _intro);\r\n    return true;\r\n  }\r\n\r\n  function userExists(address _addr) public view returns(bool){\r\n    return user_data[_addr].exists;\r\n  }\r\n  function userInfo(address _addr) public view returns(string memory name, string memory email, string memory avatar, string memory intro){\r\n    require(user_data[_addr].exists, \"not exist\");\r\n    UProfileData storage upd = user_data[_addr];\r\n    return (upd.name, upd.email, upd.avatar, upd.intro);\r\n  }\r\n\r\n  function claimStdTokens(uint64 id, address _token, address payable to) public only_signer is_majority_sig(id, \"claimStdTokens\"){\r\n    _claimStdTokens(_token, to);\r\n  }\r\n  function pauseService(uint64 id) public only_signer is_majority_sig(id, \"pauseService\"){\r\n    on_service = false;\r\n    emit Pause();\r\n  }\r\n  function unpauseService(uint64 id) public only_signer is_majority_sig(id, \"unpauseService\"){\r\n    on_service = true;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract UserProfileFactory{\r\n  event NewUserProfileContract(address addr);\r\n\r\n  function createUserProfile(address _multisig) public returns(address addr){\r\n    UserProfile up = new UserProfile(_multisig);\r\n    emit NewUserProfileContract(address(up));\r\n    return address(up);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"name\":\"createUserProfile\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewUserProfileContract\",\"type\":\"event\"}]","ContractName":"UserProfileFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://1831d21b7fd64c556f14c6bbde203737c2e54630597f2974ad00c2cfa07512d0"}]}