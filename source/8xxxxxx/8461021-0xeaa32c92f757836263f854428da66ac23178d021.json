{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n    Corpocracy:\r\n    A collaborative and competitive game in which players are investors of one of two competing megacorporations.\r\n    Players earn ether by both acquiring businesses and by earning dividends.\r\n\r\n    Notes:\r\n        Administrators can:\r\n            - change the name of the contract and token\r\n            - change the referral PoS difficulty\r\n            - charge a 2.5% transaction fee\r\n\r\n        They CANNOT:\r\n            - disable withdrawals\r\n            - kill the contract\r\n            - change the price of tokens\r\n**/\r\n\r\ncontract Corpocracy {\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    modifier onlyInitializedPlayers() {\r\n        address _customerAddress = msg.sender;\r\n        require(players[_customerAddress].wasInitialized);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenHolders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDividendHolders() {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[_customerAddress]);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPrerelease(){\r\n        require(!isPrerelease);\r\n        _;\r\n    }\r\n\r\n    modifier prereleaseLock(uint256 _incomingEther){\r\n      if(isPrerelease && ((totalEtherBalance() - _incomingEther) <= PRERELEASE_QUOTA)){\r\n        require(\r\n          (players[msg.sender].totalEtherSpent + _incomingEther) <= PRERELEASE_MAX_PURCHASE\r\n        );\r\n      } else {\r\n        isPrerelease = false;\r\n      }\r\n      _;\r\n    }\r\n\r\n    /*=================================\r\n    =             EVENTS              =\r\n    =================================*/\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEther,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 etherEarned\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 etherWithdrawn\r\n    );\r\n\r\n    // ERC20\r\n    event onTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n    event onClaimedTokens(\r\n        address indexed customerAddress,\r\n        uint256 tokens\r\n    );\r\n\r\n    event onWorldNodeRaid(\r\n        address indexed customerAddress,\r\n        uint8 worldNodeId\r\n    );\r\n\r\n    event onWorldNodeOwnerReveal(\r\n        address indexed customerAddress,\r\n        uint256 raidId,\r\n        uint8 newOwnerId\r\n    );\r\n\r\n    event onPlayerChangedCorp(\r\n        address indexed customerAddress,\r\n        uint8 fromCorpId,\r\n        uint8 toCorpId\r\n    );\r\n\r\n    /*=================================\r\n    =             STRUCTS             =\r\n    =================================*/\r\n\r\n    struct Player {\r\n        address addr;\r\n        bool wasInitialized;\r\n        uint8 corpId;\r\n        uint256 tokenBalance;\r\n        uint256 referralBalance;\r\n        int256 payoutsTo;\r\n        uint256[4] raidIds;\r\n        uint256[4] raidStakes;\r\n        uint256 totalEtherSpent;\r\n    }\r\n\r\n    struct Corporation {\r\n        uint8 id;\r\n        uint8 mainNodeId;\r\n        uint8 totalValue;\r\n        uint256 profitsPerShare;\r\n        uint256 tokenSupply;\r\n    }\r\n\r\n    struct WorldNode {\r\n        uint8 id;\r\n        uint8 ownerId;\r\n        uint8 value;\r\n        bool isImmutable;\r\n    }\r\n\r\n    struct Raid {\r\n        uint256 id;\r\n        uint8 targetNodeId;\r\n        uint8 attackingCorpId;\r\n        bool wasSuccessful;\r\n        bool hasBeenRevealed;\r\n        uint256 defenderStakes;\r\n        uint256 attackerStakes;\r\n        uint256 endBlock;\r\n    }\r\n\r\n    /*=================================\r\n    =            CONSTANTS            =\r\n    =================================*/\r\n\r\n    uint8 constant public decimals = 18;\r\n\r\n    uint256 constant internal tokenPrice = 0.000001 ether;\r\n    uint256 constant internal magnitude = 2**64;\r\n\r\n    uint256 constant internal PRERELEASE_MAX_PURCHASE = 1 ether;\r\n    uint256 constant internal PRERELEASE_QUOTA = 20 ether;\r\n\r\n    uint8 constant internal TRANSACTION_FEE_DIVIDENDS = 100; // over 1000, ie 10%\r\n    uint8 constant internal TRANSACTION_FEE_REFERRAL = 200; // over 1000, ie 20%\r\n    uint8 constant internal TRANSACTION_FEE_DEV = 25; // over 1000, ie 2.5%\r\n\r\n    uint8 constant internal CORPORATIONS_COUNT = 2;\r\n    uint8 constant internal NODES_COUNT = 14;\r\n    uint8 constant internal PLAYER_SLOTS_COUNT = 4;\r\n\r\n    /*=================================\r\n     =          CONFIGURABLES         =\r\n     ================================*/\r\n\r\n    string public name = \"Corpocracy\";\r\n    string public symbol = \"CRP\";\r\n\r\n    uint256 public stakingRequirement = 1000e18;\r\n    uint256 public raidTimeLength = 12 hours;\r\n    uint256 public secondsPerBlock = 15 seconds;\r\n\r\n    bool public isPrerelease = true;\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    mapping(address => bool) public administrators;\r\n    uint256 public adminBalance = 0;\r\n\r\n    mapping(uint8 => WorldNode) public worldNodes;\r\n    mapping(uint8 => Corporation) public corporations;\r\n    mapping(uint256 => Raid) public raids;\r\n\r\n    mapping(address => Player) public players;\r\n\r\n    address private lastAttacker;\r\n\r\n    uint256[NODES_COUNT] public pendingRaidIds;\r\n    uint256 internal nextRaidId = 1;\r\n\r\n    /*================================\r\n    =        PUBLIC FUNCTIONS        =\r\n    ================================*/\r\n\r\n    /*\r\n    * -- ADMINISTRATOR ONLY FUNCTIONS --\r\n    */\r\n\r\n    function setAdministrator(address _identifier, bool _status)\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n\r\n    function setStakingRequirement(uint256 _amountOfTokens)\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        stakingRequirement = _amountOfTokens;\r\n    }\r\n\r\n    function setName(string memory _name)\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        name = _name;\r\n    }\r\n\r\n    function setSymbol(string memory _symbol)\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function setSecondsPerBlock(uint256 _seconds)\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        require(_seconds < raidTimeLength);\r\n        secondsPerBlock = _seconds;\r\n    }\r\n\r\n    function setIsPrerelease(bool value)\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        isPrerelease = value;\r\n    }\r\n\r\n    function withdrawAdminBalance()\r\n        public\r\n        onlyAdministrator()\r\n    {\r\n        require(adminBalance > 0);\r\n\r\n        address payable _customerAddress = msg.sender;\r\n        uint256 _balance = adminBalance;\r\n        adminBalance = 0;\r\n\r\n        _customerAddress.transfer(_balance);\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        address _ownerAddress = msg.sender;\r\n        administrators[_ownerAddress] = true;\r\n\r\n        // Create world locations and organizations\r\n\r\n        // Create the Corporations\r\n        corporations[0] = Corporation({id: 0, mainNodeId: 0, totalValue: 50, profitsPerShare: 0, tokenSupply: 0});\r\n        corporations[1] = Corporation({id: 1, mainNodeId: 1, totalValue: 50, profitsPerShare: 0, tokenSupply: 0});\r\n\r\n        // Create the Nodes\r\n        // Headquarters\r\n        worldNodes[0] = WorldNode({id: 0, ownerId: 0, value: 20, isImmutable: true});\r\n        worldNodes[1] = WorldNode({id: 1, ownerId: 1, value: 20, isImmutable: true});\r\n\r\n        // Companies\r\n        // Corporation A\r\n        worldNodes[2] =  WorldNode({id: 2, ownerId: 0, value: 5, isImmutable: false});\r\n        worldNodes[3] =  WorldNode({id: 3, ownerId: 0, value: 5, isImmutable: false});\r\n        worldNodes[4] =  WorldNode({id: 4, ownerId: 0, value: 5, isImmutable: false});\r\n        worldNodes[5] =  WorldNode({id: 5, ownerId: 0, value: 5, isImmutable: false});\r\n        worldNodes[6] =  WorldNode({id: 6, ownerId: 0, value: 5, isImmutable: false});\r\n        worldNodes[7] =  WorldNode({id: 7, ownerId: 0, value: 5, isImmutable: false});\r\n        // Corporation B\r\n        worldNodes[8] =  WorldNode({id: 8, ownerId: 1, value: 5, isImmutable: false});\r\n        worldNodes[9] =  WorldNode({id: 9, ownerId: 1, value: 5, isImmutable: false});\r\n        worldNodes[10] = WorldNode({id: 10, ownerId: 1, value: 5, isImmutable: false});\r\n        worldNodes[11] = WorldNode({id: 11, ownerId: 1, value: 5, isImmutable: false});\r\n        worldNodes[12] = WorldNode({id: 12, ownerId: 1, value: 5, isImmutable: false});\r\n        worldNodes[13] = WorldNode({id: 13, ownerId: 1, value: 5, isImmutable: false});\r\n    }\r\n\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --\r\n    */\r\n\r\n    function buy(address _referredBy)\r\n        public\r\n        payable\r\n    returns(uint256)\r\n    {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        purchaseTokens(msg.value, address(0));\r\n    }\r\n\r\n    function purchaseTokens(uint256 _incomingEther, address _referredBy)\r\n        internal\r\n        prereleaseLock(_incomingEther)\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        if (!players[_customerAddress].wasInitialized) {\r\n          initializePlayer(_customerAddress);\r\n        }\r\n\r\n        Player storage _player = players[_customerAddress];\r\n        Corporation storage _corp = corporations[_player.corpId];\r\n\r\n        uint256 _devTax = _safeMul(_incomingEther, TRANSACTION_FEE_DEV) / 1000;\r\n        uint256 _etherToWorld = _safeMul(_incomingEther, TRANSACTION_FEE_DIVIDENDS) / 1000;\r\n        uint256 _referralBonus = _safeMul(_etherToWorld, TRANSACTION_FEE_REFERRAL) / 1000;\r\n        uint256 _taxedEther = _safeSub(_incomingEther, _devTax + _etherToWorld);\r\n        uint256 _amountOfTokens = _etherToTokens(_taxedEther);\r\n        uint256 _totalTokenSupply = totalSupply();\r\n\r\n        require(_amountOfTokens > 0 && (_safeAdd(_totalTokenSupply, _amountOfTokens) > _totalTokenSupply));\r\n\r\n        _player.totalEtherSpent = _safeAdd(_player.totalEtherSpent, _incomingEther);\r\n        adminBalance = _safeAdd(adminBalance, _devTax);\r\n\r\n        if(\r\n          _referredBy != address(0) &&\r\n          _referredBy != _customerAddress &&\r\n          players[_referredBy].tokenBalance >= stakingRequirement\r\n        ){\r\n          _etherToWorld = _safeSub(_etherToWorld, _referralBonus);\r\n          players[_referredBy].referralBalance = _safeAdd(players[_referredBy].referralBalance, _referralBonus);\r\n        }\r\n\r\n        _corp.tokenSupply = _safeAdd(_corp.tokenSupply, _amountOfTokens);\r\n        _player.tokenBalance = _safeAdd(_player.tokenBalance, _amountOfTokens);\r\n        _player.payoutsTo += (int256) (_corp.profitsPerShare * _amountOfTokens);\r\n\r\n        updateProfitsPerShare(_etherToWorld * magnitude);\r\n\r\n        emit onTokenPurchase(_customerAddress, _incomingEther, _amountOfTokens, _referredBy);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    function sell(uint256 _amountOfTokens)\r\n        public\r\n        onlyInitializedPlayers()\r\n        onlyTokenHolders()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        Player storage _player = players[_customerAddress];\r\n        Corporation storage _corp = corporations[_player.corpId];\r\n\r\n        require(_player.tokenBalance >= _amountOfTokens);\r\n\r\n        uint256 _ether = _tokensToEther(_amountOfTokens);\r\n        uint256 _devTax = _safeMul(_ether, TRANSACTION_FEE_DEV) / 1000;\r\n        uint256 _etherToWorld = _safeMul(_ether, TRANSACTION_FEE_DIVIDENDS) / 1000;\r\n        uint256 _taxedEther = _safeSub(_ether, _devTax + _etherToWorld);\r\n\r\n        adminBalance = _safeAdd(adminBalance, _devTax);\r\n\r\n        _corp.tokenSupply = _safeSub(_corp.tokenSupply, _amountOfTokens);\r\n        _player.tokenBalance = _safeSub(_player.tokenBalance, _amountOfTokens);\r\n        _player.payoutsTo -= (int256) (_corp.profitsPerShare * _amountOfTokens + (_taxedEther * magnitude));\r\n\r\n        updateProfitsPerShare(_etherToWorld * magnitude);\r\n\r\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedEther);\r\n    }\r\n\r\n    function withdraw()\r\n        public\r\n        onlyInitializedPlayers()\r\n        onlyDividendHolders()\r\n    {\r\n        address payable _customerAddress = msg.sender;\r\n        Player storage _player = players[_customerAddress];\r\n        uint256 _dividends = dividendsOf(_customerAddress);\r\n\r\n        _player.payoutsTo += (int256) (_dividends * magnitude);\r\n\r\n        _dividends = _safeAdd(_dividends, _player.referralBalance);\r\n        _player.referralBalance = 0;\r\n\r\n        _customerAddress.transfer(_dividends);\r\n\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n\r\n    function revealWorldNodeOwnership(uint8 _nodeId)\r\n        public\r\n        onlyInitializedPlayers()\r\n        whenNotPrerelease()\r\n    {\r\n        require(_nodeId < NODES_COUNT);\r\n\r\n        address _customerAddress = msg.sender;\r\n        uint256 _raidId = pendingRaidIds[_nodeId];\r\n\r\n        require(_raidId > 0 && !raids[_raidId].hasBeenRevealed);\r\n        require(block.number >= raids[_raidId].endBlock);\r\n\r\n        Player storage _player = players[_customerAddress];\r\n        Raid storage _raid = raids[_raidId];\r\n        WorldNode storage _node = worldNodes[_nodeId];\r\n        uint256 _defenderStakes = _raid.defenderStakes;\r\n        uint256 _attackerStakes = _raid.attackerStakes;\r\n\r\n        if (_player.corpId == _raid.attackingCorpId) {\r\n            _attackerStakes = _safeAdd(_attackerStakes, _attackerStakes / 4);\r\n        } else {\r\n            _defenderStakes = _safeAdd(_defenderStakes, _defenderStakes / 4);\r\n        }\r\n\r\n        uint256 _totalStakes = _defenderStakes + _attackerStakes;\r\n        uint256 _winningStake = _random(_raid.endBlock, 1, _totalStakes);\r\n\r\n        _raid.hasBeenRevealed = true;\r\n        _raid.wasSuccessful = (_winningStake > _defenderStakes);\r\n\r\n        pendingRaidIds[_nodeId] = 0;\r\n\r\n        if (_raid.wasSuccessful) {\r\n          Corporation storage _originCorp = corporations[_node.ownerId];\r\n          Corporation storage _targetCorp = corporations[_raid.attackingCorpId];\r\n\r\n          _originCorp.totalValue = (uint8) (_safeSub(_originCorp.totalValue, _node.value));\r\n          _node.ownerId = _raid.attackingCorpId;\r\n          _targetCorp.totalValue = (uint8) (_safeAdd(_targetCorp.totalValue, _node.value));\r\n        }\r\n\r\n        emit onWorldNodeOwnerReveal(_customerAddress, _raidId, _node.ownerId);\r\n    }\r\n\r\n    function changePlayerCorporation(uint8 _toCorporationId)\r\n        public\r\n        onlyInitializedPlayers()\r\n        whenNotPrerelease()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        Player storage _player = players[_customerAddress];\r\n        uint8 _fromCorporationId = _player.corpId;\r\n\r\n        require(_toCorporationId < CORPORATIONS_COUNT);\r\n        require(_toCorporationId != _fromCorporationId);\r\n\r\n        bool _isRaiding = false;\r\n        for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++) {\r\n          _isRaiding = (_isRaiding || _player.raidIds[i] != 0);\r\n        }\r\n\r\n        require(!_isRaiding);\r\n\r\n        if(_player.tokenBalance > 0) {\r\n          sell(_player.tokenBalance);\r\n        }\r\n\r\n        withdraw();\r\n\r\n        _player.payoutsTo = 0;\r\n        _player.corpId = _toCorporationId;\r\n\r\n        emit onPlayerChangedCorp(_customerAddress, _fromCorporationId, _toCorporationId);\r\n    }\r\n\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        public\r\n        onlyInitializedPlayers()\r\n        onlyTokenHolders()\r\n        whenNotPrerelease()\r\n    returns(bool)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(_amountOfTokens <= players[_customerAddress].tokenBalance);\r\n\r\n        Player storage _fromPlayer = players[_customerAddress];\r\n        Player storage _toPlayer = players[_toAddress];\r\n\r\n        if (!_toPlayer.wasInitialized) {\r\n          initializePlayer(_toAddress);\r\n        }\r\n\r\n        Corporation storage _fromCorp = corporations[_fromPlayer.corpId];\r\n        Corporation storage _toCorp = corporations[_toPlayer.corpId];\r\n\r\n        if(myDividends(true) > 0) {\r\n          withdraw();\r\n        }\r\n\r\n        uint256 _devTax = _safeMul(_amountOfTokens, TRANSACTION_FEE_DEV) / 1000;\r\n        uint256 _tokenFee = _safeMul(_amountOfTokens, TRANSACTION_FEE_DIVIDENDS) / 1000;\r\n        uint256 _taxedTokens = _safeSub(_amountOfTokens, _devTax + _tokenFee);\r\n        uint256 _etherToWorld = _tokensToEther(_tokenFee);\r\n\r\n        adminBalance = _safeAdd(adminBalance, _tokensToEther(_devTax));\r\n\r\n        // exchange tokens\r\n        _fromPlayer.tokenBalance = _safeSub(_fromPlayer.tokenBalance, _amountOfTokens);\r\n        _fromCorp.tokenSupply = _safeSub(_fromCorp.tokenSupply, _amountOfTokens);\r\n        _toPlayer.tokenBalance = _safeAdd(_toPlayer.tokenBalance, _taxedTokens);\r\n        _toCorp.tokenSupply = _safeAdd(_toCorp.tokenSupply, _taxedTokens);\r\n\r\n        _fromPlayer.payoutsTo -= (int256) (_fromCorp.profitsPerShare * _amountOfTokens);\r\n        _toPlayer.payoutsTo += (int256) (_toCorp.profitsPerShare * _taxedTokens);\r\n\r\n        updateProfitsPerShare(_etherToWorld * magnitude);\r\n\r\n        emit onTransfer(_customerAddress, _toAddress, _taxedTokens);\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n    function raidWorldNode(uint8 _worldNodeId, uint256 _stakes)\r\n        public\r\n        onlyInitializedPlayers()\r\n        onlyTokenHolders()\r\n        whenNotPrerelease()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        Player storage _player = players[_customerAddress];\r\n        Corporation storage _playerCorp = corporations[_player.corpId];\r\n\r\n        require(_stakes > 0 && _player.tokenBalance >= _stakes);\r\n        require(_worldNodeId < NODES_COUNT);\r\n        require(worldNodes[_worldNodeId].isImmutable == false);\r\n        require(_player.corpId != worldNodes[_worldNodeId].ownerId);\r\n\r\n        if (pendingRaidIds[_worldNodeId] != 0) {\r\n          require(block.number < raids[pendingRaidIds[_worldNodeId]].endBlock);\r\n        }\r\n\r\n        uint8 _raidSlot = getAvailableInvestmentSlot(_customerAddress, _worldNodeId);\r\n        require(_raidSlot < PLAYER_SLOTS_COUNT);\r\n\r\n        _playerCorp.tokenSupply = _safeSub(_playerCorp.tokenSupply, _stakes);\r\n        _player.tokenBalance = _safeSub(_player.tokenBalance, _stakes);\r\n        _player.payoutsTo -= (int256) (_playerCorp.profitsPerShare * _stakes);\r\n\r\n        // create a new raid if necessary\r\n        if (pendingRaidIds[_worldNodeId] == 0) {\r\n          Raid memory _newRaid = Raid({\r\n            id: nextRaidId,\r\n            targetNodeId: _worldNodeId,\r\n            attackingCorpId: _player.corpId,\r\n            wasSuccessful: false,\r\n            hasBeenRevealed: false,\r\n            defenderStakes: 0,\r\n            attackerStakes: 0,\r\n            endBlock: (raidTimeLength / secondsPerBlock) + block.number\r\n          });\r\n\r\n          raids[_newRaid.id] = _newRaid;\r\n          pendingRaidIds[_worldNodeId] = _newRaid.id;\r\n\r\n          nextRaidId++;\r\n        }\r\n\r\n        Raid storage _raid = raids[pendingRaidIds[_worldNodeId]];\r\n\r\n        _raid.attackerStakes = _safeAdd(_raid.attackerStakes, _stakes);\r\n        _player.raidIds[_raidSlot] = _raid.id;\r\n        _player.raidStakes[_raidSlot] = _safeAdd(_player.raidStakes[_raidSlot], _stakes);\r\n\r\n        lastAttacker = _customerAddress;\r\n\r\n        emit onWorldNodeRaid(_customerAddress, _worldNodeId);\r\n    }\r\n\r\n    function defendWorldNode(uint8 _worldNodeId, uint256 _stakes)\r\n        public\r\n        onlyInitializedPlayers()\r\n        onlyTokenHolders()\r\n        whenNotPrerelease()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        Player storage _player = players[_customerAddress];\r\n        Corporation storage _playerCorp = corporations[_player.corpId];\r\n\r\n        require(_stakes > 0 && _player.tokenBalance >= _stakes);\r\n        require(_worldNodeId < NODES_COUNT);\r\n        require(pendingRaidIds[_worldNodeId] != 0);\r\n        require(_player.corpId == worldNodes[_worldNodeId].ownerId);\r\n        require(block.number < raids[pendingRaidIds[_worldNodeId]].endBlock);\r\n\r\n        uint8 _raidSlot = getAvailableInvestmentSlot(_customerAddress, _worldNodeId);\r\n        require(_raidSlot < PLAYER_SLOTS_COUNT);\r\n\r\n        _playerCorp.tokenSupply = _safeSub(_playerCorp.tokenSupply, _stakes);\r\n        _player.tokenBalance = _safeSub(_player.tokenBalance, _stakes);\r\n        _player.payoutsTo -= (int256) (_playerCorp.profitsPerShare * _stakes);\r\n\r\n        Raid storage _raid = raids[pendingRaidIds[_worldNodeId]];\r\n\r\n        _raid.defenderStakes = _safeAdd(_raid.defenderStakes, _stakes);\r\n        _player.raidIds[_raidSlot] = _raid.id;\r\n        _player.raidStakes[_raidSlot] = _safeAdd(_player.raidStakes[_raidSlot], _stakes);\r\n\r\n        emit onWorldNodeRaid(_customerAddress, _worldNodeId);\r\n    }\r\n\r\n    function claimRaidTokens()\r\n        public\r\n        onlyInitializedPlayers()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        Player storage _player = players[_customerAddress];\r\n        Corporation storage _corp = corporations[_player.corpId];\r\n\r\n        uint256 _raidId = 0;\r\n        uint256 _totalPrize = 0;\r\n        uint256 _playerPrize = 0;\r\n        uint256 _tokensToAdd = 0;\r\n\r\n        for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++) {\r\n          _raidId = _player.raidIds[i];\r\n\r\n          if (_raidId > 0 && raids[_raidId].hasBeenRevealed) {\r\n            if (_player.corpId == raids[_raidId].attackingCorpId) {\r\n                if (raids[_raidId].wasSuccessful) {\r\n                  _totalPrize = raids[_raidId].defenderStakes / 4;\r\n                  _playerPrize = _totalPrize * (_player.raidStakes[i] / raids[_raidId].attackerStakes);\r\n                  _tokensToAdd = _safeAdd(_player.raidStakes[i], _playerPrize);\r\n\r\n                } else {\r\n                  _totalPrize = _player.raidStakes[i] / 4;\r\n                  _tokensToAdd = _player.raidStakes[i] - _totalPrize;\r\n                }\r\n            } else {\r\n                if (raids[_raidId].wasSuccessful) {\r\n                  _totalPrize = _player.raidStakes[i] / 4;\r\n                  _tokensToAdd = _player.raidStakes[i] - _totalPrize;\r\n\r\n                } else {\r\n                  _totalPrize = raids[_raidId].attackerStakes / 4;\r\n                  _playerPrize = _totalPrize * (_player.raidStakes[i] / raids[_raidId].defenderStakes);\r\n                  _tokensToAdd = _safeAdd(_player.raidStakes[i], _playerPrize);\r\n                }\r\n            }\r\n\r\n            _player.raidIds[i] = 0;\r\n            _player.raidStakes[i] = 0;\r\n\r\n            _corp.tokenSupply = _safeAdd(_corp.tokenSupply, _tokensToAdd);\r\n            _player.tokenBalance = _safeAdd(_player.tokenBalance, _tokensToAdd);\r\n\r\n            _player.payoutsTo += (int256) (_corp.profitsPerShare * _tokensToAdd);\r\n          }\r\n        }\r\n\r\n        emit onClaimedTokens(_customerAddress, _tokensToAdd);\r\n    }\r\n\r\n    /*\r\n    * ---- HELPERS AND CALCULATORS ----\r\n    */\r\n\r\n    function totalEtherBalance()\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        return _safeAdd(corporations[0].tokenSupply, corporations[1].tokenSupply);\r\n    }\r\n\r\n    function myTokens()\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    function myDividends(bool _includeReferralBonus)\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        Player storage _player = players[_customerAddress];\r\n\r\n        return _includeReferralBonus? dividendsOf(_customerAddress) + _player.referralBalance : dividendsOf(_customerAddress);\r\n    }\r\n\r\n    function balanceOf(address _customerAddress)\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        return players[_customerAddress].tokenBalance;\r\n    }\r\n\r\n    function dividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n    returns(uint256)\r\n    {\r\n        Player storage _player = players[_customerAddress];\r\n        Corporation storage _corp = corporations[_player.corpId];\r\n        int256 _profits = (int256)(_corp.profitsPerShare * _player.tokenBalance) - _player.payoutsTo;\r\n\r\n        if (_profits > 0) {\r\n          return (uint256) (_profits) / magnitude;\r\n        } else {\r\n          return 0;\r\n        }\r\n    }\r\n\r\n    function getSellPrice(uint256 _tokensToSell)\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        uint256 _ether = _tokensToEther(_tokensToSell);\r\n        uint256 _devFee = _safeMul(_ether, TRANSACTION_FEE_DEV) / 1000;\r\n        uint256 _etherToWorld = _safeMul(_ether, TRANSACTION_FEE_DIVIDENDS) / 1000;\r\n        uint256 _taxedEther = _safeSub(_ether, _devFee + _etherToWorld);\r\n        return _taxedEther;\r\n    }\r\n\r\n    function getBuyPrice(uint256 _tokensToBuy)\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n        uint256 _ether = _tokensToEther(_tokensToBuy) / (1 - (TRANSACTION_FEE_DEV + TRANSACTION_FEE_DIVIDENDS) / 1000);\r\n        return _ether;\r\n    }\r\n\r\n    function getTokensReceived(uint256 _etherToSpend)\r\n        public\r\n        view\r\n    returns(uint256)\r\n    {\r\n      uint256 _devFee = _safeMul(_etherToSpend, TRANSACTION_FEE_DEV) / 1000;\r\n      uint256 _etherToWorld = _safeMul(_etherToSpend, TRANSACTION_FEE_DIVIDENDS) / 1000;\r\n      uint256 _taxedEther = _safeSub(_etherToSpend, _devFee + _etherToWorld);\r\n      uint256 _tokensReceived = _etherToTokens(_taxedEther);\r\n\r\n      return _tokensReceived;\r\n    }\r\n\r\n    /**\r\n     * Called by the frontend.\r\n     */\r\n    function getPlayerData(address _customerAddress)\r\n        external\r\n        view\r\n    returns(bool, uint8, uint256, uint256, uint256, uint256[] memory, uint256[] memory, uint256)\r\n    {\r\n        Player storage _player = players[_customerAddress];\r\n        uint256 _dividends = dividendsOf(_customerAddress);\r\n\r\n        uint256[] memory _raidIds = new uint256[](PLAYER_SLOTS_COUNT);\r\n        uint256[] memory _raidStakes = new uint256[](PLAYER_SLOTS_COUNT);\r\n\r\n        for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++) {\r\n          _raidIds[i] = _player.raidIds[i];\r\n          _raidStakes[i] = _player.raidStakes[i];\r\n        }\r\n\r\n        return (\r\n          _player.wasInitialized,\r\n          _player.corpId,\r\n          _player.tokenBalance,\r\n          _dividends,\r\n          _player.referralBalance,\r\n          _raidIds,\r\n          _raidStakes,\r\n          _player.totalEtherSpent\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Called by the frontend.\r\n     */\r\n    function getWorldState()\r\n        external\r\n        view\r\n    returns(bool, uint8[] memory, uint256[] memory)\r\n    {\r\n        uint8[] memory _nodeOwners = new uint8[](NODES_COUNT);\r\n        uint256[] memory _pendingRaidIds = new uint256[](NODES_COUNT);\r\n\r\n        for (uint8 i = 0; i < NODES_COUNT; i++) {\r\n          _nodeOwners[i] = worldNodes[i].ownerId;\r\n          _pendingRaidIds[i] = pendingRaidIds[i];\r\n        }\r\n\r\n        return (isPrerelease, _nodeOwners, _pendingRaidIds);\r\n    }\r\n\r\n    /**\r\n     * Called by the frontend.\r\n     */\r\n    function getRaidState(uint256 _raidId)\r\n        external\r\n        view\r\n    returns(uint256, uint8, uint8, bool, bool, uint256, uint256, uint256)\r\n    {\r\n        Raid storage _raid = raids[_raidId];\r\n        uint256 _blocksLeft = 0;\r\n\r\n        if (block.number < _raid.endBlock) {\r\n          _blocksLeft = (_raid.endBlock - block.number);\r\n        }\r\n\r\n        return (\r\n          _raid.id,\r\n          _raid.targetNodeId,\r\n          _raid.attackingCorpId,\r\n          _raid.wasSuccessful,\r\n          _raid.hasBeenRevealed,\r\n          _raid.defenderStakes,\r\n          _raid.attackerStakes,\r\n          _blocksLeft\r\n        );\r\n    }\r\n\r\n    /*================================\r\n    =       INTERNAL FUNCTIONS       =\r\n    ================================*/\r\n\r\n    function initializePlayer(address _customerAddress)\r\n        internal\r\n    {\r\n        Player storage _player = players[_customerAddress];\r\n\r\n        require(!_player.wasInitialized);\r\n\r\n        _player.wasInitialized = true;\r\n        _player.addr = _customerAddress;\r\n        _player.corpId = corporations[0].tokenSupply <= corporations[1].tokenSupply? 0 : 1;\r\n    }\r\n\r\n    function updateProfitsPerShare(uint256 _incomingEther)\r\n        internal\r\n    {\r\n        require(_incomingEther > 0);\r\n\r\n        uint256 _corp0ProfitsTotal = 0;\r\n        uint256 _corp0Adjustment = 0;\r\n        uint256 _newProfitsPerShare = 0;\r\n\r\n        Corporation storage _corp0 = corporations[0];\r\n        Corporation storage _corp1 = corporations[1];\r\n\r\n        uint256 _totalTokenSupply = totalSupply();\r\n\r\n        if (_corp0.tokenSupply > 0) {\r\n          _corp0ProfitsTotal = _safeMul(_incomingEther, _corp0.tokenSupply) / _totalTokenSupply;\r\n\r\n          if (_corp0.totalValue > 50) {\r\n            _corp0Adjustment = _safeMul(_incomingEther - _corp0ProfitsTotal, _corp0.totalValue - 50) / 50;\r\n            _corp0ProfitsTotal = _safeAdd(_corp0ProfitsTotal, _corp0Adjustment);\r\n          } else {\r\n            _corp0Adjustment = _safeMul(_corp0ProfitsTotal, 50 - _corp0.totalValue) / 50;\r\n            _corp0ProfitsTotal = _safeSub(_corp0ProfitsTotal, _corp0Adjustment);\r\n          }\r\n\r\n          _newProfitsPerShare = _corp0ProfitsTotal / _corp0.tokenSupply;\r\n          _corp0.profitsPerShare = _safeAdd(_corp0.profitsPerShare, _newProfitsPerShare);\r\n\r\n        } else {\r\n          _corp0ProfitsTotal = 0;\r\n          _corp0.profitsPerShare = 0;\r\n        }\r\n\r\n        if (_corp1.tokenSupply > 0) {\r\n          _newProfitsPerShare = _safeSub(_incomingEther, _corp0ProfitsTotal) / _corp1.tokenSupply;\r\n          _corp1.profitsPerShare = _safeAdd(_corp1.profitsPerShare, _newProfitsPerShare);\r\n        } else {\r\n          _corp1.profitsPerShare = 0;\r\n        }\r\n    }\r\n\r\n    function getAvailableInvestmentSlot(address _customerAddress, uint8 _worldNodeId)\r\n        internal\r\n        view\r\n        returns(uint8)\r\n    {\r\n      Player storage _player = players[_customerAddress];\r\n\r\n      uint256 _raidId = 0;\r\n      uint8 _freeSlotIndex = PLAYER_SLOTS_COUNT;\r\n\r\n      for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++) {\r\n        _raidId = _player.raidIds[i];\r\n\r\n        if (_raidId > 0) {\r\n          if (raids[_raidId].targetNodeId == _worldNodeId) {\r\n            return i;\r\n          }\r\n\r\n        } else {\r\n          _freeSlotIndex = i;\r\n        }\r\n      }\r\n\r\n      return _freeSlotIndex;\r\n    }\r\n\r\n    function _etherToTokens(uint256 _ether)\r\n        internal\r\n        view\r\n    returns(uint256)\r\n    {\r\n        uint256 _tokensReceived = (_ether / tokenPrice) * 1e18;\r\n        return _tokensReceived;\r\n    }\r\n\r\n    function _tokensToEther(uint256 _tokens)\r\n        internal\r\n        view\r\n    returns(uint256)\r\n    {\r\n        uint256 _etherReceived = (_tokens / 1e18) * tokenPrice;\r\n        return _etherReceived;\r\n    }\r\n\r\n    function _getRNGTargetBlock(uint256 _block)\r\n        internal\r\n        view\r\n    returns(uint256){\r\n      uint256 currentBlock = block.number;\r\n      uint256 target = currentBlock - (currentBlock % 256) + (_block % 256);\r\n      if (target >= currentBlock) {\r\n        return (target - 256);\r\n      }\r\n      return target;\r\n    }\r\n\r\n    function _random(uint256 _targetBlock, uint256 _min, uint256 _max)\r\n        internal\r\n        view\r\n    returns (uint256)\r\n    {\r\n      uint256 _rngTargetBlock = _getRNGTargetBlock(_targetBlock);\r\n      uint256 _rngHash = uint256(keccak256(abi.encodePacked(blockhash(_rngTargetBlock)))) + uint256(lastAttacker);\r\n\r\n      return _rngHash % (_max - _min) + _min;\r\n    }\r\n\r\n    /*\r\n    * From SafeMath\r\n    */\r\n\r\n    function _safeMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n    returns (uint256)\r\n    {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n\r\n      uint256 c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function _safeSub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n    returns (uint256)\r\n    {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function _safeAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n    returns (uint256)\r\n    {\r\n      uint256 c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAdminBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToBuy\",\"type\":\"uint256\"}],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setIsPrerelease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_worldNodeId\",\"type\":\"uint8\"},{\"name\":\"_stakes\",\"type\":\"uint256\"}],\"name\":\"defendWorldNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"corporations\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"mainNodeId\",\"type\":\"uint8\"},{\"name\":\"totalValue\",\"type\":\"uint8\"},{\"name\":\"profitsPerShare\",\"type\":\"uint256\"},{\"name\":\"tokenSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toCorporationId\",\"type\":\"uint8\"}],\"name\":\"changePlayerCorporation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeId\",\"type\":\"uint8\"}],\"name\":\"revealWorldNodeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"setSecondsPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"worldNodes\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"ownerId\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint8\"},{\"name\":\"isImmutable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWorldState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint8[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRaidTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPrerelease\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_etherToSpend\",\"type\":\"uint256\"}],\"name\":\"getTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raids\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"targetNodeId\",\"type\":\"uint8\"},{\"name\":\"attackingCorpId\",\"type\":\"uint8\"},{\"name\":\"wasSuccessful\",\"type\":\"bool\"},{\"name\":\"hasBeenRevealed\",\"type\":\"bool\"},{\"name\":\"defenderStakes\",\"type\":\"uint256\"},{\"name\":\"attackerStakes\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingRaidIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"getSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raidTimeLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_worldNodeId\",\"type\":\"uint8\"},{\"name\":\"_stakes\",\"type\":\"uint256\"}],\"name\":\"raidWorldNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_raidId\",\"type\":\"uint256\"}],\"name\":\"getRaidState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"wasInitialized\",\"type\":\"bool\"},{\"name\":\"corpId\",\"type\":\"uint8\"},{\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"name\":\"referralBalance\",\"type\":\"uint256\"},{\"name\":\"payoutsTo\",\"type\":\"int256\"},{\"name\":\"totalEtherSpent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"worldNodeId\",\"type\":\"uint8\"}],\"name\":\"onWorldNodeRaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"raidId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwnerId\",\"type\":\"uint8\"}],\"name\":\"onWorldNodeOwnerReveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromCorpId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"toCorpId\",\"type\":\"uint8\"}],\"name\":\"onPlayerChangedCorp\",\"type\":\"event\"}]","ContractName":"Corpocracy","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://bc9ca67b6aaade7845e554f1f078e7aa01f51cf6e7e6c7f5deae5e576aa9d7b7"}]}