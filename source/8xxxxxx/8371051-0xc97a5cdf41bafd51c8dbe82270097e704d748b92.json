{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\ninterface IERC20 \r\n{\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\nlibrary SafeMath \r\n{\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) \r\n    {\r\n        uint256 c = add(a,m);\r\n        uint256 d = sub(c,1);\r\n        return mul(div(d,m),m);\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 \r\n{\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n    \r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract KLOWN is ERC20Detailed \r\n{\r\n    using SafeMath for uint256;\r\n    \r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n    \r\n    string constant tokenName = \"Ether Clown\";//\"Ether Clown\";\r\n    string constant tokenSymbol = \"KLOWN\";//\"KLOWN\"; \r\n    uint8  constant tokenDecimals = 7;\r\n    uint256 _totalSupply = 0;\r\n\t\r\n\t    //shown in public \r\n    uint256 public RemainingSupply = 0;\r\n\r\n    \r\n    // ------------------------------------------------------------------------\r\n  \r\n    address public contractOwner;\r\n\r\n\r\n\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    // ------------------------------------------------------------------------\r\n    \r\n    constructor() public ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) \r\n    {\r\n        contractOwner = msg.sender;\r\n\r\n        _mint(msg.sender, 777000 * (10**uint256(tokenDecimals)));\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n\r\n    function transferOwnership(address newOwner) public \r\n    {\r\n        require(msg.sender == contractOwner);\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) \r\n    {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function balanceOf(address owner) public view returns (uint256) \r\n    {\r\n        return _balances[owner];\r\n    }\r\n    \r\n   \r\n   \r\n    function allowance(address owner, address spender) public view returns (uint256) \r\n    {\r\n        return _allowed[owner][spender];\r\n    }\r\n    \r\n    function transfer(address to, uint256 value) public returns (bool) \r\n    {\r\n        _executeTransfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n    \r\n    function multiTransfer(address[] memory receivers, uint256[] memory values) public\r\n    {\r\n        require(receivers.length == values.length);\r\n        for(uint256 i = 0; i < receivers.length; i++)\r\n            _executeTransfer(msg.sender, receivers[i], values[i]);\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) \r\n    {\r\n        require(value <= _allowed[from][msg.sender]);\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _executeTransfer(from, to, value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address spender, uint256 value) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) \r\n    {\r\n        _allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n    function _mint(address account, uint256 value) internal \r\n    {\r\n        require(value != 0);\r\n        \r\n        uint256 initalBalance = _balances[account];\r\n        uint256 newBalance = initalBalance.add(value);\r\n        \r\n        _balances[account] = newBalance;\r\n        _totalSupply = _totalSupply.add(value);\r\n\r\n\r\n\t\tRemainingSupply = _totalSupply;\r\n        \r\n\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n    \r\n    function burn(uint256 value) external \r\n    {\r\n        _burn(msg.sender, value);\r\n    }\r\n    \r\n    function burnFrom(address account, uint256 value) external \r\n    {\r\n        require(value <= _allowed[account][msg.sender]);\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n    }\r\n    \r\n    function _burn(address account, uint256 value) internal \r\n    {\r\n        require(value != 0);\r\n        require(value <= _balances[account]);\r\n        \r\n        uint256 initalBalance = _balances[account];\r\n        uint256 newBalance = initalBalance.sub(value);\r\n        \r\n        _balances[account] = newBalance;\r\n        _totalSupply = _totalSupply.sub(value);\r\n\t\t//public\r\n\t\tRemainingSupply = _totalSupply;\r\n        \r\n        \r\n        emit Transfer(account, address(0), value);\r\n    }\r\n    \r\n    function random() private view returns (uint256) {\r\n        \r\n        \r\n        uint256 rndValue =  uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\r\n        // get a psudeorandom value between 150 and 350 (to be used as percent % burn)\r\n        rndValue = rndValue %200 + 150;\r\n     \r\n        \r\n       \r\n       return\r\n        rndValue;\r\n        \r\n   }\r\n\r\n    \r\n    /*\r\n    *   transfer with additional burn and stake rewards\r\n    *   the receiver gets 95% of the sent value\r\n    *   5% are split to be burnt and distributed to holders\r\n    */\r\n    function _executeTransfer(address from, address to, uint256 value) private\r\n    {\r\n        require(value <= _balances[from]);\r\n        require(to != address(0) && to != address(this));\r\n\r\n\t\t\r\n        uint256 randomBurnPercent = 0;\r\n\t\tuint256 burnPercent = 0;\r\n\t\t\r\n\t\t\r\n\t\t//burn only if total remaining supply > 15540 (percentage of orignal supply)\r\n\t\tif(_totalSupply > 15540)\r\n\t\t{\r\n\t\t\trandomBurnPercent = random();\r\n\t\t\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\t\trandom number generated is between 150 and 350. need it to be between 1.5 and 3.5 \r\n\t\t\t\tthis technique is used due to the way solidity handles floating point numbers\r\n\t\t\t\t10000 is dividing by 100 twice \r\n\t\t\t*/ \r\n\t\t\t\r\n\t\t\tburnPercent = value.mul(randomBurnPercent).div(10000);\r\n        }\r\n        \r\n\t\t\r\n        uint256 initalBalance_from = _balances[from];\r\n        uint256 newBalance_from = initalBalance_from.sub(value);\r\n        \r\n        value = value.sub(burnPercent);\r\n        \r\n        uint256 initalBalance_to = _balances[to];\r\n        uint256 newBalance_to = initalBalance_to.add(value);\r\n        \r\n        //transfer\r\n        _balances[from] = newBalance_from;\r\n        _balances[to] = newBalance_to;\r\n        emit Transfer(from, to, value);\r\n                \r\n        uint256 amountToBurn = burnPercent;\r\n                \r\n        //update total supply\r\n        _totalSupply = _totalSupply.sub(amountToBurn);\r\n\t\t//public\r\n\t\tRemainingSupply = _totalSupply;\r\n\t\t\r\n        emit Transfer(msg.sender, address(0), amountToBurn);\r\n    }\r\n    \r\n    \r\n    //withdraw tokens that were sent to this contract by accident\r\n    function withdrawERC20Tokens(address tokenAddress, uint256 amount) public\r\n    {\r\n        require(msg.sender == contractOwner);\r\n        require(tokenAddress != address(this));\r\n        IERC20(tokenAddress).transfer(msg.sender, amount);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"RemainingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"KLOWN","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://48bbb199e8ae0f3a2fcb4845bd886a3a55a99befbfbd21fc3777e5c004be18ac"}]}