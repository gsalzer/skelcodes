{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ninterface IOwnable {\r\n    /**\r\n    * @dev Returns owner\r\n    */\r\n    function owner() external view returns(address ownerAddress);\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for security token proxy deployment\r\n */\r\ninterface ISTFactory {\r\n\r\n    event LogicContractSet(string _version, address _logicContract, bytes _upgradeData);\r\n    event TokenUpgraded(\r\n        address indexed _securityToken,\r\n        uint256 indexed _version\r\n    );\r\n    event DefaultTransferManagerUpdated(address indexed _oldTransferManagerFactory, address indexed _newTransferManagerFactory);\r\n    event DefaultDataStoreUpdated(address indexed _oldDataStoreFactory, address indexed _newDataStoreFactory);\r\n\r\n    /**\r\n     * @notice Deploys the token and adds default modules like permission manager and transfer manager.\r\n     * Future versions of the proxy can attach different modules or pass some other paramters.\r\n     * @param _name is the name of the Security token\r\n     * @param _symbol is the symbol of the Security Token\r\n     * @param _decimals is the number of decimals of the Security Token\r\n     * @param _tokenDetails is the off-chain data associated with the Security Token\r\n     * @param _issuer is the owner of the Security Token\r\n     * @param _divisible whether the token is divisible or not\r\n     * @param _treasuryWallet Ethereum address which will holds the STs.\r\n     */\r\n    function deployToken(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        uint8 _decimals,\r\n        string calldata _tokenDetails,\r\n        address _issuer,\r\n        bool _divisible,\r\n        address _treasuryWallet //In v2.x this is the Polymath Registry\r\n    )\r\n    external\r\n    returns(address tokenAddress);\r\n\r\n    /**\r\n     * @notice Used to set a new token logic contract\r\n     * @param _version Version of upgraded module\r\n     * @param _logicContract Address of deployed module logic contract referenced from proxy\r\n     * @param _initializationData Initialization data that used to intialize value in the securityToken\r\n     * @param _upgradeData Data to be passed in call to upgradeToAndCall when a token upgrades its module\r\n     */\r\n    function setLogicContract(string calldata _version, address _logicContract, bytes calldata _initializationData, bytes calldata _upgradeData) external;\r\n\r\n    /**\r\n     * @notice Used to upgrade a token\r\n     * @param _maxModuleType maximum module type enumeration\r\n     */\r\n    function upgradeToken(uint8 _maxModuleType) external;\r\n\r\n    /**\r\n     * @notice Used to set a new default transfer manager\r\n     * @dev Setting this to address(0) means don't deploy a default TM\r\n     * @param _transferManagerFactory Address of new default transfer manager factory\r\n     */\r\n    function updateDefaultTransferManager(address _transferManagerFactory) external;\r\n\r\n    /**\r\n     * @notice Used to set a new default data store\r\n     * @dev Setting this to address(0) means don't deploy a default data store\r\n     * @param _dataStoreFactory Address of new default data store factory\r\n     */\r\n    function updateDefaultDataStore(address _dataStoreFactory) external;\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n    // Standard ERC20 interface\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n    function approve(address spender, uint256 value) external returns(bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    // Emit at the time when module get added\r\n    event ModuleAdded(\r\n        uint8[] _types,\r\n        bytes32 indexed _name,\r\n        address indexed _moduleFactory,\r\n        address _module,\r\n        uint256 _moduleCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    );\r\n\r\n    // Emit when the token details get updated\r\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\r\n    // Emit when the token name get updated\r\n    event UpdateTokenName(string _oldName, string _newName);\r\n    // Emit when the granularity get changed\r\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\r\n    // Emit when is permanently frozen by the issuer\r\n    event FreezeIssuance();\r\n    // Emit when transfers are frozen or unfrozen\r\n    event FreezeTransfers(bool _status);\r\n    // Emit when new checkpoint created\r\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\r\n    // Events to log controller actions\r\n    event SetController(address indexed _oldController, address indexed _newController);\r\n    //Event emit when the global treasury wallet address get changed\r\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\r\n    event DisableController();\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    // Emit when Module get archived from the securityToken\r\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get unarchived from the securityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get removed from the securityToken\r\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when the budget allocated to a module is changed\r\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed _fromPartition,\r\n        address _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // Issuance / Redemption Events\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Document Events\r\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n\r\n    // Controller Events\r\n    event ControllerTransfer(\r\n        address _controller,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    event ControllerRedemption(\r\n        address _controller,\r\n        address indexed _tokenHolder,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Issuance / Redemption Events\r\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\r\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\r\n\r\n    /**\r\n     * @notice Initialization function\r\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\r\n     * @dev Can only be called once\r\n     */\r\n    function initialize(address _getterDelegate) external;\r\n\r\n    /**\r\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\r\n     * and return details indicating the reason if the transfer is not valid.\r\n     * @param _from The address from whom the tokens get transferred.\r\n     * @param _to The address to which to transfer tokens to.\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\r\n     * @return Application specific reason codes with additional details\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function canTransferByPartition(\r\n        address _from,\r\n        address _to,\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        view\r\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    /**\r\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\r\n     * @param _documentHash hash (of the contents) of the document.\r\n     */\r\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\r\n\r\n    /**\r\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     */\r\n    function removeDocument(bytes32 _name) external;\r\n\r\n    /**\r\n     * @notice Used to return the details of a document with a known name (`bytes32`).\r\n     * @param _name Name of the document\r\n     * @return string The URI associated with the document.\r\n     * @return bytes32 The hash (of the contents) of the document.\r\n     * @return uint256 the timestamp at which the document was last modified.\r\n     */\r\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\r\n\r\n    /**\r\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\r\n     * @return bytes32 List of all documents names present in the contract.\r\n     */\r\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\r\n\r\n    /**\r\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\r\n     * or not `isControllable` function will be used.\r\n     * @dev If `isControllable` returns `false` then it always return `false` and\r\n     * `controllerTransfer` / `controllerRedeem` will always revert.\r\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\r\n     */\r\n    function isControllable() external view returns (bool controlled);\r\n\r\n    /**\r\n     * @notice Checks if an address is a module of certain type\r\n     * @param _module Address to check\r\n     * @param _type type to check against\r\n     */\r\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\r\n\r\n    /**\r\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\r\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\r\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\r\n     * is allowed to call by the operator.\r\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\r\n     * @param _value The amount of tokens need to be issued\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     */\r\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\r\n     * @dev Can only be called by the issuer or STO attached to the token.\r\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\r\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\r\n     * @return success\r\n     */\r\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\r\n\r\n    /**\r\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\r\n     * @param _partition The partition to allocate the increase in balance\r\n     * @param _tokenHolder The token holder whose balance should be increased\r\n     * @param _value The amount by which to increase the balance\r\n     * @param _data Additional data attached to the minting of tokens\r\n     */\r\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\r\n     * @param _partition The partition to allocate the decrease in balance\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     */\r\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeem(uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @dev It is analogy to `transferFrom`\r\n     * @param _tokenHolder The account whose tokens gets redeemed.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\r\n     * @dev This function can only be called by the authorised operator.\r\n     * @param _partition The partition to allocate the decrease in balance.\r\n     * @param _tokenHolder The token holder whose balance should be decreased\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     */\r\n    function operatorRedeemByPartition(\r\n        bytes32 _partition,\r\n        address _tokenHolder,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Array of module types\r\n     * @return bytes32 Module label\r\n     */\r\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice use to return the global treasury wallet\r\n     */\r\n    function getTreasuryWallet() external view returns(address treasuryWallet);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Gets list of times that checkpoints were created\r\n     * @return List of checkpoint times\r\n     */\r\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\r\n\r\n    /**\r\n     * @notice returns an array of investors\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @return list of addresses\r\n     */\r\n    function getInvestors() external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors with non zero balance at a given checkpoint\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\r\n     */\r\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     * @param _partition The partition to check\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     */\r\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Return all partitions\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return List of partitions\r\n     */\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\r\n\r\n    /**\r\n     * @notice Gets data store address\r\n     * @return data store address\r\n     */\r\n    function dataStore() external view returns (address dataStoreAddress);\r\n\r\n    /**\r\n    * @notice Allows owner to change data store\r\n    * @param _dataStore Address of the token data store\r\n    */\r\n    function changeDataStore(address _dataStore) external;\r\n\r\n\r\n    /**\r\n     * @notice Allows to change the treasury wallet address\r\n     * @param _wallet Ethereum address of the treasury wallet\r\n     */\r\n    function changeTreasuryWallet(address _wallet) external;\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n     * @param _tokenContract Address of the ERC20Basic compliance token\r\n     * @param _value Amount of POLY to withdraw\r\n     */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\r\n    * @param _module Module address\r\n    * @param _change Change in allowance\r\n    * @param _increase True if budget has to be increased, false if decrease\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string calldata _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows owner to change token name\r\n    * @param _name new name of the token\r\n    */\r\n    function changeName(string calldata _name) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Permanently freeze issuance of this security token.\r\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\r\n     */\r\n    function freezeIssuance(bytes calldata _signature) external;\r\n\r\n    /**\r\n      * @notice Attachs a module to the SecurityToken\r\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n      * @dev to control restrictions on transfers.\r\n      * @param _moduleFactory is the address of the module factory to be added\r\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n      * @param _maxCost max amount of POLY willing to pay to the module.\r\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n      * @param _label custom module label.\r\n      * @param _archived whether to add the module as an archived module\r\n      */\r\n    function addModuleWithLabel(\r\n        address _moduleFactory,\r\n        bytes calldata _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n     * @param _archived whether to add the module as an archived module\r\n     */\r\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\r\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\r\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _from Address The address which you want to send tokens from\r\n     * @param _to Address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\r\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\r\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _tokenHolder The account whose tokens will be redeemed.\r\n     * @param _value uint256 the amount of tokens need to be redeemed.\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n    function disableController(bytes calldata _signature) external;\r\n\r\n    /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n    function getVersion() external view returns(uint8[] memory version);\r\n\r\n    /**\r\n     * @notice Gets the investor count\r\n     */\r\n    function getInvestorCount() external view returns(uint256 investorCount);\r\n\r\n    /**\r\n     * @notice Gets the holder count (investors with non zero balance)\r\n     */\r\n    function holderCount() external view returns(uint256 count);\r\n\r\n    /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\r\n\r\n    /**\r\n     * @notice Get the balance according to the provided partitions\r\n     * @param _partition Partition which differentiate the tokens.\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return Amount of tokens as per the given partitions\r\n     */\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\r\n\r\n    /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n    function granularity() external view returns(uint256 granularityAmount);\r\n\r\n    /**\r\n      * @notice Provides the address of the polymathRegistry\r\n      * @return address\r\n      */\r\n    function polymathRegistry() external view returns(address registryAddress);\r\n\r\n    /**\r\n    * @notice Upgrades a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function upgradeModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Upgrades security token\r\n    */\r\n    function upgradeToken() external;\r\n\r\n    /**\r\n     * @notice A security token issuer can specify that issuance has finished for the token\r\n     * (i.e. no new tokens can be minted or issued).\r\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\r\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\r\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\r\n     */\r\n    function isIssuable() external view returns (bool issuable);\r\n\r\n    /**\r\n     * @notice Authorises an operator for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being authorised.\r\n     */\r\n    function authorizeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Authorises an operator for a given partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is authorised\r\n     * @param _operator An address which is being authorised\r\n     */\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is de-authorised\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens.\r\n     * @param _from The address from which to transfer tokens from\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function operatorTransferByPartition(\r\n        bytes32 _partition,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    )\r\n        external\r\n        returns (bytes32 partition);\r\n\r\n    /*\r\n    * @notice Returns if transfers are currently frozen or not\r\n    */\r\n    function transfersFrozen() external view returns (bool isFrozen);\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() external view returns (bool);\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() external view returns (address ownerAddress);\r\n\r\n    function controller() external view returns(address controllerAddress);\r\n\r\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\r\n\r\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\r\n\r\n    function polyToken() external view returns(address polyTokenAddress);\r\n\r\n    function tokenFactory() external view returns(address tokenFactoryAddress);\r\n\r\n    function getterDelegate() external view returns(address delegate);\r\n\r\n    function controllerDisabled() external view returns(bool isDisabled);\r\n\r\n    function initialized() external view returns(bool isInitialized);\r\n\r\n    function tokenDetails() external view returns(string memory details);\r\n\r\n    function updateFromRegistry() external;\r\n\r\n}\r\n\r\ninterface IPolymathRegistry {\r\n\r\n    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\r\n    \r\n    /**\r\n     * @notice Returns the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @return address\r\n     */\r\n    function getAddress(string calldata _nameKey) external view returns(address registryAddress);\r\n\r\n    /**\r\n     * @notice Changes the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @param _newAddress is the new contract address\r\n     */\r\n    function changeAddress(string calldata _nameKey, address _newAddress) external;\r\n\r\n}\r\n\r\ninterface IOracle {\r\n    /**\r\n    * @notice Returns address of oracle currency (0x0 for ETH)\r\n    */\r\n    function getCurrencyAddress() external view returns(address currency);\r\n\r\n    /**\r\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\r\n    */\r\n    function getCurrencySymbol() external view returns(bytes32 symbol);\r\n\r\n    /**\r\n    * @notice Returns denomination of price\r\n    */\r\n    function getCurrencyDenominated() external view returns(bytes32 denominatedCurrency);\r\n\r\n    /**\r\n    * @notice Returns price - should throw if not valid\r\n    */\r\n    function getPrice() external returns(uint256 price);\r\n\r\n}\r\n\r\ncontract EternalStorage {\r\n    /// @notice Internal mappings used to store all kinds on data into the contract\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n    mapping(bytes32 => bytes32) internal bytes32Storage;\r\n\r\n    /// @notice Internal mappings used to store arrays of different data types\r\n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\r\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\r\n    mapping(bytes32 => address[]) internal addressArrayStorage;\r\n    mapping(bytes32 => string[]) internal stringArrayStorage;\r\n\r\n    //////////////////\r\n    //// set functions\r\n    //////////////////\r\n    /// @notice Set the key values using the Overloaded `set` functions\r\n    /// Ex- string version = \"0.0.1\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"version\"), \"0.0.1\");\r\n    /// same for the other variables as well some more example listed below\r\n    /// ex1 - address securityTokenAddress = 0x123; replace to\r\n    /// set(keccak256(abi.encodePacked(\"securityTokenAddress\"), 0x123);\r\n    /// ex2 - bytes32 tokenDetails = \"I am ST20\"; replace to\r\n    /// set(keccak256(abi.encodePacked(\"tokenDetails\"), \"I am ST20\");\r\n    /// ex3 - mapping(string => address) ownedToken;\r\n    /// set(keccak256(abi.encodePacked(\"ownedToken\", \"Chris\")), 0x123);\r\n    /// ex4 - mapping(string => uint) tokenIndex;\r\n    /// tokenIndex[\"TOKEN\"] = 1; replace to set(keccak256(abi.encodePacked(\"tokenIndex\", \"TOKEN\"), 1);\r\n    /// ex5 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// registeredSymbols[\"TOKEN\"].name = \"MyFristToken\"; replace to set(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"), \"MyFirstToken\");\r\n    /// More generalized- set(keccak256(abi.encodePacked(\"registeredSymbols_<struct variable>\", \"keyname\"), \"value\");\r\n\r\n    function set(bytes32 _key, uint256 _value) internal {\r\n        uintStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, address _value) internal {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bool _value) internal {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bytes32 _value) internal {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, string memory _value) internal {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    function set(bytes32 _key, bytes memory _value) internal {\r\n        bytesStorage[_key] = _value;\r\n    }\r\n\r\n    ////////////////////////////\r\n    // deleteArray functions\r\n    ////////////////////////////\r\n    /// @notice Function used to delete the array element.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// For deleting the item from array developers needs to create a funtion for that similarly\r\n    /// in this case we have the helper function deleteArrayBytes32() which will do it for us\r\n    /// deleteArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1), 3); -- it will delete the index 3\r\n\r\n    //Deletes from mapping (bytes32 => array[]) at index _index\r\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\r\n        address[] storage array = addressArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\r\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\r\n        bytes32[] storage array = bytes32ArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => uint[]) at index _index\r\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\r\n        uint256[] storage array = uintArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    //Deletes from mapping (bytes32 => string[]) at index _index\r\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\r\n        string[] storage array = stringArrayStorage[_key];\r\n        require(_index < array.length, \"Index should less than length of the array\");\r\n        array[_index] = array[array.length - 1];\r\n        array.length = array.length - 1;\r\n    }\r\n\r\n    ////////////////////////////\r\n    //// pushArray functions\r\n    ///////////////////////////\r\n    /// @notice Below are the helper functions to facilitate storing arrays of different data types.\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByTicker;\r\n    /// tokensOwnedByTicker[owner] = tokensOwnedByTicker[owner].push(\"xyz\"); replace with\r\n    /// pushArray(keccak256(abi.encodePacked(\"tokensOwnedByTicker\", owner), \"xyz\");\r\n\r\n    /// @notice use to store the values for the array\r\n    /// @param _key bytes32 type\r\n    /// @param _value [uint256, string, bytes32, address] any of the data type in array\r\n    function pushArray(bytes32 _key, address _value) internal {\r\n        addressArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, string memory _value) internal {\r\n        stringArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    function pushArray(bytes32 _key, uint256 _value) internal {\r\n        uintArrayStorage[_key].push(_value);\r\n    }\r\n\r\n    /////////////////////////\r\n    //// Set Array functions\r\n    ////////////////////////\r\n    /// @notice used to intialize the array\r\n    /// Ex1- mapping (address => address[]) public reputation;\r\n    /// reputation[0x1] = new address[](0); It can be replaced as\r\n    /// setArray(hash('reputation', 0x1), new address[](0));\r\n\r\n    function setArray(bytes32 _key, address[] memory _value) internal {\r\n        addressArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\r\n        uintArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\r\n        bytes32ArrayStorage[_key] = _value;\r\n    }\r\n\r\n    function setArray(bytes32 _key, string[] memory _value) internal {\r\n        stringArrayStorage[_key] = _value;\r\n    }\r\n\r\n    /////////////////////////\r\n    /// getArray functions\r\n    /////////////////////////\r\n    /// @notice Get functions to get the array of the required data type\r\n    /// Ex1- mapping(address => bytes32[]) tokensOwnedByOwner;\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)); It return the bytes32 array\r\n    /// Ex2- uint256 _len =  tokensOwnedByOwner[0x1].length; replace with\r\n    /// getArrayBytes32(keccak256(abi.encodePacked(\"tokensOwnedByOwner\", 0x1)).length;\r\n\r\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\r\n        return addressArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\r\n        return bytes32ArrayStorage[_key];\r\n    }\r\n\r\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\r\n        return uintArrayStorage[_key];\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    /// setArrayIndexValue() functions\r\n    ///////////////////////////////////\r\n    /// @notice set the value of particular index of the address array\r\n    /// Ex1- mapping(bytes32 => address[]) moduleList;\r\n    /// general way is -- moduleList[moduleType][index] = temp;\r\n    /// It can be re-write as -- setArrayIndexValue(keccak256(abi.encodePacked('moduleList', moduleType)), index, temp);\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\r\n        addressArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\r\n        uintArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\r\n        bytes32ArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\r\n        stringArrayStorage[_key][_index] = _value;\r\n    }\r\n\r\n    /// Public getters functions\r\n    /////////////////////// @notice Get function use to get the value of the singleton state variables\r\n    /// Ex1- string public version = \"0.0.1\";\r\n    /// string _version = getString(keccak256(abi.encodePacked(\"version\"));\r\n    /// Ex2 - assert(temp1 == temp2); replace to\r\n    /// assert(getUint(keccak256(abi.encodePacked(temp1)) == getUint(keccak256(abi.encodePacked(temp2));\r\n    /// Ex3 - mapping(string => SymbolDetails) registeredSymbols; where SymbolDetails is the structure having different type of values as\r\n    /// {uint256 date, string name, address owner} etc.\r\n    /// string _name = getString(keccak256(abi.encodePacked(\"registeredSymbols_name\", \"TOKEN\"));\r\n\r\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\r\n        return uintStorage[_variable];\r\n    }\r\n\r\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\r\n        return boolStorage[_variable];\r\n    }\r\n\r\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\r\n        return stringStorage[_variable];\r\n    }\r\n\r\n    function getAddressValue(bytes32 _variable) public view returns(address) {\r\n        return addressStorage[_variable];\r\n    }\r\n\r\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\r\n        return bytes32Storage[_variable];\r\n    }\r\n\r\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\r\n        return bytesStorage[_variable];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract for reusable code\r\n */\r\nlibrary Util {\r\n    /**\r\n    * @notice Changes a string to upper case\r\n    * @param _base String to change\r\n    */\r\n    function upper(string memory _base) internal pure returns(string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            bytes1 b1 = _baseBytes[i];\r\n            if (b1 >= 0x61 && b1 <= 0x7A) {\r\n                b1 = bytes1(uint8(b1) - 32);\r\n            }\r\n            _baseBytes[i] = b1;\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the string into bytes32\r\n     * @param _source String that need to convert into bytes32\r\n     */\r\n    /// Notice - Maximum Length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function stringToBytes32(string memory _source) internal pure returns(bytes32) {\r\n        return bytesToBytes32(bytes(_source), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes bytes into bytes32\r\n     * @param _b Bytes that need to convert into bytes32\r\n     * @param _offset Offset from which to begin conversion\r\n     */\r\n    /// Notice - Maximum length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function bytesToBytes32(bytes memory _b, uint _offset) internal pure returns(bytes32) {\r\n        bytes32 result;\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            result |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the bytes32 into string\r\n     * @param _source that need to convert into string\r\n     */\r\n    function bytes32ToString(bytes32 _source) internal pure returns(string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        uint j = 0;\r\n        for (j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_source) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets function signature from _data\r\n     * @param _data Passed data\r\n     * @return bytes4 sig\r\n     */\r\n    function getSig(bytes memory _data) internal pure returns(bytes4 sig) {\r\n        uint len = _data.length < 4 ? _data.length : 4;\r\n        for (uint256 i = 0; i < len; i++) {\r\n          sig |= bytes4(_data[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return sig;\r\n    }\r\n}\r\n\r\nlibrary Encoder {\r\n    function getKey(string memory _key) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key)));\r\n    }\r\n\r\n    function getKey(string memory _key1, address _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string memory _key1, string memory _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string memory _key1, uint256 _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string memory _key1, bytes32 _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function getKey(string memory _key1, bool _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Helper library use to compare or validate the semantic versions\r\n */\r\n\r\nlibrary VersionUtils {\r\n\r\n    function lessThanOrEqual(uint8[] memory _current, uint8[] memory _new) internal pure returns(bool) {\r\n        require(_current.length == 3);\r\n        require(_new.length == 3);\r\n        uint8 i = 0;\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (_current[i] == _new[i]) continue;\r\n            if (_current[i] < _new[i]) return true;\r\n            if (_current[i] > _new[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function greaterThanOrEqual(uint8[] memory _current, uint8[] memory _new) internal pure returns(bool) {\r\n        require(_current.length == 3);\r\n        require(_new.length == 3);\r\n        uint8 i = 0;\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (_current[i] == _new[i]) continue;\r\n            if (_current[i] > _new[i]) return true;\r\n            if (_current[i] < _new[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to pack the uint8[] array data into uint24 value\r\n     * @param _major Major version\r\n     * @param _minor Minor version\r\n     * @param _patch Patch version\r\n     */\r\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\r\n        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into uint8 array\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpack(uint24 _packedVersion) internal pure returns(uint8[] memory) {\r\n        uint8[] memory _unpackVersion = new uint8[](3);\r\n        _unpackVersion[0] = uint8(_packedVersion >> 16);\r\n        _unpackVersion[1] = uint8(_packedVersion >> 8);\r\n        _unpackVersion[2] = uint8(_packedVersion);\r\n        return _unpackVersion;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Used to packed the KYC data\r\n     */\r\n    function packKYC(uint64 _a, uint64 _b, uint64 _c, uint8 _d) internal pure returns(uint256) {\r\n        // this function packs 3 uint64 and a uint8 together in a uint256 to save storage cost\r\n        // a is rotated left by 136 bits, b is rotated left by 72 bits and c is rotated left by 8 bits.\r\n        // rotation pads empty bits with zeroes so now we can safely do a bitwise OR operation to pack\r\n        // all the variables together.\r\n        return (uint256(_a) << 136) | (uint256(_b) << 72) | (uint256(_c) << 8) | uint256(_d);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into KYC data\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpackKYC(uint256 _packedVersion) internal pure returns(uint64 canSendAfter, uint64 canReceiveAfter, uint64 expiryTime, uint8 added) {\r\n        canSendAfter = uint64(_packedVersion >> 136);\r\n        canReceiveAfter = uint64(_packedVersion >> 72);\r\n        expiryTime = uint64(_packedVersion >> 8);\r\n        added = uint8(_packedVersion);\r\n    }\r\n}\r\n\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\r\n\r\n    /**\r\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\r\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\r\n     */\r\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\r\n        z = SafeMath.add(SafeMath.mul(x, y), (e18) / 2) / (e18);\r\n    }\r\n\r\n    /**\r\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\r\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\r\n     */\r\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\r\n        z = SafeMath.add(SafeMath.mul(x, (e18)), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function _implementation() internal view returns(address);\r\n\r\n    /**\r\n    * @dev Fallback function.\r\n    * Implemented entirely in `_fallback`.\r\n    */\r\n    function _fallback() internal {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function _delegate(address implementation) internal {\r\n        /*solium-disable-next-line security/no-inline-assembly*/\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n}\r\n\r\n/**\r\n    //\r\n        IMPORTANT: Developer should update the ISecurityTokenRegistry.sol (Interface) if there is any change in\r\n        function signature or addition/removal of the functions from SecurityTokenRegistry & STRGetter contract.\r\n    //\r\n\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Registry contract for issuers to register their tickers and security tokens\r\n */\r\ncontract SecurityTokenRegistry is EternalStorage, Proxy {\r\n\r\n    /**\r\n     * @notice state variables\r\n\r\n       address public polyToken;\r\n       uint256 public stLaunchFee;\r\n       uint256 public tickerRegFee;\r\n       uint256 public expiryLimit;\r\n       uint256 public latestProtocolVersion;\r\n       bool public paused;\r\n       address public owner;\r\n       address public polymathRegistry;\r\n\r\n       address[] public activeUsers;\r\n       mapping(address => bool) public seenUsers;\r\n\r\n       mapping(address => bytes32[]) userToTickers;\r\n       mapping(string => address) tickerToSecurityToken;\r\n       mapping(string => uint) tickerIndex;\r\n       mapping(string => TickerDetails) registeredTickers;\r\n       mapping(address => SecurityTokenData) securityTokens;\r\n       mapping(bytes32 => address) protocolVersionST;\r\n       mapping(uint256 => ProtocolVersion) versionData;\r\n\r\n       struct ProtocolVersion {\r\n           uint8 major;\r\n           uint8 minor;\r\n           uint8 patch;\r\n       }\r\n\r\n       struct TickerDetails {\r\n           address owner;\r\n           uint256 registrationDate;\r\n           uint256 expiryDate;\r\n           string tokenName; //Not stored since 3.0.0\r\n           bool status;\r\n       }\r\n\r\n       struct SecurityTokenData {\r\n           string ticker;\r\n           string tokenDetails;\r\n           uint256 deployedAt;\r\n       }\r\n\r\n     */\r\n\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 constant INITIALIZE = 0x9ef7257c3339b099aacf96e55122ee78fb65a36bd2a6c19249882be9c98633bf; //keccak256(\"initialised\")\r\n    bytes32 constant POLYTOKEN = 0xacf8fbd51bb4b83ba426cdb12f63be74db97c412515797993d2a385542e311d7; //keccak256(\"polyToken\")\r\n    bytes32 constant STLAUNCHFEE = 0xd677304bb45536bb7fdfa6b9e47a3c58fe413f9e8f01474b0a4b9c6e0275baf2; //keccak256(\"stLaunchFee\")\r\n    bytes32 constant TICKERREGFEE = 0x2fcc69711628630fb5a42566c68bd1092bc4aa26826736293969fddcd11cb2d2; //keccak256(\"tickerRegFee\")\r\n    bytes32 constant EXPIRYLIMIT = 0x604268e9a73dfd777dcecb8a614493dd65c638bad2f5e7d709d378bd2fb0baee; //keccak256(\"expiryLimit\")\r\n    bytes32 constant PAUSED = 0xee35723ac350a69d2a92d3703f17439cbaadf2f093a21ba5bf5f1a53eb2a14d9; //keccak256(\"paused\")\r\n    bytes32 constant OWNER = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0; //keccak256(\"owner\")\r\n    bytes32 constant POLYMATHREGISTRY = 0x90eeab7c36075577c7cc5ff366e389fefa8a18289b949bab3529ab4471139d4d; //keccak256(\"polymathRegistry\")\r\n    bytes32 constant STRGETTER = 0x982f24b3bd80807ec3cb227ba152e15c07d66855fa8ae6ca536e689205c0e2e9; //keccak256(\"STRGetter\")\r\n    bytes32 constant IS_FEE_IN_POLY = 0x7152e5426955da44af11ecd67fec5e2a3ba747be974678842afa9394b9a075b6; //keccak256(\"IS_FEE_IN_POLY\")\r\n    bytes32 constant ACTIVE_USERS = 0x425619ce6ba8e9f80f17c0ef298b6557e321d70d7aeff2e74dd157bd87177a9e; //keccak256(\"activeUsers\")\r\n    bytes32 constant LATEST_VERSION = 0x4c63b69b9117452b9f11af62077d0cda875fb4e2dbe07ad6f31f728de6926230; //keccak256(\"latestVersion\")\r\n\r\n    string constant POLY_ORACLE = \"StablePolyUsdOracle\";\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(address account);\r\n    // Emit when network becomes unpaused\r\n    event Unpause(address account);\r\n    // Emit when the ticker is removed from the registry\r\n    event TickerRemoved(string _ticker, address _removedBy);\r\n    // Emit when the token ticker expiry is changed\r\n    event ChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\r\n    // Emit when changeSecurityLaunchFee is called\r\n    event ChangeSecurityLaunchFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when changeTickerRegistrationFee is called\r\n    event ChangeTickerRegistrationFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when Fee currency is changed\r\n    event ChangeFeeCurrency(bool _isFeeInPoly);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    // Emit when ownership of the ticker gets changed\r\n    event ChangeTickerOwnership(string _ticker, address indexed _oldOwner, address indexed _newOwner);\r\n    // Emit at the time of launching a new security token of version 3.0+\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _usdFee,\r\n        uint256 _polyFee,\r\n        uint256 _protocolVersion\r\n    );\r\n    // Emit at the time of launching a new security token v2.0.\r\n    // _registrationFee is in poly\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit after ticker registration\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFeePoly,\r\n        uint256 _registrationFeeUsd\r\n    );\r\n    // For backwards compatibility\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        string _name,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit at when issuer refreshes exisiting token\r\n    event SecurityTokenRefreshed(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        uint256 _protocolVersion\r\n    );\r\n    event ProtocolFactorySet(address indexed _STFactory, uint8 _major, uint8 _minor, uint8 _patch);\r\n    event LatestVersionSet(uint8 _major, uint8 _minor, uint8 _patch);\r\n    event ProtocolFactoryRemoved(address indexed _STFactory, uint8 _major, uint8 _minor, uint8 _patch);\r\n    /////////////////////////////\r\n    // Modifiers\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() internal view {\r\n        require(msg.sender == owner(), \"Only owner\");\r\n    }\r\n\r\n    modifier onlyOwnerOrSelf() {\r\n        require(msg.sender == owner() || msg.sender == address(this), \"Only owner or self\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPausedOrOwner() {\r\n        _whenNotPausedOrOwner();\r\n        _;\r\n    }\r\n\r\n    function _whenNotPausedOrOwner() internal view {\r\n        if (msg.sender != owner()) {\r\n            require(!isPaused(), \"Paused\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused and ignore is msg.sender is owner.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!isPaused(), \"Paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(isPaused(), \"Not paused\");\r\n        _;\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Initialization\r\n    /////////////////////////////\r\n\r\n    // Constructor\r\n    constructor() public {\r\n        set(INITIALIZE, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes instance of STR\r\n     * @param _polymathRegistry is the address of the Polymath Registry\r\n     * @param _stLaunchFee is the fee in USD required to launch a token\r\n     * @param _tickerRegFee is the fee in USD required to register a ticker\r\n     * @param _owner is the owner of the STR,\r\n     * @param _getterContract Contract address of the contract which consists getter functions.\r\n     */\r\n    function initialize(\r\n        address _polymathRegistry,\r\n        uint256 _stLaunchFee,\r\n        uint256 _tickerRegFee,\r\n        address _owner,\r\n        address _getterContract\r\n    )\r\n        public\r\n    {\r\n        require(!getBoolValue(INITIALIZE),\"Initialized\");\r\n        require(\r\n            _owner != address(0) && _polymathRegistry != address(0) && _getterContract != address(0),\r\n            \"Invalid address\"\r\n        );\r\n        set(STLAUNCHFEE, _stLaunchFee);\r\n        set(TICKERREGFEE, _tickerRegFee);\r\n        set(EXPIRYLIMIT, uint256(60 * 1 days));\r\n        set(PAUSED, false);\r\n        set(OWNER, _owner);\r\n        set(POLYMATHREGISTRY, _polymathRegistry);\r\n        set(INITIALIZE, true);\r\n        set(STRGETTER, _getterContract);\r\n        _updateFromRegistry();\r\n    }\r\n\r\n    /**\r\n     * @notice Used to update the polyToken contract address\r\n     */\r\n    function updateFromRegistry() external onlyOwner {\r\n        _updateFromRegistry();\r\n    }\r\n\r\n    function _updateFromRegistry() internal {\r\n        address polymathRegistry = getAddressValue(POLYMATHREGISTRY);\r\n        set(POLYTOKEN, IPolymathRegistry(polymathRegistry).getAddress(\"PolyToken\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Converts USD fees into POLY amounts\r\n     */\r\n    function _takeFee(bytes32 _feeType) internal returns (uint256, uint256) {\r\n        (uint256 usdFee, uint256 polyFee) = getFees(_feeType);\r\n        if (polyFee > 0)\r\n            require(IERC20(getAddressValue(POLYTOKEN)).transferFrom(msg.sender, address(this), polyFee), \"Insufficent allowance\");\r\n        return (usdFee, polyFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the usd & poly fee for a particular feetype\r\n     * @param _feeType Key corresponding to fee type\r\n     */\r\n    function getFees(bytes32 _feeType) public returns (uint256 usdFee, uint256 polyFee) {\r\n        bool isFeesInPoly = getBoolValue(IS_FEE_IN_POLY);\r\n        uint256 rawFee = getUintValue(_feeType);\r\n        address polymathRegistry = getAddressValue(POLYMATHREGISTRY);\r\n        uint256 polyRate = IOracle(IPolymathRegistry(polymathRegistry).getAddress(POLY_ORACLE)).getPrice();\r\n        if (!isFeesInPoly) { //Fee is in USD and not poly\r\n            usdFee = rawFee;\r\n            polyFee = DecimalMath.div(rawFee, polyRate);\r\n        } else {\r\n            usdFee = DecimalMath.mul(rawFee, polyRate);\r\n            polyFee = rawFee;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the security token launch fee\r\n     * @return Fee amount\r\n     */\r\n    function getSecurityTokenLaunchFee() public returns(uint256 polyFee) {\r\n        (, polyFee) = getFees(STLAUNCHFEE);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the ticker registration fee\r\n     * @return Fee amount\r\n     */\r\n    function getTickerRegistrationFee() public returns(uint256 polyFee) {\r\n        (, polyFee) = getFees(TICKERREGFEE);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the getter contract address\r\n     * @param _getterContract Address of the contract\r\n     */\r\n    function setGetterRegistry(address _getterContract) public onlyOwnerOrSelf {\r\n        require(_getterContract != address(0));\r\n        set(STRGETTER, _getterContract);\r\n    }\r\n\r\n    function _implementation() internal view returns(address) {\r\n        return getAddressValue(STRGETTER);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Token Ticker Management\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @notice Registers the token ticker to the selected owner\r\n     * @notice Once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner is address of the owner of the token\r\n     * @param _ticker is unique token ticker\r\n     */\r\n    function registerNewTicker(address _owner, string memory _ticker) public whenNotPausedOrOwner {\r\n        require(_owner != address(0), \"Bad address\");\r\n        require(bytes(_ticker).length > 0 && bytes(_ticker).length <= 10, \"Bad ticker\");\r\n        // Attempt to charge the reg fee if it is > 0 USD\r\n        (uint256 usdFee, uint256 polyFee) = _takeFee(TICKERREGFEE);\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(tickerAvailable(ticker), \"Ticker reserved\");\r\n        // Check whether ticker was previously registered (and expired)\r\n        address previousOwner = _tickerOwner(ticker);\r\n        if (previousOwner != address(0)) {\r\n            _deleteTickerOwnership(previousOwner, ticker);\r\n        }\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        _addTicker(_owner, ticker, now, now.add(getUintValue(EXPIRYLIMIT)), false, false, polyFee, usdFee);\r\n    }\r\n\r\n    /**\r\n     * @dev This function is just for backwards compatibility\r\n     */\r\n    function registerTicker(address _owner, string calldata _ticker, string calldata _tokenName) external {\r\n        registerNewTicker(_owner, _ticker);\r\n        (, uint256 polyFee) = getFees(TICKERREGFEE);\r\n        emit RegisterTicker(_owner, _ticker, _tokenName, now, now.add(getUintValue(EXPIRYLIMIT)), false, polyFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Sets the details of the ticker\r\n     */\r\n    function _addTicker(\r\n        address _owner,\r\n        string memory _ticker,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status,\r\n        bool _fromAdmin,\r\n        uint256 _polyFee,\r\n        uint256 _usdFee\r\n    )\r\n        internal\r\n    {\r\n        _setTickerOwnership(_owner, _ticker);\r\n        _storeTickerDetails(_ticker, _owner, _registrationDate, _expiryDate, _status);\r\n        emit RegisterTicker(_owner, _ticker, _registrationDate, _expiryDate, _fromAdmin, _polyFee, _usdFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only Polymath has the ability to do so.\r\n     * @notice Only allowed to modify the tickers which are not yet deployed.\r\n     * @param _owner is the owner of the token\r\n     * @param _ticker is the token ticker\r\n     * @param _registrationDate is the date at which ticker is registered\r\n     * @param _expiryDate is the expiry date for the ticker\r\n     * @param _status is the token deployment status\r\n     */\r\n    function modifyExistingTicker(\r\n        address _owner,\r\n        string memory _ticker,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(bytes(_ticker).length > 0 && bytes(_ticker).length <= 10, \"Bad ticker\");\r\n        require(_expiryDate != 0 && _registrationDate != 0, \"Bad dates\");\r\n        require(_registrationDate <= _expiryDate, \"Bad dates\");\r\n        require(_owner != address(0), \"Bad address\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        _modifyTicker(_owner, ticker, _registrationDate, _expiryDate, _status);\r\n    }\r\n\r\n    /**\r\n     * @dev This function is just for backwards compatibility\r\n     */\r\n    function modifyTicker(\r\n        address _owner,\r\n        string calldata _ticker,\r\n        string calldata _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        external\r\n    {\r\n        modifyExistingTicker(_owner, _ticker, _registrationDate, _expiryDate, _status);\r\n        emit RegisterTicker(_owner, _ticker, _tokenName, now, now.add(getUintValue(EXPIRYLIMIT)), false, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal -- Modifies the ticker details.\r\n     */\r\n    function _modifyTicker(\r\n        address _owner,\r\n        string memory _ticker,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        internal\r\n    {\r\n        address currentOwner = _tickerOwner(_ticker);\r\n        if (currentOwner != address(0)) {\r\n            _deleteTickerOwnership(currentOwner, _ticker);\r\n        }\r\n        if (_tickerStatus(_ticker) && !_status) {\r\n            set(Encoder.getKey(\"tickerToSecurityToken\", _ticker), address(0));\r\n        }\r\n        // If status is true, there must be a security token linked to the ticker already\r\n        if (_status) {\r\n            require(getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", _ticker)) != address(0), \"Not registered\");\r\n        }\r\n        _addTicker(_owner, _ticker, _registrationDate, _expiryDate, _status, true, uint256(0), uint256(0));\r\n    }\r\n\r\n    function _tickerOwner(string memory _ticker) internal view returns(address) {\r\n        return getAddressValue(Encoder.getKey(\"registeredTickers_owner\", _ticker));\r\n    }\r\n\r\n    /**\r\n     * @notice Removes the ticker details, associated ownership & security token mapping\r\n     * @param _ticker is the token ticker\r\n     */\r\n    function removeTicker(string memory _ticker) public onlyOwner {\r\n        string memory ticker = Util.upper(_ticker);\r\n        address owner = _tickerOwner(ticker);\r\n        require(owner != address(0), \"Bad ticker\");\r\n        _deleteTickerOwnership(owner, ticker);\r\n        set(Encoder.getKey(\"tickerToSecurityToken\", ticker), address(0));\r\n        _storeTickerDetails(ticker, address(0), 0, 0, false);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit TickerRemoved(ticker, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the entered ticker is registered and has not expired\r\n     * @param _ticker is the token ticker\r\n     * @return bool\r\n     */\r\n    function tickerAvailable(string memory _ticker) public view returns(bool) {\r\n        if (_tickerOwner(_ticker) != address(0)) {\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            if ((now > getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", _ticker))) && !_tickerStatus(_ticker)) {\r\n                return true;\r\n            } else return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _tickerStatus(string memory _ticker) internal view returns(bool) {\r\n        return getBoolValue(Encoder.getKey(\"registeredTickers_status\", _ticker));\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Sets the ticker owner\r\n     * @param _owner is the address of the owner of the ticker\r\n     * @param _ticker is the ticker symbol\r\n     */\r\n    function _setTickerOwnership(address _owner, string memory _ticker) internal {\r\n        bytes32 _ownerKey = Encoder.getKey(\"userToTickers\", _owner);\r\n        uint256 length = uint256(getArrayBytes32(_ownerKey).length);\r\n        pushArray(_ownerKey, Util.stringToBytes32(_ticker));\r\n        set(Encoder.getKey(\"tickerIndex\", _ticker), length);\r\n        bytes32 seenKey = Encoder.getKey(\"seenUsers\", _owner);\r\n        if (!getBoolValue(seenKey)) {\r\n            pushArray(ACTIVE_USERS, _owner);\r\n            set(seenKey, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Stores the ticker details\r\n     */\r\n    function _storeTickerDetails(\r\n        string memory _ticker,\r\n        address _owner,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        internal\r\n    {\r\n        bytes32 key = Encoder.getKey(\"registeredTickers_owner\", _ticker);\r\n        set(key, _owner);\r\n        key = Encoder.getKey(\"registeredTickers_registrationDate\", _ticker);\r\n        set(key, _registrationDate);\r\n        key = Encoder.getKey(\"registeredTickers_expiryDate\", _ticker);\r\n        set(key, _expiryDate);\r\n        key = Encoder.getKey(\"registeredTickers_status\", _ticker);\r\n        set(key, _status);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers the ownership of the ticker\r\n     * @param _newOwner is the address of the new owner of the ticker\r\n     * @param _ticker is the ticker symbol\r\n     */\r\n    function transferTickerOwnership(address _newOwner, string memory _ticker) public whenNotPausedOrOwner {\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(_newOwner != address(0), \"Bad address\");\r\n        bytes32 ownerKey = Encoder.getKey(\"registeredTickers_owner\", ticker);\r\n        require(getAddressValue(ownerKey) == msg.sender, \"Only owner\");\r\n        if (_tickerStatus(ticker)) require(\r\n            IOwnable(getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", ticker))).owner() == _newOwner,\r\n            \"Owner mismatch\"\r\n        );\r\n        _deleteTickerOwnership(msg.sender, ticker);\r\n        _setTickerOwnership(_newOwner, ticker);\r\n        set(ownerKey, _newOwner);\r\n        emit ChangeTickerOwnership(ticker, msg.sender, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Removes the owner of a ticker\r\n     */\r\n    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {\r\n        uint256 index = uint256(getUintValue(Encoder.getKey(\"tickerIndex\", _ticker)));\r\n        bytes32 ownerKey = Encoder.getKey(\"userToTickers\", _owner);\r\n        bytes32[] memory tickers = getArrayBytes32(ownerKey);\r\n        assert(index < tickers.length);\r\n        assert(_tickerOwner(_ticker) == _owner);\r\n        deleteArrayBytes32(ownerKey, index);\r\n        if (getArrayBytes32(ownerKey).length > index) {\r\n            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];\r\n            set(Encoder.getKey(\"tickerIndex\", Util.bytes32ToString(switchedTicker)), index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the expiry time for the token ticker. Only available to Polymath.\r\n     * @param _newExpiry is the new expiry for newly generated tickers\r\n     */\r\n    function changeExpiryLimit(uint256 _newExpiry) public onlyOwner {\r\n        require(_newExpiry >= 1 days, \"Bad dates\");\r\n        emit ChangeExpiryLimit(getUintValue(EXPIRYLIMIT), _newExpiry);\r\n        set(EXPIRYLIMIT, _newExpiry);\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Security Token Management\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token of version 2.0 and records it to the registry\r\n     * @dev this function is for backwards compatibilty with 2.0 dApp.\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function generateSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible\r\n    )\r\n        external\r\n    {\r\n        generateNewSecurityToken(_name, _ticker, _tokenDetails, _divisible, msg.sender, VersionUtils.pack(2, 0, 0));\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and records it to the registry\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     * @param _treasuryWallet Ethereum address which will holds the STs.\r\n     * @param _protocolVersion Version of securityToken contract\r\n     * - `_protocolVersion` is the packed value of uin8[3] array (it will be calculated offchain)\r\n     * - if _protocolVersion == 0 then latest version of securityToken will be generated\r\n     */\r\n    function generateNewSecurityToken(\r\n        string memory _name,\r\n        string memory _ticker,\r\n        string memory _tokenDetails,\r\n        bool _divisible,\r\n        address _treasuryWallet,\r\n        uint256 _protocolVersion\r\n    )\r\n        public\r\n        whenNotPausedOrOwner\r\n    {\r\n        require(bytes(_name).length > 0 && bytes(_ticker).length > 0, \"Bad ticker\");\r\n        require(_treasuryWallet != address(0), \"0x0 not allowed\");\r\n        if (_protocolVersion == 0) {\r\n            _protocolVersion = getUintValue(LATEST_VERSION);\r\n        }\r\n        _ticker = Util.upper(_ticker);\r\n        bytes32 statusKey = Encoder.getKey(\"registeredTickers_status\", _ticker);\r\n        require(!getBoolValue(statusKey), \"Already deployed\");\r\n        set(statusKey, true);\r\n        address issuer = msg.sender;\r\n        require(_tickerOwner(_ticker) == issuer, \"Not authorised\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", _ticker)) >= now, \"Ticker expired\");\r\n        (uint256 _usdFee, uint256 _polyFee) = _takeFee(STLAUNCHFEE);\r\n        address newSecurityTokenAddress =\r\n            _deployToken(_name, _ticker, _tokenDetails, issuer, _divisible, _treasuryWallet, _protocolVersion);\r\n        if (_protocolVersion == VersionUtils.pack(2, 0, 0)) {\r\n            // For backwards compatibilty. Should be removed with an update when we disable st 2.0 generation.\r\n            emit NewSecurityToken(\r\n                _ticker, _name, newSecurityTokenAddress, issuer, now, issuer, false, _polyFee\r\n            );\r\n        } else {\r\n            emit NewSecurityToken(\r\n                _ticker, _name, newSecurityTokenAddress, issuer, now, issuer, false, _usdFee, _polyFee, _protocolVersion\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and replaces the old one in the registry\r\n     * This can be used to upgrade from version 2.0 of ST to 3.0 or in case something goes wrong with earlier ST\r\n     * @dev This function needs to be in STR 3.0. Defined public to avoid stack overflow\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function refreshSecurityToken(\r\n        string memory _name,\r\n        string memory _ticker,\r\n        string memory _tokenDetails,\r\n        bool _divisible,\r\n        address _treasuryWallet\r\n    )\r\n        public whenNotPausedOrOwner returns (address)\r\n    {\r\n        require(bytes(_name).length > 0 && bytes(_ticker).length > 0, \"Bad ticker\");\r\n        require(_treasuryWallet != address(0), \"0x0 not allowed\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(_tickerStatus(ticker), \"not deployed\");\r\n        address st = getAddressValue(Encoder.getKey(\"tickerToSecurityToken\", ticker));\r\n        address stOwner = IOwnable(st).owner();\r\n        require(msg.sender == stOwner, \"Unauthroized\");\r\n        require(ISecurityToken(st).transfersFrozen(), \"Transfers not frozen\");\r\n        uint256 protocolVersion = getUintValue(LATEST_VERSION);\r\n        address newSecurityTokenAddress =\r\n            _deployToken(_name, ticker, _tokenDetails, stOwner, _divisible, _treasuryWallet, protocolVersion);\r\n        emit SecurityTokenRefreshed(\r\n            _ticker, _name, newSecurityTokenAddress, stOwner, now, stOwner, protocolVersion\r\n        );\r\n    }\r\n\r\n    function _deployToken(\r\n        string memory _name,\r\n        string memory _ticker,\r\n        string memory _tokenDetails,\r\n        address _issuer,\r\n        bool _divisible,\r\n        address _wallet,\r\n        uint256 _protocolVersion\r\n    )\r\n        internal\r\n        returns(address newSecurityTokenAddress)\r\n    {\r\n        // In v2.x of STFactory, the final argument to deployToken is the PolymathRegistry.\r\n        // In v3.x of STFactory, the final argument to deployToken is the Treasury wallet.\r\n        uint8[] memory upperLimit = new uint8[](3);\r\n        upperLimit[0] = 2;\r\n        upperLimit[1] = 99;\r\n        upperLimit[2] = 99;\r\n        if (VersionUtils.lessThanOrEqual(VersionUtils.unpack(uint24(_protocolVersion)), upperLimit)) {\r\n            _wallet = getAddressValue(POLYMATHREGISTRY);\r\n        }\r\n\r\n        newSecurityTokenAddress = ISTFactory(getAddressValue(Encoder.getKey(\"protocolVersionST\", _protocolVersion))).deployToken(\r\n            _name,\r\n            _ticker,\r\n            18,\r\n            _tokenDetails,\r\n            _issuer,\r\n            _divisible,\r\n            _wallet\r\n        );\r\n\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        _storeSecurityTokenData(newSecurityTokenAddress, _ticker, _tokenDetails, now);\r\n        set(Encoder.getKey(\"tickerToSecurityToken\", _ticker), newSecurityTokenAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _owner is the owner of the token\r\n     * @param _securityToken is the address of the securityToken\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _deployedAt is the timestamp at which the security token is deployed\r\n     */\r\n    function modifyExistingSecurityToken(\r\n        string memory _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string memory _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(bytes(_ticker).length <= 10, \"Bad ticker\");\r\n        require(_deployedAt != 0 && _owner != address(0), \"Bad data\");\r\n        string memory ticker = Util.upper(_ticker);\r\n        require(_securityToken != address(0), \"Bad address\");\r\n        uint256 registrationTime = getUintValue(Encoder.getKey(\"registeredTickers_registrationDate\", ticker));\r\n        uint256 expiryTime = getUintValue(Encoder.getKey(\"registeredTickers_expiryDate\", ticker));\r\n        if (registrationTime == 0) {\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            registrationTime = now;\r\n            expiryTime = registrationTime.add(getUintValue(EXPIRYLIMIT));\r\n        }\r\n        set(Encoder.getKey(\"tickerToSecurityToken\", ticker), _securityToken);\r\n        _modifyTicker(_owner, ticker, registrationTime, expiryTime, true);\r\n        _storeSecurityTokenData(_securityToken, ticker, _tokenDetails, _deployedAt);\r\n        emit NewSecurityToken(\r\n            ticker, ISecurityToken(_securityToken).name(), _securityToken, _owner, _deployedAt, msg.sender, true, uint256(0), uint256(0), 0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev This function is just for backwards compatibility\r\n     */\r\n    function modifySecurityToken(\r\n        string calldata /* */,\r\n        string calldata _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string calldata _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        external\r\n    {\r\n        modifyExistingSecurityToken(_ticker, _owner, _securityToken, _tokenDetails, _deployedAt);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal - Stores the security token details\r\n     */\r\n    function _storeSecurityTokenData(\r\n        address _securityToken,\r\n        string memory _ticker,\r\n        string memory _tokenDetails,\r\n        uint256 _deployedAt\r\n    ) internal {\r\n        set(Encoder.getKey(\"securityTokens_ticker\", _securityToken), _ticker);\r\n        set(Encoder.getKey(\"securityTokens_tokenDetails\", _securityToken), _tokenDetails);\r\n        set(Encoder.getKey(\"securityTokens_deployedAt\", _securityToken), _deployedAt);\r\n    }\r\n\r\n    /**\r\n    * @notice Checks that Security Token is registered\r\n    * @param _securityToken is the address of the security token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) external view returns(bool) {\r\n        return (keccak256(bytes(getStringValue(Encoder.getKey(\"securityTokens_ticker\", _securityToken)))) != keccak256(\"\"));\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Ownership, lifecycle & Utility\r\n    /////////////////////////////\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"Bad address\");\r\n        emit OwnershipTransferred(getAddressValue(OWNER), _newOwner);\r\n        set(OWNER, _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() external whenNotPaused onlyOwner {\r\n        set(PAUSED, true);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() external whenPaused onlyOwner {\r\n        set(PAUSED, false);\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in USD tokens. Only Polymath.\r\n    * @param _tickerRegFee is the registration fee in USD tokens (base 18 decimals)\r\n    */\r\n    function changeTickerRegistrationFee(uint256 _tickerRegFee) public onlyOwner {\r\n        uint256 fee = getUintValue(TICKERREGFEE);\r\n        require(fee != _tickerRegFee, \"Bad fee\");\r\n        _changeTickerRegistrationFee(fee, _tickerRegFee);\r\n    }\r\n\r\n    function _changeTickerRegistrationFee(uint256 _oldFee, uint256 _newFee) internal {\r\n        emit ChangeTickerRegistrationFee(_oldFee, _newFee);\r\n        set(TICKERREGFEE, _newFee);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in USD tokens. Only Polymath.\r\n    * @param _stLaunchFee is the registration fee in USD tokens (base 18 decimals)\r\n    */\r\n    function changeSecurityLaunchFee(uint256 _stLaunchFee) public onlyOwner {\r\n        uint256 fee = getUintValue(STLAUNCHFEE);\r\n        require(fee != _stLaunchFee, \"Bad fee\");\r\n        _changeSecurityLaunchFee(fee, _stLaunchFee);\r\n    }\r\n\r\n    function _changeSecurityLaunchFee(uint256 _oldFee, uint256 _newFee) internal {\r\n        emit ChangeSecurityLaunchFee(_oldFee, _newFee);\r\n        set(STLAUNCHFEE, _newFee);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the ticker registration and ST launch fee amount and currency\r\n    * @param _tickerRegFee is the ticker registration fee (base 18 decimals)\r\n    * @param _stLaunchFee is the st generation fee (base 18 decimals)\r\n    * @param _isFeeInPoly defines if the fee is in poly or usd\r\n    */\r\n    function changeFeesAmountAndCurrency(uint256 _tickerRegFee, uint256 _stLaunchFee, bool _isFeeInPoly) public onlyOwner {\r\n        uint256 tickerFee = getUintValue(TICKERREGFEE);\r\n        uint256 stFee = getUintValue(STLAUNCHFEE);\r\n        bool isOldFeesInPoly = getBoolValue(IS_FEE_IN_POLY);\r\n        require(isOldFeesInPoly != _isFeeInPoly, \"Currency unchanged\");\r\n        _changeTickerRegistrationFee(tickerFee, _tickerRegFee);\r\n        _changeSecurityLaunchFee(stFee, _stLaunchFee);\r\n        emit ChangeFeeCurrency(_isFeeInPoly);\r\n        set(IS_FEE_IN_POLY, _isFeeInPoly);\r\n    }\r\n\r\n    /**\r\n    * @notice Reclaims all ERC20Basic compatible tokens\r\n    * @param _tokenContract is the address of the token contract\r\n    */\r\n    function reclaimERC20(address _tokenContract) public onlyOwner {\r\n        require(_tokenContract != address(0), \"Bad address\");\r\n        IERC20 token = IERC20(_tokenContract);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(owner(), balance), \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n    * @notice Changes the SecurityToken contract for a particular factory version\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _STFactoryAddress is the address of the proxy.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setProtocolFactory(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) public onlyOwner {\r\n        _setProtocolFactory(_STFactoryAddress, _major, _minor, _patch);\r\n    }\r\n\r\n    function _setProtocolFactory(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal {\r\n        require(_STFactoryAddress != address(0), \"Bad address\");\r\n        uint24 _packedVersion = VersionUtils.pack(_major, _minor, _patch);\r\n        address stFactoryAddress = getAddressValue(Encoder.getKey(\"protocolVersionST\", uint256(_packedVersion)));\r\n        require(stFactoryAddress == address(0), \"Already exists\");\r\n        set(Encoder.getKey(\"protocolVersionST\", uint256(_packedVersion)), _STFactoryAddress);\r\n        emit ProtocolFactorySet(_STFactoryAddress, _major, _minor, _patch);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes a STFactory\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function removeProtocolFactory(uint8 _major, uint8 _minor, uint8 _patch) public onlyOwner {\r\n        uint24 _packedVersion = VersionUtils.pack(_major, _minor, _patch);\r\n        require(getUintValue(LATEST_VERSION) != _packedVersion, \"Cannot remove latestVersion\");\r\n        emit ProtocolFactoryRemoved(getAddressValue(Encoder.getKey(\"protocolVersionST\", _packedVersion)), _major, _minor, _patch);\r\n        set(Encoder.getKey(\"protocolVersionST\", uint256(_packedVersion)), address(0));\r\n    }\r\n\r\n    /**\r\n    * @notice Changes the default protocol version\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setLatestVersion(uint8 _major, uint8 _minor, uint8 _patch) public onlyOwner {\r\n        _setLatestVersion(_major, _minor, _patch);\r\n    }\r\n\r\n    function _setLatestVersion(uint8 _major, uint8 _minor, uint8 _patch) internal {\r\n        uint24 _packedVersion = VersionUtils.pack(_major, _minor, _patch);\r\n        require(getAddressValue(Encoder.getKey(\"protocolVersionST\", _packedVersion)) != address(0), \"No factory\");\r\n        set(LATEST_VERSION, uint256(_packedVersion));\r\n        emit LatestVersionSet(_major, _minor, _patch);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the PolyToken address. Only Polymath.\r\n     * @param _newAddress is the address of the polytoken.\r\n     */\r\n    function updatePolyTokenAddress(address _newAddress) public onlyOwner {\r\n        require(_newAddress != address(0), \"Bad address\");\r\n        set(POLYTOKEN, _newAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the registry is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() public view returns(bool) {\r\n        return getBoolValue(PAUSED);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() public view returns(address) {\r\n        return getAddressValue(OWNER);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_STFactoryAddress\",\"type\":\"address\"},{\"name\":\"_major\",\"type\":\"uint8\"},{\"name\":\"_minor\",\"type\":\"uint8\"},{\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"setProtocolFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytes32Value\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_polymathRegistry\",\"type\":\"address\"},{\"name\":\"_stLaunchFee\",\"type\":\"uint256\"},{\"name\":\"_tickerRegFee\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_getterContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_registrationDate\",\"type\":\"uint256\"},{\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"modifyExistingTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_deployedAt\",\"type\":\"uint256\"}],\"name\":\"modifyExistingSecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExpiry\",\"type\":\"uint256\"}],\"name\":\"changeExpiryLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenName\",\"type\":\"string\"}],\"name\":\"registerTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_divisible\",\"type\":\"bool\"},{\"name\":\"_treasuryWallet\",\"type\":\"address\"},{\"name\":\"_protocolVersion\",\"type\":\"uint256\"}],\"name\":\"generateNewSecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stLaunchFee\",\"type\":\"uint256\"}],\"name\":\"changeSecurityLaunchFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBytesValue\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getAddressValue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_getterContract\",\"type\":\"address\"}],\"name\":\"setGetterRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_deployedAt\",\"type\":\"uint256\"}],\"name\":\"modifySecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getArrayAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_divisible\",\"type\":\"bool\"},{\"name\":\"_treasuryWallet\",\"type\":\"address\"}],\"name\":\"refreshSecurityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getBoolValue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_registrationDate\",\"type\":\"uint256\"},{\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"modifyTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickerRegFee\",\"type\":\"uint256\"}],\"name\":\"changeTickerRegistrationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"removeTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getStringValue\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getArrayBytes32\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"tickerAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_major\",\"type\":\"uint8\"},{\"name\":\"_minor\",\"type\":\"uint8\"},{\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"removeProtocolFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_major\",\"type\":\"uint8\"},{\"name\":\"_minor\",\"type\":\"uint8\"},{\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"setLatestVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"registerNewTicker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeType\",\"type\":\"bytes32\"}],\"name\":\"getFees\",\"outputs\":[{\"name\":\"usdFee\",\"type\":\"uint256\"},{\"name\":\"polyFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_divisible\",\"type\":\"bool\"}],\"name\":\"generateSecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getSecurityTokenLaunchFee\",\"outputs\":[{\"name\":\"polyFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"transferTickerOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"}],\"name\":\"isSecurityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickerRegFee\",\"type\":\"uint256\"},{\"name\":\"_stLaunchFee\",\"type\":\"uint256\"},{\"name\":\"_isFeeInPoly\",\"type\":\"bool\"}],\"name\":\"changeFeesAmountAndCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getTickerRegistrationFee\",\"outputs\":[{\"name\":\"polyFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updatePolyTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_variable\",\"type\":\"bytes32\"}],\"name\":\"getUintValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateFromRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getArrayUint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_removedBy\",\"type\":\"address\"}],\"name\":\"TickerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldExpiry\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newExpiry\",\"type\":\"uint256\"}],\"name\":\"ChangeExpiryLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"ChangeSecurityLaunchFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"ChangeTickerRegistrationFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_isFeeInPoly\",\"type\":\"bool\"}],\"name\":\"ChangeFeeCurrency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeTickerOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_securityTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_addedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_registrant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fromAdmin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_usdFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_polyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_protocolVersion\",\"type\":\"uint256\"}],\"name\":\"NewSecurityToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_securityTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_addedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_registrant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fromAdmin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_registrationFee\",\"type\":\"uint256\"}],\"name\":\"NewSecurityToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_registrationDate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fromAdmin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_registrationFeePoly\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_registrationFeeUsd\",\"type\":\"uint256\"}],\"name\":\"RegisterTicker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_registrationDate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_expiryDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fromAdmin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_registrationFee\",\"type\":\"uint256\"}],\"name\":\"RegisterTicker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_securityTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_addedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_registrant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_protocolVersion\",\"type\":\"uint256\"}],\"name\":\"SecurityTokenRefreshed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_STFactory\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_major\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_minor\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"ProtocolFactorySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_major\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_minor\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"LatestVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_STFactory\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_major\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_minor\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_patch\",\"type\":\"uint8\"}],\"name\":\"ProtocolFactoryRemoved\",\"type\":\"event\"}]","ContractName":"SecurityTokenRegistry","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://940b7afd6d6f64b6706a93b93d79bea9f1b38d55a519e06113e3ce00c18a2d2a"}]}