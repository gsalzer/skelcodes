{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IToken is ERC20 {\r\n    // note: we use external visibility for all non-standard functions \r\n    // (which are not used internally) \r\n\r\n    function reclaimToken(ERC20Basic _token, address _to) external;\r\n\r\n    function setMaxTransferGasPrice(uint newGasPrice) external;\r\n\r\n    // TAP whitelisting functions\r\n    function whitelist(address TAP) external;\r\n    function deWhitelist(address TAP) external;\r\n\r\n    function setTransferFeeNumerator(uint newTransferFeeNumerator) external;\r\n\r\n    // transfer blacklist functions\r\n    function blacklist(address a) external;\r\n    function deBlacklist(address a) external;\r\n\r\n    // seizing function\r\n    function seize(address a) external;\r\n\r\n    // rebalance functions\r\n    function rebalance(bool deducts, uint tokensAmount) external;\r\n\r\n    // transfer fee functions\r\n    function disableFee(address a) external;\r\n    function enableFee(address a) external;\r\n    function computeFee(uint amount) public view returns(uint);\r\n\r\n    // to disable\r\n    function renounceOwnership() public;\r\n\r\n    // mintable\r\n    event Mint(address indexed to, uint amount);\r\n    function mint(address _to, uint _amount) public returns(bool);\r\n    // to disable\r\n    function finishMinting() public returns (bool);\r\n\r\n    // burnable\r\n    event Burn(address indexed burner, uint value);\r\n    // burn is only available through the transfer function\r\n    function burn(uint _value) public;\r\n\r\n    // pausable\r\n    function pause() public;\r\n    function unpause() public;\r\n\r\n    // ownable\r\n    function transferOwnership(address newOwner) public;\r\n    function transferSuperownership(address newOwner) external; // external for consistency reasons\r\n\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool);\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    hasMintPermission\r\n    canMint\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public onlyOwner canMint returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract Token is IToken, PausableToken, BurnableToken, MintableToken, DetailedERC20 {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for ERC20Basic;\r\n\r\n    // scaling factor\r\n    uint public scaleFactor = 10 ** 18;\r\n    mapping(address => uint) internal lastScalingFactor;\r\n\r\n    // maximum percent of scaling of balances\r\n    uint constant internal MAX_REBALANCE_PERCENT = 5;\r\n\r\n    // gas price\r\n    // deactivate the limit at deployment: set it to the maximum integer\r\n    uint public maxTransferGasPrice = uint(-1);\r\n    event TransferGasPrice(uint oldGasPrice, uint newGasPrice);\r\n\r\n    // transfer fee is computed as:\r\n    // regular transfer amount * transferFeeNumerator / TRANSFER_FEE_DENOMINATOR\r\n    uint public transferFeeNumerator = 0;\r\n    uint constant internal MAX_NUM_DISABLED_FEES = 100;\r\n    uint constant internal MAX_FEE_PERCENT = 5;\r\n    uint constant internal TRANSFER_FEE_DENOMINATOR = 10 ** 18;\r\n    mapping(address => bool) public avoidsFees;\r\n    address[] public avoidsFeesArray;\r\n    event TransferFeeNumerator(uint oldNumerator, uint newNumerator);\r\n    event TransferFeeDisabled(address indexed account);\r\n    event TransferFeeEnabled(address indexed account);\r\n    event TransferFee(\r\n        address indexed to,\r\n        AccountClassification\r\n        fromAccountClassification,\r\n        uint amount\r\n    );\r\n\r\n    // whitelisted TAPs\r\n    mapping(address => bool) public TAPwhiteListed;\r\n    event TAPWhiteListed(address indexed TAP);\r\n    event TAPDeWhiteListed(address indexed TAP);\r\n\r\n    // blacklisted Accounts\r\n    mapping(address => bool) public transferBlacklisted;\r\n    event TransferBlacklisted(address indexed account);\r\n    event TransferDeBlacklisted(address indexed account);\r\n\r\n    // seized funds\r\n    event FundsSeized(\r\n        address indexed account,\r\n        AccountClassification fromAccountClassification,\r\n        uint amount\r\n    );\r\n\r\n    // extended transfer event\r\n    enum AccountClassification {Zero, Owner, Superowner, TAP, Other} // Enum\r\n    // block accounts with classification Other\r\n    bool public blockOtherAccounts;\r\n    event TransferExtd(\r\n        address indexed from,\r\n        AccountClassification fromAccountClassification,\r\n        address indexed to,\r\n        AccountClassification toAccountClassification,\r\n        uint amount\r\n    );\r\n    event BlockOtherAccounts(bool isEnabled);\r\n\r\n    // rebalancing event\r\n    event Rebalance(\r\n        bool deducts,\r\n        uint amount,\r\n        uint oldScaleFactor,\r\n        uint newScaleFactor,\r\n        uint oldTotalSupply,\r\n        uint newTotalSupply\r\n    );\r\n\r\n    // additional owner\r\n    address public superowner;\r\n    event SuperownershipTransferred(address indexed previousOwner,\r\n      address indexed newOwner);\r\n    mapping(address => bool) public usedOwners;\r\n\r\n    constructor(\r\n      string name,\r\n      string symbol,\r\n      uint8 decimals,\r\n      address _superowner\r\n    )\r\n    public DetailedERC20(name, symbol, decimals)\r\n    {\r\n        require(_superowner != address(0), \"superowner is not the zero address\");\r\n        superowner = _superowner;\r\n        usedOwners[owner] = true;\r\n        usedOwners[superowner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender),  \"sender is owner or superowner\");\r\n        _;\r\n    }\r\n\r\n    modifier hasMintPermission() {\r\n        require(isOwner(msg.sender),  \"sender is owner or superowner\");\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address account) {\r\n        require(account != address(0), \"account is not the zero address\");\r\n        _;\r\n    }\r\n\r\n    modifier limitGasPrice() {\r\n        require(tx.gasprice <= maxTransferGasPrice, \"gasprice is less than its upper bound\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reclaim all ERC20Basic compatible tokens that have been sent by mistake to this\r\n     * contract\r\n     * @param _token ERC20Basic The address of the token contract\r\n     * @param _to The address of the recipient of the tokens\r\n     */\r\n    function reclaimToken(ERC20Basic _token, address _to) external onlyOwner {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        _token.safeTransfer(_to, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Setter of max transfer gas price\r\n     * @param newGasPrice the new gas price\r\n     */\r\n    function setMaxTransferGasPrice(uint newGasPrice) external onlyOwner {\r\n        require(newGasPrice != 0, \"gas price limit cannot be null\");\r\n        emit TransferGasPrice(maxTransferGasPrice, newGasPrice);\r\n        maxTransferGasPrice = newGasPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Whitelist an address as a TAP to which tokens can be minted\r\n     * @param TAP The address to whitelist\r\n     */\r\n    function whitelist(address TAP) external nonZeroAddress(TAP) onlyOwner {\r\n        require(!isOwner(TAP), \"TAP is not owner or superowner\");\r\n        require(!TAPwhiteListed[TAP], \"TAP cannot be whitlisted\");\r\n        emit TAPWhiteListed(TAP);\r\n        TAPwhiteListed[TAP] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Dewhitelist an address as a TAP\r\n     * @param TAP The address to dewhitelist\r\n     */\r\n    function deWhitelist(address TAP) external nonZeroAddress(TAP) onlyOwner {\r\n        require(TAPwhiteListed[TAP], \"TAP is whitlisted\");\r\n        emit TAPDeWhiteListed(TAP);\r\n        TAPwhiteListed[TAP] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the transfer fee numerator\r\n     * @param newTransferFeeNumerator The new transfer fee numerator\r\n     */\r\n    function setTransferFeeNumerator(uint newTransferFeeNumerator) external onlyOwner {\r\n        require(newTransferFeeNumerator <= TRANSFER_FEE_DENOMINATOR.mul(MAX_FEE_PERCENT).div(100),\r\n            \"transfer fee numerator is less than its upper bound\");\r\n        emit TransferFeeNumerator(transferFeeNumerator, newTransferFeeNumerator);\r\n        transferFeeNumerator = newTransferFeeNumerator;\r\n    }\r\n\r\n    /**\r\n     * @notice Blacklist an account to prevent their transfers\r\n     * @dev this function can be called while the contract is paused, to prevent blacklisting and\r\n     * front-running (by first pausing, then blacklisting)\r\n     * @param account The address to blacklist\r\n     */\r\n    function blacklist(address account) external nonZeroAddress(account) onlyOwner {\r\n        require(!transferBlacklisted[account], \"account is not blacklisted\");\r\n        emit TransferBlacklisted(account);\r\n        transferBlacklisted[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Deblacklist an account to allow their transfers once again\r\n     * @param account The address to deblacklist\r\n     */\r\n    function deBlacklist(address account) external nonZeroAddress(account) onlyOwner {\r\n        require(transferBlacklisted[account], \"account is blacklisted\");\r\n        emit TransferDeBlacklisted(account);\r\n        transferBlacklisted[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Seize all funds from a blacklisted account\r\n     * @param account The address to be seized\r\n     */\r\n    function seize(address account) external nonZeroAddress(account) onlyOwner {\r\n        require(transferBlacklisted[account], \"account has been blacklisted\");\r\n        updateBalanceAndScaling(account);\r\n        uint balance = balanceOf(account);\r\n        emit FundsSeized(account, getAccountClassification(account), balance);\r\n        super._burn(account, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice disable future transfer fees for an account\r\n     * @dev The fees owed before this function are paid here, via updateBalanceAndScaling.\r\n     * @param account The address which will avoid future transfer fees\r\n     */\r\n    function disableFee(address account) external nonZeroAddress(account) onlyOwner {\r\n        require(!avoidsFees[account], \"account has fees\");\r\n        require(avoidsFeesArray.length < MAX_NUM_DISABLED_FEES, \"array is not full\");\r\n        emit TransferFeeDisabled(account);\r\n        avoidsFees[account] = true;\r\n        avoidsFeesArray.push(account);\r\n    }\r\n\r\n    /**\r\n     * @notice enable future transfer fees for an account\r\n     * @param account The address which will pay future transfer fees\r\n     */\r\n    function enableFee(address account) external nonZeroAddress(account) onlyOwner {\r\n        require(avoidsFees[account], \"account avoids fees\");\r\n        emit TransferFeeEnabled(account);\r\n        avoidsFees[account] = false;\r\n        uint len = avoidsFeesArray.length;\r\n        assert(len != 0);\r\n        for (uint i = 0; i < len; i++) {\r\n            if (avoidsFeesArray[i] == account) {\r\n                avoidsFeesArray[i] = avoidsFeesArray[len.sub(1)];\r\n                avoidsFeesArray.length--;\r\n                return;\r\n            }\r\n        }\r\n        assert(false);\r\n    }\r\n\r\n    /**\r\n     * @notice rebalance changes the total supply by the given amount (either deducts or adds)\r\n     * by scaling all balance amounts proportionally (also those exempt from fees)\r\n     * @dev this uses the current total supply (which is the sum of all token balances excluding\r\n     * the inventory, i.e., the balances of owner and superowner) to compute the new scale factor\r\n     * @param deducts indication if we deduct or add token from total supply\r\n     * @param tokensAmount the number of tokens to add/deduct\r\n     */\r\n    function rebalance(bool deducts, uint tokensAmount) external onlyOwner {\r\n        uint oldTotalSupply = totalSupply();\r\n        uint oldScaleFactor = scaleFactor;\r\n\r\n        require(\r\n            tokensAmount <= oldTotalSupply.mul(MAX_REBALANCE_PERCENT).div(100),\r\n            \"tokensAmount is within limits\"\r\n        );\r\n\r\n        // new scale factor and total supply\r\n        uint newScaleFactor;\r\n        if (deducts) {\r\n            newScaleFactor = oldScaleFactor.mul(\r\n                oldTotalSupply.sub(tokensAmount)).div(oldTotalSupply\r\n            );\r\n        } else {\r\n            newScaleFactor = oldScaleFactor.mul(\r\n                oldTotalSupply.add(tokensAmount)).div(oldTotalSupply\r\n            );\r\n        }\r\n        // update scaleFactor\r\n        scaleFactor = newScaleFactor;\r\n\r\n        // update total supply\r\n        uint newTotalSupply = oldTotalSupply.mul(scaleFactor).div(oldScaleFactor);\r\n        totalSupply_ = newTotalSupply;\r\n\r\n        emit Rebalance(\r\n            deducts,\r\n            tokensAmount,\r\n            oldScaleFactor,\r\n            newScaleFactor,\r\n            oldTotalSupply,\r\n            newTotalSupply\r\n        );\r\n\r\n        if (deducts) {\r\n            require(newTotalSupply < oldTotalSupply, \"totalSupply shrinks\");\r\n            // avoid overly large rounding errors\r\n            assert(oldTotalSupply.sub(tokensAmount.mul(9).div(10)) >= newTotalSupply);\r\n            assert(oldTotalSupply.sub(tokensAmount.mul(11).div(10)) <= newTotalSupply);\r\n        } else {\r\n           require(newTotalSupply > oldTotalSupply, \"totalSupply grows\");\r\n           // avoid overly large rounding errors\r\n           assert(oldTotalSupply.add(tokensAmount.mul(9).div(10)) <= newTotalSupply);\r\n           assert(oldTotalSupply.add(tokensAmount.mul(11).div(10)) >= newTotalSupply);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice enable change of superowner\r\n     * @param _newSuperowner the address of the new owner\r\n     */\r\n    function transferSuperownership(\r\n        address _newSuperowner\r\n    )\r\n    external nonZeroAddress(_newSuperowner)\r\n    {\r\n        require(msg.sender == superowner, \"only superowner\");\r\n        require(!usedOwners[_newSuperowner], \"owner was not used before\");\r\n        usedOwners[_newSuperowner] = true;\r\n        uint value = balanceOf(superowner);\r\n        if (value > 0) {\r\n            super._burn(superowner, value);\r\n            emit TransferExtd(\r\n                superowner,\r\n                AccountClassification.Superowner,\r\n                address(0),\r\n                AccountClassification.Zero,\r\n                value\r\n            );\r\n        }\r\n        emit SuperownershipTransferred(superowner, _newSuperowner);\r\n        superowner = _newSuperowner;\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the regular amount of tokens of an account.\r\n     * @dev Gets the balance of the specified address.\r\n     * @param account The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address account) public view returns (uint) {\r\n        uint amount = balances[account];\r\n        uint oldScaleFactor = lastScalingFactor[account];\r\n        if (oldScaleFactor == 0) {\r\n            return 0;\r\n        } else if (oldScaleFactor == scaleFactor) {\r\n            return amount;\r\n        } else {\r\n            return amount.mul(scaleFactor).div(oldScaleFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the fee corresponding to a transfer not exempt from fees.\r\n     * @param amount The amount of the transfer\r\n     * @return the number of tokens to be paid as a fee\r\n     */\r\n    function computeFee(uint amount) public view returns (uint) {\r\n        return amount.mul(transferFeeNumerator).div(TRANSFER_FEE_DENOMINATOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the total outstanding of tokens (excluding those held by owner\r\n     * and superowner, i.e., the inventory accounts).\r\n     * @dev function to get the total supply excluding inventory\r\n     * @return The uint total supply excluding inventory\r\n     */\r\n    function totalSupply() public view returns(uint) {\r\n        uint inventory = balanceOf(owner);\r\n        if (owner != superowner) {\r\n            inventory = inventory.add(balanceOf(superowner));\r\n        }\r\n        return (super.totalSupply().sub(inventory));\r\n    }\r\n\r\n    /**\r\n     * @notice enable change of owner\r\n     * @param _newOwner the address of the new owner\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(!usedOwners[_newOwner], \"owner was not used before\");\r\n        usedOwners[_newOwner] = true;\r\n        uint value = balanceOf(owner);\r\n        if (value > 0) {\r\n            super._burn(owner, value);\r\n            emit TransferExtd(\r\n                owner,\r\n                AccountClassification.Owner,\r\n                address(0),\r\n                AccountClassification.Zero,\r\n                value\r\n            );\r\n        }\r\n        super.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Wrapper around OZ's increaseApproval\r\n     * @dev Update the corresponding balance and scaling before increasing approval\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     * @return true in case of success\r\n     */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n    public whenNotPaused returns (bool)\r\n    {\r\n        updateBalanceAndScaling(msg.sender);\r\n        updateBalanceAndScaling(_spender);\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Wrapper around OZ's decreaseApproval\r\n     * @dev Update the corresponding balance and scaling before decreasing approval\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     * @return true in case of success\r\n     */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n    public whenNotPaused returns (bool)\r\n    {\r\n        updateBalanceAndScaling(msg.sender);\r\n        updateBalanceAndScaling(_spender);\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred, from which the transfer fee will be deducted\r\n     * @return true in case of success\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint _value\r\n    )\r\n    public whenNotPaused limitGasPrice returns (bool)\r\n    {\r\n        require(!transferBlacklisted[msg.sender], \"sender is not blacklisted\");\r\n        require(!transferBlacklisted[_to], \"to address is not blacklisted\");\r\n        require(!blockOtherAccounts ||\r\n            (getAccountClassification(msg.sender) != AccountClassification.Other &&\r\n            getAccountClassification(_to) != AccountClassification.Other),\r\n            \"addresses are not blocked\");\r\n\r\n        emit TransferExtd(\r\n            msg.sender,\r\n            getAccountClassification(msg.sender),\r\n            _to,\r\n            getAccountClassification(_to),\r\n            _value\r\n        );\r\n\r\n        updateBalanceAndScaling(msg.sender);\r\n\r\n        if (_to == address(0)) {\r\n            // burn tokens\r\n            super.burn(_value);\r\n            return true;\r\n        }\r\n\r\n        updateBalanceAndScaling(_to);\r\n\r\n        require(super.transfer(_to, _value), \"transfer succeeds\");\r\n\r\n        if (!avoidsFees[msg.sender] && !avoidsFees[_to]) {\r\n            computeAndBurnFee(_to, _value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred, from which the transfer fee\r\n     * will be deducted\r\n     * @return true in case of success\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _value\r\n    )\r\n    public whenNotPaused limitGasPrice returns (bool)\r\n    {\r\n        require(!transferBlacklisted[msg.sender], \"sender is not blacklisted\");\r\n        require(!transferBlacklisted[_from], \"from address is not blacklisted\");\r\n        require(!transferBlacklisted[_to], \"to address is not blacklisted\");\r\n        require(!blockOtherAccounts ||\r\n            (getAccountClassification(_from) != AccountClassification.Other &&\r\n            getAccountClassification(_to) != AccountClassification.Other),\r\n            \"addresses are not blocked\");\r\n\r\n        emit TransferExtd(\r\n            _from,\r\n            getAccountClassification(_from),\r\n            _to,\r\n            getAccountClassification(_to),\r\n            _value\r\n        );\r\n\r\n        updateBalanceAndScaling(_from);\r\n\r\n        if (_to == address(0)) {\r\n            // burn tokens\r\n            super.transferFrom(_from, msg.sender, _value);\r\n            super.burn(_value);\r\n            return true;\r\n        }\r\n\r\n        updateBalanceAndScaling(_to);\r\n\r\n        require(super.transferFrom(_from, _to, _value), \"transfer succeeds\");\r\n\r\n        if (!avoidsFees[msg.sender] && !avoidsFees[_from] && !avoidsFees[_to]) {\r\n            computeAndBurnFee(_to, _value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\r\n     * msg.sender. Beware that changing an allowance with this method brings the risk that someone\r\n     * may use both the old and the new allowance by unfortunate transaction ordering. One\r\n     * possible solution to mitigate this race condition is to first reduce the spender's\r\n     * allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value Amount of tokens to be spent, from which the transfer fee will be deducted.\r\n     * @return true in case of success\r\n     */\r\n    function approve(address _spender, uint _value) public whenNotPaused returns (bool) {\r\n        updateBalanceAndScaling(_spender);\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Function for TAPs to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return true in case of success\r\n     */\r\n    function mint(address _to, uint _amount) public returns(bool) {\r\n        require(!transferBlacklisted[_to], \"to address is not blacklisted\");\r\n        require(!blockOtherAccounts || getAccountClassification(_to) != AccountClassification.Other,\r\n            \"to address is not blocked\");\r\n        updateBalanceAndScaling(_to);\r\n        emit TransferExtd(\r\n            address(0),\r\n            AccountClassification.Zero,\r\n            _to,\r\n            getAccountClassification(_to),\r\n            _amount\r\n        );\r\n        return super.mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice toggle allowOthterAccounts variable\r\n     */\r\n    function toggleBlockOtherAccounts() public onlyOwner {\r\n        blockOtherAccounts = !blockOtherAccounts;\r\n        emit BlockOtherAccounts(blockOtherAccounts);\r\n    }\r\n\r\n    // get AccountClassification of an account\r\n    function getAccountClassification(\r\n        address account\r\n    )\r\n    internal view returns(AccountClassification)\r\n    {\r\n        if (account == address(0)) {\r\n            return AccountClassification.Zero;\r\n        } else if (account == owner) {\r\n            return AccountClassification.Owner;\r\n        } else if (account == superowner) {\r\n            return AccountClassification.Superowner;\r\n        } else if (TAPwhiteListed[account]) {\r\n            return AccountClassification.TAP;\r\n        } else {\r\n            return AccountClassification.Other;\r\n        }\r\n    }\r\n\r\n    // check if account is an owner\r\n    function isOwner(address account) internal view returns (bool) {\r\n        return account == owner || account == superowner;\r\n    }\r\n\r\n    // update balance and scaleFactor\r\n    function updateBalanceAndScaling(address account) internal {\r\n        uint oldBalance = balances[account];\r\n        uint newBalance = balanceOf(account);\r\n        if (lastScalingFactor[account] != scaleFactor) {\r\n            lastScalingFactor[account] = scaleFactor;\r\n        }\r\n        if (oldBalance != newBalance) {\r\n            balances[account] = newBalance;\r\n        }\r\n    }\r\n\r\n    // compute and burn a transfer fee\r\n    function computeAndBurnFee(address _to, uint _value) internal {\r\n        uint fee = computeFee(_value);\r\n        if (fee > 0) {\r\n            _burn(_to, fee);\r\n            emit TransferFee(_to, getAccountClassification(_to), fee);\r\n        }\r\n    }\r\n\r\n    // disabled\r\n    function finishMinting() public returns (bool) {\r\n        require(false, \"is disabled\");\r\n        return false;\r\n    }\r\n\r\n    // disabled\r\n    function burn(uint /* _value */) public {\r\n        // burn is only available through the transfer function\r\n        require(false, \"is disabled\");\r\n    }\r\n\r\n    // disabled\r\n    function renounceOwnership() public {\r\n        require(false, \"is disabled\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newTransferFeeNumerator\",\"type\":\"uint256\"}],\"name\":\"setTransferFeeNumerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superowner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTransferGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"deBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"deducts\",\"type\":\"bool\"},{\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scaleFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockOtherAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TAP\",\"type\":\"address\"}],\"name\":\"deWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"avoidsFees\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usedOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TAP\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"avoidsFeesArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"enableFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"computeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"TAPwhiteListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSuperowner\",\"type\":\"address\"}],\"name\":\"transferSuperownership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleBlockOtherAccounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGasPrice\",\"type\":\"uint256\"}],\"name\":\"setMaxTransferGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"disableFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"seize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"_superowner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newGasPrice\",\"type\":\"uint256\"}],\"name\":\"TransferGasPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newNumerator\",\"type\":\"uint256\"}],\"name\":\"TransferFeeNumerator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TransferFeeDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TransferFeeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromAccountClassification\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"TAP\",\"type\":\"address\"}],\"name\":\"TAPWhiteListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"TAP\",\"type\":\"address\"}],\"name\":\"TAPDeWhiteListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TransferBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TransferDeBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromAccountClassification\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsSeized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromAccountClassification\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAccountClassification\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferExtd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"BlockOtherAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"deducts\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldScaleFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newScaleFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldTotalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SuperownershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000af025157567b14e6e91cf4e6276b0fcc4d18425b0000000000000000000000000000000000000000000000000000000000000004564742500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045647425000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://1a8c7483f970c5c0ccf8e2ed6a0d6164c6b39b7c417658061b8031a62383cfae"}]}