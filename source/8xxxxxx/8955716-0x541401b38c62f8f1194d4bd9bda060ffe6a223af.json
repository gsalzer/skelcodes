{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/*\r\n\r\n    modifications\r\n    le sc contient le nombre de parts, s'il est de type 2, et le total des parts\r\n  5/11   suppression de MaltaSafeTransferFrom car en backoffice chez nous\r\n  gaslimit  a augmenter à 3200000\r\n  12/11  ajout de uri dans buytoken\r\n  \t  constructor() ERC721Token(\"MonartAuctionity\", \"test\") public {\r\n\r\n  \r\n    */\r\n\r\n\t/* \r\n\t\tBig Thanks from the Document crew to chuckbergeron for providing \r\n\t\tthis template and Andrew Parker for creating the tutorial on building \r\n\t\tNFT's. Also, thanks to the ethereum team for providing the ERC721 standard. \r\n\t\tCode is Law! \r\n\t*/\r\n\r\n\t/**\r\n\t * @title SafeMath\r\n\t * @dev Math operations with safety checks that throw on error\r\n\t */\r\n\tlibrary SafeMath {\r\n\r\n\t  /**\r\n\t  * @dev Multiplies two numbers, throws on overflow.\r\n\t  */\r\n\t  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t  return 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * @dev Integer division of two numbers, truncating the quotient.\r\n\t  */\r\n\t  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t  */\r\n\t  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * @dev Adds two numbers, throws on overflow.\r\n\t  */\r\n\t  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t  }\r\n\t}\r\n\t\r\n\t/**\r\n\t* @title Helps contracts guard against reentrancy attacks.\r\n\t* @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n\t* @dev If you mark a function `nonReentrant`, you should also\r\n\t* mark it `external`.\r\n\t*/\r\n\tcontract ReentrancyGuard {\r\n\r\n\t/// @dev counter to allow mutex lock with only one SSTORE operation\r\n\tuint256 private guardCounter = 1;\r\n\r\n\t/**\r\n\t* @dev Prevents a contract from calling itself, directly or indirectly.\r\n\t* If you mark a function `nonReentrant`, you should also\r\n\t* mark it `external`. Calling one `nonReentrant` function from\r\n\t* another is not supported. Instead, you can implement a\r\n\t* `private` function doing the actual work, and an `external`\r\n\t* wrapper marked as `nonReentrant`.\r\n\t*/\r\n\t\tmodifier nonReentrant() {\r\n\t\t\tguardCounter += 1;\r\n\t\t\tuint256 localCounter = guardCounter;\r\n\t\t\t_;\r\n\t\t\trequire(localCounter == guardCounter);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * @title ERC165\r\n\t * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n\t */\r\n\tinterface ERC165 {\r\n\r\n\t  /**\r\n\t   * @notice Query if a contract implements an interface\r\n\t   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n\t   * @dev Interface identification is specified in ERC-165. This function\r\n\t   * uses less than 30,000 gas.\r\n\t   */\r\n\t  function supportsInterface(bytes4 _interfaceId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool);\r\n\t}\r\n\r\n\t/**\r\n\t * @title ERC721 token receiver interface\r\n\t * @dev Interface for any contract that wants to support safeTransfers\r\n\t * from ERC721 asset contracts.\r\n\t */\r\n\tcontract ERC721Receiver {\r\n\t  /**\r\n\t   * @dev Magic value to be returned upon successful reception of an NFT\r\n\t   *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n\t   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n\t   */\r\n\t  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\t  /**\r\n\t   * @notice Handle the receipt of an NFT\r\n\t   * @dev The ERC721 smart contract calls this function on the recipient\r\n\t   * after a `safetransfer`. This function MAY throw to revert and reject the\r\n\t   * transfer. Return of other than the magic value MUST result in the \r\n\t   * transaction being reverted.\r\n\t   * Note: the contract address is always the message sender.\r\n\t   * @param _operator The address which called `safeTransferFrom` function\r\n\t   * @param _from The address which previously owned the token\r\n\t   * @param _tokenId The NFT identifier which is being transfered\r\n\t   * @param _data Additional data with no specified format\r\n\t   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n\t   */\r\n\t  function onERC721Received(\r\n\t\taddress _operator,\r\n\t\taddress _from,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes  memory _data \r\n\t  )\r\n\t\tpublic\r\n\t\treturns(bytes4);\r\n\t}\r\n\r\n\t/**\r\n\t * Utility library of inline functions on addresses\r\n\t */\r\n\tlibrary AddressUtils {\r\n\r\n\t  /**\r\n\t   * Returns whether the target address is a contract\r\n\t   * @dev This function will return false if invoked during the constructor of a contract,\r\n\t   * as the code is not actually created until after the constructor finishes.\r\n\t   * @param addr address to check\r\n\t   * @return whether the target address is a contract\r\n\t   */\r\n\t  function isContract(address addr) internal view returns (bool) {\r\n\t\tuint256 size;\r\n\t\t// XXX Currently there is no better way to check if there is a contract in an address\r\n\t\t// than to check the size of the code at that address.\r\n\t\t// See https://ethereum.stackexchange.com/a/14016/36603\r\n\t\t// for more details about how this works.\r\n\t\t// TODO Check this again before the Serenity release, because all addresses will be\r\n\t\t// contracts then.\r\n\t\t// solium-disable-next-line security/no-inline-assembly\r\n\t\tassembly { size := extcodesize(addr) }\r\n\t\treturn size > 0;\r\n\t  }\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @title Ownable\r\n\t * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n\t * functions, this simplifies the implementation of \"user permissions\".\r\n\t */\r\n\tcontract Ownable {\r\n\t  address public owner;\r\n\r\n\r\n\t  event OwnershipRenounced(address indexed previousOwner);\r\n\t  event OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t  );\r\n\r\n\r\n\t  /**\r\n\t   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t   * account.\r\n\t   */\r\n\t  constructor() public {\r\n\t\towner = msg.sender;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Throws if called by any account other than the owner.\r\n\t   */\r\n\t  modifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Allows the current owner to relinquish control of the contract.\r\n\t   * @notice Renouncing to ownership will leave the contract without an owner.\r\n\t   * It will not be possible to call the functions with the `onlyOwner`\r\n\t   * modifier anymore.\r\n\t   */\r\n\t  function renounceOwnership() public onlyOwner {\r\n\t\temit OwnershipRenounced(owner);\r\n\t\towner = address(0);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t   * @param _newOwner The address to transfer ownership to.\r\n\t   */\r\n\t  function transferOwnership(address _newOwner) public onlyOwner {\r\n\t\t_transferOwnership(_newOwner);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Transfers control of the contract to a newOwner.\r\n\t   * @param _newOwner The address to transfer ownership to.\r\n\t   */\r\n\t  function _transferOwnership(address _newOwner) internal {\r\n\t\trequire(_newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, _newOwner);\r\n\t\towner = _newOwner;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @title SupportsInterfaceWithLookup\r\n\t * @author Matt Condon (@shrugs)\r\n\t * @dev Implements ERC165 using a lookup table.\r\n\t */\r\n\tcontract SupportsInterfaceWithLookup is ERC165 {\r\n\t  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n\t  /**\r\n\t   * 0x01ffc9a7 ===\r\n\t   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n\t   */\r\n\r\n\t  /**\r\n\t   * @dev a mapping of interface id to whether or not it's supported\r\n\t   */\r\n\t  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\t  /**\r\n\t   * @dev A contract implementing SupportsInterfaceWithLookup\r\n\t   * implement ERC165 itself\r\n\t   */\r\n\t  constructor()\r\n\t\tpublic\r\n\t  {\r\n\t\t_registerInterface(InterfaceId_ERC165);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev implement supportsInterface(bytes4) using a lookup table\r\n\t   */\r\n\t  function supportsInterface(bytes4 _interfaceId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool)\r\n\t  {\r\n\t\treturn supportedInterfaces[_interfaceId];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev private method for registering an interface\r\n\t   */\r\n\t  function _registerInterface(bytes4 _interfaceId)\r\n\t\tinternal\r\n\t  {\r\n\t\trequire(_interfaceId != 0xffffffff);\r\n\t\tsupportedInterfaces[_interfaceId] = true;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @title ERC721 Non-Fungible Token Standard basic interface\r\n\t * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n\t */\r\n\tcontract ERC721Basic is ERC165 {\r\n\t  event Transfer(\r\n\t\taddress indexed _from,\r\n\t\taddress indexed _to,\r\n\t\tuint256 indexed _tokenId\r\n\t  );\r\n\t  event Approval(\r\n\t\taddress indexed _owner,\r\n\t\taddress indexed _approved,\r\n\t\tuint256 indexed _tokenId\r\n\t  );\r\n\t  event ApprovalForAll(\r\n\t\taddress indexed _owner,\r\n\t\taddress indexed _operator,\r\n\t\tbool _approved\r\n\t  );\r\n\r\n\t  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n\t  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n\t  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n\t  function approve(address _to, uint256 _tokenId) public;\r\n\t  function getApproved(uint256 _tokenId)\r\n\t\tpublic view returns (address _operator);\r\n\r\n\t  function setApprovalForAll(address _operator, bool _approved) public;\r\n\t  function isApprovedForAll(address _owner, address _operator)\r\n\t\tpublic view returns (bool);\r\n\r\n\t  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\t  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n\t\tpublic;\r\n\r\n\t  function safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes memory _data\r\n\t  )\r\n\t\tpublic;\r\n\t}\r\n\r\n\t/**\r\n\t * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n\t * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n\t */\r\n\tcontract ERC721Enumerable is ERC721Basic {\r\n\t  function totalSupply() public view returns (uint256);\r\n\t  function tokenOfOwnerByIndex(\r\n\t\taddress _owner,\r\n\t\tuint256 _index\r\n\t  )\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 _tokenId);\r\n\r\n\t  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n\t * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n\t */\r\n\tcontract ERC721Metadata is ERC721Basic {\r\n\t  function name() external view returns (string memory _name);\r\n\t  function symbol() external view returns (string memory _symbol);\r\n\t  function tokenURI(uint256 _tokenId) public view returns (string memory);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n\t * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n\t */\r\n\tcontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n\t}\r\n\r\n\t/**\r\n\t * @title ERC721 Non-Fungible Token Standard basic implementation\r\n\t * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n\t */\r\n\tcontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\r\n\r\n\t  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\r\n\t  /*\r\n\t   * 0x80ac58cd ===\r\n\t   *   bytes4(keccak256('balanceOf(address)')) ^\r\n\t   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n\t   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n\t   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n\t   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n\t   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n\t   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n\t   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n\t   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n\t   */\r\n\r\n\t  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n\t  /*\r\n\t   * 0x4f558e79 ===\r\n\t   *   bytes4(keccak256('exists(uint256)'))\r\n\t   */\r\n\r\n\t  using SafeMath for uint256;\r\n\t  using AddressUtils for address;\r\n\r\n\t  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n\t  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n\t  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\t  // Mapping from token ID to owner\r\n\t  mapping (uint256 => address) internal tokenOwner;\r\n\r\n\t  // Mapping from token ID to approved address\r\n\t  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n\t  // Mapping from owner to number of owned token\r\n\t  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n\t  // Mapping from owner to operator approvals\r\n\t  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n\t  /**\r\n\t   * @dev Guarantees msg.sender is owner of the given token\r\n\t   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n\t   */\r\n\t  modifier onlyOwnerOf(uint256 _tokenId) {\r\n\t\trequire(ownerOf(_tokenId) == msg.sender);\r\n\t\t_;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n\t   * @param _tokenId uint256 ID of the token to validate\r\n\t   */\r\n\t  modifier canTransfer(uint256 _tokenId) {\r\n\t\trequire(isApprovedOrOwner(msg.sender, _tokenId));\r\n\t\t_;\r\n\t  }\r\n\r\n\t  constructor()\r\n\t\tpublic\r\n\t  {\r\n\t\t// register the supported interfaces to conform to ERC721 via ERC165\r\n\t\t_registerInterface(InterfaceId_ERC721);\r\n\t\t_registerInterface(InterfaceId_ERC721Exists);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the balance of the specified address\r\n\t   * @param _owner address to query the balance of\r\n\t   * @return uint256 representing the amount owned by the passed address\r\n\t   */\r\n\t  function balanceOf(address _owner) public view returns (uint256) {\r\n\t\trequire(_owner != address(0));\r\n\t\treturn ownedTokensCount[_owner];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the owner of the specified token ID\r\n\t   * @param _tokenId uint256 ID of the token to query the owner of\r\n\t   * @return owner address currently marked as the owner of the given token ID\r\n\t   */\r\n\t  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n\t\taddress owner = tokenOwner[_tokenId];\r\n\t\trequire(owner != address(0));\r\n\t\treturn owner;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Returns whether the specified token exists\r\n\t   * @param _tokenId uint256 ID of the token to query the existence of\r\n\t   * @return whether the token exists\r\n\t   */\r\n\t  function exists(uint256 _tokenId) public view returns (bool) {\r\n\t\taddress owner = tokenOwner[_tokenId];\r\n\t\treturn owner != address(0);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Approves another address to transfer the given token ID\r\n\t   * The zero address indicates there is no approved address.\r\n\t   * There can only be one approved address per token at a given time.\r\n\t   * Can only be called by the token owner or an approved operator.\r\n\t   * @param _to address to be approved for the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be approved\r\n\t   */\r\n\t  function approve(address _to, uint256 _tokenId) public {\r\n\t\taddress owner = ownerOf(_tokenId);\r\n\t\trequire(_to != owner);\r\n\t\trequire(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n\t\ttokenApprovals[_tokenId] = _to;\r\n\t\temit Approval(owner, _to, _tokenId);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the approved address for a token ID, or zero if no address set\r\n\t   * @param _tokenId uint256 ID of the token to query the approval of\r\n\t   * @return address currently approved for the given token ID\r\n\t   */\r\n\t  function getApproved(uint256 _tokenId) public view returns (address) {\r\n\t\treturn tokenApprovals[_tokenId];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Sets or unsets the approval of a given operator\r\n\t   * An operator is allowed to transfer all tokens of the sender on their behalf\r\n\t   * @param _to operator address to set the approval\r\n\t   * @param _approved representing the status of the approval to be set\r\n\t   */\r\n\t  function setApprovalForAll(address _to, bool _approved) public {\r\n\t\trequire(_to != msg.sender);\r\n\t\toperatorApprovals[msg.sender][_to] = _approved;\r\n\t\temit ApprovalForAll(msg.sender, _to, _approved);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Tells whether an operator is approved by a given owner\r\n\t   * @param _owner owner address which you want to query the approval of\r\n\t   * @param _operator operator address which you want to query the approval of\r\n\t   * @return bool whether the given operator is approved by the given owner\r\n\t   */\r\n\t  function isApprovedForAll(\r\n\t\taddress _owner,\r\n\t\taddress _operator\r\n\t  )\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (bool)\r\n\t  {\r\n\t\treturn operatorApprovals[_owner][_operator];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Transfers the ownership of a given token ID to another address\r\n\t   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n\t   * Requires the msg sender to be the owner, approved, or operator\r\n\t   * @param _from current owner of the token\r\n\t   * @param _to address to receive the ownership of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be transferred\r\n\t  */\r\n\t  function transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId\r\n\t  )\r\n\t\tpublic\r\n\t\tcanTransfer(_tokenId)\r\n\t  {\r\n\t\trequire(_from != address(0));\r\n\t\trequire(_to != address(0));\r\n\r\n\t\tclearApproval(_from, _tokenId);\r\n\t\tremoveTokenFrom(_from, _tokenId);\r\n\t\taddTokenTo(_to, _tokenId);\r\n\r\n\t\temit Transfer(_from, _to, _tokenId);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Safely transfers the ownership of a given token ID to another address\r\n\t   * If the target address is a contract, it must implement `onERC721Received`,\r\n\t   * which is called upon a safe transfer, and return the magic value\r\n\t   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n\t   * the transfer is reverted.\r\n\t   *\r\n\t   * Requires the msg sender to be the owner, approved, or operator\r\n\t   * @param _from current owner of the token\r\n\t   * @param _to address to receive the ownership of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be transferred\r\n\t  */\r\n\t  function safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId\r\n\t  )\r\n\t\tpublic\r\n\t\tcanTransfer(_tokenId)\r\n\t  {\r\n\t\t// solium-disable-next-line arg-overflow\r\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Safely transfers the ownership of a given token ID to another address\r\n\t   * If the target address is a contract, it must implement `onERC721Received`,\r\n\t   * which is called upon a safe transfer, and return the magic value\r\n\t   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n\t   * the transfer is reverted.\r\n\t   * Requires the msg sender to be the owner, approved, or operator\r\n\t   * @param _from current owner of the token\r\n\t   * @param _to address to receive the ownership of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be transferred\r\n\t   * @param _data bytes data to send along with a safe transfer check\r\n\t   */\r\n\t  function safeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes memory _data\r\n\t  )\r\n\t\tpublic\r\n\t\tcanTransfer(_tokenId)\r\n\t  {\r\n\t\ttransferFrom(_from, _to, _tokenId);\r\n\t\t// solium-disable-next-line arg-overflow\r\n\t\trequire(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n\t  }\r\n\r\n/*\r\n  function MaltaSafeTransferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes memory _data\r\n\t  )\r\n\t\tpublic\r\n\t\tcanTransfer(_tokenId)\r\n\t  {\r\n\t      address malta=\"0x7ECCA02c87D7E6c2c59Bcb65457EFe2fC2bEAa78\";//monartOfficielCB\r\n\t\ttransferFrom(_from, _malta, _tokenId);\r\n\t\ttransferFrom(_malta, _to, _tokenId);\r\n\t\t// solium-disable-next-line arg-overflow\r\n\t\trequire(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n\t  }\r\n*/\r\n\r\n\r\n\t  /**\r\n\t   * @dev Returns whether the given spender can transfer a given token ID\r\n\t   * @param _spender address of the spender to query\r\n\t   * @param _tokenId uint256 ID of the token to be transferred\r\n\t   * @return bool whether the msg.sender is approved for the given token ID,\r\n\t   *  is an operator of the owner, or is the owner of the token\r\n\t   */\r\n\t  function isApprovedOrOwner(\r\n\t\taddress _spender,\r\n\t\tuint256 _tokenId\r\n\t  )\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bool)\r\n\t  {\r\n\t\taddress owner = ownerOf(_tokenId);\r\n\t\t// Disable solium check because of\r\n\t\t// https://github.com/duaraghav8/Solium/issues/175\r\n\t\t// solium-disable-next-line operator-whitespace\r\n\t\treturn (\r\n\t\t  _spender == owner ||\r\n\t\t  getApproved(_tokenId) == _spender ||\r\n\t\t  isApprovedForAll(owner, _spender)\r\n\t\t);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to mint a new token\r\n\t   * Reverts if the given token ID already exists\r\n\t   * @param _to The address that will own the minted token\r\n\t   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n\t   */\r\n\t  function _mint(address _to, uint256 _tokenId) internal {\r\n\t\trequire(_to != address(0));\r\n\t\taddTokenTo(_to, _tokenId);\r\n\t\temit Transfer(address(0), _to, _tokenId);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to burn a specific token\r\n\t   * Reverts if the token does not exist\r\n\t   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n\t   */\r\n\t  function _burn(address _owner, uint256 _tokenId) internal {\r\n\t\tclearApproval(_owner, _tokenId);\r\n\t\tremoveTokenFrom(_owner, _tokenId);\r\n\t\temit Transfer(_owner, address(0), _tokenId);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to clear current approval of a given token ID\r\n\t   * Reverts if the given address is not indeed the owner of the token\r\n\t   * @param _owner owner of the token\r\n\t   * @param _tokenId uint256 ID of the token to be transferred\r\n\t   */\r\n\t  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n\t\trequire(ownerOf(_tokenId) == _owner);\r\n\t\tif (tokenApprovals[_tokenId] != address(0)) {\r\n\t\t  tokenApprovals[_tokenId] = address(0);\r\n\t\t}\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to add a token ID to the list of a given address\r\n\t   * @param _to address representing the new owner of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n\t   */\r\n\t  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n\t\trequire(tokenOwner[_tokenId] == address(0));\r\n\t\ttokenOwner[_tokenId] = _to;\r\n\t\townedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to remove a token ID from the list of a given address\r\n\t   * @param _from address representing the previous owner of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n\t   */\r\n\t  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n\t\trequire(ownerOf(_tokenId) == _from);\r\n\t\townedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n\t\ttokenOwner[_tokenId] = address(0);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to invoke `onERC721Received` on a target address\r\n\t   * The call is not executed if the target address is not a contract\r\n\t   * @param _from address representing the previous owner of the given token ID\r\n\t   * @param _to target address that will receive the tokens\r\n\t   * @param _tokenId uint256 ID of the token to be transferred\r\n\t   * @param _data bytes optional data to send along with the call\r\n\t   * @return whether the call correctly returned the expected magic value\r\n\t   */\r\n\t  function checkAndCallSafeTransfer(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _tokenId,\r\n\t\tbytes memory _data\r\n\t  )\r\n\t\tinternal\r\n\t\treturns (bool)\r\n\t  {\r\n\t\tif (!_to.isContract()) {\r\n\t\t  return true;\r\n\t\t}\r\n\t\tbytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n\t\t  msg.sender, _from, _tokenId, _data);\r\n\t\treturn (retval == ERC721_RECEIVED);\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @title Full ERC721 Token\r\n\t * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n\t * Moreover, it includes approve all functionality using operator terminology\r\n\t * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n\t */\r\n\tcontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\r\n\r\n\t  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n\t  /**\r\n\t   * 0x780e9d63 ===\r\n\t   *   bytes4(keccak256('totalSupply()')) ^\r\n\t   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n\t   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n\t   */\r\n\r\n\t  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n\t  /**\r\n\t   * 0x5b5e139f ===\r\n\t   *   bytes4(keccak256('name()')) ^\r\n\t   *   bytes4(keccak256('symbol()')) ^\r\n\t   *   bytes4(keccak256('tokenURI(uint256)'))\r\n\t   */\r\n\r\n\t  // Token name\r\n\t  string internal name_;\r\n\r\n\t  // Token symbol\r\n\t  string internal symbol_;\r\n\r\n\t  // Mapping from owner to list of owned token IDs\r\n\t  mapping(address => uint256[]) internal ownedTokens;\r\n\r\n\t  // Mapping from token ID to index of the owner tokens list\r\n\t  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n\t  // Array with all token ids, used for enumeration\r\n\t  uint256[] internal allTokens;\r\n\r\n\t  // Mapping from token id to position in the allTokens array\r\n\t  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n\t  // Optional mapping for token URIs\r\n\t  mapping(uint256 => string) internal tokenURIs;\r\n\r\n\t  /**\r\n\t   * @dev Constructor function\r\n\t   */\r\n\t  constructor(string memory _name, string memory _symbol) public {\r\n\t\tname_ = _name;\r\n\t\tsymbol_ = _symbol;\r\n\r\n\t\t// register the supported interfaces to conform to ERC721 via ERC165\r\n\t\t_registerInterface(InterfaceId_ERC721Enumerable);\r\n\t\t_registerInterface(InterfaceId_ERC721Metadata);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the token name\r\n\t   * @return string representing the token name\r\n\t   */\r\n\t  function name() external view returns (string memory) {\r\n\t\treturn name_;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the token symbol\r\n\t   * @return string representing the token symbol\r\n\t   */\r\n\t  function symbol() external view returns (string memory) {\r\n\t\treturn symbol_;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Returns an URI for a given token ID\r\n\t   * Throws if the token ID does not exist. May return an empty string.\r\n\t   * @param _tokenId uint256 ID of the token to query\r\n\t   */\r\n\t  function tokenURI(uint256 _tokenId) public view returns (string memory) {\r\n\t\trequire(exists(_tokenId));\r\n\t\treturn tokenURIs[_tokenId];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n\t   * @param _owner address owning the tokens list to be accessed\r\n\t   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n\t   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n\t   */\r\n\t  function tokenOfOwnerByIndex(\r\n\t\taddress _owner,\r\n\t\tuint256 _index\r\n\t  )\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t  {\r\n\t\trequire(_index < balanceOf(_owner));\r\n\t\treturn ownedTokens[_owner][_index];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the total amount of tokens stored by the contract\r\n\t   * @return uint256 representing the total amount of tokens\r\n\t   */\r\n\t  function totalSupply() public view returns (uint256) {\r\n\t\treturn allTokens.length;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n\t   * Reverts if the index is greater or equal to the total number of tokens\r\n\t   * @param _index uint256 representing the index to be accessed of the tokens list\r\n\t   * @return uint256 token ID at the given index of the tokens list\r\n\t   */\r\n\t  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n\t\trequire(_index < totalSupply());\r\n\t\treturn allTokens[_index];\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to set the token URI for a given token\r\n\t   * Reverts if the token ID does not exist\r\n\t   * @param _tokenId uint256 ID of the token to set its URI\r\n\t   * @param _uri string URI to assign\r\n\t   */\r\n\t  function _setTokenURI(uint256 _tokenId, string memory _uri) internal {\r\n\t\trequire(exists(_tokenId));\r\n\t\ttokenURIs[_tokenId] = _uri;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to add a token ID to the list of a given address\r\n\t   * @param _to address representing the new owner of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n\t   */\r\n\t  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n\t\tsuper.addTokenTo(_to, _tokenId);\r\n\t\tuint256 length = ownedTokens[_to].length;\r\n\t\townedTokens[_to].push(_tokenId);\r\n\t\townedTokensIndex[_tokenId] = length;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to remove a token ID from the list of a given address\r\n\t   * @param _from address representing the previous owner of the given token ID\r\n\t   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n\t   */\r\n\t  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n\t\tsuper.removeTokenFrom(_from, _tokenId);\r\n\r\n\t\tuint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n\t\tuint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n\t\townedTokens[_from][tokenIndex] = lastToken;\r\n\t\townedTokens[_from][lastTokenIndex] = 0;\r\n\t\t// Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n\t\t// be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n\t\t// the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n\t\townedTokens[_from].length--;\r\n\t\townedTokensIndex[_tokenId] = 0;\r\n\t\townedTokensIndex[lastToken] = tokenIndex;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to mint a new token\r\n\t   * Reverts if the given token ID already exists\r\n\t   * @param _to address the beneficiary that will own the minted token\r\n\t   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n\t   */\r\n\t  function _mint(address _to, uint256 _tokenId) internal {\r\n\t\tsuper._mint(_to, _tokenId);\r\n\r\n\t\tallTokensIndex[_tokenId] = allTokens.length;\r\n\t\tallTokens.push(_tokenId);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Internal function to burn a specific token\r\n\t   * Reverts if the token does not exist\r\n\t   * @param _owner owner of the token to burn\r\n\t   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n\t   */\r\n\t  function _burn(address _owner, uint256 _tokenId) internal {\r\n\t\tsuper._burn(_owner, _tokenId);\r\n\r\n\t\t// Clear metadata (if any)\r\n\t\tif (bytes(tokenURIs[_tokenId]).length != 0) {\r\n\t\t  delete tokenURIs[_tokenId];\r\n\t\t}\r\n\r\n\t\t// Reorg all tokens array\r\n\t\tuint256 tokenIndex = allTokensIndex[_tokenId];\r\n\t\tuint256 lastTokenIndex = allTokens.length.sub(1);\r\n\t\tuint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n\t\tallTokens[tokenIndex] = lastToken;\r\n\t\tallTokens[lastTokenIndex] = 0;\r\n\r\n\t\tallTokens.length--;\r\n\t\tallTokensIndex[_tokenId] = 0;\r\n\t\tallTokensIndex[lastToken] = tokenIndex;\r\n\t  }\r\n\r\n\t}\r\n\r\n\tcontract MonartArtworkToken is ERC721Token, Ownable {\r\n\r\n\t  /*** EVENTS ***/\r\n\t  /// The event emitted (useable by web3) when a token is purchased\r\n\t  event BoughtToken(address indexed buyer, uint256 tokenId);\r\n\r\n\t  /*** CONSTANTS ***/\r\n//\t  uint8 constant TITLE_MIN_LENGTH = 1;\r\n//\t  uint8 constant TITLE_MAX_LENGTH = 64;\r\n//\t  uint256 constant DESCRIPTION_MIN_LENGTH = 1;\r\n//\t  uint256 constant DESCRIPTION_MAX_LENGTH = 10000;\r\n\r\n\t  /*** DATA TYPES ***/\r\n\r\n\t  /// Price set by contract owner for each token in Wei.\r\n\t  /// @dev If you'd like a different price for each token type, you will\r\n\t  ///   need to use a mapping like: `mapping(uint256 => uint256) tokenTypePrices;`\r\n\t  uint256 currentPrice = 0;\r\n\r\n// enregistrer le monertID\r\n      mapping(uint256 => uint256) tokenMonartIDs;\r\n\t  /// The token type (1 for complete artwork, 2 for parts, 3 for collection, 4 for bouquets)\r\n\t  mapping(uint256 => uint256) tokenTypes;\r\n\r\n\t  /// The title of the token\r\n\t  mapping(uint256 => string) tokenTitles;\r\n\t  /// The artist of the token\r\n\t  mapping(uint256 => string) tokenArtists;\r\n\t  \r\n\t  /// The description of the token aka legal\r\n\t  mapping(uint256 => string) tokenDescription;\r\n\r\n\r\n\t  /// The number of parts  of the token (for sales by parts)\r\n\t  mapping(uint256 => uint256) tokenNbOfParts;\r\n\t  mapping(uint256 => uint256) tokenTotalNbOfParts;\r\n\r\n\r\n\t  constructor() ERC721Token(\"MonartAuctionity\", \"test\") public {\r\n\t\t// any init code when you deploy the contract would run here\r\n\t  }\r\n\r\n\t  /// Requires the amount of Ether be at least or more of the currentPrice\r\n\t  /// @dev Creates an instance of an token and mints it to the purchaser\r\n\t  /// @param _type The token type as an integer\r\n\t  /// @param _title The short title of the token\r\n\t  /// @param _description Description of the token\r\n\t  function buyToken (\r\n\t    uint256 _monartID,\r\n\t\tuint256 _type,\r\n\t\tstring calldata _title,\r\n\t\tstring calldata _artist,\r\n\t\tstring calldata _description,\r\n\t\tuint256 _nbOfParts,\r\n\t\tuint256 _TotalNbOfParts,\r\n\t\tstring calldata _uri\r\n\r\n\t  ) external payable {\r\n\t//\tbytes memory _titleBytes = bytes(_title);\r\n\t//\trequire(_titleBytes.length >= TITLE_MIN_LENGTH, \"Title is too short\");\r\n\t//\trequire(_titleBytes.length <= TITLE_MAX_LENGTH, \"Title is too long\");\r\n\t\t\r\n\t//\tbytes memory _descriptionBytes = bytes(_description);\r\n\t//\trequire(_descriptionBytes.length >= DESCRIPTION_MIN_LENGTH, \"Description is too short\");\r\n\t//\trequire(_descriptionBytes.length <= DESCRIPTION_MAX_LENGTH, \"Description is too long\");\r\n\t//CB\trequire(msg.value >= currentPrice, \"Amount of Ether sent too small\");\r\n\r\n\t\tuint256 index = allTokens.length + 1;\r\n\r\n\t\t_mint(msg.sender, index);\r\n\r\n\t\ttokenMonartIDs[index] = _monartID;\r\n\t\ttokenTypes[index] = _type;\r\n\t\ttokenTitles[index] = _title;\r\n\t\ttokenArtists[index] = _artist;\r\n\t\ttokenDescription[index] = _description;\r\n\t\ttokenURIs[index] = _uri;\r\n\t\t//\r\n\t\ttokenNbOfParts[index] = _nbOfParts;\r\n\t\ttokenTotalNbOfParts[index] = _TotalNbOfParts;\r\n\r\n\t\temit BoughtToken(msg.sender, index);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @dev Returns all of the tokens that the user owns\r\n\t   * @return An array of token indices\r\n\t   */\r\n\t  function myTokens()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t   uint256[] memory\r\n\t\t)\r\n\t  {\r\n\t\treturn ownedTokens[msg.sender];\r\n\t  }\r\n\r\n\t  /// @notice Returns all the relevant information about a specific token\r\n\t  /// @param _tokenId The ID of the token of interest\r\n\t  function viewToken(uint256 _tokenId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t  uint256 tokenType_,\r\n\t\t  string memory tokenTitle_,\r\n\t\t  string memory tokenDescription_,\r\n\t\t  uint256 nbOfParts_,\r\n\t\t  uint256 TotalNbOfParts_,\r\n\t\t  string memory url_\r\n\t\r\n\t  ) {\r\n\t\t  tokenType_ = tokenTypes[_tokenId];\r\n\t\t  tokenTitle_ = tokenTitles[_tokenId];\r\n\t\t  tokenDescription_ = tokenDescription[_tokenId];\r\n\t\t  nbOfParts_ = tokenNbOfParts[_tokenId];\r\n\t\t  TotalNbOfParts_ = tokenTotalNbOfParts[_tokenId];\r\n\t\t  url_=tokenURIs[_tokenId];\r\n\t  }\r\n\r\n\t  /// @notice Allows the owner of this contract to set the currentPrice for each token\r\n\t  function setCurrentPrice(uint256 newPrice)\r\n\t\tpublic\r\n\t\tonlyOwner\r\n\t  {\r\n\t\t  currentPrice = newPrice;\r\n\t  }\r\n\r\n\t  /// @notice Returns the currentPrice for each token\r\n\t  function getCurrentPrice()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\tuint256 price\r\n\t  ) {\r\n\t\t  price = currentPrice;\r\n\t  }\r\n\t  \r\n\t  \r\n\t  /// @notice allows the owner of this contract to destroy the contract\r\n/*\t   function kill() public {\r\n\t\t  if(msg.sender == owner) selfdestruct(owner);\r\n\t   }  \r\n*/\r\n\t}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setCurrentPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"viewToken\",\"outputs\":[{\"name\":\"tokenType_\",\"type\":\"uint256\"},{\"name\":\"tokenTitle_\",\"type\":\"string\"},{\"name\":\"tokenDescription_\",\"type\":\"string\"},{\"name\":\"nbOfParts_\",\"type\":\"uint256\"},{\"name\":\"TotalNbOfParts_\",\"type\":\"uint256\"},{\"name\":\"url_\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_monartID\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_artist\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_nbOfParts\",\"type\":\"uint256\"},{\"name\":\"_TotalNbOfParts\",\"type\":\"uint256\"},{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"BoughtToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"MonartArtworkToken","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://f938043dfa4315cb9827e2fd8cbacfcf1383de5043450250939a2552b227fdf4"}]}