{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n\r\ncontract AbstractAccount {\r\n\r\n  event DeviceAdded(address device, bool isOwner);\r\n  event DeviceRemoved(address device);\r\n  event TransactionExecuted(address recipient, uint256 value, bytes data, bytes response);\r\n\r\n  struct Device {\r\n    bool isOwner;\r\n    bool exists;\r\n    bool existed;\r\n  }\r\n\r\n  mapping(address => Device) public devices;\r\n\r\n  function addDevice(address _device, bool _isOwner) public;\r\n\r\n  function removeDevice(address _device) public;\r\n\r\n  function executeTransaction(address payable _recipient, uint256 _value, bytes memory _data) public returns (bytes memory _response);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Account Library\r\n */\r\nlibrary AccountLibrary {\r\n\r\n  using ECDSA for bytes32;\r\n\r\n  function isOwnerDevice(\r\n    AbstractAccount _account,\r\n    address _device\r\n  ) internal view returns (bool) {\r\n    bool isOwner;\r\n    (isOwner,,) = _account.devices(_device);\r\n    return isOwner;\r\n  }\r\n\r\n  function isAnyDevice(\r\n    AbstractAccount _account,\r\n    address _device\r\n  ) internal view returns (bool) {\r\n    bool exists;\r\n    (,exists,) = _account.devices(_device);\r\n    return exists;\r\n  }\r\n\r\n  function isExistedDevice(\r\n    AbstractAccount _account,\r\n    address _device\r\n  ) internal view returns (bool) {\r\n    bool existed;\r\n    (,,existed) = _account.devices(_device);\r\n    return existed;\r\n  }\r\n\r\n  function verifyOwnerSignature(\r\n    AbstractAccount _account,\r\n    bytes32 _messageHash,\r\n    bytes memory _signature\r\n  ) internal view returns (bool _result) {\r\n    address _recovered = _messageHash.recover(_signature);\r\n\r\n    if (_recovered != address(0)) {\r\n      _result = isOwnerDevice(_account, _recovered);\r\n    }\r\n  }\r\n\r\n  function verifySignature(\r\n    AbstractAccount _account,\r\n    bytes32 _messageHash,\r\n    bytes memory _signature,\r\n    bool _strict\r\n  ) internal view returns (bool _result) {\r\n    address _recovered = _messageHash.recover(_signature);\r\n\r\n    if (_recovered != address(0)) {\r\n      if (_strict) {\r\n        _result = isAnyDevice(_account, _recovered);\r\n      } else {\r\n        _result = isExistedDevice(_account, _recovered);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Address Library\r\n */\r\nlibrary AddressLibrary {\r\n\r\n  using AccountLibrary for AbstractAccount;\r\n  using Address for address;\r\n  using ECDSA for bytes32;\r\n\r\n  function verifySignature(\r\n    address _address,\r\n    bytes32 _messageHash,\r\n    bytes memory _signature,\r\n    bool _strict\r\n  ) internal view returns (bool _result) {\r\n    if (_address.isContract()) {\r\n      _result = AbstractAccount(_address).verifySignature(\r\n        _messageHash,\r\n        _signature,\r\n        _strict\r\n      );\r\n    } else {\r\n      address _recovered = _messageHash.recover(_signature);\r\n      _result = _recovered == _address;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Virtual Payment Manager\r\n */\r\ncontract VirtualPaymentManager {\r\n\r\n  using AddressLibrary for address;\r\n  using ECDSA for bytes32;\r\n  using SafeMath for uint256;\r\n\r\n  event NewDeposit(address owner, address token, uint256 value);\r\n  event NewWithdrawal(address recipient, address token, uint256 value);\r\n  event NewWithdrawalRequest(address owner, address token, uint256 unlockedAt);\r\n  event NewPayment(address sender, address recipient, address token, uint256 id, uint256 value);\r\n\r\n  struct Deposit {\r\n    uint256 value;\r\n    uint256 withdrawalUnlockedAt;\r\n  }\r\n\r\n  struct Payment {\r\n    uint256 value;\r\n  }\r\n\r\n  mapping(address => mapping(address => Deposit)) public deposits;\r\n  mapping(bytes32 => Payment) public payments;\r\n\r\n  address public guardian;\r\n  uint256 public depositWithdrawalLockPeriod;\r\n\r\n  string constant ERR_INVALID_SIGNATURE = \"Invalid signature\";\r\n  string constant ERR_INVALID_VALUE = \"Invalid value\";\r\n  string constant ERR_INVALID_TOKEN = \"Invalid token\";\r\n\r\n  constructor(\r\n    address _guardian,\r\n    uint256 _depositWithdrawalLockPeriod\r\n  ) public {\r\n    guardian = _guardian;\r\n    depositWithdrawalLockPeriod = _depositWithdrawalLockPeriod;\r\n  }\r\n\r\n  function getDepositValue(address _owner, address _token) public view returns (uint256) {\r\n    return deposits[_owner][_token].value;\r\n  }\r\n\r\n  function getDepositWithdrawalUnlockedAt(address _owner, address _token) public view returns (uint256) {\r\n    return deposits[_owner][_token].withdrawalUnlockedAt;\r\n  }\r\n\r\n  function() external payable {\r\n    deposits[msg.sender][address(0)].value = deposits[msg.sender][address(0)].value.add(msg.value);\r\n\r\n    emit NewDeposit(msg.sender, address(0), msg.value);\r\n  }\r\n\r\n  function depositToken(address _token, uint256 _value) public {\r\n    require(\r\n      _token != address(0),\r\n      ERR_INVALID_TOKEN\r\n    );\r\n\r\n    IERC20(_token).transferFrom(msg.sender, address(this), _value);\r\n\r\n    deposits[msg.sender][_token].value = deposits[msg.sender][_token].value.add(_value);\r\n\r\n    emit NewDeposit(msg.sender, _token, _value);\r\n  }\r\n\r\n  function depositPayment(\r\n    address _sender,\r\n    address _recipient,\r\n    address _token,\r\n    uint256 _id,\r\n    uint256 _value,\r\n    bytes memory _senderSignature,\r\n    bytes memory _guardianSignature\r\n  ) public {\r\n    uint256 _processedValue = _processPayment(\r\n      _sender,\r\n      _recipient,\r\n      _token,\r\n      _id,\r\n      _value,\r\n      _senderSignature,\r\n      _guardianSignature\r\n    );\r\n\r\n    deposits[_recipient][_token].value = deposits[_recipient][_token].value.add(_processedValue);\r\n\r\n    emit NewPayment(_sender, _recipient, _token, _id, _processedValue);\r\n    emit NewDeposit(_recipient, _token, _processedValue);\r\n  }\r\n\r\n  function withdrawPayment(\r\n    address _sender,\r\n    address _recipient,\r\n    address _token,\r\n    uint256 _id,\r\n    uint256 _value,\r\n    bytes memory _senderSignature,\r\n    bytes memory _guardianSignature\r\n  ) public {\r\n    uint256 _processedValue = _processPayment(\r\n      _sender,\r\n      _recipient,\r\n      _token,\r\n      _id,\r\n      _value,\r\n      _senderSignature,\r\n      _guardianSignature\r\n    );\r\n\r\n    _transfer(_recipient, _token, _processedValue);\r\n\r\n    emit NewPayment(_sender, _recipient, _token, _id, _processedValue);\r\n    emit NewWithdrawal(_recipient, _token, _processedValue);\r\n  }\r\n\r\n  function withdrawDeposit(address _token) public {\r\n    if (\r\n      deposits[msg.sender][_token].withdrawalUnlockedAt != 0 && deposits[msg.sender][_token].withdrawalUnlockedAt <= now\r\n    ) {\r\n      _transfer(msg.sender, _token, deposits[msg.sender][_token].value);\r\n\r\n      emit NewWithdrawal(msg.sender, _token, deposits[msg.sender][_token].value);\r\n\r\n      delete deposits[msg.sender][_token];\r\n    } else {\r\n      deposits[msg.sender][_token].withdrawalUnlockedAt = now.add(depositWithdrawalLockPeriod);\r\n\r\n      emit NewWithdrawalRequest(msg.sender, _token, deposits[msg.sender][_token].withdrawalUnlockedAt);\r\n    }\r\n  }\r\n\r\n  function _processPayment(\r\n    address _sender,\r\n    address _recipient,\r\n    address _token,\r\n    uint256 _id,\r\n    uint256 _value,\r\n    bytes memory _senderSignature,\r\n    bytes memory _guardianSignature\r\n  ) private returns (uint256 _processedValue) {\r\n    bytes32 _messageHash = keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        _sender,\r\n        _recipient,\r\n        _token,\r\n        _id,\r\n        _value\r\n      )\r\n    ).toEthSignedMessageHash();\r\n\r\n    require(\r\n      _sender.verifySignature(_messageHash, _senderSignature, false),\r\n      ERR_INVALID_SIGNATURE\r\n    );\r\n    require(\r\n      guardian.verifySignature(_messageHash, _guardianSignature, true),\r\n      ERR_INVALID_SIGNATURE\r\n    );\r\n\r\n    bytes32 _paymentHash = keccak256(abi.encodePacked(\r\n        _sender,\r\n        _recipient,\r\n        _token,\r\n        _id\r\n      ));\r\n\r\n    require(\r\n      _value > 0,\r\n      ERR_INVALID_VALUE\r\n    );\r\n\r\n    if (payments[_paymentHash].value > 0) {\r\n      require(\r\n        payments[_paymentHash].value < _value,\r\n        ERR_INVALID_VALUE\r\n      );\r\n      _processedValue = _value.sub(payments[_paymentHash].value);\r\n    } else {\r\n      _processedValue = _value;\r\n    }\r\n\r\n    require(\r\n      deposits[_sender][_token].value >= _processedValue,\r\n      ERR_INVALID_VALUE\r\n    );\r\n\r\n    if (deposits[_sender][_token].withdrawalUnlockedAt > 0) {\r\n      delete deposits[_sender][_token].withdrawalUnlockedAt;\r\n    }\r\n\r\n    payments[_paymentHash].value = _value;\r\n    deposits[_sender][_token].value = deposits[_sender][_token].value.sub(_processedValue);\r\n  }\r\n\r\n  function _transfer(address _recipient, address _token, uint256 _value) private {\r\n    if (_token == address(0)) {\r\n      address payable _payableRecipient = address(uint160(_recipient));\r\n      _payableRecipient.transfer(_value);\r\n    } else {\r\n      IERC20(_token).transfer(_recipient, _value);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_senderSignature\",\"type\":\"bytes\"},{\"name\":\"_guardianSignature\",\"type\":\"bytes\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositWithdrawalLockPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getDepositValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"withdrawalUnlockedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getDepositWithdrawalUnlockedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_senderSignature\",\"type\":\"bytes\"},{\"name\":\"_guardianSignature\",\"type\":\"bytes\"}],\"name\":\"depositPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_guardian\",\"type\":\"address\"},{\"name\":\"_depositWithdrawalLockPeriod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unlockedAt\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawalRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewPayment\",\"type\":\"event\"}]","ContractName":"VirtualPaymentManager","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000099819fedbcf9986824bbe094df928887d1a443a60000000000000000000000000000000000000000000000000000000000278d00","Library":"","SwarmSource":"bzzr://391633be56c80e203adeae89068b4d065c9a2f9e1e05159061ff008f1dfc6439"}]}