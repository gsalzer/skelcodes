{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\ncontract EtherCenter {\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    modifier onlyBagholders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(abi.encodePacked(_customerAddress))]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidAddress(address _to){\r\n        require(_to != address(0x0000000000000000000000000000000000000000));\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n\r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"EtherCenter\";\r\n    string public symbol = \"EC\";\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal realRate_ = 98;\r\n    uint8 constant internal valueChange_ = 5 ;\r\n    uint256 constant internal tokenPriceInitial_ = 0.001 ether;\r\n    uint256 constant internal defaultValue = 10**18;\r\n    address constant internal admin_ = address(0xaD5874D6A14CC9963FC303F745f454Ef3A6E9BEb);\r\n\r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal payoutsTo_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 internal ethereumBuy_ = 0;\r\n\r\n    mapping(bytes32 => bool) public administrators; \r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --\r\n    */\r\n    constructor()\r\n        public\r\n    {\r\n        // add administrators here\r\n        administrators[keccak256(abi.encode(admin_))] = true;\r\n    }\r\n\r\n    function buy()\r\n        public\r\n        payable\r\n    {\r\n        ethereumBuy_ = msg.value;\r\n        purchaseTokens(msg.value);\r\n        ethereumBuy_ = 0;\r\n    }\r\n\r\n    function exit()\r\n        public\r\n    {\r\n        // get token count for caller & sell them all\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens > 0) sell(_tokens);\r\n    }\r\n\r\n    function sell(uint256 _amountOfTokens)\r\n        onlyBagholders()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        // russian hackers BTFO\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _realEthereum = SafeMath.div(SafeMath.mul(_ethereum, realRate_), 100);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _realEthereum);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n\r\n        _customerAddress.transfer(_realEthereum);\r\n        admin_.transfer(_taxedEthereum);\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _tokens, _realEthereum);\r\n    }\r\n\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyValidAddress(_toAddress)\r\n        onlyBagholders()\r\n        public\r\n        returns(bool)\r\n    {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n        uint256 _taxedTokens = SafeMath.div(SafeMath.mul(_amountOfTokens, valueChange_), 100);\r\n        require(SafeMath.add(_amountOfTokens, _taxedTokens) <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _realTokens = SafeMath.add(_amountOfTokens, _taxedTokens);\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _realTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n        tokenSupply_ -= _taxedTokens;\r\n\r\n        // fire event\r\n        emit Transfer(_customerAddress, _toAddress, _realTokens);\r\n        \r\n        // ERC20\r\n        return true;\r\n       \r\n    }\r\n\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /**\r\n     * In case one of us dies, we need to replace ourselves.\r\n     */\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n\r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setName(string memory _name)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n\r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setSymbol(string memory _symbol)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     * Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     */\r\n    function sellPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _ethereum = guaranteePrice_();\r\n        uint256 _sellEthereum = SafeMath.div(SafeMath.mul(\r\n                                    SafeMath.div(SafeMath.mul(_ethereum,\r\n                                        SafeMath.sub(100, valueChange_)), 100), realRate_), 100);\r\n        return _sellEthereum;\r\n    }\r\n\r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _ethereum = guaranteePrice_();\r\n        uint256 _buyEthereum = SafeMath.div(SafeMath.mul(_ethereum, SafeMath.add(100, valueChange_)), realRate_);\r\n        return _buyEthereum;\r\n    }\r\n\r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n     */\r\n    function calculateTokensReceived(uint256 _ethereumToSpend)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _amountOfTokens = ethereumToTokens_(_ethereumToSpend);\r\n        uint256 _realTokens = SafeMath.div(SafeMath.mul(_amountOfTokens, realRate_), 100);\r\n        return _realTokens;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n     */\r\n    function calculateEthereumReceived(uint256 _tokensToSell)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _realEthereum = SafeMath.div(SafeMath.mul(_ethereum, realRate_), 100);\r\n        return _realEthereum;\r\n    }\r\n\r\n /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    function purchaseTokens(uint256 _incomingEthereum)\r\n        internal\r\n    {\r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        // Amount of tokens can buy\r\n        uint256 _amountOfTokens = ethereumToTokens_(_incomingEthereum);\r\n        uint256 _realTokens = SafeMath.div(SafeMath.mul(_amountOfTokens, realRate_), 100);\r\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _realTokens);\r\n        // Require for the number Token is buying\r\n        require(_realTokens > 0 && _realTokens <= 3000*defaultValue && (SafeMath.add(_realTokens, tokenSupply_) > tokenSupply_));\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _realTokens);\r\n        tokenBalanceLedger_[admin_] = SafeMath.add(tokenBalanceLedger_[admin_], _taxedTokens);\r\n        // update system\r\n        tokenSupply_ += _amountOfTokens;\r\n    \r\n        payoutsTo_[_customerAddress] += SafeMath.div(_realTokens, defaultValue);\r\n\r\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _realTokens);\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     */\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // Check guaranteePrice\r\n        uint256 _guarantee = guaranteePrice_();\r\n        uint256 _tokensReceived = \r\n        (\r\n            SafeMath.div(_ethereum*defaultValue, SafeMath.div(SafeMath.mul(_guarantee, SafeMath.add(100, valueChange_)), 100))\r\n        );\r\n        return _tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n     */\r\n    function tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // Check guaranteePrice\r\n        uint256 _guarantee = guaranteePrice_();\r\n        uint256 _etherReceived =\r\n        (\r\n            SafeMath.div(SafeMath.mul(_tokens, SafeMath.div(SafeMath.mul(_guarantee, SafeMath.sub(100, valueChange_)), 100)), defaultValue)\r\n        );\r\n        return _etherReceived;\r\n    }\r\n    \r\n    function guaranteePrice_()\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _guarantee = 0;\r\n        if (tokenSupply_ == 0){\r\n            _guarantee = tokenPriceInitial_;\r\n        } else\r\n            _guarantee = SafeMath.div((address(this).balance - ethereumBuy_)*defaultValue, tokenSupply_);\r\n        return _guarantee;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"EtherCenter","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://44d8fc66881d9f0b33102740fda098e0fbb765814aa151e5f10965fe2a044d88"}]}