{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.5;\r\nlibrary SafeMath{\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256){\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256){\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256){\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\ncontract EPlay {\r\n    modifier isOwner() {\r\n        require(msg.sender == _owner);\r\n        _;\r\n    }\r\nstruct User{\r\n        address userAddress;\r\n        uint investAmount;   \r\n        address inviter;    \r\n        address[] children; \r\n        uint invitersCount;   \r\n        uint achieveTime;   \r\n        uint annualRing;  \r\n        uint64 referCode;   \r\nuint birth;               \r\nuint rebirth;             \r\nbool gameOver;\r\n    }\r\n    address _owner;\r\n    address[] public investors;\r\n    mapping (address => User) public addressToUser;\r\n    mapping (uint64 => address) public codeToAddress;\r\n\r\n    uint256 minInvest;\r\n\r\n    uint256 maxInvest;\r\n\r\n    uint64 currentReferCode;\r\n\r\n\r\n    uint256 public globalNodeNumber = 0;\r\n\r\n    uint256 public totalInvestAmount;  \r\n\r\n    uint256 public ethMissPool; \r\n    uint256 public racePool;   \r\n    // address racePool;  \r\n    address fusePool;     \r\naddress guaranteePool;   \r\naddress foundingPool;    \r\naddress appFund;         \r\nuint256 oneLoop = 24 hours;\r\nuint256 roundOfLoop = 9;\r\n\r\n    constructor() public{\r\n        _owner = msg.sender;\r\n        minInvest = 1 ether;\r\n        maxInvest = 29 ether;\r\n        currentReferCode = 168870;\r\n\r\n        User memory creation = User(msg.sender, minInvest, address(0x0), new address[](0),0, 0,0,currentReferCode,now, now, false);\r\naddressToUser[msg.sender] = creation;\r\ncodeToAddress[currentReferCode] = msg.sender;\r\ncurrentReferCode = currentReferCode + 9;\r\n\r\nfusePool = address(0x513E61aD45ABCe80c3306BDF535b8964129f675d);\r\nguaranteePool = address(0xAfC22C4e544600675AA322608435ae6C65bccA05);\r\nfoundingPool = address(0xAD7565A73b145e7FC58fAc02eECa28a1591C551e);\r\nappFund = address(0x6464FC7e76c1167608A2aa9d4238A792FD766013);\r\n\r\n    }\r\n\tfunction transferOwnership(address newOwner) public isOwner {\r\n\t\trequire(newOwner != address(0x0), \"Ownable: new owner is the zero address\");\r\n\t\t_owner = newOwner;\r\n\t}\r\n\tfunction isOrNotOwner() public view returns (bool){\r\n\t    return _owner == msg.sender;\r\n\t}\r\n    function() payable external{\r\n        ethMissPool = SafeMath.add(ethMissPool,msg.value);\r\n    }\r\n\r\n\r\n    function invest(uint64 referrNO)public payable{\r\n\r\n        require(msg.value >= minInvest, \"less than min\");\r\n        User memory o_user = addressToUser[msg.sender];\r\n\r\n        require(SafeMath.add(msg.value, o_user.investAmount) <= maxInvest, \"more than max\");\r\n        address r_address =  codeToAddress[referrNO];\r\n        require (r_address != address(0x0), \"invalid referrNO\");\r\n        o_user.investAmount = SafeMath.add(o_user.investAmount, msg.value);\r\n        o_user.rebirth = now;\r\n        o_user.annualRing = 0;\r\n        o_user.gameOver = false;\r\n         User  storage r_user = addressToUser[r_address];\r\n        if (o_user.inviter == address(0x0)){\r\n\r\n           \r\n           \r\n            r_user.children.push(msg.sender);\r\n            o_user.birth = now;\r\n            o_user.inviter = r_user.userAddress;\r\n            o_user.userAddress = msg.sender;\r\n            codeToAddress[currentReferCode] = msg.sender;\r\n            o_user.referCode = currentReferCode;\r\n            currentReferCode = currentReferCode + 9;\r\n            investors.push(msg.sender);\r\n            globalNodeNumber = globalNodeNumber + 1;\r\n        }else{\r\n\r\n        }\r\n        r_user.invitersCount = SafeMath.add(r_user.invitersCount , msg.value);\r\n        r_user.achieveTime = now;\r\n        \r\n    addressToUser[msg.sender] = o_user;\r\n    totalInvestAmount = totalInvestAmount + msg.value;\r\n    address payable payFoundingPool = address(uint160(foundingPool));\r\n    payFoundingPool.transfer(SafeMath.div( msg.value, 100));\r\n    address payable payAppFund = address(uint160(appFund));\r\n    payAppFund.transfer(SafeMath.div( msg.value, 50));\r\n    racePool = SafeMath.add(racePool, SafeMath.div(msg.value, 100));\r\n    }\r\n    function sendReward() public isOwner{\r\n\r\n        for (uint i = 0; i < investors.length; i ++){\r\n            address _add = investors[i];\r\n            User memory _user = addressToUser[_add];\r\n            if (_user.gameOver){\r\n                autoReInvest(_add);\r\n                _user.rebirth = now - (oneLoop / 2);\r\n                addressToUser[_add] = _user;\r\n            }else {\r\n                if (SafeMath.sub(now , _user.rebirth) >=  oneLoop){\r\n                \r\n                  address payable needPay = address(uint160(_add));\r\n      \r\n                 uint staticAmount = getStatic(_add);\r\n                      if (staticAmount > 0){\r\n                     needPay.transfer(staticAmount);\r\n                    }\r\n                    uint dynamicAmount = getDynamic(_add);\r\n\r\n                    if (dynamicAmount > 0){\r\n                        needPay.transfer(dynamicAmount);\r\n                        address payable safePool = address(uint160(fusePool));\r\n                        safePool.transfer(SafeMath.div(dynamicAmount, 5));\r\n                  }\r\n                \r\n                   if(SafeMath.sub(now, _user.rebirth) >=  (oneLoop * roundOfLoop)){\r\n                        _user.annualRing = _user.annualRing + 1;\r\n                        _user.rebirth = now - (oneLoop / 2);\r\n                        _user.gameOver = true;\r\n                      addressToUser[_add] = _user;\r\n                     }\r\n                \r\n                 }\r\n            }\r\n        }\r\n    }\r\n    function autoReInvest(address _address) private {\r\n        User memory _user = addressToUser[_address];\r\n        require (_user.gameOver, \"auto reInvest\");\r\n        _user.gameOver = false;\r\n        addressToUser[_address] = _user;\r\n        uint payAmount = _user.investAmount;\r\n         address payable payFoundingPool = address(uint160(foundingPool));\r\n    payFoundingPool.transfer(SafeMath.div( payAmount, 100));\r\n    address payable payAppFund = address(uint160(appFund));\r\n    payAppFund.transfer(SafeMath.div(payAmount, 50));\r\n    }\r\n    function reInvest() public{\r\n      autoReInvest(msg.sender);\r\n    }\r\n    function canWithDraw() public view returns (bool){\r\n         User memory _user = addressToUser[msg.sender];\r\n        require (_user.gameOver, \"can't withdraw\");\r\n        return true;\r\n    }\r\n    function withDrawForUser() public{\r\n        User storage _user = addressToUser[msg.sender];\r\n        require (_user.gameOver, \"auto reInvest,can't withdraw\");\r\n        address payable needPay = address(uint160(_user.userAddress));\r\n        \r\n        uint payAmount = _user.investAmount;\r\n\r\n        require (payAmount > 0, \"no amount\");\r\n        _user.investAmount = 0;\r\n        if (_user.annualRing > 3){\r\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 95));\r\n            address payable pool = address(uint160(guaranteePool));\r\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),5));\r\n        }else if (_user.annualRing > 2){\r\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 90));\r\n            address payable pool = address(uint160(guaranteePool));\r\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),10));\r\n        }else if (_user.annualRing > 1){\r\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 85));\r\n            address payable pool = address(uint160(guaranteePool));\r\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),15));\r\n        }else if (_user.annualRing > 0){\r\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 80));\r\n            address payable pool = address(uint160(guaranteePool));\r\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),20));\r\n        }\r\n        \r\n    }\r\n    function getStatic(address _address) public view returns(uint){\r\nif (getLevel(_address) == 1){\r\n   User memory _user = addressToUser[_address];\r\n   return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),11 ); //0.7%\r\n}else if (getLevel(_address) == 2){\r\n   User memory _user = addressToUser[_address];\r\n   return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),11 ); //0.8%\r\n}else if (getLevel(_address) == 3){\r\n   User memory _user = addressToUser[_address];\r\n   return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),12 ); //1.0%\r\n}else if (getLevel(_address) == 4){\r\n   User memory _user = addressToUser[_address];\r\n   return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),13 ); //1.1%\r\n}\r\nreturn 0;\r\n    }\r\n    function getDynamic(address _address) public view returns(uint){\r\n       if (getLevel(_address) == 0){\r\n           return 0;\r\n       }else  if (getLevel(_address) == 1){\r\n            return getChildrenDynamic(_address, _address, 1, 1, 0);\r\n       }else  if (getLevel(_address) == 2){\r\n           return  getChildrenDynamic(_address, _address, 1, 2, 0);\r\n       }else  if (getLevel(_address) == 3){\r\n           return getChildrenDynamic(_address, _address, 1, 10, 0);\r\n       }else  if (getLevel(_address) == 4){\r\n           return getChildrenDynamic(_address, _address, 1, 99, 0);\r\n       }\r\n    }\r\n    function getChildrenDynamic(address adam, address _par,uint8 generation,uint endGeneration, uint total) public view returns (uint){\r\n\r\n    User memory _user = addressToUser[_par];\r\n    address[] memory child = _user.children;\r\n    uint myTotal = 0;\r\n\r\n    for (uint i = 0; i < child.length; i ++){\r\n        User memory _childUser = addressToUser[child[i]];\r\n        uint rate = getDynamicRate(adam, generation);\r\n        uint staticReward = 0;\r\n        User memory adamUser = addressToUser[adam];\r\n        if (adamUser.investAmount <= _childUser.investAmount){\r\n            staticReward = getStatic(adam);\r\n        }else {\r\n            staticReward = getStatic(_childUser.userAddress);\r\n        }\r\n        if (generation < endGeneration){\r\n            myTotal = getChildrenDynamic(adam, _childUser.userAddress, generation + 1, endGeneration, myTotal);\r\n        }\r\n        \r\n        myTotal = myTotal + SafeMath.mul(SafeMath.div(staticReward , 100),rate);\r\n    }\r\n    return myTotal + total;\r\n}\r\nfunction getDynamicRate(address _address,uint generation)public view returns (uint){\r\nif (getLevel(_address) == 1){\r\nif (generation == 1){\r\n    return 60;\r\n}\r\n}else if (getLevel(_address) == 2){\r\nif (generation == 1){\r\n    return 70;\r\n}else if (generation == 2){\r\n    return 30;\r\n}\r\n}else if (getLevel(_address) == 3){\r\n    if (generation == 1){\r\n    return 80;\r\n}else if (generation == 2){\r\n    return 30;\r\n}else if (generation == 3){\r\n    return 20;\r\n}else if (generation <= 10){\r\n    return 10;\r\n}\r\n\r\n}else if (getLevel(_address) == 4){\r\n   if (generation == 1){\r\n    return 100;\r\n}else if (generation == 2){\r\n    return 40;\r\n}else if (generation == 3){\r\n    return 30;\r\n}else if (generation <= 10){\r\n    return 10;\r\n}else if (generation <= 15){\r\n    return 5;\r\n}else if (generation <= 99){\r\n   return 1; \r\n}\r\n}\r\nreturn 0;\r\n}\r\n    \r\n\r\n    function getLevel(address _address) public view returns(uint8){\r\nUser memory _user = addressToUser[_address];\r\nif (_user.investAmount >= 16 ether){\r\nreturn 4;\r\n}else if (_user.investAmount >= 11 ether){\r\n    return 3;\r\n}else if (_user.investAmount >= 6 ether){\r\n    return 2;\r\n}else if (_user.investAmount >= 1 ether){\r\nreturn 1;\r\n}   \r\nreturn 0;\r\n }\r\n    function sendRace() public isOwner{\r\n\r\n        address[] memory top10 = getTop10();\r\n        uint256[9] memory rate = [uint256(40),20,10,5,5,5,5,5,5];\r\n        uint256 sendedAmount = 0;\r\n        for (uint i = 0; i < top10.length; i ++){\r\n            address _add = top10[i];\r\n            if (_add != address(0x0)){\r\n                User memory _user = addressToUser[_add];\r\n                if (_user.invitersCount != 0){\r\n                    address payable needPay = address(uint160(_user.userAddress));\r\n                    needPay.transfer(SafeMath.mul(SafeMath.div(racePool, 100), rate[i]));\r\n                    sendedAmount = sendedAmount + SafeMath.mul(SafeMath.div(racePool, 100), rate[i]);\r\n                }\r\n            }\r\n        }\r\n        racePool = SafeMath.sub(racePool, sendedAmount);\r\n        resetRace();\r\n\r\n\r\n    }\r\n    function getTop10() public view returns(address[] memory) {\r\n              address[] memory allInvitors = investors;\r\n         for (uint i = allInvitors.length - 1; i > 0; i--){\r\n             address temp;\r\n             for (uint j = i; j > 0; j--){\r\n                 User memory _user = addressToUser[allInvitors[j]];\r\n                 User memory _preUser = addressToUser[allInvitors[j - 1]];\r\n                 if (_user.invitersCount > _preUser.invitersCount){\r\n                     temp = allInvitors[j];\r\n                     allInvitors[j] = allInvitors[j - 1];\r\n                     allInvitors[j - 1] = temp;\r\n                 }else if (_user.invitersCount == _preUser.invitersCount && _user.achieveTime < _preUser.achieveTime){\r\n                    temp = allInvitors[j];\r\n                     allInvitors[j] = allInvitors[j - 1];\r\n                     allInvitors[j - 1] = temp;\r\n                }\r\n             }\r\n         }\r\n        address[] memory top9 = new address[](9);\r\n        uint count = 9;\r\n        if (allInvitors.length < 9){\r\n            count = allInvitors.length;\r\n        }\r\n        for (uint i = 0; i < count; i++){\r\n            top9[i] = allInvitors[i];\r\n        }\r\n\r\n         return top9;\r\n    }\r\n    function getTopInfo (uint rank)public view returns(address, uint, uint){\r\n         address[] memory allInvitors = investors;\r\n         for (uint i = allInvitors.length - 1; i > 0; i--){\r\n             address temp;\r\n             for (uint j = i; j > 0; j--){\r\n                 User memory _user = addressToUser[allInvitors[j]];\r\n                 User memory _preUser = addressToUser[allInvitors[j - 1]];\r\n                 if (_user.invitersCount > _preUser.invitersCount){\r\n                     temp = allInvitors[j];\r\n                     allInvitors[j] = allInvitors[j - 1];\r\n                     allInvitors[j - 1] = temp;\r\n                 }else if (_user.invitersCount == _preUser.invitersCount && _user.achieveTime < _preUser.achieveTime){\r\n                    temp = allInvitors[j];\r\n                     allInvitors[j] = allInvitors[j - 1];\r\n                     allInvitors[j - 1] = temp;\r\n                }\r\n             }\r\n         }\r\n         if (allInvitors.length > rank){\r\n         User memory userRank = addressToUser[allInvitors[rank]];\r\n\r\n         return (userRank.userAddress,userRank.children.length,userRank.invitersCount);\r\n         }else{\r\n        return(address(0x0),0,0);\r\n    }\r\n         \r\n    }\r\n    function resetRace() private isOwner{\r\n        for (uint i = 0; i < investors.length; i ++){\r\n            User storage _user = addressToUser[investors[i]];\r\n            _user.invitersCount = 0;\r\n        }\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"sendReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalNodeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"codeToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrNO\",\"type\":\"uint64\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethMissPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"generation\",\"type\":\"uint256\"}],\"name\":\"getDynamicRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStatic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop10\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"getTopInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withDrawForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canWithDraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adam\",\"type\":\"address\"},{\"name\":\"_par\",\"type\":\"address\"},{\"name\":\"generation\",\"type\":\"uint8\"},{\"name\":\"endGeneration\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"getChildrenDynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"racePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToUser\",\"outputs\":[{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"investAmount\",\"type\":\"uint256\"},{\"name\":\"inviter\",\"type\":\"address\"},{\"name\":\"invitersCount\",\"type\":\"uint256\"},{\"name\":\"achieveTime\",\"type\":\"uint256\"},{\"name\":\"annualRing\",\"type\":\"uint256\"},{\"name\":\"referCode\",\"type\":\"uint64\"},{\"name\":\"birth\",\"type\":\"uint256\"},{\"name\":\"rebirth\",\"type\":\"uint256\"},{\"name\":\"gameOver\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOrNotOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"EPlay","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://013e7402d7519d31baa1dea6b075c5ea65bf0a8b3a7a5d87ff2ac1aa3486792d"}]}