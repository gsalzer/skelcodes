{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\ncontract IBNEST {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint256 value) external;\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n    \r\n    function balancesStart() public view returns(uint256);\r\n    function balancesGetBool(uint256 num) public view returns(bool);\r\n    function balancesGetNext(uint256 num) public view returns(uint256);\r\n    function balancesGetValue(uint256 num) public view returns(address, uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = _a / _b;\r\n    assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract IBMapping {\r\n    function checkAddress(string memory name) public view returns (address contractAddress);\r\n    function checkOwners(address man) public view returns (bool);\r\n}\r\n\r\nlibrary address_make_payable {\r\n   function make_payable(address x) internal pure returns (address payable) {\r\n      return address(uint160(x));\r\n   }\r\n}\r\n\r\n/**\r\n * @title Nest storage contract\r\n */\r\ncontract NESTSave {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) baseMapping;                   //  General ledger\r\n    IBNEST nestContract;                                        //  Nest contract\r\n    IBMapping mappingContract;                                  //  Mapping contract \r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor(address map) public {\r\n        mappingContract = IBMapping(map); \r\n        nestContract = IBNEST(address(mappingContract.checkAddress(\"nest\")));\r\n    }\r\n    \r\n    /**\r\n    * @dev Change mapping contract\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner{\r\n        mappingContract = IBMapping(map); \r\n        nestContract = IBNEST(address(mappingContract.checkAddress(\"nest\")));\r\n    }\r\n    \r\n    /**\r\n    * @dev Take out nest\r\n    * @param num Quantity taken out\r\n    */\r\n    function takeOut(uint256 num) public onlyContract {\r\n        require(isContract(address(tx.origin)) == false);          \r\n        require(num <= baseMapping[tx.origin]);\r\n        baseMapping[address(tx.origin)] = baseMapping[address(tx.origin)].sub(num);\r\n        nestContract.transfer(address(tx.origin), num);\r\n    }\r\n    \r\n    /**\r\n    * @dev Deposit in nest\r\n    * @param num Deposit quantity\r\n    */\r\n    function depositIn(uint256 num) public onlyContract {\r\n        require(isContract(address(tx.origin)) == false);                               \r\n        require(nestContract.balanceOf(address(tx.origin)) >= num);                     \r\n        require(nestContract.allowance(address(tx.origin), address(this)) >= num);      \r\n        require(nestContract.transferFrom(address(tx.origin),address(this),num));       \r\n        baseMapping[address(tx.origin)] = baseMapping[address(tx.origin)].add(num);\r\n    }\r\n    \r\n    /**\r\n    * @dev Take out all\r\n    */\r\n    function takeOutPrivate() public {\r\n        require(isContract(address(msg.sender)) == false);          \r\n        require(baseMapping[msg.sender] > 0);\r\n        nestContract.transfer(address(msg.sender), baseMapping[msg.sender]);\r\n        baseMapping[address(msg.sender)] = 0;\r\n    }\r\n    \r\n    function checkAmount(address sender) public view returns(uint256) {\r\n        return baseMapping[address(sender)];\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyContract(){\r\n        require(mappingContract.checkAddress(\"nestAbonus\") == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function isContract(address addr) public view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Dividend pool contract\r\n */\r\ncontract Abonus {\r\n    using address_make_payable for address;\r\n    IBMapping mappingContract;                                  //  Mapping contract\r\n    \r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor(address map) public {\r\n        mappingContract = IBMapping(map);\r\n    }\r\n    \r\n    /**\r\n    * @dev Change mapping contract\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner{\r\n        mappingContract = IBMapping(map);\r\n    }\r\n    \r\n    /**\r\n    * @dev Draw ETH\r\n    * @param num Draw amount\r\n    * @param target Transfer target\r\n    */\r\n    function getETH(uint256 num, address target) public onlyContract {\r\n        require(num <= getETHNum());\r\n        address payable addr = target.make_payable();\r\n        addr.transfer(num);                                                                              \r\n    }\r\n    \r\n    function getETHNum() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    modifier onlyContract(){\r\n        require(mappingContract.checkAddress(\"nestAbonus\") == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    function () external payable {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * @title Leveling contract\r\n */\r\ncontract NESTLeveling {\r\n    using address_make_payable for address;\r\n    IBMapping mappingContract;                              //  Mapping contract\r\n\r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor (address map) public {\r\n        mappingContract = IBMapping(map); \r\n    }\r\n    \r\n    /**\r\n    * @dev Change mapping contract\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner {\r\n        mappingContract = IBMapping(map); \r\n    }\r\n    \r\n    /**\r\n    * @dev Transfer ETH\r\n    * @param amount Transfer quantity\r\n    * @param target Transfer target\r\n    */\r\n    function tranEth(uint256 amount, address target) public {\r\n        require(address(msg.sender) == address(mappingContract.checkAddress(\"nestAbonus\")));\r\n        uint256 tranAmount = amount;\r\n        if (amount > address(this).balance) {\r\n            tranAmount = address(this).balance;\r\n        }\r\n        address payable addr = target.make_payable();\r\n        addr.transfer(tranAmount);\r\n    }\r\n    \r\n    function () external payable {\r\n        \r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Dividend logical contract\r\n */\r\ncontract NESTAbonus {\r\n    using address_make_payable for address;\r\n    using SafeMath for uint256;\r\n    IBNEST nestContract;\r\n    IBMapping mappingContract;                  \r\n    NESTSave baseMapping;\r\n    Abonus abonusContract;\r\n    NESTLeveling nestLeveling;\r\n    uint256 timeLimit = 168 hours;                                  //  Dividend period\r\n    uint256 nextTime = 1587700800;                                  //  Next dividend time\r\n    uint256 getAbonusTimeLimit = 60 hours;                          //  Trigger calculation settlement time\r\n    uint256 ethNum = 0;                                             //  ETH amount\r\n    uint256 nestAllValue = 0;                                       //  Nest circulation\r\n    uint256 times = 0;                                              //  Dividend book\r\n    uint256 expectedIncrement = 3;                                  //  Expected dividend increment proportion\r\n    uint256 expectedMinimum = 100 ether;                            //  Expected minimum dividend\r\n    uint256 levelingProportion = 10;                                //  Proportion of dividends deducted\r\n    mapping(uint256 => mapping(address => bool)) getMapping;        //  Dividend collection record\r\n\r\n    /**\r\n    * @dev Initialization method\r\n    * @param map Mapping contract address\r\n    */\r\n    constructor (address map) public {\r\n        mappingContract = IBMapping(map); \r\n        nestContract = IBNEST(address(mappingContract.checkAddress(\"nest\")));\r\n        baseMapping = NESTSave(address(mappingContract.checkAddress(\"nestSave\")));\r\n        address payable addr = address(mappingContract.checkAddress(\"abonus\")).make_payable();\r\n        abonusContract = Abonus(addr);\r\n        address payable levelingAddr = address(mappingContract.checkAddress(\"nestLeveling\")).make_payable();\r\n        nestLeveling = NESTLeveling(levelingAddr);\r\n    }\r\n    \r\n    /**\r\n    * @dev Change mapping contract\r\n    * @param map Mapping contract address\r\n    */\r\n    function changeMapping(address map) public onlyOwner {\r\n        mappingContract = IBMapping(map); \r\n        nestContract = IBNEST(address(mappingContract.checkAddress(\"nest\")));\r\n        baseMapping = NESTSave(address(mappingContract.checkAddress(\"nestSave\")));\r\n        address payable addr = address(mappingContract.checkAddress(\"abonus\")).make_payable();\r\n        abonusContract = Abonus(addr);\r\n        address payable levelingAddr = address(mappingContract.checkAddress(\"nestLeveling\")).make_payable();\r\n        nestLeveling = NESTLeveling(levelingAddr);\r\n    }\r\n    \r\n    /**\r\n    * @dev Deposit in nest\r\n    * @param amount Deposit quantity\r\n    */\r\n    function depositIn(uint256 amount) public {\r\n        require(address(tx.origin) == address(msg.sender));         \r\n        uint256 nowTime = now;\r\n        if (nowTime < nextTime) {\r\n            require(!(nowTime >= nextTime.sub(timeLimit) && nowTime <= nextTime.sub(timeLimit).add(getAbonusTimeLimit)));\r\n        } else {\r\n            require(!(nowTime >= nextTime && nowTime <= nextTime.add(getAbonusTimeLimit)));\r\n            uint256 time = (nowTime.sub(nextTime)).div(timeLimit);\r\n            uint256 startTime = nextTime.add((time).mul(timeLimit));        \r\n            uint256 endTime = startTime.add(getAbonusTimeLimit);        \r\n            require(!(nowTime >= startTime && nowTime <= endTime));\r\n        }\r\n        baseMapping.depositIn(amount);                           \r\n    }\r\n    \r\n    /**\r\n    * @dev Take out nest\r\n    * @param amount Quantity taken out\r\n    */\r\n    function takeOut(uint256 amount) public {\r\n        require(address(tx.origin) == address(msg.sender));          \r\n        require(amount != 0);                                      \r\n        require(amount <= baseMapping.checkAmount(address(msg.sender)));\r\n        baseMapping.takeOut(amount);                           \r\n    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \r\n    \r\n    /**\r\n    * @dev Receive dividend\r\n    */\r\n    function getETH() public {\r\n        require(address(tx.origin) == address(msg.sender));        \r\n        reloadTimeAndMapping ();            \r\n        uint256 nowTime = now;\r\n        require(nowTime >= nextTime.sub(timeLimit) && nowTime <= nextTime.sub(timeLimit).add(getAbonusTimeLimit));\r\n        require(getMapping[times.sub(1)][address(msg.sender)] != true);       \r\n        uint256 nestAmount = baseMapping.checkAmount(address(msg.sender));\r\n        require(nestAmount > 0);\r\n        require(nestAllValue > 0);\r\n        uint256 selfEth = nestAmount.mul(ethNum).div(nestAllValue);\r\n        require(selfEth > 0);\r\n        getMapping[times.sub(1)][address(msg.sender)] = true;\r\n        abonusContract.getETH(selfEth, address(msg.sender));                        \r\n    }\r\n    \r\n    function levelingResult() private {\r\n        abonusContract.getETH(abonusContract.getETHNum().mul(levelingProportion).div(100), address(nestLeveling));\r\n        uint256 miningAmount = allValue().div(100000000 ether);\r\n        uint256 minimumAbonus = expectedMinimum;\r\n        for (uint256 i = 0; i < miningAmount; i++) {\r\n            minimumAbonus = minimumAbonus.add(minimumAbonus.mul(expectedIncrement).div(100));\r\n        }\r\n        uint256 nowEth = abonusContract.getETHNum();\r\n        if (nowEth < minimumAbonus) {\r\n            nestLeveling.tranEth(minimumAbonus.sub(nowEth), address(abonusContract));\r\n        }\r\n    }\r\n    \r\n    function reloadTimeAndMapping() private {\r\n        uint256 nowTime = now;\r\n        if (nowTime >= nextTime) {                                          \r\n            levelingResult();\r\n            uint256 time = (nowTime.sub(nextTime)).div(timeLimit);\r\n            uint256 startTime = nextTime.add((time).mul(timeLimit));      \r\n            uint256 endTime = startTime.add(getAbonusTimeLimit);           \r\n            if (nowTime >= startTime && nowTime <= endTime) {\r\n                nextTime = getNextTime();                                   \r\n                times = times.add(1);                                   \r\n                ethNum = abonusContract.getETHNum();                    \r\n                nestAllValue = allValue();                              \r\n            }\r\n        }\r\n    }\r\n    \r\n    function getInfo() public view returns (uint256 _nextTime, uint256 _getAbonusTime, uint256 _ethNum, uint256 _nestValue, uint256 _myJoinNest, uint256 _getEth, uint256 _allowNum, uint256 _leftNum, bool allowAbonus)  {\r\n        uint256 nowTime = now;\r\n        if (nowTime >= nextTime.sub(timeLimit) && nowTime <= nextTime.sub(timeLimit).add(getAbonusTimeLimit)) {\r\n            allowAbonus = getMapping[times.sub(1)][address(msg.sender)];\r\n            _ethNum = ethNum;\r\n            _nestValue = nestAllValue;\r\n        } else {\r\n            _ethNum = abonusContract.getETHNum();\r\n            _nestValue = allValue();\r\n            allowAbonus = getMapping[times][address(msg.sender)];\r\n        }\r\n        _myJoinNest = baseMapping.checkAmount(address(msg.sender));\r\n        if (allowAbonus == true) {\r\n            _getEth = 0; \r\n        } else {\r\n            _getEth = _myJoinNest.mul(_ethNum).div(_nestValue);\r\n        }\r\n        _nextTime = getNextTime();\r\n        _getAbonusTime = _nextTime.sub(timeLimit).add(getAbonusTimeLimit);\r\n        _allowNum = nestContract.allowance(address(msg.sender), address(baseMapping));\r\n        _leftNum = nestContract.balanceOf(address(msg.sender));\r\n    }\r\n    \r\n    function getNextTime() public view returns (uint256) {\r\n        uint256 nowTime = now;\r\n        if (nextTime > nowTime) { \r\n            return nextTime; \r\n        } else {\r\n            uint256 time = (nowTime.sub(nextTime)).div(timeLimit);\r\n            return nextTime.add(timeLimit.mul(time.add(1)));\r\n        }\r\n    }\r\n    \r\n    function allValue() public view returns (uint256) {\r\n        uint256 all = 10000000000 ether;\r\n        uint256 leftNum = all.sub(nestContract.balanceOf(address(mappingContract.checkAddress(\"miningSave\"))));\r\n        return leftNum;\r\n    }\r\n\r\n    function checkTimeLimit() public view returns(uint256) {\r\n        return timeLimit;\r\n    }\r\n\r\n    function checkGetAbonusTimeLimit() public view returns(uint256) {\r\n        return getAbonusTimeLimit;\r\n    }\r\n\r\n    function checkMinimumAbonus() public view returns(uint256) {\r\n        uint256 miningAmount = allValue().div(100000000 ether);\r\n        uint256 minimumAbonus = expectedMinimum;\r\n        for (uint256 i = 0; i < miningAmount; i++) {\r\n            minimumAbonus = minimumAbonus.add(minimumAbonus.mul(expectedIncrement).div(100));\r\n        }\r\n        return minimumAbonus;\r\n    }\r\n\r\n    function changeTimeLimit(uint256 hour) public onlyOwner {\r\n        require(hour > 0);\r\n        timeLimit = hour.mul(1 hours);\r\n    }\r\n\r\n    function changeGetAbonusTimeLimit(uint256 hour) public onlyOwner {\r\n        require(hour > 0);\r\n        getAbonusTimeLimit = hour;\r\n    }\r\n\r\n    function changeExpectedIncrement(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        expectedIncrement = num;\r\n    }\r\n\r\n    function changeExpectedMinimum(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        expectedMinimum = num;\r\n    }\r\n\r\n    function changeLevelingProportion(uint256 num) public onlyOwner {\r\n        require(num > 0);\r\n        levelingProportion = num;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(mappingContract.checkOwners(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"depositIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeOutPrivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"map\",\"type\":\"address\"}],\"name\":\"changeMapping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"takeOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"checkAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"map\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"NESTSave","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005e7db2ffc5b2c7c47103e4f21c702bc402603fbf","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://47edd32e9aa90309eb6d2351719fc142a39a4db207092efa6abedee9136ab13a"}]}