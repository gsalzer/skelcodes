{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\n\n\nlibrary Buffer {\n    \n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    \n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        \n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    \n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns(uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    \n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    \n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            \n            let bufptr := mload(buf)\n            \n            let buflen := mload(bufptr)\n            \n            dest := add(add(bufptr, 32), off)\n            \n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        \n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        \n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    \n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    \n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    \n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            \n            let bufptr := mload(buf)\n            \n            let buflen := mload(bufptr)\n            \n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            \n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    \n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    \n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint mask = 256 ** len - 1;\n        \n        data = data >> (8 * (32 - len));\n        assembly {\n            \n            let bufptr := mload(buf)\n            \n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            \n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    \n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    \n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    \n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    \n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint mask = 256 ** len - 1;\n        assembly {\n            \n            let bufptr := mload(buf)\n            \n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            \n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    \n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n        if(value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if(value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if(value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if(value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        encodeType(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if(value >= 0) {\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\n        } else {\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n        buf.append(value);\n    }\n\n    function encodeString(Buffer.buffer memory buf, string value) internal pure {\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256;\n\n  using CBOR for Buffer.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    Buffer.buffer buf;\n  }\n\n  \n  function initialize(\n    Request memory self,\n    bytes32 _id,\n    address _callbackAddress,\n    bytes4 _callbackFunction\n  ) internal pure returns (Chainlink.Request memory) {\n    Buffer.init(self.buf, defaultBufferSize);\n    self.id = _id;\n    self.callbackAddress = _callbackAddress;\n    self.callbackFunctionId = _callbackFunction;\n    return self;\n  }\n\n  \n  function setBuffer(Request memory self, bytes _data)\n    internal pure\n  {\n    Buffer.init(self.buf, _data.length);\n    Buffer.append(self.buf, _data);\n  }\n\n  \n  function add(Request memory self, string _key, string _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeString(_value);\n  }\n\n  \n  function addBytes(Request memory self, string _key, bytes _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeBytes(_value);\n  }\n\n  \n  function addInt(Request memory self, string _key, int256 _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeInt(_value);\n  }\n\n  \n  function addUint(Request memory self, string _key, uint256 _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeUInt(_value);\n  }\n\n  \n  function addStringArray(Request memory self, string _key, string[] memory _values)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < _values.length; i++) {\n      self.buf.encodeString(_values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n\ncontract ENSResolver {\n  function addr(bytes32 node) public view returns (address);\n}\n\ninterface ENSInterface {\n\n    \n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    \n    event Transfer(bytes32 indexed node, address owner);\n\n    \n    event NewResolver(bytes32 indexed node, address resolver);\n\n    \n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n\n}\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external returns (bool success);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external returns (uint256 balance);\n  function decimals() external returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external returns (string tokenName);\n  function symbol() external returns (string tokenSymbol);\n  function totalSupply() external returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 payment,\n    bytes32 id,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 version,\n    bytes data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n\nlibrary SafeMath {\n\n  \n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    \n    \n    \n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  \n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    \n    \n    \n    return _a / _b;\n  }\n\n  \n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  \n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\ncontract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n  using SafeMath for uint256;\n\n  uint256 constant internal LINK = 10**18;\n  uint256 constant private AMOUNT_OVERRIDE = 0;\n  address constant private SENDER_OVERRIDE = 0x0;\n  uint256 constant private ARGS_VERSION = 1;\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private ens;\n  bytes32 private ensNode;\n  LinkTokenInterface private link;\n  ChainlinkRequestInterface private oracle;\n  uint256 private requests = 1;\n  mapping(bytes32 => address) private pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  \n  function buildChainlinkRequest(\n    bytes32 _specId,\n    address _callbackAddress,\n    bytes4 _callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature);\n  }\n\n  \n  function sendChainlinkRequest(Chainlink.Request memory _req, uint256 _payment)\n    internal\n    returns (bytes32)\n  {\n    return sendChainlinkRequestTo(oracle, _req, _payment);\n  }\n\n  \n  function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment)\n    internal\n    returns (bytes32 requestId)\n  {\n    requestId = keccak256(abi.encodePacked(this, requests));\n    _req.nonce = requests;\n    pendingRequests[requestId] = _oracle;\n    emit ChainlinkRequested(requestId);\n    require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \"unable to transferAndCall to oracle\");\n    requests += 1;\n\n    return requestId;\n  }\n\n  \n  function cancelChainlinkRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunc,\n    uint256 _expiration\n  )\n    internal\n  {\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]);\n    delete pendingRequests[_requestId];\n    emit ChainlinkCancelled(_requestId);\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration);\n  }\n\n  \n  function setChainlinkOracle(address _oracle) internal {\n    oracle = ChainlinkRequestInterface(_oracle);\n  }\n\n  \n  function setChainlinkToken(address _link) internal {\n    link = LinkTokenInterface(_link);\n  }\n\n  \n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  \n  function chainlinkTokenAddress()\n    internal\n    view\n    returns (address)\n  {\n    return address(link);\n  }\n\n  \n  function chainlinkOracleAddress()\n    internal\n    view\n    returns (address)\n  {\n    return address(oracle);\n  }\n\n  \n  function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)\n    internal\n    notPendingRequest(_requestId)\n  {\n    pendingRequests[_requestId] = _oracle;\n  }\n\n  \n  function useChainlinkWithENS(address _ens, bytes32 _node)\n    internal\n  {\n    ens = ENSInterface(_ens);\n    ensNode = _node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver resolver = ENSResolver(ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  \n  function updateChainlinkOracleWithENS()\n    internal\n  {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver resolver = ENSResolver(ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  \n  function encodeRequest(Chainlink.Request memory _req)\n    private\n    view\n    returns (bytes memory)\n  {\n    return abi.encodeWithSelector(\n      oracle.oracleRequest.selector,\n      SENDER_OVERRIDE, \n      AMOUNT_OVERRIDE, \n      _req.id,\n      _req.callbackAddress,\n      _req.callbackFunctionId,\n      _req.nonce,\n      ARGS_VERSION,\n      _req.buf.buf);\n  }\n\n  \n  function validateChainlinkCallback(bytes32 _requestId)\n    internal\n    recordChainlinkFulfillment(_requestId)\n    \n  {}\n\n  \n  modifier recordChainlinkFulfillment(bytes32 _requestId) {\n    require(msg.sender == pendingRequests[_requestId], \"Source must be the oracle of the request\");\n    delete pendingRequests[_requestId];\n    emit ChainlinkFulfilled(_requestId);\n    _;\n  }\n\n  \n  modifier notPendingRequest(bytes32 _requestId) {\n    require(pendingRequests[_requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n\ncontract DSMath {\n    \n    \n\n    function add(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        assert((z = x * y) >= x);\n    }\n    \n    function div(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        require(y > 0);\n        z = x / y;\n    }\n    \n    function min(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n    function max(uint256 x, uint256 y) pure internal returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    \n\n\n    function hadd(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x + y) >= x);\n    }\n\n    function hsub(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x - y) <= x);\n    }\n\n    function hmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert((z = x * y) >= x);\n    }\n\n    function hdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        assert(y > 0);\n        z = x / y;\n    }\n\n    function hmin(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x <= y ? x : y;\n    }\n    function hmax(uint128 x, uint128 y) pure internal returns (uint128 z) {\n        return x >= y ? x : y;\n    }\n\n\n    \n\n    function imin(int256 x, int256 y) pure internal returns (int256 z) {\n        return x <= y ? x : y;\n    }\n    function imax(int256 x, int256 y) pure internal returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    \n\n    uint128 constant WAD = 10 ** 18;\n\n    function wadd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function wsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function wmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\n    }\n\n    function wdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * WAD + y / 2) / y);\n    }\n\n    function wmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function wmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    \n\n    uint128 constant RAY = 10 ** 27;\n\n    function radd(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hadd(x, y);\n    }\n\n    function rsub(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hsub(x, y);\n    }\n\n    function rmul(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\n    }\n\n    function rdiv(uint128 x, uint128 y) view internal returns (uint128 z) {\n        z = cast((uint256(x) * RAY + y / 2) / y);\n    }\n\n    function rpow(uint128 x, uint64 n) view internal returns (uint128 z) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n\n    function rmin(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmin(x, y);\n    }\n    function rmax(uint128 x, uint128 y) pure internal returns (uint128) {\n        return hmax(x, y);\n    }\n\n    function cast(uint256 x) pure internal returns (uint128 z) {\n        assert((z = uint128(x)) == x);\n    }\n\n}\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract MedianizerInterface {\n    function peek() public view returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke() public;\n    function poke(bytes32) public;\n    function fund (uint256 amount, ERC20 token) public;\n}\n\ncontract Oracle is DSMath {\n    uint32  constant public DELAY = 900; \n    uint128 constant public prem = 1100000000000000000; \n    uint128 constant public turn = 1010000000000000000; \n\n    MedianizerInterface med;\n\n    uint32 public expiry;\n    uint32 public timeout;\n    uint128 assetPrice;                     \n    uint128 public paymentTokenPrice;\n    uint256 rewardAmount;\n\n    mapping(bytes32 => AsyncRequest) asyncRequests;\n\n    struct AsyncRequest {\n        address rewardee;\n        uint128 payment;\n        uint128 disbursement;\n        ERC20 token;\n        bool assetPriceSet;\n        bool paymentTokenPriceSet;\n    }\n\n    function peek() public view\n        returns (bytes32,bool)\n    {\n        return (bytes32(uint(assetPrice)), now < expiry);\n    }\n\n    function read() public view\n        returns (bytes32)\n    {\n        assert(now < expiry);\n        return bytes32(uint(assetPrice));\n    }\n    \n    function setAssetPrice(bytes32 queryId, uint128 assetPrice_, uint32 expiry_) internal\n    {\n        asyncRequests[queryId].disbursement = 0;\n        if (assetPrice_ >= wmul(assetPrice, turn) || assetPrice_ <= wdiv(assetPrice, turn)) { asyncRequests[queryId].disbursement = asyncRequests[queryId].payment; }\n        assetPrice = assetPrice_;\n        expiry = expiry_;\n        med.poke();\n        asyncRequests[queryId].assetPriceSet = true;\n        if (asyncRequests[queryId].paymentTokenPriceSet) { reward(queryId); }\n    }\n\n    function setPaymentTokenPrice(bytes32 queryId, uint128 paymentTokenPrice_) internal {\n        paymentTokenPrice = paymentTokenPrice_;\n        asyncRequests[queryId].paymentTokenPriceSet = true;\n        if (asyncRequests[queryId].assetPriceSet) { reward(queryId); }\n    }\n\n    function reward(bytes32 queryId) internal { \n        rewardAmount = wmul(wmul(paymentTokenPrice, asyncRequests[queryId].disbursement), prem);\n        if (asyncRequests[queryId].token.balanceOf(address(this)) >= rewardAmount && asyncRequests[queryId].disbursement > 0) {\n            require(asyncRequests[queryId].token.transfer(asyncRequests[queryId].rewardee, rewardAmount));\n        }\n        delete(asyncRequests[queryId]);\n    }\n\n    function setMaxReward(uint256 maxReward_) public;\n}\n\ncontract ChainLink is ChainlinkClient, Oracle {\n    ERC20 link;\n    uint256 maxReward; \n\n    bytes32 public lastQueryId;\n\n    mapping(bytes32 => bytes32) linkIdToQueryId;\n\n    constructor(MedianizerInterface med_, ERC20 link_, address oracle_)\n        public\n    {\n        med = med_;\n        link = link_;\n        setChainlinkToken(address(link_));\n        setChainlinkOracle(oracle_);\n        asyncRequests[lastQueryId].payment = uint128(2 * LINK);\n    }\n\n    function bill() public view returns (uint256) {\n        return asyncRequests[lastQueryId].payment;\n    }\n\n    function update(uint128 payment_, ERC20 token_) { \n        require(uint32(now) > timeout);\n        require(link.transferFrom(msg.sender, address(this), uint(payment_)));\n        bytes32 queryId = getAssetPrice(payment_);\n        lastQueryId = queryId;\n        bytes32 linkId = getPaymentTokenPrice(payment_, queryId);\n        linkIdToQueryId[linkId] = queryId;\n        asyncRequests[queryId].rewardee = msg.sender;\n        asyncRequests[queryId].payment  = payment_;\n        asyncRequests[queryId].token    = token_;\n        timeout = uint32(now) + DELAY;\n    }\n\n    function getAssetPrice(uint128 payment) internal returns (bytes32);\n\n    function getPaymentTokenPrice(uint128 payment, bytes32 queryId) internal returns (bytes32);\n\n    function returnAssetPrice(bytes32 _requestId, uint256 _price) \n        public\n        recordChainlinkFulfillment(_requestId)\n    {\n        setAssetPrice(_requestId, uint128(_price), uint32(now + 43200));\n    }\n    \n    function returnPaymentTokenPrice(bytes32 _requestId, uint256 _price) \n        public\n        recordChainlinkFulfillment(_requestId)\n    {\n        setPaymentTokenPrice(linkIdToQueryId[_requestId], uint128(_price));\n    }\n\n    function reward(bytes32 queryId) internal { \n        rewardAmount = wmul(wmul(paymentTokenPrice, asyncRequests[queryId].disbursement), prem);\n        if (asyncRequests[queryId].token.balanceOf(address(this)) >= min(maxReward, rewardAmount) && asyncRequests[queryId].disbursement > 0) {\n            require(asyncRequests[queryId].token.transfer(asyncRequests[queryId].rewardee, min(maxReward, rewardAmount)));\n        }\n    }\n\n    function setMaxReward(uint256 maxReward_) public {\n        require(msg.sender == address(med));\n        maxReward = maxReward_;\n    }\n}\n\ncontract CoinMarketCap is ChainLink {\n    bytes32 constant UINT256_MUL_JOB = bytes32(\"f1805afed6a0482bb43702692ff9e061\"); \n    \n\n    constructor(MedianizerInterface med_, ERC20 link_, address oracle_)\n        public\n        ChainLink(med_, link_, oracle_)\n    {}\n\n    function getAssetPrice(uint128 payment) internal returns (bytes32 queryId) {\n        Chainlink.Request memory req = buildChainlinkRequest(UINT256_MUL_JOB, this, this.returnAssetPrice.selector);\n        req.add(\"sym\", \"BTC\");\n        req.add(\"convert\", \"USD\");\n        string[] memory path = new string[](5);\n        path[0] = \"data\";\n        path[1] = \"BTC\";\n        path[2] = \"quote\";\n        path[3] = \"USD\";\n        path[4] = \"price\";\n        req.addStringArray(\"copyPath\", path);\n        req.addInt(\"times\", 1000000000000000000);\n        queryId = sendChainlinkRequest(req, div(payment, 2));\n    }\n\n    function getPaymentTokenPrice(uint128 payment, bytes32 queryId) internal returns (bytes32) {\n        Chainlink.Request memory req = buildChainlinkRequest(UINT256_MUL_JOB, this, this.returnPaymentTokenPrice.selector);\n        req.add(\"sym\", \"LINK\");\n        req.add(\"convert\", \"USD\");\n        string[] memory path = new string[](5);\n        path[0] = \"data\";\n        path[1] = \"LINK\";\n        path[2] = \"quote\";\n        path[3] = \"USD\";\n        path[4] = \"price\";\n        req.addStringArray(\"copyPath\", path);\n        req.addInt(\"times\", 1000000000000000000);\n        bytes32 linkId = sendChainlinkRequest(req, div(payment, 2));\n        linkIdToQueryId[linkId] = queryId;\n        return linkId;\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastQueryId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxReward_\",\"type\":\"uint256\"}],\"name\":\"setMaxReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"returnAssetPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"turn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"returnPaymentTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payment_\",\"type\":\"uint128\"},{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expiry\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prem\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"med_\",\"type\":\"address\"},{\"name\":\"link_\",\"type\":\"address\"},{\"name\":\"oracle_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"}]","ContractName":"CoinMarketCap","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000010d2f250a30dc78f3b418730e6aae4c1cf695889000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000089f70fa9f439dbd0a1bc22a09befc56ada04d9b4","Library":"","LicenseType":"","SwarmSource":"bzzr://4779cdbd55f12c1126496e73081b271e076693037694aa09569d3089002f4f82"}]}