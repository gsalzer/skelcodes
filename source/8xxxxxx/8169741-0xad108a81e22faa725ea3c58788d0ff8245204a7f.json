{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        uint year;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        uint year;\r\n        uint month;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n\r\ninterface IDataStore {\r\n    /**\r\n     * @dev Changes security token atatched to this data store\r\n     * @param _securityToken address of the security token\r\n     */\r\n    function setSecurityToken(address _securityToken) external;\r\n\r\n    /**\r\n     * @dev Stores a uint256 data against a key\r\n     * @param _key Unique key to identify the data\r\n     * @param _data Data to be stored against the key\r\n     */\r\n    function setUint256(bytes32 _key, uint256 _data) external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _data) external;\r\n\r\n    function setAddress(bytes32 _key, address _data) external;\r\n\r\n    function setString(bytes32 _key, string calldata _data) external;\r\n\r\n    function setBytes(bytes32 _key, bytes calldata _data) external;\r\n\r\n    function setBool(bytes32 _key, bool _data) external;\r\n\r\n    /**\r\n     * @dev Stores a uint256 array against a key\r\n     * @param _key Unique key to identify the array\r\n     * @param _data Array to be stored against the key\r\n     */\r\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\r\n\r\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\r\n\r\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\r\n\r\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\r\n\r\n    /**\r\n     * @dev Inserts a uint256 element to the array identified by the key\r\n     * @param _key Unique key to identify the array\r\n     * @param _data Element to push into the array\r\n     */\r\n    function insertUint256(bytes32 _key, uint256 _data) external;\r\n\r\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\r\n\r\n    function insertAddress(bytes32 _key, address _data) external;\r\n\r\n    function insertBool(bytes32 _key, bool _data) external;\r\n\r\n    /**\r\n     * @dev Deletes an element from the array identified by the key.\r\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\r\n     * @param _key Unique key to identify the array\r\n     * @param _index Index of the element to delete\r\n     */\r\n    function deleteUint256(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteAddress(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteBool(bytes32 _key, uint256 _index) external;\r\n\r\n    /**\r\n     * @dev Stores multiple uint256 data against respective keys\r\n     * @param _keys Array of keys to identify the data\r\n     * @param _data Array of data to be stored against the respective keys\r\n     */\r\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\r\n\r\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\r\n\r\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\r\n\r\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\r\n\r\n    /**\r\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\r\n     * @param _keys Array of keys to identify the data\r\n     * @param _data Array of data to be inserted in arrays of the respective keys\r\n     */\r\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\r\n\r\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\r\n\r\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\r\n\r\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\r\n\r\n    function getUint256(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBytes32(bytes32 _key) external view returns(bytes32);\r\n\r\n    function getAddress(bytes32 _key) external view returns(address);\r\n\r\n    function getString(bytes32 _key) external view returns(string memory);\r\n\r\n    function getBytes(bytes32 _key) external view returns(bytes memory);\r\n\r\n    function getBool(bytes32 _key) external view returns(bool);\r\n\r\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\r\n\r\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\r\n\r\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\r\n\r\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\r\n\r\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\r\n\r\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\r\n\r\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\r\n\r\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\r\n\r\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\r\n\r\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\r\n\r\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\r\n\r\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\r\n}\r\n\r\n/**\r\n * @title Storage layout for VolumeRestrictionTM\r\n */\r\ncontract VolumeRestrictionTMStorage {\r\n\r\n    enum RestrictionType { Fixed, Percentage }\r\n\r\n    enum TypeOfPeriod { MultipleDays, OneDay, Both }\r\n\r\n    // Store the type of restriction corresponds to token holder address\r\n    mapping(address => TypeOfPeriod) holderToRestrictionType;\r\n\r\n    struct VolumeRestriction {\r\n        // If typeOfRestriction is `Percentage` then allowedTokens will be in\r\n        // the % (w.r.t to totalSupply) with a multiplier of 10**16 . else it\r\n        // will be fixed amount of tokens\r\n        uint256 allowedTokens;\r\n        uint256 startTime;\r\n        uint256 rollingPeriodInDays;\r\n        uint256 endTime;\r\n        RestrictionType typeOfRestriction;\r\n    }\r\n\r\n    struct IndividualRestrictions {\r\n        // Restriction stored corresponds to a particular token holder\r\n        mapping(address => VolumeRestriction) individualRestriction;\r\n        // Daily restriction stored corresponds to a particular token holder\r\n        mapping(address => VolumeRestriction) individualDailyRestriction;\r\n    }\r\n\r\n    // Individual and daily restrictions for investors\r\n    IndividualRestrictions individualRestrictions;\r\n\r\n    struct GlobalRestrictions {\r\n      // Global restriction that applies to all token holders\r\n      VolumeRestriction defaultRestriction;\r\n      // Daily global restriction that applies to all token holders (Total ST traded daily is restricted)\r\n      VolumeRestriction defaultDailyRestriction;\r\n    }\r\n\r\n    // Individual and daily restrictions for investors\r\n    GlobalRestrictions globalRestrictions;\r\n\r\n    struct BucketDetails {\r\n        uint256 lastTradedDayTime;\r\n        uint256 sumOfLastPeriod;   // It is the sum of transacted amount within the last rollingPeriodDays\r\n        uint256 daysCovered;    // No of days covered till (from the startTime of VolumeRestriction)\r\n        uint256 dailyLastTradedDayTime;\r\n        uint256 lastTradedTimestamp; // It is the timestamp at which last transaction get executed\r\n    }\r\n\r\n    struct BucketData {\r\n        // Storing _from => day's timestamp => total amount transact in a day --individual\r\n        mapping(address => mapping(uint256 => uint256)) bucket;\r\n        // Storing _from => day's timestamp => total amount transact in a day --individual\r\n        mapping(address => mapping(uint256 => uint256)) defaultBucket;\r\n        // Storing the information that used to validate the transaction\r\n        mapping(address => BucketDetails) userToBucket;\r\n        // Storing the information related to default restriction\r\n        mapping(address => BucketDetails) defaultUserToBucket;\r\n    }\r\n\r\n    BucketData bucketData;\r\n\r\n    // Hold exempt index\r\n    struct Exemptions {\r\n        mapping(address => uint256) exemptIndex;\r\n        address[] exemptAddresses;\r\n    }\r\n\r\n    Exemptions exemptions;\r\n\r\n}\r\n\r\nlibrary VolumeRestrictionLib {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = uint256(1);\r\n    uint8 internal constant INDEX = uint8(2);\r\n    bytes32 internal constant INVESTORFLAGS = \"INVESTORFLAGS\";\r\n    bytes32 internal constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\r\n    bytes32 internal constant WHITELIST = \"WHITELIST\";\r\n\r\n\r\n    function deleteHolderFromList(\r\n        mapping(address => VolumeRestrictionTMStorage.TypeOfPeriod) storage _holderToRestrictionType,\r\n        address _holder,\r\n        IDataStore _dataStore,\r\n        VolumeRestrictionTMStorage.TypeOfPeriod _typeOfPeriod\r\n    )\r\n        public\r\n    {\r\n        // Deleting the holder if holder's type of Period is `Both` type otherwise\r\n        // it will assign the given type `_typeOfPeriod` to the _holder typeOfPeriod\r\n        // `_typeOfPeriod` it always be contrary to the removing restriction\r\n        // if removing restriction is individual then typeOfPeriod is TypeOfPeriod.OneDay\r\n        // in uint8 its value is 1. if removing restriction is daily individual then typeOfPeriod\r\n        // is TypeOfPeriod.MultipleDays in uint8 its value is 0.\r\n        if (_holderToRestrictionType[_holder] != VolumeRestrictionTMStorage.TypeOfPeriod.Both) {\r\n            uint256 flags = _dataStore.getUint256(_getKey(INVESTORFLAGS, _holder));\r\n            flags = flags & ~(ONE << INDEX);\r\n            _dataStore.setUint256(_getKey(INVESTORFLAGS, _holder), flags);\r\n        } else {\r\n            _holderToRestrictionType[_holder] = _typeOfPeriod;\r\n        }\r\n    }\r\n\r\n    function addRestrictionData(\r\n        mapping(address => VolumeRestrictionTMStorage.TypeOfPeriod) storage _holderToRestrictionType,\r\n        address _holder,\r\n        VolumeRestrictionTMStorage.TypeOfPeriod _callFrom,\r\n        uint256 _endTime,\r\n        IDataStore _dataStore\r\n    )\r\n        public\r\n    {\r\n        uint256 flags = _dataStore.getUint256(_getKey(INVESTORFLAGS, _holder));\r\n        if (!_isExistingInvestor(_holder, _dataStore)) {\r\n            _dataStore.insertAddress(INVESTORSKEY, _holder);\r\n            //KYC data can not be present if added is false and hence we can set packed KYC as uint256(1) to set added as true\r\n            _dataStore.setUint256(_getKey(WHITELIST, _holder), uint256(1));\r\n        }\r\n        if (!_isVolRestricted(flags)) {\r\n            flags = flags | (ONE << INDEX);\r\n            _dataStore.setUint256(_getKey(INVESTORFLAGS, _holder), flags);\r\n        }\r\n        VolumeRestrictionTMStorage.TypeOfPeriod _type = _getTypeOfPeriod(_holderToRestrictionType[_holder], _callFrom, _endTime);\r\n        _holderToRestrictionType[_holder] = _type;\r\n    }\r\n\r\n    function isValidAmountAfterRestrictionChanges(\r\n        uint256 _amountTradedLastDay,\r\n        uint256 _amount,\r\n        uint256 _sumOfLastPeriod,\r\n        uint256 _allowedAmount,\r\n        uint256 _lastTradedTimestamp\r\n    )\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        // if restriction is to check whether the current transaction is performed within the 24 hours\r\n        // span after the last transaction performed by the user\r\n        if (BokkyPooBahsDateTimeLibrary.diffSeconds(_lastTradedTimestamp, now) < 86400) {\r\n            (,, uint256 lastTxDay) = BokkyPooBahsDateTimeLibrary.timestampToDate(_lastTradedTimestamp);\r\n            (,, uint256 currentTxDay) = BokkyPooBahsDateTimeLibrary.timestampToDate(now);\r\n            // This if statement is to check whether the last transaction timestamp (of `individualRestriction[_from]`\r\n            // when `_isDefault` is true or defaultRestriction when `_isDefault` is false) is comes within the same day of the current\r\n            // transaction timestamp or not.\r\n            if (lastTxDay == currentTxDay) {\r\n                // Not allow to transact more than the current transaction restriction allowed amount\r\n                if ((_sumOfLastPeriod.add(_amount)).add(_amountTradedLastDay) > _allowedAmount)\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Provide the restriction details of all the restricted addresses\r\n     * @return address List of the restricted addresses\r\n     * @return uint256 List of the tokens allowed to the restricted addresses corresponds to restricted address\r\n     * @return uint256 List of the start time of the restriction corresponds to restricted address\r\n     * @return uint256 List of the rolling period in days for a restriction corresponds to restricted address.\r\n     * @return uint256 List of the end time of the restriction corresponds to restricted address.\r\n     * @return uint8 List of the type of restriction to validate the value of the `allowedTokens`\r\n     * of the restriction corresponds to restricted address\r\n     */\r\n    function getRestrictionData(\r\n        mapping(address => VolumeRestrictionTMStorage.TypeOfPeriod) storage _holderToRestrictionType,\r\n        VolumeRestrictionTMStorage.IndividualRestrictions storage _individualRestrictions,\r\n        IDataStore _dataStore\r\n    )\r\n        public\r\n        view\r\n        returns(\r\n            address[] memory allAddresses,\r\n            uint256[] memory allowedTokens,\r\n            uint256[] memory startTime,\r\n            uint256[] memory rollingPeriodInDays,\r\n            uint256[] memory endTime,\r\n            VolumeRestrictionTMStorage.RestrictionType[] memory typeOfRestriction\r\n            )\r\n    {\r\n        address[] memory investors = _dataStore.getAddressArray(INVESTORSKEY);\r\n        uint256 counter;\r\n        uint256 i;\r\n        for (i = 0; i < investors.length; i++) {\r\n            if (_isVolRestricted(_dataStore.getUint256(_getKey(INVESTORFLAGS, investors[i])))) {\r\n                counter = counter + (_holderToRestrictionType[investors[i]] == VolumeRestrictionTMStorage.TypeOfPeriod.Both ? 2 : 1);\r\n            }\r\n        }\r\n        allAddresses = new address[](counter);\r\n        allowedTokens = new uint256[](counter);\r\n        startTime = new uint256[](counter);\r\n        rollingPeriodInDays = new uint256[](counter);\r\n        endTime = new uint256[](counter);\r\n        typeOfRestriction = new VolumeRestrictionTMStorage.RestrictionType[](counter);\r\n        counter = 0;\r\n        for (i = 0; i < investors.length; i++) {\r\n            if (_isVolRestricted(_dataStore.getUint256(_getKey(INVESTORFLAGS, investors[i])))) {\r\n                allAddresses[counter] = investors[i];\r\n                if (_holderToRestrictionType[investors[i]] == VolumeRestrictionTMStorage.TypeOfPeriod.MultipleDays) {\r\n                    _setValues(_individualRestrictions.individualRestriction[investors[i]], allowedTokens, startTime, rollingPeriodInDays, endTime, typeOfRestriction, counter);\r\n                }\r\n                else if (_holderToRestrictionType[investors[i]] == VolumeRestrictionTMStorage.TypeOfPeriod.OneDay) {\r\n                    _setValues(_individualRestrictions.individualDailyRestriction[investors[i]], allowedTokens, startTime, rollingPeriodInDays, endTime, typeOfRestriction, counter);\r\n                }\r\n                else if (_holderToRestrictionType[investors[i]] == VolumeRestrictionTMStorage.TypeOfPeriod.Both) {\r\n                    _setValues(_individualRestrictions.individualRestriction[investors[i]], allowedTokens, startTime, rollingPeriodInDays, endTime, typeOfRestriction, counter);\r\n                    counter++;\r\n                    allAddresses[counter] = investors[i];\r\n                    _setValues(_individualRestrictions.individualDailyRestriction[investors[i]], allowedTokens, startTime, rollingPeriodInDays, endTime, typeOfRestriction, counter);\r\n                }\r\n                counter++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setValues(\r\n        VolumeRestrictionTMStorage.VolumeRestriction memory _restriction,\r\n        uint256[] memory _allowedTokens,\r\n        uint256[] memory _startTime,\r\n        uint256[] memory _rollingPeriodInDays,\r\n        uint256[] memory _endTime,\r\n        VolumeRestrictionTMStorage.RestrictionType[] memory _typeOfRestriction,\r\n        uint256 _index\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        _allowedTokens[_index] = _restriction.allowedTokens;\r\n        _startTime[_index] = _restriction.startTime;\r\n        _rollingPeriodInDays[_index] = _restriction.rollingPeriodInDays;\r\n        _endTime[_index] = _restriction.endTime;\r\n        _typeOfRestriction[_index] = _restriction.typeOfRestriction;\r\n    }\r\n\r\n    function _isVolRestricted(uint256 _flags) internal pure returns(bool) {\r\n        uint256 volRestricted = (_flags >> INDEX) & ONE;\r\n        return (volRestricted > 0 ? true : false);\r\n    }\r\n\r\n    function _getTypeOfPeriod(\r\n        VolumeRestrictionTMStorage.TypeOfPeriod _currentTypeOfPeriod,\r\n        VolumeRestrictionTMStorage.TypeOfPeriod _callFrom,\r\n        uint256 _endTime\r\n    )\r\n        internal\r\n        pure\r\n        returns(VolumeRestrictionTMStorage.TypeOfPeriod)\r\n    {\r\n        if (_currentTypeOfPeriod != _callFrom && _endTime != uint256(0))\r\n            return VolumeRestrictionTMStorage.TypeOfPeriod.Both;\r\n        else\r\n            return _callFrom;\r\n    }\r\n\r\n    function _isExistingInvestor(address _investor, IDataStore _dataStore) internal view returns(bool) {\r\n        uint256 data = _dataStore.getUint256(_getKey(WHITELIST, _investor));\r\n        //extracts `added` from packed `_whitelistData`\r\n        return uint8(data) == 0 ? false : true;\r\n    }\r\n\r\n    function _getKey(bytes32 _key1, address _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module contract should implement\r\n */\r\ninterface IModule {\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() external pure returns(bytes4 initFunction);\r\n\r\n    /**\r\n     * @notice Return the permission flags that are associated with a module\r\n     */\r\n    function getPermissions() external view returns(bytes32[] memory permissions);\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract to allow pausing and unpausing of certain functions\r\n */\r\ncontract Pausable {\r\n    event Pause(address account);\r\n    event Unpause(address account);\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to unpause, returns to normal state\r\n    */\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(msg.sender);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module factory contract should implement\r\n */\r\ninterface IModuleFactory {\r\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\r\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\r\n    event GenerateModuleFromFactory(\r\n        address _module,\r\n        bytes32 indexed _moduleName,\r\n        address indexed _moduleFactory,\r\n        address _creator,\r\n        uint256 _setupCost,\r\n        uint256 _setupCostInPoly\r\n    );\r\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    //Should create an instance of the Module, or throw\r\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function version() external view returns(string memory moduleVersion);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function name() external view returns(bytes32 moduleName);\r\n\r\n    /**\r\n     * @notice Returns the title associated with the module\r\n     */\r\n    function title() external view returns(string memory moduleTitle);\r\n\r\n    /**\r\n     * @notice Returns the description associated with the module\r\n     */\r\n    function description() external view returns(string memory moduleDescription);\r\n\r\n    /**\r\n     * @notice Get the setup cost of the module in USD\r\n     */\r\n    function setupCost() external returns(uint256 usdSetupCost);\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[] memory moduleTypes);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns(bytes32[] memory moduleTags);\r\n\r\n    /**\r\n     * @notice Used to change the setup fee\r\n     * @param _newSetupCost New setup fee\r\n     */\r\n    function changeSetupCost(uint256 _newSetupCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the currency and amount setup cost\r\n     * @param _setupCost new setup cost\r\n     * @param _isCostInPoly new setup cost currency. USD or POLY\r\n     */\r\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion New version array\r\n     */\r\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\r\n\r\n    /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function setupCostInPoly() external returns (uint256 polySetupCost);\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return Lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\r\n\r\n    /**\r\n     * @notice Used to get the upper bound\r\n     * @return Upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\r\n\r\n    /**\r\n     * @notice Updates the tags of the ModuleFactory\r\n     * @param _tagsData New list of tags\r\n     */\r\n    function changeTags(bytes32[] calldata _tagsData) external;\r\n\r\n    /**\r\n     * @notice Updates the name of the ModuleFactory\r\n     * @param _name New name that will replace the old one.\r\n     */\r\n    function changeName(bytes32 _name) external;\r\n\r\n    /**\r\n     * @notice Updates the description of the ModuleFactory\r\n     * @param _description New description that will replace the old one.\r\n     */\r\n    function changeDescription(string calldata _description) external;\r\n\r\n    /**\r\n     * @notice Updates the title of the ModuleFactory\r\n     * @param _title New Title that will replace the old one.\r\n     */\r\n    function changeTitle(string calldata _title) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n    // Standard ERC20 interface\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n    function approve(address spender, uint256 value) external returns(bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    // Emit at the time when module get added\r\n    event ModuleAdded(\r\n        uint8[] _types,\r\n        bytes32 indexed _name,\r\n        address indexed _moduleFactory,\r\n        address _module,\r\n        uint256 _moduleCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    );\r\n\r\n    // Emit when the token details get updated\r\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\r\n    // Emit when the token name get updated\r\n    event UpdateTokenName(string _oldName, string _newName);\r\n    // Emit when the granularity get changed\r\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\r\n    // Emit when is permanently frozen by the issuer\r\n    event FreezeIssuance();\r\n    // Emit when transfers are frozen or unfrozen\r\n    event FreezeTransfers(bool _status);\r\n    // Emit when new checkpoint created\r\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\r\n    // Events to log controller actions\r\n    event SetController(address indexed _oldController, address indexed _newController);\r\n    //Event emit when the global treasury wallet address get changed\r\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\r\n    event DisableController();\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    // Emit when Module get archived from the securityToken\r\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get unarchived from the securityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get removed from the securityToken\r\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when the budget allocated to a module is changed\r\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed _fromPartition,\r\n        address _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // Issuance / Redemption Events\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Document Events\r\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n\r\n    // Controller Events\r\n    event ControllerTransfer(\r\n        address _controller,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    event ControllerRedemption(\r\n        address _controller,\r\n        address indexed _tokenHolder,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Issuance / Redemption Events\r\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\r\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\r\n\r\n    /**\r\n     * @notice Initialization function\r\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\r\n     * @dev Can only be called once\r\n     */\r\n    function initialize(address _getterDelegate) external;\r\n\r\n    /**\r\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\r\n     * and return details indicating the reason if the transfer is not valid.\r\n     * @param _from The address from whom the tokens get transferred.\r\n     * @param _to The address to which to transfer tokens to.\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\r\n     * @return Application specific reason codes with additional details\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function canTransferByPartition(\r\n        address _from,\r\n        address _to,\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        view\r\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    /**\r\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\r\n     * @param _documentHash hash (of the contents) of the document.\r\n     */\r\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\r\n\r\n    /**\r\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     */\r\n    function removeDocument(bytes32 _name) external;\r\n\r\n    /**\r\n     * @notice Used to return the details of a document with a known name (`bytes32`).\r\n     * @param _name Name of the document\r\n     * @return string The URI associated with the document.\r\n     * @return bytes32 The hash (of the contents) of the document.\r\n     * @return uint256 the timestamp at which the document was last modified.\r\n     */\r\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\r\n\r\n    /**\r\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\r\n     * @return bytes32 List of all documents names present in the contract.\r\n     */\r\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\r\n\r\n    /**\r\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\r\n     * or not `isControllable` function will be used.\r\n     * @dev If `isControllable` returns `false` then it always return `false` and\r\n     * `controllerTransfer` / `controllerRedeem` will always revert.\r\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\r\n     */\r\n    function isControllable() external view returns (bool controlled);\r\n\r\n    /**\r\n     * @notice Checks if an address is a module of certain type\r\n     * @param _module Address to check\r\n     * @param _type type to check against\r\n     */\r\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\r\n\r\n    /**\r\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\r\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\r\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\r\n     * is allowed to call by the operator.\r\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\r\n     * @param _value The amount of tokens need to be issued\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     */\r\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\r\n     * @dev Can only be called by the issuer or STO attached to the token.\r\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\r\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\r\n     * @return success\r\n     */\r\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\r\n\r\n    /**\r\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\r\n     * @param _partition The partition to allocate the increase in balance\r\n     * @param _tokenHolder The token holder whose balance should be increased\r\n     * @param _value The amount by which to increase the balance\r\n     * @param _data Additional data attached to the minting of tokens\r\n     */\r\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\r\n     * @param _partition The partition to allocate the decrease in balance\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     */\r\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeem(uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @dev It is analogy to `transferFrom`\r\n     * @param _tokenHolder The account whose tokens gets redeemed.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\r\n     * @dev This function can only be called by the authorised operator.\r\n     * @param _partition The partition to allocate the decrease in balance.\r\n     * @param _tokenHolder The token holder whose balance should be decreased\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     */\r\n    function operatorRedeemByPartition(\r\n        bytes32 _partition,\r\n        address _tokenHolder,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Array of module types\r\n     * @return bytes32 Module label\r\n     */\r\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice use to return the global treasury wallet\r\n     */\r\n    function getTreasuryWallet() external view returns(address treasuryWallet);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Gets list of times that checkpoints were created\r\n     * @return List of checkpoint times\r\n     */\r\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\r\n\r\n    /**\r\n     * @notice returns an array of investors\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @return list of addresses\r\n     */\r\n    function getInvestors() external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors with non zero balance at a given checkpoint\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\r\n     */\r\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     * @param _partition The partition to check\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     */\r\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Return all partitions\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return List of partitions\r\n     */\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\r\n\r\n    /**\r\n     * @notice Gets data store address\r\n     * @return data store address\r\n     */\r\n    function dataStore() external view returns (address dataStoreAddress);\r\n\r\n    /**\r\n    * @notice Allows owner to change data store\r\n    * @param _dataStore Address of the token data store\r\n    */\r\n    function changeDataStore(address _dataStore) external;\r\n\r\n\r\n    /**\r\n     * @notice Allows to change the treasury wallet address\r\n     * @param _wallet Ethereum address of the treasury wallet\r\n     */\r\n    function changeTreasuryWallet(address _wallet) external;\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n     * @param _tokenContract Address of the ERC20Basic compliance token\r\n     * @param _value Amount of POLY to withdraw\r\n     */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\r\n    * @param _module Module address\r\n    * @param _change Change in allowance\r\n    * @param _increase True if budget has to be increased, false if decrease\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string calldata _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows owner to change token name\r\n    * @param _name new name of the token\r\n    */\r\n    function changeName(string calldata _name) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Permanently freeze issuance of this security token.\r\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\r\n     */\r\n    function freezeIssuance(bytes calldata _signature) external;\r\n\r\n    /**\r\n      * @notice Attachs a module to the SecurityToken\r\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n      * @dev to control restrictions on transfers.\r\n      * @param _moduleFactory is the address of the module factory to be added\r\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n      * @param _maxCost max amount of POLY willing to pay to the module.\r\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n      * @param _label custom module label.\r\n      * @param _archived whether to add the module as an archived module\r\n      */\r\n    function addModuleWithLabel(\r\n        address _moduleFactory,\r\n        bytes calldata _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n     * @param _archived whether to add the module as an archived module\r\n     */\r\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\r\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\r\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _from Address The address which you want to send tokens from\r\n     * @param _to Address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\r\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\r\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _tokenHolder The account whose tokens will be redeemed.\r\n     * @param _value uint256 the amount of tokens need to be redeemed.\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n    function disableController(bytes calldata _signature) external;\r\n\r\n    /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n    function getVersion() external view returns(uint8[] memory version);\r\n\r\n    /**\r\n     * @notice Gets the investor count\r\n     */\r\n    function getInvestorCount() external view returns(uint256 investorCount);\r\n\r\n    /**\r\n     * @notice Gets the holder count (investors with non zero balance)\r\n     */\r\n    function holderCount() external view returns(uint256 count);\r\n\r\n    /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\r\n\r\n    /**\r\n     * @notice Get the balance according to the provided partitions\r\n     * @param _partition Partition which differentiate the tokens.\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return Amount of tokens as per the given partitions\r\n     */\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\r\n\r\n    /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n    function granularity() external view returns(uint256 granularityAmount);\r\n\r\n    /**\r\n      * @notice Provides the address of the polymathRegistry\r\n      * @return address\r\n      */\r\n    function polymathRegistry() external view returns(address registryAddress);\r\n\r\n    /**\r\n    * @notice Upgrades a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function upgradeModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Upgrades security token\r\n    */\r\n    function upgradeToken() external;\r\n\r\n    /**\r\n     * @notice A security token issuer can specify that issuance has finished for the token\r\n     * (i.e. no new tokens can be minted or issued).\r\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\r\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\r\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\r\n     */\r\n    function isIssuable() external view returns (bool issuable);\r\n\r\n    /**\r\n     * @notice Authorises an operator for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being authorised.\r\n     */\r\n    function authorizeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Authorises an operator for a given partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is authorised\r\n     * @param _operator An address which is being authorised\r\n     */\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is de-authorised\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens.\r\n     * @param _from The address from which to transfer tokens from\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function operatorTransferByPartition(\r\n        bytes32 _partition,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    )\r\n        external\r\n        returns (bytes32 partition);\r\n\r\n    /*\r\n    * @notice Returns if transfers are currently frozen or not\r\n    */\r\n    function transfersFrozen() external view returns (bool isFrozen);\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() external view returns (bool);\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() external view returns (address ownerAddress);\r\n\r\n    function controller() external view returns(address controllerAddress);\r\n\r\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\r\n\r\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\r\n\r\n    function polyToken() external view returns(address polyTokenAddress);\r\n\r\n    function tokenFactory() external view returns(address tokenFactoryAddress);\r\n\r\n    function getterDelegate() external view returns(address delegate);\r\n\r\n    function controllerDisabled() external view returns(bool isDisabled);\r\n\r\n    function initialized() external view returns(bool isInitialized);\r\n\r\n    function tokenDetails() external view returns(string memory details);\r\n\r\n    function updateFromRegistry() external;\r\n\r\n}\r\n\r\ninterface ICheckPermission {\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPerm);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Storage for Module contract\r\n * @notice Contract is abstract\r\n */\r\ncontract ModuleStorage {\r\n    address public factory;\r\n\r\n    ISecurityToken public securityToken;\r\n\r\n    // Permission flag\r\n    bytes32 public constant ADMIN = \"ADMIN\";\r\n    bytes32 public constant OPERATOR = \"OPERATOR\";\r\n\r\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\r\n\r\n    IERC20 public polyToken;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor(address _securityToken, address _polyAddress) public {\r\n        securityToken = ISecurityToken(_securityToken);\r\n        factory = msg.sender;\r\n        polyToken = IERC20(_polyAddress);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface that any module contract should implement\r\n * @notice Contract is abstract\r\n */\r\ncontract Module is IModule, ModuleStorage, Pausable {\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public\r\n    ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n    }\r\n\r\n    //Allows owner, factory or permissioned delegate\r\n    modifier withPerm(bytes32 _perm) {\r\n        require(_checkPerm(_perm, msg.sender), \"Invalid permission\");\r\n        _;\r\n    }\r\n\r\n    function _checkPerm(bytes32 _perm, address _caller) internal view returns (bool) {\r\n        bool isOwner = _caller == Ownable(address(securityToken)).owner();\r\n        bool isFactory = _caller == factory;\r\n        return isOwner || isFactory || ICheckPermission(address(securityToken)).checkPermission(_caller, address(this), _perm);\r\n    }\r\n\r\n    function _onlySecurityTokenOwner() internal view {\r\n        require(msg.sender == Ownable(address(securityToken)).owner(), \"Sender is not owner\");\r\n    }\r\n\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"Sender is not factory\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Pause (overridden function)\r\n     */\r\n    function pause() public {\r\n        _onlySecurityTokenOwner();\r\n        super._pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause (overridden function)\r\n     */\r\n    function unpause() public {\r\n        _onlySecurityTokenOwner();\r\n        super._unpause();\r\n    }\r\n\r\n    /**\r\n     * @notice used to return the data store address of securityToken\r\n     */\r\n    function getDataStore() public view returns(IDataStore) {\r\n        return IDataStore(securityToken.dataStore());\r\n    }\r\n\r\n    /**\r\n    * @notice Reclaims ERC20Basic compatible tokens\r\n    * @dev We duplicate here due to the overriden owner & onlyOwner\r\n    * @param _tokenContract The address of the token contract\r\n    */\r\n    function reclaimERC20(address _tokenContract) external {\r\n        _onlySecurityTokenOwner();\r\n        require(_tokenContract != address(0), \"Invalid address\");\r\n        IERC20 token = IERC20(_tokenContract);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(token.transfer(msg.sender, balance), \"Transfer failed\");\r\n    }\r\n\r\n   /**\r\n    * @notice Reclaims ETH\r\n    * @dev We duplicate here due to the overriden owner & onlyOwner\r\n    */\r\n    function reclaimETH() external {\r\n        _onlySecurityTokenOwner();\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all Transfer Manager modules\r\n */\r\ninterface ITransferManager {\r\n    //  If verifyTransfer returns:\r\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\r\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\r\n    //  VALID, then the transfer is valid for this TM\r\n    //  NA, then the result from this TM is ignored\r\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\r\n\r\n    /**\r\n     * @notice Determines if the transfer between these two accounts can happen\r\n     */\r\n    function executeTransfer(address _from, address _to, uint256 _amount, bytes calldata _data) external returns(Result result);\r\n\r\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes calldata _data) external view returns(Result result, bytes32 partition);\r\n\r\n    /**\r\n     * @notice return the amount of tokens for a given user as per the partition\r\n     * @param _partition Identifier\r\n     * @param _tokenHolder Whom token amount need to query\r\n     * @param _additionalBalance It is the `_value` that transfer during transfer/transferFrom function call\r\n     */\r\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 _additionalBalance) external view returns(uint256 amount);\r\n\r\n}\r\n\r\n/**\r\n * @title Base abstract contract to be implemented by all Transfer Manager modules\r\n */\r\ncontract TransferManager is ITransferManager, Module {\r\n\r\n    bytes32 public constant LOCKED = \"LOCKED\";\r\n    bytes32 public constant UNLOCKED = \"UNLOCKED\";\r\n\r\n    modifier onlySecurityToken() {\r\n        require(msg.sender == address(securityToken), \"Sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    // Provide default versions of ERC1410 functions that can be overriden\r\n\r\n    /**\r\n     * @notice return the amount of tokens for a given user as per the partition\r\n     * @dev returning the balance of token holder against the UNLOCKED partition. \r\n     * This condition is valid only when the base contract doesn't implement the\r\n     * `getTokensByPartition()` function.  \r\n     */\r\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 /*_additionalBalance*/) external view returns(uint256) {\r\n        if (_partition == UNLOCKED)\r\n            return securityToken.balanceOf(_tokenHolder);\r\n        return uint256(0);\r\n    }\r\n\r\n}\r\n\r\ncontract VolumeRestrictionTM is VolumeRestrictionTMStorage, TransferManager {\r\n    using SafeMath for uint256;\r\n\r\n    // Emit when the token holder is added/removed from the exemption list\r\n    event ChangedExemptWalletList(address indexed _wallet, bool _exempted);\r\n    // Emit when the new individual restriction is added corresponds to new token holders\r\n    event AddIndividualRestriction(\r\n        address indexed _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when the new daily (Individual) restriction is added\r\n    event AddIndividualDailyRestriction(\r\n        address indexed _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when the individual restriction is modified for a given address\r\n    event ModifyIndividualRestriction(\r\n        address indexed _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when individual daily restriction get modified\r\n    event ModifyIndividualDailyRestriction(\r\n        address indexed _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when the new global restriction is added\r\n    event AddDefaultRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when the new daily (Default) restriction is added\r\n    event AddDefaultDailyRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when default restriction get modified\r\n    event ModifyDefaultRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when daily default restriction get modified\r\n    event ModifyDefaultDailyRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _typeOfRestriction\r\n    );\r\n    // Emit when the individual restriction gets removed\r\n    event IndividualRestrictionRemoved(address indexed _holder);\r\n    // Emit when individual daily restriction removed\r\n    event IndividualDailyRestrictionRemoved(address indexed _holder);\r\n    // Emit when the default restriction gets removed\r\n    event DefaultRestrictionRemoved();\r\n    // Emit when the daily default restriction gets removed\r\n    event DefaultDailyRestrictionRemoved();\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress)\r\n    public\r\n    Module(_securityToken, _polyAddress)\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Used to verify the transfer/transferFrom transaction and prevent tranaction\r\n     * whose volume of tokens will voilate the maximum volume transfer restriction\r\n     * @param _from Address of the sender\r\n     * @param _amount The amount of tokens to transfer\r\n     */\r\n    function executeTransfer(address _from, address /*_to */, uint256 _amount, bytes calldata /*_data*/) external onlySecurityToken returns (Result success) {\r\n        uint256 fromTimestamp;\r\n        uint256 sumOfLastPeriod;\r\n        uint256 daysCovered;\r\n        uint256 dailyTime;\r\n        uint256 endTime;\r\n        bool isGlobal;\r\n        (success, fromTimestamp, sumOfLastPeriod, daysCovered, dailyTime, endTime, ,isGlobal) = _verifyTransfer(_from, _amount);\r\n        if (fromTimestamp != 0 || dailyTime != 0) {\r\n            _updateStorage(\r\n                _from,\r\n                _amount,\r\n                fromTimestamp,\r\n                sumOfLastPeriod,\r\n                daysCovered,\r\n                dailyTime,\r\n                endTime,\r\n                isGlobal\r\n            );\r\n        }\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to verify the transfer/transferFrom transaction and prevent tranaction\r\n     * whose volume of tokens will voilate the maximum volume transfer restriction\r\n     * @param _from Address of the sender\r\n     * @param _amount The amount of tokens to transfer\r\n     */\r\n    function verifyTransfer(\r\n        address _from,\r\n        address /*_to*/ ,\r\n        uint256 _amount,\r\n        bytes memory /*_data*/\r\n    )\r\n        public\r\n        view\r\n        returns (Result, bytes32)\r\n    {\r\n\r\n        (Result success,,,,,,,) = _verifyTransfer(_from, _amount);\r\n        if (success == Result.INVALID)\r\n            return (success, bytes32(uint256(address(this)) << 96));\r\n        return (Result.NA, bytes32(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Used to verify the transfer/transferFrom transaction and prevent tranaction\r\n     * whose volume of tokens will voilate the maximum volume transfer restriction\r\n     * @param _from Address of the sender\r\n     * @param _amount The amount of tokens to transfer\r\n     */\r\n    function _verifyTransfer(\r\n        address _from,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n        view\r\n        returns (Result, uint256, uint256, uint256, uint256, uint256, uint256, bool)\r\n    {\r\n        // If `_from` is present in the exemptionList or it is `0x0` address then it will not follow the vol restriction\r\n        if (!paused && _from != address(0) && exemptions.exemptIndex[_from] == 0) {\r\n            // Checking the individual restriction if the `_from` comes in the individual category\r\n            if ((individualRestrictions.individualRestriction[_from].endTime >= now && individualRestrictions.individualRestriction[_from].startTime <= now)\r\n                || (individualRestrictions.individualDailyRestriction[_from].endTime >= now && individualRestrictions.individualDailyRestriction[_from].startTime <= now)) {\r\n\r\n                return _restrictionCheck(_amount, _from, false, individualRestrictions.individualRestriction[_from]);\r\n                // If the `_from` doesn't fall under the individual category. It will processed with in the global category automatically\r\n            } else if ((globalRestrictions.defaultRestriction.endTime >= now && globalRestrictions.defaultRestriction.startTime <= now)\r\n                || (globalRestrictions.defaultDailyRestriction.endTime >= now && globalRestrictions.defaultDailyRestriction.startTime <= now)) {\r\n\r\n                return _restrictionCheck(_amount, _from, true, globalRestrictions.defaultRestriction);\r\n            }\r\n        }\r\n        return (Result.NA, 0, 0, 0, 0, 0, 0, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Add/Remove wallet address from the exempt list\r\n     * @param _wallet Ethereum wallet/contract address that need to be exempted\r\n     * @param _exempted Boolean value used to add (i.e true) or remove (i.e false) from the list\r\n     */\r\n    function changeExemptWalletList(address _wallet, bool _exempted) public withPerm(ADMIN) {\r\n        require(_wallet != address(0));\r\n        require((exemptions.exemptIndex[_wallet] == 0) == _exempted);\r\n        if (_exempted) {\r\n            exemptions.exemptAddresses.push(_wallet);\r\n            exemptions.exemptIndex[_wallet] = exemptions.exemptAddresses.length;\r\n        } else {\r\n            exemptions.exemptAddresses[exemptions.exemptIndex[_wallet] - 1] = exemptions.exemptAddresses[exemptions.exemptAddresses.length - 1];\r\n            exemptions.exemptIndex[exemptions.exemptAddresses[exemptions.exemptIndex[_wallet] - 1]] = exemptions.exemptIndex[_wallet];\r\n            delete exemptions.exemptIndex[_wallet];\r\n            exemptions.exemptAddresses.length--;\r\n        }\r\n        emit ChangedExemptWalletList(_wallet, _exempted);\r\n    }\r\n\r\n    /**\r\n     * @notice Use to add the new individual restriction for a given token holder\r\n     * @param _holder Address of the token holder, whom restriction will be implied\r\n     * @param _allowedTokens Amount of tokens allowed to be trade for a given address.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function addIndividualRestriction(\r\n        address _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        public\r\n        withPerm(ADMIN)\r\n    {\r\n        // It will help to reduce the chances of transaction failure (Specially when the issuer\r\n        // wants to set the startTime near to the current block.timestamp) and minting delayed because\r\n        // of the gas fee or network congestion that lead to the process block timestamp may grater\r\n        // than the given startTime.\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        require(_holder != address(0) && exemptions.exemptIndex[_holder] == 0, \"Invalid address\");\r\n        _checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType, now, false);\r\n\r\n        if (individualRestrictions.individualRestriction[_holder].endTime != 0) {\r\n            removeIndividualRestriction(_holder);\r\n        }\r\n        individualRestrictions.individualRestriction[_holder] = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        VolumeRestrictionLib\r\n            .addRestrictionData(\r\n                holderToRestrictionType,\r\n                _holder,\r\n                TypeOfPeriod.MultipleDays,\r\n                individualRestrictions.individualRestriction[_holder].endTime,\r\n                getDataStore()\r\n            );\r\n        emit AddIndividualRestriction(\r\n            _holder,\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to add the new individual daily restriction for all token holder\r\n     * @param _holder Address of the token holder, whom restriction will be implied\r\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function addIndividualDailyRestriction(\r\n        address _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        public\r\n        withPerm(ADMIN)\r\n    {\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        _checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType, now, false);\r\n        if (individualRestrictions.individualDailyRestriction[_holder].endTime != 0) {\r\n            removeIndividualDailyRestriction(_holder);\r\n        }\r\n        individualRestrictions.individualDailyRestriction[_holder] = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        VolumeRestrictionLib\r\n            .addRestrictionData(\r\n                holderToRestrictionType,\r\n                _holder,\r\n                TypeOfPeriod.OneDay,\r\n                individualRestrictions.individualRestriction[_holder].endTime,\r\n                getDataStore()\r\n            );\r\n        emit AddIndividualDailyRestriction(\r\n            _holder,\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to add the new individual daily restriction for multiple token holders\r\n     * @param _holders Array of address of the token holders, whom restriction will be implied\r\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\r\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\r\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\r\n     * @param _restrictionTypes Array of restriction types value whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function addIndividualDailyRestrictionMulti(\r\n        address[] memory _holders,\r\n        uint256[] memory _allowedTokens,\r\n        uint256[] memory _startTimes,\r\n        uint256[] memory _endTimes,\r\n        RestrictionType[] memory _restrictionTypes\r\n    )\r\n        public\r\n    {\r\n        //NB - we duplicate _startTimes below to allow function reuse\r\n        _checkLengthOfArray(_holders, _allowedTokens, _startTimes, _startTimes, _endTimes, _restrictionTypes);\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            addIndividualDailyRestriction(\r\n                _holders[i],\r\n                _allowedTokens[i],\r\n                _startTimes[i],\r\n                _endTimes[i],\r\n                _restrictionTypes[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Use to add the new individual restriction for multiple token holders\r\n     * @param _holders Array of address of the token holders, whom restriction will be implied\r\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\r\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\r\n     * @param _rollingPeriodInDays Array of rolling period in days (Minimum value should be 1 day)\r\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\r\n     * @param _restrictionTypes Array of restriction types value whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function addIndividualRestrictionMulti(\r\n        address[] memory _holders,\r\n        uint256[] memory _allowedTokens,\r\n        uint256[] memory _startTimes,\r\n        uint256[] memory _rollingPeriodInDays,\r\n        uint256[] memory _endTimes,\r\n        RestrictionType[] memory _restrictionTypes\r\n    )\r\n        public\r\n    {\r\n        _checkLengthOfArray(_holders, _allowedTokens, _startTimes, _rollingPeriodInDays, _endTimes, _restrictionTypes);\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            addIndividualRestriction(\r\n                _holders[i],\r\n                _allowedTokens[i],\r\n                _startTimes[i],\r\n                _rollingPeriodInDays[i],\r\n                _endTimes[i],\r\n                _restrictionTypes[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Use to add the new default restriction for all token holder\r\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function addDefaultRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        external\r\n        withPerm(ADMIN)\r\n    {\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        _checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType, now, false);\r\n        globalRestrictions.defaultRestriction = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        emit AddDefaultRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to add the new default daily restriction for all token holder\r\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function addDefaultDailyRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        external\r\n        withPerm(ADMIN)\r\n    {\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        _checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType, now, false);\r\n        globalRestrictions.defaultDailyRestriction = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        emit AddDefaultDailyRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice use to remove the individual restriction for a given address\r\n     * @param _holder Address of the user\r\n     */\r\n    function removeIndividualRestriction(address _holder) public withPerm(ADMIN) {\r\n        _removeIndividualRestriction(_holder);\r\n    }\r\n\r\n    function _removeIndividualRestriction(address _holder) internal {\r\n        require(_holder != address(0));\r\n        require(individualRestrictions.individualRestriction[_holder].endTime != 0);\r\n        individualRestrictions.individualRestriction[_holder] = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\r\n        VolumeRestrictionLib.deleteHolderFromList(holderToRestrictionType, _holder, getDataStore(), TypeOfPeriod.OneDay);\r\n        bucketData.userToBucket[_holder].lastTradedDayTime = 0;\r\n        bucketData.userToBucket[_holder].sumOfLastPeriod = 0;\r\n        bucketData.userToBucket[_holder].daysCovered = 0;\r\n        emit IndividualRestrictionRemoved(_holder);\r\n    }\r\n\r\n    /**\r\n     * @notice use to remove the individual restriction for a given address\r\n     * @param _holders Array of address of the user\r\n     */\r\n    function removeIndividualRestrictionMulti(address[] memory _holders) public withPerm(ADMIN) {\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            _removeIndividualRestriction(_holders[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice use to remove the individual daily restriction for a given address\r\n     * @param _holder Address of the user\r\n     */\r\n    function removeIndividualDailyRestriction(address _holder) public withPerm(ADMIN) {\r\n        _removeIndividualDailyRestriction(_holder);\r\n    }\r\n\r\n    function _removeIndividualDailyRestriction(address _holder) internal {\r\n        require(_holder != address(0));\r\n        require(individualRestrictions.individualDailyRestriction[_holder].endTime != 0);\r\n        individualRestrictions.individualDailyRestriction[_holder] = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\r\n        VolumeRestrictionLib.deleteHolderFromList(holderToRestrictionType, _holder, getDataStore(), TypeOfPeriod.MultipleDays);\r\n        bucketData.userToBucket[_holder].dailyLastTradedDayTime = 0;\r\n        emit IndividualDailyRestrictionRemoved(_holder);\r\n    }\r\n\r\n    /**\r\n     * @notice use to remove the individual daily restriction for a given address\r\n     * @param _holders Array of address of the user\r\n     */\r\n    function removeIndividualDailyRestrictionMulti(address[] memory _holders) public withPerm(ADMIN) {\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            _removeIndividualDailyRestriction(_holders[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Use to remove the default restriction\r\n     */\r\n    function removeDefaultRestriction() public withPerm(ADMIN) {\r\n        require(globalRestrictions.defaultRestriction.endTime != 0);\r\n        globalRestrictions.defaultRestriction = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\r\n        emit DefaultRestrictionRemoved();\r\n    }\r\n\r\n    /**\r\n     * @notice Use to remove the daily default restriction\r\n     */\r\n    function removeDefaultDailyRestriction() external withPerm(ADMIN) {\r\n        require(globalRestrictions.defaultDailyRestriction.endTime != 0);\r\n        globalRestrictions.defaultDailyRestriction = VolumeRestriction(0, 0, 0, 0, RestrictionType(0));\r\n        emit DefaultDailyRestrictionRemoved();\r\n    }\r\n\r\n    /**\r\n     * @notice Use to modify the existing individual restriction for a given token holder\r\n     * @param _holder Address of the token holder, whom restriction will be implied\r\n     * @param _allowedTokens Amount of tokens allowed to be trade for a given address.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function modifyIndividualRestriction(\r\n        address _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        public\r\n        withPerm(ADMIN)\r\n    {\r\n        _isAllowedToModify(individualRestrictions.individualRestriction[_holder].startTime);\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        _checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType, now, false);\r\n        individualRestrictions.individualRestriction[_holder] = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        emit ModifyIndividualRestriction(\r\n            _holder,\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n      );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to modify the existing individual daily restriction for a given token holder\r\n     * @dev Changing of startTime will affect the 24 hrs span. i.e if in earlier restriction days start with\r\n     * morning and end on midnight while after the change day may start with afternoon and end with other day afternoon\r\n     * @param _holder Address of the token holder, whom restriction will be implied\r\n     * @param _allowedTokens Amount of tokens allowed to be trade for a given address.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function modifyIndividualDailyRestriction(\r\n        address _holder,\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        public\r\n        withPerm(ADMIN)\r\n    {\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        uint256 checkTime = (individualRestrictions.individualDailyRestriction[_holder].startTime <= now ? individualRestrictions.individualDailyRestriction[_holder].startTime : now);\r\n        _checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType, checkTime, true);\r\n        individualRestrictions.individualDailyRestriction[_holder] = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        emit ModifyIndividualDailyRestriction(\r\n            _holder,\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to modify the existing individual daily restriction for multiple token holders\r\n     * @param _holders Array of address of the token holders, whom restriction will be implied\r\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\r\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\r\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\r\n     * @param _restrictionTypes Array of restriction types value whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function modifyIndividualDailyRestrictionMulti(\r\n        address[] memory _holders,\r\n        uint256[] memory _allowedTokens,\r\n        uint256[] memory _startTimes,\r\n        uint256[] memory _endTimes,\r\n        RestrictionType[] memory _restrictionTypes\r\n    )\r\n        public\r\n    {\r\n        //NB - we duplicate _startTimes below to allow function reuse\r\n        _checkLengthOfArray(_holders, _allowedTokens, _startTimes, _startTimes, _endTimes, _restrictionTypes);\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            modifyIndividualDailyRestriction(\r\n                _holders[i],\r\n                _allowedTokens[i],\r\n                _startTimes[i],\r\n                _endTimes[i],\r\n                _restrictionTypes[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Use to modify the existing individual restriction for multiple token holders\r\n     * @param _holders Array of address of the token holders, whom restriction will be implied\r\n     * @param _allowedTokens Array of amount of tokens allowed to be trade for a given address.\r\n     * @param _startTimes Array of unix timestamps at which restrictions get into effect\r\n     * @param _rollingPeriodInDays Array of rolling period in days (Minimum value should be 1 day)\r\n     * @param _endTimes Array of unix timestamps at which restriction effects will gets end.\r\n     * @param _restrictionTypes Array of restriction types value whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function modifyIndividualRestrictionMulti(\r\n        address[] memory _holders,\r\n        uint256[] memory _allowedTokens,\r\n        uint256[] memory _startTimes,\r\n        uint256[] memory _rollingPeriodInDays,\r\n        uint256[] memory _endTimes,\r\n        RestrictionType[] memory _restrictionTypes\r\n    )\r\n        public\r\n    {\r\n        _checkLengthOfArray(_holders, _allowedTokens, _startTimes, _rollingPeriodInDays, _endTimes, _restrictionTypes);\r\n        for (uint256 i = 0; i < _holders.length; i++) {\r\n            modifyIndividualRestriction(\r\n                _holders[i],\r\n                _allowedTokens[i],\r\n                _startTimes[i],\r\n                _rollingPeriodInDays[i],\r\n                _endTimes[i],\r\n                _restrictionTypes[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Use to modify the global restriction for all token holder\r\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _rollingPeriodInDays Rolling period in days (Minimum value should be 1 day)\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function modifyDefaultRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodInDays,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        external\r\n        withPerm(ADMIN)\r\n    {\r\n        _isAllowedToModify(globalRestrictions.defaultRestriction.startTime);\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        _checkInputParams(_allowedTokens, startTime, _rollingPeriodInDays, _endTime, _restrictionType, now, false);\r\n        globalRestrictions.defaultRestriction = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        emit ModifyDefaultRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            _rollingPeriodInDays,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to modify the daily default restriction for all token holder\r\n     * @dev Changing of startTime will affect the 24 hrs span. i.e if in earlier restriction days start with\r\n     * morning and end on midnight while after the change day may start with afternoon and end with other day afternoon.\r\n     * @param _allowedTokens Amount of tokens allowed to be traded for all token holder.\r\n     * @param _startTime Unix timestamp at which restriction get into effect\r\n     * @param _endTime Unix timestamp at which restriction effects will gets end.\r\n     * @param _restrictionType Whether it will be `Fixed` (fixed no. of tokens allowed to transact)\r\n     * or `Percentage` (tokens are calculated as per the totalSupply in the fly).\r\n     */\r\n    function modifyDefaultDailyRestriction(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType\r\n    )\r\n        external\r\n        withPerm(ADMIN)\r\n    {\r\n        uint256 startTime = _getValidStartTime(_startTime);\r\n        // If old startTime is already passed then new startTime should be greater than or equal to the\r\n        // old startTime otherwise any past startTime can be allowed in compare to earlier startTime.\r\n        _checkInputParams(_allowedTokens, startTime, 1, _endTime, _restrictionType,\r\n            (globalRestrictions.defaultDailyRestriction.startTime <= now ? globalRestrictions.defaultDailyRestriction.startTime : now),\r\n            true\r\n        );\r\n        globalRestrictions.defaultDailyRestriction = VolumeRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n        emit ModifyDefaultDailyRestriction(\r\n            _allowedTokens,\r\n            startTime,\r\n            1,\r\n            _endTime,\r\n            _restrictionType\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function used to validate the transaction for a given address\r\n    * If it validates then it also update the storage corressponds to the default restriction\r\n    */\r\n    function _restrictionCheck(\r\n        uint256 _amount,\r\n        address _from,\r\n        bool _isDefault,\r\n        VolumeRestriction memory _restriction\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n        Result success,\r\n        uint256 fromTimestamp,\r\n        uint256 sumOfLastPeriod,\r\n        uint256 daysCovered,\r\n        uint256 dailyTime,\r\n        uint256 endTime,\r\n        uint256 allowedAmountToTransact,\r\n        bool allowedDaily\r\n    ) {\r\n        // using the variable to avoid stack too deep error\r\n        VolumeRestriction memory dailyRestriction = _isDefault ? globalRestrictions.defaultDailyRestriction :individualRestrictions.individualDailyRestriction[_from];\r\n        BucketDetails memory _bucketDetails = _isDefault ? bucketData.defaultUserToBucket[_from]: bucketData.userToBucket[_from];\r\n        daysCovered = _restriction.rollingPeriodInDays;\r\n        // This variable works for both allowedDefault or allowedIndividual\r\n        bool allowedDefault = true;\r\n        if (_restriction.endTime >= now && _restriction.startTime <= now) {\r\n            if (_bucketDetails.lastTradedDayTime < _restriction.startTime) {\r\n                // It will execute when the txn is performed first time after the addition of individual restriction\r\n                fromTimestamp = _restriction.startTime;\r\n            } else {\r\n                // Picking up the last timestamp\r\n                fromTimestamp = _bucketDetails.lastTradedDayTime;\r\n            }\r\n\r\n            // Check with the bucket and parse all the new timestamps to calculate the sumOfLastPeriod\r\n            // re-using the local variables to avoid the stack too deep error.\r\n            (sumOfLastPeriod, fromTimestamp, daysCovered) = _bucketCheck(\r\n                _from,\r\n                _isDefault,\r\n                fromTimestamp,\r\n                BokkyPooBahsDateTimeLibrary.diffDays(fromTimestamp, now),\r\n\r\n                daysCovered,\r\n                _bucketDetails\r\n            );\r\n            // validation of the transaction amount\r\n            // reusing the local variable to avoid stack too deep error\r\n            // here variable allowedAmountToTransact is representing the allowedAmount\r\n            (allowedDefault, allowedAmountToTransact) = _checkValidAmountToTransact(_amount, _from, _isDefault, _restriction, sumOfLastPeriod);\r\n            if (!allowedDefault) {\r\n                allowedDefault = false;\r\n            }\r\n        }\r\n\r\n        // reusing the local variable to avoid stack too deep error\r\n        // here variable endTime is representing the allowedDailyAmount\r\n        (allowedDaily, dailyTime, endTime) = _dailyTxCheck(_amount, _from, _isDefault, _bucketDetails.dailyLastTradedDayTime, dailyRestriction);\r\n        success = ((allowedDaily && allowedDefault) == true ? Result.NA : Result.INVALID);\r\n        allowedAmountToTransact = _validAllowedAmount(dailyRestriction, _restriction, allowedAmountToTransact, endTime);\r\n        endTime = dailyRestriction.endTime;\r\n        allowedDaily = _isDefault;\r\n    }\r\n\r\n    function _validAllowedAmount(\r\n        VolumeRestriction memory dailyRestriction,\r\n        VolumeRestriction memory restriction,\r\n        uint256 allowedAmount,\r\n        uint256 allowedDailyAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (now > dailyRestriction.endTime || now < dailyRestriction.startTime)\r\n            return allowedAmount;\r\n        else if (now > restriction.endTime || now < restriction.startTime)\r\n            return allowedDailyAmount;\r\n        else\r\n            return Math.min(allowedDailyAmount, allowedAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice The function is used to check specific edge case where the user restriction type change from\r\n     * default to individual or vice versa. It will return true when last transaction traded by the user\r\n     * and the current txn timestamp lies in the same day.\r\n     * NB - Instead of comparing the current day transaction amount, we are comparing the total amount traded\r\n     * on the lastTradedDayTime that makes the restriction strict. The reason is not availability of amount\r\n     * that transacted on the current day (because of bucket desgin).\r\n     */\r\n    function _isValidAmountAfterRestrictionChanges(\r\n        bool _isDefault,\r\n        address _from,\r\n        uint256 _amount,\r\n        uint256 _sumOfLastPeriod,\r\n        uint256 _allowedAmount\r\n    )\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        // Always use the alternate bucket details as per the current transaction restriction\r\n        BucketDetails storage bucketDetails = _isDefault ? bucketData.userToBucket[_from] : bucketData.defaultUserToBucket[_from];\r\n        uint256 amountTradedLastDay = _isDefault ? bucketData.bucket[_from][bucketDetails.lastTradedDayTime]: bucketData.defaultBucket[_from][bucketDetails.lastTradedDayTime];\r\n        return VolumeRestrictionLib.isValidAmountAfterRestrictionChanges(\r\n            amountTradedLastDay,\r\n            _amount,\r\n            _sumOfLastPeriod,\r\n            _allowedAmount,\r\n            bucketDetails.lastTradedTimestamp\r\n        );\r\n    }\r\n\r\n    function _dailyTxCheck(\r\n        uint256 _amount,\r\n        address _from,\r\n        bool _isDefault,\r\n        uint256 _dailyLastTradedDayTime,\r\n        VolumeRestriction memory _restriction\r\n    )\r\n        internal\r\n        view\r\n        returns(bool, uint256, uint256)\r\n    {\r\n        // Checking whether the daily restriction is added or not if yes then calculate\r\n        // the total amount get traded on a particular day (~ _fromTime)\r\n        if ( now <= _restriction.endTime && now >= _restriction.startTime) {\r\n            uint256 txSumOfDay = 0;\r\n            if (_dailyLastTradedDayTime == 0 || _dailyLastTradedDayTime < _restriction.startTime)\r\n                // This if condition will be executed when the individual daily restriction executed first time\r\n                _dailyLastTradedDayTime = _restriction.startTime.add(BokkyPooBahsDateTimeLibrary.diffDays(_restriction.startTime, now).mul(1 days));\r\n            else if (now.sub(_dailyLastTradedDayTime) >= 1 days)\r\n                _dailyLastTradedDayTime = _dailyLastTradedDayTime.add(BokkyPooBahsDateTimeLibrary.diffDays(_dailyLastTradedDayTime, now).mul(1 days));\r\n            // Assgining total sum traded on dailyLastTradedDayTime timestamp\r\n            if (_isDefault)\r\n                txSumOfDay = bucketData.defaultBucket[_from][_dailyLastTradedDayTime];\r\n            else\r\n                txSumOfDay = bucketData.bucket[_from][_dailyLastTradedDayTime];\r\n            (bool isAllowed, uint256 allowedAmount) = _checkValidAmountToTransact(_amount, _from, _isDefault, _restriction, txSumOfDay);\r\n            return (isAllowed, _dailyLastTradedDayTime, allowedAmount);\r\n        }\r\n        return (true, _dailyLastTradedDayTime, _amount);\r\n    }\r\n\r\n    /// Internal function for the bucket check\r\n    function _bucketCheck(\r\n        address _from,\r\n        bool isDefault,\r\n        uint256 _fromTime,\r\n        uint256 _diffDays,\r\n        uint256 _rollingPeriodInDays,\r\n        BucketDetails memory _bucketDetails\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        uint256 counter = _bucketDetails.daysCovered;\r\n        uint256 sumOfLastPeriod = _bucketDetails.sumOfLastPeriod;\r\n        uint256 i = 0;\r\n        if (_diffDays >= _rollingPeriodInDays) {\r\n            // If the difference of days is greater than the rollingPeriod then sumOfLastPeriod will always be zero\r\n            sumOfLastPeriod = 0;\r\n            counter = counter.add(_diffDays);\r\n        } else {\r\n            for (i = 0; i < _diffDays; i++) {\r\n                counter++;\r\n                // This condition is to check whether the first rolling period is covered or not\r\n                // if not then it continues and adding 0 value into sumOfLastPeriod without subtracting\r\n                // the earlier value at that index\r\n                if (counter >= _rollingPeriodInDays) {\r\n                    // Subtracting the former value(Sum of all the txn amount of that day) from the sumOfLastPeriod\r\n                    // The below line subtracts (the traded volume on days no longer covered by rolling period) from sumOfLastPeriod.\r\n                    // Every loop execution subtracts one day's trade volume.\r\n                    // Loop starts from the first day covered in sumOfLastPeriod upto the day that is covered by rolling period.\r\n                    uint256 temp = _bucketDetails.daysCovered.sub(counter.sub(_rollingPeriodInDays));\r\n                    temp = _bucketDetails.lastTradedDayTime.sub(temp.mul(1 days));\r\n                    if (isDefault)\r\n                        sumOfLastPeriod = sumOfLastPeriod.sub(bucketData.defaultBucket[_from][temp]);\r\n                    else\r\n                        sumOfLastPeriod = sumOfLastPeriod.sub(bucketData.bucket[_from][temp]);\r\n                }\r\n                // Adding the last amount that is transacted on the `_fromTime` not actually doing it but left written to understand\r\n                // the alogrithm\r\n                //_bucketDetails.sumOfLastPeriod = _bucketDetails.sumOfLastPeriod.add(uint256(0));\r\n            }\r\n        }\r\n        // calculating the timestamp that will used as an index of the next bucket\r\n        // i.e buckets period will be look like this T1 to T2-1, T2 to T3-1 ....\r\n        // where T1,T2,T3 are timestamps having 24 hrs difference\r\n        _fromTime = _fromTime.add(_diffDays.mul(1 days));\r\n        return (sumOfLastPeriod, _fromTime, counter);\r\n    }\r\n\r\n    function _checkValidAmountToTransact(\r\n        uint256 _amountToTransact,\r\n        address _from,\r\n        bool _isDefault,\r\n        VolumeRestriction memory _restriction,\r\n        uint256 _sumOfLastPeriod\r\n    )\r\n        internal\r\n        view\r\n        returns (bool, uint256)\r\n    {\r\n        uint256 allowedAmount = _allowedAmountToTransact(_sumOfLastPeriod, _restriction);\r\n        // Validation on the amount to transact\r\n        bool allowed = allowedAmount >= _amountToTransact;\r\n        return ((allowed && _isValidAmountAfterRestrictionChanges(_isDefault, _from, _amountToTransact, _sumOfLastPeriod, allowedAmount)), allowedAmount);\r\n    }\r\n\r\n    function _allowedAmountToTransact(\r\n        uint256 _sumOfLastPeriod,\r\n        VolumeRestriction memory _restriction\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 _allowedAmount = 0;\r\n        if (_restriction.typeOfRestriction == RestrictionType.Percentage) {\r\n            _allowedAmount = (_restriction.allowedTokens.mul(securityToken.totalSupply())) / uint256(10) ** 18;\r\n        } else {\r\n            _allowedAmount = _restriction.allowedTokens;\r\n        }\r\n        return _allowedAmount.sub(_sumOfLastPeriod);\r\n    }\r\n\r\n    function _updateStorage(\r\n        address _from,\r\n        uint256 _amount,\r\n        uint256 _lastTradedDayTime,\r\n        uint256 _sumOfLastPeriod,\r\n        uint256 _daysCovered,\r\n        uint256 _dailyLastTradedDayTime,\r\n        uint256 _endTime,\r\n        bool isDefault\r\n    )\r\n        internal\r\n    {\r\n\r\n        if (isDefault){\r\n            BucketDetails storage defaultUserToBucketDetails = bucketData.defaultUserToBucket[_from];\r\n            _updateStorageActual(_from, _amount, _lastTradedDayTime, _sumOfLastPeriod, _daysCovered, _dailyLastTradedDayTime, _endTime, true,  defaultUserToBucketDetails);\r\n        }\r\n        else {\r\n            BucketDetails storage userToBucketDetails = bucketData.userToBucket[_from];\r\n            _updateStorageActual(_from, _amount, _lastTradedDayTime, _sumOfLastPeriod, _daysCovered, _dailyLastTradedDayTime, _endTime, false, userToBucketDetails);\r\n        }\r\n    }\r\n\r\n    function _updateStorageActual(\r\n        address _from,\r\n        uint256 _amount,\r\n        uint256 _lastTradedDayTime,\r\n        uint256 _sumOfLastPeriod,\r\n        uint256 _daysCovered,\r\n        uint256 _dailyLastTradedDayTime,\r\n        uint256 _endTime,\r\n        bool isDefault,\r\n        BucketDetails storage details\r\n    )\r\n        internal\r\n    {\r\n        // Cheap storage technique\r\n        if (details.lastTradedDayTime != _lastTradedDayTime) {\r\n            // Assigning the latest transaction timestamp of the day\r\n            details.lastTradedDayTime = _lastTradedDayTime;\r\n        }\r\n        if (details.dailyLastTradedDayTime != _dailyLastTradedDayTime) {\r\n            // Assigning the latest transaction timestamp of the day\r\n            details.dailyLastTradedDayTime = _dailyLastTradedDayTime;\r\n        }\r\n        if (details.daysCovered != _daysCovered) {\r\n            details.daysCovered = _daysCovered;\r\n        }\r\n        // Assigning the latest transaction timestamp\r\n        details.lastTradedTimestamp = now;\r\n\r\n        if (_amount != 0) {\r\n            if (_lastTradedDayTime !=0) {\r\n                details.sumOfLastPeriod = _sumOfLastPeriod.add(_amount);\r\n                // Increasing the total amount of the day by `_amount`\r\n                if (isDefault)\r\n                    bucketData.defaultBucket[_from][_lastTradedDayTime] = bucketData.defaultBucket[_from][_lastTradedDayTime].add(_amount);\r\n                else\r\n                    bucketData.bucket[_from][_lastTradedDayTime] = bucketData.bucket[_from][_lastTradedDayTime].add(_amount);\r\n            }\r\n            if ((_dailyLastTradedDayTime != _lastTradedDayTime) && _dailyLastTradedDayTime != 0 && now <= _endTime) {\r\n                // Increasing the total amount of the day by `_amount`\r\n                if (isDefault)\r\n                    bucketData.defaultBucket[_from][_dailyLastTradedDayTime] = bucketData.defaultBucket[_from][_dailyLastTradedDayTime].add(_amount);\r\n                else\r\n                    bucketData.bucket[_from][_dailyLastTradedDayTime] = bucketData.bucket[_from][_dailyLastTradedDayTime].add(_amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _checkInputParams(\r\n        uint256 _allowedTokens,\r\n        uint256 _startTime,\r\n        uint256 _rollingPeriodDays,\r\n        uint256 _endTime,\r\n        RestrictionType _restrictionType,\r\n        uint256 _earliestStartTime,\r\n        bool isModifyDaily\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (isModifyDaily)\r\n            require(_startTime >= _earliestStartTime, \"Invalid startTime\");\r\n        else\r\n            require(_startTime > _earliestStartTime, \"Invalid startTime\");\r\n        require(_allowedTokens > 0);\r\n        if (_restrictionType != RestrictionType.Fixed) {\r\n            require(_allowedTokens <= 100 * 10 ** 16, \"Invalid value\");\r\n        }\r\n        // Maximum limit for the rollingPeriod is 365 days\r\n        require(_rollingPeriodDays >= 1 && _rollingPeriodDays <= 365, \"Invalid rollingperiod\");\r\n        require(\r\n            BokkyPooBahsDateTimeLibrary.diffDays(_startTime, _endTime) >= _rollingPeriodDays,\r\n            \"Invalid times\"\r\n        );\r\n    }\r\n\r\n    function _isAllowedToModify(uint256 _startTime) internal view {\r\n        require(_startTime > now);\r\n    }\r\n\r\n    function _getValidStartTime(uint256 _startTime) internal view returns(uint256) {\r\n        if (_startTime == 0)\r\n            _startTime = now + 1;\r\n        return _startTime;\r\n    }\r\n\r\n    /**\r\n     * @notice return the amount of tokens for a given user as per the partition\r\n     * @param _partition Identifier\r\n     * @param _tokenHolder Whom token amount need to query\r\n     * @param _additionalBalance It is the `_value` that transfer during transfer/transferFrom function call\r\n     */\r\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 _additionalBalance) external view returns(uint256) {\r\n        uint256 allowedAmountToTransact;\r\n        uint256 fromTimestamp;\r\n        uint256 dailyTime;\r\n        uint256 currentBalance = (msg.sender == address(securityToken)) ? (securityToken.balanceOf(_tokenHolder)).add(_additionalBalance) : securityToken.balanceOf(_tokenHolder);\r\n        if (paused)\r\n            return (_partition == UNLOCKED ? currentBalance: 0);\r\n\r\n        (,fromTimestamp,,,dailyTime,,allowedAmountToTransact,) = _verifyTransfer(_tokenHolder, 0);\r\n        if (_partition == LOCKED) {\r\n            if (allowedAmountToTransact == 0 && fromTimestamp == 0 && dailyTime == 0)\r\n                return 0;\r\n            else if (allowedAmountToTransact == 0)\r\n                return currentBalance;\r\n            else\r\n                return (currentBalance.sub(allowedAmountToTransact));\r\n        }\r\n        else if (_partition == UNLOCKED) {\r\n            if (allowedAmountToTransact == 0 && fromTimestamp == 0 && dailyTime == 0)\r\n                return currentBalance;\r\n            else if (allowedAmountToTransact == 0)\r\n                return 0;\r\n            else\r\n                return allowedAmountToTransact;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Use to get the bucket details for a given address\r\n     * @param _user Address of the token holder for whom the bucket details has queried\r\n     * @return uint256 lastTradedDayTime\r\n     * @return uint256 sumOfLastPeriod\r\n     * @return uint256 days covered\r\n     * @return uint256 24h lastTradedDayTime\r\n     * @return uint256 Timestamp at which last transaction get executed\r\n     */\r\n    function getIndividualBucketDetailsToUser(address _user) public view returns(uint256, uint256, uint256, uint256, uint256) {\r\n        return _getBucketDetails(bucketData.userToBucket[_user]);\r\n    }\r\n\r\n    /**\r\n     * @notice Use to get the bucket details for a given address\r\n     * @param _user Address of the token holder for whom the bucket details has queried\r\n     * @return uint256 lastTradedDayTime\r\n     * @return uint256 sumOfLastPeriod\r\n     * @return uint256 days covered\r\n     * @return uint256 24h lastTradedDayTime\r\n     * @return uint256 Timestamp at which last transaction get executed\r\n     */\r\n    function getDefaultBucketDetailsToUser(address _user) public view returns(uint256, uint256, uint256, uint256, uint256) {\r\n        return _getBucketDetails(bucketData.defaultUserToBucket[_user]);\r\n    }\r\n\r\n    function _getBucketDetails(BucketDetails storage _bucket) internal view returns(\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) {\r\n        return(\r\n            _bucket.lastTradedDayTime,\r\n            _bucket.sumOfLastPeriod,\r\n            _bucket.daysCovered,\r\n            _bucket.dailyLastTradedDayTime,\r\n            _bucket.lastTradedTimestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Use to get the volume of token that being traded at a particular day (`_at` + 24 hours) for a given user\r\n     * @param _user Address of the token holder\r\n     * @param _at Timestamp\r\n     */\r\n    function getTotalTradedByUser(address _user, uint256 _at) external view returns(uint256) {\r\n        return (bucketData.bucket[_user][_at].add(bucketData.defaultBucket[_user][_at]));\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() public pure returns(bytes4) {\r\n        return bytes4(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Use to return the list of exempted addresses\r\n     */\r\n    function getExemptAddress() external view returns(address[] memory) {\r\n        return exemptions.exemptAddresses;\r\n    }\r\n\r\n    function getIndividualRestriction(address _investor) external view returns(uint256, uint256, uint256, uint256, RestrictionType) {\r\n        return _volumeRestrictionSplay(individualRestrictions.individualRestriction[_investor]);\r\n    }\r\n\r\n    function getIndividualDailyRestriction(address _investor) external view returns(uint256, uint256, uint256, uint256, RestrictionType) {\r\n        return _volumeRestrictionSplay(individualRestrictions.individualDailyRestriction[_investor]);\r\n    }\r\n\r\n    function getDefaultRestriction() external view returns(uint256, uint256, uint256, uint256, RestrictionType) {\r\n        return _volumeRestrictionSplay(globalRestrictions.defaultRestriction);\r\n    }\r\n\r\n    function getDefaultDailyRestriction() external view returns(uint256, uint256, uint256, uint256, RestrictionType) {\r\n        return _volumeRestrictionSplay(globalRestrictions.defaultDailyRestriction);\r\n    }\r\n\r\n    function _volumeRestrictionSplay(VolumeRestriction memory _volumeRestriction) internal pure returns(uint256, uint256, uint256, uint256, RestrictionType) {\r\n        return (\r\n            _volumeRestriction.allowedTokens,\r\n            _volumeRestriction.startTime,\r\n            _volumeRestriction.rollingPeriodInDays,\r\n            _volumeRestriction.endTime,\r\n            _volumeRestriction.typeOfRestriction\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Provide the restriction details of all the restricted addresses\r\n     * @return address List of the restricted addresses\r\n     * @return uint256 List of the tokens allowed to the restricted addresses corresponds to restricted address\r\n     * @return uint256 List of the start time of the restriction corresponds to restricted address\r\n     * @return uint256 List of the rolling period in days for a restriction corresponds to restricted address.\r\n     * @return uint256 List of the end time of the restriction corresponds to restricted address.\r\n     * @return uint8 List of the type of restriction to validate the value of the `allowedTokens`\r\n     * of the restriction corresponds to restricted address\r\n     */\r\n    function getRestrictionData() external view returns(\r\n        address[] memory allAddresses,\r\n        uint256[] memory allowedTokens,\r\n        uint256[] memory startTime,\r\n        uint256[] memory rollingPeriodInDays,\r\n        uint256[] memory endTime,\r\n        RestrictionType[] memory typeOfRestriction\r\n    ) {\r\n        return VolumeRestrictionLib.getRestrictionData(holderToRestrictionType, individualRestrictions, getDataStore());\r\n    }\r\n\r\n    function _checkLengthOfArray(\r\n        address[] memory _holders,\r\n        uint256[] memory _allowedTokens,\r\n        uint256[] memory _startTimes,\r\n        uint256[] memory _rollingPeriodInDays,\r\n        uint256[] memory _endTimes,\r\n        RestrictionType[] memory _restrictionTypes\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(\r\n            _holders.length == _allowedTokens.length &&\r\n            _allowedTokens.length == _startTimes.length &&\r\n            _startTimes.length == _rollingPeriodInDays.length &&\r\n            _rollingPeriodInDays.length == _endTimes.length &&\r\n            _endTimes.length == _restrictionTypes.length,\r\n            \"Length mismatch\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the permissions flag that are associated with Percentage transfer Manager\r\n     */\r\n    function getPermissions() public view returns(bytes32[] memory allPermissions) {\r\n        allPermissions = new bytes32[](1);\r\n        allPermissions[0] = ADMIN;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"removeDefaultRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"modifyDefaultRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_partition\",\"type\":\"bytes32\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_additionalBalance\",\"type\":\"uint256\"}],\"name\":\"getTokensByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getIndividualDailyRestriction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256[]\"},{\"name\":\"_endTimes\",\"type\":\"uint256[]\"},{\"name\":\"_restrictionTypes\",\"type\":\"uint8[]\"}],\"name\":\"modifyIndividualRestrictionMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"executeTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_endTimes\",\"type\":\"uint256[]\"},{\"name\":\"_restrictionTypes\",\"type\":\"uint8[]\"}],\"name\":\"addIndividualDailyRestrictionMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getIndividualRestriction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"addDefaultDailyRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"modifyIndividualRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"}],\"name\":\"removeIndividualRestrictionMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"}],\"name\":\"removeIndividualDailyRestrictionMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNLOCKED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256[]\"},{\"name\":\"_endTimes\",\"type\":\"uint256[]\"},{\"name\":\"_restrictionTypes\",\"type\":\"uint8[]\"}],\"name\":\"addIndividualRestrictionMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"addDefaultRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"removeIndividualRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultRestriction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getIndividualBucketDetailsToUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeDefaultDailyRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"modifyDefaultDailyRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCKED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"modifyIndividualDailyRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_at\",\"type\":\"uint256\"}],\"name\":\"getTotalTradedByUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"addIndividualDailyRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_restrictionType\",\"type\":\"uint8\"}],\"name\":\"addIndividualRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"},{\"name\":\"_allowedTokens\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_endTimes\",\"type\":\"uint256[]\"},{\"name\":\"_restrictionTypes\",\"type\":\"uint8[]\"}],\"name\":\"modifyIndividualDailyRestrictionMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRestrictionData\",\"outputs\":[{\"name\":\"allAddresses\",\"type\":\"address[]\"},{\"name\":\"allowedTokens\",\"type\":\"uint256[]\"},{\"name\":\"startTime\",\"type\":\"uint256[]\"},{\"name\":\"rollingPeriodInDays\",\"type\":\"uint256[]\"},{\"name\":\"endTime\",\"type\":\"uint256[]\"},{\"name\":\"typeOfRestriction\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDefaultBucketDetailsToUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"allPermissions\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultDailyRestriction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"removeIndividualDailyRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"verifyTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_exempted\",\"type\":\"bool\"}],\"name\":\"changeExemptWalletList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExemptAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_exempted\",\"type\":\"bool\"}],\"name\":\"ChangedExemptWalletList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"AddIndividualRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"AddIndividualDailyRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"ModifyIndividualRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"ModifyIndividualDailyRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"AddDefaultRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"AddDefaultDailyRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"ModifyDefaultRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rollingPeriodInDays\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_typeOfRestriction\",\"type\":\"uint8\"}],\"name\":\"ModifyDefaultDailyRestriction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"IndividualRestrictionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"IndividualDailyRestrictionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultRestrictionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultDailyRestrictionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"VolumeRestrictionTM","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"VolumeRestrictionLib:6efff28f0f45c278ed5585913c68f23e9fb2890a","SwarmSource":"bzzr://148c664cb033a8c1ec31febd23a88da1c604583da38a4ca010ab16d51ede1549"}]}