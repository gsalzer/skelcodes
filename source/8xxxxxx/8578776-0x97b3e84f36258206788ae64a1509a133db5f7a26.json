{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ncontract DenshiJitsuin {\r\n    /// \"60f91998: sign(uint256,bytes32,address,bytes)\r\n    bytes4 SIGN_METHOD_HASH = 0x60f91998;\r\n    \r\n    struct Signature {\r\n        bool isSigned;\r\n        bytes32 hash;\r\n    }\r\n\r\n    // mapping(documentId => mapping(signer => Signature))\r\n    mapping(uint256 => mapping(address => Signature)) private _signatures; \r\n    // mapping(documentId => mapping(index => signer)\r\n    mapping(uint256 => mapping(uint256 => address)) private _documentSigners;\r\n    // mapping(documentId => signerCount)\r\n    mapping(uint256 => uint256) private _documentSignerCount;\r\n\r\n    constructor() public {}\r\n\r\n    /// @dev Sign on a specified document.\r\n    /// @dev _signer should be matched against the msg.sender or an address recovered from _sig\r\n    /// @param _documentId Document's ID\r\n    /// @param _documentHash SHA256 hash of the document's content\r\n    /// @param _signer Account address who is signing to the document\r\n    /// @param _sig ECDSA signature (for meta transaction)\r\n    /// @return bool true if the method succeeded\r\n    function sign(uint256 _documentId, bytes32 _documentHash, address _signer, bytes calldata _sig) external returns (bool) {\r\n        if(_signatures[_documentId][_signer].isSigned) {\r\n            return true;\r\n        } else {\r\n            address signer = msg.sender == _signer ? msg.sender : recover(keccak256(abi.encodePacked(SIGN_METHOD_HASH, _documentId, _documentHash)), _sig);\r\n            require(signer == _signer);\r\n            _signatures[_documentId][_signer] = Signature(true, _documentHash);\r\n            _documentSigners[_documentId][_documentSignerCount[_documentId]] = _signer;\r\n            _documentSignerCount[_documentId]++;\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    /// @dev Get status if a specified signer has signed on a specified document or not.\r\n    /// @dev It also returns document hash sent by the signer at the timing of sigining.\r\n    /// @param _documentId Document's ID\r\n    /// @param _signer Account address to inspect its signature on the document\r\n    /// @return bool true if the method succeeded\r\n    function getSignature(uint256 _documentId, address _signer) external view returns (bool, bytes32) {\r\n        Signature memory _signature = _signatures[_documentId][_signer];\r\n        return (_signature.isSigned, _signature.hash);\r\n    }\r\n    \r\n    /// @dev Get a signer address at the specified document and index\r\n    /// @param _documentId Document's ID\r\n    /// @param _index Index number of signer on the document\r\n    /// @return address Signer address\r\n    function getSigner(uint256 _documentId, uint256 _index) external view returns (address) {\r\n        return _documentSigners[_documentId][_index];\r\n    }\r\n    \r\n    /// @dev Get the number of signers on the specified document\r\n    /// @param _documentId Document's ID\r\n    /// @return uint256 Number of signers\r\n    function getSignerCount(uint256 _documentId) external view returns (uint256) {\r\n        return _documentSignerCount[_documentId];\r\n    }\r\n\r\n    function recover(bytes32 _hash, bytes memory _sig) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        \r\n        //Check the signature length\r\n        if (_sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(_hash, v, r, s);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_documentId\",\"type\":\"uint256\"},{\"name\":\"_documentHash\",\"type\":\"bytes32\"},{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"sign\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_documentId\",\"type\":\"uint256\"}],\"name\":\"getSignerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_documentId\",\"type\":\"uint256\"},{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"getSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_documentId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DenshiJitsuin","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://4e9cf96c3c6c9ce5b6236c3e0e47ae853333e8d81c16f0cf7f7e6b8ff18d0ea6"}]}