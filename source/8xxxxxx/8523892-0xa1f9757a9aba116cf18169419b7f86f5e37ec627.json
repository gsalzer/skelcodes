{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20Token.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ncontract ERC20Token {\\n  function totalSupply() public constant returns (uint);\\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\\n  function transfer(address to, uint256 tokens) public returns (bool success);\\n  function approve(address spender, uint256 tokens) public returns (bool success);\\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\\n\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\\n\"},\"FLXCToken.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\u0027./StandardToken.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\n\\ncontract FLXCToken is StandardToken, Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    string public constant symbol = \\\"FLXC\\\";\\n    string public constant name = \\\"FLXC Token\\\";\\n    uint8 public constant decimals = 18;\\n\\n    // Total Number of tokens ever goint to be minted. 10 BILLION FLXC tokens.\\n    uint256 private constant minting_capped_amount = 10000000000 * 10 ** uint256(decimals);\\n\\n    // 10% of inital supply.\\n    uint256  constant vesting_amount = 100000000 * 10 ** uint256(decimals);\\n\\n    uint256 private initialSupply = minting_capped_amount;\\n\\n    address public vestingAddress;\\n\\n  \\n    /** @dev to cap the total number of tokens that will ever be newly minted\\n      * owner has to stop the minting by setting this variable to true.\\n      */\\n    bool public mintingFinished = false;\\n\\n    /** @dev Miniting Essentials functions as per OpenZeppelin standards\\n      */\\n    modifier canMint() {\\n      require(!mintingFinished);\\n      _;\\n    }\\n    modifier hasMintPermission() {\\n      require(msg.sender == owner);\\n      _;\\n    }\\n\\n    /** @dev to prevent malicious use of FLXC tokens and to comply with Anti\\n      * Money laundering regulations FLXC tokens can be frozen.\\n      */\\n    mapping (address =\\u003e bool) public frozenAccount;\\n\\n    /** @dev This generates a public event on the blockchain that will notify clients\\n      */\\n    event FrozenFunds(address target, bool frozen);\\n    event Mint(address indexed to, uint256 amount);\\n    event MintFinished();\\n    event Burn(address indexed burner, uint256 value);\\n\\n    constructor() public {\\n\\n        _totalSupply = minting_capped_amount;\\n        owner = msg.sender;\\n        balances[owner] = _totalSupply;\\n        emit Transfer(address(0), owner, balances[owner]);\\n    }\\n\\n    /* Do not accept ETH */\\n    function() public payable {\\n        revert();\\n    }\\n\\n\\n    function setVestingAddress(address _vestingAddress) external onlyOwner {\\n        vestingAddress = _vestingAddress;\\n        assert(approve(vestingAddress, vesting_amount));\\n    }\\n   \\n    function getVestingAmount() public view returns(uint256) {\\n        return vesting_amount;\\n    }\\n\\n\\n    /** @dev Transfer possible only after ICO ends and Frozen accounts\\n      * wont be able to transfer funds to other any other account and viz.\\n      * @notice added safeTransfer functionality\\n      */\\n    function transfer(address _to, uint256 _value) public returns(bool) {\\n        require(!frozenAccount[msg.sender]);\\n        require(!frozenAccount[_to]);\\n\\n        require(super.transfer(_to, _value));\\n        return true;\\n    }\\n\\n    /** @dev Only owner\\u0027s tokens can be transferred before Crowdsale ends.\\n      * beacuse the inital supply of FLXC is allocated to owners acc and later\\n      * distributed to various subcontracts.\\n      * @notice added safeTransferFrom functionality\\n      */\\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\\n        require(!frozenAccount[_from]);\\n        require(!frozenAccount[_to]);\\n        require(!frozenAccount[msg.sender]);\\n\\n\\n        require(super.transferFrom(_from, _to, _value));\\n        return true;\\n    }\\n\\n    /** @notice added safeApprove functionality\\n      */\\n    function approve(address spender, uint256 tokens) public returns (bool){\\n        require(super.approve(spender, tokens));\\n        return true;\\n    }\\n\\n   /** @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\n     * @param target Address to be frozen\\n     * @param freeze either to freeze it or not\\n     */\\n    function freezeAccount(address target, bool freeze) public onlyOwner {\\n        require(frozenAccount[target] != freeze);\\n\\n        frozenAccount[target] = freeze;\\n        emit FrozenFunds(target, freeze);\\n    }\\n\\n\\n    /** @dev Function to mint tokens\\n      * @param _to The address that will receive the minted tokens.\\n      * @param _amount The amount of tokens to mint.\\n      * @return A boolean that indicates if the operation was successful.\\n      */\\n    function mint(address _to, uint256 _amount) public hasMintPermission canMint returns (bool) {\\n      require(_totalSupply.add(_amount) \\u003c= minting_capped_amount);\\n\\n      _totalSupply = _totalSupply.add(_amount);\\n      balances[_to] = balances[_to].add(_amount);\\n      emit Mint(_to, _amount);\\n      emit Transfer(address(0), _to, _amount);\\n      return true;\\n    }\\n\\n   /** @dev Function to stop minting new tokens.\\n     * @return True if the operation was successful.\\n     */\\n    function finishMinting() public onlyOwner canMint returns (bool) {\\n      mintingFinished = true;\\n      emit MintFinished();\\n      return true;\\n    }\\n\\n    /** @dev Burns a specific amount of tokens.\\n      * @param _value The amount of token to be burned.\\n      */\\n     function burn(uint256 _value) public {\\n       _burn(msg.sender, _value);\\n     }\\n\\n     function _burn(address _who, uint256 _value) internal {\\n       require(_value \\u003c= balances[_who]);\\n       // no need to require value \\u003c= totalSupply, since that would imply the\\n       // sender\\u0027s balance is greater than the totalSupply, which *should* be an assertion failure\\n\\n       balances[_who] = balances[_who].sub(_value);\\n       _totalSupply = _totalSupply.sub(_value);\\n       emit Burn(_who, _value);\\n       emit Transfer(_who, address(0), _value);\\n     }\\n}\\n\\n\\n\\n\"},\"FLXCTokenVestingFactory.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\u0027./StandardTokenVesting.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\n\\n\\n/** @notice Factory is a software design pattern for creating instances of a class.\\n * Using this pattern simplifies creating new vesting contracts and saves\\n * transaction costs (\\\"gas\\\"). Instead of deploying a new TokenVesting contract\\n * for each team member, we deploy a single instance of TokenVestingFactory\\n * that ensures the creation of new token vesting contracts.\\n */\\n\\ncontract FLXCTokenVestingFactory is Ownable {\\n\\n    mapping(address =\\u003e StandardTokenVesting) vestingContractAddresses;\\n\\n    // The token being sold\\n    FLXCToken public token;\\n\\n    event CreatedStandardVestingContract(StandardTokenVesting vesting);\\n\\n    constructor(address _token) public {\\n        require(_token != address(0));\\n        owner = msg.sender;\\n        token = FLXCToken(_token);\\n    }\\n\\n   /** @dev Deploy FLXCTokenVestingFactory, and use it to create vesting contracts\\n     * for founders, advisors and developers. after creation transfer FLXC tokens\\n     * to those addresses and vesting vaults will be initialised.\\n     */\\n    // function create(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable, uint256 noOfTokens) onlyOwner public returns(StandardTokenVesting) {\\n    function create(address _beneficiary, uint256 _cliff, uint256 _duration, bool _revocable, uint256 noOfTokens) public onlyOwner  returns(StandardTokenVesting) {\\n        StandardTokenVesting vesting = new StandardTokenVesting(_beneficiary, now , _cliff , _duration, _revocable);\\n\\n        vesting.transferOwnership(msg.sender);\\n        vestingContractAddresses[_beneficiary] = vesting;\\n        emit CreatedStandardVestingContract(vesting);\\n        assert(token.transferFrom(owner, vesting, noOfTokens));\\n\\n        return vesting;\\n    }\\n\\n    function getVestingContractAddress(address _beneficiary) public view returns(address) {\\n        require(_beneficiary != address(0));\\n        require(vestingContractAddresses[_beneficiary] != address(0));\\n\\n        return vestingContractAddresses[_beneficiary];\\n    }\\n\\n    function releasableAmount(address _beneficiary) public view returns(uint256) {\\n        require(getVestingContractAddress( _beneficiary) != address(0));\\n        return vestingContractAddresses[_beneficiary].releasableAmount(token);\\n    }\\n\\n    function vestedAmount(address _beneficiary) public view returns(uint256) {\\n        require(getVestingContractAddress(_beneficiary) != address(0));\\n        return vestingContractAddresses[_beneficiary].vestedAmount(token);\\n    }\\n\\n    function release(address _beneficiary) public returns(bool) {\\n        require(getVestingContractAddress(_beneficiary) != address(0));\\n        return vestingContractAddresses[_beneficiary].release(token);\\n    }\\n\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/* Pausable contract */\\ncontract Pausable is Ownable {\\n\\n    event Pause();\\n    event Unpause();\\n\\n    bool public paused = false;\\n\\n    /** @dev Modifier to make a function callable only when the contract is not paused.\\n      */\\n    modifier whenNotPaused() {\\n        require(!paused);\\n        _;\\n    }\\n\\n    /** @dev Modifier to make a function callable only when the contract is paused.\\n      */\\n    modifier whenPaused() {\\n        require(paused);\\n        _;\\n    }\\n\\n    /** @dev called by the owner to pause, triggers stopped state\\n      */\\n    function pause() onlyOwner whenNotPaused public {\\n        paused = true;\\n        emit Pause();\\n    }\\n\\n    /** @dev called by the owner to unpause, returns to normal state\\n      */\\n    function unpause() onlyOwner whenPaused public {\\n        paused = false;\\n        emit Unpause();\\n    }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"StandardToken.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\u0027./ERC20Token.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract StandardToken is ERC20Token {\\n\\n  using SafeMath for uint256;\\n\\n  // Global variable to store total number of tokens passed from FLXCToken.sol\\n  uint256 _totalSupply;\\n\\n  mapping(address =\\u003e uint256) balances;\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) allowed;\\n\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address tokenOwner) public view returns (uint256){\\n        return balances[tokenOwner];\\n  }\\n\\n\\n\\n  function transfer(address to, uint256 tokens) public returns (bool){\\n      require(to != address(0));\\n      require(tokens \\u003e 0 \\u0026\\u0026 tokens \\u003c= balances[msg.sender]);\\n\\n      balances[msg.sender] = balances[msg.sender].sub(tokens);\\n      balances[to] = balances[to].add(tokens);\\n      emit Transfer(msg.sender, to, tokens);\\n      return true;\\n  }\\n\\n  // Transfer tokens from one address to another\\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success){\\n      require(to != address(0));\\n      require(tokens \\u003e 0 \\u0026\\u0026 tokens \\u003c= balances[from]);\\n      require(tokens \\u003c= allowed[from][msg.sender]);\\n\\n      balances[from] = balances[from].sub(tokens);\\n      balances[to] = balances[to].add(tokens);\\n      allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\n      emit Transfer(from, to, tokens);\\n\\n      return true;\\n  }\\n\\n  // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  function approve(address spender, uint256 tokens) public returns (bool success){\\n      allowed[msg.sender][spender] = tokens;\\n      emit Approval(msg.sender, spender, tokens);\\n      return true;\\n  }\\n\\n  // Function to check the amount of tokens that an owner allowed to a spender.\\n  function allowance(address tokenOwner, address spender) public view returns (uint256 remaining){\\n      return allowed[tokenOwner][spender];\\n  }\\n\\n  // Increase the amount of tokens that an owner allowed to a spender.\\n  // approve should be called when allowed[spender] == 0.\\n  // To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\\n  function increaseApproval(address spender, uint256 addedValue) public returns (bool) {\\n    allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  // Decrease the amount of tokens that an owner allowed to a spender.\\n  // approve should be called when allowed[spender] == 0.\\n  // To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\\n  function decreaseApproval(address spender, uint256 subtractedValue ) public returns (bool){\\n    uint256 oldValue = allowed[msg.sender][spender];\\n    if (subtractedValue \\u003e= oldValue) {\\n      allowed[msg.sender][spender] = 0;\\n    } else {\\n      allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\\n    }\\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n}\\n\"},\"StandardTokenVesting.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./FLXCToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/** @title StandardTokenVesting\\n  * @dev A token holder contract that can release its token balance gradually like a\\n  * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the owner.\\n  */\\ncontract StandardTokenVesting is Ownable {\\n  using SafeMath for uint256;\\n\\n  event Released(uint256 amount);\\n  event Revoked();\\n\\n  // beneficiary of tokens after they are released\\n  address public beneficiary;\\n\\n  uint256 public cliff;\\n  uint256 public start;\\n  uint256 public duration;\\n\\n  bool public revocable;\\n\\n  mapping (address =\\u003e uint256) public released;\\n  mapping (address =\\u003e bool) public revoked;\\n\\n\\n  /** @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\\n   * of the balance will have vested.\\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\\n   * @param _start the time (as Unix time) at which point vesting starts\\n   * @param _duration duration in seconds of the period in which the tokens will vest\\n   * @param _revocable whether the vesting is revocable or not\\n   */\\n  constructor(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\\n    require(_beneficiary != address(0));\\n    require(_cliff \\u003c= _duration);\\n\\n    beneficiary = _beneficiary;\\n    revocable = _revocable;\\n    duration = _duration;\\n    owner = msg.sender;\\n    cliff = _start.add(_cliff);\\n    start = _start;\\n  }\\n\\n  /** @notice Transfers vested tokens to beneficiary.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function release(FLXCToken token) public returns (bool){\\n    uint256 unreleased = releasableAmount(token);\\n    require(unreleased \\u003e 0);\\n    released[token] = released[token].add(unreleased);\\n\\n    token.transfer(beneficiary, unreleased);\\n    emit Released(unreleased);\\n    return true;\\n  }\\n\\n  /** @notice Allows the owner to revoke the vesting. Tokens already vested\\n    * remain in the contract, the rest are returned to the owner.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function revoke(FLXCToken token) public onlyOwner returns(bool) {\\n    require(revocable);\\n    require(!revoked[token]);\\n    uint256 balance = token.balanceOf(this);\\n    uint256 unreleased = releasableAmount(token);\\n    uint256 refund = balance.sub(unreleased);\\n\\n    revoked[token] = true;\\n    token.transfer(owner, refund);\\n    emit Revoked();\\n\\n    return true;\\n  }\\n\\n  /** @dev Calculates the amount that has already vested but hasn\\u0027t been released yet.\\n    * @param token ERC20 token which is being vested\\n    */\\n  function releasableAmount(FLXCToken token) public view returns (uint256) {\\n    return vestedAmount(token).sub(released[token]);\\n  }\\n\\n  /** @dev Calculates the amount that has already vested.\\n    * @param token FLXC Token which is being vested\\n    */\\n  function vestedAmount(FLXCToken token) public view returns (uint256) {\\n    uint256 currentBalance = token.balanceOf(this);\\n    uint256 totalBalance = currentBalance.add(released[token]);\\n\\n    if (block.timestamp \\u003c cliff) {\\n      return 0;\\n    } else if (block.timestamp \\u003e= start.add(duration) || revoked[token]) {\\n      return totalBalance;\\n    } else {\\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\\n    }\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVestingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"setVestingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FLXCToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://5b8059e7ff9509506b80b4d158f54a76988335ff63c2731e1c11bd857cbab0f8"}]}