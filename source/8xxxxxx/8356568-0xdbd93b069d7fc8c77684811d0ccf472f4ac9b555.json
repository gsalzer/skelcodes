{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\ncontract ERC20\r\n{\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint    value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title Burnable ERC20 Token Interface\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract BurnableERC20 is ERC20\r\n{\r\n    function burn(\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function burnFrom(\r\n        address from,\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// This code is taken from https://gist.github.com/holiman/069de8d056a531575d2b786df3345665\r\n\r\nlibrary Cloneable {\r\n    function clone(address a)\r\n        external\r\n        returns (address)\r\n    {\r\n\r\n    /*\r\n    Assembly of the code that we want to use as init-code in the new contract,\r\n    along with stack values:\r\n                    # bottom [ STACK ] top\r\n     PUSH1 00       # [ 0 ]\r\n     DUP1           # [ 0, 0 ]\r\n     PUSH20\r\n     <address>      # [0,0, address]\r\n     DUP1           # [0,0, address ,address]\r\n     EXTCODESIZE    # [0,0, address, size ]\r\n     DUP1           # [0,0, address, size, size]\r\n     SWAP4          # [ size, 0, address, size, 0]\r\n     DUP1           # [ size, 0, address ,size, 0,0]\r\n     SWAP2          # [ size, 0, address, 0, 0, size]\r\n     SWAP3          # [ size, 0, size, 0, 0, address]\r\n     EXTCODECOPY    # [ size, 0]\r\n     RETURN\r\n\r\n    The code above weighs in at 33 bytes, which is _just_ above fitting into a uint.\r\n    So a modified version is used, where the initial PUSH1 00 is replaced by `PC`.\r\n    This is one byte smaller, and also a bit cheaper Wbase instead of Wverylow. It only costs 2 gas.\r\n\r\n     PC             # [ 0 ]\r\n     DUP1           # [ 0, 0 ]\r\n     PUSH20\r\n     <address>      # [0,0, address]\r\n     DUP1           # [0,0, address ,address]\r\n     EXTCODESIZE    # [0,0, address, size ]\r\n     DUP1           # [0,0, address, size, size]\r\n     SWAP4          # [ size, 0, address, size, 0]\r\n     DUP1           # [ size, 0, address ,size, 0,0]\r\n     SWAP2          # [ size, 0, address, 0, 0, size]\r\n     SWAP3          # [ size, 0, size, 0, 0, address]\r\n     EXTCODECOPY    # [ size, 0]\r\n     RETURN\r\n\r\n    The opcodes are:\r\n    58 80 73 <address> 80 3b 80 93 80 91 92 3c F3\r\n    We get <address> in there by OR:ing the upshifted address into the 0-filled space.\r\n      5880730000000000000000000000000000000000000000803b80938091923cF3\r\n     +000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx000000000000000000\r\n     -----------------------------------------------------------------\r\n      588073xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx00000803b80938091923cF3\r\n\r\n    This is simply stored at memory position 0, and create is invoked.\r\n    */\r\n        address retval;\r\n        assembly{\r\n            mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(a,0x1000000000000000000)))\r\n            retval := create(0,0, 32)\r\n        }\r\n        return retval;\r\n    }\r\n}\r\n\r\n/// @title IExchange\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract IExchange is Claimable, ReentrancyGuard\r\n{\r\n    string  constant public version          = \"\"; // must override this\r\n    bytes32 constant public genesisBlockHash = 0;  // must override this\r\n\r\n    /// @dev Clone an exchange without any initialization\r\n    /// @return  cloneAddress The address of the new exchange.\r\n    function clone()\r\n        external\r\n        nonReentrant\r\n        returns (address cloneAddress)\r\n    {\r\n        address origin = address(this);\r\n        cloneAddress = Cloneable.clone(origin);\r\n\r\n        assert(cloneAddress != origin);\r\n        assert(cloneAddress != address(0));\r\n    }\r\n}\r\n\r\n/// @title ILoopring\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopring is Claimable, ReentrancyGuard\r\n{\r\n    address public protocolRegistry;\r\n    address public lrcAddress;\r\n    uint    public exchangeCreationCostLRC;\r\n\r\n    event ExchangeInitialized(\r\n        uint    indexed exchangeId,\r\n        address indexed exchangeAddress,\r\n        address indexed owner,\r\n        address         operator,\r\n        bool            onchainDataAvailability\r\n    );\r\n\r\n    /// @dev Initialize and register an exchange.\r\n    ///      This function should only be callabled by the protocolRegistry contract.\r\n    ///      Also note that this function can only be called once per exchange instance.\r\n    /// @param  exchangeAddress The address of the exchange to initialize and register.\r\n    /// @param  exchangeId The unique exchange id.\r\n    /// @param  owner The owner of the exchange.\r\n    /// @param  operator The operator of the exchange.\r\n    /// @param  onchainDataAvailability True if \"Data Availability\" is turned on for this\r\n    ///         exchange. Note that this value can not be changed once the exchange is initialized.\r\n    /// @return exchangeId The id of the exchange.\r\n    function initializeExchange(\r\n        address exchangeAddress,\r\n        uint    exchangeId,\r\n        address owner,\r\n        address payable operator,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external;\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n  /**\r\n  * @dev Tells the address of the implementation where every call will be delegated.\r\n  * @return address of the implementation to which it will be delegated\r\n  */\r\n  function implementation() public view returns (address);\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable external {\r\n    address _impl = implementation();\r\n    require(_impl != address(0));\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n}\r\n\r\n/// @title IProtocalRegistry\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract IProtocolRegistry is Claimable, ReentrancyGuard\r\n{\r\n    address     public lrcAddress;\r\n    address     public defaultProtocol;\r\n    address[]   public exchanges;\r\n\r\n    event ExchangeForged (\r\n        address indexed loopring,\r\n        address indexed exchangeAddress,\r\n        address         owner,\r\n        bool            supportUpgradability,\r\n        bool            onchainDataAvailability,\r\n        uint            exchangeId,\r\n        uint            amountLRCBurned\r\n    );\r\n\r\n    event ProtocolRegistered (\r\n        address indexed protocol,\r\n        address indexed implementation\r\n    );\r\n\r\n    event ProtocolUpgraded (\r\n        address indexed protocol,\r\n        address indexed newImplementation,\r\n        address         oldImplementation\r\n    );\r\n\r\n    event DefaultProtocolChanged(\r\n        address indexed newDefault,\r\n        address         oldDefault\r\n    );\r\n\r\n    event ProtocolDisabled(\r\n        address indexed protocol\r\n    );\r\n\r\n    event ProtocolEnabled(\r\n        address indexed protocol\r\n    );\r\n\r\n    /// @dev Registers a new protocol\r\n    /// @param protocol The protocol address.\r\n    /// @param implementation The protocol's implementaion address.\r\n    /// @return implementation The Protocol's implementation.\r\n    function registerProtocol(\r\n        address protocol,\r\n        address implementation\r\n        )\r\n        external;\r\n\r\n    /// @dev Updates a protocol with a new implementation\r\n    /// @param protocol The protocol address.\r\n    /// @param newImplementation The protocol's new implementation.\r\n    /// @return oldImplementation The Protocol's previous implementation.\r\n    function upgradeProtocol(\r\n        address protocol,\r\n        address newImplementation\r\n        )\r\n        external\r\n        returns (address oldImplementation);\r\n\r\n    /// @dev Disables a protocol.\r\n    /// @param protocol The protocol to disable.\r\n    function disableProtocol(\r\n        address protocol\r\n        )\r\n        external;\r\n\r\n    /// @dev Enables a protocol.\r\n    /// @param protocol The protocol to re-enable.\r\n    function enableProtocol(\r\n        address protocol\r\n        )\r\n        external;\r\n\r\n    /// @dev Sets the default protocol.\r\n    /// @param protocol The address of the default protocol version.\r\n    function setDefaultProtocol(\r\n        address protocol\r\n        )\r\n        external;\r\n\r\n    /// @dev Returns information regarding the default protocol.\r\n    ///      This function throws if no default protocol is set.\r\n    /// @return loopring The default protocol address.\r\n    /// @return implementation The protocol's implementation.\r\n    /// @return enabled Whether the protocol is enabled.\r\n    function getDefaultProtocol()\r\n        external\r\n        view\r\n        returns (\r\n            address protocol,\r\n            address implementation,\r\n            bool    enabled\r\n        );\r\n\r\n    /// @dev Returns information regarding a protocol.\r\n    /// @return protocol The protocol address.\r\n    /// @return implementation The protocol's implementation.\r\n    /// @return enabled Whether the protocol is enabled.\r\n    function getProtocol(\r\n        address protocol\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            address implementation,\r\n            bool    enabled\r\n        );\r\n\r\n    /// @dev Returns the protocol associated with an exchange.\r\n    /// @param exchangeAddress The address of the exchange.\r\n    /// @return protocol The protocol address.\r\n    /// @return implementation The protocol's implementation.\r\n    /// @return enabled Whether the protocol is enabled.\r\n    function getExchangeProtocol(\r\n        address exchangeAddress\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            address protocol,\r\n            address implementation,\r\n            bool    enabled\r\n        );\r\n\r\n    /// @dev Create a new exchange using the default protocol with msg.sender\r\n    ///      as owner and operator.\r\n    /// @param supportUpgradability True to indicate an ExchangeProxy shall be deploy\r\n    ///        in front of the native exchange contract to support upgradability.\r\n    /// @param onchainDataAvailability If the on-chain DA is on\r\n    /// @return exchangeAddress The new exchange's  address.\r\n    /// @return exchangeId The new exchange's ID.\r\n    function forgeExchange(\r\n        bool supportUpgradability,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        returns (\r\n            address exchangeAddress,\r\n            uint    exchangeId\r\n        );\r\n\r\n    /// @dev Create a new exchange using a specific protocol with msg.sender\r\n    ///      as owner and operator.\r\n    /// @param protocol The protocol address.\r\n    /// @param supportUpgradability True to indicate an ExchangeProxy shall be deploy\r\n    ///        in front of the native exchange contract to support upgradability.\r\n    /// @param onchainDataAvailability IF the on-chain DA is on\r\n    /// @return exchangeAddress The new exchange's address.\r\n    /// @return exchangeId The new exchange's ID.\r\n    function forgeExchange(\r\n        address protocol,\r\n        bool    supportUpgradability,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external\r\n        returns (\r\n            address exchangeAddress,\r\n            uint    exchangeId\r\n        );\r\n}\r\n\r\n/// @title ExchangeProxy\r\n/// @dev This proxy is designed to support transparent upgradeability offered by a\r\n///      IProtocolRegistry contract.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ExchangeProxy is Proxy\r\n{\r\n    bytes32 private constant registryPosition = keccak256(\r\n        \"org.loopring.protocol.v3.registry\"\r\n    );\r\n\r\n    constructor(address _registry)\r\n        public\r\n    {\r\n        bytes32 position = registryPosition;\r\n        assembly {\r\n          sstore(position, _registry)\r\n        }\r\n    }\r\n\r\n    function registry()\r\n        public\r\n        view\r\n        returns (address _addr)\r\n    {\r\n        bytes32 position = registryPosition;\r\n        assembly {\r\n          _addr := sload(position)\r\n        }\r\n    }\r\n\r\n    function protocol()\r\n        public\r\n        view\r\n        returns (address _protocol)\r\n    {\r\n        IProtocolRegistry r = IProtocolRegistry(registry());\r\n        (_protocol, , ) = r.getExchangeProtocol(address(this));\r\n    }\r\n\r\n    function implementation()\r\n        public\r\n        view\r\n        returns (address impl)\r\n    {\r\n        IProtocolRegistry r = IProtocolRegistry(registry());\r\n        (, impl, ) = r.getExchangeProtocol(address(this));\r\n    }\r\n}\r\n\r\n\r\n/// @title An Implementation of IProtocolRegistry.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ProtocolRegistry is IProtocolRegistry\r\n{\r\n    struct Protocol\r\n    {\r\n       address implementation;  // updatable\r\n       bool    enabled;         // updatable\r\n    }\r\n\r\n    struct Implementation\r\n    {\r\n        address protocol; // must never change\r\n        string  version;  // must be unique globally\r\n    }\r\n\r\n    mapping (address => Protocol)       private protocols;\r\n    mapping (address => Implementation) private impls;\r\n    mapping (string => address)         private versions;\r\n    mapping (address => address)        private exchangeToProtocol;\r\n\r\n    modifier addressNotZero(address addr)\r\n    {\r\n        require(addr != address(0), \"ZERO_ADDRESS\");\r\n        _;\r\n    }\r\n\r\n    modifier protocolNotRegistered(address addr)\r\n    {\r\n        require(protocols[addr].implementation == address(0), \"PROTOCOL_REGISTERED\");\r\n        _;\r\n    }\r\n\r\n    modifier protocolRegistered(address addr)\r\n    {\r\n        require(protocols[addr].implementation != address(0), \"PROTOCOL_NOT_REGISTERED\");\r\n        _;\r\n    }\r\n\r\n    modifier protocolDisabled(address addr)\r\n    {\r\n        require(!protocols[addr].enabled, \"PROTOCOL_ENABLED\");\r\n        _;\r\n    }\r\n\r\n    modifier protocolEnabled(address addr)\r\n    {\r\n        require(protocols[addr].enabled, \"PROTOCOL_DISABLED\");\r\n        _;\r\n    }\r\n\r\n    modifier implNotRegistered(address addr)\r\n    {\r\n        require(impls[addr].protocol == address(0), \"IMPL_REGISTERED\");\r\n        _;\r\n    }\r\n\r\n    modifier implRegistered(address addr)\r\n    {\r\n        require(impls[addr].protocol != address(0), \"IMPL_NOT_REGISTERED\");\r\n        _;\r\n    }\r\n\r\n    /// === Public Functions ==\r\n    constructor(\r\n        address _lrcAddress\r\n        )\r\n        Claimable()\r\n        public\r\n        addressNotZero(_lrcAddress)\r\n    {\r\n        lrcAddress = _lrcAddress;\r\n    }\r\n\r\n    function registerProtocol(\r\n        address protocol,\r\n        address implementation\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        addressNotZero(protocol)\r\n        addressNotZero(implementation)\r\n        protocolNotRegistered(protocol)\r\n        implNotRegistered(implementation)\r\n    {\r\n        ILoopring loopring = ILoopring(protocol);\r\n        require(loopring.owner() == owner, \"INCONSISTENT_OWNER\");\r\n        require(loopring.protocolRegistry() == address(this), \"INCONSISTENT_REGISTRY\");\r\n        require(loopring.lrcAddress() == lrcAddress, \"INCONSISTENT_LRC_ADDRESS\");\r\n\r\n        string memory version = IExchange(implementation).version();\r\n        require(versions[version] == address(0), \"VERSION_USED\");\r\n\r\n        // register\r\n        impls[implementation] = Implementation(protocol, version);\r\n        versions[version] = implementation;\r\n\r\n        protocols[protocol] = Protocol(implementation, true);\r\n        emit ProtocolRegistered(protocol, implementation);\r\n    }\r\n\r\n    function upgradeProtocol(\r\n        address protocol,\r\n        address newImplementation\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        addressNotZero(protocol)\r\n        addressNotZero(newImplementation)\r\n        protocolRegistered(protocol)\r\n        returns (address oldImplementation)\r\n    {\r\n        require(protocols[protocol].implementation != newImplementation, \"SAME_IMPLEMENTATION\");\r\n\r\n        oldImplementation = protocols[protocol].implementation;\r\n\r\n        if (impls[newImplementation].protocol == address(0)) {\r\n            // the new implementation is new\r\n            string memory version = IExchange(newImplementation).version();\r\n            require(versions[version] == address(0), \"VERSION_USED\");\r\n\r\n            impls[newImplementation] = Implementation(protocol, version);\r\n            versions[version] = newImplementation;\r\n        } else {\r\n            require(impls[newImplementation].protocol == protocol, \"IMPLEMENTATION_BINDED\");\r\n        }\r\n\r\n        protocols[protocol].implementation = newImplementation;\r\n        emit ProtocolUpgraded(protocol, newImplementation, oldImplementation);\r\n    }\r\n\r\n    function disableProtocol(\r\n        address protocol\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        addressNotZero(protocol)\r\n        protocolRegistered(protocol)\r\n        protocolEnabled(protocol)\r\n    {\r\n        require(protocol != defaultProtocol, \"FORBIDDEN\");\r\n        protocols[protocol].enabled = false;\r\n        emit ProtocolDisabled(protocol);\r\n    }\r\n\r\n    function enableProtocol(\r\n        address protocol\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        addressNotZero(protocol)\r\n        protocolRegistered(protocol)\r\n        protocolDisabled(protocol)\r\n    {\r\n        protocols[protocol].enabled = true;\r\n        emit ProtocolEnabled(protocol);\r\n    }\r\n\r\n    function setDefaultProtocol(\r\n        address protocol\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n        addressNotZero(protocol)\r\n        protocolRegistered(protocol)\r\n        protocolEnabled(protocol)\r\n    {\r\n        address oldDefaultProtocol = defaultProtocol;\r\n        defaultProtocol = protocol;\r\n        emit DefaultProtocolChanged(protocol, oldDefaultProtocol);\r\n    }\r\n\r\n    function getDefaultProtocol()\r\n        external\r\n        view\r\n        returns (\r\n            address protocol,\r\n            address implementation,\r\n            bool    enabled\r\n        )\r\n    {\r\n        require(defaultProtocol != address(0), \"NO_DEFAULT_PROTOCOL\");\r\n        protocol = defaultProtocol;\r\n        Protocol storage p = protocols[protocol];\r\n        implementation = p.implementation;\r\n        enabled = p.enabled;\r\n    }\r\n\r\n    function getProtocol(\r\n        address protocol\r\n        )\r\n        external\r\n        view\r\n        addressNotZero(protocol)\r\n        protocolRegistered(protocol)\r\n        returns (\r\n            address implementation,\r\n            bool    enabled\r\n        )\r\n    {\r\n        Protocol storage p = protocols[protocol];\r\n        implementation = p.implementation;\r\n        enabled = p.enabled;\r\n    }\r\n\r\n    function getExchangeProtocol(\r\n        address exchangeAddress\r\n        )\r\n        external\r\n        view\r\n        addressNotZero(exchangeAddress)\r\n        returns (\r\n            address protocol,\r\n            address implementation,\r\n            bool    enabled\r\n        )\r\n    {\r\n        protocol = exchangeToProtocol[exchangeAddress];\r\n        require(protocol != address(0), \"INVALID_EXCHANGE\");\r\n\r\n        Protocol storage p = protocols[protocol];\r\n        implementation = p.implementation;\r\n        enabled = p.enabled;\r\n    }\r\n\r\n    function forgeExchange(\r\n        bool    supportUpgradability,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external\r\n        nonReentrant\r\n        returns (\r\n            address exchangeAddress,\r\n            uint    exchangeId\r\n        )\r\n    {\r\n        return forgeExchangeInternal(\r\n            defaultProtocol,\r\n            supportUpgradability,\r\n            onchainDataAvailability\r\n        );\r\n    }\r\n\r\n    function forgeExchange(\r\n        address protocol,\r\n        bool    supportUpgradability,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external\r\n        nonReentrant\r\n        returns (\r\n            address exchangeAddress,\r\n            uint    exchangeId\r\n        )\r\n    {\r\n        return forgeExchangeInternal(\r\n            protocol,\r\n            supportUpgradability,\r\n            onchainDataAvailability\r\n        );\r\n    }\r\n\r\n    // --- Private Functions ---\r\n\r\n    function forgeExchangeInternal(\r\n        address protocol,\r\n        bool    supportUpgradability,\r\n        bool    onchainDataAvailability\r\n        )\r\n        private\r\n        protocolRegistered(protocol)\r\n        protocolEnabled(protocol)\r\n        returns (\r\n            address exchangeAddress,\r\n            uint    exchangeId\r\n        )\r\n    {\r\n        ILoopring loopring = ILoopring(protocol);\r\n        uint exchangeCreationCostLRC = loopring.exchangeCreationCostLRC();\r\n\r\n        if (exchangeCreationCostLRC > 0) {\r\n            require(\r\n                BurnableERC20(lrcAddress).burnFrom(msg.sender, exchangeCreationCostLRC),\r\n                \"BURN_FAILURE\"\r\n            );\r\n        }\r\n\r\n        IExchange implementation = IExchange(protocols[protocol].implementation);\r\n        if (supportUpgradability) {\r\n            // Deploy an exchange proxy and points to the implementation\r\n            exchangeAddress = address(new ExchangeProxy(address(this)));\r\n        } else {\r\n            // Clone a native exchange from the implementation.\r\n            exchangeAddress = implementation.clone();\r\n        }\r\n\r\n        assert(exchangeToProtocol[exchangeAddress] == address(0));\r\n\r\n        exchangeToProtocol[exchangeAddress] = protocol;\r\n        exchanges.push(exchangeAddress);\r\n        exchangeId = exchanges.length;\r\n\r\n        loopring.initializeExchange(\r\n            exchangeAddress,\r\n            exchangeId,\r\n            msg.sender,  // owner\r\n            msg.sender,  // operator\r\n            onchainDataAvailability\r\n        );\r\n\r\n        emit ExchangeForged(\r\n            protocol,\r\n            exchangeAddress,\r\n            msg.sender,\r\n            supportUpgradability,\r\n            onchainDataAvailability,\r\n            exchangeId,\r\n            exchangeCreationCostLRC\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"supportUpgradability\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"}],\"name\":\"forgeExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"supportUpgradability\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"}],\"name\":\"forgeExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"getProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchanges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"registerProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lrcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"setDefaultProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"}],\"name\":\"getExchangeProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"enableProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"disableProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeProtocol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lrcAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loopring\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"supportUpgradability\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLRCBurned\",\"type\":\"uint256\"}],\"name\":\"ExchangeForged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ProtocolRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"}],\"name\":\"ProtocolUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDefault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDefault\",\"type\":\"address\"}],\"name\":\"DefaultProtocolChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"ProtocolDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"}],\"name\":\"ProtocolEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ProtocolRegistry","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bbbbca6a901c926f240b89eacb641d8aec7aeafd","Library":"","SwarmSource":"bzzr://1d7fc8935c343640d8a080353e62cf1a9461603b23fb195d35837a94a7c9be7d"}]}