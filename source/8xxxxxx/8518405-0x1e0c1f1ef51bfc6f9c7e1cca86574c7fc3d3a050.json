{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ncontract ERC20Interface {\r\n  function totalSupply() public view returns (uint);\r\n  function balanceOf(address tokenOwner) public view returns (uint balance);\r\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n  function transfer(address to, uint tokens) public returns (bool success);\r\n  function approve(address spender, uint tokens) public returns (bool success);\r\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function add(uint a, uint b) internal pure returns (uint c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint c) {\r\n    require(b <= a);\r\n    c = a - b;\r\n  }\r\n\r\n  function mul(uint a, uint b) internal pure returns (uint c) {\r\n    c = a * b;\r\n    require(a == 0 || c / a == b);\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint c) {\r\n    require(b > 0);\r\n    c = a / b;\r\n  }\r\n}\r\n\r\nlibrary Math {\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\ncontract alive is ERC20Interface {\r\n\r\n  using SafeMath for uint;\r\n  using Math for uint;\r\n  uint8 public constant decimals = 18;\r\n  string public constant symbol = \"ALIVE\";\r\n  string public constant name = \"PROOF OF LIFE\";\r\n  uint public constant maxSupply = 1000000 * 10**uint(decimals);\r\n  uint private _totalSupply = 0;\r\n  uint private _minted = 0;\r\n  uint private _nextAirdrop = 9571 * 10**uint(decimals);\r\n  address devAddress = address(0x8160aEBf3B1a65D1b4992A95Bd50350b1a08E35b);\r\n  address[] private _holderArray;\r\n\r\n  mapping(address => uint) private _balances;\r\n  mapping(address => mapping (address => uint)) private _allowances;\r\n  mapping(address => bool) private _airdropClaim; \r\n  mapping(address => bool) private _holderFlag;\r\n  mapping(address => uint) private _timeStamp;\r\n\r\n  function totalSupply() public view returns (uint) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n    return _balances[tokenOwner];\r\n  }\r\n\r\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n    return _allowances[tokenOwner][spender];\r\n  }\r\n\r\n  function transfer(address to, uint amount) public returns (bool success) {\r\n    _transfer(msg.sender, to, amount);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint amount) public returns (bool success) {\r\n    _approve(msg.sender, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address sender, address recipient, uint amount) public returns (bool success) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n    return true;\r\n  }\r\n\r\n  //internal functions\r\n  function _isHuman(address addr) private returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size == 0;\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint amount) internal {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function _transfer(address sender, address recipient, uint amount) internal {\r\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    // If transfer amount is zero emit event and stop execution\r\n    if (amount == 0) {\r\n      emit Transfer(sender, recipient, 0);\r\n      return;\r\n    }\r\n\r\n    _balances[sender] = _balances[sender].sub(amount);\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n\r\n    //if receiving address is a new one and the receiving address is not a contract and it has a balnce of >0 tokens, then add it to the array of all holders\r\n    //contract addresses are kept out of slashing to enable trading activity\r\n    if(_holderFlag[recipient] != true && _isHuman(recipient) && (_balances[recipient] > 0)){ \r\n      _holderArray.push(recipient);\r\n      _holderFlag[recipient] = true;\r\n    }\r\n\r\n    //update timestamp of sender and recipient last activity\r\n    _timeStamp[sender] = now;\r\n    _timeStamp[recipient] = now;\r\n    if(_minted >= 785000 * 10**uint(decimals)){\r\n      _findSlashCandidate();\r\n    }\r\n  }\r\n\r\n  function _findSlashCandidate() private {\r\n    uint oldestTimestamp = now;\r\n    address oldestInactive = address(0);\r\n    for(uint i=0; i<_holderArray.length; i++) { //loop to findout the oldest inactive account with non zero balance\r\n      if(_timeStamp[_holderArray[i]]<oldestTimestamp && (_balances[_holderArray[i]] > 0)) {\r\n        oldestInactive = _holderArray[i];\r\n        oldestTimestamp = _timeStamp[oldestInactive];\r\n      }\r\n    }\r\n    _slash(oldestInactive);\r\n  }\r\n\r\n  function _slash(address account) private {\r\n    uint slashingAmount = _balances[account].div(2);\r\n    if(slashingAmount < 1*10**(decimals)) { // slash accounts with token dust to zero\r\n      slashingAmount = _balances[account];\r\n    }\r\n    _timeStamp[account] = now; //ensure slashed accounts dont get slashed again by updating timestamp\r\n    _burn(account,slashingAmount); //slash half tokens of oldest inactive account\r\n  }\r\n\r\n  function _burn(address account, uint amount) private {\r\n    _balances[account] = _balances[account].sub(amount);\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  function _mint(address account, uint amount) internal {\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _minted = _minted.add(amount);\r\n    uint devReward = (amount.mul(5)).div(100);\r\n    _balances[devAddress] = _balances[devAddress].add(devReward);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n    emit Transfer(address(0), devAddress, devReward);\r\n  }\r\n\r\n  function _airdrop(address account) internal {\r\n    require(_minted < maxSupply); // check on total suppy\r\n    require(_airdropClaim[account] != true); //airdrop can be claimed only once per account\r\n    _nextAirdrop = Math.min((_nextAirdrop.mul(995)).div(1000),(maxSupply - _minted));\r\n    _holderArray.push(account);\r\n    _timeStamp[account] = now;\r\n    _holderFlag[account] = true;\r\n    _airdropClaim[account] = true;\r\n    _mint(account,_nextAirdrop);\r\n  }\r\n\r\n  function () external payable {\r\n    if(msg.value > 0){\r\n      revert();\r\n    }\r\n    else {\r\n      _airdrop(msg.sender);\r\n    }\r\n  }\r\n\r\n  function burned() public view returns(uint) {\r\n    return _minted-_totalSupply;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"alive","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://aa49c38d9c8068c22a4bdebca1f99288c5bdf79de6dcb5adf81e73e8552b3c8c"}]}