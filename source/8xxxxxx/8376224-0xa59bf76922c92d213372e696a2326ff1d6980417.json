{"status":"1","message":"OK","result":[{"SourceCode":"//  This file is concatenated source code for the HashRegistry smart contract\r\n// which was uploaded to Ethereum mainnet at the address\r\n// 0xA59bF76922c92D213372e696A2326Ff1D6980417 on August 18, 2019.\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n *  HashRegistry contract\r\n *      This Smart contract allows for the association of a hash with an Ethereum\r\n *  address.  \r\n *      Contract owner can update associations. \r\n *      Emits a HashModified event when an association is added / changed.\r\n */\r\ncontract HashRegistry is Ownable, WhitelistedRole {\r\n\r\n    event HashModified(uint256 hashData);\r\n\r\n    uint256 _feeAdd = 0;\r\n    uint256 _feeUpdate = 0;\r\n\r\n    mapping (uint256 => address) private _hashValues;\r\n    mapping (address => uint256) private _associations;\r\n\r\n    struct HashMetadata {\r\n        address owner;\r\n        uint256 expiration;\r\n        uint256 associatedHash;\r\n        string notes;\r\n    }\r\n\r\n    mapping (uint256 => HashMetadata) private _hashData;\r\n\r\n\r\n    /** \r\n     * \r\n     */\r\n    function addHash(uint256 hashData) public payable {\r\n        require(_hashData[hashData].owner == address(0), \"Hash already exists\");\r\n        require(msg.value >= _feeAdd, 'Fee not sufficient');\r\n\r\n        HashMetadata memory metadata = HashMetadata(msg.sender, 0, 0, \"\");\r\n        _addHash(hashData, metadata);\r\n    }\r\n\r\n    /** \r\n     * \r\n     */\r\n    function addHashWithMetadata(uint256 hashData, \r\n                                    uint256 expiration, \r\n                                    uint256 assocHash, \r\n                                    string memory notes) public payable {\r\n        require(_hashData[hashData].owner == address(0), \"Hash already exists\");\r\n        require(msg.value >= _feeAdd, 'Fee not sufficient');\r\n\r\n        HashMetadata memory metadata = HashMetadata(msg.sender, expiration, assocHash, notes);\r\n        _addHash(hashData, metadata);\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    function updateHashMetadata(uint256 hashData,\r\n                                uint256 expiration,\r\n                                uint256 assocHash,\r\n                                string memory notes) public payable {\r\n        require(_hashData[hashData].owner == msg.sender, \"Can only update owned hashes\");\r\n        require(_hashData[hashData].owner != address(0), \"Hash must exist\");\r\n        require(msg.value >= _feeUpdate, 'Update Fee not sufficient');\r\n\r\n        HashMetadata memory metadata = HashMetadata(msg.sender, expiration, assocHash, notes);\r\n        _addHash(hashData, metadata);\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    function updateHashMetadataWhitelisted(uint256 hashData,\r\n                                        address hashOwner,\r\n                                        uint256 expiration,\r\n                                        uint256 assocHash,\r\n                                        string memory notes) public onlyWhitelisted {\r\n        require(hashOwner != address(0), \"Hash must have an owner\");\r\n\r\n        HashMetadata memory metadata = HashMetadata(hashOwner, expiration, assocHash, notes);\r\n        _addHash(hashData, metadata);\r\n    }\r\n\r\n    /**\r\n     * @return true if the hash data specified has been registered\r\n     */\r\n    function isRegistered(uint256 hashData) public view returns (bool) {\r\n        return _hashData[hashData].owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @return the owning address of the hash\r\n     */\r\n    function getOwner(uint256 hashData) public view returns (address) {\r\n        return _hashData[hashData].owner;\r\n    }\r\n\r\n    /**\r\n     * @return the expiration date (block number) associated with the hash\r\n     */\r\n    function getExpiration(uint256 hashData) public view returns (uint256) {\r\n        return _hashData[hashData].expiration;\r\n    }\r\n\r\n    /**\r\n     * @return true if the hash is expired\r\n     */\r\n    function isExpired(uint256 hashData) public view returns (bool) {\r\n        return ((_hashData[hashData].expiration != 0) && \r\n                (_hashData[hashData].expiration <= block.number));\r\n    }\r\n\r\n    /**\r\n     * @return the associated (secondary) hash associated with the (primary) hash\r\n     */\r\n    function getAssociatedHash(uint256 hashData) public view returns (uint256) {\r\n        return _hashData[hashData].associatedHash;\r\n    }\r\n\r\n    /**\r\n     * @return the notes string associated withthe hash\r\n     */\r\n    function getNotes(uint256 hashData) public view returns (string memory) {\r\n        return _hashData[hashData].notes;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     */\r\n    function setFeeAdd(uint256 fee) public onlyOwner {\r\n        _feeAdd = fee;\r\n    }\r\n\r\n    /**\r\n     * @return fee (in wei) for performing anonymous interactions\r\n     */\r\n    function getFeeAdd() public view returns (uint256) {\r\n        return _feeAdd;\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    function setFeeUpdate(uint256 fee) public onlyOwner {\r\n        _feeUpdate = fee;\r\n    }\r\n\r\n    /**\r\n     * @return fee (in wei) for performing anonymous update interactions\r\n     */\r\n     function getFeeUpdate() public view returns (uint256) {\r\n        return _feeUpdate;\r\n     }\r\n\r\n\r\n     /**\r\n      *\r\n      */\r\n    function sweep() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n    function _addHash(uint256 hashData, HashMetadata memory metadata) internal {\r\n        _hashData[hashData] = metadata;\r\n        emit HashModified(hashData);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"addHash\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"assocHash\",\"type\":\"uint256\"},{\"name\":\"notes\",\"type\":\"string\"}],\"name\":\"addHashWithMetadata\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sweep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFeeUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"},{\"name\":\"hashOwner\",\"type\":\"address\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"assocHash\",\"type\":\"uint256\"},{\"name\":\"notes\",\"type\":\"string\"}],\"name\":\"updateHashMetadataWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFeeAdd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"getExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"assocHash\",\"type\":\"uint256\"},{\"name\":\"notes\",\"type\":\"string\"}],\"name\":\"updateHashMetadata\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"getNotes\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"getAssociatedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"isExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hashData\",\"type\":\"uint256\"}],\"name\":\"HashModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HashRegistry","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://91acf1d86fb8102d610042b4520afb00340a160844083b684df53ccff79c179d"}]}