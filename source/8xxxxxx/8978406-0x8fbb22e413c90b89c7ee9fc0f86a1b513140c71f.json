{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\n\ncontract SafeMath {\n\n    function safeMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(\n            c / a == b,\n            \"UINT256_OVERFLOW\"\n        );\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(\n            b <= a,\n            \"UINT256_UNDERFLOW\"\n        );\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a + b;\n        require(\n            c >= a,\n            \"UINT256_OVERFLOW\"\n        );\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n\ncontract LibFillResults is\n    SafeMath\n{\n    struct FillResults {\n        uint256 makerAssetFilledAmount;  \n        uint256 takerAssetFilledAmount;  \n        uint256 makerFeePaid;            \n        uint256 takerFeePaid;            \n    }\n\n    struct MatchedFillResults {\n        FillResults left;                    \n        FillResults right;                   \n        uint256 leftMakerAssetSpreadAmount;  \n    }\n\n    \n    \n    \n    \n    function addFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\n        internal\n        pure\n    {\n        totalFillResults.makerAssetFilledAmount = safeAdd(totalFillResults.makerAssetFilledAmount, singleFillResults.makerAssetFilledAmount);\n        totalFillResults.takerAssetFilledAmount = safeAdd(totalFillResults.takerAssetFilledAmount, singleFillResults.takerAssetFilledAmount);\n        totalFillResults.makerFeePaid = safeAdd(totalFillResults.makerFeePaid, singleFillResults.makerFeePaid);\n        totalFillResults.takerFeePaid = safeAdd(totalFillResults.takerFeePaid, singleFillResults.takerFeePaid);\n    }\n}\n\ncontract LibEIP712 {\n\n    \n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    \n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\n\n    \n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\n\n    \n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    \n    \n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor ()\n        public\n    {\n        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            uint256(address(this))\n        ));\n    }\n\n    \n    \n    \n    function hashEIP712Message(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\n\n        \n        \n        \n        \n        \n        \n\n        assembly {\n            \n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  \n            mstore(add(memPtr, 2), eip712DomainHash)                                            \n            mstore(add(memPtr, 34), hashStruct)                                                 \n\n            \n            result := keccak256(memPtr, 66)\n        }\n        return result;\n    }\n}\n\ncontract LibOrder is\n    LibEIP712\n{\n    \n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"Order(\",\n        \"address makerAddress,\",\n        \"address takerAddress,\",\n        \"address feeRecipientAddress,\",\n        \"address senderAddress,\",\n        \"uint256 makerAssetAmount,\",\n        \"uint256 takerAssetAmount,\",\n        \"uint256 makerFee,\",\n        \"uint256 takerFee,\",\n        \"uint256 expirationTimeSeconds,\",\n        \"uint256 salt,\",\n        \"bytes makerAssetData,\",\n        \"bytes takerAssetData\",\n        \")\"\n    ));\n\n    \n    \n    enum OrderStatus {\n        INVALID,                     \n        INVALID_MAKER_ASSET_AMOUNT,  \n        INVALID_TAKER_ASSET_AMOUNT,  \n        FILLABLE,                    \n        EXPIRED,                     \n        FULLY_FILLED,                \n        CANCELLED                    \n    }\n\n    \n    struct Order {\n        address makerAddress;           \n        address takerAddress;           \n        address feeRecipientAddress;    \n        address senderAddress;          \n        uint256 makerAssetAmount;       \n        uint256 takerAssetAmount;       \n        uint256 makerFee;               \n        uint256 takerFee;               \n        uint256 expirationTimeSeconds;  \n        uint256 salt;                   \n        bytes makerAssetData;           \n        bytes takerAssetData;           \n    }\n    \n\n    struct OrderInfo {\n        uint8 orderStatus;                    \n        bytes32 orderHash;                    \n        uint256 orderTakerAssetFilledAmount;  \n    }\n\n    \n    \n    \n    function getOrderHash(Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        orderHash = hashEIP712Message(hashOrder(order));\n        return orderHash;\n    }\n\n    \n    \n    \n    function hashOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        assembly {\n            \n            let pos1 := sub(order, 32)\n            let pos2 := add(order, 320)\n            let pos3 := add(order, 352)\n\n            \n            let temp1 := mload(pos1)\n            let temp2 := mload(pos2)\n            let temp3 := mload(pos3)\n            \n            \n            mstore(pos1, schemaHash)\n            mstore(pos2, makerAssetDataHash)\n            mstore(pos3, takerAssetDataHash)\n            result := keccak256(pos1, 416)\n            \n            \n            mstore(pos1, temp1)\n            mstore(pos2, temp2)\n            mstore(pos3, temp3)\n        }\n        return result;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    \n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    \n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\ncontract IExchange {\n\n    \n    \n    \n    \n    function fillOrKillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        returns (LibFillResults.FillResults memory fillResults);\n\n    \n    \n    \n    \n    \n    \n    function fillOrderNoThrow(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        returns (LibFillResults.FillResults memory fillResults);\n\n    \n    \n    \n    \n    \n    function batchFillOrders(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    \n    \n    \n    function batchFillOrKillOrders(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    \n    \n    \n    \n    function batchFillOrdersNoThrow(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    \n    \n    \n    function marketSellOrders(\n        LibOrder.Order[] memory orders,\n        uint256 takerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    \n    \n    \n    \n    function marketSellOrdersNoThrow(\n        LibOrder.Order[] memory orders,\n        uint256 takerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    \n    \n    \n    function marketBuyOrders(\n        LibOrder.Order[] memory orders,\n        uint256 makerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    \n    \n    \n    \n    function marketBuyOrdersNoThrow(\n        LibOrder.Order[] memory orders,\n        uint256 makerAssetFillAmount,\n        bytes[] memory signatures\n    )\n        public\n        returns (LibFillResults.FillResults memory totalFillResults);\n\n    \n    \n    function batchCancelOrders(LibOrder.Order[] memory orders)\n        public;\n\n    \n    \n    \n    function getOrdersInfo(LibOrder.Order[] memory orders)\n        public\n        view\n        returns (LibOrder.OrderInfo[] memory);\n}\n\ncontract IEtherToken is IERC20 {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n    function withdrawTo(address _to, uint256 _amount) public;\n}\n\nlibrary LibBytesRichErrors {\n\n    enum InvalidByteOperationErrorCodes {\n        FromLessThanOrEqualsToRequired,\n        ToLessThanOrEqualsLengthRequired,\n        LengthGreaterThanZeroRequired,\n        LengthGreaterThanOrEqualsFourRequired,\n        LengthGreaterThanOrEqualsTwentyRequired,\n        LengthGreaterThanOrEqualsThirtyTwoRequired,\n        LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n        DestinationLengthGreaterThanOrEqualSourceLengthRequired\n    }\n\n    \n    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR =\n        0x28006595;\n\n    \n    function InvalidByteOperationError(\n        InvalidByteOperationErrorCodes errorCode,\n        uint256 offset,\n        uint256 required\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n            errorCode,\n            offset,\n            required\n        );\n    }\n}\n\nlibrary LibRichErrors {\n\n    \n    bytes4 internal constant STANDARD_ERROR_SELECTOR =\n        0x08c379a0;\n\n    \n    \n    \n    \n    \n    \n    function StandardError(\n        string memory message\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            STANDARD_ERROR_SELECTOR,\n            bytes(message)\n        );\n    }\n    \n\n    \n    \n    function rrevert(bytes memory errorData)\n        internal\n        pure\n    {\n        assembly {\n            revert(add(errorData, 0x20), mload(errorData))\n        }\n    }\n}\n\nlibrary LibBytes {\n\n    using LibBytes for bytes;\n\n    \n    \n    \n    \n    \n    function rawAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := input\n        }\n        return memoryAddress;\n    }\n\n    \n    \n    \n    function contentAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := add(input, 32)\n        }\n        return memoryAddress;\n    }\n\n    \n    \n    \n    \n    function memCopy(\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        internal\n        pure\n    {\n        if (length < 32) {\n            \n            \n            \n            assembly {\n                let mask := sub(exp(256, sub(32, length)), 1)\n                let s := and(mload(source), not(mask))\n                let d := and(mload(dest), mask)\n                mstore(dest, or(s, d))\n            }\n        } else {\n            \n            if (source == dest) {\n                return;\n            }\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            if (source > dest) {\n                assembly {\n                    \n                    \n                    \n                    \n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    \n                    \n                    \n                    \n                    let last := mload(sEnd)\n\n                    \n                    \n                    \n                    \n                    for {} lt(source, sEnd) {} {\n                        mstore(dest, mload(source))\n                        source := add(source, 32)\n                        dest := add(dest, 32)\n                    }\n\n                    \n                    mstore(dEnd, last)\n                }\n            } else {\n                assembly {\n                    \n                    \n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    \n                    \n                    \n                    \n                    let first := mload(source)\n\n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    for {} slt(dest, dEnd) {} {\n                        mstore(dEnd, mload(sEnd))\n                        sEnd := sub(sEnd, 32)\n                        dEnd := sub(dEnd, 32)\n                    }\n\n                    \n                    mstore(dest, first)\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    function slice(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        \n        \n        if (from > to) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n                from,\n                to\n            ));\n        }\n        if (to > b.length) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n                to,\n                b.length\n            ));\n        }\n\n        \n        result = new bytes(to - from);\n        memCopy(\n            result.contentAddress(),\n            b.contentAddress() + from,\n            result.length\n        );\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    \n    function sliceDestructive(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        \n        \n        if (from > to) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n                from,\n                to\n            ));\n        }\n        if (to > b.length) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n                to,\n                b.length\n            ));\n        }\n\n        \n        assembly {\n            result := add(b, from)\n            mstore(result, sub(to, from))\n        }\n        return result;\n    }\n\n    \n    \n    \n    function popLastByte(bytes memory b)\n        internal\n        pure\n        returns (bytes1 result)\n    {\n        if (b.length == 0) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n                b.length,\n                0\n            ));\n        }\n\n        \n        result = b[b.length - 1];\n\n        assembly {\n            \n            let newLen := sub(mload(b), 1)\n            mstore(b, newLen)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function equals(\n        bytes memory lhs,\n        bytes memory rhs\n    )\n        internal\n        pure\n        returns (bool equal)\n    {\n        \n        \n        \n        return lhs.length == rhs.length && keccak256(lhs) == keccak256(rhs);\n    }\n\n    \n    \n    \n    \n    function readAddress(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (address result)\n    {\n        if (b.length < index + 20) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n                b.length,\n                index + 20 \n            ));\n        }\n\n        \n        \n        \n        index += 20;\n\n        \n        assembly {\n            \n            \n            \n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        internal\n        pure\n    {\n        if (b.length < index + 20) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n                b.length,\n                index + 20 \n            ));\n        }\n\n        \n        \n        \n        index += 20;\n\n        \n        assembly {\n            \n            \n            \n            \n\n            \n            \n            \n            let neighbors := and(\n                mload(add(b, index)),\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n            )\n\n            \n            \n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n            \n            mstore(add(b, index), xor(input, neighbors))\n        }\n    }\n\n    \n    \n    \n    \n    function readBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        if (b.length < index + 32) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n                b.length,\n                index + 32\n            ));\n        }\n\n        \n        index += 32;\n\n        \n        assembly {\n            result := mload(add(b, index))\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        internal\n        pure\n    {\n        if (b.length < index + 32) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n                b.length,\n                index + 32\n            ));\n        }\n\n        \n        index += 32;\n\n        \n        assembly {\n            mstore(add(b, index), input)\n        }\n    }\n\n    \n    \n    \n    \n    function readUint256(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = uint256(readBytes32(b, index));\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        internal\n        pure\n    {\n        writeBytes32(b, index, bytes32(input));\n    }\n\n    \n    \n    \n    \n    function readBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        if (b.length < index + 4) {\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n                b.length,\n                index + 4\n            ));\n        }\n\n        \n        index += 32;\n\n        \n        assembly {\n            result := mload(add(b, index))\n            \n            \n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function writeLength(bytes memory b, uint256 length)\n        internal\n        pure\n    {\n        assembly {\n            mstore(b, length)\n        }\n    }\n}\n\ncontract Forwarder is LibOrder {\n\n    using LibBytes for bytes;\n\n    address public ZERO_EX_EXCHANGE;\n    address public ZERO_EX_TOKEN_PROXY;\n\n    address payable public ETHER_TOKEN;\n\n    constructor(\n        address zeroExExchange,\n        address zeroExProxy,\n        address payable etherToken\n    )\n        public\n    {\n        ZERO_EX_EXCHANGE = zeroExExchange;\n        ZERO_EX_TOKEN_PROXY = zeroExProxy;\n        ETHER_TOKEN = etherToken;\n\n        \n        IEtherToken(ETHER_TOKEN).approve(ZERO_EX_TOKEN_PROXY, (2**256)-1);\n    }\n\n    function fillOrders(\n        LibOrder.Order[] memory orders,\n        uint256[] memory takerAssetFillAmounts,\n        bytes[] memory signatures\n    )\n        public\n        payable\n    {\n        \n        IEtherToken token = IEtherToken(ETHER_TOKEN);\n        IExchange v2Exchange = IExchange(ZERO_EX_EXCHANGE);\n\n        token.deposit.value(msg.value)();\n\n        \n        \n        for (uint i = 0; i < orders.length; i++) {\n            LibFillResults.FillResults memory result = v2Exchange.fillOrderNoThrow(\n                orders[i],\n                takerAssetFillAmounts[i],\n                signatures[i]\n            );\n\n            \n            (address cardToken, uint256 tokenId) = abi.decode(\n                orders[i].makerAssetData.sliceDestructive(\n                    4,\n                    orders[i].makerAssetData.length\n                ),\n                (address, uint256)\n            );\n\n            \n            if (result.takerAssetFilledAmount == takerAssetFillAmounts[i]) {\n                IERC721(cardToken).transferFrom(address(this), msg.sender, tokenId);\n            }\n        }\n\n        uint remainingBalance = token.balanceOf(address(this));\n        token.withdraw(remainingBalance);\n\n        \n        address(msg.sender).transfer(remainingBalance);\n\n        \n        require(\n            address(this).balance == 0,\n            \"Forwarder: must have zero ETH at the end\"\n        );\n\n    }\n\n    function ()\n        external\n        payable\n    {\n        require(\n            msg.sender == address(ETHER_TOKEN),\n            \"Forwarder: will not accept ETH from only ether token address\"\n        );\n    }\n\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_TOKEN\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_EX_EXCHANGE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"takerAssetFillAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"fillOrders\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_EX_TOKEN_PROXY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"zeroExExchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zeroExProxy\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"etherToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Forwarder","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000080bf510fcbf18b91105470639e956102293771200000000000000000000000095e6f48254609a6ee006f7d493c8e5fb97094cef000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","Library":"","LicenseType":"","SwarmSource":"bzzr://c72be876b35ef141e653b144a306fb98f02cc2917735a4c2e95800ac175883e8"}]}