{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract dexBlueEvents{\r\n    // Events\r\n\r\n    /** @notice Emitted when a trade is settled\r\n      * @param  makerAsset  The address of the token the maker gave\r\n      * @param  makerAmount The amount of makerAsset the maker gave\r\n      * @param  takerAsset  The address of the token the taker gave\r\n      * @param  takerAmount The amount of takerAsset the taker gave\r\n      */\r\n    event LogTrade(address makerAsset, uint256 makerAmount, address takerAsset, uint256 takerAmount);\r\n    \r\n    /** @notice Emitted when a simple token swap against a reserve is settled\r\n      * @param  soldAsset    The address of the token the maker gave\r\n      * @param  soldAmount   The amount of makerAsset the maker gave\r\n      * @param  boughtAsset  The address of the token the taker gave\r\n      * @param  boughtAmount The amount of takerAsset the taker gave\r\n      */\r\n    event LogSwap(address soldAsset, uint256 soldAmount, address boughtAsset, uint256 boughtAmount);\r\n\r\n    /** @notice Emitted when a trade settlement failed\r\n      */\r\n    event LogTradeFailed();\r\n\r\n    /** @notice Emitted after a successful deposit of ETH or token\r\n      * @param  account  The address, which deposited the asset\r\n      * @param  token    The address of the deposited token (ETH is address(0))\r\n      * @param  amount   The amount deposited in this transaction \r\n      */\r\n    event LogDeposit(address account, address token, uint256 amount);\r\n\r\n    /** @notice Emitted after a successful multi-sig withdrawal of deposited ETH or token\r\n      * @param  account  The address, which initiated the withdrawal\r\n      * @param  token    The address of the token which is withdrawn (ETH is address(0))\r\n      * @param  amount   The amount withdrawn in this transaction \r\n      */\r\n    event LogWithdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice Emitted after a successful direct withdrawal of deposited ETH or token\r\n      * @param  account  The address, which initiated the withdrawal\r\n      * @param  token    The address of the token which is withdrawn (ETH is address(0))\r\n      * @param  amount   The amount withdrawn in this transaction \r\n      */\r\n    event LogDirectWithdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice Emitted after a user successfully blocked tokens or ETH for a single signature withdrawal\r\n      * @param  account  The address controlling the tokens\r\n      * @param  token    The address of the token which is blocked (ETH is address(0))\r\n      * @param  amount   The amount blocked in this transaction \r\n      */\r\n    event LogBlockedForSingleSigWithdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice Emitted after a successful single-sig withdrawal of deposited ETH or token\r\n      * @param  account  The address, which initiated the withdrawal\r\n      * @param  token    The address of the token which is withdrawn (ETH is address(0))\r\n      * @param  amount   The amount withdrawn in this transaction \r\n      */\r\n    event LogSingleSigWithdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice Emitted once an on-chain cancellation of an order was performed\r\n      * @param  hash    The invalidated orders hash \r\n      */\r\n    event LogOrderCanceled(bytes32 hash);\r\n   \r\n    /** @notice Emitted once a address delegation or dedelegation was performed\r\n      * @param  delegator The delegating address,\r\n      * @param  delegate  The delegated address,\r\n      * @param  status    whether the transaction delegated an address (true) or inactivated an active delegation (false) \r\n      */\r\n    event LogDelegateStatus(address delegator, address delegate, bool status);\r\n}\r\n\r\ncontract dexBlueStorage{\r\n    // Storage Variables\r\n\r\n    mapping(address => mapping(address => uint256)) balances;                           // Users balances (token address > user address > balance amount) (ETH is address(0))\r\n    mapping(address => mapping(address => uint256)) blocked_for_single_sig_withdrawal;  // Users balances, blocked to withdraw without arbiters multi-sig (token address > user address > blocked amount) (ETH is address(0))\r\n    mapping(address => uint256) last_blocked_timestamp;                                 // The last timestamp a user blocked tokens at, to withdraw with single-sig\r\n    \r\n    mapping(bytes32 => bool) processed_withdrawals;                                     // Processed withdrawal hashes\r\n    mapping(bytes32 => uint256) matched;                                                // Orders matched sell amounts to prevent multiple-/over- matches of the same orders\r\n    \r\n    mapping(address => address) delegates;                                              // Registered Delegated Signing Key addresses\r\n    \r\n    mapping(uint256 => address) tokens;                                                 // Cached token index > address mapping\r\n    mapping(address => uint256) token_indices;                                          // Cached token addresses > index mapping\r\n    address[] token_arr;                                                                // Array of cached token addresses\r\n    \r\n    mapping(uint256 => address payable) reserves;                                       // Reserve index > reserve address mapping\r\n    mapping(address => uint256) reserve_indices;                                        // Reserve address > reserve index mapping\r\n    mapping(address => bool) public_reserves;                                           // Reserves publicly accessible through swap() & swapWithReserve()\r\n    address[] public_reserve_arr;                                                       // Array of the publicly accessible reserves\r\n\r\n    address payable owner;                      // Contract owner address (has the right to nominate arbiters and feeCollector addresses)   \r\n    mapping(address => bool) arbiters;          // Mapping of arbiters\r\n    bool marketActive = true;                   // Make it possible to pause the market\r\n    address payable feeCollector;               // feeCollector address\r\n    bool feeCollectorLocked = false;            // Make it possible to lock the feeCollector address (to allow to change the feeCollector to a fee distribution contract)\r\n    uint256 single_sig_waiting_period = 86400;  // waiting period for single sig withdrawas, default (and max) is one day\r\n}\r\n\r\ncontract dexBlueUtils is dexBlueStorage{\r\n    /** @notice Get the balance of a user for a specific token\r\n      * @param  token  The token address (ETH is address(0))\r\n      * @param  holder The address holding the token\r\n      * @return The amount of the specified token held by the user \r\n      */\r\n    function getBalance(address token, address holder) view public returns(uint256){\r\n        return balances[token][holder];\r\n    }\r\n    \r\n    /** @notice Get index of a cached token address\r\n      * @param  token  The token address (ETH is address(0))\r\n      * @return The index of the token\r\n      */\r\n    function getTokenIndex(address token) view public returns(uint256){\r\n        return token_indices[token];\r\n    }\r\n    \r\n    /** @notice Get a cached token address from an index\r\n      * @param  index  The index of the token\r\n      * @return The address of the token\r\n      */\r\n    function getTokenFromIndex(uint256 index) view public returns(address){\r\n        return tokens[index];\r\n    }\r\n    \r\n    /** @notice Get the array containing all indexed token addresses\r\n      * @return The array of all indexed token addresses\r\n      */\r\n    function getTokens() view public returns(address[] memory){\r\n        return token_arr;\r\n    }\r\n    \r\n    /** @notice Get index of a cached reserve address\r\n      * @param  reserve  The reserve address\r\n      * @return The index of the reserve\r\n      */\r\n    function getReserveIndex(address reserve) view public returns(uint256){\r\n        return reserve_indices[reserve];\r\n    }\r\n    \r\n    /** @notice Get a cached reserve address from an index\r\n      * @param  index  The index of the reserve\r\n      * @return The address of the reserve\r\n      */\r\n    function getReserveFromIndex(uint256 index) view public returns(address){\r\n        return reserves[index];\r\n    }\r\n    \r\n    /** @notice Get the array containing all publicly available reserve addresses\r\n      * @return The array of addresses of all publicly available reserves\r\n      */\r\n    function getReserves() view public returns(address[] memory){\r\n        return public_reserve_arr;\r\n    }\r\n    \r\n    /** @notice Get the balance a user blocked for a single-signature withdrawal (ETH is address(0))\r\n      * @param  token  The token address (ETH is address(0))\r\n      * @param  holder The address holding the token\r\n      * @return The amount of the specified token blocked by the user \r\n      */\r\n    function getBlocked(address token, address holder) view public returns(uint256){\r\n        return blocked_for_single_sig_withdrawal[token][holder];\r\n    }\r\n    \r\n    /** @notice Returns the timestamp of the last blocked balance\r\n      * @param  user  Address of the user which blocked funds\r\n      * @return The last unix timestamp the user blocked funds at, which starts the waiting period for single-sig withdrawals \r\n      */\r\n    function getLastBlockedTimestamp(address user) view public returns(uint256){\r\n        return last_blocked_timestamp[user];\r\n    }\r\n    \r\n    /** @notice We have to check returndatasize after ERC20 tokens transfers, as some tokens are implemented badly (dont return a boolean)\r\n      * @return Whether the last ERC20 transfer failed or succeeded\r\n      */\r\n    function checkERC20TransferSuccess() pure internal returns(bool){\r\n        uint256 success = 0;\r\n\r\n        assembly {\r\n            switch returndatasize               // Check the number of bytes the token contract returned\r\n                case 0 {                        // Nothing returned, but contract did not throw > assume our transfer succeeded\r\n                    success := 1\r\n                }\r\n                case 32 {                       // 32 bytes returned, result is the returned bool\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n        }\r\n\r\n        return success != 0;\r\n    }\r\n}\r\n\r\ncontract dexBlueStructs is dexBlueStorage{\r\n\r\n    // EIP712 Domain\r\n    struct EIP712_Domain {\r\n        string  name;\r\n        string  version;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n    bytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n    bytes32          EIP712_DOMAIN_SEPARATOR;\r\n    // Order typehash\r\n    bytes32 constant EIP712_ORDER_TYPEHASH = keccak256(\"Order(address sellTokenAddress,uint128 sellTokenAmount,address buyTokenAddress,uint128 buyTokenAmount,uint32 expiry,uint64 nonce)\");\r\n    // Withdrawal typehash\r\n    bytes32 constant EIP712_WITHDRAWAL_TYPEHASH = keccak256(\"Withdrawal(address token,uint256 amount,uint64 nonce)\");\r\n\r\n    \r\n    struct Order{\r\n        address     sellToken;     // The token, the order signee wants to sell\r\n        uint256     sellAmount;    // The total amount the signee wants to give for the amount he wants to buy (the orders \"rate\" is implied by the ratio between the two amounts)\r\n        address     buyToken;      // The token, the order signee wants to buy\r\n        uint256     buyAmount;     // The total amount the signee wants to buy\r\n        uint256     expiry;        // The expiry time of the order (after which it is not longer valid)\r\n        bytes32     hash;          // The orders hash\r\n        address     signee;        // The orders signee\r\n    }\r\n\r\n    struct OrderInputPacked{\r\n        /*\r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0 - 15    | sell amount\r\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff | 16 - 31    | buy amount\r\n        */  \r\n        bytes32     packedInput1;\r\n        /*\r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffff000000000000000000000000000000000000000000000000000000000000 |  0 -  1    | sell token identifier\r\n            0x0000ffff00000000000000000000000000000000000000000000000000000000 |  2 -  3    | buy token identifier\r\n            0x00000000ffffffff000000000000000000000000000000000000000000000000 |  4 -  7    | expiry\r\n            0x0000000000000000ffffffffffffffff00000000000000000000000000000000 |  8 - 15    | nonce\r\n            0x00000000000000000000000000000000ff000000000000000000000000000000 | 16 - 16    | v\r\n            0x0000000000000000000000000000000000ff0000000000000000000000000000 | 17 - 17    | signing scheme 0x00 = personal.sign, 0x01 = EIP712\r\n            0x000000000000000000000000000000000000ff00000000000000000000000000 | 18 - 18    | signed by delegate\r\n        */\r\n        bytes32     packedInput2;\r\n        \r\n        bytes32     r;                          // Signature r\r\n        bytes32     s;                          // Signature s\r\n    }\r\n    \r\n    /** @notice Helper function parse an Order struct from an OrderInputPacked struct\r\n      * @param   orderInput  The OrderInputPacked struct to parse\r\n      * @return The parsed Order struct\r\n      */\r\n    function orderFromInput(OrderInputPacked memory orderInput) view public returns(Order memory){\r\n        // Parse packed input\r\n        Order memory order = Order({\r\n            sellToken  : tokens[uint256(orderInput.packedInput2 >> 240)],\r\n            sellAmount : uint256(orderInput.packedInput1 >> 128),\r\n            buyToken   : tokens[uint256((orderInput.packedInput2 & 0x0000ffff00000000000000000000000000000000000000000000000000000000) >> 224)],\r\n            buyAmount  : uint256(orderInput.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n            expiry     : uint256((orderInput.packedInput2 & 0x00000000ffffffff000000000000000000000000000000000000000000000000) >> 192), \r\n            hash       : 0x0,\r\n            signee     : address(0x0)\r\n        });\r\n        \r\n        // Restore order hash\r\n        if(\r\n            orderInput.packedInput2[17] == byte(0x00)   // Signing scheme\r\n        ){                                              // Order is hashed after signature scheme personal.sign()\r\n            order.hash = keccak256(abi.encodePacked(    // Restore the hash of this order\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                keccak256(abi.encodePacked(\r\n                    order.sellToken,\r\n                    uint128(order.sellAmount),\r\n                    order.buyToken,\r\n                    uint128(order.buyAmount),\r\n                    uint32(order.expiry), \r\n                    uint64(uint256((orderInput.packedInput2 & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000) >> 128)), // nonce     \r\n                    address(this)                       // This contract's address\r\n                ))\r\n            ));\r\n        }else{                                          // Order is hashed after EIP712\r\n            order.hash = keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                EIP712_DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(\r\n                    EIP712_ORDER_TYPEHASH,\r\n                    order.sellToken,\r\n                    order.sellAmount,\r\n                    order.buyToken,\r\n                    order.buyAmount,\r\n                    order.expiry, \r\n                    uint256((orderInput.packedInput2 & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000) >> 128) // nonce   \r\n                ))\r\n            ));\r\n        }\r\n        \r\n        // Restore the signee of this order\r\n        order.signee = ecrecover(\r\n            order.hash,                             // Order hash\r\n            uint8(orderInput.packedInput2[16]),     // Signature v\r\n            orderInput.r,                           // Signature r\r\n            orderInput.s                            // Signature s\r\n        );\r\n        \r\n        // When the signature was delegated restore delegating address\r\n        if(\r\n            orderInput.packedInput2[18] == byte(0x01)  // Is delegated\r\n        ){\r\n            order.signee = delegates[order.signee];\r\n        }\r\n        \r\n        return order;\r\n    }\r\n    \r\n    struct Trade{\r\n        uint256 makerAmount;\r\n        uint256 takerAmount; \r\n        uint256 makerFee; \r\n        uint256 takerFee;\r\n        uint256 makerRebate;\r\n    }\r\n    \r\n    struct ReserveReserveTrade{\r\n        address makerToken;\r\n        address takerToken; \r\n        uint256 makerAmount;\r\n        uint256 takerAmount; \r\n        uint256 makerFee; \r\n        uint256 takerFee;\r\n        uint256 gasLimit;\r\n    }\r\n    \r\n    struct ReserveTrade{\r\n        uint256 orderAmount;\r\n        uint256 reserveAmount; \r\n        uint256 orderFee; \r\n        uint256 reserveFee;\r\n        uint256 orderRebate;\r\n        uint256 reserveRebate;\r\n        bool    orderIsMaker;\r\n        uint256 gasLimit;\r\n    }\r\n    \r\n    struct TradeInputPacked{\r\n        /* \r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0 - 15    | maker amount\r\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff | 16 - 31    | taker amount\r\n        */\r\n        bytes32     packedInput1;  \r\n        /*\r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0-15      | maker fee\r\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff | 16-31      | taker fee\r\n        */\r\n        bytes32     packedInput2; \r\n        /*\r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0 - 15    | maker rebate           (optional)\r\n            0x00000000000000000000000000000000ff000000000000000000000000000000 | 16 - 16    | counterparty types:\r\n                                                                               |            |   0x11 : maker=order,   taker=order, \r\n                                                                               |            |   0x10 : maker=order,   taker=reserve, \r\n                                                                               |            |   0x01 : maker=reserve, taker=order\r\n                                                                               |            |   0x00 : maker=reserve, taker=reserve\r\n            0x0000000000000000000000000000000000ffff00000000000000000000000000 | 17 - 18    | maker_identifier\r\n            0x00000000000000000000000000000000000000ffff0000000000000000000000 | 19 - 20    | taker_identifier\r\n            0x000000000000000000000000000000000000000000ffff000000000000000000 | 21 - 22    | maker_token_identifier (optional)\r\n            0x0000000000000000000000000000000000000000000000ffff00000000000000 | 23 - 24    | taker_token_identifier (optional)\r\n            0x00000000000000000000000000000000000000000000000000ffffff00000000 | 25 - 27    | gas_limit              (optional)\r\n            0x00000000000000000000000000000000000000000000000000000000ff000000 | 28 - 28    | burn_gas_tokens        (optional)\r\n        */\r\n        bytes32     packedInput3; \r\n    }\r\n\r\n    /** @notice Helper function parse an Trade struct from an TradeInputPacked struct\r\n      * @param  packed      The TradeInputPacked struct to parse\r\n      * @return The parsed Trade struct\r\n      */\r\n    function tradeFromInput(TradeInputPacked memory packed) public pure returns (Trade memory){\r\n        return Trade({\r\n            makerAmount : uint256(packed.packedInput1 >> 128),\r\n            takerAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n            makerFee    : uint256(packed.packedInput2 >> 128),\r\n            takerFee    : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n            makerRebate : uint256(packed.packedInput3 >> 128)\r\n        });\r\n    }\r\n    \r\n    /** @notice Helper function parse an ReserveTrade struct from an TradeInputPacked struct\r\n      * @param  packed      The TradeInputPacked struct to parse\r\n      * @return The parsed ReserveTrade struct\r\n      */\r\n    function reserveTradeFromInput(TradeInputPacked memory packed) public pure returns (ReserveTrade memory){\r\n        if(packed.packedInput3[16] == byte(0x10)){\r\n            // maker is order, taker is reserve\r\n            return ReserveTrade({\r\n                orderAmount   : uint256( packed.packedInput1 >> 128),\r\n                reserveAmount : uint256( packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n                orderFee      : uint256( packed.packedInput2 >> 128),\r\n                reserveFee    : uint256( packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n                orderRebate   : uint256((packed.packedInput3 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128),\r\n                reserveRebate : 0,\r\n                orderIsMaker  : true,\r\n                gasLimit      : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\r\n            });\r\n        }else{\r\n            // taker is order, maker is reserve\r\n            return ReserveTrade({\r\n                orderAmount   : uint256( packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n                reserveAmount : uint256( packed.packedInput1 >> 128),\r\n                orderFee      : uint256( packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n                reserveFee    : uint256( packed.packedInput2 >> 128),\r\n                orderRebate   : 0,\r\n                reserveRebate : uint256((packed.packedInput3 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128),\r\n                orderIsMaker  : false,\r\n                gasLimit      : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\r\n            });\r\n        }\r\n    }\r\n\r\n    /** @notice Helper function parse an ReserveReserveTrade struct from an TradeInputPacked struct\r\n      * @param  packed      The TradeInputPacked struct to parse\r\n      * @return The parsed ReserveReserveTrade struct\r\n      */\r\n    function reserveReserveTradeFromInput(TradeInputPacked memory packed) public view returns (ReserveReserveTrade memory){\r\n        return ReserveReserveTrade({\r\n            makerToken    : tokens[uint256((packed.packedInput3 & 0x000000000000000000000000000000000000000000ffff000000000000000000) >> 72)],\r\n            takerToken    : tokens[uint256((packed.packedInput3 & 0x0000000000000000000000000000000000000000000000ffff00000000000000) >> 56)],\r\n            makerAmount   : uint256( packed.packedInput1 >> 128),\r\n            takerAmount   : uint256( packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n            makerFee      : uint256( packed.packedInput2 >> 128),\r\n            takerFee      : uint256( packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n            gasLimit      : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\r\n        });\r\n    }\r\n    \r\n    struct RingTrade {\r\n        bool    isReserve;      // 1 if this trade is from a reserve, 0 when from an order\r\n        uint256 identifier;     // identifier of the reserve or order\r\n        address giveToken;      // the token this trade gives, the receive token is the givetoken of the previous ring element\r\n        uint256 giveAmount;     // the amount of giveToken, this ring element is giving for the amount it reeives from the previous element\r\n        uint256 fee;            // the fee this ring element has to pay on the giveToken giveAmount of the previous ring element\r\n        uint256 rebate;         // the rebate on giveAmount this element receives\r\n        uint256 gasLimit;       // the gas limit for the reserve call (if the element is a reserve)\r\n    }\r\n\r\n    struct RingTradeInputPacked{\r\n        /* \r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0 - 15    | give amount\r\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff | 16 - 31    | fee\r\n        */\r\n        bytes32     packedInput1;    \r\n        /* \r\n            BITMASK                                                            | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0 - 15    | rebate\r\n            0x00000000000000000000000000000000ff000000000000000000000000000000 | 16 - 16    | is reserve\r\n            0x0000000000000000000000000000000000ffff00000000000000000000000000 | 17 - 18    | identifier\r\n            0x00000000000000000000000000000000000000ffff0000000000000000000000 | 19 - 20    | giveToken identifier\r\n            0x000000000000000000000000000000000000000000ffffff0000000000000000 | 21 - 23    | gas_limit\r\n            0x000000000000000000000000000000000000000000000000ff00000000000000 | 24 - 24    | burn_gas_tokens\r\n        */\r\n        bytes32     packedInput2;   \r\n    }\r\n    \r\n    /** @notice Helper function parse an RingTrade struct from an RingTradeInputPacked struct\r\n      * @param  packed  The RingTradeInputPacked struct to parse\r\n      * @return The parsed RingTrade struct\r\n      */\r\n    function ringTradeFromInput(RingTradeInputPacked memory packed) view public returns(RingTrade memory){\r\n        return RingTrade({\r\n            isReserve     : (packed.packedInput2[16] == bytes1(0x01)),\r\n            identifier    : uint256((       packed.packedInput2 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104),\r\n            giveToken     : tokens[uint256((packed.packedInput2 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)],\r\n            giveAmount    : uint256(        packed.packedInput1                                                                       >> 128),\r\n            fee           : uint256(        packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\r\n            rebate        : uint256(        packed.packedInput2                                                                       >> 128),\r\n            gasLimit      : uint256((       packed.packedInput2 & 0x000000000000000000000000000000000000000000ffffff0000000000000000) >> 64)\r\n        });\r\n    }\r\n}\r\n\r\ncontract dexBlueSettlementModule is dexBlueStorage, dexBlueEvents, dexBlueUtils, dexBlueStructs{\r\n    \r\n    /** @notice Internal helper function to settle a trade between two orders\r\n      * @param  makerOrder  The maker order\r\n      * @param  takerOrder  The taker order\r\n      * @param  trade       The trade to settle between the two\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function matchOrders(\r\n        Order memory makerOrder,\r\n        Order memory takerOrder,\r\n        Trade memory trade\r\n    ) internal returns (bool){\r\n        // Load the orders previously matched amounts into memory\r\n        uint makerOrderMatched = matched[makerOrder.hash];\r\n        uint takerOrderMatched = matched[takerOrder.hash];\r\n\r\n        if( // Check if the arbiter has matched following the conditions of the two order signees\r\n            // Do maker and taker want to trade the same tokens with each other\r\n               makerOrder.buyToken == takerOrder.sellToken\r\n            && takerOrder.buyToken == makerOrder.sellToken\r\n            \r\n            // Are both of the orders still valid\r\n            && makerOrder.expiry > block.timestamp\r\n            && takerOrder.expiry > block.timestamp \r\n            \r\n            // Do maker and taker hold the required balances\r\n            && balances[makerOrder.sellToken][makerOrder.signee] >= trade.makerAmount - trade.makerRebate\r\n            && balances[takerOrder.sellToken][takerOrder.signee] >= trade.takerAmount\r\n            \r\n            // Are they both matched at a rate better or equal to the one they signed\r\n            && trade.makerAmount - trade.makerRebate <= makerOrder.sellAmount * trade.takerAmount / makerOrder.buyAmount + 1  // Check maker doesn't overpay (+ 1 to deal with rouding errors for very smal amounts)\r\n            && trade.takerAmount                     <= takerOrder.sellAmount * trade.makerAmount / takerOrder.buyAmount + 1  // Check taker doesn't overpay (+ 1 to deal with rouding errors for very smal amounts)\r\n            \r\n            // Check if the order was cancelled\r\n            && makerOrder.sellAmount > makerOrderMatched\r\n            && takerOrder.sellAmount > takerOrderMatched\r\n\r\n            // Check if the matched amount + previously matched trades doesn't exceed the amount specified by the order signee\r\n            && trade.makerAmount - trade.makerRebate + makerOrderMatched <= makerOrder.sellAmount\r\n            && trade.takerAmount                     + takerOrderMatched <= takerOrder.sellAmount\r\n                \r\n            // Check if the charged fee is not too high\r\n            && trade.makerFee <= trade.takerAmount / 20\r\n            && trade.takerFee <= trade.makerAmount / 20\r\n            \r\n            // Check if maker_rebate is smaller than or equal to the taker's fee which compensates it\r\n            && trade.makerRebate <= trade.takerFee\r\n        ){\r\n            // Settle the trade:\r\n            \r\n            // Substract sold amounts\r\n            balances[makerOrder.sellToken][makerOrder.signee] -= trade.makerAmount - trade.makerRebate;     // Substract maker's sold amount minus the makers rebate\r\n            balances[takerOrder.sellToken][takerOrder.signee] -= trade.takerAmount;                         // Substract taker's sold amount\r\n            \r\n            // Add bought amounts\r\n            balances[makerOrder.buyToken][makerOrder.signee] += trade.takerAmount - trade.makerFee;         // Give the maker his bought amount minus the fee\r\n            balances[takerOrder.buyToken][takerOrder.signee] += trade.makerAmount - trade.takerFee;         // Give the taker his bought amount minus the fee\r\n            \r\n            // Save sold amounts to prevent double matching\r\n            matched[makerOrder.hash] += trade.makerAmount - trade.makerRebate;                              // Prevent maker order from being reused\r\n            matched[takerOrder.hash] += trade.takerAmount;                                                  // Prevent taker order from being reused\r\n            \r\n            // Give fee to feeCollector\r\n            balances[takerOrder.buyToken][feeCollector] += trade.takerFee - trade.makerRebate;              // Give the feeColletor the taker fee minus the maker rebate \r\n            balances[makerOrder.buyToken][feeCollector] += trade.makerFee;                                  // Give the feeColletor the maker fee\r\n            \r\n            // Set potential previous blocking of these funds to 0\r\n            blocked_for_single_sig_withdrawal[makerOrder.sellToken][makerOrder.signee] = 0;                 // If the maker tried to block funds which he/she used in this order we have to unblock them\r\n            blocked_for_single_sig_withdrawal[takerOrder.sellToken][takerOrder.signee] = 0;                 // If the taker tried to block funds which he/she used in this order we have to unblock them\r\n            \r\n            emit LogTrade(makerOrder.sellToken, trade.makerAmount, takerOrder.sellToken, trade.takerAmount);\r\n\r\n            return true;                                                                         \r\n        }else{\r\n            return false;                                                                                   \r\n        }\r\n    }\r\n\r\n    /** @notice Internal helper function to settle a trade between an order and a reserve\r\n      * @param  order    The order\r\n      * @param  reserve  The reserve\r\n      * @param  trade    The trade to settle between the two\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function matchOrderWithReserve(\r\n        Order memory order,\r\n        address      reserve,\r\n        ReserveTrade memory trade\r\n    ) internal returns(bool){\r\n        // Load the orders previously matched amount into memory\r\n        uint orderMatched = matched[order.hash];\r\n\r\n        if( // Check if the arbiter matched the conditions of the order signee\r\n            // Does the order signee has the required balances deposited\r\n            balances[order.sellToken][order.signee] >= trade.orderAmount - trade.orderRebate\r\n            \r\n            // Is the order still valid\r\n            && order.expiry > block.timestamp \r\n            \r\n            // Is the order matched at a rate better or equal to the one specified by the signee\r\n            && trade.orderAmount - trade.orderRebate <= order.sellAmount * trade.reserveAmount / order.buyAmount + 1  // + 1 to deal with rouding errors\r\n            \r\n            // Check if the order was cancelled\r\n            && order.sellAmount > orderMatched\r\n\r\n            // Check if the matched amount + previously matched trades doesn't exceed the amount specified by the order signee\r\n            && trade.orderAmount - trade.orderRebate + orderMatched <= order.sellAmount\r\n                \r\n            // Check if the charged fee is not too high\r\n            && trade.orderFee   <= trade.reserveAmount / 20\r\n            && trade.reserveFee <= trade.orderAmount   / 20\r\n            \r\n            // Check if the rebates can be compensated by the fees\r\n            && trade.orderRebate   <= trade.reserveFee\r\n            && trade.reserveRebate <= trade.orderFee\r\n        ){\r\n            balances[order.sellToken][order.signee] -= trade.orderAmount - trade.orderRebate;  // Substract users's sold amount minus the makers rebate\r\n            \r\n            (bool txSuccess, bytes memory returnData) = address(this).call.gas(\r\n                    trade.gasLimit                                              // The gas limit for the call\r\n                )(\r\n                    abi.encodePacked(                                           // This encodes the function to call and the parameters we are passing to the settlement function\r\n                        dexBlue(address(0)).executeReserveTrade.selector,       // This function executes the call to the reserve\r\n                        abi.encode(                            \r\n                            order.sellToken,                                    // The token the order signee wants to exchange with the reserve\r\n                            trade.orderAmount   - trade.reserveFee,             // The reserve receives the sold amount minus the fee\r\n                            order.buyToken,                                     // The token the order signee wants to receive from the reserve\r\n                            trade.reserveAmount - trade.reserveRebate,          // The reserve has to return the amount the order want to receive minus\r\n                            reserve                                             // The reserve the trade is settled with\r\n                        )\r\n                    )\r\n                );\r\n            \r\n            if(\r\n               txSuccess                                    // The call to the reserve did not fail\r\n               && abi.decode(returnData, (bool))            // The call returned true (we are sure its a contract we called)\r\n               // executeReserveTrade checks whether the reserve deposited the funds\r\n            ){\r\n                // Substract the deposited amount from reserves balance\r\n                balances[order.buyToken][reserve]      -= trade.reserveAmount - trade.reserveRebate;    // Substract reserves's sold amount\r\n                \r\n                // The amount to the order signees balance\r\n                balances[order.buyToken][order.signee] += trade.reserveAmount - trade.orderFee;         // Give the users his bought amount minus the fee\r\n                \r\n                // Save sold amounts to prevent double matching\r\n                matched[order.hash] += trade.orderAmount - trade.orderRebate;                           // Prevent maker order from being reused\r\n                \r\n                // Give fee to feeCollector\r\n                balances[order.buyToken][feeCollector]  += trade.orderFee   - trade.reserveRebate;      // Give the feeColletor the fee minus the maker rebate\r\n                balances[order.sellToken][feeCollector] += trade.reserveFee - trade.orderRebate;        // Give the feeColletor the fee minus the maker rebate\r\n                \r\n                // Set potential previous blocking of these funds to 0\r\n                blocked_for_single_sig_withdrawal[order.sellToken][order.signee] = 0;                   // If the user blocked funds which he/she used in this order we have to unblock them\r\n\r\n                if(trade.orderIsMaker){\r\n                    emit LogTrade(order.sellToken, trade.orderAmount, order.buyToken, trade.reserveAmount);\r\n                }else{\r\n                    emit LogTrade(order.buyToken, trade.reserveAmount, order.sellToken, trade.orderAmount);\r\n                }\r\n                emit LogDirectWithdrawal(reserve, order.sellToken, trade.orderAmount - trade.reserveFee);\r\n                \r\n                return true;\r\n            }else{\r\n                balances[order.sellToken][order.signee] += trade.orderAmount - trade.orderRebate;  // Refund substracted amount\r\n                \r\n                return false;\r\n            }\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /** @notice Internal helper function to settle a trade between an order and a reserve, passing some additional data to the reserve\r\n      * @param  order    The order\r\n      * @param  reserve  The reserve\r\n      * @param  trade    The trade to settle between the two\r\n      * @param  data     The data to pass along to the reserve\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function matchOrderWithReserveWithData(\r\n        Order        memory order,\r\n        address      reserve,\r\n        ReserveTrade memory trade,\r\n        bytes32[]    memory data\r\n    ) internal returns(bool){\r\n        // Load the orders previously matched amount into memory\r\n        uint orderMatched = matched[order.hash];\r\n\r\n        if( // Check if the arbiter matched the conditions of the order signee\r\n            // Does the order signee has the required balances deposited\r\n            balances[order.sellToken][order.signee] >= trade.orderAmount - trade.orderRebate\r\n            \r\n            // Is the order still valid\r\n            && order.expiry > block.timestamp \r\n            \r\n            // Is the order matched at a rate better or equal to the one specified by the signee\r\n            && trade.orderAmount - trade.orderRebate <= order.sellAmount * trade.reserveAmount / order.buyAmount + 1  // + 1 to deal with rouding errors\r\n            \r\n            // Check if the order was cancelled\r\n            && order.sellAmount > orderMatched\r\n\r\n            // Check if the matched amount + previously matched trades doesn't exceed the amount specified by the order signee\r\n            && trade.orderAmount - trade.orderRebate + orderMatched <= order.sellAmount\r\n                \r\n            // Check if the charged fee is not too high\r\n            && trade.orderFee   <= trade.reserveAmount / 20\r\n            && trade.reserveFee <= trade.orderAmount   / 20\r\n            \r\n            // Check if the rebates can be compensated by the fees\r\n            && trade.orderRebate   <= trade.reserveFee\r\n            && trade.reserveRebate <= trade.orderFee\r\n        ){\r\n            balances[order.sellToken][order.signee] -= trade.orderAmount - trade.orderRebate;  // Substract users's sold amount minus the makers rebate\r\n            \r\n            (bool txSuccess, bytes memory returnData) = address(this).call.gas(\r\n                    trade.gasLimit                                                  // The gas limit for the call\r\n                )(\r\n                    abi.encodePacked(                                               // This encodes the function to call and the parameters we are passing to the settlement function\r\n                        dexBlue(address(0)).executeReserveTradeWithData.selector,   // This function executes the call to the reserve\r\n                        abi.encode(                            \r\n                            order.sellToken,                                        // The token the order signee wants to exchange with the reserve\r\n                            trade.orderAmount   - trade.reserveFee,                 // The reserve receives the sold amount minus the fee\r\n                            order.buyToken,                                         // The token the order signee wants to receive from the reserve\r\n                            trade.reserveAmount - trade.reserveRebate,              // The reserve has to return the amount the order want to receive minus\r\n                            reserve,                                                // The reserve the trade is settled with\r\n                            data                                                    // The data passed on to the reserve\r\n                        )\r\n                    )\r\n                );\r\n            \r\n            if(\r\n               txSuccess                                    // The call to the reserve did not fail\r\n               && abi.decode(returnData, (bool))            // The call returned true (we are sure its a contract we called)\r\n               // executeReserveTrade checks whether the reserve deposited the funds\r\n            ){\r\n                // substract the deposited amount from reserves balance\r\n                balances[order.buyToken][reserve]      -= trade.reserveAmount - trade.reserveRebate;    // Substract reserves's sold amount\r\n                \r\n                // the amount to the order signees balance\r\n                balances[order.buyToken][order.signee] += trade.reserveAmount - trade.orderFee;         // Give the users his bought amount minus the fee\r\n                \r\n                // Save sold amounts to prevent double matching\r\n                matched[order.hash] += trade.orderAmount - trade.orderRebate;                           // Prevent maker order from being reused\r\n                \r\n                // Give fee to feeCollector\r\n                balances[order.buyToken][feeCollector]  += trade.orderFee   - trade.reserveRebate;      // Give the feeColletor the fee minus the maker rebate\r\n                balances[order.sellToken][feeCollector] += trade.reserveFee - trade.orderRebate;        // Give the feeColletor the fee minus the maker rebate\r\n                \r\n                // Set potential previous blocking of these funds to 0\r\n                blocked_for_single_sig_withdrawal[order.sellToken][order.signee] = 0;                   // If the user blocked funds which he/she used in this order we have to unblock them\r\n\r\n                if(trade.orderIsMaker){\r\n                    emit LogTrade(order.sellToken, trade.orderAmount, order.buyToken, trade.reserveAmount);\r\n                }else{\r\n                    emit LogTrade(order.buyToken, trade.reserveAmount, order.sellToken, trade.orderAmount);\r\n                }\r\n                emit LogDirectWithdrawal(reserve, order.sellToken, trade.orderAmount - trade.reserveFee);\r\n                \r\n                return true;\r\n            }else{\r\n                balances[order.sellToken][order.signee] += trade.orderAmount - trade.orderRebate;  // Refund substracted amount\r\n                \r\n                return false;\r\n            }\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /** @notice internal helper function to settle a trade between two reserves\r\n      * @param  makerReserve  The maker reserve\r\n      * @param  takerReserve  The taker reserve\r\n      * @param  trade         The trade to settle between the two\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function matchReserveWithReserve(\r\n        address             makerReserve,\r\n        address             takerReserve,\r\n        ReserveReserveTrade memory trade\r\n    ) internal returns(bool){\r\n\r\n        (bool txSuccess, bytes memory returnData) = address(this).call.gas(\r\n            trade.gasLimit                                                      // The gas limit for the call\r\n        )(\r\n            abi.encodePacked(                                                   // This encodes the function to call and the parameters we are passing to the settlement function\r\n                dexBlue(address(0)).executeReserveReserveTrade.selector,     // This function executes the call to the reserves\r\n                abi.encode(                            \r\n                    makerReserve,\r\n                    takerReserve,\r\n                    trade\r\n                )\r\n            )\r\n        );\r\n\r\n        return (\r\n            txSuccess                                    // The call to the reserve did not fail\r\n            && abi.decode(returnData, (bool))            // The call returned true (we are sure its a contract we called)\r\n        );\r\n    }\r\n\r\n    \r\n    /** @notice internal helper function to settle a trade between two reserves\r\n      * @param  makerReserve  The maker reserve\r\n      * @param  takerReserve  The taker reserve\r\n      * @param  trade         The trade to settle between the two\r\n      * @param  makerData     The data to pass on to the maker reserve\r\n      * @param  takerData     The data to pass on to the taker reserve\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function matchReserveWithReserveWithData(\r\n        address             makerReserve,\r\n        address             takerReserve,\r\n        ReserveReserveTrade memory trade,\r\n        bytes32[] memory    makerData,\r\n        bytes32[] memory    takerData\r\n    ) internal returns(bool){\r\n\r\n        (bool txSuccess, bytes memory returnData) = address(this).call.gas(\r\n            trade.gasLimit                                                       // The gas limit for the call\r\n        )(\r\n            abi.encodePacked(                                                    // This encodes the function to call and the parameters we are passing to the settlement function\r\n                dexBlue(address(0)).executeReserveReserveTradeWithData.selector, // This function executes the call to the reserves\r\n                abi.encode(                            \r\n                    makerReserve,\r\n                    takerReserve,\r\n                    trade,\r\n                    makerData,\r\n                    takerData\r\n                )\r\n            )\r\n        );\r\n\r\n        return (\r\n            txSuccess                                    // The call to the reserve did not fail\r\n            && abi.decode(returnData, (bool))            // The call returned true (we are sure its a contract we called)\r\n        );\r\n    }\r\n    \r\n    /** @notice Allows an arbiter to settle multiple trades between multiple orders and reserves\r\n      * @param  orderInput     Array of all orders involved in the transactions\r\n      * @param  tradeInput     Array of the trades to be settled\r\n      */   \r\n    function batchSettleTrades(OrderInputPacked[] calldata orderInput, TradeInputPacked[] calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        Order[] memory orders = new Order[](orderInput.length);\r\n        uint256 i = orderInput.length;\r\n\r\n        while(i-- != 0){                                // Loop through the orderInput array, to parse the infos and restore all signees\r\n            orders[i] = orderFromInput(orderInput[i]);  // Parse this orders infos\r\n        }\r\n        \r\n        uint256 makerIdentifier;\r\n        uint256 takerIdentifier;\r\n        \r\n        for(i = 0; i < tradeInput.length; i++){\r\n            makerIdentifier = uint256((tradeInput[i].packedInput3 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104);\r\n            takerIdentifier = uint256((tradeInput[i].packedInput3 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88);\r\n            \r\n            if(tradeInput[i].packedInput3[16] == byte(0x11)){       // Both are orders\r\n                if(!matchOrders(\r\n                    orders[makerIdentifier],\r\n                    orders[takerIdentifier],\r\n                    tradeFromInput(tradeInput[i])\r\n                )){\r\n                    emit LogTradeFailed();      \r\n                }\r\n            }else if(tradeInput[i].packedInput3[16] == byte(0x10)){ // Maker is order, taker is reserve\r\n                if(!matchOrderWithReserve(\r\n                    orders[makerIdentifier],\r\n                    reserves[takerIdentifier],\r\n                    reserveTradeFromInput(tradeInput[i])\r\n                )){\r\n                    emit LogTradeFailed();      \r\n                }\r\n            }else if(tradeInput[i].packedInput3[16] == byte(0x01)){ // Taker is order, maker is reserve\r\n                if(!matchOrderWithReserve(\r\n                    orders[takerIdentifier],\r\n                    reserves[makerIdentifier],\r\n                    reserveTradeFromInput(tradeInput[i])\r\n                )){\r\n                    emit LogTradeFailed();      \r\n                }\r\n            }else{                                                  // Both are reserves\r\n                if(!matchReserveWithReserve(\r\n                    reserves[makerIdentifier],\r\n                    reserves[takerIdentifier],\r\n                    reserveReserveTradeFromInput(tradeInput[i])\r\n                )){\r\n                    emit LogTradeFailed();      \r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Allows an arbiter to settle a trade between two orders\r\n      * @param  makerOrderInput  The packed maker order input\r\n      * @param  takerOrderInput  The packed taker order input\r\n      * @param  tradeInput       The packed trade to settle between the two\r\n      */ \r\n    function settleTrade(OrderInputPacked calldata makerOrderInput, OrderInputPacked calldata takerOrderInput, TradeInputPacked calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        if(!matchOrders(\r\n            orderFromInput(makerOrderInput),\r\n            orderFromInput(takerOrderInput),\r\n            tradeFromInput(tradeInput)\r\n        )){\r\n            emit LogTradeFailed();      \r\n        }\r\n    }\r\n        \r\n    /** @notice Allows an arbiter to settle a trade between an order and a reserve\r\n      * @param  orderInput  The packed maker order input\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      */ \r\n    function settleReserveTrade(OrderInputPacked calldata orderInput, TradeInputPacked calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        if(!matchOrderWithReserve(\r\n            orderFromInput(orderInput),\r\n            reserves[\r\n                tradeInput.packedInput3[16] == byte(0x01) ? // is maker reserve\r\n                    // maker is reserve\r\n                    uint256((tradeInput.packedInput3 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104) :\r\n                    // taker is reserve\r\n                    uint256((tradeInput.packedInput3 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)\r\n            ],\r\n            reserveTradeFromInput(tradeInput)\r\n        )){\r\n            emit LogTradeFailed();      \r\n        }\r\n    }\r\n\r\n    /** @notice Allows an arbiter to settle a trade between an order and a reserve\r\n      * @param  orderInput  The packed maker order input\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      * @param  data        The data to pass on to the reserve\r\n      */ \r\n    function settleReserveTradeWithData(\r\n        OrderInputPacked calldata orderInput, \r\n        TradeInputPacked calldata tradeInput,\r\n        bytes32[] calldata        data\r\n    ) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        if(!matchOrderWithReserveWithData(\r\n            orderFromInput(orderInput),\r\n            reserves[\r\n                tradeInput.packedInput3[16] == byte(0x01) ? // Is maker reserve\r\n                    // maker is reserve\r\n                    uint256((tradeInput.packedInput3 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104) :\r\n                    // taker is reserve\r\n                    uint256((tradeInput.packedInput3 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)\r\n            ],\r\n            reserveTradeFromInput(tradeInput),\r\n            data\r\n        )){\r\n            emit LogTradeFailed();      \r\n        }\r\n    }\r\n    \r\n    /** @notice Allows an arbiter to settle a trade between two reserves\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      */ \r\n    function settleReserveReserveTrade(\r\n        TradeInputPacked calldata tradeInput\r\n    ) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        if(!matchReserveWithReserve(\r\n            reserves[uint256((tradeInput.packedInput3 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104)],\r\n            reserves[uint256((tradeInput.packedInput3 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)],\r\n            reserveReserveTradeFromInput(tradeInput)\r\n        )){\r\n            emit LogTradeFailed();      \r\n        }\r\n    }\r\n    \r\n    /** @notice Allows an arbiter to settle a trade between two reserves\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      * @param  makerData   The data to pass on to the maker reserve\r\n      * @param  takerData   The data to pass on to the taker reserve\r\n      */ \r\n    function settleReserveReserveTradeWithData(\r\n        TradeInputPacked calldata tradeInput,\r\n        bytes32[] calldata        makerData,\r\n        bytes32[] calldata        takerData\r\n    ) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        if(!matchReserveWithReserveWithData(\r\n            reserves[uint256((tradeInput.packedInput3 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104)],\r\n            reserves[uint256((tradeInput.packedInput3 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)],\r\n            reserveReserveTradeFromInput(tradeInput),\r\n            makerData,\r\n            takerData\r\n        )){\r\n            emit LogTradeFailed();      \r\n        }\r\n    }\r\n    \r\n    /** @notice Allow arbiters to settle a ring of order and reserve trades\r\n      * @param  orderInput Array of OrderInputPacked structs\r\n      * @param  tradeInput Array of RingTradeInputPacked structs\r\n      */\r\n    function settleRingTrade(OrderInputPacked[] calldata orderInput, RingTradeInputPacked[] calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        // Parse Orders from packed input\r\n        uint256 i = orderInput.length;\r\n        Order[] memory orders = new Order[](i);\r\n        while(i-- != 0){\r\n            orders[i] = orderFromInput(orderInput[i]);\r\n        }\r\n        \r\n        // Parse RingTrades from packed input\r\n        i = tradeInput.length;\r\n        RingTrade[] memory trades = new RingTrade[](i);\r\n        while(i-- != 0){\r\n            trades[i] = ringTradeFromInput(tradeInput[i]);\r\n        }\r\n        \r\n        uint256 prev = trades.length - 1;\r\n        uint256 next = 1;\r\n         // Loop through the RingTrades array and settle each participants trade\r\n        for(i = 0; i < trades.length; i++){\r\n            \r\n            require(\r\n                // Check if the charged fee is not too high\r\n                trades[i].fee       <= trades[prev].giveAmount / 20\r\n                \r\n                // Check if maker_rebate is smaller than or equal to the taker's fee which compensates it\r\n                && trades[i].rebate <= trades[next].fee\r\n            );\r\n            \r\n            if(trades[i].isReserve){ // Ring element is a reserve\r\n                address reserve = reserves[trades[i].identifier];\r\n\r\n                if(i == 0){\r\n                    require(\r\n                        dexBlueReserve(reserve).offer(\r\n                            trades[i].giveToken,                                   // The token the reserve would sell\r\n                            trades[i].giveAmount - trades[i].rebate,               // The amount the reserve would sell\r\n                            trades[prev].giveToken,                                // The token the reserve would receive\r\n                            trades[prev].giveAmount - trades[i].fee                // The amount the reserve would receive\r\n                        )\r\n                        && balances[trades[i].giveToken][reserve] >= trades[i].giveAmount\r\n                    );\r\n                }else{\r\n                    uint256 receiveAmount = trades[prev].giveAmount - trades[i].fee;\r\n\r\n                    if(trades[prev].giveToken != address(0)){\r\n                        Token(trades[prev].giveToken).transfer(reserve, receiveAmount);  // Send collateral to reserve\r\n                        require(                                                         // Revert if the send failed\r\n                            checkERC20TransferSuccess(),\r\n                            \"ERC20 token transfer failed.\"\r\n                        );\r\n                    }\r\n\r\n                    require(\r\n                        dexBlueReserve(reserve).trade.value(\r\n                            trades[prev].giveToken == address(0) ? receiveAmount : 0\r\n                        )(             \r\n                            trades[prev].giveToken,\r\n                            receiveAmount,                                      // Reserve gets the reserve_buy_amount minus the fee\r\n                            trades[i].giveToken,    \r\n                            trades[i].giveAmount - trades[i].rebate             // Reserve has to give reserve_sell_amount minus the rebate\r\n                        )\r\n                    );\r\n                }\r\n\r\n                // Substract deposited amount from reserves balance\r\n                balances[trades[i].giveToken][reserve] -= trades[i].giveAmount - trades[i].rebate;\r\n\r\n                emit LogDirectWithdrawal(reserve, trades[prev].giveToken, trades[prev].giveAmount - trades[i].fee);\r\n            }else{ // Ring element is an order\r\n                \r\n                Order memory order = orders[trades[i].identifier];  // Cache order\r\n\r\n                uint256 orderMatched = matched[order.hash];\r\n                \r\n                require(\r\n                    // Does the order signee want to trade the last elements giveToken and this elements giveToken\r\n                       order.buyToken  == trades[prev].giveToken\r\n                    && order.sellToken == trades[i].giveToken\r\n                    \r\n                    // Is the order still valid\r\n                    && order.expiry > block.timestamp\r\n                    \r\n                    // Does the order signee hold the required balances\r\n                    && balances[order.sellToken][order.signee] >= trades[i].giveAmount - trades[i].rebate\r\n                    \r\n                    // Is the order matched at a rate better or equal to the one the order signee signed\r\n                    && trades[i].giveAmount - trades[i].rebate <= order.sellAmount * trades[prev].giveAmount / order.buyAmount + 1  // Check order doesn't overpay (+ 1 to deal with rouding errors for very smal amounts)\r\n                    \r\n                    // Check if the order was cancelled\r\n                    && order.sellAmount > orderMatched\r\n                    \r\n                    // Do the matched amount + previously matched trades not exceed the amount specified by the order signee\r\n                    && trades[i].giveAmount - trades[i].rebate + orderMatched <= order.sellAmount\r\n                );\r\n                \r\n                // Substract the sold amounts\r\n                balances[order.sellToken       ][order.signee] -= trades[i].giveAmount - trades[i].rebate;      // Substract sold amount minus the makers rebate from order signees balance\r\n                \r\n                // Add bought amounts\r\n                balances[trades[prev].giveToken][order.signee] += trades[prev].giveAmount - trades[i].fee;      // Give the order signee his bought amount minus the fee\r\n                \r\n                // Save sold amounts to prevent double matching\r\n                matched[order.hash] += trades[i].giveAmount - trades[i].rebate;                                 // Prevent order from being reused\r\n                \r\n                // Set potential previous blocking of these funds to 0\r\n                blocked_for_single_sig_withdrawal[order.sellToken][order.signee] = 0;                           // If the order signee tried to block funds which he/she used in this order we have to unblock them\r\n            }\r\n\r\n            emit LogTrade(trades[prev].giveToken, trades[prev].giveAmount, trades[i].giveToken, trades[i].giveAmount);\r\n            \r\n            // Give fee to feeCollector\r\n            balances[trades[prev].giveToken][feeCollector] += trades[i].fee - trades[prev].rebate;              // Give the feeColletor the fee minus the maker rebate \r\n            \r\n            prev = i;\r\n            if(i == trades.length - 2){\r\n                next = 0;\r\n            }else{\r\n                next = i + 2;\r\n            }\r\n        }\r\n\r\n        if(trades[0].isReserve){\r\n            address payable reserve = reserves[trades[0].identifier];\r\n            prev = trades.length - 1;\r\n            \r\n            if(trades[prev].giveToken == address(0)){                                                       // Is the withdrawal token ETH\r\n                require(\r\n                    reserve.send(trades[prev].giveAmount - trades[0].fee),                                  // Withdraw ETH\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(trades[prev].giveToken).transfer(reserve, trades[prev].giveAmount - trades[0].fee);   // Withdraw ERC20\r\n                require(                                                                                    // Revert if the withdrawal failed\r\n                    checkERC20TransferSuccess(),\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n\r\n            // Notify the reserve, that the offer got executed\r\n            dexBlueReserve(reserve).offerExecuted(\r\n                trades[0].giveToken,                                   // The token the reserve sold\r\n                trades[0].giveAmount - trades[0].rebate,               // The amount the reserve sold\r\n                trades[prev].giveToken,                                // The token the reserve received\r\n                trades[prev].giveAmount - trades[0].fee                // The amount the reserve received\r\n            );\r\n        }\r\n    }\r\n    \r\n    \r\n    /** @notice Allow arbiters to settle a ring of order and reserve trades, passing on some data to the reserves\r\n      * @param  orderInput Array of OrderInputPacked structs\r\n      * @param  tradeInput Array of RingTradeInputPacked structs\r\n      * @param  data       Array of data to pass along to the reserves\r\n      */\r\n    function settleRingTradeWithData(\r\n        OrderInputPacked[]     calldata orderInput,\r\n        RingTradeInputPacked[] calldata tradeInput,\r\n        bytes32[][]            calldata data\r\n    ) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        // Parse Orders from packed input\r\n        uint256 i = orderInput.length;\r\n        Order[] memory orders = new Order[](i);\r\n        while(i-- != 0){\r\n            orders[i] = orderFromInput(orderInput[i]);\r\n        }\r\n        \r\n        // Parse RingTrades from packed input\r\n        i = tradeInput.length;\r\n        RingTrade[] memory trades = new RingTrade[](i);\r\n        while(i-- != 0){\r\n            trades[i] = ringTradeFromInput(tradeInput[i]);\r\n        }\r\n        \r\n        uint256 prev = trades.length - 1;\r\n        uint256 next = 1;\r\n         // Loop through the RingTrades array and settle each participants trade\r\n        for(i = 0; i < trades.length; i++){\r\n            \r\n            require(\r\n                // Check if the charged fee is not too high\r\n                trades[i].fee       <= trades[prev].giveAmount / 20\r\n                \r\n                // Check if maker_rebate is smaller than or equal to the taker's fee which compensates it\r\n                && trades[i].rebate <= trades[next].fee\r\n            );\r\n            \r\n            if(trades[i].isReserve){ // ring element is a reserve\r\n                address reserve = reserves[trades[i].identifier];\r\n\r\n                if(i == 0){\r\n                    require(\r\n                        dexBlueReserve(reserve).offerWithData(\r\n                            trades[i].giveToken,                                   // The token the reserve would sell\r\n                            trades[i].giveAmount - trades[i].rebate,               // The amount the reserve would sell\r\n                            trades[prev].giveToken,                                // The token the reserve would receive\r\n                            trades[prev].giveAmount - trades[i].fee,               // The amount the reserve would receive\r\n                            data[i]                                                // The data to pass along to the reserve\r\n                        )\r\n                        && balances[trades[i].giveToken][reserve] >= trades[i].giveAmount\r\n                    );\r\n                }else{\r\n                    uint256 receiveAmount = trades[prev].giveAmount - trades[i].fee;\r\n\r\n                    if(trades[prev].giveToken != address(0)){\r\n                        Token(trades[prev].giveToken).transfer(reserve, receiveAmount);  // Send collateral to reserve\r\n                        require(                                                         // Revert if the send failed\r\n                            checkERC20TransferSuccess(),\r\n                            \"ERC20 token transfer failed.\"\r\n                        );\r\n                    }\r\n\r\n                    require(\r\n                        dexBlueReserve(reserve).tradeWithData.value(\r\n                            trades[prev].giveToken == address(0) ? receiveAmount : 0\r\n                        )(             \r\n                            trades[prev].giveToken,\r\n                            receiveAmount,                                      // Reserve gets the reserve_buy_amount minus the fee\r\n                            trades[i].giveToken,    \r\n                            trades[i].giveAmount - trades[i].rebate,            // Reserve has to give reserve_sell_amount minus the reserve rebate\r\n                            data[i]                                             // The data to pass along to the reserve\r\n                        )\r\n                    );\r\n                }\r\n\r\n                // Substract deposited amount from reserves balance\r\n                balances[trades[i].giveToken][reserve] -= trades[i].giveAmount - trades[i].rebate;\r\n\r\n                emit LogDirectWithdrawal(reserve, trades[prev].giveToken, trades[prev].giveAmount - trades[i].fee);\r\n            }else{ // Ring element is an order\r\n                \r\n                Order memory order = orders[trades[i].identifier];  // Cache order\r\n\r\n                uint256 orderMatched = matched[order.hash];\r\n                \r\n                require(\r\n                    // Does the order signee want to trade the last elements giveToken and this elements giveToken\r\n                       order.buyToken  == trades[prev].giveToken\r\n                    && order.sellToken == trades[i].giveToken\r\n                    \r\n                    // Is the order still valid\r\n                    && order.expiry > block.timestamp\r\n                    \r\n                    // Does the order signee hold the required balances\r\n                    && balances[order.sellToken][order.signee] >= trades[i].giveAmount - trades[i].rebate\r\n                    \r\n                    // Is the order matched at a rate better or equal to the one the order signee signed\r\n                    && trades[i].giveAmount - trades[i].rebate <= order.sellAmount * trades[prev].giveAmount / order.buyAmount + 1  // Check order doesn't overpay (+ 1 to deal with rouding errors for very smal amounts)\r\n                    \r\n                    // Check if the order was cancelled\r\n                    && order.sellAmount > orderMatched\r\n                    \r\n                    // Do the matched amount + previously matched trades not exceed the amount specified by the order signee\r\n                    && trades[i].giveAmount - trades[i].rebate + orderMatched <= order.sellAmount\r\n                );\r\n                \r\n                // Substract the sold amounts\r\n                balances[order.sellToken       ][order.signee] -= trades[i].giveAmount - trades[i].rebate;      // Substract sold amount minus the makers rebate from order signees balance\r\n                \r\n                // Add bought amounts\r\n                balances[trades[prev].giveToken][order.signee] += trades[prev].giveAmount - trades[i].fee;      // Give the order signee his bought amount minus the fee\r\n                \r\n                // Save sold amounts to prevent double matching\r\n                matched[order.hash] += trades[i].giveAmount - trades[i].rebate;                                 // Prevent order from being reused\r\n                \r\n                // Set potential previous blocking of these funds to 0\r\n                blocked_for_single_sig_withdrawal[order.sellToken][order.signee] = 0;                           // If the order signee tried to block funds which he/she used in this order we have to unblock them\r\n            }\r\n\r\n            emit LogTrade(trades[prev].giveToken, trades[prev].giveAmount, trades[i].giveToken, trades[i].giveAmount);\r\n            \r\n            // Give fee to feeCollector\r\n            balances[trades[prev].giveToken][feeCollector] += trades[i].fee - trades[prev].rebate;              // Give the feeColletor the fee minus the maker rebate \r\n            \r\n            prev = i;\r\n            if(i == trades.length - 2){\r\n                next = 0;\r\n            }else{\r\n                next = i + 2;\r\n            }\r\n        }\r\n\r\n        if(trades[0].isReserve){\r\n            address payable reserve = reserves[trades[0].identifier];\r\n            prev = trades.length - 1;\r\n            \r\n            if(trades[prev].giveToken == address(0)){                                                       // Is the withdrawal token ETH\r\n                require(\r\n                    reserve.send(trades[prev].giveAmount - trades[0].fee),                                  // Withdraw ETH\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(trades[prev].giveToken).transfer(reserve, trades[prev].giveAmount - trades[0].fee);   // Withdraw ERC20\r\n                require(                                                                                    // Revert if the withdrawal failed\r\n                    checkERC20TransferSuccess(),\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n\r\n            // Notify the reserve, that the offer got executed\r\n            dexBlueReserve(reserve).offerExecuted(\r\n                trades[0].giveToken,                                   // The token the reserve sold\r\n                trades[0].giveAmount - trades[0].rebate,               // The amount the reserve sold\r\n                trades[prev].giveToken,                                // The token the reserve received\r\n                trades[prev].giveAmount - trades[0].fee                // The amount the reserve received\r\n            );\r\n        }\r\n    }\r\n    \r\n    \r\n    // Swapping functions\r\n    \r\n    /** @notice Queries best output for a trade currently available from the reserves\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @return The output amount the reserve with the best price offers\r\n    */\r\n    function getSwapOutput(address sell_token, uint256 sell_amount, address buy_token) public view returns (uint256){\r\n        (, uint256 output) = getBestReserve(sell_token, sell_amount, buy_token);\r\n        return output;\r\n    }\r\n    \r\n    /** @notice Queries the reserve address and output of trade, of the reserve which offers the best deal on a trade\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @return The address of the reserve offering the best deal and the expected output of the trade\r\n    */\r\n    function getBestReserve(address sell_token, uint256 sell_amount, address buy_token) public view returns (address, uint256){\r\n        address bestReserve;\r\n        uint256 bestOutput = 0;\r\n        uint256 output;\r\n        \r\n        for(uint256 i = 0; i < public_reserve_arr.length; i++){\r\n            output = dexBlueReserve(public_reserve_arr[i]).getSwapOutput(sell_token, sell_amount, buy_token);\r\n            if(output > bestOutput){\r\n                bestOutput  = output;\r\n                bestReserve = public_reserve_arr[i];\r\n            }\r\n        }\r\n        \r\n        return (bestReserve, bestOutput);\r\n    }\r\n    \r\n    /** @notice Allows users to swap a token or ETH with the reserve offering the best price for his trade\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @param  min_output   The minimum amount of buy_token, the trade should result in \r\n      * @param  deadline     The timestamp after which the transaction should not be executed\r\n      * @return The amount of buy_token the user receives\r\n    */\r\n    function swap(address sell_token, uint256 sell_amount, address buy_token,  uint256 min_output, uint256 deadline) external payable returns(uint256){        \r\n        require(\r\n            (\r\n                deadline == 0                               // No deadline is set         \r\n                || deadline > block.timestamp               // Deadline is met\r\n            ),                                              // Check whether the deadline is met\r\n            \"Call deadline exceeded.\"\r\n        );\r\n        \r\n        (address reserve, uint256 amount) = getBestReserve(sell_token, sell_amount, buy_token);     // Check which reserve offers the best deal on the trade\r\n        \r\n        require(\r\n            amount >= min_output,                                                                   // Check whether the best reserves deal is good enough\r\n            \"Too much slippage\"\r\n        );\r\n        \r\n        return swapWithReserve(sell_token, sell_amount, buy_token,  min_output, reserve, deadline); // Execute the swap with the best reserve\r\n    }\r\n    \r\n    /** @notice Allows users to swap a token or ETH with a specified reserve\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @param  min_output   The minimum amount of buy_token, the trade should result in \r\n      * @param  reserve      The address of the reserve to trade with\r\n      * @param  deadline     The timestamp after which the transaction should not be executed\r\n    */\r\n    function swapWithReserve(address sell_token, uint256 sell_amount, address buy_token,  uint256 min_output, address reserve, uint256 deadline) public payable returns (uint256){\r\n        require(\r\n            (\r\n                deadline == 0                               // No deadline is set         \r\n                || deadline > block.timestamp               // Deadline is met\r\n            ),\r\n            \"Call deadline exceeded.\"\r\n        );\r\n        \r\n        require(\r\n            public_reserves[reserve],                       // Check whether the reserve is registered\r\n            \"Unknown reserve.\"\r\n        );\r\n        \r\n        if(sell_token == address(0)){                       // Caller wants to swap ETH\r\n            require(\r\n                msg.value == sell_amount,                   // Check whether the caller sent the required ETH\r\n                \"ETH amount not sent with the call.\"\r\n            );\r\n        }else{                                              // Caller wants to swap a token\r\n            require(\r\n                msg.value == 0,                             // Check the caller hasn't sent any ETH with the call\r\n                \"Don't send ETH when swapping a token.\"\r\n            );\r\n            \r\n            Token(sell_token).transferFrom(msg.sender, reserve, sell_amount);   // Deposit ERC20 into the reserve\r\n            \r\n            require(\r\n                checkERC20TransferSuccess(),                // Check whether the ERC20 token transfer was successful\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n        }\r\n        \r\n        // Execute the swap with the reserve\r\n        uint256 output = dexBlueReserve(reserve).swap.value(msg.value)(\r\n            sell_token,\r\n            sell_amount,\r\n            buy_token,\r\n            min_output\r\n        );\r\n        \r\n        if(\r\n            output >= min_output                                // Check whether the output amount is sufficient \r\n            && balances[buy_token][reserve] >= output           // Check whether the reserve deposited the output amount\r\n        ){\r\n            balances[buy_token][reserve] -= output;             // Substract the amount from the reserves balance\r\n            \r\n            if(buy_token == address(0)){                        // Is the bought asset ETH\r\n                require(\r\n                    msg.sender.send(output),                    // Send the output ETH of the swap to msg.sender\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(buy_token).transfer(msg.sender, output);  // Transfer the output token of the swap msg.sender\r\n                require(                                        // Revert if the transfer failed\r\n                    checkERC20TransferSuccess(),\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n\r\n            emit LogSwap(sell_token, sell_amount, buy_token, output);\r\n            \r\n            return output;\r\n        }else{\r\n            revert(\"Too much slippage.\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract dexBlue is dexBlueStorage, dexBlueEvents, dexBlueUtils, dexBlueStructs{\r\n    // Hardcode settlement module contract:\r\n    address constant settlementModuleAddress = 0x9e3d5C6ffACA00cAf136609680b536DC0Eb20c66;\r\n\r\n    // Deposit functions:\r\n\r\n    /** @notice Deposit Ether into the smart contract \r\n      */\r\n    function depositEther() public payable{\r\n        balances[address(0)][msg.sender] += msg.value;          // Add the received ETH to the users balance\r\n        emit LogDeposit(msg.sender, address(0), msg.value);     // emit LogDeposit event\r\n    }\r\n    \r\n    /** @notice Fallback function to credit ETH sent to the contract without data \r\n      */\r\n    function() external payable{\r\n        if(msg.sender != wrappedEtherContract){     // ETH sends from WETH contract are handled in the depositWrappedEther() function\r\n            depositEther();                 // Call the deposit function to credit ETH sent in this transaction\r\n        }\r\n    }\r\n    \r\n    /** @notice Deposit Wrapped Ether (remember to set allowance in the token contract first)\r\n      * @param  amount  The amount of WETH to deposit \r\n      */\r\n    address constant wrappedEtherContract = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // We hardcode the address, to prevent misbehaviour through custom contracts (reentrancy etc)\r\n    function depositWrappedEther(uint256 amount) external {\r\n        \r\n        Token(wrappedEtherContract).transferFrom(msg.sender, address(this), amount);    // Transfer WETH to this contract\r\n        \r\n        require(\r\n            checkERC20TransferSuccess(),                                        // Check whether the ERC20 token transfer was successful\r\n            \"WETH deposit failed.\"\r\n        );\r\n        \r\n        uint balanceBefore = address(this).balance;                             // Remember ETH balance before the call\r\n        \r\n        WETH(wrappedEtherContract).withdraw(amount);                            // Unwrap the WETH\r\n        \r\n        require(balanceBefore + amount == address(this).balance);               // Check whether the ETH was deposited\r\n        \r\n        balances[address(0)][msg.sender] += amount;                             // Credit the deposited eth to users balance\r\n        \r\n        emit LogDeposit(msg.sender, address(0), amount);                        // emit LogDeposit event\r\n    }\r\n    \r\n    /** @notice Deposit ERC20 tokens into the smart contract (remember to set allowance in the token contract first)\r\n      * @param  token   The address of the token to deposit\r\n      * @param  amount  The amount of tokens to deposit \r\n      */\r\n    function depositToken(address token, uint256 amount) external {\r\n        Token(token).transferFrom(msg.sender, address(this), amount);    // Deposit ERC20\r\n        require(\r\n            checkERC20TransferSuccess(),                                 // Check whether the ERC20 token transfer was successful\r\n            \"ERC20 token transfer failed.\"\r\n        );\r\n        balances[token][msg.sender] += amount;                           // Credit the deposited token to users balance\r\n        emit LogDeposit(msg.sender, token, amount);                      // emit LogDeposit event\r\n    }\r\n        \r\n    // Multi-sig withdrawal functions:\r\n\r\n    /** @notice User-submitted withdrawal with arbiters signature, which withdraws to the users address\r\n      * @param  token   The token to withdraw (ETH is address(address(0)))\r\n      * @param  amount  The amount of tokens to withdraw\r\n      * @param  nonce   The nonce (to salt the hash)\r\n      * @param  v       Multi-signature v\r\n      * @param  r       Multi-signature r\r\n      * @param  s       Multi-signature s \r\n      */\r\n    function multiSigWithdrawal(address token, uint256 amount, uint64 nonce, uint8 v, bytes32 r, bytes32 s) external {\r\n        multiSigSend(token, amount, nonce, v, r, s, msg.sender); // Call multiSigSend to send funds to msg.sender\r\n    }    \r\n\r\n    /** @notice User-submitted withdrawal with arbiters signature, which sends tokens to specified address\r\n      * @param  token              The token to withdraw (ETH is address(address(0)))\r\n      * @param  amount             The amount of tokens to withdraw\r\n      * @param  nonce              The nonce (to salt the hash)\r\n      * @param  v                  Multi-signature v\r\n      * @param  r                  Multi-signature r\r\n      * @param  s                  Multi-signature s\r\n      * @param  receiving_address  The address to send the withdrawn token/ETH to\r\n      */\r\n    function multiSigSend(address token, uint256 amount, uint64 nonce, uint8 v, bytes32 r, bytes32 s, address payable receiving_address) public {\r\n        bytes32 hash = keccak256(abi.encodePacked(                      // Calculate the withdrawal hash from the parameters \r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                token,\r\n                amount,\r\n                nonce,\r\n                address(this)\r\n            ))\r\n        ));\r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[ecrecover(hash, v,r,s)]                         // Check if the multi-sig is valid\r\n            && balances[token][msg.sender] >= amount                    // Check if the user holds the required balance\r\n        ){\r\n            processed_withdrawals[hash]  = true;                        // Mark this withdrawal as processed\r\n            balances[token][msg.sender] -= amount;                      // Substract the withdrawn balance from the users balance\r\n            \r\n            if(token == address(0)){                                    // Process an ETH withdrawal\r\n                require(\r\n                    receiving_address.send(amount),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{                                                      // Withdraw an ERC20 token\r\n                Token(token).transfer(receiving_address, amount);       // Transfer the ERC20 token\r\n                require(\r\n                    checkERC20TransferSuccess(),                        // Check whether the ERC20 token transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n\r\n            blocked_for_single_sig_withdrawal[token][msg.sender] = 0;   // Set potential previous blocking of these funds to 0\r\n            \r\n            emit LogWithdrawal(msg.sender,token,amount);                // emit LogWithdrawal event\r\n        }else{\r\n            revert();                                                   // Revert the transaction if checks fail\r\n        }\r\n    }\r\n\r\n    /** @notice User-submitted transfer with arbiters signature, which sends tokens to another addresses account in the smart contract\r\n      * @param  token              The token to transfer (ETH is address(address(0)))\r\n      * @param  amount             The amount of tokens to transfer\r\n      * @param  nonce              The nonce (to salt the hash)\r\n      * @param  v                  Multi-signature v\r\n      * @param  r                  Multi-signature r\r\n      * @param  s                  Multi-signature s\r\n      * @param  receiving_address  The address to transfer the token/ETH to\r\n      */\r\n    function multiSigTransfer(address token, uint256 amount, uint64 nonce, uint8 v, bytes32 r, bytes32 s, address receiving_address) external {\r\n        bytes32 hash = keccak256(abi.encodePacked(                      // Calculate the withdrawal/transfer hash from the parameters \r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                token,\r\n                amount,\r\n                nonce,\r\n                address(this)\r\n            ))\r\n        ));\r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[ecrecover(hash, v,r,s)]                         // Check if the multi-sig is valid\r\n            && balances[token][msg.sender] >= amount                    // Check if the user holds the required balance\r\n        ){\r\n            processed_withdrawals[hash]         = true;                 // Mark this withdrawal as processed\r\n            balances[token][msg.sender]        -= amount;               // Substract the balance from the withdrawing account\r\n            balances[token][receiving_address] += amount;               // Add the balance to the receiving account\r\n            \r\n            blocked_for_single_sig_withdrawal[token][msg.sender] = 0;   // Set potential previous blocking of these funds to 0\r\n            \r\n            emit LogWithdrawal(msg.sender,token,amount);                // emit LogWithdrawal event\r\n            emit LogDeposit(receiving_address,token,amount);            // emit LogDeposit event\r\n        }else{\r\n            revert();                                                   // Revert the transaction if checks fail\r\n        }\r\n    }\r\n    \r\n    /** @notice Arbiter submitted withdrawal with users multi-sig to users address\r\n      * @param  packedInput1 tightly packed input arguments:\r\n      *             amount  The amount of tokens to withdraw\r\n      *             fee     The fee, covering the gas cost of the arbiter\r\n      * @param  packedInput2 tightly packed input arguments:\r\n      *             token           The token to withdraw (ETH is address(address(0)))\r\n      *             nonce           The nonce (to salt the hash)\r\n      *             v               Multi-signature v (either 27 or 28. To identify the different signing schemes an offset of 10 is applied for EIP712)\r\n      *             signing_scheme  The signing scheme of the users signature\r\n      *             burn_gas_tokens The amount of gas tokens to burn\r\n      * @param  r       Multi-signature r\r\n      * @param  s       Multi-signature s\r\n      */\r\n    function userSigWithdrawal(bytes32 packedInput1, bytes32 packedInput2, bytes32 r, bytes32 s) external {\r\n        /* \r\n            BITMASK packedInput1                                               | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 |  0-15      | amount\r\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff | 16-31      | gas fee\r\n            \r\n            BITMASK packedInput2                                               | BYTE RANGE | DESCRIPTION\r\n            -------------------------------------------------------------------|------------|----------------------------------\r\n            0xffff000000000000000000000000000000000000000000000000000000000000 |  0- 1      | token identifier\r\n            0x0000ffffffffffffffff00000000000000000000000000000000000000000000 |  2- 9      | nonce\r\n            0x00000000000000000000ff000000000000000000000000000000000000000000 | 10-10      | v\r\n            0x0000000000000000000000ff0000000000000000000000000000000000000000 | 11-11      | signing scheme 0x00 = personal.sign, 0x01 = EIP712\r\n            0x000000000000000000000000ff00000000000000000000000000000000000000 | 12-12      | burn_gas_tokens\r\n        */\r\n        // parse the packed input parameters\r\n        uint256 amount = uint256(packedInput1 >> 128);\r\n        uint256 fee    = uint256(packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff);\r\n        address token  = tokens[uint256(packedInput2 >> 240)];\r\n        uint64  nonce  = uint64(uint256((packedInput2 & 0x0000ffffffffffffffff00000000000000000000000000000000000000000000) >> 176));\r\n        uint8   v      = uint8(packedInput2[10]);\r\n\r\n        bytes32 hash;\r\n        if(packedInput2[11] == byte(0x00)){                             // Standard signing scheme (personal.sign())\r\n            hash = keccak256(abi.encodePacked(                          // Restore multi-sig hash\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                keccak256(abi.encodePacked(\r\n                    token,\r\n                    amount,\r\n                    nonce,\r\n                    address(this)\r\n                ))\r\n            ));\r\n        }else{                                                          // EIP712 signing scheme\r\n            hash = keccak256(abi.encodePacked(                          // Restore multi-sig hash\r\n                \"\\x19\\x01\",\r\n                EIP712_DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(\r\n                    EIP712_WITHDRAWAL_TYPEHASH,\r\n                    token,\r\n                    amount,\r\n                    nonce\r\n                ))\r\n            ));\r\n        }\r\n\r\n        address payable account = address(uint160(ecrecover(hash, v, r, s)));   // Restore signing address\r\n        \r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[msg.sender]                                     // Check if transaction comes from arbiter\r\n            && fee <= amount / 20                                       // Check if fee is not too big\r\n            && balances[token][account] >= amount                       // Check if the user holds the required tokens\r\n        ){\r\n            processed_withdrawals[hash]    = true;                      // Mark the withdrawal as processed\r\n            balances[token][account]      -= amount;                    // Deduct the withdrawn tokens from the users balance\r\n            balances[token][feeCollector] += fee;                       // Fee to cover gas costs for the withdrawal\r\n            \r\n            if(token == address(0)){                                    // Send ETH\r\n                require(\r\n                    account.send(amount - fee),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(token).transfer(account, amount - fee);           // Withdraw ERC20\r\n                require(\r\n                    checkERC20TransferSuccess(),                        // Check if the transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n        \r\n            blocked_for_single_sig_withdrawal[token][account] = 0;      // Set potential previous blocking of these funds to 0\r\n            \r\n            emit LogWithdrawal(account,token,amount);                   // emit LogWithdrawal event\r\n            \r\n            // burn gas tokens\r\n            if(packedInput2[12] != byte(0x00)){\r\n                spendGasTokens(uint8(packedInput2[12]));\r\n            }\r\n        }else{\r\n            revert();                                                   // Revert the transaction is checks fail\r\n        }\r\n    }\r\n    \r\n    // Single-sig withdrawal functions:\r\n\r\n    /** @notice Allows user to block funds for single-sig withdrawal after 24h waiting period \r\n      *         (This period is necessary to ensure all trades backed by these funds will be settled.)\r\n      * @param  token   The address of the token to block (ETH is address(address(0)))\r\n      * @param  amount  The amount of the token to block\r\n      */\r\n    function blockFundsForSingleSigWithdrawal(address token, uint256 amount) external {\r\n        if (balances[token][msg.sender] - blocked_for_single_sig_withdrawal[token][msg.sender] >= amount){  // Check if the user holds the required funds\r\n            blocked_for_single_sig_withdrawal[token][msg.sender] += amount;                                 // Block funds for manual withdrawal\r\n            last_blocked_timestamp[msg.sender] = block.timestamp;                                           // Start waiting period\r\n            emit LogBlockedForSingleSigWithdrawal(msg.sender, token, amount);                               // emit LogBlockedForSingleSigWithdrawal event\r\n        }else{\r\n            revert();                                                                                       // Revert the transaction if the user does not hold the required balance\r\n        }\r\n    }\r\n    \r\n    /** @notice Allows user to withdraw blocked funds without multi-sig after the waiting period\r\n      * @param  token   The address of the token to withdraw (ETH is address(address(0)))\r\n      * @param  amount  The amount of the token to withdraw\r\n      */\r\n    function initiateSingleSigWithdrawal(address token, uint256 amount) external {\r\n        if (\r\n            balances[token][msg.sender] >= amount                                   // Check if the user holds the funds\r\n            && (\r\n                (\r\n                    blocked_for_single_sig_withdrawal[token][msg.sender] >= amount                          // Check if these funds are blocked\r\n                    && last_blocked_timestamp[msg.sender] + single_sig_waiting_period <= block.timestamp    // Check if the waiting period has passed\r\n                )\r\n                || single_sig_waiting_period == 0                                                           // or the waiting period is disabled\r\n            )\r\n        ){\r\n            balances[token][msg.sender] -= amount;                                  // Substract the tokens from users balance\r\n\r\n            if(blocked_for_single_sig_withdrawal[token][msg.sender] >= amount){\r\n                blocked_for_single_sig_withdrawal[token][msg.sender] = 0;     // Substract the tokens from users blocked balance\r\n            }\r\n            \r\n            if(token == address(0)){                                                // Withdraw ETH\r\n                require(\r\n                    msg.sender.send(amount),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{                                                                  // Withdraw ERC20 tokens\r\n                Token(token).transfer(msg.sender, amount);                          // Transfer the ERC20 tokens\r\n                require(\r\n                    checkERC20TransferSuccess(),                                    // Check if the transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n            \r\n            emit LogSingleSigWithdrawal(msg.sender, token, amount);                 // emit LogSingleSigWithdrawal event\r\n        }else{\r\n            revert();                                                               // Revert the transaction if the required checks fail\r\n        }\r\n    } \r\n\r\n    //Trade settlement structs and function\r\n\r\n    /** @notice Allows an arbiter to settle a trade between two orders\r\n      * @param  makerOrderInput  The packed maker order input\r\n      * @param  takerOrderInput  The packed taker order input\r\n      * @param  tradeInput       The packed trade to settle between the two\r\n      */ \r\n    function settleTrade(OrderInputPacked calldata makerOrderInput, OrderInputPacked calldata takerOrderInput, TradeInputPacked calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);   // Check if msg.sender is an arbiter and the market is active\r\n\r\n        settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n        \r\n        // burn gas tokens\r\n        if(tradeInput.packedInput3[28] != byte(0x00)){\r\n            spendGasTokens(uint8(tradeInput.packedInput3[28]));\r\n        }\r\n    }\r\n\r\n    /** @notice Allows an arbiter to settle a trade between an order and a reserve\r\n      * @param  orderInput  The packed maker order input\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      */ \r\n    function settleReserveTrade(OrderInputPacked calldata orderInput, TradeInputPacked calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);   // Check if msg.sender is an arbiter and the market is active\r\n\r\n        settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n        \r\n        // burn gas tokens\r\n        if(tradeInput.packedInput3[28] != byte(0x00)){\r\n            spendGasTokens(uint8(tradeInput.packedInput3[28]));\r\n        }\r\n    }\r\n\r\n    /** @notice Allows an arbiter to settle a trade between an order and a reserve, passing some additional data to the reserve\r\n      * @param  orderInput  The packed maker order input\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      * @param  data        The data to pass on to the reserve\r\n      */ \r\n    function settleReserveTradeWithData(OrderInputPacked calldata orderInput, TradeInputPacked calldata tradeInput, bytes32[] calldata data) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n        \r\n        // burn gas tokens\r\n        if(tradeInput.packedInput3[28] != byte(0x00)){\r\n            spendGasTokens(uint8(tradeInput.packedInput3[28]));\r\n        }\r\n    }\r\n    \r\n    /** @notice Allows an arbiter to settle a trade between two reserves\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      */ \r\n    function settleReserveReserveTrade(TradeInputPacked calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);          // Check if msg.sender is an arbiter and the market is active\r\n\r\n        settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n        \r\n        // burn gas tokens\r\n        if(tradeInput.packedInput3[28] != byte(0x00)){\r\n            spendGasTokens(uint8(tradeInput.packedInput3[28]));\r\n        }\r\n    }\r\n    \r\n    /** @notice Allows an arbiter to settle a trade between two reserves\r\n      * @param  tradeInput  The packed trade to settle between the two\r\n      * @param  makerData   The data to pass on to the maker reserve\r\n      * @param  takerData   The data to pass on to the taker reserve\r\n      */ \r\n    function settleReserveReserveTradeWithData(TradeInputPacked calldata tradeInput, bytes32[] calldata makerData, bytes32[] calldata takerData) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        settlementModuleAddress.delegatecall(msg.data);     // delegate the call to the settlement module\r\n        \r\n        // burn gas tokens\r\n        if(tradeInput.packedInput3[28] != byte(0x00)){\r\n            spendGasTokens(uint8(tradeInput.packedInput3[28]));\r\n        }\r\n    }\r\n    \r\n\r\n    /** @notice Allows an arbiter to settle multiple trades between multiple orders and reserves\r\n      * @param  orderInput     Array of all orders involved in the transactions\r\n      * @param  tradeInput     Array of the trades to be settled\r\n      */   \r\n    function batchSettleTrades(OrderInputPacked[] calldata orderInput, TradeInputPacked[] calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);          // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n        \r\n        // Loop through the trades and calc the gasToken sum\r\n        uint256 i = tradeInput.length;        \r\n        uint256 gasTokenSum;\r\n        while(i-- != 0){\r\n            gasTokenSum += uint8(tradeInput[i].packedInput3[28]);\r\n        }\r\n        \r\n        // burn gas tokens\r\n        if(gasTokenSum > 0){\r\n            spendGasTokens(gasTokenSum);\r\n        }\r\n    }\r\n\r\n    /** @notice Allow arbiters to settle a ring of order and reserve trades\r\n      * @param  orderInput Array of OrderInputPacked structs\r\n      * @param  tradeInput Array of RingTradeInputPacked structs\r\n      */\r\n    function settleRingTrade(OrderInputPacked[] calldata orderInput, RingTradeInputPacked[] calldata tradeInput) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n\r\n        settlementModuleAddress.delegatecall(msg.data);\r\n        \r\n        // Loop through the trades and calc the gasToken sum\r\n        uint256 i = tradeInput.length;        \r\n        uint256 gasTokenSum;\r\n        while(i-- != 0){\r\n            gasTokenSum += uint8(tradeInput[i].packedInput2[24]);\r\n        }\r\n        \r\n        // burn gas tokens\r\n        if(gasTokenSum > 0){\r\n            spendGasTokens(gasTokenSum);\r\n        }\r\n    }\r\n\r\n    /** @notice Allow arbiters to settle a ring of order and reserve trades, passing on some data to the reserves\r\n      * @param  orderInput Array of OrderInputPacked structs\r\n      * @param  tradeInput Array of RingTradeInputPacked structs\r\n      * @param  data       Array of data to pass along to the reserves\r\n      */\r\n    function settleRingTradeWithData(OrderInputPacked[] calldata orderInput, RingTradeInputPacked[] calldata tradeInput, bytes32[][] calldata data) external {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n\r\n        settlementModuleAddress.delegatecall(msg.data);\r\n        \r\n        // Loop through the trades and calc the gasToken sum\r\n        uint256 i = tradeInput.length;        \r\n        uint256 gasTokenSum;\r\n        while(i-- != 0){\r\n            gasTokenSum += uint8(tradeInput[i].packedInput2[24]);\r\n        }\r\n        \r\n        // burn gas tokens\r\n        if(gasTokenSum > 0){\r\n            spendGasTokens(gasTokenSum);\r\n        }\r\n    }\r\n\r\n\r\n    /** @notice Helper function, callable only by the contract itself, to execute a trade between two reserves\r\n      * @param  makerReserve  The maker reserve\r\n      * @param  takerReserve  The taker reserve\r\n      * @param  trade         The trade to settle between the two\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function executeReserveReserveTrade(\r\n        address             makerReserve,\r\n        address payable     takerReserve,\r\n        ReserveReserveTrade calldata trade\r\n    ) external returns(bool){\r\n        // this method is only callable from the contract itself\r\n        // a call is used vs a jump, to be able to revert the sending of funds to the reserve without throwing the entire transaction\r\n        require(msg.sender == address(this));                       // Check that the caller is the contract itself\r\n        \r\n        // Check whether the taker reserve accepts the trade\r\n        require(\r\n            dexBlueReserve(takerReserve).offer(                     \r\n                trade.takerToken,                                   // The token we offer the reserve to sell\r\n                trade.takerAmount,                                  // The amount the reserve could sell\r\n                trade.makerToken,                                   // The token the reserve would receive\r\n                trade.makerAmount - trade.takerFee                  // The amount the reserve would receive\r\n            )\r\n            && balances[trade.takerToken][takerReserve] >= trade.takerAmount    // Check whether the taker reserve deposited the collateral\r\n        );\r\n        \r\n        balances[trade.takerToken][takerReserve] -= trade.takerAmount;          // Substract the deposited amount from the taker reserve\r\n        \r\n        if(trade.takerToken != address(0)){\r\n            Token(trade.takerToken).transfer(makerReserve, trade.takerAmount - trade.makerFee);     // Send the taker reserves collateral to the maker reserve\r\n            require(                                                                                // Revert if the send failed\r\n                checkERC20TransferSuccess(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n        }\r\n        \r\n        // Check whether the maker reserve accepts the trade\r\n        require(\r\n            dexBlueReserve(makerReserve).trade.value(               // Execute the trade in the maker reserve\r\n                trade.takerToken == address(0) ? \r\n                    trade.takerAmount - trade.makerFee              // Send the taker reserves collateral to the maker reserve\r\n                    : 0\r\n            )(\r\n                trade.takerToken,                                   // The token the taker reserve is selling\r\n                trade.takerAmount - trade.makerFee,                 // The amount of sellToken the taker reserve wants to sell\r\n                trade.makerToken,                                   // The token the taker reserve wants in return\r\n                trade.makerAmount                                   // The amount of token the taker reserve wants in return\r\n            )\r\n            && balances[trade.makerToken][makerReserve] >= trade.makerAmount  // Check whether the maker reserve deposited the collateral\r\n        );\r\n\r\n        balances[trade.makerToken][makerReserve] -= trade.makerAmount;                              // Substract the maker reserves's sold amount\r\n        \r\n        // Send the acquired amount to the taker reserve\r\n        if(trade.makerToken == address(0)){                                                         // Is the acquired token ETH\r\n            require(\r\n                takerReserve.send(trade.makerAmount - trade.takerFee),                              // Send ETH\r\n                \"Sending of ETH failed.\"\r\n            );\r\n        }else{\r\n            Token(trade.makerToken).transfer(takerReserve, trade.makerAmount - trade.takerFee);     // Transfer ERC20\r\n            require(                                                                                // Revert if the transfer failed\r\n                checkERC20TransferSuccess(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n        }\r\n\r\n        // Notify the reserve, that the offer got executed\r\n        dexBlueReserve(takerReserve).offerExecuted(                     \r\n            trade.takerToken,                                   // The token the reserve sold\r\n            trade.takerAmount,                                  // The amount the reserve sold\r\n            trade.makerToken,                                   // The token the reserve received\r\n            trade.makerAmount - trade.takerFee                  // The amount the reserve received\r\n        );\r\n        \r\n        // Give fee to feeCollector\r\n        balances[trade.makerToken][feeCollector] += trade.takerFee;  // Give feeColletor the taker fee\r\n        balances[trade.takerToken][feeCollector] += trade.makerFee;  // Give feeColletor the maker fee\r\n        \r\n        emit LogTrade(trade.makerToken, trade.makerAmount, trade.takerToken, trade.takerAmount);\r\n        \r\n        emit LogDirectWithdrawal(makerReserve, trade.takerToken, trade.takerAmount - trade.makerFee);\r\n        emit LogDirectWithdrawal(takerReserve, trade.makerToken, trade.makerAmount - trade.takerFee);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /** @notice Helper function, callable only by the contract itself, to execute a trade between two reserves\r\n      * @param  makerReserve  The maker reserve\r\n      * @param  takerReserve  The taker reserve\r\n      * @param  trade         The trade to settle between the two\r\n      * @param  makerData     The data to pass on to the maker reserve\r\n      * @param  takerData     The data to pass on to the taker reserve\r\n      * @return Whether the trade succeeded or failed\r\n      */\r\n    function executeReserveReserveTradeWithData(\r\n        address             makerReserve,\r\n        address payable     takerReserve,\r\n        ReserveReserveTrade calldata trade,\r\n        bytes32[] calldata  makerData,\r\n        bytes32[] calldata  takerData\r\n    ) external returns(bool){\r\n        // this method is only callable from the contract itself\r\n        // a call is used vs a jump, to be able to revert the sending of funds to the reserve without throwing the entire transaction\r\n        require(msg.sender == address(this));                       // Check that the caller is the contract itself\r\n        \r\n        // Check whether the taker reserve accepts the trade\r\n        require(\r\n            dexBlueReserve(takerReserve).offerWithData(                     \r\n                trade.takerToken,                                   // The token we offer the reserve to sell\r\n                trade.takerAmount,                                  // The amount the reserve could sell\r\n                trade.makerToken,                                   // The token the reserve would receive\r\n                trade.makerAmount - trade.takerFee,                 // The amount the reserve would receive\r\n                takerData\r\n            )\r\n            && balances[trade.takerToken][takerReserve] >= trade.takerAmount    // Check whether the taker reserve deposited the collateral\r\n        );\r\n        \r\n        balances[trade.takerToken][takerReserve] -= trade.takerAmount;          // Substract the deposited amount from the taker reserve\r\n        \r\n        if(trade.takerToken != address(0)){\r\n            Token(trade.takerToken).transfer(makerReserve, trade.takerAmount - trade.makerFee);     // Send the taker reserves collateral to the maker reserve\r\n            require(                                                                                // Revert if the send failed\r\n                checkERC20TransferSuccess(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n        }\r\n        \r\n        // Check whether the maker reserve accepts the trade\r\n        require(\r\n            dexBlueReserve(makerReserve).tradeWithData.value(       // Execute the trade in the maker reserve\r\n                trade.takerToken == address(0) ? \r\n                    trade.takerAmount - trade.makerFee              // Send the taker reserves collateral to the maker reserve\r\n                    : 0\r\n            )(\r\n                trade.takerToken,                                   // The token the taker reserve is selling\r\n                trade.takerAmount - trade.makerFee,                 // The amount of sellToken the taker reserve wants to sell\r\n                trade.makerToken,                                   // The token the taker reserve wants in return\r\n                trade.makerAmount,                                  // The amount of token the taker reserve wants in return\r\n                makerData\r\n            )\r\n            && balances[trade.makerToken][makerReserve] >= trade.makerAmount  // Check whether the maker reserve deposited the collateral\r\n        );\r\n\r\n        balances[trade.makerToken][makerReserve] -= trade.makerAmount;                              // Substract the maker reserves's sold amount\r\n        \r\n        // Send the acquired amount to the taker reserve\r\n        if(trade.makerToken == address(0)){                                                         // Is the acquired token ETH\r\n            require(\r\n                takerReserve.send(trade.makerAmount - trade.takerFee),                              // Send ETH\r\n                \"Sending of ETH failed.\"\r\n            );\r\n        }else{\r\n            Token(trade.makerToken).transfer(takerReserve, trade.makerAmount - trade.takerFee);     // Transfer ERC20\r\n            require(                                                                                // Revert if the transfer failed\r\n                checkERC20TransferSuccess(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n        }\r\n\r\n        // Notify the reserve, that the offer got executed\r\n        dexBlueReserve(takerReserve).offerExecuted(                     \r\n            trade.takerToken,                                   // The token the reserve sold\r\n            trade.takerAmount,                                  // The amount the reserve sold\r\n            trade.makerToken,                                   // The token the reserve received\r\n            trade.makerAmount - trade.takerFee                  // The amount the reserve received\r\n        );\r\n        \r\n        // Give fee to feeCollector\r\n        balances[trade.makerToken][feeCollector] += trade.takerFee;  // Give feeColletor the taker fee\r\n        balances[trade.takerToken][feeCollector] += trade.makerFee;  // Give feeColletor the maker fee\r\n        \r\n        emit LogTrade(trade.makerToken, trade.makerAmount, trade.takerToken, trade.takerAmount);\r\n        \r\n        emit LogDirectWithdrawal(makerReserve, trade.takerToken, trade.takerAmount - trade.makerFee);\r\n        emit LogDirectWithdrawal(takerReserve, trade.makerToken, trade.makerAmount - trade.takerFee);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /** @notice Helper function, callable only by the contract itself, to execute a trade with a reserve contract\r\n      * @param  sellToken   The address of the token we want to sell (ETH is address(address(0)))\r\n      * @param  sellAmount  The amount of sellToken we want to sell\r\n      * @param  buyToken    The address of the token we want to buy (ETH is address(address(0)))\r\n      * @param  buyAmount   The amount of buyToken we want in exchange for sellAmount\r\n      * @param  reserve     The address of the reserve, we want to trade with\r\n      */\r\n    function executeReserveTrade(\r\n        address    sellToken,\r\n        uint256    sellAmount,\r\n        address    buyToken,\r\n        uint256    buyAmount,\r\n        address    reserve\r\n    ) external returns(bool){\r\n        // this method is only callable from the contract itself\r\n        // a call is used vs a jump, to be able to revert the sending of funds to the reserve without throwing the entire transaction\r\n        require(msg.sender == address(this));                   // check that the caller is the contract itself\r\n        \r\n        if(sellToken == address(0)){\r\n            require(dexBlueReserve(reserve).trade.value(        // execute the trade in the reserve\r\n                                                                // if the reserve accepts the trade, it will deposit the buyAmount and return true\r\n                sellAmount                                      // send collateral to reserve\r\n            )(\r\n                sellToken,                                      // the token we want to sell\r\n                sellAmount,                                     // the amount of sellToken we want to exchange\r\n                buyToken,                                       // the token we want to receive\r\n                buyAmount                                       // the quantity of buyToken we demand in return\r\n            ));\r\n        }else{\r\n            Token(sellToken).transfer(reserve, sellAmount);     // send collateral to reserve\r\n            require(                                            // revert if the send failed\r\n                checkERC20TransferSuccess(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n            \r\n            require(dexBlueReserve(reserve).trade(              // execute the trade in the reserve\r\n                sellToken,                                      // the token we want to sell\r\n                sellAmount,                                     // the amount of sellToken we want to exchange\r\n                buyToken,                                       // the token we want to receive\r\n                buyAmount                                       // the quantity of buyToken we demand in return\r\n            ));\r\n        }\r\n        \r\n        require(balances[buyToken][reserve] >= buyAmount);      // check if the reserve delivered on the request, else revert\r\n        \r\n        return true;                                            // return true if all checks are passed and the trade was executed successfully\r\n    }\r\n    \r\n    /** @notice private function to execute a trade with a reserve contract\r\n      * @param  sellToken   The address of the token we want to sell (ETH is address(address(0)))\r\n      * @param  sellAmount  The amount of sellToken we want to sell\r\n      * @param  buyToken    The address of the token we want to buy (ETH is address(address(0)))\r\n      * @param  buyAmount   The amount of buyToken we want in exchange for sellAmount\r\n      * @param  reserve     The address of the reserve, we want to trade with\r\n      * @param  data        The data passed on to the reserve\r\n      */\r\n    function executeReserveTradeWithData(\r\n        address    sellToken,\r\n        uint256    sellAmount,\r\n        address    buyToken,\r\n        uint256    buyAmount,\r\n        address    reserve,\r\n        bytes32[]  calldata data\r\n    ) external returns(bool){\r\n        // this method is only callable from the contract itself\r\n        // a call is used vs a jump, to be able to revert the sending of funds to the reserve without throwing the entire transaction\r\n        require(msg.sender == address(this));                   // check that the caller is the contract itself\r\n        \r\n        if(sellToken == address(0)){\r\n            require(dexBlueReserve(reserve).tradeWithData.value(// execute the trade in the reserve\r\n                                                                // if the reserve accepts the trade, it will deposit the buyAmount and return true\r\n                sellAmount                                      // send collateral to reserve\r\n            )(\r\n                sellToken,                                      // the token we want to sell\r\n                sellAmount,                                     // the amount of sellToken we want to exchange\r\n                buyToken,                                       // the token we want to receive\r\n                buyAmount,                                      // the quantity of buyToken we demand in return\r\n                data                                            // the data passed on to the reserve\r\n            ));\r\n        }else{\r\n            Token(sellToken).transfer(reserve, sellAmount);     // send collateral to reserve\r\n            require(                                            // revert if the send failed\r\n                checkERC20TransferSuccess(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n            require(dexBlueReserve(reserve).tradeWithData(      // execute the trade in the reserve\r\n                sellToken,                                      // the token we want to sell\r\n                sellAmount,                                     // the amount of sellToken we want to exchange\r\n                buyToken,                                       // the token we want to receive\r\n                buyAmount,                                      // the quantity of buyToken we demand in return\r\n                data                                            // the data passed on to the reserve\r\n            ));\r\n        }\r\n        \r\n        require(balances[buyToken][reserve] >= buyAmount);      // check if the reserve delivered on the request, else revert\r\n        \r\n        return true;                                            // return true if all checks are passed and the trade was executed successfully\r\n    }\r\n\r\n\r\n    // Token swapping functionality\r\n\r\n    /** @notice Queries best output for a trade currently available from the reserves\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @return The output amount the reserve with the best price offers\r\n    */\r\n    function getSwapOutput(address sell_token, uint256 sell_amount, address buy_token) public view returns (uint256){\r\n        (, uint256 output) = getBestReserve(sell_token, sell_amount, buy_token);\r\n        return output;\r\n    }\r\n\r\n    /** @notice Queries the reserve address and output of trade, of the reserve which offers the best deal on a trade\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @return The address of the reserve offering the best deal and the expected output of the trade\r\n    */\r\n    function getBestReserve(address sell_token, uint256 sell_amount, address buy_token) public view returns (address, uint256){\r\n        address bestReserve;\r\n        uint256 bestOutput = 0;\r\n        uint256 output;\r\n        \r\n        for(uint256 i = 0; i < public_reserve_arr.length; i++){\r\n            output = dexBlueReserve(public_reserve_arr[i]).getSwapOutput(sell_token, sell_amount, buy_token);\r\n            if(output > bestOutput){\r\n                bestOutput  = output;\r\n                bestReserve = public_reserve_arr[i];\r\n            }\r\n        }\r\n        \r\n        return (bestReserve, bestOutput);\r\n    }\r\n\r\n    /** @notice Allows users to swap a token or ETH with the reserve offering the best price for his trade\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @param  min_output   The minimum amount of buy_token, the trade should result in \r\n      * @param  deadline     The timestamp after which the transaction should not be executed\r\n      * @return The amount of buy_token the user receives\r\n    */\r\n    function swap(address sell_token, uint256 sell_amount, address buy_token,  uint256 min_output, uint256 deadline) external payable returns(uint256){\r\n\r\n        (bool success, bytes memory returnData) = settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n\r\n        require(success);\r\n\r\n        return abi.decode(returnData, (uint256));\r\n    }\r\n\r\n    /** @notice Allows users to swap a token or ETH with a specified reserve\r\n      * @param  sell_token   The token the user wants to sell (ETH is address(0))\r\n      * @param  sell_amount  The amount of sell_token to sell\r\n      * @param  buy_token    The token the user wants to acquire (ETH is address(0))\r\n      * @param  min_output   The minimum amount of buy_token, the trade should result in \r\n      * @param  reserve      The address of the reserve to trade with\r\n      * @param  deadline     The timestamp after which the transaction should not be executed\r\n    */\r\n    function swapWithReserve(address sell_token, uint256 sell_amount, address buy_token,  uint256 min_output, address reserve, uint256 deadline) public payable returns (uint256){\r\n        \r\n        (bool success, bytes memory returnData) = settlementModuleAddress.delegatecall(msg.data);  // delegate the call to the settlement module\r\n\r\n        require(success);\r\n\r\n        return abi.decode(returnData, (uint256));\r\n    }\r\n\r\n    \r\n    // Order cancellation functions\r\n\r\n    /** @notice Give the user the option to perform multiple on-chain cancellations of orders at once with arbiters multi-sig\r\n      * @param  orderHashes Array of orderHashes of the orders to be canceled\r\n      * @param  v           Multi-sig v\r\n      * @param  r           Multi-sig r\r\n      * @param  s           Multi-sig s\r\n      */\r\n    function multiSigOrderBatchCancel(bytes32[] calldata orderHashes, uint8 v, bytes32 r, bytes32 s) external {\r\n        if(\r\n            arbiters[                                               // Check if the signee is an arbiter\r\n                ecrecover(                                          // Restore the signing address\r\n                    keccak256(abi.encodePacked(                     // Restore the signed hash (hash of all orderHashes)\r\n                        \"\\x19Ethereum Signed Message:\\n32\", \r\n                        keccak256(abi.encodePacked(orderHashes))\r\n                    )),\r\n                    v, r, s\r\n                )\r\n            ]\r\n        ){\r\n            uint256 len = orderHashes.length;\r\n            for(uint256 i = 0; i < len; i++){\r\n                matched[orderHashes[i]] = 2**256 - 1;               // Set the matched amount of all orders to the maximum\r\n                emit LogOrderCanceled(orderHashes[i]);              // emit LogOrderCanceled event\r\n            }\r\n        }else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    \r\n    // Gastoken functionality\r\n    \r\n    // This is heavily inspired and based on the work of the gastoken.io team @ initc3.org, kudos!\r\n    // Why not use their implementation?\r\n    // We can safe even more gas through: having a even shorter contract address (1 byte less), saving the call to their contract, their token logic, and other minor optimisations\r\n    \r\n    uint256 gas_token_nonce_head;\r\n    uint256 gas_token_nonce_tail;\r\n    \r\n    /** @notice Get the available amount of gasTokens\r\n      * @return The array of all indexed token addresses\r\n      */\r\n    function getAvailableGasTokens() view public returns (uint256 amount){\r\n        return gas_token_nonce_head - gas_token_nonce_tail;\r\n    }\r\n    \r\n    /** @notice Mint new gasTokens\r\n      * @param  amount  The amount of gasTokens to mint\r\n      */\r\n    function mintGasTokens(uint amount) public {\r\n        gas_token_nonce_head += amount;\r\n        while(amount-- > 0){\r\n            createChildContract();   \r\n        }\r\n    }\r\n    \r\n    /** @notice internal function to burn gasTokens\r\n      * @param  amount  The amount of gasTokens to burn\r\n      */\r\n    function spendGasTokens(uint256 amount) internal {\r\n        uint256 tail = gas_token_nonce_tail;\r\n        \r\n        if(amount <= gas_token_nonce_head - tail){\r\n            \r\n            // tail points to slot behind the last contract in the queue\r\n            for (uint256 i = tail + 1; i <= tail + amount; i++) {\r\n                restoreChildContractAddress(i).call(\"\");\r\n            }\r\n    \r\n            gas_token_nonce_tail = tail + amount;\r\n        }\r\n    }\r\n    \r\n    /** @notice internal helper function to create a child contract\r\n      * @return The address of the created contract\r\n      */\r\n    function createChildContract() internal returns (address addr) {\r\n        assembly {\r\n            let solidity_free_mem_ptr := mload(0x40)\r\n            mstore(solidity_free_mem_ptr, 0x746d541e251335090ac5b47176af4f7e3318585733ff6000526015600bf3) // Load contract bytecode into memory\r\n            addr := create(0, add(solidity_free_mem_ptr, 2), 30)                                          // Create child contract\r\n        }\r\n    }\r\n    \r\n    /** @notice internal helper function to restore the address of a child contract for a given nonce\r\n      * @param  nonce   The nonce of the child contract\r\n      * @return The address of the child contract\r\n      */\r\n    function restoreChildContractAddress(uint256 nonce) view internal returns (address) {\r\n        require(nonce <= 256**9 - 1);\r\n\r\n        uint256 encoded;\r\n        uint256 tot_bytes;\r\n\r\n        if (nonce < 128) {\r\n            // RLP(nonce) = nonce\r\n            // add the encoded nonce to the encoded word\r\n            encoded = nonce * 256**9;\r\n            \r\n            // [address_length(1) address(20) nonce_length(0) nonce(1)]\r\n            tot_bytes = 22;\r\n        } else {\r\n            // RLP(nonce) = [num_bytes_in_nonce nonce]\r\n            uint nonce_bytes = 1;\r\n            // count nonce bytes\r\n            uint mask = 256;\r\n            while (nonce >= mask) {\r\n                nonce_bytes += 1;\r\n                mask        *= 256;\r\n            }\r\n            \r\n            // add the encoded nonce to the word\r\n            encoded = ((128 + nonce_bytes) * 256**9) +  // nonce length\r\n                      (nonce * 256**(9 - nonce_bytes)); // nonce\r\n                   \r\n            // [address_length(1) address(20) nonce_length(1) nonce(1-9)]\r\n            tot_bytes = 22 + nonce_bytes;\r\n        }\r\n\r\n        // add the prefix and encoded address to the encoded word\r\n        encoded += ((192 + tot_bytes) * 256**31) +     // total length\r\n                   ((128 + 20) * 256**30) +            // address length\r\n                   (uint256(address(this)) * 256**10); // address(this)\r\n\r\n        uint256 hash;\r\n\r\n        assembly {\r\n            let mem_start := mload(0x40)        // get a pointer to free memory\r\n            mstore(0x40, add(mem_start, 0x20))  // update the pointer\r\n\r\n            mstore(mem_start, encoded)          // store the rlp encoding\r\n            hash := keccak256(mem_start,\r\n                         add(tot_bytes, 1))     // hash the rlp encoding\r\n        }\r\n\r\n        // interpret hash as address (20 least significant bytes)\r\n        return address(hash);\r\n    }\r\n    \r\n        \r\n    // Signature delegation\r\n\r\n    /** @notice delegate an address to allow it to sign orders on your behalf\r\n      * @param delegate  The address to delegate\r\n      */\r\n    function delegateAddress(address delegate) external {\r\n        // set as delegate\r\n        require(delegates[delegate] == address(0), \"Address is already a delegate\");\r\n        delegates[delegate] = msg.sender;\r\n        \r\n        emit LogDelegateStatus(msg.sender, delegate, true);\r\n    }\r\n    \r\n    /** @notice revoke the delegation of an address\r\n      * @param  delegate  The delegated address\r\n      * @param  v         Multi-sig v\r\n      * @param  r         Multi-sig r\r\n      * @param  s         Multi-sig s\r\n      */\r\n    function revokeDelegation(address delegate, uint8 v, bytes32 r, bytes32 s) external {\r\n        bytes32 hash = keccak256(abi.encodePacked(              // Restore the signed hash\r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                delegate,\r\n                msg.sender,\r\n                address(this)\r\n            ))\r\n        ));\r\n\r\n        require(\r\n            arbiters[ecrecover(hash, v, r, s)],     // Check if signee is an arbiter\r\n            \"MultiSig is not from known arbiter\"\r\n        );\r\n        \r\n        delegates[delegate] = address(1);           // Set to 1 not 0 to prevent double delegation, which would make old signed orders valid for the new delegator\r\n        \r\n        emit LogDelegateStatus(msg.sender, delegate, false);\r\n    }\r\n    \r\n\r\n    // Management functions:\r\n\r\n    /** @notice Constructor function. Sets initial roles and creates EIP712 Domain.\r\n      */\r\n    constructor() public {\r\n        owner = msg.sender;             // Nominate sender to be the contract owner\r\n        \r\n        // create EIP712 domain seperator\r\n        EIP712_Domain memory eip712Domain = EIP712_Domain({\r\n            name              : \"dex.blue\",\r\n            version           : \"1\",\r\n            chainId           : 1,\r\n            verifyingContract : address(this)\r\n        });\r\n        EIP712_DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            keccak256(bytes(eip712Domain.name)),\r\n            keccak256(bytes(eip712Domain.version)),\r\n            eip712Domain.chainId,\r\n            eip712Domain.verifyingContract\r\n        ));\r\n    }\r\n    \r\n    /** @notice Allows the owner to change / disable the waiting period for a single sig withdrawal\r\n      * @param  waiting_period The new waiting period\r\n      */\r\n    function changeSingleSigWaitingPeriod(uint256 waiting_period) external {\r\n        require(\r\n            msg.sender == owner             // only owner can set waiting period\r\n            && waiting_period <= 86400      // max period owner can set is one day\r\n        );\r\n        \r\n        single_sig_waiting_period = waiting_period;\r\n    }\r\n    \r\n    /** @notice Allows the owner to handle over the ownership to another address\r\n      * @param  new_owner The new owner address\r\n      */\r\n    function changeOwner(address payable new_owner) external {\r\n        require(msg.sender == owner);\r\n        owner = new_owner;\r\n    }\r\n    \r\n    /** @notice Allows the owner to register & cache a new reserve address in the smart conract\r\n      * @param  reserve   The address of the reserve to add\r\n      * @param  index     The index under which the reserve should be indexed\r\n      * @param  is_public Whether the reserve should publicly available through swap() & swapWithReserve()\r\n      */\r\n    function cacheReserveAddress(address payable reserve, uint256 index, bool is_public) external {\r\n        require(arbiters[msg.sender]);\r\n        \r\n        reserves[index] = reserve;\r\n        reserve_indices[reserve] = index;\r\n        \r\n        if(is_public){\r\n            public_reserves[reserve] = true;\r\n            public_reserve_arr.push(reserve);  // append the reserve to the reserve array\r\n        }\r\n    }\r\n    \r\n    /** @notice Allows the owner to remove a reserve from the array swap() and getSwapOutput() need to loop through\r\n      * @param  reserve The address of the reserve to remove\r\n      */\r\n    function removePublicReserveAddress(address reserve) external {\r\n        require(arbiters[msg.sender]);\r\n        \r\n        public_reserves[reserve] = false;\r\n\r\n        for(uint256 i = 0; i < public_reserve_arr.length; i++){\r\n            if(public_reserve_arr[i] == reserve){\r\n                public_reserve_arr[i] = public_reserve_arr[public_reserve_arr.length - 1]; // array order does not matter, so we just move the last element in the slot of the element we are removing\r\n                \r\n                delete public_reserve_arr[public_reserve_arr.length-1];                    // delete the last element of the array\r\n                public_reserve_arr.length--;                             \r\n                \r\n                return;\r\n            }\r\n        }\r\n    }\r\n        \r\n    /** @notice Allows an arbiterto cache a new token address\r\n      * @param  token   The address of the token to add\r\n      * @param  index   The index under which the token should be indexed\r\n      */\r\n    function cacheTokenAddress(address token, uint256 index) external {\r\n        require(arbiters[msg.sender]);\r\n        \r\n        tokens[index]        = token;\r\n        token_indices[token] = index;\r\n        \r\n        token_arr.push(token);  // append the token to the array\r\n    }\r\n\r\n    /** @notice Allows arbiters to remove a token from the token array\r\n      * @param  token The address of the token to remove\r\n      */\r\n    function removeTokenAddressFromArr(address token) external {\r\n        require(arbiters[msg.sender]);\r\n        \r\n        for(uint256 i = 0; i < token_arr.length; i++){\r\n            if(token_arr[i] == token){\r\n                token_arr[i] = token_arr[token_arr.length - 1]; // array order does not matter, so we just move the last element in the slot of the element we are removing\r\n                \r\n                delete token_arr[token_arr.length-1];           // delete the last element of the array\r\n                token_arr.length--;                             \r\n                \r\n                return;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /** @notice Allows the owner to nominate or denominate trade arbiting addresses\r\n      * @param  arbiter The arbiter whose status to change\r\n      * @param  status  whether the address should be an arbiter (true) or not (false)\r\n      */\r\n    function nominateArbiter(address arbiter, bool status) external {\r\n        require(msg.sender == owner);                           // Check if sender is owner\r\n        arbiters[arbiter] = status;                             // Update address status\r\n    }\r\n    \r\n    /** @notice Allows the owner to pause / unpause the market\r\n      * @param  state  whether the the market should be active (true) or paused (false)\r\n      */\r\n    function setMarketActiveState(bool state) external {\r\n        require(msg.sender == owner);                           // Check if sender is owner\r\n        marketActive = state;                                   // pause / unpause market\r\n    }\r\n    \r\n    /** @notice Allows the owner to nominate the feeCollector address\r\n      * @param  collector The address to nominate as feeCollector\r\n      */\r\n    function nominateFeeCollector(address payable collector) external {\r\n        require(msg.sender == owner && !feeCollectorLocked);    // Check if sender is owner and feeCollector address is not locked\r\n        feeCollector = collector;                               // Update feeCollector address\r\n    }\r\n    \r\n    /** @notice Allows the owner to lock the feeCollector address\r\n    */\r\n    function lockFeeCollector() external {\r\n        require(msg.sender == owner);                           // Check if sender is owner\r\n        feeCollectorLocked = true;                              // Lock feeCollector address\r\n    }\r\n    \r\n    /** @notice Get the feeCollectors address\r\n      * @return The feeCollectors address\r\n      */\r\n    function getFeeCollector() public view returns (address){\r\n        return feeCollector;\r\n    }\r\n\r\n    /** @notice Allows an arbiter or feeCollector to directly withdraw his own funds (would allow e.g. a fee distribution contract the withdrawal of collected fees)\r\n      * @param  token   The token to withdraw\r\n      * @param  amount  The amount of tokens to withdraw\r\n    */\r\n    function directWithdrawal(address token, uint256 amount) external returns(bool){\r\n        if (\r\n            (\r\n                msg.sender == feeCollector                        // Check if the sender is the feeCollector\r\n                || arbiters[msg.sender]                           // Check if the sender is an arbiter\r\n            )\r\n            && balances[token][msg.sender] >= amount              // Check if feeCollector has the sufficient balance\r\n        ){\r\n            balances[token][msg.sender] -= amount;                // Substract the feeCollectors balance\r\n            \r\n            if(token == address(0)){                              // Is the withdrawal token ETH\r\n                require(\r\n                    msg.sender.send(amount),                      // Withdraw ETH\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(token).transfer(msg.sender, amount);        // Withdraw ERC20\r\n                require(                                          // Revert if the withdrawal failed\r\n                    checkERC20TransferSuccess(),\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n            \r\n            emit LogDirectWithdrawal(msg.sender, token, amount);     // emit LogDirectWithdrawal event\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// dexBlueReserve\r\ncontract dexBlueReserve{\r\n    // insured trade function with fixed outcome\r\n    function trade(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public payable returns(bool success){}\r\n    \r\n    // insured trade function with fixed outcome, passes additional data to the reserve\r\n    function tradeWithData(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount, bytes32[] memory data) public payable returns(bool success){}\r\n    \r\n    // offer the reserve to enter a trade a a taker\r\n    function offer(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public returns(bool accept){}\r\n    \r\n    // offer the reserve to enter a trade a a taker, passes additional data to the reserve\r\n    function offerWithData(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount, bytes32[] memory data) public returns(bool accept){}\r\n    \r\n    // callback function, to inform the reserve that an offer has been accepted by the maker reserve\r\n    function offerExecuted(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public{}\r\n\r\n    // uninsured swap\r\n    function swap(address sell_token, uint256 sell_amount, address buy_token,  uint256 min_output) public payable returns(uint256 output){}\r\n    \r\n    // get output amount of swap\r\n    function getSwapOutput(address sell_token, uint256 sell_amount, address buy_token) public view returns(uint256 output){}\r\n}\r\n\r\n// Standart ERC20 token interface to interact with ERC20 token contracts\r\n// To support badly implemented tokens (which dont return a boolean on the transfer functions)\r\n// we have to expect a badly implemented token and then check with checkERC20TransferSuccess() whether the transfer succeeded\r\n\r\ncontract Token {\r\n    /** @return total amount of tokens\r\n      */\r\n    function totalSupply() view public returns (uint256 supply) {}\r\n\r\n    /** @param _owner The address from which the balance will be retrieved\r\n      * @return The balance\r\n      */\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\r\n\r\n    /** @notice send `_value` token to `_to` from `msg.sender`\r\n      * @param  _to     The address of the recipient\r\n      * @param  _value  The amount of tokens to be transferred\r\n      * @return whether the transfer was successful or not\r\n      */\r\n    function transfer(address _to, uint256 _value) public {}\r\n\r\n    /** @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n      * @param  _from   The address of the sender\r\n      * @param  _to     The address of the recipient\r\n      * @param  _value  The amount of tokens to be transferred\r\n      * @return whether the transfer was successful or not\r\n      */\r\n    function transferFrom(address _from, address _to, uint256 _value)  public {}\r\n\r\n    /** @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n      * @param  _spender The address of the account able to transfer the tokens\r\n      * @param  _value   The amount of wei to be approved for transfer\r\n      * @return whether the approval was successful or not\r\n      */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n    /** @param  _owner   The address of the account owning tokens\r\n      * @param  _spender The address of the account able to transfer the tokens\r\n      * @return Amount of remaining tokens allowed to spend\r\n      */\r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint256 public decimals;\r\n    string public name;\r\n}\r\n\r\n// Wrapped Ether interface\r\ncontract WETH is Token{\r\n    function deposit() public payable {}\r\n    function withdraw(uint256 amount) public {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"tradeInput\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"makerData\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"takerData\",\"type\":\"bytes32[]\"}],\"name\":\"settleReserveReserveTradeWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"tradeInput\",\"type\":\"tuple\"}],\"name\":\"settleReserveReserveTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.RingTradeInputPacked\",\"name\":\"packed\",\"type\":\"tuple\"}],\"name\":\"ringTradeFromInput\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isReserve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"giveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"giveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"internalType\":\"struct dexBlueStructs.RingTrade\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked\",\"name\":\"orderInput\",\"type\":\"tuple\"}],\"name\":\"orderFromInput\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"signee\",\"type\":\"address\"}],\"internalType\":\"struct dexBlueStructs.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked[]\",\"name\":\"orderInput\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked[]\",\"name\":\"tradeInput\",\"type\":\"tuple[]\"}],\"name\":\"batchSettleTrades\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min_output\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"}],\"name\":\"getBestReserve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"packed\",\"type\":\"tuple\"}],\"name\":\"reserveTradeFromInput\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderRebate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveRebate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orderIsMaker\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"internalType\":\"struct dexBlueStructs.ReserveTrade\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min_output\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapWithReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLastBlockedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked\",\"name\":\"orderInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"tradeInput\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"}],\"name\":\"settleReserveTradeWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"packed\",\"type\":\"tuple\"}],\"name\":\"reserveReserveTradeFromInput\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"internalType\":\"struct dexBlueStructs.ReserveReserveTrade\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTokenFromIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked[]\",\"name\":\"orderInput\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.RingTradeInputPacked[]\",\"name\":\"tradeInput\",\"type\":\"tuple[]\"}],\"name\":\"settleRingTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getReserveFromIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"packed\",\"type\":\"tuple\"}],\"name\":\"tradeFromInput\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerRebate\",\"type\":\"uint256\"}],\"internalType\":\"struct dexBlueStructs.Trade\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked\",\"name\":\"makerOrderInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked\",\"name\":\"takerOrderInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"tradeInput\",\"type\":\"tuple\"}],\"name\":\"settleTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"}],\"name\":\"getSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"getReserveIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked[]\",\"name\":\"orderInput\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.RingTradeInputPacked[]\",\"name\":\"tradeInput\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"data\",\"type\":\"bytes32[][]\"}],\"name\":\"settleRingTradeWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getBlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.OrderInputPacked\",\"name\":\"orderInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"packedInput1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"packedInput3\",\"type\":\"bytes32\"}],\"internalType\":\"struct dexBlueStructs.TradeInputPacked\",\"name\":\"tradeInput\",\"type\":\"tuple\"}],\"name\":\"settleReserveTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"takerAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"}],\"name\":\"LogTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"soldAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"boughtAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtAmount\",\"type\":\"uint256\"}],\"name\":\"LogSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogTradeFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDirectWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogBlockedForSingleSigWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSingleSigWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"LogOrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LogDelegateStatus\",\"type\":\"event\"}]","ContractName":"dexBlueSettlementModule","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://d1f6bbc3d8948583de50f12fac7d6fa06c7d1b43a6692ae6beb44fb98fc88002"}]}