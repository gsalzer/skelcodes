{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract SoloMarginContract {\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n    \r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n    \r\n     enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n    \r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n    \r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n    \r\n    \r\n    \r\n        function operate(Info[] memory accounts, ActionArgs[] memory actions\r\n    )\r\n        public;\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract DSMath{\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getSoloAddress() public pure returns (address addr) {\r\n        addr = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ETH/ERC20 to user\r\n     */\r\n    function transferToken(address erc20) internal {\r\n        if (erc20 == getAddressETH()) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20Interface erc20Contract = ERC20Interface(erc20);\r\n            uint srcBal = erc20Contract.balanceOf(address(this));\r\n            if (srcBal > 0) {\r\n                erc20Contract.transfer(msg.sender, srcBal);\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev setting allowance to compound for the \"user proxy\" if required\r\n     */\r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        ERC20Interface erc20Contract = ERC20Interface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt > tokenAllowance) {\r\n            erc20Contract.approve(to, 2**255);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract dydxResolver is Helpers {\r\n    event LogDeposit(address erc20Addr);\r\n    \r\n    function Deposit(SoloMarginContract.Info[] memory accounts, SoloMarginContract.ActionArgs[] memory actions, address erc20Addr) public {\r\n        SoloMarginContract solo = SoloMarginContract(getSoloAddress());\r\n        solo.operate(accounts, actions);\r\n        emit LogDeposit(erc20Addr);\r\n    }\r\n}\r\n\r\n\r\ncontract InstaDYDX is dydxResolver {\r\n\r\n    uint public version;\r\n\r\n    /**\r\n     * @dev setting up variables on deployment\r\n     * 1...2...3 versioning in each subsequent deployments\r\n     */\r\n    constructor(uint _version) public {\r\n        version = _version;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSoloAddress\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressETH\",\"outputs\":[{\"name\":\"eth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"actionType\",\"type\":\"uint8\"},{\"name\":\"accountId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"sign\",\"type\":\"bool\"},{\"name\":\"denomination\",\"type\":\"uint8\"},{\"name\":\"ref\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"amount\",\"type\":\"tuple\"},{\"name\":\"primaryMarketId\",\"type\":\"uint256\"},{\"name\":\"secondaryMarketId\",\"type\":\"uint256\"},{\"name\":\"otherAddress\",\"type\":\"address\"},{\"name\":\"otherAccountId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"erc20Addr\",\"type\":\"address\"}],\"name\":\"Deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20Addr\",\"type\":\"address\"}],\"name\":\"LogDeposit\",\"type\":\"event\"}]","ContractName":"InstaDYDX","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://2c2cbc290d77cb7c74d1fd7bf3f6867da04bb270f73643574d2f4474e02d93cc"}]}