{"status":"1","message":"OK","result":[{"SourceCode":"{\"DQICoin.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\u0027./Ownable.sol\\u0027;\\nimport \\u0027./Pausable.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./ERC20.sol\\u0027;\\n\\n\\ncontract DetailedERC20 is ERC20 {\\n  string public name;\\n  string public symbol;\\n  uint8 public decimals;\\n  uint256 public unlocktime;\\n\\n  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\\n    name = _name;\\n    symbol = _symbol;\\n    decimals = _decimals;\\n  }\\n}\\n\\ncontract DQICoin is Pausable, DetailedERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping(address =\\u003e uint256) balances;\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n  mapping(address =\\u003e uint256) public lockedBalances;\\n\\n  address public crowdsaleContract = 0;\\n\\n  function DQICoin() DetailedERC20(\\\"DotQii\\\", \\\"DQI\\\", 18) public {\\n    unlocktime = 0;\\n    totalSupply = 300 * (10**6) * 10**uint256(decimals);  // 300 million\\n  }\\n\\n  function setCrowdsaleContract(address crowdsale) onlyOwner public {\\n    crowdsaleContract = crowdsale;\\n  }\\n\\n  modifier timeLock(address from, uint value) {\\n    if (now \\u003c unlocktime) {\\n      require(value \\u003c= balances[from] - lockedBalances[from]);\\n    } else {\\n      lockedBalances[from] = 0;\\n    }\\n    _;\\n  }\\n\\n  function addToBalances(address _person,uint256 value) public {\\n    require(msg.sender == crowdsaleContract);\\n    balances[_person] = balances[_person].add(value);\\n    Transfer(address(this), _person, value);\\n  }\\n\\n  function transfer(address _to, uint256 _value) timeLock(msg.sender, _value) whenNotPaused public returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  function transferToLockedBalance(address _to, uint256 _value) whenNotPaused public returns (bool) {\\n    require(msg.sender == crowdsaleContract);\\n    if (transfer(_to, _value)) {\\n      lockedBalances[_to] = lockedBalances[_to].add(_value);\\n      return true;\\n    }\\n  }\\n\\n  function balanceOf(address _owner) public view returns (uint256 balance) {\\n    return balances[_owner];\\n  }\\n\\n\\n  function transferFrom(address _from, address _to, uint256 _value) public timeLock(_from, _value) whenNotPaused returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\\n    allowed[msg.sender][_spender] = _value;\\n    Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  function allowance(address _owner, address _spender) public view returns (uint256) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\\n    uint oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  function updateUnlocktime(uint newtime) onlyOwner public {\\n    unlocktime = newtime;\\n  }\\n}\"},\"ERC20.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./ERC20Interface.sol\\\";\\n\\ncontract ERC20 is ERC20Interface {\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    uint256 public totalSupply;\\n\\n    // Function to access name of token .\\n    function name() public view returns (string _name) {\\n        return name;\\n    }\\n    // Function to access symbol of token .\\n    function symbol() public view returns (string _symbol) {\\n        return symbol;\\n    }\\n    // Function to access decimals of token .\\n    function decimals() public view returns (uint8 _decimals) {\\n        return decimals;\\n    }\\n    // Function to access total supply of tokens .\\n    function totalSupply() public view returns (uint256 _totalSupply) {\\n        return totalSupply;\\n    }\\n\\n    mapping (address =\\u003e uint256) balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n    function balanceOf(address participant) public constant returns (uint256 balance) {\\n        return balances[participant];\\n    }\\n\\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) {\\n        require(_to != address(0));\\n        // documentation says transfer of 0 must be treated as a transfer and fire the transfer event\\n        require(balances[msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0);\\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\\n        balances[_to] = safeAdd(balances[_to], _value);\\n        emit Transfer(msg.sender, _to, _value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool success) {\\n        require(_to != address(0));\\n        require(balances[_from] \\u003e= _value \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0);\\n        balances[_from] = safeSub(balances[_from], _value);\\n        balances[_to] = safeAdd(balances[_to], _value);\\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\\n        emit Transfer(_from, _to, _value);\\n\\n        return true;\\n    }\\n\\n \\t// To change the approve amount you first have to reduce the addresses\\u0027\\n    //  allowance to zero by calling \\u0027approve(_spender, 0)\\u0027 if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool success) {\\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n\\n        return true;\\n    }\\n\\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) public returns (bool success) {\\n        require(allowed[msg.sender][_spender] == _oldValue);\\n        allowed[msg.sender][_spender] = _newValue;\\n        emit Approval(msg.sender, _spender, _newValue);\\n\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    // mitigate short address attack\\n    // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\\n    // TODO: doublecheck implication of \\u003e= compared to ==\\n    modifier onlyPayloadSize(uint numWords) {\\n        assert(msg.data.length \\u003e= numWords * 32 + 4);\\n        _;\\n    }\\n\\n    function safeMul(uint a, uint b) internal pure returns (uint) {\\n        uint c = a * b;\\n        assert(a == 0 || c / a == b);\\n        return c;\\n    }\\n\\n    function safeSub(uint a, uint b) internal pure returns (uint) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        assert(c\\u003e=a \\u0026\\u0026 c\\u003e=b);\\n        return c;\\n    }\\n}\"},\"ERC20Interface.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ncontract ERC20Interface  {\\n    function balanceOf(address _owner) public constant returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\\n    function totalSupply() public constant returns (uint256);\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  function Ownable() public {\\n    owner = msg.sender;\\n  }\\n\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyOwner whenNotPaused public {\\n    paused = true;\\n    Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() onlyOwner whenPaused public {\\n    paused = false;\\n    Unpause();\\n  }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToLockedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_person\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addToBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newtime\",\"type\":\"uint256\"}],\"name\":\"updateUnlocktime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlocktime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"changeApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DQICoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4014ce1a96f2fb46ef3810be4ee2ebe8d7aba6ac65df4f10a9285fc6c34a7065"}]}