{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/Reversi.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\nlibrary Reversi {\r\n    // event DebugBool(bool boolean);\r\n    // event DebugBoard(bytes16 board);\r\n    // event DebugUint(uint u);\r\n    uint8 constant BLACK = 1; //0b01 //0x1\r\n    uint8 constant WHITE = 2; //0b10 //0x2\r\n    uint8 constant EMPTY = 3; //0b11 //0x3\r\n\r\n    struct Game {\r\n        bool error;\r\n        bool complete;\r\n        bool symmetrical;\r\n        bool RotSym;\r\n        bool Y0Sym;\r\n        bool X0Sym;\r\n        bool XYSym;\r\n        bool XnYSym;\r\n        bytes16 board;\r\n        bytes28 first32Moves;\r\n        bytes28 lastMoves;\r\n\r\n        uint8 currentPlayer;\r\n        uint8 moveKey;\r\n        uint8 blackScore;\r\n        uint8 whiteScore;\r\n        // string msg;\r\n    }\r\n\r\n\r\n    function isValid (bytes28[2] moves) public pure returns (bool) {\r\n        Game memory game = playGame(moves);\r\n        if (game.error) {\r\n            return false;\r\n        } else if (!game.complete) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function getGame (bytes28[2] moves) public pure returns (bool error, bool complete, bool symmetrical, bytes16 board, uint8 currentPlayer, uint8 moveKey) {\r\n      Game memory game = playGame(moves);\r\n        return (\r\n            game.error,\r\n            game.complete,\r\n            game.symmetrical,\r\n            game.board,\r\n            game.currentPlayer,\r\n            game.moveKey\r\n            // game.msg\r\n        );\r\n    }\r\n\r\n    function showColors () public pure returns(uint8, uint8, uint8) {\r\n        return (EMPTY, BLACK, WHITE);\r\n    }\r\n\r\n    function playGame (bytes28[2] moves) internal pure returns (Game)  {\r\n        Game memory game;\r\n\r\n        game.first32Moves = moves[0];\r\n        game.lastMoves = moves[1];\r\n        game.moveKey = 0;\r\n        game.blackScore = 2;\r\n        game.whiteScore = 2;\r\n\r\n        game.error = false;\r\n        game.complete = false;\r\n        game.currentPlayer = BLACK;\r\n\r\n\r\n        // game.board = bytes16(10625432672847758622720); // completely empty board\r\n        game.board = bytes16(340282366920938456379662753540715053055); // empty board except for center pieces\r\n\r\n        bool skip;\r\n        uint8 move;\r\n        uint8 col;\r\n        uint8 row;\r\n        uint8 i;\r\n        bytes28 currentMoves;\r\n\r\n        for (i = 0; i < 60 && !skip; i++) {\r\n            currentMoves = game.moveKey < 32 ? game.first32Moves : game.lastMoves;\r\n            move = readMove(currentMoves, game.moveKey % 32, 32);\r\n            (col, row) = convertMove(move);\r\n            skip = !validMove(move);\r\n            if (i == 0 && (col != 2 || row != 3)) {\r\n                skip = true; // this is to force the first move to always be C4 to avoid repeatable boards via mirroring translations\r\n                game.error = true;\r\n            }\r\n            if (!skip && col < 8 && row < 8 && col >= 0 && row >= 0) {\r\n                // game.msg = \"make a move\";\r\n                game = makeMove(game, col, row);\r\n                game.moveKey = game.moveKey + 1;\r\n                if (game.error) {\r\n                    game.error = false;\r\n                    // maybe player has no valid moves and must pass\r\n                    if (game.currentPlayer == BLACK) {\r\n                        game.currentPlayer = WHITE;\r\n                    } else {\r\n                        game.currentPlayer = BLACK;\r\n                    }\r\n                    game = makeMove(game, col, row);\r\n                    if (game.error) {\r\n                        game.error = true;\r\n                        skip = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!game.error) {\r\n            game.error = false;\r\n            game = isComplete(game);\r\n            game = isSymmetrical(game);\r\n        }\r\n        return game;\r\n    }\r\n\r\n    function makeMove (Game memory game, uint8 col, uint8 row) internal pure returns (Game)  {\r\n        // square is already occupied\r\n        if (returnTile(game.board, col, row) != EMPTY){\r\n            game.error = true;\r\n            // game.msg = \"Invalid Game (square is already occupied)\";\r\n            return game;\r\n        }\r\n        int8[2][8] memory possibleDirections;\r\n        uint8  possibleDirectionsLength;\r\n        (possibleDirections, possibleDirectionsLength) = getPossibleDirections(game, col, row);\r\n        // no valid directions\r\n        if (possibleDirectionsLength == 0) {\r\n            game.error = true;\r\n            // game.msg = \"Invalid Game (doesnt border other tiles)\";\r\n            return game;\r\n        }\r\n\r\n        bytes28 newFlips;\r\n        uint8 newFlipsLength;\r\n        uint8 newFlipCol;\r\n        uint8 newFlipRow;\r\n        uint8 j;\r\n        bool valid = false;\r\n        for (uint8 i = 0; i < possibleDirectionsLength; i++) {\r\n            delete newFlips;\r\n            delete newFlipsLength;\r\n            (newFlips, newFlipsLength) = traverseDirection(game, possibleDirections[i], col, row);\r\n            for (j = 0; j < newFlipsLength; j++) {\r\n                if (!valid) valid = true;\r\n                (newFlipCol, newFlipRow) = convertMove(readMove(newFlips, j, newFlipsLength));\r\n                game.board = turnTile(game.board, game.currentPlayer, newFlipCol, newFlipRow);\r\n                if (game.currentPlayer == WHITE) {\r\n                    game.whiteScore += 1;\r\n                    game.blackScore -= 1;\r\n                } else {\r\n                    game.whiteScore -= 1;\r\n                    game.blackScore += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        //no valid flips in directions\r\n        if (valid) {\r\n            game.board = turnTile(game.board, game.currentPlayer, col, row);\r\n            if (game.currentPlayer == WHITE) {\r\n                game.whiteScore += 1;\r\n            } else {\r\n                game.blackScore += 1;\r\n            }\r\n        } else {\r\n            game.error = true;\r\n            // game.msg = \"Invalid Game (doesnt flip any other tiles)\";\r\n            return game;\r\n        }\r\n\r\n        // switch players\r\n        if (game.currentPlayer == BLACK) {\r\n            game.currentPlayer = WHITE;\r\n        } else {\r\n            game.currentPlayer = BLACK;\r\n        }\r\n        return game;\r\n    }\r\n\r\n    function getPossibleDirections (Game memory game, uint8 col, uint8 row) internal pure returns(int8[2][8], uint8){\r\n\r\n        int8[2][8] memory possibleDirections;\r\n        uint8 possibleDirectionsLength = 0;\r\n        int8[2][8] memory dirs = [\r\n            [int8(-1), int8(0)], // W\r\n            [int8(-1), int8(1)], // SW\r\n            [int8(0), int8(1)], // S\r\n            [int8(1), int8(1)], // SE\r\n            [int8(1), int8(0)], // E\r\n            [int8(1), int8(-1)], // NE\r\n            [int8(0), int8(-1)], // N\r\n            [int8(-1), int8(-1)] // NW\r\n        ];\r\n        int8 focusedRowPos;\r\n        int8 focusedColPos;\r\n        int8[2] memory dir;\r\n        uint8 testSquare;\r\n\r\n        for (uint8 i = 0; i < 8; i++) {\r\n            dir = dirs[i];\r\n            focusedColPos = int8(col) + dir[0];\r\n            focusedRowPos = int8(row) + dir[1];\r\n\r\n            // if tile is off the board it is not a valid move\r\n            if (!(focusedRowPos > 7 || focusedRowPos < 0 || focusedColPos > 7 || focusedColPos < 0)) {\r\n                testSquare = returnTile(game.board, uint8(focusedColPos), uint8(focusedRowPos));\r\n\r\n                // if the surrounding tile is current color or no color it can\"t be part of a capture\r\n                if (testSquare != game.currentPlayer) {\r\n                    if (testSquare != EMPTY) {\r\n                        possibleDirections[possibleDirectionsLength] = dir;\r\n                        possibleDirectionsLength++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return (possibleDirections, possibleDirectionsLength);\r\n    }\r\n\r\n    function traverseDirection (Game memory game, int8[2] dir, uint8 col, uint8 row) internal pure returns(bytes28, uint8) {\r\n        bytes28 potentialFlips;\r\n        uint8 potentialFlipsLength = 0;\r\n\r\n        if (game.currentPlayer == BLACK) {\r\n            uint8 opponentColor = WHITE;\r\n        } else {\r\n            opponentColor = BLACK;\r\n        }\r\n\r\n        // take one step at a time in this direction\r\n        // ignoring the first step look for the same color as your tile\r\n        bool skip = false;\r\n        int8 testCol;\r\n        int8 testRow;\r\n        uint8 tile;\r\n        for (uint8 j = 1; j < 9; j++) {\r\n            if (!skip) {\r\n                testCol = (int8(j) * dir[0]) + int8(col);\r\n                testRow = (int8(j) * dir[1]) + int8(row);\r\n                // ran off the board before hitting your own tile\r\n                if (testCol > 7 || testCol < 0 || testRow > 7 || testRow < 0) {\r\n                    delete potentialFlips;\r\n                    potentialFlipsLength = 0;\r\n                    skip = true;\r\n                } else{\r\n\r\n                    tile = returnTile(game.board, uint8(testCol), uint8(testRow));\r\n\r\n                    if (tile == opponentColor) {\r\n                        // if tile is opposite color it could be flipped, so add to potential flip array\r\n                        (potentialFlips, potentialFlipsLength) = addMove(potentialFlips, potentialFlipsLength, uint8(testCol), uint8(testRow));\r\n                    } else if (tile == game.currentPlayer && j > 1) {\r\n                        // hit current players tile which means capture is complete\r\n                        skip = true;\r\n                    } else {\r\n                        // either hit current players own color before hitting an opponent\"s\r\n                        // or hit an empty space\r\n                        delete potentialFlips;\r\n                        delete potentialFlipsLength;\r\n                        skip = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return (potentialFlips, potentialFlipsLength);\r\n    }\r\n\r\n    function isComplete (Game memory game) internal pure returns (Game) {\r\n\r\n        if (game.moveKey == 60) {\r\n            // game.msg = \"good game\";\r\n            game.complete = true;\r\n            return game;\r\n        } else {\r\n            uint8[2][60] memory empties;\r\n            uint8 emptiesLength = 0;\r\n            for (uint8 i = 0; i < 64; i++) {\r\n                uint8 tile = returnTile(game.board, ((i - (i % 8)) / 8), (i % 8));\r\n                if (tile == EMPTY) {\r\n                    empties[emptiesLength] = [((i - (i % 8)) / 8), (i % 8)];\r\n                    emptiesLength++;\r\n                }\r\n            }\r\n            bool validMovesRemains = false;\r\n            if (emptiesLength > 0) {\r\n                bytes16 board = game.board;\r\n                uint8[2] memory move;\r\n                for (i = 0; i < emptiesLength && !validMovesRemains; i++) {\r\n                    move = empties[i];\r\n\r\n                    game.currentPlayer = BLACK;\r\n                    game.error = false;\r\n                    game.board = board;\r\n                    game = makeMove(game, move[0], move[1]);\r\n                    if (!game.error) {\r\n                        validMovesRemains = true;\r\n                    }\r\n                    game.currentPlayer = WHITE;\r\n                    game.error = false;\r\n                    game.board = board;\r\n                    game = makeMove(game, move[0], move[1]);\r\n                    if (!game.error) {\r\n                        validMovesRemains = true;\r\n                    }\r\n                }\r\n                game.board = board;\r\n            }\r\n            if (validMovesRemains) {\r\n                game.error = true;\r\n                // game.msg = \"Invalid Game (moves still available)\";\r\n            } else {\r\n                // game.msg = \"good game\";\r\n                game.complete = true;\r\n                game.error = false;\r\n            }\r\n        }\r\n        return game;\r\n    }\r\n\r\n    function isSymmetrical (Game memory game) internal pure returns (Game) {\r\n        bool RotSym = true;\r\n        bool Y0Sym = true;\r\n        bool X0Sym = true;\r\n        bool XYSym = true;\r\n        bool XnYSym = true;\r\n        for (uint8 i = 0; i < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); i++) {\r\n            for (uint8 j = 0; j < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); j++) {\r\n\r\n                // rotational symmetry\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), (7 - j))) {\r\n                    RotSym = false;\r\n                }\r\n                // symmetry on y = 0\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, i, (7 - j))) {\r\n                    Y0Sym = false;\r\n                }\r\n                // symmetry on x = 0\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), j)) {\r\n                    X0Sym = false;\r\n                }\r\n                // symmetry on x = y\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - j), (7 - i))) {\r\n                    XYSym = false;\r\n                }\r\n                // symmetry on x = -y\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, j, i)) {\r\n                    XnYSym = false;\r\n                }\r\n            }\r\n        }\r\n        if (RotSym || Y0Sym || X0Sym || XYSym || XnYSym) {\r\n            game.symmetrical = true;\r\n            game.RotSym = RotSym;\r\n            game.Y0Sym = Y0Sym;\r\n            game.X0Sym = X0Sym;\r\n            game.XYSym = XYSym;\r\n            game.XnYSym = XnYSym;\r\n        }\r\n        return game;\r\n    }\r\n\r\n\r\n\r\n    // Utilities\r\n\r\n    function returnSymmetricals (bool RotSym, bool Y0Sym, bool X0Sym, bool XYSym, bool XnYSym) public view returns (uint256) {\r\n        uint256 symmetries = (RotSym ? 1  : 0) << 1;\r\n        symmetries = (symmetries & (Y0Sym ? 1 : 0)) << 1;\r\n        symmetries = (symmetries & (X0Sym ? 1 : 0)) << 1;\r\n        symmetries = (symmetries & (XYSym ? 1 : 0)) << 1;\r\n        symmetries = symmetries & (XnYSym ? 1 : 0);\r\n        return symmetries;\r\n    }\r\n\r\n\r\n    function returnBytes (bytes16 board, uint8 col, uint8 row) internal pure returns (bytes16) {\r\n        uint128 push = posToPush(col, row);\r\n        return (board >> push) & bytes16(3);\r\n    }\r\n\r\n    function turnTile (bytes16 board, uint8 color, uint8 col, uint8 row) internal pure returns (bytes16){\r\n        if (col > 7) revert();\r\n        if (row > 7) revert();\r\n        uint128 push = posToPush(col, row);\r\n        bytes16 mask = bytes16(3) << push;// 0b00000011 (ones)\r\n\r\n        board = ((board ^ mask) & board);\r\n\r\n        return board | (bytes16(color) << push);\r\n    }\r\n\r\n    function returnTile (bytes16 board, uint8 col, uint8 row) internal pure returns (uint8){\r\n        uint128 push = posToPush(col, row);\r\n        bytes16 tile = (board >> push ) & bytes16(3);\r\n        return uint8(tile); // returns 2\r\n    }\r\n\r\n    function posToPush (uint8 col, uint8 row) internal pure returns (uint128){\r\n        return uint128(((64) - ((8 * col) + row + 1)) * 2);\r\n    }\r\n\r\n    function readMove (bytes28 moveSequence, uint8 moveKey, uint8 movesLength) public pure returns(uint8) {\r\n        bytes28 mask = bytes28(127);\r\n        uint8 push = (movesLength * 7) - (moveKey * 7) - 7;\r\n        return uint8((moveSequence >> push) & mask);\r\n    }\r\n\r\n    function addMove (bytes28 moveSequence, uint8 movesLength, uint8 col, uint8 row) internal pure returns (bytes28, uint8) {\r\n        bytes28 move = bytes28(col + (row * 8) + 64);\r\n        moveSequence = moveSequence << 7;\r\n        moveSequence = moveSequence | move;\r\n        movesLength++;\r\n        return (moveSequence, movesLength);\r\n    }\r\n\r\n    function validMove (uint8 move) internal pure returns(bool) {\r\n        return move >= 64;\r\n    }\r\n\r\n    function convertMove (uint8 move) public pure returns(uint8, uint8) {\r\n        move = move - 64;\r\n        uint8 col = move % 8;\r\n        uint8 row = (move - col) / 8;\r\n        return (col, row);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"moves\",\"type\":\"bytes28[2]\"}],\"name\":\"getGame\",\"outputs\":[{\"name\":\"error\",\"type\":\"bool\"},{\"name\":\"complete\",\"type\":\"bool\"},{\"name\":\"symmetrical\",\"type\":\"bool\"},{\"name\":\"board\",\"type\":\"bytes16\"},{\"name\":\"currentPlayer\",\"type\":\"uint8\"},{\"name\":\"moveKey\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moves\",\"type\":\"bytes28[2]\"}],\"name\":\"isValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showColors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"convertMove\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"RotSym\",\"type\":\"bool\"},{\"name\":\"Y0Sym\",\"type\":\"bool\"},{\"name\":\"X0Sym\",\"type\":\"bool\"},{\"name\":\"XYSym\",\"type\":\"bool\"},{\"name\":\"XnYSym\",\"type\":\"bool\"}],\"name\":\"returnSymmetricals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moveSequence\",\"type\":\"bytes28\"},{\"name\":\"moveKey\",\"type\":\"uint8\"},{\"name\":\"movesLength\",\"type\":\"uint8\"}],\"name\":\"readMove\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Reversi","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fdf2ee2384cc9dc29002c3ab11c1aa48e48cc63ac1bc4c5b4d17e5a431e8499c"}]}