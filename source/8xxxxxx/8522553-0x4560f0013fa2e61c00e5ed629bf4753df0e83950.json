{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Math.sol\\\";\\r\\n\\r\\n\\r\\ncontract ERC20 is IERC20 {\\r\\n    using Math for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) public balanceOf;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    function transfer(address to, uint256 amount) public returns (bool) {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\\r\\n        _transfer(from, to, amount);\\r\\n        _approve(from, msg.sender, allowance[from][msg.sender].sub(amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedAmount) public returns (bool) {\\r\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedAmount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedAmount) public returns (bool) {\\r\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedAmount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal {\\r\\n        require(to != address(0), \\\"transfer to the zero address\\\");\\r\\n\\r\\n        balanceOf[from] = balanceOf[from].sub(amount);\\r\\n        balanceOf[to] = balanceOf[to].add(amount);\\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal {\\r\\n        require(spender != address(0), \\\"approve to the zero address\\\");\\r\\n\\r\\n        allowance[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"mint to the zero address\\\");\\r\\n\\r\\n        totalSupply = totalSupply.add(amount);\\r\\n        balanceOf[account] = balanceOf[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n}\\r\\n\"},\"Exchange.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract Exchange is Ownable {\\r\\n    event Collect(address indexed from, uint256 amount, bytes32 desc);\\r\\n    event Withdraw(address indexed from, address indexed to, uint256 amount, bytes32 desc);\\r\\n\\r\\n    IERC20 public token;\\r\\n\\r\\n    constructor (address token_) public {\\r\\n        token = IERC20(token_);\\r\\n    }\\r\\n\\r\\n    function withdraw(address from, address to, uint256 amount, bytes32 desc) public onlyOwner {\\r\\n        token.transfer(to, amount);\\r\\n        emit Withdraw(from, to, amount, desc);\\r\\n    }\\r\\n\\r\\n    function collect(address from, uint256 amount, bytes32 desc) public {\\r\\n        token.transferFrom(from, address(this), amount);\\r\\n        emit Collect(from, amount, desc);\\r\\n    }\\r\\n\\r\\n    function batchCollect(address[] memory from, uint256[] memory amount, bytes32[] memory desc) public {\\r\\n        require(from.length == amount.length \\u0026\\u0026 from.length == desc.length, \\\"array length mismatch\\\");\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c from.length; i++) {\\r\\n            token.transferFrom(from[i], address(this), amount[i]);\\r\\n            emit Collect(from[i], amount[i], desc[i]);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"},\"Lockup.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract Lockup {\\r\\n    address public owner;\\r\\n    uint256 public lockupExpiryDate;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"msg.sender is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(uint256 lockupExpiryDate_) public {\\r\\n        owner = msg.sender;\\r\\n        lockupExpiryDate = lockupExpiryDate_;\\r\\n    }\\r\\n\\r\\n    function transfer(address token, address to, uint256 amount) public onlyOwner {\\r\\n        require(now \\u003e lockupExpiryDate, \\\"lockup period is not over\\\");\\r\\n        IERC20(token).transfer(to, amount);\\r\\n    }\\r\\n}\\r\\n\"},\"Math.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\nlibrary Math {\\r\\n     function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(a \\u003e= b, \\\"subtraction underflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n}\\r\\n\"},\"Nabu.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./Token.sol\\\";\\r\\nimport \\\"./Exchange.sol\\\";\\r\\nimport \\\"./Lockup.sol\\\";\\r\\n\\r\\n\\r\\ncontract Nabu is Ownable {\\r\\n    using Math for uint256;\\r\\n\\r\\n    event TransferReserve(address to, uint256 amount, bytes32 desc);\\r\\n    event TransferTeamShare(address to, uint256 amount, bytes32 desc);\\r\\n\\r\\n    Token public token;\\r\\n    Exchange public sportsplex;\\r\\n    Lockup public team;\\r\\n\\r\\n    constructor () public {\\r\\n        token = new Token();\\r\\n        sportsplex = new Exchange(address(token));\\r\\n\\r\\n        uint256 startDate = 1565013600; // Monday August 05, 2019 10:00:00 (am) in time zone America/New York (EDT)\\r\\n        team = new Lockup(startDate + 550 days); // Friday February 05, 2021 09:00:00 (am) in time zone America/New York (EST)\\r\\n\\r\\n        uint256 totalSupply = token.totalSupply();\\r\\n        token.transfer(address(sportsplex), totalSupply.mul(60).div(100));\\r\\n        token.transfer(address(team), totalSupply.mul(15).div(100));\\r\\n\\r\\n        sportsplex.transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    function transferReserve(address to, uint256 amount, bytes32 desc) public onlyOwner {\\r\\n        token.transfer(to, amount);\\r\\n        emit TransferReserve(to, amount, desc);\\r\\n    }\\r\\n\\r\\n    function transferTeamShare(address to, uint256 amount, bytes32 desc) public onlyOwner {\\r\\n        team.transfer(address(token), to, amount);\\r\\n        emit TransferTeamShare(to, amount, desc);\\r\\n    }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\ncontract Ownable {\\r\\n    event TransferOwnership(address previousOwner, address newOwner);\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"msg.sender is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor () internal {\\r\\n        owner = msg.sender;\\r\\n        emit TransferOwnership(address(0), owner);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        emit TransferOwnership(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"},\"Token.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract Token is ERC20 {\\r\\n    string public constant name = \\\"SportsplexToken\\\";\\r\\n    string public constant symbol = \\\"SPX\\\";\\r\\n    uint8  public constant decimals = 8;\\r\\n\\r\\n    constructor() public {\\r\\n        uint256 supply = (10 ** 9);\\r\\n        _mint(msg.sender, supply.mul(10 ** uint256(decimals)));\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"desc\",\"type\":\"bytes32\"}],\"name\":\"transferReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"internalType\":\"contract Lockup\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"desc\",\"type\":\"bytes32\"}],\"name\":\"transferTeamShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sportsplex\",\"outputs\":[{\"internalType\":\"contract Exchange\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"desc\",\"type\":\"bytes32\"}],\"name\":\"TransferReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"desc\",\"type\":\"bytes32\"}],\"name\":\"TransferTeamShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"}]","ContractName":"Nabu","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"10000000","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://00d87837d36b21f20b6afa2fb76a5c24f8db8c169d089a35a29d968543533b42"}]}