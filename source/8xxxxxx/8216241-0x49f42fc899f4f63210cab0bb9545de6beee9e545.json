{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n\n}\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver{\n    event AddrChanged(bytes32 indexed node, address a);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function addr(bytes32 node) external view returns (address);\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function dnsrr(bytes32 node) external view returns (bytes memory);\n    function name(bytes32 node) external view returns (string memory);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n    function setAddr(bytes32 node, address addr) external;\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n    function setName(bytes32 node, string calldata _name) external;\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n    function multihash(bytes32 node) external view returns (bytes memory);\n    function setContent(bytes32 node, bytes32 hash) external;\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n\ninterface IClock {\n  function getTime() view external returns (uint256);\n}\n\ncontract Clock is IClock {\n  function getTime() view public returns (uint256) {\n    return block.timestamp;\n  }\n}\n\n// This registrar allows a set of claimant addresses to alias any subnode to an address.\ncontract EthvaultENSRegistrar is Clock {\n  // The public resolver address can be found as the resolver of the \"resolver\" top level node\n  bytes32 public constant RESOLVER_NODE = keccak256(abi.encodePacked(bytes32(0), keccak256(\"resolver\")));\n\n  // Emitted when a user is registered\n  event Registration(address claimant, bytes32 label, address owner, uint256 value);\n\n  ENS public ens;\n\n  // The node corresponding to ethvault.xyz\n  bytes32 public rootNode;\n\n  // The addresses that may claim ENS subdomains for the given node\n  mapping(address => bool) public isClaimant;\n\n  constructor(ENS _ens, bytes32 _rootNode) public {\n    ens = _ens;\n    rootNode = _rootNode;\n\n    isClaimant[msg.sender] = true;\n  }\n\n  // Only one of the claimants may call a function.\n  modifier claimantOnly() {\n    if (!isClaimant[msg.sender]) {\n      revert(\"unauthorized - must be from claimant\");\n    }\n\n    _;\n  }\n\n  // Add claimants to the set.\n  function addClaimants(address[] calldata claimants) external claimantOnly {\n    for (uint i = 0; i < claimants.length; i++) {\n      isClaimant[claimants[i]] = true;\n    }\n  }\n\n  // Remove claimants from the set.\n  function removeClaimants(address[] calldata claimants) external claimantOnly {\n    for (uint i = 0; i < claimants.length; i++) {\n      isClaimant[claimants[i]] = false;\n    }\n  }\n\n  // Compute the namehash from the label and the root node.\n  function namehash(bytes32 label) view public returns (bytes32) {\n    return keccak256(abi.encodePacked(rootNode, label));\n  }\n\n  // Get the data that the user should sign to release a name.\n  function getReleaseSignData(bytes32 label, uint256 expirationTimestamp) pure public returns (bytes32) {\n    return keccak256(abi.encodePacked(label, expirationTimestamp));\n  }\n\n  /**\n   * @dev Recover signer address from a message by using their signature\n   * @param _hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n   * @param _sig bytes signature, the signature is generated using web3.eth.sign()\n   */\n  function recover(bytes32 _hash, bytes memory _sig)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    // Check the signature length\n    if (_sig.length != 65) {\n      return (address(0));\n    }\n\n    // Divide the signature in r, s and v variables\n    // ecrecover takes the signature parameters, and the only way to get them\n    // currently is to use assembly.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      r := mload(add(_sig, 32))\n      s := mload(add(_sig, 64))\n      v := byte(0, mload(add(_sig, 96)))\n    }\n\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    if (v < 27) {\n      v += 27;\n    }\n\n    // If the version is correct return the signer address\n    if (v != 27 && v != 28) {\n      return (address(0));\n    } else {\n      // solium-disable-next-line arg-overflow\n      return ecrecover(_hash, v, r, s);\n    }\n  }\n\n  /**\n   * toEthSignedMessageHash\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n   * and hash the result\n   */\n  function toEthSignedMessageHash(bytes32 _hash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\n    );\n  }\n\n  // Allow a subnode to be released given the user's signature. Anyone can perform this operation as long as the\n  // signature has not expired.\n  function release(bytes32 label, uint256 expirationTimestamp, bytes calldata signature) external {\n    bytes32 subnode = namehash(label);\n\n    address currentOwner = ens.owner(subnode);\n\n    if (currentOwner == address(0)) {\n      // No-op, just return.\n      return;\n    }\n\n    address signer = recover(\n      toEthSignedMessageHash(getReleaseSignData(label, expirationTimestamp)),\n      signature\n    );\n\n    if (signer == address(0)) {\n      revert(\"invalid signature\");\n    }\n\n    if (signer != currentOwner) {\n      revert(\"signature is not from current owner\");\n    }\n\n    if (expirationTimestamp < getTime()) {\n      revert(\"the signature has expired\");\n    }\n\n    ens.setSubnodeOwner(rootNode, label, address(0));\n  }\n\n  // Return the public resolver. This is called to get the public resolver to use during registration.\n  function getPublicResolver() view public returns (Resolver) {\n    address resolverAddr = ens.resolver(RESOLVER_NODE);\n    \n    if (resolverAddr == address(0)) {\n      revert(\"failed to get resolver address\");\n    }\n\n    Resolver resolver = Resolver(resolverAddr);\n\n    address publicResolver = resolver.addr(RESOLVER_NODE);\n    if (publicResolver == address(0)) {\n      revert(\"resolver had address zero for node\");\n    }\n\n    return Resolver(publicResolver);\n  }\n\n  /**\n   * Register a subdomain name, sets the resolver, updates the resolver, and sets the address of the resolver to the\n   * new owner. Also transfers any additional value to each address.\n   * @param labels The hashes of the label to register\n   * @param owners The addresses of the new owners\n   * @param values The WEI values to send to each address\n   */\n  function register(bytes32[] calldata labels, address payable[] calldata owners, uint256[] calldata values) external payable claimantOnly {\n    if (labels.length != owners.length || owners.length != values.length) {\n      revert(\"must pass the same number of labels and owners\");\n    }\n\n    uint256 dispersedTotal = 0;\n\n    for (uint i = 0; i < owners.length; i++) {\n      bytes32 label = labels[i];\n      address payable owner = owners[i];\n      uint256 value = values[i];\n\n      // Compute the subnode hash\n      bytes32 subnode = namehash(label);\n\n      // Get the current owner of this subnode\n      address currentOwner = ens.owner(subnode);\n\n      // Prevent overwriting ownership with a different address\n      if (currentOwner != address(0) && currentOwner != owner) {\n        revert(\"the label owner may not be changed\");\n      }\n\n      // Skip if the current owner is already the owner\n      if (currentOwner == owner) {\n        continue;\n      }\n\n      Resolver publicResolver = getPublicResolver();\n\n      // First set it to this, so we can update it.\n      ens.setSubnodeOwner(rootNode, label, address(this));\n\n      // Set the resolver for the subnode to the public resolver\n      ens.setResolver(subnode, address(publicResolver));\n\n      // Set the address to the owner in the public resolver\n      publicResolver.setAddr(subnode, owner);\n\n      // Finally pass ownership to the new owner.\n      ens.setSubnodeOwner(rootNode, label, owner);\n\n      if (value > 0) {\n        dispersedTotal = dispersedTotal + value;\n        owner.transfer(value);\n      }\n\n      emit Registration(msg.sender, label, owner, value);\n    }\n\n    if (dispersedTotal < msg.value) {\n      msg.sender.transfer(msg.value - dispersedTotal);\n    }\n  }\n\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getPublicResolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESOLVER_NODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"getReleaseSignData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimants\",\"type\":\"address[]\"}],\"name\":\"addClaimants\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"labels\",\"type\":\"bytes32[]\"},{\"name\":\"owners\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"namehash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isClaimant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimants\",\"type\":\"address[]\"}],\"name\":\"removeClaimants\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ens\",\"type\":\"address\"},{\"name\":\"_rootNode\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"}]","ContractName":"EthvaultENSRegistrar","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b9cf26cb6c48342af8482135f0ea9d35d6e90e93366e24b7e891b92e73ee92908","Library":"","SwarmSource":"bzzr://bd24f6b98d8aa5e2be8378f0752454ae8130199031f88f42fcde3fdca9f447df"}]}