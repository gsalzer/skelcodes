{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable private owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    \r\n    constructor(address payable _owner) public {\r\n        owner = _owner;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function getOwner() internal view returns(address){\r\n        return owner;\r\n    }\r\n    \r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address payable from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract Cache is Owned(msg.sender), ERC20Interface{\r\n    using SafeMath for uint256;\r\n    \r\n    /* ERC20 public vars */\r\n    string public constant version = 'Cache 1.0';\r\n    string public name = 'Cache';\r\n    string public symbol = 'CACHE';\r\n    uint256 public decimals = 18;\r\n    uint256 internal _totalSupply;\r\n\r\n    /* ERC20 This creates an array with all balances */\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    \r\n\r\n    /* Keeps record of Depositor's amount and deposit time */\r\n    mapping (address => Depositor) public depositor;\r\n    \r\n    struct Depositor{\r\n        uint256 amount;\r\n    }\r\n\r\n    /* reservedReward collects owner reward share */\r\n    uint256 public reservedReward;\r\n    uint256 public constant initialSupply = 4e6;                                                //4,000,000\r\n    \r\n    /* custom events to notify users */\r\n    event Withdraw(address indexed by, uint256 amount, uint256 fee);                            // successful withdraw event\r\n    event Deposited(address indexed by, uint256 amount);                                        // funds Deposited event\r\n    event PaidOwnerReward(uint256 amount);\r\n    /*\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     * In our case, there's no initial supply. Tokens will be created as ether is sent\r\n     * to the fall-back function. Then tokens are burned when ether is withdrawn.\r\n     */\r\n    Owned private owned;\r\n    address payable private owner;\r\n     \r\n    constructor () payable public {\r\n        owner = address(uint160(getOwner()));\r\n        _totalSupply = initialSupply * 10 ** uint(decimals);                            // Update total supply\r\n        balances[owner] = _totalSupply;                                                 // Give the creator all initial tokens\r\n        emit Transfer(address(0),address(owner), _totalSupply);\r\n    }\r\n\r\n    /**\r\n     * Fallback function when sending ether to the contract\r\n     * Gas use: 91000\r\n    */\r\n    function() external payable {                                                   \r\n        makeDeposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    //Pay the owner the reservedReward\r\n    function ownerReward() internal{\r\n        require(owner.send(reservedReward));\r\n        emit PaidOwnerReward(reservedReward);\r\n        reservedReward = reservedReward.sub(reservedReward);\r\n    }\r\n    \r\n    //Charge a 0.3% deposit fee\r\n    function makeDeposit(address sender, uint256 amount) internal {\r\n        require(balances[sender] == 0);\r\n        require(amount > 0);\r\n        \r\n        //Take 0.3% of the fee and send it to the Owner of the contract\r\n        uint256 depositFee = (amount.div(1000)).mul(3);\r\n        uint256 newAmount  = (amount.mul(1000)).sub(depositFee.mul(1000));\r\n        \r\n        //Send the tokens to depositor of the Ethereum\r\n        balances[sender] = balances[sender] + newAmount;                                // mint new tokens\r\n        _totalSupply = _totalSupply + newAmount;                                 // track the supply\r\n        emit Transfer(address(0), sender, newAmount);                                   // notify of the transfer event\r\n        \r\n        //Adding the fee to the reservedReward\r\n        reservedReward = reservedReward.add(depositFee);\r\n        \r\n        //Adding the amount deposited to the depositor\r\n        depositor[sender].amount = newAmount;\r\n        emit Deposited(sender, newAmount);\r\n    }\r\n    \r\n    \r\n    //Charge a 0.3% withdrawal fee\r\n    function withdraw(address payable _sender, uint256 amount) internal {\r\n        \r\n        uint256 withdrawFee = (amount.div(1000)).mul(3);\r\n        uint256 newAmount   = (amount.mul(1000)).sub(withdrawFee.mul(1000));\r\n        \r\n        //Remove deposit in terms of ETH\r\n        depositor[_sender].amount = depositor[_sender].amount.sub(amount);                               // remove deposit information from depositor record\r\n\r\n        //Withdraw the amount from the contract and pay the fee\r\n        require(_sender.send(newAmount.div(1000000)));                                                       // transfer ethers plus earned reward to sender\r\n        emit Withdraw(_sender, newAmount.div(1000000), withdrawFee.div(1000));\r\n        \r\n        //Adding the fee to the reservedReward\r\n        reservedReward = reservedReward.add(withdrawFee.div(1000));\r\n    }\r\n    \r\n    \r\n    /***************************** ERC20 implementation **********************/\r\n    function totalSupply() public view returns (uint){\r\n       return _totalSupply;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    \r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        if(msg.sender == owner) { require(tokens >= 1e18);}                         // minimum tokens sent by owner sould be >= 1\r\n        require(to != address(0));                                                  // receiver address should not be zero-address\r\n        require(balances[msg.sender] >= tokens );                                   // sender must have sufficient tokens to transfer\r\n        \r\n        uint256 bal1 = balances[address(this)]; \r\n        \r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);                    // remove tokens from sender\r\n            \r\n        require(balances[to] + tokens >= balances[to]);                             // if tokens are sent to any other wallet address\r\n        \r\n        balances[to] = balances[to].add(tokens);                                    // Transfer the tokens to \"to\" address\r\n        \r\n        emit Transfer(msg.sender,to,tokens);                                        // emit Transfer event to \"to\" address\r\n\r\n        if(to ==  address(this)){                                                   // if tokens are sent to contract address\r\n            require(bal1 < balances[address(this)]);\r\n                                                                                   // sender must be an actual depositor\r\n            //If the sender is the owner then withdraw the reward\r\n            //Otherwise its a user and let them withdraw the reward\r\n            if(msg.sender == owner){\r\n                ownerReward();\r\n            }\r\n            \r\n            if(depositor[msg.sender].amount > 0){                                     // sender must be an actual depositor\r\n                if(tokens > depositor[msg.sender].amount){\r\n                    withdraw(msg.sender,  depositor[msg.sender].amount);  \r\n                }else{\r\n                    withdraw(msg.sender, tokens);                                       // perform withdraw \r\n                }\r\n            }\r\n            \r\n            \r\n            balances[to] = balances[to].sub(tokens);                                // remove tokens from sender balance\r\n            _totalSupply = _totalSupply.sub(tokens);                                // remove sent tokens from totalSupply\r\n            emit Transfer(to, address(0), tokens);                                  // emit Transfer event of burning\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address payable from, address to, uint tokens) public returns (bool success){\r\n        require(from != address(0));\r\n        require(to != address(0));\r\n        require(tokens <= allowed[from][msg.sender]); //check allowance\r\n        require(balances[from] >= tokens); // check if sufficient balance exist or not\r\n        \r\n        if(to == address(this)){\r\n            if(from == owner)\r\n                require(tokens == 1e18);\r\n        }\r\n        \r\n        uint256 bal1 = balances[address(this)];\r\n        balances[from] = balances[from].sub(tokens);\r\n        \r\n        require(balances[to] + tokens >= balances[to]);\r\n        \r\n        balances[to] = balances[to].add(tokens);                                            // Transfer the tokens to \"to\" address\r\n        \r\n        emit Transfer(from,to,tokens);                                                // emit Transfer event to \"to\" address\r\n\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        \r\n        if(to ==  address(this)){                                                   // if tokens are sent to contract address\r\n            require(bal1 < balances[address(this)]);\r\n            \r\n            if(msg.sender == owner){\r\n                ownerReward();\r\n            }\r\n            \r\n            if(depositor[msg.sender].amount > 0){                                     // sender must be an actual depositor\r\n                withdraw(from, tokens);                                       // perform withdraw \r\n            }\r\n            \r\n            \r\n            balances[to] = balances[to].sub(tokens);                                // remove tokens from sender balance\r\n            \r\n            _totalSupply = _totalSupply.sub(tokens);                                // remove sent tokens from totalSupply\r\n            \r\n            emit Transfer(to, address(0), tokens);                                  // emit Transfer event of burning\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success){\r\n        require(spender != address(0));\r\n        require(tokens <= balances[msg.sender]);\r\n        require(tokens >= 0);\r\n        require(allowed[msg.sender][spender] == 0 || tokens == 0);\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender,spender,tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaidOwnerReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Cache","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://9b0364b15100fce55ee11840a0047cce160d6419778d9d010d9e5ae03167fc27"}]}