{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n//==============================================================================\r\n// ____     _____    __   __\r\n///\\  _`\\  /\\  __`\\ /\\ \\ /\\ \\\r\n//\\ \\ \\L\\ \\\\ \\ \\/\\ \\\\ `\\`\\/'/'\r\n// \\ \\  _ <'\\ \\ \\ \\ \\`\\/ > <\r\n//  \\ \\ \\L\\ \\\\ \\ \\_\\ \\  \\/'/\\`\\\r\n//   \\ \\____/ \\ \\_____\\ /\\_\\\\ \\_\\\r\n//    \\/___/   \\/_____/ \\/_/ \\/_/\r\n//==============================================================================\r\n\r\nlibrary BoxTypes {\r\n    \r\n    enum TeamId {\r\n        TeamNone,\r\n        TeamWhite,\r\n        TeamBlack,\r\n        TeamBlue,\r\n        TeamRed\r\n    }\r\n\r\n    enum FinanceReason {\r\n        FinancePotUserCommon,           //静态分红\r\n        FinancePotUserSenior,           //高阶用户分红\r\n        FinancePotTeamCaptain,          //战队奖励队长分红\r\n        FinancePotTeam,                 //战队奖励分红\r\n        FinanceWithdrawBoxBalance,      //提取盒子余额\r\n        FinanceWithdrawInvitorBalance   //提取推广分红\r\n    }\r\n\r\n    struct Player {\r\n        uint256 invitor;                    //邀请人\r\n        \r\n        uint256 boxTotal;                   //盒子总数量\r\n        uint256 boxCount;                   //有效盒子数量\r\n        uint256 boxEthCur;                  //盒子当前以太币\r\n        uint256 boxEthCum;                  //盒子累计获得以太币\r\n\r\n        uint256 invitorBalance;             //未领取推广分红\r\n\r\n        int16 invited;                      //已邀请人数\r\n        address addr;                       //账号地址\r\n    }\r\n\r\n    struct Round {\r\n        uint256 end;                                                        //结束时间\r\n        uint256 boxTotal;\r\n        uint256 potCaptain;                                                 //队长奖励\r\n        uint256 potTeam;\r\n        uint256 potTeamReserved;\r\n        int8 luckyTeam;                                                     //中奖队伍\r\n\r\n        mapping (int8 => uint256[]) teamPlayers;                            //(tId => pIds)\r\n        mapping (int8 => mapping (uint256 => uint256)) teamPlayerBoxCount;  //(tId => pId => boxCount)\r\n        mapping (int8 => uint256) teamCaptain;                              //(tId => pId of captain)\r\n        mapping (uint256 => uint256) potPlayer;                             //(pId => pot Player)\r\n    }\r\n\r\n    struct Pot {\r\n        uint256 end;                                                        //结束时间\r\n        uint256 potUserCommon;\r\n        uint256 potUserSenior;\r\n\r\n        mapping (uint256 => uint256) potSenior;                             //(pId => pot user senior)\r\n    }\r\n\r\n    struct Statistics {\r\n        uint256 totalInvest;                                                //总投入\r\n        uint256 totalWithdraw;                                              //总提取\r\n        uint256 totalPotCaptain;                                            //总队长奖励\r\n        uint256 devGain;                                                    //研发收入\r\n    }\r\n}\r\n\r\ncontract AccessControl {\r\n    string public constant RoleOwner = \"owner\";\r\n\r\n    struct RoleEntry {\r\n        address addr;\r\n        bool enable;\r\n    }\r\n    struct Role {\r\n        string name;\r\n        mapping (address => RoleEntry) userMap;\r\n        address[] userArray;\r\n    }\r\n    mapping (string =>  Role) roles;\r\n    string[] public roleNames;\r\n\r\n    event RoleAdd(address indexed user, string name);\r\n    event RoleRemove(address indexed user, string name);\r\n\r\n    constructor() public {\r\n        _roleAdd(RoleOwner, msg.sender);\r\n    }\r\n\r\n    function _roleAdd(string _name, address _user) private {\r\n        if ((bytes(_name).length == 0) || (_user == address(0))) {\r\n            return;\r\n        }\r\n\r\n        Role storage role = roles[_name];\r\n        if (bytes(role.name).length == 0) {\r\n            role.name = _name;\r\n            roleNames.push(_name);\r\n        }\r\n\r\n        RoleEntry storage entry = role.userMap[_user];\r\n        if (entry.addr == address(0)) {\r\n            entry.addr = _user;\r\n            role.userArray.push(_user);\r\n        }\r\n        entry.enable = true;\r\n        emit RoleAdd(_user, _name);\r\n    }\r\n\r\n    /**\r\n    * @dev add a role to a user\r\n    * @param _name the name of the role\r\n    * @param _user address of user\r\n    */\r\n    function roleAdd(string _name, address _user) public onlyOwner {\r\n        _roleAdd(_name, _user);\r\n    }\r\n\r\n    /**\r\n    * @dev remove a role from a user\r\n    * @param _name the name of the role\r\n    * @param _user address of user\r\n    */\r\n    function roleRemove(string _name, address _user) public onlyOwner {\r\n        roles[_name].userMap[_user].enable = false;\r\n        emit RoleRemove(_user, _name);\r\n    }\r\n\r\n    /**\r\n    * @dev check if user has this role\r\n    * @param _name the name of the role\r\n    * @param _user address of user\r\n    * @return bool\r\n    */\r\n    function _roleHas(string _name, address _user) internal view returns (bool){\r\n        return roles[_name].userMap[_user].enable;\r\n    }\r\n\r\n    /**\r\n    * @dev reverts if addr does not have role\r\n    * @param _name the name of the role\r\n    * @param _user address of user\r\n    * // reverts\r\n    */\r\n    function roleCheck(string _name, address _user) public view {\r\n        require(_roleHas(_name, _user));\r\n    }\r\n\r\n    /**\r\n    * @dev determine if addr has role\r\n    * @param _name the name of the role\r\n    * @param _user address of user\r\n    * @return bool\r\n    */\r\n    function roleHas(string _name, address _user) public view returns (bool) {\r\n        return _roleHas(_name, _user);\r\n    }\r\n\r\n    function roleUsers(string _name) public view returns (address[] memory addrs) {\r\n        Role storage role = roles[_name];\r\n        if (role.userArray.length == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 len = 0;\r\n        for (uint256 j = 0; j < role.userArray.length; j++) {\r\n            RoleEntry storage entry = role.userMap[role.userArray[j]];\r\n            if (entry.enable) {\r\n                len++;\r\n            }\r\n        }\r\n        addrs = new address[](len);\r\n        uint256 index = 0;\r\n        for (j = 0; j < role.userArray.length; j++) {\r\n            entry = role.userMap[role.userArray[j]];\r\n            if (entry.enable) {\r\n                addrs[index++] = entry.addr;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n    * @param _role the name of the role\r\n    * // reverts\r\n    */\r\n    modifier onlyRole(string _role) {\r\n        roleCheck(_role, msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        roleCheck(RoleOwner, msg.sender);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract BoxConstants {\r\n\r\n    //round constants\r\n    uint256 constant RoundTimeInitial = 24 hours;\r\n    uint256 constant RoundTimeMax = 48 hours;\r\n    uint256 constant RoundTimeAdd = 10 minutes;\r\n    uint256 constant PotTime = 24 hours;\r\n\r\n    //box constants\r\n    uint256 constant BoxEthMaxFold = 3;\r\n    uint256 constant BoxPrice = 0.005 ether;\r\n    uint256 constant BoxEthMax = BoxEthMaxFold * BoxPrice;\r\n\r\n    //role constants\r\n    string constant RoleOwner = \"owner\";            //角色：所有者\r\n    string constant RoleAdmin = \"admin\";            //角色：管理\r\n\r\n    //pot\r\n    // uint256 constant PotRatioUserCommon = 40;       //in %\r\n    // uint256 constant PotRatioUserSenior = 15;       //in %\r\n    // uint256 constant PotRatioTeam = 20;             //in %\r\n    // uint256 constant PotRatioTeamReserved = 15;     //in %\r\n    // uint256 constant PotRatioInvitor = 8;           //in %\r\n    // uint256 constant PotRatioDeveloper = 2;         //in %\r\n\r\n    uint256 constant PotRatioTeamCaptain = 40;      //in %\r\n}\r\n\r\ncontract BoxData is AccessControl, BoxConstants {\r\n    using SafeMath for uint256;\r\n\r\n    address public addrGame;\r\n    address public addrImpl;\r\n\r\n    //TODO 金钱统计\r\n\r\n    //game\r\n    bool public activated = false;\r\n\r\n    constructor(address addr) public {\r\n        roleAdd(RoleAdmin, msg.sender);\r\n        _setGame(addr);\r\n    }\r\n\r\n    //game\r\n\r\n    /** @dev set activated\r\n    * @param status activated status\r\n    */\r\n    function setActivated(bool status) public onlyAdmin {\r\n        activated = status;\r\n    }\r\n \r\n    function setImpl(address addr) public onlyAdmin {\r\n        addrImpl = addr;\r\n    }\r\n\r\n    function _setGame(address addr) private {\r\n        addrGame = addr;\r\n        addrImpl = BoxGame(addrGame).addrImpl();\r\n    }\r\n\r\n    function setGame(address addr) public onlyAdmin {\r\n        _setGame(addr);\r\n    }\r\n\r\n    //round\r\n    uint256 public nRound = 0;\r\n    mapping (uint256 => BoxTypes.Round) public rounds;          //(rID => Round)\r\n\r\n    /** @dev new round\r\n    * @return rId Id of round\r\n    */\r\n    function newRound(uint256 end, uint256 potTeam) public onlyAdmin returns (uint256 rId) {\r\n        nRound++;\r\n        rId = nRound;\r\n        BoxTypes.Round storage round = rounds[rId];\r\n        round.end = end;\r\n        round.potTeam = potTeam;\r\n    }\r\n\r\n    /** @dev get round base info\r\n    * @param rId activated status\r\n    * @return end end of round\r\n    */\r\n    function getRoundBase(uint256 rId) public view returns (\r\n        uint256 end, uint256 boxTotal, uint256 potCaptain, uint256 potTeam, uint256 potTeamReserved, int8 luckyTeam) {\r\n        BoxTypes.Round storage round = rounds[rId];\r\n\r\n        end = round.end;\r\n        boxTotal = round.boxTotal;\r\n        potCaptain = round.potCaptain;\r\n        potTeam = round.potTeam;\r\n        potTeamReserved = round.potTeamReserved;\r\n        luckyTeam = round.luckyTeam;\r\n    }\r\n\r\n    function setRoundTime(uint256 time) public onlyAdmin {\r\n        rounds[nRound].end = time;\r\n    }\r\n\r\n    function setRoundPotInfo(uint256 rId, uint256 potCaptain, int8 luckyTeam) public onlyAdmin {\r\n        BoxTypes.Round storage round = rounds[rId];\r\n\r\n        round.potCaptain = potCaptain;\r\n        round.luckyTeam = luckyTeam;\r\n    }\r\n\r\n    function getRoundTeam(uint256 rId, int8 tId) public view returns (uint256 captain, uint256[] players, uint256[] boxCounts, uint256 boxTotal) {\r\n        BoxTypes.Round storage round = rounds[rId];\r\n\r\n        if (0 == round.end) {\r\n            return;\r\n        }\r\n\r\n        captain = round.teamCaptain[tId];\r\n        uint256[] storage teamPlayers = round.teamPlayers[tId];\r\n        uint256 count = teamPlayers.length;\r\n        if (0 == count) {\r\n            return;\r\n        }\r\n\r\n        players = new uint256[](count);\r\n        boxCounts = new uint256[](count);\r\n        for (uint256 index = 0; index < count; index++) {\r\n            uint256 pId = teamPlayers[index];\r\n            uint256 boxCount = round.teamPlayerBoxCount[tId][pId];\r\n            players[index] = pId;\r\n            boxCounts[index] = boxCount;\r\n            boxTotal += boxCount;\r\n        }\r\n    }\r\n\r\n    function getRoundPlayerBoxCount(uint256 rId, uint256 pId, int8 tId) public view returns (uint256) {\r\n        return rounds[rId].teamPlayerBoxCount[tId][pId];\r\n    }\r\n\r\n    function getRoundPotPlayer(uint256 rId, uint256 pId) public view returns (uint256) {\r\n        return rounds[rId].potPlayer[pId];\r\n    }\r\n    \r\n    //pot\r\n    uint256 public nPot = 0;\r\n    mapping (uint256 => BoxTypes.Pot) public pots;              //(potID => Pot)\r\n\r\n    function newPot(uint256 end) public onlyAdmin returns (uint256 potId) {\r\n        nPot++;\r\n        potId = nPot;\r\n        BoxTypes.Pot storage pot = pots[potId];\r\n        pot.end = end;\r\n    }\r\n\r\n    function getPotBase(uint256 potId) public view returns (\r\n        uint256 end, uint256 potUserCommon, uint256 potUserSenior) {\r\n        BoxTypes.Pot storage pot = pots[potId];\r\n\r\n        end = pot.end;\r\n        potUserCommon = pot.potUserCommon;\r\n        potUserSenior = pot.potUserSenior;\r\n    }\r\n\r\n    function incPot(uint256 potUserCommon, uint256 potUserSenior, uint256 potTeam, uint256 potTeamReserved) public onlyAdmin {\r\n        BoxTypes.Pot storage pot = pots[nPot];\r\n        pot.potUserCommon = pot.potUserCommon.add(potUserCommon);\r\n        pot.potUserSenior = pot.potUserSenior.add(potUserSenior);\r\n\r\n        BoxTypes.Round storage round = rounds[nRound];\r\n        round.potTeam = round.potTeam.add(potTeam);\r\n        round.potTeamReserved = round.potTeamReserved.add(potTeamReserved);\r\n    }\r\n\r\n    function getPotSenior(uint256 potId, uint256 pId) public view returns (uint256) {\r\n        return pots[potId].potSenior[pId];\r\n    }\r\n\r\n    //player\r\n    uint256 public nPlayer = 0;\r\n    mapping (address => uint256) public pAddrTopId;             //(address => pId)\r\n    mapping (uint256 => BoxTypes.Player) public players;        //(pId => Player)\r\n\r\n    /** @dev new player\r\n    * @param addr Address of player\r\n    * @param invitor invitor of player\r\n    * @return pId Id of player\r\n    */\r\n    function newPlayer(address addr, uint256 invitor) public onlyAdmin returns (uint256 pId) {\r\n        nPlayer++;\r\n        pId = nPlayer;\r\n\r\n        BoxTypes.Player storage player = players[pId];\r\n        pAddrTopId[addr] = pId;\r\n        player.invitor = invitor;\r\n        player.addr = addr;\r\n    }\r\n\r\n    function getPlayer(uint256 pId) public view returns (\r\n        address addr, uint256 invitor, int16 invited, uint256 invitorBalance, uint256 boxCount, uint256 boxTotal, uint256 boxEthCur, uint256 boxEthCum) {\r\n        BoxTypes.Player storage player = players[pId];\r\n        if (address(0) == player.addr) {\r\n            return;\r\n        }\r\n\r\n        addr = player.addr;\r\n        invitor = player.invitor;\r\n        invited = player.invited;\r\n        invitorBalance = player.invitorBalance;\r\n        boxCount = player.boxCount;\r\n        boxTotal = player.boxTotal;\r\n        boxEthCur = player.boxEthCur;\r\n        boxEthCum = player.boxEthCum;\r\n    }\r\n\r\n    function getPlayerAddress(uint256 pId) public view returns (address addr) {\r\n        return players[pId].addr;\r\n    }\r\n\r\n    function getProfitablePlayers(uint256 ethMaxPerBox) public view returns (uint256[] profitablePlayers, uint256[] boxCounts, uint256 boxTotal, int16[] inviteds) {\r\n        uint256 count;\r\n        for (uint256 pId = 1; pId <= nPlayer; pId++) {\r\n            BoxTypes.Player storage player = players[pId];\r\n            uint256 ethMax = ethMaxPerBox.mul(player.boxCount);\r\n            if (player.boxEthCum < ethMax) {\r\n                count++;\r\n            }\r\n        }\r\n        profitablePlayers = new uint256[](count); \r\n        boxCounts = new uint256[](count);\r\n        inviteds = new int16[](count);\r\n        uint256 pos;\r\n        for (pId = 1; pId <= nPlayer; pId++) {\r\n            player = players[pId];\r\n            ethMax = ethMaxPerBox.mul(player.boxCount);\r\n            if (player.boxEthCum < ethMax) {\r\n                profitablePlayers[pos] = pId;\r\n                boxCounts[pos] = player.boxCount;\r\n                inviteds[pos] = player.invited;\r\n                boxTotal += player.boxCount;\r\n                pos++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setPlayerInvitor(uint256 pId, uint256 invitorId) public onlyAdmin {\r\n        players[pId].invitor = invitorId;\r\n    }\r\n\r\n    function incPlayerInvited(uint256 pId) public onlyAdmin returns (int16) {\r\n        players[pId].invited++;\r\n        return players[pId].invited;\r\n    }\r\n\r\n    function newBox(uint256 pId, uint256 count, int8 tId) public onlyAdmin {\r\n        BoxTypes.Player storage player = players[pId];\r\n        player.boxCount += count;\r\n        player.boxTotal += count;\r\n\r\n        BoxTypes.Round storage round = rounds[nRound];\r\n        round.boxTotal += count;\r\n\r\n        uint256 boxCountOld = round.teamPlayerBoxCount[tId][pId];\r\n        if (0 == boxCountOld) {\r\n            round.teamPlayers[tId].push(pId);\r\n        }\r\n        uint256 boxCountNew = boxCountOld + count;\r\n        round.teamPlayerBoxCount[tId][pId] = boxCountNew;\r\n        uint256 captainId = round.teamCaptain[tId];\r\n        uint256 captainBoxCount = round.teamPlayerBoxCount[tId][captainId];\r\n        if (boxCountNew > captainBoxCount) {\r\n            round.teamCaptain[tId] = pId;\r\n        }\r\n    }\r\n\r\n    function incPlayerInvitorBalance(uint256 pId, uint256 val) public onlyAdmin {\r\n        players[pId].invitorBalance = players[pId].invitorBalance.add(val);\r\n    }\r\n\r\n    function _addPlayerBoxEth(uint256 pId, uint256 val, uint256 ethMaxPerBox) private returns (uint256 change) {\r\n        BoxTypes.Player storage player = players[pId];\r\n\r\n        uint256 ethMax = ethMaxPerBox.mul(player.boxCount);\r\n        if (ethMax <= player.boxEthCum) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 changeMax = ethMax - player.boxEthCum;\r\n        if (val >= changeMax) {\r\n            change = changeMax;\r\n            player.boxEthCur += change;\r\n            player.boxEthCum = 0;\r\n            player.boxCount = 0;\r\n        } else {\r\n            change = val;\r\n            player.boxEthCur += change;\r\n            player.boxEthCum += change;\r\n        }\r\n    }\r\n\r\n    function addPlayerPotTeam(uint256 rId, uint256[] pIds, uint256[] vals, uint256 ethMaxPerBox) public onlyAdmin returns (uint256 distributed) {\r\n        uint256 count = pIds.length;\r\n        if(count <= 0) {\r\n            return;\r\n        }\r\n        for (uint256 index = 0; index < count; index++) {\r\n            uint256 pId = pIds[index];\r\n            uint256 val = vals[index];\r\n            distributed += _addPlayerBoxEth(pId, val, ethMaxPerBox);\r\n            rounds[rId].potPlayer[pId] += val;\r\n        }\r\n    }\r\n\r\n    function addPlayerPotUser(uint256 potId, uint256[] pIds, uint256[] valCommons, uint256[] valSeniors, uint256 ethMaxPerBox) public onlyAdmin returns (uint256 distributed) {\r\n        uint256 count = pIds.length;\r\n        if(count <= 0) {\r\n            return;\r\n        }\r\n        for (uint256 index = 0; index < count; index++) {\r\n            uint256 pId = pIds[index];\r\n            uint256 valCommon = valCommons[index];\r\n            uint256 valSenior = valSeniors[index];\r\n            uint256 val = valCommon.add(valSenior);\r\n            distributed += _addPlayerBoxEth(pId, val, ethMaxPerBox);\r\n            pots[potId].potSenior[pId] += valSenior;\r\n        }\r\n    }\r\n\r\n    function resetPlayerBoxEth(uint256 pId,  uint256 ethMaxPerBox) public onlyAdmin returns (uint256 eth) {\r\n        BoxTypes.Player storage player = players[pId];\r\n\r\n        eth = player.boxEthCur;\r\n        player.boxEthCur = 0;\r\n        uint256 ethMax = ethMaxPerBox.mul(player.boxCount);\r\n        if (ethMax <= player.boxEthCum) {\r\n            player.boxCount = 0;\r\n            player.boxEthCum = 0;\r\n        }\r\n    }\r\n\r\n    function resetPlayerInvitorBalance(uint256 pId) public onlyAdmin returns (uint256 eth) {\r\n        BoxTypes.Player storage player = players[pId];\r\n        eth = player.invitorBalance;\r\n        player.invitorBalance = 0;\r\n    }\r\n\r\n    //stats\r\n    BoxTypes.Statistics public stats;\r\n\r\n    function addStatsInvest(uint256 val) public onlyAdmin {\r\n        stats.totalInvest = stats.totalInvest.add(val);\r\n    }\r\n\r\n    function addStatsWithdraw(uint256 val) public onlyAdmin {\r\n        stats.totalWithdraw = stats.totalWithdraw.add(val);\r\n    }\r\n\r\n    function addStatsPotCaptain(uint256 val) public onlyAdmin {\r\n        stats.totalPotCaptain = stats.totalPotCaptain.add(val);\r\n    }\r\n\r\n    function addStatsDevGain(uint256 val) public onlyAdmin {\r\n        stats.devGain = stats.devGain.add(val);\r\n    }\r\n\r\n    /**\r\n     * @dev call only by impl or admin\r\n     */\r\n    modifier onlyAdmin() {\r\n        require((msg.sender == addrImpl) || (msg.sender == addrGame) || roleHas(RoleAdmin, msg.sender), \"can only call by admin\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract BoxEvents {\r\n\r\n    event evNewRound (\r\n        uint256 indexed rId,\r\n        uint256 end,\r\n        uint256 potTeam,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event evNewPot (\r\n        uint256 indexed potId,\r\n        uint256 end,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event evBuyBox (\r\n        uint256 indexed pId,\r\n        int8 indexed tId,\r\n        uint256 indexed invitor,\r\n        uint256 count,\r\n        uint256 value,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event evEndRound (\r\n        uint256 indexed rId,\r\n        uint256 potTeam,\r\n        uint256 potTeamReserved,\r\n        int8 luckyTeam,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event evTransfer (\r\n        address indexed addr,\r\n        int8 indexed reason,\r\n        uint256 value,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event evDistributePot (\r\n        uint256 potUserCommon,\r\n        uint256 potUserSenior,\r\n        uint256 boxCount,\r\n        uint256 timeStamp\r\n    );\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary TimeUtil {\r\n    using SafeMath for uint256;\r\n\r\n    function isSameDay(uint256 time1, uint256 time2) internal pure returns (bool) {\r\n         //GMT +8\r\n        uint256 timeZone = uint256(8).mul(3600);\r\n        uint256 secondsOneDay = uint256(24).mul(3600);\r\n        uint256 day1 = time1.add(timeZone).div(secondsOneDay);\r\n        uint256 day2 = time2.add(timeZone).div(secondsOneDay);\r\n        if(day1 == day2){\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n}\r\n\r\nlibrary BoxCommon {\r\n    using SafeMath for uint256;\r\n\r\n    function calcPot(uint256 value) internal pure returns (\r\n        uint256 valUserCommon,\r\n        uint256 valUserSenior,\r\n        uint256 valTeam,\r\n        uint256 valTeamReserved,\r\n        uint256 valInvitor,\r\n        uint256 valDev\r\n    ) {\r\n        // uint256 constant PotRatioUserCommon = 40;       //in %\r\n        // uint256 constant PotRatioUserSenior = 15;       //in %\r\n        // uint256 constant PotRatioTeam = 20;             //in %\r\n        // uint256 constant PotRatioTeamReserved = 15;     //in %\r\n        // uint256 constant PotRatioInvitor = 8;           //in %\r\n\r\n        valUserCommon = value.mul(40).div(100);\r\n        valUserSenior = value.mul(15).div(100);\r\n        valTeam = value.mul(20).div(100);\r\n        valTeamReserved = value.mul(15).div(100);\r\n        valInvitor = value.mul(8).div(100);\r\n        valDev = value - valUserCommon - valUserSenior - valTeam - valTeamReserved - valInvitor;\r\n    }\r\n\r\n    function invited2PotWeight(int16 invited) internal pure returns (uint256) {\r\n        if (invited < 1) {\r\n            return 0;\r\n        } else if (invited < 3) {\r\n            return 1;\r\n        } else if (invited < 8) {\r\n            return 3;\r\n        } else if (invited < 15) {\r\n            return 10;\r\n        } else if (invited < 30) {\r\n            return 15;\r\n        } else {\r\n            return 30;\r\n        }\r\n    }\r\n\r\n    function calcPotUserSenior(uint256 potUserSenior, uint256 count, uint256[] memory boxCounts, int16[] memory inviteds) internal pure returns (\r\n        uint256 potBoxSeniorAvg, uint256[] memory weights) {\r\n        uint256 weightTotal;\r\n        weights = new uint256[](count);\r\n        for (uint256 index = 0; index < count; index++) {\r\n            uint256 weight = invited2PotWeight(inviteds[index]).mul(boxCounts[index]);\r\n            weights[index] = weight;\r\n            weightTotal += weight;\r\n        }\r\n        if (weightTotal > 0) {\r\n            potBoxSeniorAvg = potUserSenior.div(weightTotal);\r\n        }\r\n    }\r\n\r\n    function calcPotUserCommon(uint256 potUserCommon, uint256 boxTotal) internal pure returns (uint256 potBoxCommonAvg) {\r\n        potBoxCommonAvg = potUserCommon.div(boxTotal);\r\n    }\r\n\r\n    function calcPotUser(uint256 potUserSenior, uint256 potUserCommon, uint256 boxTotal, uint256 count, uint256[] memory boxCounts, int16[] memory inviteds) internal pure returns (uint256[] memory valSeniors, uint256[] memory valCommons) {\r\n        (uint256 potBoxSeniorAvg, uint256[] memory weights) = calcPotUserSenior(potUserSenior, count, boxCounts, inviteds);\r\n        uint256 potBoxCommonAvg = calcPotUserCommon(potUserCommon, boxTotal);\r\n        valSeniors = new uint256[](count);\r\n        valCommons = new uint256[](count);\r\n        for (uint256 index = 0; index < count; index++) {\r\n            valCommons[index] = potBoxCommonAvg.mul(boxCounts[index]);\r\n            valSeniors[index] = potBoxSeniorAvg.mul(weights[index]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev safe math operations.\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (0 == a) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = ((add(x, 1)) / 2);\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    function sq(uint256 x) internal pure returns (uint256) {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    function pwr(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (0 == x)\r\n            return (0);\r\n        else if (0 == y)\r\n            return (1);\r\n        else {\r\n            uint256 z = x;\r\n            for (uint256 i = 1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract BoxGame is Ownable, BoxEvents, BoxConstants {\r\n    address public addrData;\r\n    address public addrImpl;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function () public payable {\r\n    }\r\n\r\n    function _setAddr(address addrD, address addrI) private {\r\n        addrData = addrD;\r\n        addrImpl = addrI;\r\n        BoxData(addrData).setImpl(addrImpl);\r\n        BoxImpl(addrImpl).setData(addrData);\r\n    }\r\n\r\n    function setAddr(address addrD, address addrI) public onlyOwner {\r\n        _setAddr(addrD, addrI);\r\n    }\r\n\r\n    /**\r\n    * @dev activate game\r\n    */\r\n    function activate(address addrD, address addrI, uint256 timeBase) public onlyOwner {\r\n        _setAddr(addrD, addrI);\r\n        BoxImpl(addrImpl).activate(msg.sender, timeBase);\r\n    }\r\n\r\n    /** @dev Buy boxes\r\n    * @param count count of box to buy\r\n    * @param tid team of box to buy\r\n    * @param invitorId invitor of player\r\n    */\r\n    function buyBox(uint256 count, int8 tid, uint256 invitorId) public payable {\r\n        require(tx.origin == msg.sender, \"sorry humans only\");\r\n\r\n        BoxImpl(addrImpl).buyBox(msg.sender, msg.value, count, tid, invitorId);\r\n    }\r\n\r\n    /**\r\n    * @dev tick game\r\n    */\r\n    function tickGame() public {\r\n        BoxImpl(addrImpl).tickGame();\r\n    }\r\n\r\n    /**\r\n    * @dev tick pot\r\n    */\r\n    function tickPot() public {\r\n        BoxImpl(addrImpl).tickPot();\r\n    }\r\n\r\n    /**\r\n    * @dev withdraw box balance\r\n    */\r\n    function withdrawBoxBalance() public {\r\n        BoxImpl(addrImpl).withdrawBoxBalance(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev withdraw invitor balance\r\n    */\r\n    function withdrawInvitorBalance() public {\r\n        BoxImpl(addrImpl).withdrawInvitorBalance(msg.sender);\r\n    }\r\n\r\n    function transferToPlayer(address addr, uint256 value, int8 reason) public {\r\n        require((addrImpl == msg.sender) || BoxData(addrData).roleHas(RoleAdmin, msg.sender), \"can only call by admin\");\r\n\r\n        addr.transfer(value);\r\n\r\n        emit evTransfer (\r\n            addr,\r\n            reason,\r\n            value,\r\n            now\r\n        );\r\n    }\r\n\r\n    function roundShouldEnd() public view returns (bool) {\r\n        return BoxImpl(addrImpl).roundShouldEnd();\r\n    }\r\n\r\n    function potShouldDistribute() public view returns (bool) {\r\n        return BoxImpl(addrImpl).potShouldDistribute();\r\n    }\r\n\r\n    /** @dev get round info\r\n    * @return end end of round\r\n    * @return invest total invest of round\r\n    * @return potTeam ether of team pot\r\n    * @return boxCounts total box count of each team\r\n    * @return captains captain of each team\r\n    * @return capBoxCounts total box count of each captain\r\n    */\r\n    function getRoundInfo() public view returns (\r\n        uint256 end, uint256 invest, uint256 potTeam, uint256[] boxCounts, address[] captains, uint256[] capBoxCounts) {\r\n        return BoxImpl(addrImpl).getRoundInfo();\r\n    }\r\n\r\n    /** @dev get player info\r\n    * @param addr addr of player\r\n    * @return pId player id\r\n    * @return invited invited count of players\r\n    * @return boxTotal total box count of player\r\n    * @return profitSpace profit space of player\r\n    * @return boxBalance box balance of player\r\n    * @return invitorBalance invitor balance of player\r\n    * @return potUserSeniorLast invitor balance of player cumulated\r\n    * @return boxeCounts total box count of each team\r\n    */\r\n    function getPlayerInfo(address addr) public view returns (\r\n        uint256 pId, int16 invited, uint256 boxTotal, uint256 profitSpace, uint256 boxBalance, uint256 invitorBalance, uint256 potUserSeniorLast, uint256[] boxeCounts) {\r\n        return BoxImpl(addrImpl).getPlayerInfo(addr);\r\n    }\r\n\r\n    function getPotHistory(address addr) public view returns (\r\n        uint256 time, int8 tId, address captain, uint256 potCaptain, uint256 potUser) {\r\n        return BoxImpl(addrImpl).getPotHistory(addr);\r\n    }\r\n\r\n    function _getPotTotal(BoxData data) private view returns (uint256 potTotal) {\r\n        (, , , uint256 potTeam, uint256 potTeamReserved,) = data.getRoundBase(data.nRound());\r\n        (, uint256 potUserCommon, uint256 potUserSenior) = data.getPotBase(data.nPot());\r\n        potTotal = potTeam + potTeamReserved + potUserCommon + potUserSenior;\r\n    }\r\n\r\n    function getStats() public view returns (\r\n        uint256 invest, uint256 withdraw, uint256 potCaptain, uint256 balance, uint256 potTotal, uint256 balanceTotal, uint256 devGain) {\r\n        BoxData data = BoxData(addrData);\r\n        balance = address(this).balance;\r\n        potTotal = _getPotTotal(data);\r\n\r\n        (invest, withdraw, potCaptain, devGain) = data.stats();\r\n\r\n        for (uint256 pId = 1; pId <= data.nPlayer(); pId++) {\r\n            (, , , uint256 invitorBalance, , , uint256 boxEthCur,) = data.getPlayer(pId);\r\n            balanceTotal += (invitorBalance + boxEthCur);\r\n        }\r\n    }\r\n\r\n    function withdraw(address addr, uint256 value) public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(value <= balance, \"not enough ether\");\r\n        \r\n        addr.transfer(value);\r\n    }\r\n}\r\n\r\ncontract BoxImpl is Ownable, BoxConstants, BoxEvents {\r\n    using TimeUtil for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    BoxGame public game;\r\n    BoxData public data;\r\n\r\n    constructor(address addrGame) public {\r\n        _setGame(addrGame);\r\n    }\r\n\r\n    function _setGame(address addr) private {\r\n        game = BoxGame(addr);\r\n        data = BoxData(game.addrData());\r\n    }\r\n\r\n    function setData(address addr) public {\r\n        require((address(game) == msg.sender) || (owner == msg.sender), \"can only call by admin\");\r\n\r\n        data = BoxData(addr);\r\n    }\r\n\r\n    function setGame(address addr) public {\r\n        require((owner == msg.sender) || data.roleHas(RoleAdmin, msg.sender), \"can only call by admin\");\r\n\r\n        _setGame(addr);\r\n    }\r\n\r\n    function _newRound(uint256 potTeam) private {\r\n        uint256 begin = now;\r\n        uint256 end = begin.add(RoundTimeInitial);\r\n        uint256 rId = data.newRound(end, potTeam);\r\n        emit evNewRound (\r\n            rId,\r\n            end,\r\n            potTeam,\r\n            begin\r\n        );\r\n    }\r\n\r\n    function _newPot(uint256 timeBase) private {\r\n        uint256 nowTime = now;\r\n        uint256 n;\r\n        if (nowTime >= timeBase) {\r\n            n = now.sub(timeBase).div(PotTime) + 1;\r\n        } else {\r\n            n = 0;\r\n        }\r\n        uint256 end = timeBase.add(PotTime.mul(n));\r\n        uint256 potId = data.newPot(end);\r\n        emit evNewPot (\r\n            potId,\r\n            end,\r\n            now\r\n        );\r\n    }\r\n\r\n    function activate(address, uint256 timeBase) public {\r\n        require((address(game) == msg.sender) || data.roleHas(RoleAdmin, msg.sender), \"can only call by admin\");\r\n\r\n        if (data.activated()) {\r\n            return;\r\n        }\r\n\r\n        _newRound(0);\r\n\r\n        //pot\r\n        _newPot(timeBase);\r\n\r\n        data.setActivated(true);\r\n    }\r\n\r\n    function _updateInviteInfo(address sender, uint256 invitorId) private returns (uint256, uint256) {\r\n        bool newInvited = false;\r\n\r\n        uint256 pId = data.pAddrTopId(sender);\r\n        if (0 == pId) {\r\n            if (invitorId != 0) {\r\n                newInvited = true;\r\n            }\r\n            pId = data.newPlayer(sender, invitorId);\r\n        } else {\r\n            if (pId == invitorId) {\r\n                invitorId = 0;\r\n            }\r\n\r\n            (, uint256 invitorLast, , , , , , ) = data.getPlayer(pId);\r\n            if (invitorLast != 0) {\r\n                invitorId = invitorLast;\r\n            } else if (invitorId != 0) {\r\n                data.setPlayerInvitor(pId, invitorId);\r\n                newInvited = true;\r\n            }\r\n        }\r\n        if (newInvited) {\r\n            data.incPlayerInvited(invitorId);\r\n        }\r\n        return (pId, invitorId);\r\n    }\r\n\r\n    function _addPot(uint256 value, uint256 invitorId) private {\r\n        (uint256 valUserCommon, uint256 valUserSenior, uint256 valTeam, uint256 valTeamReserved, uint256 valInvitor, uint256 valDev) = BoxCommon.calcPot(value);\r\n        data.incPot(valUserCommon, valUserSenior, valTeam, valTeamReserved);\r\n        data.addStatsDevGain(valDev);\r\n        if (invitorId != 0 && valInvitor > 0) {\r\n            data.incPlayerInvitorBalance(invitorId, valInvitor);\r\n        } else {\r\n            data.addStatsDevGain(valInvitor);\r\n        }\r\n    }\r\n\r\n    function buyBox(address sender, uint256 value, uint256 count, int8 tId, uint256 invitorId) public {\r\n        require(data.activated(), \"not activated\");\r\n        require(value >= BoxPrice.mul(count), \"not enough ether\");\r\n\r\n        uint256 pId;\r\n        (pId, invitorId) = _updateInviteInfo(sender, invitorId);\r\n\r\n        data.newBox(pId, count, tId);\r\n\r\n        (uint256 end, , , , ,) = data.getRoundBase(data.nRound());\r\n        uint256 endMax = now.add(RoundTimeMax);\r\n        end = end.add(RoundTimeAdd.mul(count));\r\n        if (end > endMax) {\r\n            end = endMax;\r\n        }\r\n        data.setRoundTime(end);\r\n\r\n        _addPot(value, invitorId);\r\n\r\n        data.addStatsInvest(value);\r\n\r\n        emit evBuyBox (\r\n            pId,\r\n            tId,\r\n            invitorId,\r\n            count,\r\n            value,\r\n            now\r\n        );\r\n    }\r\n\r\n    function roundShouldEnd() public view returns (bool) {\r\n        (uint256 end, , , , ,) = data.getRoundBase(data.nRound());\r\n        if (now >= end) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _rollLuckyTeam() private view returns(int8 tId) {\r\n        return int8(uint256(keccak256(abi.encodePacked(\r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n        ))) % 4) + 1;\r\n    }\r\n\r\n    function _distributePotTeamCaptain(uint256 potTeamCaptain, uint256 captain) private {\r\n        if(0 == captain) {\r\n            return;\r\n        }\r\n        address captainAddr = data.getPlayerAddress(captain);\r\n        game.transferToPlayer(captainAddr, potTeamCaptain, int8(BoxTypes.FinanceReason.FinancePotTeamCaptain));\r\n        data.addStatsPotCaptain(potTeamCaptain);\r\n    }\r\n\r\n    function _distributePotTeamBox(uint256 rId, uint256 potTeamBox, uint256[] players, uint256[] boxCounts, uint256 boxTotal) private {\r\n        uint256 playerCount = players.length;\r\n        if (0 == boxTotal) {\r\n            return;\r\n        }\r\n\r\n        uint256 potTeamBoxAvg = potTeamBox.div(boxTotal);\r\n        uint256[] memory vals = new uint256[](playerCount);\r\n        for (uint256 index = 0; index < playerCount; index++) {\r\n            vals[index] = potTeamBoxAvg.mul(boxCounts[index]);\r\n        }\r\n        uint256 distributed = data.addPlayerPotTeam(rId, players, vals, BoxEthMax);\r\n        if (distributed < potTeamBox) {\r\n            data.addStatsDevGain(potTeamBox - distributed);\r\n        }\r\n    }\r\n\r\n    function _rotateRound() private {\r\n        uint256 rId = data.nRound();\r\n        (, , , uint256 potTeam, uint256 potTeamReserved,) = data.getRoundBase(rId);\r\n        int8 luckyTeam = _rollLuckyTeam();\r\n        uint256 potTeamCaptain;\r\n        uint256 potTeamBox;\r\n        uint256 potNextRound;\r\n\r\n        if (potTeam > 0) {\r\n            potNextRound = potTeamReserved;\r\n            (uint256 captain, uint256[] memory players, uint256[] memory boxCounts, uint256 boxTotal) = data.getRoundTeam(rId, luckyTeam);\r\n            potTeamCaptain = potTeam.mul(PotRatioTeamCaptain).div(100);\r\n            potTeamBox = potTeam.sub(potTeamCaptain);\r\n\r\n            if (captain > 0) {\r\n                //potTeamCaptain\r\n                _distributePotTeamCaptain(potTeamCaptain, captain);\r\n\r\n                //potTeamBox\r\n                _distributePotTeamBox(rId, potTeamBox, players, boxCounts, boxTotal);\r\n            } else {\r\n                potTeamCaptain = 0;\r\n                potNextRound = potNextRound.add(potTeam);\r\n            }\r\n        }\r\n\r\n        data.setRoundPotInfo(rId, potTeamCaptain, luckyTeam);\r\n\r\n        //end round\r\n        emit evEndRound (\r\n            rId,\r\n            potTeam,\r\n            potTeamReserved,\r\n            luckyTeam,\r\n            now\r\n        );\r\n\r\n        //new round\r\n        _newRound(potNextRound);\r\n    }\r\n\r\n    function tickGame() public {\r\n        require((address(game) == msg.sender) || data.roleHas(RoleAdmin, msg.sender), \"can only call by admin\");\r\n\r\n        _rotateRound();\r\n    }\r\n\r\n    function _addPlayerPotUser(uint potId, uint256[] memory players, uint256 potUserSenior, uint256 potUserCommon, uint256 boxTotal, uint256 count, uint256[] memory boxCounts, int16[] memory inviteds) private {\r\n        (uint256[] memory valSeniors, uint256[] memory valCommons) = BoxCommon.calcPotUser(potUserSenior, potUserCommon, boxTotal, count, boxCounts, inviteds);\r\n        uint256 potTotal = potUserSenior.add(potUserCommon);\r\n        uint256 distributed = data.addPlayerPotUser(potId, players, valCommons, valSeniors, BoxEthMax);\r\n        if (distributed < potTotal) {\r\n            data.addStatsDevGain(potTotal - distributed);\r\n        }\r\n    }\r\n\r\n    function _distributePot() private {\r\n        uint potId = data.nPot();\r\n        (uint256 end, uint256 potUserCommon, uint256 potUserSenior) = data.getPotBase(potId);\r\n        if (potUserCommon > 0) {\r\n            (uint256[] memory players, uint256[] memory boxCounts, uint256 boxTotal, int16[] memory inviteds) = data.getProfitablePlayers(BoxEthMax);\r\n            uint256 count = players.length;\r\n            if (count != 0) {\r\n                _addPlayerPotUser(potId, players, potUserSenior, potUserCommon, boxTotal, count, boxCounts, inviteds);\r\n            }\r\n        }\r\n\r\n        emit evDistributePot (\r\n            potUserCommon,\r\n            potUserSenior,\r\n            boxTotal,\r\n            now\r\n        );\r\n\r\n        _newPot(end);\r\n    }\r\n\r\n    function tickPot() public {\r\n        require((address(game) == msg.sender) || data.roleHas(RoleAdmin, msg.sender), \"can only call by admin\");\r\n        \r\n        _distributePot();\r\n    }\r\n\r\n    function potShouldDistribute() public view returns (bool) {\r\n        (uint256 end, ,) = data.getPotBase(data.nPot());\r\n        if (end <= now) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function withdrawBoxBalance(address addr) public {\r\n        uint256 pId = data.pAddrTopId(addr);\r\n        uint256 eth = data.resetPlayerBoxEth(pId,  BoxEthMax);\r\n        if (eth > 0) {\r\n            game.transferToPlayer(addr, eth, int8(BoxTypes.FinanceReason.FinanceWithdrawBoxBalance));\r\n            data.addStatsWithdraw(eth);\r\n        }\r\n    }\r\n\r\n    function withdrawInvitorBalance(address addr) public {\r\n        uint256 pId = data.pAddrTopId(addr);\r\n        uint256 eth = data.resetPlayerInvitorBalance(pId);\r\n        if (eth > 0) {\r\n           game.transferToPlayer(addr, eth, int8(BoxTypes.FinanceReason.FinanceWithdrawInvitorBalance));\r\n           data.addStatsWithdraw(eth);\r\n        }\r\n    }\r\n\r\n    function getRoundInfo() public view returns (\r\n        uint256 end, uint256 invest, uint256 potTeam, uint256[] boxCounts, address[] captains, uint256[] capBoxCounts) {\r\n        uint256 rId = data.nRound();\r\n        uint256 boxTotal;\r\n        (end, boxTotal, , potTeam, ,) = data.getRoundBase(rId);\r\n        invest = boxTotal.mul(BoxPrice);\r\n\r\n        boxCounts = new uint256[](4);\r\n        captains = new address[](4);\r\n        capBoxCounts = new uint256[](4);\r\n        for (uint256 index = 0; index < 4; index++) {\r\n            int8 tId = int8(index) + 1;\r\n            (uint256 captain, , , uint256 boxCount) = data.getRoundTeam(rId, tId);\r\n            boxCounts[index] = boxCount;\r\n            captains[index] = data.getPlayerAddress(captain);\r\n            capBoxCounts[index] = data.getRoundPlayerBoxCount(rId, captain, tId);\r\n        }\r\n    }\r\n\r\n    function _getPlayerInfoEx(uint256 pId, uint256 boxCount, uint256 boxEthCum) private view returns (\r\n        uint256 profitSpace, uint256 potUserSeniorLast, uint256[] boxeCounts) {\r\n        profitSpace = BoxEthMax.mul(boxCount).sub(boxEthCum);\r\n        boxeCounts = new uint256[](4);\r\n        uint256 rId = data.nRound();\r\n        uint256 potId = data.nPot();\r\n        for (uint256 index = 0; index < 4; index++) {\r\n            boxeCounts[index] = data.getRoundPlayerBoxCount(rId, pId, int8(index) + 1);\r\n        }\r\n        if (potId > 1) {\r\n            potId -= 1;\r\n            potUserSeniorLast = data.getPotSenior(potId, pId);\r\n        }\r\n    }\r\n\r\n    function getPlayerInfo(address addr) public view returns (\r\n        uint256 pId, int16 invited, uint256 boxTotal, uint256 profitSpace, uint256 boxBalance, uint256 invitorBalance, uint256 potUserSeniorLast, uint256[] boxeCounts) {\r\n        uint256 boxCount;\r\n        uint256 boxEthCum;\r\n        pId = data.pAddrTopId(addr);\r\n        (, , invited, invitorBalance, boxCount, boxTotal, boxBalance, boxEthCum) = data.getPlayer(pId);\r\n        (profitSpace, potUserSeniorLast, boxeCounts) = _getPlayerInfoEx(pId, boxCount, boxEthCum);\r\n    }\r\n\r\n    function getPotHistory(address addr) public view returns (\r\n        uint256 time, int8 tId, address captain, uint256 potCaptain, uint256 potUser) {\r\n\r\n        uint256 rId = data.nRound();\r\n        if (1 == rId) {\r\n            return;\r\n        }\r\n        rId -= 1;\r\n        (time, , potCaptain, , , tId) = data.getRoundBase(rId);\r\n        (uint256 captainId, , ,) = data.getRoundTeam(rId, tId);\r\n        captain = data.getPlayerAddress(captainId);\r\n        potUser = data.getRoundPotPlayer(rId, data.pAddrTopId(addr));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"addrData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"tid\",\"type\":\"int8\"},{\"name\":\"invitorId\",\"type\":\"uint256\"}],\"name\":\"buyBox\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrD\",\"type\":\"address\"},{\"name\":\"addrI\",\"type\":\"address\"},{\"name\":\"timeBase\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"pId\",\"type\":\"uint256\"},{\"name\":\"invited\",\"type\":\"int16\"},{\"name\":\"boxTotal\",\"type\":\"uint256\"},{\"name\":\"profitSpace\",\"type\":\"uint256\"},{\"name\":\"boxBalance\",\"type\":\"uint256\"},{\"name\":\"invitorBalance\",\"type\":\"uint256\"},{\"name\":\"potUserSeniorLast\",\"type\":\"uint256\"},{\"name\":\"boxeCounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawInvitorBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"reason\",\"type\":\"int8\"}],\"name\":\"transferToPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tickGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addrImpl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBoxBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"invest\",\"type\":\"uint256\"},{\"name\":\"potTeam\",\"type\":\"uint256\"},{\"name\":\"boxCounts\",\"type\":\"uint256[]\"},{\"name\":\"captains\",\"type\":\"address[]\"},{\"name\":\"capBoxCounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tickPot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potShouldDistribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStats\",\"outputs\":[{\"name\":\"invest\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"uint256\"},{\"name\":\"potCaptain\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"potTotal\",\"type\":\"uint256\"},{\"name\":\"balanceTotal\",\"type\":\"uint256\"},{\"name\":\"devGain\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundShouldEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPotHistory\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"tId\",\"type\":\"int8\"},{\"name\":\"captain\",\"type\":\"address\"},{\"name\":\"potCaptain\",\"type\":\"uint256\"},{\"name\":\"potUser\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrD\",\"type\":\"address\"},{\"name\":\"addrI\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"evNewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"potId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"evNewPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tId\",\"type\":\"int8\"},{\"indexed\":true,\"name\":\"invitor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"evBuyBox\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potTeamReserved\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"luckyTeam\",\"type\":\"int8\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"evEndRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"reason\",\"type\":\"int8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"evTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"potUserCommon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potUserSenior\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"boxCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"evDistributePot\",\"type\":\"event\"}]","ContractName":"BoxGame","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://1860c5ef11d76d510efdb54aba958a7eee19ede5564c453d454e64459f6a88b1"}]}