{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\ncontract MWT_interests is Ownable, ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 midId; // mid term partition identifier\r\n    bytes32 lngId; // long term partition identifier\r\n    bytes32 perId; // perpetual partition identifier\r\n\r\n    /**\r\n      * @dev Represents the balance of a given user. The 'previous' field is used to store the\r\n      *     balance of the previous month in order to ponderate the bond's held time when updating\r\n      *     interests\r\n      */\r\n    struct Balance {\r\n        // Total number of tokens held last month\r\n        uint256 previousBalance;\r\n        // Total number of tokens held atm\r\n        uint256 currentBalance;\r\n        // Total number of months these tokens have been held as of last month\r\n        uint256 previousHolding;\r\n        // Total number of months these tokens have been held atm\r\n        uint256 currentHolding;\r\n        // How much tokens has been bought through referral\r\n        uint256 refereeBalance;\r\n        // Customizable interests rate for specific investors\r\n        uint256 customInterestRate;\r\n    }\r\n\r\n    /**\r\n      * @dev Represents all about an investor.\r\n      */\r\n    struct Info {\r\n        // Calculated according to the balance, the held time, and the token type (multiply by 1000 to get the € value)\r\n        uint256 balanceInterests;        \r\n        // Total of midterm bond tokens\r\n        Balance mid;\r\n        // Total of longterm bond tokens\r\n        Balance lng;\r\n        // Total of perpetual bond tokens\r\n        Balance per;\r\n    }\r\n\r\n    mapping (address => Info) investors;\r\n\r\n    uint256 FLOAT_FACTOR = 100000000000000; // 10^14\r\n\r\n    constructor(\r\n        bytes32 _midId,\r\n        bytes32 _lngId,\r\n        bytes32 _perId\r\n    )\r\n    public\r\n    {\r\n        midId = _midId;\r\n        lngId = _lngId;\r\n        perId = _perId;\r\n    }\r\n\r\n\r\n    /**************************** MWT_interests events ********************************/\r\n\r\n    event Refered (\r\n        address referer,\r\n        address referee,\r\n        uint256 midAmount,\r\n        uint256 lngAmount,\r\n        uint256 perAmount\r\n    );\r\n\r\n    event ModifiedReferee (\r\n        address investor,\r\n        bytes32 partitionId,\r\n        uint256 amount\r\n    );\r\n    event ModifiedInterests (\r\n        address investor,\r\n        uint256 value\r\n    );\r\n    event UpdatedInterests (\r\n        address investor,\r\n        uint256 interests\r\n    );\r\n    event CustomizedInterests (\r\n        address investor,\r\n        uint256 midRate,\r\n        uint256 lngRate,\r\n        uint256 perRate\r\n    );\r\n\r\n\r\n    /**************************** MWT_interests getters ********************************/\r\n\r\n    /**\r\n      * @dev Get the interests balance of an investor\r\n      *      this needs to be divided by FLOAT_FACTOR to get the actual amount of MWT interests\r\n      */\r\n    function interestsOf (address investor) external view returns (uint256) {\r\n        return (investors[investor].balanceInterests);\r\n    }\r\n\r\n    /**\r\n      * @dev Get the midterm bond infos of an investor\r\n      */\r\n    function midtermBondInfosOf (address investor) external view returns (\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) {\r\n        return (\r\n            investors[investor].mid.previousBalance,\r\n            investors[investor].mid.currentBalance,\r\n            investors[investor].mid.previousHolding,\r\n            investors[investor].mid.currentHolding,\r\n            investors[investor].mid.refereeBalance,\r\n            investors[investor].mid.customInterestRate\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Get the longterm bond infos of an investor\r\n      */\r\n    function longtermBondInfosOf (address investor) external view returns (\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) {\r\n        return (\r\n            investors[investor].lng.previousBalance,\r\n            investors[investor].lng.currentBalance,\r\n            investors[investor].lng.previousHolding,\r\n            investors[investor].lng.currentHolding,\r\n            investors[investor].lng.refereeBalance,\r\n            investors[investor].lng.customInterestRate\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Get the perpetual bond infos of an investor\r\n      */\r\n    function perpetualBondInfosOf (address investor) external view returns (\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) {\r\n        return (\r\n            investors[investor].per.previousBalance,\r\n            investors[investor].per.currentBalance,\r\n            investors[investor].per.previousHolding,\r\n            investors[investor].per.currentHolding,\r\n            investors[investor].per.refereeBalance,\r\n            investors[investor].per.customInterestRate\r\n\r\n        );\r\n    }\r\n\r\n    /**************************** MWT_interests external functions ********************************/\r\n\r\n    /**\r\n      * @dev Set the interests balance of an investor\r\n      *      this MUST NOT be multiplied by FLOAT_FACTOR before\r\n      */\r\n    function setInterests (address investor, uint256 value) external onlyOwner nonReentrant {\r\n        investors[investor].balanceInterests = value * FLOAT_FACTOR * 10000;\r\n\r\n        emit ModifiedInterests (investor, value);\r\n    }\r\n\r\n    /**\r\n      * @dev Set a different interest rate for specific investors\r\n      * @param investor Address for whom we decide to set a custom rate\r\n      * @param midRate The custom midterm bond intrest rate\r\n      * @param lngRate The custom longterm bond intrest rate\r\n      * @param perRate The custom perpetual bond intrest rate\r\n      */\r\n    function setCustomInterestRate (address investor, uint256 midRate, uint256 lngRate, uint256 perRate) external onlyOwner {\r\n        require(midRate <= 100 && lngRate <= 100 && perRate <= 100, \"The rate is not a percentage\");\r\n\r\n        investors[investor].mid.customInterestRate = midRate * 100 * FLOAT_FACTOR;\r\n        investors[investor].lng.customInterestRate = lngRate * 100 * FLOAT_FACTOR;\r\n        investors[investor].per.customInterestRate = perRate * 100 * FLOAT_FACTOR;\r\n\r\n        emit CustomizedInterests (investor, midRate, lngRate, perRate);\r\n    }\r\n\r\n    /**\r\n      * @dev Increases the referer interests balance of a given amount\r\n      *\r\n      * @param referer The address of the referal initiator\r\n      * @param referee The address of the referal consumer\r\n      * @param percent The percentage of interests earned by the referer\r\n      * @param midAmount How many mid term bonds the referee bought through this referal\r\n      * @param lngAmount How many long term bonds the referee bought through this referal\r\n      * @param perAmount How many perpetual tokens the referee bought through this referal\r\n      */\r\n    function updateReferralInfos (\r\n        address referer,\r\n        address referee,\r\n        uint256 percent,\r\n        uint256 midAmount,\r\n        uint256 lngAmount,\r\n        uint256 perAmount\r\n    ) external onlyOwner {\r\n        require (referer != referee && referer != address(0) && referee != address(0),\r\n                 \"Referee and/or referer address(es) is(/are) not valid.\");\r\n        require (percent >= 1 && percent <= 100, \"The given percent parameter is not a valid percentage.\");\r\n\r\n        // updates referer interest balance accounting for the referee investment\r\n        investors[referer].balanceInterests = investors[referer].balanceInterests.add(midAmount * percent * 100 * FLOAT_FACTOR);\r\n        investors[referer].balanceInterests = investors[referer].balanceInterests.add(lngAmount * percent * 100 * FLOAT_FACTOR);\r\n        investors[referer].balanceInterests = investors[referer].balanceInterests.add(perAmount * percent * 100 * FLOAT_FACTOR);\r\n\r\n        investors[referee].mid.refereeBalance = investors[referee].mid.refereeBalance.add(midAmount);\r\n        investors[referee].lng.refereeBalance = investors[referee].lng.refereeBalance.add(lngAmount);\r\n        investors[referee].per.refereeBalance = investors[referee].per.refereeBalance.add(perAmount);\r\n\r\n        emit Refered (referer, referee, midAmount, lngAmount, perAmount);\r\n    }\r\n\r\n    /**\r\n      * @dev Set the referee balance of an investor\r\n      *\r\n      * @param investor The address of the investor whose balance has to be modified\r\n      * @param partitionId The partition identifier of the token for which to modify the referee balance\r\n      * @param amount The new referee balance of the investor\r\n      */\r\n    function setRefereeAmountByPartition (\r\n        address investor,\r\n        bytes32 partitionId,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if ( partitionId == midId ) {\r\n            investors[investor].mid.refereeBalance = amount;\r\n        } else if ( partitionId == lngId ) {\r\n            investors[investor].lng.refereeBalance = amount;\r\n        } else if ( partitionId == perId ) {\r\n            investors[investor].per.refereeBalance = amount;\r\n        } else {\r\n            revert(\"The partition identifier passed as parameter is not a valid one.\");\r\n        }\r\n\r\n        emit ModifiedReferee (investor, partitionId, amount);\r\n    }\r\n\r\n    /**\r\n      * @dev Updates the investor's interests\r\n      * @dev Should (and will) be called each month\r\n      *\r\n      * @param investor The address of the investor for which to update interests\r\n      * @param midBalance Balance of mid term bond\r\n      * @param lngBalance Balance of long term bond\r\n      * @param perBalance Balance of perpetual token\r\n      */\r\n    function updateInterests (address investor, uint256 midBalance, uint256 lngBalance, uint256 perBalance) external onlyOwner nonReentrant {\r\n        // Investor's balance in each bond may have changed since last month\r\n        investors[investor].mid.currentBalance = midBalance;\r\n        investors[investor].lng.currentBalance = lngBalance;\r\n        investors[investor].per.currentBalance = perBalance;\r\n\r\n        // Increment the hodling counter : we pass to the next month. The hodling (in months) has to be adjusted\r\n        // if the longterm or perpetual bonds balance has increased\r\n        // A factor 1000 is applied to months to have a significant amount of digits for calculus\r\n        if (investors[investor].mid.currentBalance > 0) {\r\n            investors[investor].mid.currentHolding = investors[investor].mid.currentHolding.add(1000);\r\n        }\r\n        if (investors[investor].lng.currentBalance > 0) {\r\n            if (investors[investor].lng.currentBalance > investors[investor].lng.previousBalance &&\r\n                investors[investor].lng.previousBalance > 0) {\r\n                uint256 adjustmentRate = (\r\n                    (\r\n                        investors[investor].lng.currentBalance.sub(investors[investor].lng.previousBalance)\r\n                    ).mul(\r\n                      FLOAT_FACTOR.div(\r\n                        investors[investor].lng.currentBalance\r\n                      )\r\n                    )\r\n                );\r\n                investors[investor].lng.currentHolding = (\r\n                  FLOAT_FACTOR.sub(adjustmentRate)\r\n                ).mul(\r\n                  (\r\n                    investors[investor].lng.previousHolding.add(1000)\r\n                  ).div(FLOAT_FACTOR)\r\n                );\r\n            }\r\n            else {\r\n                investors[investor].lng.currentHolding = investors[investor].lng.currentHolding.add(1000);\r\n            }\r\n        }\r\n        if (investors[investor].per.currentBalance > 0) {\r\n            if (investors[investor].per.currentBalance > investors[investor].per.previousBalance &&\r\n                investors[investor].per.previousBalance > 0) {\r\n                uint256 adjustmentRate = (\r\n                    (\r\n                        investors[investor].per.currentBalance.sub(investors[investor].per.previousBalance)\r\n                    ).mul(FLOAT_FACTOR.div(investors[investor].per.currentBalance))\r\n                );\r\n                investors[investor].per.currentHolding = (\r\n                  (\r\n                    FLOAT_FACTOR.sub(adjustmentRate)\r\n                  ).mul(\r\n                    investors[investor].per.previousHolding.add(1000)\r\n                  ).div(FLOAT_FACTOR)\r\n                );\r\n            }\r\n            else {\r\n                investors[investor].per.currentHolding = investors[investor].per.currentHolding.add(1000);\r\n            }\r\n        }\r\n\r\n        // Update the investor's total interests\r\n        if (investors[investor].mid.customInterestRate > 0) {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                investors[investor].mid.customInterestRate.mul(investors[investor].mid.currentBalance)\r\n              ).div(12)\r\n            );\r\n        }\r\n        if (investors[investor].lng.customInterestRate > 0) {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                investors[investor].lng.customInterestRate.mul(investors[investor].lng.currentBalance)\r\n              ).div(12)\r\n            );\r\n        }\r\n        if (investors[investor].per.customInterestRate > 0) {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                investors[investor].per.customInterestRate.mul(investors[investor].per.currentBalance)\r\n              ).div(12)\r\n            );\r\n        }\r\n        if (investors[investor].mid.customInterestRate == 0 &&\r\n            investors[investor].lng.customInterestRate == 0 &&\r\n            investors[investor].per.customInterestRate == 0) {\r\n          _minterest(investor);\r\n        }\r\n\r\n        // We pass to the next month, hence the previous month is now the current one :D\r\n        investors[investor].per.previousHolding = investors[investor].per.currentHolding;\r\n        investors[investor].lng.previousHolding = investors[investor].lng.currentHolding;\r\n\r\n        // Same thing for balances\r\n        investors[investor].per.previousBalance = investors[investor].per.currentBalance;\r\n        investors[investor].mid.previousBalance = investors[investor].mid.currentBalance;\r\n        investors[investor].lng.previousBalance = investors[investor].lng.currentBalance;\r\n\r\n        emit UpdatedInterests (investor, investors[investor].balanceInterests);\r\n    }\r\n\r\n\r\n    /******************** MWT_interests internal functions ************************/\r\n\r\n    /**\r\n     *  @dev Calculate the investor's total interests given how many tokens he holds, their type, and\r\n     *       for how long he's been holding them.\r\n     *       For midterm bonds tokens, the interest rate is constant. For longterm and perpetual bonds tokens\r\n     *       rates are given by a table designed by the token issuer (Montessori Worldwide) which is\r\n     *       translated in Solidity as a set of conditions.\r\n     */\r\n    function _minterest (address investor) internal {\r\n        // midRate represents the interest rate of the user's midterm bonds multiplied by 10^13 (10000 * FLOAT_FACTOR)\r\n        uint256 midRate = FLOAT_FACTOR.mul(575);\r\n\r\n        // lngRate represents the interest rate of the user's midterm bonds multiplied by 10^13 (10000 * FLOAT_FACTOR)\r\n        uint256 lngRate = 0;\r\n        if (investors[investor].lng.currentBalance > 0) {\r\n            if (investors[investor].lng.currentHolding < 12000) {\r\n                if (investors[investor].lng.currentBalance < 800) {\r\n                    lngRate = FLOAT_FACTOR.mul(700);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 2400) {\r\n                    lngRate = FLOAT_FACTOR.mul(730);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 7200) {\r\n                    lngRate = FLOAT_FACTOR.mul(749);\r\n                }\r\n                else {\r\n                    lngRate = FLOAT_FACTOR.mul(760);\r\n                }\r\n            }\r\n            else if (investors[investor].lng.currentHolding < 36000) {\r\n                if (investors[investor].lng.currentBalance < 800) {\r\n                    lngRate = FLOAT_FACTOR.mul(730);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 2400) {\r\n                    lngRate = FLOAT_FACTOR.mul(745);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 7200) {\r\n                    lngRate = FLOAT_FACTOR.mul(756);\r\n                }\r\n                else {\r\n                    lngRate = FLOAT_FACTOR.mul(764);\r\n                }\r\n            }\r\n            else if (investors[investor].lng.currentHolding < 72000) {\r\n                if (investors[investor].lng.currentBalance < 800) {\r\n                    lngRate = FLOAT_FACTOR.mul(749);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 2400) {\r\n                    lngRate = FLOAT_FACTOR.mul(757);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 7200) {\r\n                    lngRate = FLOAT_FACTOR.mul(763);\r\n                }\r\n                else {\r\n                    lngRate = FLOAT_FACTOR.mul(767);\r\n                }\r\n            }\r\n            else if (investors[investor].lng.currentHolding >= 72000) {\r\n                if (investors[investor].lng.currentBalance < 800) {\r\n                    lngRate = FLOAT_FACTOR.mul(760);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 2400) {\r\n                    lngRate = FLOAT_FACTOR.mul(764);\r\n                }\r\n                else if (investors[investor].lng.currentBalance < 7200) {\r\n                    lngRate = FLOAT_FACTOR.mul(767);\r\n                }\r\n                else if (investors[investor].lng.currentBalance >= 7200) {\r\n                    lngRate = FLOAT_FACTOR.mul(770);\r\n                }\r\n            }\r\n            assert(lngRate != 0);\r\n        }\r\n\r\n        // perRate represents the interest rate of the user's midterm bonds multiplied by 10^13 (10000 * FLOAT_FACTOR)\r\n        uint256 perRate = 0;\r\n        if (investors[investor].per.currentBalance > 0) {\r\n            if (investors[investor].per.currentHolding < 12000) {\r\n                if (investors[investor].per.currentBalance < 800) {\r\n                    perRate = FLOAT_FACTOR.mul(850);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 2400) {\r\n                    perRate = FLOAT_FACTOR.mul(888);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(911);\r\n                }\r\n                else if (investors[investor].per.currentBalance >= 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(925);\r\n                }\r\n            }\r\n            else if (investors[investor].per.currentHolding < 36000) {\r\n                if (investors[investor].per.currentBalance < 800) {\r\n                    perRate = FLOAT_FACTOR.mul(888);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 2400) {\r\n                    perRate = FLOAT_FACTOR.mul(906);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(919);\r\n                }\r\n                else if (investors[investor].per.currentBalance >= 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(930);\r\n                }\r\n            }\r\n            else if (investors[investor].per.currentHolding < 72000) {\r\n                if (investors[investor].per.currentBalance < 800) {\r\n                    perRate = FLOAT_FACTOR.mul(911);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 2400) {\r\n                    perRate = FLOAT_FACTOR.mul(919);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(927);\r\n                }\r\n                else if (investors[investor].per.currentBalance >= 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(934);\r\n                }\r\n            }\r\n            else if (investors[investor].per.currentHolding >= 72000) {\r\n                if (investors[investor].per.currentBalance < 800) {\r\n                    perRate = FLOAT_FACTOR.mul(925);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 2400) {\r\n                    perRate = FLOAT_FACTOR.mul(930);\r\n                }\r\n                else if (investors[investor].per.currentBalance < 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(934);\r\n                }\r\n                else if (investors[investor].per.currentBalance >= 7200) {\r\n                    perRate = FLOAT_FACTOR.mul(937);\r\n                }\r\n            }\r\n            assert(perRate != 0);\r\n        }\r\n\r\n        // The total user interests are incremented by this month's interests in each bond\r\n        // We divide by 12 because the interest rate is calculated on a yearly basis\r\n        // \"102\" factor is applied in the case the user benefits from the referee bonus of 2% (only applies to the \"referee\" balance)\r\n        if (investors[investor].mid.refereeBalance > 0) {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                (\r\n                  midRate.mul(102)\r\n                ).mul(investors[investor].mid.refereeBalance)\r\n              ).div(1200)\r\n            );\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                (\r\n                  investors[investor].mid.currentBalance.sub(investors[investor].mid.refereeBalance)\r\n                ).mul(midRate)\r\n              ).div(12)\r\n            );\r\n        } else {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                investors[investor].mid.currentBalance.mul(midRate)\r\n              ).div(12)\r\n            );\r\n        }\r\n\r\n        if (investors[investor].lng.refereeBalance > 0) {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                (\r\n                  lngRate.mul(102)\r\n                ).mul(investors[investor].lng.refereeBalance)\r\n              ).div(1200)\r\n            );\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                (\r\n                  investors[investor].lng.currentBalance.sub(investors[investor].lng.refereeBalance)\r\n                ).mul(lngRate)\r\n              ).div(12)\r\n            );\r\n        } else {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                lngRate.mul(investors[investor].lng.currentBalance)\r\n              ).div(12)\r\n            );\r\n        }    \r\n\r\n        if (investors[investor].per.refereeBalance > 0) {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                (\r\n                  perRate.mul(investors[investor].per.refereeBalance)\r\n                ).mul(102)\r\n              ).div(1200)\r\n            );\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                (\r\n                  investors[investor].per.currentBalance.sub(investors[investor].per.refereeBalance)\r\n                ).mul(perRate)\r\n              ).div(12)\r\n            );\r\n        } else {\r\n            investors[investor].balanceInterests = investors[investor].balanceInterests.add(\r\n              (\r\n                perRate.mul(investors[investor].per.currentBalance)\r\n              ).div(12)\r\n            );\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"referer\",\"type\":\"address\"},{\"name\":\"referee\",\"type\":\"address\"},{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"midAmount\",\"type\":\"uint256\"},{\"name\":\"lngAmount\",\"type\":\"uint256\"},{\"name\":\"perAmount\",\"type\":\"uint256\"}],\"name\":\"updateReferralInfos\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"perpetualBondInfosOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"midRate\",\"type\":\"uint256\"},{\"name\":\"lngRate\",\"type\":\"uint256\"},{\"name\":\"perRate\",\"type\":\"uint256\"}],\"name\":\"setCustomInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"midtermBondInfosOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"interestsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"longtermBondInfosOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"partitionId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setRefereeAmountByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setInterests\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"midBalance\",\"type\":\"uint256\"},{\"name\":\"lngBalance\",\"type\":\"uint256\"},{\"name\":\"perBalance\",\"type\":\"uint256\"}],\"name\":\"updateInterests\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_midId\",\"type\":\"bytes32\"},{\"name\":\"_lngId\",\"type\":\"bytes32\"},{\"name\":\"_perId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"midAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lngAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"perAmount\",\"type\":\"uint256\"}],\"name\":\"Refered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"partitionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ModifiedReferee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ModifiedInterests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"interests\",\"type\":\"uint256\"}],\"name\":\"UpdatedInterests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"midRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lngRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"perRate\",\"type\":\"uint256\"}],\"name\":\"CustomizedInterests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MWT_interests","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"6d696400000000000000000000000000000000000000000000000000000000006c6e6700000000000000000000000000000000000000000000000000000000007065720000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://64a41d8b96986b231bc57b26486284926971846c216b965546fc9bbf9d260c53"}]}