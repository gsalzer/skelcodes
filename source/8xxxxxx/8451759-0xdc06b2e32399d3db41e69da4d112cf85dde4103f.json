{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity 0.5.11;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IArbitrableTokenList {\r\n    \r\n    enum TokenStatus {\r\n        Absent, // The token is not in the registry.\r\n        Registered, // The token is in the registry.\r\n        RegistrationRequested, // The token has a request to be added to the registry.\r\n        ClearingRequested // The token has a request to be removed from the registry.\r\n    }\r\n    \r\n    function getTokenInfo(bytes32) external view returns (string memory, string memory, address, string memory, TokenStatus, uint);\r\n    function queryTokens(bytes32 _cursor, uint _count, bool[8] calldata _filter, bool _oldestFirst, address _tokenAddr)\r\n        external\r\n        view\r\n        returns (bytes32[] memory values, bool hasMore);\r\n    function tokenCount() external view returns (uint);\r\n}\r\n\r\n/** @title TokensView\r\n *  Utility view contract to fetch multiple token information at once.\r\n */\r\ncontract TokensView {\r\n    \r\n    struct Token {\r\n        bytes32 ID;\r\n        string name;\r\n        string ticker;\r\n        address addr;\r\n        string symbolMultihash;\r\n        IArbitrableTokenList.TokenStatus status;\r\n        uint decimals;\r\n    }\r\n    \r\n    /** @dev Fetch up to 500 token IDs of the first tokens present on the tcr with the address.\r\n     *  @param _t2crAddress The address of the t2cr contract from where to fetch token information.\r\n     *  @param _tokenAddresses The address of each token.\r\n     *  @return The IDs of the tokens or 0 if the token is not present.\r\n     */\r\n    function getTokensIDsForAddresses(address _t2crAddress, address[] calldata _tokenAddresses) external view returns (bytes32[500] memory tokenIDs) {\r\n        IArbitrableTokenList t2cr = IArbitrableTokenList(_t2crAddress);\r\n        bytes32 ZERO_ID = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        for (uint i = 0; i < _tokenAddresses.length; i++){\r\n            (bytes32[] memory tokenID, ) = t2cr.queryTokens(ZERO_ID, 50, [false, true, false, true, false, true, false, false], true, _tokenAddresses[i]);\r\n            tokenIDs[i] = tokenID[0];\r\n        }\r\n    }\r\n    \r\n    /** @dev Fetch up token information with token IDs. If a token contract does not implement the decimals() function, its decimals field will be 0.\r\n     *  @param _t2crAddress The address of the t2cr contract from where to fetch token information.\r\n     *  @param _tokenIDs The IDs of the tokens we want to query.\r\n     *  @return tokens The tokens information.\r\n     */\r\n    function getTokens(address _t2crAddress, bytes32[] calldata _tokenIDs) \r\n        external \r\n        view \r\n        returns (Token[] memory tokens)\r\n    {\r\n        IArbitrableTokenList t2cr = IArbitrableTokenList(_t2crAddress);\r\n        tokens = new Token[](_tokenIDs.length);\r\n        for (uint i = 0; i < _tokenIDs.length ; i++){\r\n            string[] memory strings = new string[](3); // name, ticker and symbolMultihash respectively.\r\n            address tokenAddress;\r\n            IArbitrableTokenList.TokenStatus status;\r\n            (\r\n                strings[0], \r\n                strings[1], \r\n                tokenAddress, \r\n                strings[2], \r\n                status, \r\n            ) = t2cr.getTokenInfo(_tokenIDs[i]);\r\n            \r\n            tokens[i] = Token(\r\n                _tokenIDs[i],\r\n                strings[0],\r\n                strings[1],\r\n                tokenAddress,\r\n                strings[2],\r\n                status,\r\n                0\r\n            );\r\n            \r\n            // Call the contract's decimals() function without reverting when\r\n            // the contract does not implement it.\r\n            // \r\n            // Two things should be noted: if the contract does not implement the function\r\n            // and does not implement the contract fallback function, `success` will be set to\r\n            // false and decimals won't be set. However, in some cases (such as old contracts) \r\n            // the fallback function is implemented, and so staticcall will return true\r\n            // even though the value returned will not be correct (the number below):\r\n            // \r\n            // 22270923699561257074107342068491755213283769984150504402684791726686939079929\r\n            //\r\n            // We handle that edge case by also checking against this value.\r\n            uint decimals;\r\n            bool success;\r\n            bytes4 sig = bytes4(keccak256(\"decimals()\"));\r\n            assembly {\r\n                let x := mload(0x40)   // Find empty storage location using \"free memory pointer\"\r\n                mstore(x, sig)          // Set the signature to the first call parameter. 0x313ce567 === bytes4(keccak256(\"decimals()\")\r\n                success := staticcall(\r\n                    30000,              // 30k gas\r\n                    tokenAddress,       // The call target.\r\n                    x,                  // Inputs are stored at location x\r\n                    0x04,               // Input is 4 bytes long\r\n                    x,                  // Overwrite x with output\r\n                    0x20                // The output length\r\n                )\r\n                \r\n                decimals := mload(x)   \r\n            }\r\n            if (success && decimals != 22270923699561257074107342068491755213283769984150504402684791726686939079929) {\r\n                tokens[i].decimals = decimals;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getTokensIDsForAddresses\",\"outputs\":[{\"internalType\":\"bytes32[500]\",\"name\":\"tokenIDs\",\"type\":\"bytes32[500]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t2crAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_tokenIDs\",\"type\":\"bytes32[]\"}],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"ID\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbolMultihash\",\"type\":\"string\"},{\"internalType\":\"enum IArbitrableTokenList.TokenStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"internalType\":\"struct TokensView.Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokensView","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ae563d650b5ed862abf771c6449ff0d11e0013b8c082461e2994d905c7065b3"}]}