{"status":"1","message":"OK","result":[{"SourceCode":"{\"FWLogic.sol\":{\"content\":\"pragma solidity ^0.5.5;\\nimport \\\"./FWStorage.sol\\\";\\n\\ncontract FWLogic is FWStorage {\\n     event CollectProfit(address indexed from, uint256 staticAmount, uint256 dynamicAmount);\\n     event Invest(address indexed from, uint256 amount, uint64 referCode);\\n     event AppendInvest(address indexed from, uint256 amount);\\n     event UserWithdraw(address indexed from, uint amount);\\n     \\n        //可以接收以太币的特殊函数(payable)\\n    function() payable external{\\n        ethMissPool = SafeMath.add(ethMissPool,msg.value);\\n    }\\n    function transferOwnership(address newOwner) public isOwner {\\n\\t\\trequire(newOwner != address(0x0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\t_owner = newOwner;\\n\\t}\\n    /**\\n     * 投资eth\\n     * referrNO:6位邀请码\\n     * 转入ETH到合约储存池\\n     */\\n    function invest(uint64 referrNO)public payable{\\n\\n        require(msg.value \\u003e= minInvest, \\\"less than min\\\");\\n        require (SafeMath.add(msg.value, totalInvestAmount) \\u003c= getCapacity(), \\\"more than capacity\\\");\\n        User storage o_user = addressToUser[msg.sender];\\n        require(SafeMath.add(msg.value, o_user.investAmount) \\u003c= maxInvest, \\\"more than max\\\");\\n\\n        if (o_user.inviter == address(0x0)){\\n            //初次投资\\n            address r_address =  codeToAddress[referrNO];\\n            require (r_address != address(0x0), \\\"invalid referrNO\\\");\\n            User  storage r_user = addressToUser[r_address];\\n            r_user.children.push(msg.sender);\\n            o_user.birth = now;\\n            o_user.inviter = r_user.userAddress;\\n            o_user.userAddress = msg.sender;\\n            codeToAddress[currentReferCode] = msg.sender;\\n            o_user.referCode = currentReferCode;\\n            currentReferCode = currentReferCode + 9;\\n            investors.push(msg.sender);\\n            globalNodeNumber = globalNodeNumber + 1;\\n            r_user.invitersCount = SafeMath.add(r_user.invitersCount , msg.value);\\n             r_user.achieveTime = now;\\n             battleWithTop(r_address);\\n             emit Invest(msg.sender, msg.value, referrNO);\\n        }else{\\n            //原来投资过的人\\n            haveFun();\\n            address r_address = o_user.inviter;\\n            User  storage r_user = addressToUser[r_address];\\n            r_user.invitersCount = SafeMath.add(r_user.invitersCount , msg.value);\\n            r_user.achieveTime = now;\\n            battleWithTop(r_address);\\n            emit AppendInvest(msg.sender, msg.value);\\n        }\\n        o_user.investAmount = SafeMath.add(o_user.investAmount, msg.value);\\n        o_user.allInvestAmount = SafeMath.add(o_user.allInvestAmount, msg.value);\\n        o_user.rebirth = now;\\n\\n        \\n    totalInvestAmount = totalInvestAmount + msg.value;\\n    address payable payFoundingPool = address(uint160(foundingPool));\\n    payFoundingPool.transfer(SafeMath.div( msg.value, 100));\\n    address payable payAppFund = address(uint160(appFund));\\n    payAppFund.transfer(SafeMath.div( msg.value, 50));\\n    racePool = SafeMath.add(racePool, SafeMath.div(msg.value, 100));\\n    }\\n    function battleWithTop(address _add) public{\\n         User memory challenger = addressToUser[_add];\\n         address minAdd = topUsers[8];\\n         User memory minWinner = addressToUser[minAdd];\\n         if (challenger.invitersCount \\u003c= minWinner.invitersCount){\\n             return;\\n         }\\n        uint hitIndex = 100;\\n        for (uint h = 0; h \\u003c 9; h++){\\n            address winnerAdd = topUsers[h];\\n            if (winnerAdd == _add){\\n                hitIndex = h;\\n                break;\\n            }\\n        }\\n        if (hitIndex \\u003c 9){ \\n            //hitted\\n           \\n            for (uint g = hitIndex; g \\u003e 0; g--){\\n                address winnerAdd = topUsers[g - 1];\\n                User memory winner = addressToUser[winnerAdd];\\n                if (challenger.invitersCount \\u003e winner.invitersCount){\\n                   //change index;\\n                   topUsers[g] = topUsers[g - 1];\\n                   topUsers[g - 1] = _add;\\n                }\\n            }\\n        }else {\\n       \\n            uint index = 100;\\n            for (uint i = 0; i \\u003c 9; i ++){\\n                address winnerAdd = topUsers[i];\\n                User memory winner = addressToUser[winnerAdd];\\n                if (challenger.invitersCount \\u003e winner.invitersCount){\\n                    index = i;\\n                    break;\\n                }\\n             }\\n             if (index \\u003c 9){\\n                for (uint j = 8; j \\u003e index; j--){\\n                 topUsers[j] = topUsers[j - 1];\\n                 }\\n                 topUsers[index] = _add;\\n             }\\n             \\n             \\n            }\\n    }\\n    function getCapacity() public view returns (uint) {\\n        uint ages = (SafeMath.div(SafeMath.sub(now , contractBirthDay), oneLoop)) + 1;\\n        uint capacity =  (11 ** ages) * 10000 / (10 ** ages) - 10000;\\n        return capacity * 1 ether;\\n    }\\n     function happy() public{\\n         \\n        User storage _user = addressToUser[msg.sender];\\n        require(!_user.inserted, \\\"can\\u0027t withdraw form insert\\\");\\n        uint payAmount = _user.investAmount;\\n        require (payAmount \\u003e 0, \\\"no amount\\\");\\n        uint ages = SafeMath.div(SafeMath.sub(now , _user.birth), oneLoop);\\n        uint residue = ages % (roundOfLoop + 1);\\n        require (residue == roundOfLoop, \\\"not today\\\");\\n        address payable needPay = address(uint160(_user.userAddress));\\n        _user.investAmount = 0;\\n        uint ring = SafeMath.div(ages, (roundOfLoop + 1));\\n        if (ring \\u003e 3){\\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 95));\\n            address payable pool = address(uint160(guaranteePool));\\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),5));\\n        }else if (ring \\u003e 2){\\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 90));\\n            address payable pool = address(uint160(guaranteePool));\\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),10));\\n        }else if (ring \\u003e 1){\\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 85));\\n            address payable pool = address(uint160(guaranteePool));\\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),15));\\n        }else {\\n            needPay.transfer(SafeMath.mul(SafeMath.div(payAmount,100), 80));\\n            address payable pool = address(uint160(guaranteePool));\\n            pool.transfer(SafeMath.mul( SafeMath.div(payAmount,100),20));\\n        }\\n        emit UserWithdraw(msg.sender, payAmount);\\n    }\\n    function haveFun() public {\\n        \\n        User storage _user = addressToUser[msg.sender];\\n        uint sAmount = getLiveStaticProfit(msg.sender);\\n        uint dAmount = getLiveDynamicProfit(msg.sender);\\n        _user.gottenStaticProfit = SafeMath.add(_user.gottenStaticProfit, sAmount);\\n        _user.gottenDynamicProfit = SafeMath.add(_user.gottenDynamicProfit, dAmount);\\n        _user.rebirth = now;\\n        msg.sender.transfer(SafeMath.add(sAmount, dAmount));\\n                 //动态奖励\\n        if (dAmount \\u003e 0){\\n            address payable safePool = address(uint160(fusePool));\\n            safePool.transfer(SafeMath.div(dAmount, 5));\\n        }\\n        emit CollectProfit(msg.sender, sAmount, dAmount);\\n    }\\n    function getLast10Children(address _par)public view returns(address[] memory){\\n         User memory _user = addressToUser[_par];\\n         if (_user.children.length \\u003e= 10) {\\n             address[] memory last10 = new address[](10);\\n             uint j = 0;\\n             for (uint i = _user.children.length - 10; i \\u003c _user.children.length;i++){\\n                 last10[j] = _user.children[i];\\n                 j++;\\n             }\\n             return last10;\\n         }else {\\n             return _user.children;\\n         }\\n    }\\n    function getOneDayStatic(address _address) public view returns(uint){\\n        if (getLevel(_address) == 1){\\n             User memory _user = addressToUser[_address];\\n              return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),13 ); //0.7%\\n        }else if (getLevel(_address) == 2){\\n             User memory _user = addressToUser[_address];\\n            return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),12 ); //0.8%\\n        }else if (getLevel(_address) == 3){\\n               User memory _user = addressToUser[_address];\\n              return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),11 ); //1.0%\\n        }else if (getLevel(_address) == 4){\\n              User memory _user = addressToUser[_address];\\n             return SafeMath.mul(SafeMath.div(_user.investAmount, 1000),11 ); //1.1%\\n        }\\n        return 0;\\n    }\\n    function getOneDayStaticPure(uint _amount) public pure returns (uint){\\n      \\n        if (_amount \\u003e= 16 ether){\\n             return SafeMath.mul(SafeMath.div(_amount, 1000),11 );\\n        }else if (_amount \\u003e= 11 ether){\\n             return SafeMath.mul(SafeMath.div(_amount, 1000),11 );\\n        }else if (_amount \\u003e= 6 ether){\\n             return SafeMath.mul(SafeMath.div(_amount, 1000),12 );\\n        }else if (_amount \\u003e= 1 ether){\\n            return SafeMath.mul(SafeMath.div(_amount, 1000),13);\\n        }   \\n            return 0;\\n    }\\n    function getOneDayDynamic(address _address) public view returns(uint){\\n        User memory _user = addressToUser[_address];\\n       if (getLevel(_address) == 0){\\n           return 0;\\n       }else  if (getLevel(_address) == 1){\\n            return getChildrenDynamic(_user.investAmount, _address, 1, 1, 0);\\n       }else  if (getLevel(_address) == 2){\\n           return  getChildrenDynamic(_user.investAmount, _address, 1, 2, 0);\\n       }else  if (getLevel(_address) == 3){\\n           return getChildrenDynamic(_user.investAmount, _address, 1, 10, 0);\\n       }else  if (getLevel(_address) == 4){\\n           return getChildrenDynamic(_user.investAmount, _address, 1, 59, 0);\\n       }\\n    }\\n\\n    function getLiveStaticProfit(address _address) public view returns(uint){\\n        User memory _user = addressToUser[_address];\\n        uint times = now - _user.rebirth;\\n        uint minu = SafeMath.div(times, 60);\\n        uint profit =  SafeMath.div(SafeMath.mul(getOneDayStatic(_address), minu), 1440);\\n        return profit;\\n        \\n    }\\n    function getLiveDynamicProfit(address _address) public view returns(uint){\\n                User memory _user = addressToUser[_address];\\n        uint times = now - _user.rebirth;\\n        uint minu = SafeMath.div(times, 60);\\n        uint profit =  SafeMath.div(SafeMath.mul(getOneDayDynamic(_address), minu), 1440);\\n        return profit;\\n    }\\n    \\n    \\n    function getChildrenDynamic(uint adamAmount, address _par,uint8 generation,uint endGeneration, uint total) public view returns (uint){\\n         User memory _user = addressToUser[_par];\\n         address[] memory child = _user.children;\\n            if (child.length == 0){\\n                return total;\\n            }\\n            uint myTotal = 0;\\n          for (uint i = 0; i \\u003c child.length; i ++){\\n             User memory _childUser = addressToUser[child[i]];\\n             uint8 level = getLevel(_childUser.userAddress);\\n             uint rate = getDynamicRateByLevel(level, generation);\\n             uint staticReward = 0;\\n             if (adamAmount \\u003c= _childUser.investAmount){\\n             staticReward = getOneDayStaticPure(adamAmount);\\n            }else {\\n                staticReward = getOneDayStatic(_childUser.userAddress);\\n            }\\n             if (generation \\u003c endGeneration){\\n               myTotal = getChildrenDynamic(adamAmount, _childUser.userAddress, generation + 1, endGeneration, myTotal);\\n           }\\n        myTotal = myTotal + SafeMath.mul(SafeMath.div(staticReward , 100),rate);\\n    }\\n        return myTotal + total;\\n    }\\n    \\n    function getDynamicRateByLevel(uint8 _level, uint _generation)public pure returns (uint){\\n        if (_level == 1){\\n            if (_generation == 1){\\n                return 60;\\n            }\\n        }else if (_level == 2){\\n            if (_generation == 1){\\n            return 70;\\n        }else if (_generation == 2){\\n             return 30;\\n        }\\n        }else if (_level == 3){\\n            if (_generation == 1){\\n              return 80;\\n            }else if (_generation == 2){\\n              return 30;\\n            }else if (_generation == 3){\\n              return 20;\\n            }else if (_generation \\u003c= 10){\\n              return 10;\\n            }\\n\\n        }else if (_level == 4){\\n             if (_generation == 1){\\n                return 100;\\n            }else if (_generation == 2){\\n                return 40;\\n            }else if (_generation == 3){\\n                return 30;\\n             }else if (_generation \\u003c= 10){\\n                 return 10;\\n             }else if (_generation \\u003c= 15){\\n                 return 5;\\n             }else if (_generation \\u003c= 99){\\n              return 1; \\n         }\\n         }\\n        return 0;\\n    }\\n\\n    function canHappyU(address _add)public view returns(uint){\\n        User storage _user = addressToUser[_add];\\n        uint ages = SafeMath.div(SafeMath.sub(now , _user.birth), oneLoop);\\n        uint residue = ages % (roundOfLoop + 1);\\n        if (residue == roundOfLoop){\\n            return 1;\\n        }else {\\n            return 2;\\n        }\\n        \\n    }\\n\\n    function getLevel(address _address) public view returns(uint8){\\n        User memory _user = addressToUser[_address];\\n        if (_user.investAmount \\u003e= 16 ether){\\n            return 4;\\n        }else if (_user.investAmount \\u003e= 11 ether){\\n             return 3;\\n        }else if (_user.investAmount \\u003e= 6 ether){\\n             return 2;\\n        }else if (_user.investAmount \\u003e= 1 ether){\\n            return 1;\\n        }   \\n            return 0;\\n    }\\n    function getTeamScore(address _address)public view returns (uint256){\\n        return getChildrenTeamScore(_address, 1, 59, 0);\\n    }\\n\\n    function getChildrenTeamScore(address _par,uint8 generation,uint endGeneration, uint total) public view returns (uint){\\n\\n         User memory _user = addressToUser[_par];\\n         address[] memory child = _user.children;\\n            if (child.length == 0){\\n            return total;\\n        }\\n        uint myTotal = 0;\\n        for (uint i = 0; i \\u003c child.length; i ++){\\n             User memory _childUser = addressToUser[child[i]];\\n             uint amount = _childUser.allInvestAmount;\\n             if (generation \\u003c endGeneration){\\n               myTotal = getChildrenTeamScore(_childUser.userAddress, generation + 1, endGeneration, myTotal);\\n             }\\n        myTotal = myTotal + amount;\\n      }\\n        return myTotal + total;\\n    }\\n    function sendRace() public isOwner{\\n//发放竞赛奖励,每月一次\\n        address[] memory top10 = topUsers;\\n        uint256[9] memory rate = [uint256(40),20,10,5,5,5,5,5,5];\\n        uint256 sendedAmount = 0;\\n        for (uint i = 0; i \\u003c 10; i ++){\\n            address _add = top10[i];\\n            if (_add != address(0x0)){\\n                User memory _user = addressToUser[_add];\\n                if (_user.invitersCount != 0){\\n                    address payable needPay = address(uint160(_user.userAddress));\\n                    needPay.transfer(SafeMath.mul(SafeMath.div(racePool, 100), rate[i]));\\n                    sendedAmount = sendedAmount + SafeMath.mul(SafeMath.div(racePool, 100), rate[i]);\\n                }\\n            }\\n        }\\n        racePool = SafeMath.sub(racePool, sendedAmount);\\n    }\\n    function getTopInfo (uint rank)public view returns(address, uint, uint){\\n        address _add = topUsers[rank];\\n         if (_add == address(0x0)){\\n             return(address(0x0),0,0);\\n           }else {\\n         User memory userRank = addressToUser[_add];\\n         return (userRank.userAddress,userRank.children.length,userRank.invitersCount);\\n      }\\n    }\\n    function resetRace(uint _from, uint _to) public isOwner{\\n        for (uint i = _from; i \\u003c _to; i ++){\\n            User storage _user = addressToUser[investors[i]];\\n            _user.invitersCount = 0;\\n        }\\n    }\\n    \\n  \\n}\"},\"FWStorage.sol\":{\"content\":\"pragma solidity ^0.5.5;\\nlibrary SafeMath{\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256){\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256){\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256){\\n        uint256 c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\\ncontract FWStorage {\\n    modifier isOwner() {\\n        require(msg.sender == _owner);\\n        _;\\n    }\\n    struct User{\\n        address userAddress;\\n        uint investAmount;   //投资的数量\\n        uint allInvestAmount;   //\\n        address inviter;    //邀请我的人\\n        address[] children; //我直接邀请的人\\n        uint invitersCount;   //本月邀请的人数ETH,参与竞赛\\n        uint achieveTime;   //达成时间\\n        uint annualRing;  //经历过的轮数\\n        uint64 referCode;   //我的邀请码\\n         uint birth;               //初次投资时间\\n         uint rebirth;             //本轮生效时间\\n         uint gottenStaticProfit;\\n         uint gottenDynamicProfit;\\n        bool inserted;\\n    }\\n    address _owner;\\n    address[] public investors;\\n    mapping (address =\\u003e User) public addressToUser;\\n    mapping (uint64 =\\u003e address) public codeToAddress;\\n    //最小投资eth数量\\n    uint256 minInvest;\\n    //最大投资eth数量\\n    uint256 maxInvest;\\n    //第一位邀请人推荐码\\n    uint64 currentReferCode;\\n\\n    //全球节点\\n    uint256 public globalNodeNumber = 0;\\n    //合约总量\\n    uint256 public totalInvestAmount;  //总流水\\n    \\n    uint256 public insertedNodeNumber = 0;\\n    uint256 public insertedAmount;\\n\\n    //用于接收直接打入合约的以太币\\n    uint256 public ethMissPool; //balance direct send to this contract ,sorry ,it will not in ethFundPool\\n    uint256 public racePool;   //基金数量 ,用于发放竞赛的资金   充值的1%\\n    // address racePool;  //基金,用于发放竞赛的资金   充值的1%\\n    address fusePool;     //保险池,入金最后一名投资额的10倍奖励,最后99名平分  动态的20%\\n    address guaranteePool;    //保障池       提现扣手续费\\n    address foundingPool;     //创始团队     充值的1%\\n    address appFund;          //应用专款     充值的2%\\n    uint256 oneLoop = 24 hours;\\n    uint256 roundOfLoop = 9;\\n    uint256 contractBirthDay;\\n    address[] public topUsers;\\n    constructor() public{\\n        _owner = msg.sender;\\n        minInvest = 1 ether;\\n        maxInvest = 29 ether;\\n        currentReferCode = 218870;\\n        // empty.push(this);\\n        User memory creation = User(msg.sender, minInvest,minInvest, address(0x0), new address[](0),0, 0,0,currentReferCode,now, now,0,0, false);\\n        topUsers = new address[](9);\\n    addressToUser[msg.sender] = creation;\\n    codeToAddress[currentReferCode] = msg.sender;\\n    currentReferCode = currentReferCode + 9;\\n    contractBirthDay = now;\\n    fusePool = msg.sender;\\n    guaranteePool = msg.sender;\\n    foundingPool = msg.sender;\\n    appFund = msg.sender;\\n    }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"insertedNodeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insertedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLiveDynamicProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalNodeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_par\",\"type\":\"address\"},{\"name\":\"generation\",\"type\":\"uint8\"},{\"name\":\"endGeneration\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"getChildrenTeamScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"codeToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"canHappyU\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOneDayStaticPure\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrNO\",\"type\":\"uint64\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethMissPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adamAmount\",\"type\":\"uint256\"},{\"name\":\"_par\",\"type\":\"address\"},{\"name\":\"generation\",\"type\":\"uint8\"},{\"name\":\"endGeneration\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"getChildrenDynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haveFun\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTeamScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_par\",\"type\":\"address\"}],\"name\":\"getLast10Children\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_generation\",\"type\":\"uint256\"}],\"name\":\"getDynamicRateByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"getTopInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLiveStaticProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getOneDayDynamic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"resetRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCapacity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getOneDayStatic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"racePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"happy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToUser\",\"outputs\":[{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"investAmount\",\"type\":\"uint256\"},{\"name\":\"allInvestAmount\",\"type\":\"uint256\"},{\"name\":\"inviter\",\"type\":\"address\"},{\"name\":\"invitersCount\",\"type\":\"uint256\"},{\"name\":\"achieveTime\",\"type\":\"uint256\"},{\"name\":\"annualRing\",\"type\":\"uint256\"},{\"name\":\"referCode\",\"type\":\"uint64\"},{\"name\":\"birth\",\"type\":\"uint256\"},{\"name\":\"rebirth\",\"type\":\"uint256\"},{\"name\":\"gottenStaticProfit\",\"type\":\"uint256\"},{\"name\":\"gottenDynamicProfit\",\"type\":\"uint256\"},{\"name\":\"inserted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"battleWithTop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"staticAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dynamicAmount\",\"type\":\"uint256\"}],\"name\":\"CollectProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referCode\",\"type\":\"uint64\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AppendInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserWithdraw\",\"type\":\"event\"}]","ContractName":"FWLogic","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://e8c1baef316fa7112ae5869e51e41068ea971e769ae0ef7cd0bc99debf96e30f"}]}