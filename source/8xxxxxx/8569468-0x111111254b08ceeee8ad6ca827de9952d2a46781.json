{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary ExternalCall {\r\n    // Source: https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function externalCall(address destination, uint value, bytes memory data, uint dataOffset, uint dataLength) internal returns(bool result) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                add(d, dataOffset),\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract IZrxExchange {\r\n\r\n    struct Order {\r\n        address makerAddress;           // Address that created the order.\r\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\r\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\r\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\r\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\r\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\r\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\r\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\r\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\r\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\r\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\r\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\r\n        bytes32 orderHash;                    // EIP712 hash of the order (see IZrxExchange.getOrderHash).\r\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\r\n    }\r\n\r\n    struct FillResults {\r\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\r\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\r\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\r\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\r\n    }\r\n\r\n    function getOrderInfo(Order memory order)\r\n        public\r\n        view\r\n        returns (OrderInfo memory orderInfo);\r\n\r\n    function getOrdersInfo(Order[] memory orders)\r\n        public\r\n        view\r\n        returns (OrderInfo[] memory ordersInfo);\r\n\r\n    function fillOrder(\r\n        Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (FillResults memory fillResults);\r\n\r\n    function fillOrderNoThrow(\r\n        Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (FillResults memory fillResults);\r\n}\r\n\r\n\r\ncontract IGST2 is IERC20 {\r\n\r\n    function freeUpTo(uint256 value) external returns (uint256 freed);\r\n\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract IWETH is IERC20 {\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\n\r\n\r\ncontract Shutdownable is Ownable {\r\n\r\n    bool public isShutdown;\r\n\r\n    event Shutdown();\r\n\r\n    modifier notShutdown {\r\n        require(!isShutdown, \"Smart contract is shut down.\");\r\n        _;\r\n    }\r\n\r\n    function shutdown() public onlyOwner {\r\n        isShutdown = true;\r\n        emit Shutdown();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract IERC20NonView {\r\n    // Methods are not view to avoid throw on proxy tokens with delegatecall inside\r\n    function balanceOf(address user) public returns(uint256);\r\n    function allowance(address from, address to) public returns(uint256);\r\n}\r\n\r\ncontract ZrxMarketOrder {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    function marketSellOrdersProportion(\r\n        IERC20 tokenSell,\r\n        address tokenBuy,\r\n        address zrxExchange,\r\n        address zrxTokenProxy,\r\n        IZrxExchange.Order[] calldata orders,\r\n        bytes[] calldata signatures,\r\n        uint256 mul,\r\n        uint256 div\r\n    )\r\n        external\r\n    {\r\n        uint256 amount = tokenSell.balanceOf(msg.sender).mul(mul).div(div);\r\n        this.marketSellOrders(tokenBuy, zrxExchange, zrxTokenProxy, amount, orders, signatures);\r\n    }\r\n\r\n    function marketSellOrders(\r\n        address makerAsset,\r\n        address zrxExchange,\r\n        address zrxTokenProxy,\r\n        uint256 takerAssetFillAmount,\r\n        IZrxExchange.Order[] calldata orders,\r\n        bytes[] calldata signatures\r\n    )\r\n        external\r\n        returns (IZrxExchange.FillResults memory totalFillResults)\r\n    {\r\n        for (uint i = 0; i < orders.length; i++) {\r\n\r\n            // Stop execution if the entire amount of takerAsset has been sold\r\n            if (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\r\n                break;\r\n            }\r\n\r\n            // Calculate the remaining amount of takerAsset to sell\r\n            uint256 remainingTakerAmount = takerAssetFillAmount.sub(totalFillResults.takerAssetFilledAmount);\r\n\r\n            IZrxExchange.OrderInfo memory orderInfo = IZrxExchange(zrxExchange).getOrderInfo(orders[i]);\r\n            uint256 orderRemainingTakerAmount = orders[i].takerAssetAmount.sub(orderInfo.orderTakerAssetFilledAmount);\r\n\r\n            // Check available balance and allowance and update orderRemainingTakerAmount\r\n            {\r\n                uint256 balance = IERC20NonView(makerAsset).balanceOf(orders[i].makerAddress);\r\n                uint256 allowance = IERC20NonView(makerAsset).allowance(orders[i].makerAddress, zrxTokenProxy);\r\n                uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\r\n                uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\r\n\r\n                if (availableTakerAmount < orderRemainingTakerAmount) {\r\n                    orderRemainingTakerAmount = availableTakerAmount;\r\n                }\r\n            }\r\n\r\n            uint256 takerAmount = (orderRemainingTakerAmount < remainingTakerAmount) ? orderRemainingTakerAmount : remainingTakerAmount;\r\n\r\n            IZrxExchange.FillResults memory fillResults = IZrxExchange(zrxExchange).fillOrderNoThrow(\r\n                orders[i],\r\n                takerAmount,\r\n                signatures[i]\r\n            );\r\n\r\n            _addFillResults(totalFillResults, fillResults);\r\n        }\r\n\r\n        return totalFillResults;\r\n    }\r\n\r\n    function _addFillResults(\r\n        IZrxExchange.FillResults memory totalFillResults,\r\n        IZrxExchange.FillResults memory singleFillResults\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        totalFillResults.makerAssetFilledAmount = totalFillResults.makerAssetFilledAmount.add(singleFillResults.makerAssetFilledAmount);\r\n        totalFillResults.takerAssetFilledAmount = totalFillResults.takerAssetFilledAmount.add(singleFillResults.takerAssetFilledAmount);\r\n        totalFillResults.makerFeePaid = totalFillResults.makerFeePaid.add(singleFillResults.makerFeePaid);\r\n        totalFillResults.takerFeePaid = totalFillResults.takerFeePaid.add(singleFillResults.takerFeePaid);\r\n    }\r\n\r\n    function getOrdersInfoRespectingBalancesAndAllowances(\r\n        IERC20 token,\r\n        IZrxExchange zrx,\r\n        address zrxTokenProxy,\r\n        IZrxExchange.Order[] memory orders\r\n    )\r\n        public\r\n        view\r\n        returns (IZrxExchange.OrderInfo[] memory ordersInfo)\r\n    {\r\n        ordersInfo = zrx.getOrdersInfo(orders);\r\n\r\n        for (uint i = 0; i < ordersInfo.length; i++) {\r\n\r\n            uint256 balance = token.balanceOf(orders[i].makerAddress);\r\n            uint256 allowance = token.allowance(orders[i].makerAddress, zrxTokenProxy);\r\n            uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\r\n            uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\r\n\r\n            for (uint j = 0; j < i; j++) {\r\n\r\n                if (orders[j].makerAddress == orders[i].makerAddress) {\r\n\r\n                    uint256 orderTakerAssetRemainigAmount = orders[j].takerAssetAmount.sub(\r\n                        ordersInfo[j].orderTakerAssetFilledAmount\r\n                    );\r\n\r\n                    if (availableTakerAmount > orderTakerAssetRemainigAmount) {\r\n\r\n                        availableTakerAmount = availableTakerAmount.sub(orderTakerAssetRemainigAmount);\r\n                    } else {\r\n\r\n                        availableTakerAmount = 0;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            uint256 remainingTakerAmount = orders[i].takerAssetAmount.sub(\r\n                ordersInfo[i].orderTakerAssetFilledAmount\r\n            );\r\n\r\n            if (availableTakerAmount < remainingTakerAmount) {\r\n\r\n                ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(availableTakerAmount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary UniversalERC20 {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 private constant ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\r\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    function universalTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        universalTransfer(token, to, amount, false);\r\n    }\r\n\r\n    function universalTransfer(IERC20 token, address to, uint256 amount, bool mayFail) internal returns(bool) {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\r\n            if (mayFail) {\r\n                return address(uint160(to)).send(amount);\r\n            } else {\r\n                address(uint160(to)).transfer(amount);\r\n                return true;\r\n            }\r\n        } else {\r\n            token.safeTransfer(to, amount);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function universalApprove(IERC20 token, address to, uint256 amount) internal {\r\n        if (token != ZERO_ADDRESS && token != ETH_ADDRESS) {\r\n            token.safeApprove(to, amount);\r\n        }\r\n    }\r\n\r\n    function universalTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\r\n            require(from == msg.sender && msg.value >= amount, \"msg.value is zero\");\r\n            if (to != address(this)) {\r\n                address(uint160(to)).transfer(amount);\r\n            }\r\n            if (msg.value > amount) {\r\n                msg.sender.transfer(msg.value.sub(amount));\r\n            }\r\n        } else {\r\n            token.safeTransferFrom(from, to, amount);\r\n        }\r\n    }\r\n\r\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\r\n        if (token == ZERO_ADDRESS || token == ETH_ADDRESS) {\r\n            return who.balance;\r\n        } else {\r\n            return token.balanceOf(who);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract TokenSpender {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public owner;\r\n    IGST2 public gasToken;\r\n    address public gasTokenOwner;\r\n\r\n    constructor(IGST2 _gasToken, address _gasTokenOwner) public {\r\n        owner = msg.sender;\r\n        gasToken = _gasToken;\r\n        gasTokenOwner = _gasTokenOwner;\r\n    }\r\n\r\n    function claimTokens(IERC20 token, address who, address dest, uint256 amount) external {\r\n        require(msg.sender == owner, \"Access restricted\");\r\n        token.safeTransferFrom(who, dest, amount);\r\n    }\r\n\r\n    function burnGasToken(uint gasSpent) external {\r\n        require(msg.sender == owner, \"Access restricted\");\r\n        uint256 tokens = (gasSpent + 14154) / 41130;\r\n        gasToken.freeUpTo(tokens);\r\n    }\r\n\r\n    function() external {\r\n        if (msg.sender == gasTokenOwner) {\r\n            gasToken.transfer(msg.sender, gasToken.balanceOf(address(this)));\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract OneInchExchange is Shutdownable, ZrxMarketOrder {\r\n\r\n    using SafeMath for uint256;\r\n    using UniversalERC20 for IERC20;\r\n    using ExternalCall for address;\r\n\r\n    IERC20 constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    TokenSpender public spender;\r\n    uint fee; // 10000 => 100%, 1 => 0.01%\r\n\r\n    event Swapped(\r\n        IERC20 indexed fromToken,\r\n        IERC20 indexed toToken,\r\n        uint256 fromAmount,\r\n        uint256 toAmount,\r\n        address indexed referrer,\r\n        uint256 referrerFee,\r\n        uint256 fee\r\n    );\r\n\r\n    constructor(address _owner, IGST2 _gasToken, uint _fee) public {\r\n        spender = new TokenSpender(\r\n            _gasToken,\r\n            _owner\r\n        );\r\n\r\n        _transferOwnership(_owner);\r\n        fee = _fee;\r\n    }\r\n\r\n    function () external payable notShutdown {\r\n        require(msg.sender != tx.origin);\r\n    }\r\n\r\n    function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        uint256 guaranteedAmount,\r\n        address payable referrer,\r\n        address[] memory callAddresses,\r\n        bytes memory callDataConcat,\r\n        uint256[] memory starts,\r\n        uint256[] memory values\r\n    )\r\n        public\r\n        payable\r\n        notShutdown\r\n        returns (uint256 returnAmount)\r\n    {\r\n        uint256 gasProvided = gasleft();\r\n\r\n        if (fromToken != ETH_ADDRESS) {\r\n            spender.claimTokens(fromToken, msg.sender, address(this), fromTokenAmount);\r\n        }\r\n\r\n        for (uint i = 0; i < callAddresses.length; i++) {\r\n            require(callAddresses[i] != address(spender), \"Access denied\");\r\n            require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\r\n        }\r\n\r\n        returnAmount = toToken.universalBalanceOf(address(this));\r\n        (uint256 toTokenAmount, uint256 referrerFee) = _handleFees(toToken, referrer, returnAmount, guaranteedAmount);\r\n\r\n        require(toTokenAmount >= minReturnAmount, \"Return amount is not enough\");\r\n        toToken.universalTransfer(msg.sender, toTokenAmount);\r\n\r\n        emit Swapped(\r\n            fromToken,\r\n            toToken,\r\n            fromTokenAmount,\r\n            toTokenAmount,\r\n            referrer,\r\n            referrerFee,\r\n            returnAmount.sub(toTokenAmount)\r\n        );\r\n\r\n        spender.burnGasToken(gasProvided.sub(gasleft()));\r\n    }\r\n\r\n    function _handleFees(\r\n        IERC20 toToken,\r\n        address referrer,\r\n        uint256 returnAmount,\r\n        uint256 guaranteedAmount\r\n    )\r\n        internal\r\n        returns(\r\n            uint256 toTokenAmount,\r\n            uint256 referrerFee\r\n        )\r\n    {\r\n        if (returnAmount <= guaranteedAmount) {\r\n            return (returnAmount, 0);\r\n        }\r\n\r\n        uint256 feeAmount = returnAmount.sub(guaranteedAmount).mul(fee).div(10000);\r\n\r\n        if (referrer != address(0) && referrer != msg.sender && referrer != tx.origin) {\r\n            referrerFee = feeAmount.div(10);\r\n            if (toToken.universalTransfer(referrer, referrerFee, true)) {\r\n                returnAmount = returnAmount.sub(referrerFee);\r\n                feeAmount = feeAmount.sub(referrerFee);\r\n            } else {\r\n                referrerFee = 0;\r\n            }\r\n        }\r\n\r\n        if (toToken.universalTransfer(owner(), feeAmount, true)) {\r\n            returnAmount = returnAmount.sub(feeAmount);\r\n        }\r\n\r\n        return (returnAmount, referrerFee);\r\n    }\r\n\r\n    function infiniteApproveIfNeeded(IERC20 token, address to) external notShutdown {\r\n        if (token != ETH_ADDRESS) {\r\n            if ((token.allowance(address(this), to) >> 255) == 0) {\r\n                token.universalApprove(to, uint256(- 1));\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawAllToken(IWETH token) external notShutdown {\r\n        uint256 amount = token.balanceOf(address(this));\r\n        token.withdraw(amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IZrxExchange\",\"name\":\"zrx\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zrxTokenProxy\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct IZrxExchange.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"getOrdersInfoRespectingBalancesAndAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"orderStatus\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"orderTakerAssetFilledAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IZrxExchange.OrderInfo[]\",\"name\":\"ordersInfo\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenSell\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenBuy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zrxExchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zrxTokenProxy\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct IZrxExchange.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"mul\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"div\",\"type\":\"uint256\"}],\"name\":\"marketSellOrdersProportion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawAllToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"infiniteApproveIfNeeded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spender\",\"outputs\":[{\"internalType\":\"contract TokenSpender\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guaranteedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"callAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"callDataConcat\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"starts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"makerAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zrxExchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zrxTokenProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetFillAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct IZrxExchange.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"marketSellOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"makerAssetFilledAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetFilledAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerFeePaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerFeePaid\",\"type\":\"uint256\"}],\"internalType\":\"struct IZrxExchange.FillResults\",\"name\":\"totalFillResults\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract IGST2\",\"name\":\"_gasToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Shutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OneInchExchange","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d37f28d2db99e8d35a6c725a5f1749a085850a30000000000000000000000000000000000b3f879cb30fe243b4dfee438691c040000000000000000000000000000000000000000000000000000000000001388","Library":"","LicenseType":"None","SwarmSource":"bzzr://8c59ccff021a83d26af80f0ae27ae65fc175b110caabc0e0c3a1c87caaac1222"}]}