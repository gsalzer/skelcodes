{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\n\n\ncontract GenerateRandomEntityInterface {\n  address public tokenAddr;\n  address public entityDataAddr;\n  uint256 public priceWei;\n  uint256 public cntDrawnByEth;\n  uint256 public capDrawByEth;\n  address payable public adminWalletAddr;\n  uint256 public idCounter;\n  uint256 public modelId;\n  uint256 public constant modelIdDigit = 1000000;\n  uint256 public constant typeIdDigit = 100000;\n  uint256 public constant gen0TypeId = 1;\n\n  event TokenAdded(address tokenAddr, uint256 priceInToken);\n\n  event Generate (\n      uint256 tokenId,\n      address owner,\n      uint256 createdAt\n  );\n\n  function setPriceWei(uint256 _priceWei) external;\n\n  function setPriceToken(address _payableTokenAddr, uint256 _priceInToken) public;\n\n  function removePayableToken(address _payableTokenAddr) external;\n\n  function setAdminWallet(address payable newWalletAddr) public;\n\n  function setCapDrawByEth(uint256 _cap) external;\n\n  function setCapDrawByToken(address _tokenAddr, uint256 _cap) external;\n\n  function setModelId(uint256 _modelId) external;\n\n  function () external payable;\n\n  function tokenFallback(address _from, uint _value, bytes memory _data) public;\n\n  function isReady() external view returns(bool);\n\n  function getPriceInToken(address _payableTokenAddr)\n      external\n      view\n      returns(bool isPayable, uint256 price);\n\n  function isEthAvailable() public view returns (bool);\n\n  function isTokenAvailable(address _tokenAddr) public view returns (bool);\n\n  function getCapDrawByToken(address _tokenAddr) external view returns (uint256);\n\n  function getCntDrawnByToken(address _tokenAddr) external view returns (uint256);\n\n  function calculateTokenId(uint256 _modelId, uint256 _typeId, uint256 _idCount)\n      public\n      pure\n      returns(uint256 tokenId);\n}\n\ncontract EntityDataInterface {\n\n    address public tokenAddr;\n\n    mapping(uint256 => Entity) public entityData;\n    mapping(uint256 => address) public siringApprovedTo;\n\n    event UpdateRootHash (\n        uint256 tokenId,\n        bytes rootHash\n    );\n\n    event Birth (\n        uint256 tokenId,\n        address owner,\n        uint256 matronId,\n        uint256 sireId\n    );\n\n    struct Entity {\n        bytes rootHash;\n        uint256 birthTime;\n        uint256 cooldownEndTime;\n        uint256 matronId;\n        uint256 sireId;\n        uint256 generation;\n    }\n\n    function updateRootHash(uint256 tokenId, bytes calldata rootHash) external;\n\n    function createEntity(address owner, uint256 tokenId, uint256 _generation, uint256 _matronId, uint256 _sireId, uint256 _birthTime) public;\n\n    function getEntity(uint256 tokenId)\n      external\n      view\n      returns(\n            uint256 birthTime,\n            uint256 cooldownEndTime,\n            uint256 matronId,\n            uint256 sireId,\n            uint256 generation\n        );\n\n    function setCooldownEndTime(uint256 tokenId, uint256 _cooldownEndTime) external;\n\n    function approveSiring(uint256 sireId, address approveTo) external;\n\n    function clearSiringApproval(uint256 sireId) external;\n\n    function isSiringApprovedTo(uint256 tokenId, address borrower)\n        external\n        view\n        returns(bool);\n\n    function isReadyForFusion(uint256 tokenId)\n        external\n        view\n        returns (bool ready);\n}\n\ncontract RoleManager {\n\n    mapping(address => bool) private admins;\n    mapping(address => bool) private controllers;\n\n    modifier onlyAdmins {\n        require(admins[msg.sender], 'only admins');\n        _;\n    }\n\n    modifier onlyControllers {\n        require(controllers[msg.sender], 'only controllers');\n        _;\n    } \n\n    constructor() public {\n        admins[msg.sender] = true;\n        controllers[msg.sender] = true;\n    }\n\n    function addController(address _newController) external onlyAdmins{\n        controllers[_newController] = true;\n    } \n\n    function addAdmin(address _newAdmin) external onlyAdmins{\n        admins[_newAdmin] = true;\n    } \n\n    function removeController(address _controller) external onlyAdmins{\n        controllers[_controller] = false;\n    } \n    \n    function removeAdmin(address _admin) external onlyAdmins{\n        require(_admin != msg.sender, 'unexecutable operation'); \n        admins[_admin] = false;\n    } \n\n    function isAdmin(address addr) external view returns (bool) {\n        return (admins[addr]);\n    }\n\n    function isController(address addr) external view returns (bool) {\n        return (controllers[addr]);\n    }\n\n}\n\ncontract AccessController {\n\n    address roleManagerAddr;\n\n    modifier onlyAdmins {\n        require(RoleManager(roleManagerAddr).isAdmin(msg.sender), 'only admins');\n        _;\n    }\n\n    modifier onlyControllers {\n        require(RoleManager(roleManagerAddr).isController(msg.sender), 'only controllers');\n        _;\n    }\n\n    constructor (address _roleManagerAddr) public {\n        require(_roleManagerAddr != address(0), '_roleManagerAddr: Invalid address (zero address)');\n        roleManagerAddr = _roleManagerAddr;\n    }\n\n}\n\ninterface ERC165Interface {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract ERC721Interface is ERC165Interface {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\ncontract ERC721MetadataInterface is ERC721Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721EnumerableInterface is ERC721Interface {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\ncontract ERC165 is ERC165Interface {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    \n\n    \n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    \n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    \n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ERC721ReceiverInterface {\n    \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\nlibrary SafeMath {\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ncontract ERC721Extended is ERC721Interface, ERC721MetadataInterface, ERC721EnumerableInterface, ERC165, Ownable {\n    using SafeMath for uint256;\n\n    \n    mapping(uint256 => address) private _tokenOwner;\n\n    \n    mapping(uint256 => address) private _tokenApprovals;\n\n    \n    mapping(address => uint256) private _ownedTokensCount;\n\n    \n    mapping(address => mapping (address => bool)) private _operatorApprovals;\n\n    \n    string private _name;\n\n    \n    string private _symbol;\n\n    \n    mapping(uint256 => string) private _tokenURIs;\n\n    \n    mapping(address => uint256[]) private _ownedTokens;\n\n    \n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \n    uint256[] private _allTokens;\n\n    \n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    \n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    \n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    \n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    \n    constructor(string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _current(owner);\n    }\n\n    \n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    \n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    \n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    \n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    \n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    \n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    \n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId));\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _increment(to);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n        _addTokenToAllTokensEnumeration(tokenId);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _decrement(owner);\n        _tokenOwner[tokenId] = address(0);\n\n        \n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        \n        _ownedTokensIndex[tokenId] = 0;\n        _removeTokenFromAllTokensEnumeration(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    \n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _decrement(from);\n        _increment(to);\n\n        _tokenOwner[tokenId] = to;\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!_isContract(to)) {\n            return true;\n        }\n\n        bytes4 retval = ERC721ReceiverInterface(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    \n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId));\n        return _tokenURIs[tokenId];\n    }\n\n    \n    function setTokenURI(uint256 tokenId, string calldata uri) external onlyOwner {\n        _setTokenURI(tokenId, uri);\n    }\n\n    \n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId));\n        _tokenURIs[tokenId] = uri;\n    }\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    \n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    \n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    \n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    \n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \n        \n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \n            _ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n\n        \n        _ownedTokens[from].length--;\n\n        \n        \n    }\n\n    \n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \n        \n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \n        \n        \n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \n        _allTokensIndex[lastTokenId] = tokenIndex; \n\n        \n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n\n    \n    function _isContract(address account) private view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    \n    function _current(address tokenAddress) private view returns (uint256) {\n        return _ownedTokensCount[tokenAddress];\n    }\n\n    \n    function _increment(address tokenAddress) private {\n        _ownedTokensCount[tokenAddress] = _ownedTokensCount[tokenAddress].add(1);\n    }\n\n    \n    function _decrement(address tokenAddress) private {\n        _ownedTokensCount[tokenAddress] = _ownedTokensCount[tokenAddress].sub(1);\n    }\n\n    \n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n  }\n\ncontract GeneAidolsToken is ERC721Extended, AccessController {\n    constructor(address _roleManagerAddr)\n        public\n        ERC721Extended(\"GeneA.I.dols\", \"GAI\")\n        AccessController(_roleManagerAddr)\n    {\n    }\n\n    function generateToken(uint256 tokenId, address to) external onlyControllers {\n        _mint(to, tokenId);\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata uri) external onlyAdmins {\n        _setTokenURI(tokenId, uri);\n    }\n\n    function tokenExists(uint256 tokenId) external view returns (bool exists) {\n        return _exists(tokenId);\n    }\n}\n\ncontract ERC223ReceivingContract {\n\n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\n}\n\ninterface ERC20Interface {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract GenerateRandomEntityBase is GenerateRandomEntityInterface, AccessController, ERC223ReceivingContract{\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private priceInToken;\n    mapping(address => uint256) private cntDrawnByToken;\n    mapping(address => uint256) private capDrawByToken;\n    mapping(address => bool) private payableTokenAddr;\n    uint256 public idCounter;\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    modifier onlyWhenReady {\n        require(this.isReady(), 'Not ready');\n        _;\n    }\n\n    constructor(\n        address _entityDataAddr,\n        address _roleManagerAddr,\n        uint256 _modelId\n    )\n        public\n        AccessController(_roleManagerAddr)\n    {\n        require(_entityDataAddr != address(0));\n        entityDataAddr = _entityDataAddr;\n        tokenAddr = EntityDataInterface(entityDataAddr).tokenAddr();\n        require(ERC721Interface(tokenAddr).supportsInterface(_INTERFACE_ID_ERC721), 'Given address doesn`t suuport ERC721');\n\n        \n        setPriceToken(0x8232875761b97A5242A4CfFB94828Dff5c101950, 5 * 10**9);\n\n        setAdminWallet(msg.sender);\n\n        priceWei = 100 finney;\n        cntDrawnByEth = 0;\n        capDrawByEth = 10**9;\n\n        modelId = _modelId;\n    }\n\n    function setPriceWei(uint256 _priceWei) external onlyAdmins {\n        priceWei = _priceWei;\n    }\n\n    function setPriceToken(address _payableTokenAddr, uint256 _priceInToken) public onlyAdmins {\n        require(_priceInToken > 0);\n        payableTokenAddr[_payableTokenAddr] = true;\n        priceInToken[_payableTokenAddr] = _priceInToken;\n\n        emit TokenAdded(_payableTokenAddr, _priceInToken);\n    }\n\n    function removePayableToken(address _payableTokenAddr) external onlyAdmins {\n        payableTokenAddr[_payableTokenAddr] = false;\n        delete priceInToken[_payableTokenAddr];\n    }\n\n    function setAdminWallet(address payable newWalletAddr) public onlyAdmins {\n        require(newWalletAddr != address(0), 'newWalletAddr: Invalid address (zero address)');\n        adminWalletAddr = newWalletAddr;\n    }\n\n    function setCapDrawByEth(uint256 _cap) external onlyAdmins {\n        capDrawByEth = _cap;\n    }\n\n    function setCapDrawByToken(address _tokenAddr, uint256 _cap) external onlyAdmins {\n        capDrawByToken[_tokenAddr] = _cap;\n    }\n\n    function setModelId(uint256 _modelId) external onlyAdmins {\n        modelId = _modelId;\n    }\n\n    function () external payable onlyWhenReady {\n        uint256 weiReceipt = msg.value;\n        require(weiReceipt >= priceWei, 'Insufficient amount of ether');\n\n        uint256 numTake = weiReceipt.div(priceWei);\n\n        \n        cntDrawnByEth = cntDrawnByEth.add(numTake);\n        require(isEthAvailable(), 'Reached cap');\n\n        for(uint256 i=0; i < numTake; i++){\n            _generateNewEntity(msg.sender);\n        }\n\n        \n        require(msg.sender.send(weiReceipt.sub(numTake.mul(priceWei))));\n\n        \n        adminWalletAddr.transfer(priceWei.mul(numTake));\n    }\n\n    function tokenFallback(address _from, uint _value, bytes memory _data) public onlyWhenReady {\n        require(payableTokenAddr[msg.sender], 'not registered');\n        uint256 price = priceInToken[msg.sender];\n        require(_value >= price, 'invalid price');\n\n        uint256 numTake = _value.div(price);\n\n        \n        cntDrawnByToken[msg.sender] = cntDrawnByToken[msg.sender].add(numTake);\n        require(isTokenAvailable(msg.sender), 'not available');\n\n\n        \n        ERC20Interface(msg.sender).transfer(_from, _value.sub(numTake.mul(price)));\n\n        \n        ERC20Interface(msg.sender).transfer(adminWalletAddr, ERC20Interface(msg.sender).balanceOf(address(this)));\n\n        for(uint256 i=0; i < numTake; i++){\n            _generateNewEntity(_from);\n        }\n    }\n\n    function _generateNewEntity(address owner) internal {\n        uint256 tokenId = calculateTokenId(modelId, gen0TypeId, idCounter);\n        EntityDataInterface(entityDataAddr).createEntity(owner, tokenId, 0, 0, 0, block.timestamp);\n        idCounter++;\n    }\n\n    function calculateTokenId(uint256 _modelId, uint256 _typeId, uint256 _idCount)\n        public\n        pure\n        returns(uint256 tokenId)\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        return _modelId.mul(modelIdDigit).add(_typeId.mul(typeIdDigit).add(_idCount));\n    }\n\n    function isReady() external view returns(bool) {\n        if(!RoleManager(roleManagerAddr).isController(address(this))){\n            return false;\n        }\n\n        return true;\n    }\n\n    function getPriceInToken(address _payableTokenAddr)\n        external\n        view\n        returns(bool isPayable, uint256 price)\n    {\n        if(!payableTokenAddr[_payableTokenAddr])\n        {\n            return (false, 0);\n        }else{\n            return (true, priceInToken[_payableTokenAddr]);\n        }\n    }\n\n    function isEthAvailable() public view returns (bool) {\n        if( cntDrawnByEth >= capDrawByEth ){\n            return false;\n        }\n\n        return true;\n    }\n\n    function isTokenAvailable(address _tokenAddr) public view returns (bool) {\n        if( cntDrawnByToken[_tokenAddr] >= capDrawByToken[_tokenAddr] ){\n            return false;\n        }\n        return true;\n    }\n\n    function getCapDrawByToken(address _tokenAddr) external view returns (uint256) {\n        return capDrawByToken[_tokenAddr];\n    }\n\n    function getCntDrawnByToken(address _tokenAddr) external view returns (uint256) {\n        return cntDrawnByToken[_tokenAddr];\n    }\n}\n\ncontract GenerateRandomEntityModel101 is GenerateRandomEntityBase {\n    using SafeMath for uint256;\n\n    constructor(\n        address _tokenAddr,\n        address _roleManagerAddr\n      )\n        public\n        GenerateRandomEntityBase(_tokenAddr, _roleManagerAddr, 101)\n      {\n      }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"modelIdDigit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"isTokenAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminWalletAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capDrawByEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWalletAddr\",\"type\":\"address\"}],\"name\":\"setAdminWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_modelId\",\"type\":\"uint256\"},{\"name\":\"_typeId\",\"type\":\"uint256\"},{\"name\":\"_idCount\",\"type\":\"uint256\"}],\"name\":\"calculateTokenId\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gen0TypeId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"modelId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cntDrawnByEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_modelId\",\"type\":\"uint256\"}],\"name\":\"setModelId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getCntDrawnByToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payableTokenAddr\",\"type\":\"address\"}],\"name\":\"getPriceInToken\",\"outputs\":[{\"name\":\"isPayable\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payableTokenAddr\",\"type\":\"address\"}],\"name\":\"removePayableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payableTokenAddr\",\"type\":\"address\"},{\"name\":\"_priceInToken\",\"type\":\"uint256\"}],\"name\":\"setPriceToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setCapDrawByToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getCapDrawByToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isReady\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceWei\",\"type\":\"uint256\"}],\"name\":\"setPriceWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"typeIdDigit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entityDataAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEthAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setCapDrawByEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_roleManagerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceInToken\",\"type\":\"uint256\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"createdAt\",\"type\":\"uint256\"}],\"name\":\"Generate\",\"type\":\"event\"}]","ContractName":"GenerateRandomEntityModel101","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000016659c6931ec572d6b89781f2e5a5b8562ecb416000000000000000000000000d9e1ec33d63d6d73ec9418254261d0cb341eb646","Library":"","LicenseType":"","SwarmSource":"bzzr://e96afad05bec89b33e750fad886facdd155c33451071752cecdd0d5cc3b64328"}]}