{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\n\n\ncontract Resolvable {\n    \n    function resolveIfCriteriaMet()\n    public;\n\n    \n    \n    function resolutionCriteriaMet()\n    public\n    view\n    returns (bool);\n\n    \n    \n    \n    function resolutionDeltaAmount(bool _status)\n    public\n    view\n    returns (uint256);\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract RBACed {\n    using Roles for Roles.Role;\n\n    event RoleAdded(string _role);\n    event RoleAccessorAdded(string _role, address indexed _address);\n    event RoleAccessorRemoved(string _role, address indexed _address);\n\n    string constant public OWNER_ROLE = \"OWNER\";\n\n    string[] public roles;\n    mapping(bytes32 => uint256) roleIndexByName;\n    mapping(bytes32 => Roles.Role) private roleByName;\n\n    \n    constructor()\n    public\n    {\n        \n        _addRole(OWNER_ROLE);\n\n        \n        _addRoleAccessor(OWNER_ROLE, msg.sender);\n    }\n\n    modifier onlyRoleAccessor(string memory _role) {\n        require(isRoleAccessor(_role, msg.sender), \"RBACed: sender is not accessor of the role\");\n        _;\n    }\n\n    \n    \n    function rolesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return roles.length;\n    }\n\n    \n    \n    \n    function isRole(string memory _role)\n    public\n    view\n    returns (bool)\n    {\n        return 0 != roleIndexByName[_role2Key(_role)];\n    }\n\n    \n    \n    function addRole(string memory _role)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        _addRole(_role);\n\n        \n        emit RoleAdded(_role);\n    }\n\n    \n    \n    \n    \n    function isRoleAccessor(string memory _role, address _address)\n    public\n    view\n    returns (bool)\n    {\n        return roleByName[_role2Key(_role)].has(_address);\n    }\n\n    \n    \n    \n    function addRoleAccessor(string memory _role, address _address)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        _addRoleAccessor(_role, _address);\n\n        \n        emit RoleAccessorAdded(_role, _address);\n    }\n\n    \n    \n    \n    function removeRoleAccessor(string memory _role, address _address)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        roleByName[_role2Key(_role)].remove(_address);\n\n        \n        emit RoleAccessorRemoved(_role, _address);\n    }\n\n    function _addRole(string memory _role)\n    internal\n    {\n        if (0 == roleIndexByName[_role2Key(_role)]) {\n            roles.push(_role);\n            roleIndexByName[_role2Key(_role)] = roles.length;\n        }\n    }\n\n    function _addRoleAccessor(string memory _role, address _address)\n    internal\n    {\n        roleByName[_role2Key(_role)].add(_address);\n    }\n\n    function _role2Key(string memory _role)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_role));\n    }\n}\n\ncontract Able {\n    event Disabled(string _name);\n    event Enabled(string _name);\n\n    mapping(string => bool) private _disabled;\n\n    \n    \n    function enable(string memory _name)\n    public\n    {\n        \n        require(_disabled[_name], \"Able: name is enabled\");\n\n        \n        _disabled[_name] = false;\n\n        \n        emit Enabled(_name);\n    }\n\n    \n    \n    function disable(string memory _name)\n    public\n    {\n        \n        require(!_disabled[_name], \"Able: name is disabled\");\n\n        \n        _disabled[_name] = true;\n\n        \n        emit Disabled(_name);\n    }\n\n    \n    \n    function enabled(string memory _name)\n    public\n    view\n    returns (bool)\n    {\n        return !_disabled[_name];\n    }\n\n    \n    \n    function disabled(string memory _name)\n    public\n    view\n    returns (bool)\n    {\n        return _disabled[_name];\n    }\n\n    modifier onlyEnabled(string memory _name) {\n        require(enabled(_name), \"Able: name is disabled\");\n        _;\n    }\n\n    modifier onlyDisabled(string memory _name) {\n        require(disabled(_name), \"Able: name is enabled\");\n        _;\n    }\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\nlibrary VerificationPhaseLib {\n    using SafeMath for uint256;\n\n    enum State {Unopened, Opened, Closed}\n    enum Status {Null, True, False}\n\n    struct VerificationPhase {\n        State state;\n        Status result;\n\n        uint256 stakedAmount;\n        mapping(bool => uint256) stakedAmountByStatus;\n        mapping(address => mapping(bool => uint256)) stakedAmountByWalletStatus;\n        mapping(uint256 => mapping(bool => uint256)) stakedAmountByBlockStatus;\n\n        mapping(address => bool) stakedByWallet;\n        uint256 stakingWallets;\n\n        uint256 bountyAmount;\n        bool bountyAwarded;\n\n        uint256 startBlock;\n        uint256 endBlock;\n\n        uint256[] uintCriteria;\n    }\n\n    function open(VerificationPhase storage _phase, uint256 _bountyAmount) internal {\n        _phase.state = State.Opened;\n        _phase.bountyAmount = _bountyAmount;\n        _phase.startBlock = block.number;\n    }\n\n    function close(VerificationPhase storage _phase) internal {\n        _phase.state = State.Closed;\n        _phase.endBlock = block.number;\n        if (_phase.stakedAmountByStatus[true] > _phase.stakedAmountByStatus[false])\n            _phase.result = Status.True;\n        else if (_phase.stakedAmountByStatus[true] < _phase.stakedAmountByStatus[false])\n            _phase.result = Status.False;\n    }\n\n    function stake(VerificationPhase storage _phase, address _wallet,\n        bool _status, uint256 _amount) internal {\n        _phase.stakedAmount = _phase.stakedAmount.add(_amount);\n        _phase.stakedAmountByStatus[_status] = _phase.stakedAmountByStatus[_status].add(_amount);\n        _phase.stakedAmountByWalletStatus[_wallet][_status] =\n        _phase.stakedAmountByWalletStatus[_wallet][_status].add(_amount);\n        _phase.stakedAmountByBlockStatus[block.number][_status] =\n        _phase.stakedAmountByBlockStatus[block.number][_status].add(_amount);\n\n        if (!_phase.stakedByWallet[_wallet]) {\n            _phase.stakedByWallet[_wallet] = true;\n            _phase.stakingWallets = _phase.stakingWallets.add(1);\n        }\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\ninterface Allocator {\n    \n    function allocate()\n    external\n    view\n    returns (uint256);\n}\n\ncontract BountyFund is RBACed {\n    using SafeMath for uint256;\n\n    event ResolutionEngineSet(address indexed _resolutionEngine);\n    event TokensDeposited(address indexed _wallet, uint256 _amount, uint256 _balance);\n    event TokensAllocated(address indexed _wallet, address indexed _allocator,\n        uint256 _amount, uint256 _balance);\n    event Withdrawn(address indexed _wallet, uint256 _amount);\n\n    ERC20 public token;\n\n    address public operator;\n    address public resolutionEngine;\n\n    \n    constructor(address _token, address _operator)\n    public\n    {\n        \n        token = ERC20(_token);\n\n        \n        operator = _operator;\n    }\n\n    modifier onlyResolutionEngine() {\n        require(msg.sender == resolutionEngine, \"BountyFund: sender is not the defined resolution engine\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"BountyFund: sender is not the defined operator\");\n        _;\n    }\n\n    \n    \n    \n    function setResolutionEngine(address _resolutionEngine)\n    public\n    {\n        require(address(0) != _resolutionEngine, \"BountyFund: resolution engine argument is zero address\");\n        require(address(0) == resolutionEngine, \"BountyFund: resolution engine has already been set\");\n\n        \n        resolutionEngine = _resolutionEngine;\n\n        \n        emit ResolutionEngineSet(_resolutionEngine);\n    }\n\n    \n    \n    \n    function depositTokens(uint256 _amount)\n    public\n    {\n        \n        token.transferFrom(msg.sender, address(this), _amount);\n\n        \n        emit TokensDeposited(msg.sender, _amount, token.balanceOf(address(this)));\n    }\n\n    \n    \n    function allocateTokens(address _allocator)\n    public\n    onlyResolutionEngine\n    returns (uint256)\n    {\n        \n        uint256 amount = Allocator(_allocator).allocate();\n\n        \n        token.transfer(msg.sender, amount);\n\n        \n        emit TokensAllocated(msg.sender, _allocator, amount, token.balanceOf(address(this)));\n\n        \n        return amount;\n    }\n\n    \n    \n    function withdraw(address _wallet)\n    public\n    onlyOperator\n    {\n        \n        uint256 amount = token.balanceOf(address(this));\n\n        \n        token.transfer(_wallet, amount);\n\n        \n        emit Withdrawn(_wallet, amount);\n    }\n}\n\ncontract ResolutionEngine is Resolvable, RBACed, Able {\n    using SafeMath for uint256;\n    using VerificationPhaseLib for VerificationPhaseLib.VerificationPhase;\n\n    event Frozen();\n    event BountyAllocatorSet(address indexed _bountyAllocator);\n    event Staked(address indexed _wallet, uint256 indexed _verificationPhaseNumber, bool _status,\n        uint256 _amount);\n    event BountyWithdrawn(address indexed _wallet, uint256 _bountyAmount);\n    event VerificationPhaseOpened(uint256 indexed _verificationPhaseNumber, uint256 _bountyAmount);\n    event VerificationPhaseClosed(uint256 indexed _verificationPhaseNumber);\n    event PayoutStaged(address indexed _wallet, uint256 indexed _firstVerificationPhaseNumber,\n        uint256 indexed _lastVerificationPhaseNumber, uint256 _payout);\n    event StakeStaged(address indexed _wallet, uint _amount);\n    event Staged(address indexed _wallet, uint _amount);\n    event Withdrawn(address indexed _wallet, uint _amount);\n\n    string constant public STAKE_ACTION = \"STAKE\";\n    string constant public RESOLVE_ACTION = \"RESOLVE\";\n\n    address public oracle;\n    address public operator;\n    address public bountyAllocator;\n\n    BountyFund public bountyFund;\n\n    ERC20 public token;\n\n    bool public frozen;\n\n    uint256 public verificationPhaseNumber;\n\n    mapping(uint256 => VerificationPhaseLib.VerificationPhase) public verificationPhaseByPhaseNumber;\n\n    mapping(address => mapping(bool => uint256)) public stakedAmountByWalletStatus;\n    mapping(uint256 => mapping(bool => uint256)) public stakedAmountByBlockStatus;\n\n    VerificationPhaseLib.Status public verificationStatus;\n\n    mapping(address => mapping(uint256 => bool)) public payoutStagedByWalletPhase;\n    mapping(address => uint256) public stagedAmountByWallet;\n\n    \n    constructor(address _oracle, address _operator, address _bountyFund)\n    public\n    {\n        \n        oracle = _oracle;\n        operator = _operator;\n\n        \n        bountyFund = BountyFund(_bountyFund);\n        bountyFund.setResolutionEngine(address(this));\n\n        \n        token = ERC20(bountyFund.token());\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle, \"ResolutionEngine: sender is not the defined oracle\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"ResolutionEngine: sender is not the defined operator\");\n        _;\n    }\n\n    modifier onlyNotFrozen() {\n        require(!frozen, \"ResolutionEngine: is frozen\");\n        _;\n    }\n\n    \n    \n    function freeze()\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        frozen = true;\n\n        \n        emit Frozen();\n    }\n\n    \n    \n    function setBountyAllocator(address _bountyAllocator)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        bountyAllocator = _bountyAllocator;\n\n        \n        emit BountyAllocatorSet(bountyAllocator);\n    }\n\n    \n    function initialize()\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    {\n        \n        require(0 == verificationPhaseNumber, \"ResolutionEngine: already initialized\");\n\n        \n        _openVerificationPhase();\n    }\n\n    \n    \n    function disable(string memory _action)\n    public\n    onlyOperator\n    {\n        \n        super.disable(_action);\n    }\n\n    \n    \n    function enable(string memory _action)\n    public\n    onlyOperator\n    {\n        \n        super.enable(_action);\n    }\n\n    \n    \n    \n    \n    \n    function stake(address _wallet, bool _status, uint256 _amount)\n    public\n    onlyOracle\n    onlyEnabled(STAKE_ACTION)\n    {\n        \n        stakedAmountByWalletStatus[_wallet][_status] = stakedAmountByWalletStatus[_wallet][_status].add(_amount);\n        stakedAmountByBlockStatus[block.number][_status] = stakedAmountByBlockStatus[block.number][_status]\n        .add(_amount);\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].stake(_wallet, _status, _amount);\n\n        \n        emit Staked(_wallet, verificationPhaseNumber, _status, _amount);\n    }\n\n    \n    \n    \n    function resolveIfCriteriaMet()\n    public\n    onlyOracle\n    onlyEnabled(RESOLVE_ACTION)\n    {\n        \n        if (resolutionCriteriaMet()) {\n            \n            _closeVerificationPhase();\n\n            \n            _openVerificationPhase();\n        }\n    }\n\n    \n    \n    \n    function metricsByVerificationPhaseNumber(uint256 _verificationPhaseNumber)\n    public\n    view\n    returns (VerificationPhaseLib.State state, uint256 trueStakeAmount, uint256 falseStakeAmount,\n        uint256 stakeAmount, uint256 numberOfWallets, uint256 bountyAmount, bool bountyAwarded,\n        uint256 startBlock, uint256 endBlock, uint256 numberOfBlocks)\n    {\n        state = verificationPhaseByPhaseNumber[_verificationPhaseNumber].state;\n        trueStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmountByStatus[true];\n        falseStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmountByStatus[false];\n        stakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmount;\n        numberOfWallets = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakingWallets;\n        bountyAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAmount;\n        bountyAwarded = verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAwarded;\n        startBlock = verificationPhaseByPhaseNumber[_verificationPhaseNumber].startBlock;\n        endBlock = verificationPhaseByPhaseNumber[_verificationPhaseNumber].endBlock;\n        numberOfBlocks = (startBlock > 0 && endBlock == 0 ? block.number : endBlock).sub(startBlock);\n    }\n\n    \n    \n    \n    \n    \n    function metricsByVerificationPhaseNumberAndWallet(uint256 _verificationPhaseNumber, address _wallet)\n    public\n    view\n    returns (uint256 trueStakeAmount, uint256 falseStakeAmount, uint256 stakeAmount)\n    {\n        trueStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][true];\n        falseStakeAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][false];\n        stakeAmount = trueStakeAmount.add(falseStakeAmount);\n    }\n\n    \n    \n    \n    function metricsByWallet(address _wallet)\n    public\n    view\n    returns (uint256 trueStakeAmount, uint256 falseStakeAmount, uint256 stakeAmount)\n    {\n        trueStakeAmount = stakedAmountByWalletStatus[_wallet][true];\n        falseStakeAmount = stakedAmountByWalletStatus[_wallet][false];\n        stakeAmount = trueStakeAmount.add(falseStakeAmount);\n    }\n\n    \n    \n    \n    \n    function metricsByBlockNumber(uint256 _blockNumber)\n    public\n    view\n    returns (uint256 trueStakeAmount, uint256 falseStakeAmount, uint256 stakeAmount)\n    {\n        trueStakeAmount = stakedAmountByBlockStatus[_blockNumber][true];\n        falseStakeAmount = stakedAmountByBlockStatus[_blockNumber][false];\n        stakeAmount = trueStakeAmount.add(falseStakeAmount);\n    }\n\n    \n    \n    \n    \n    \n    function calculatePayout(address _wallet, uint256 _firstVerificationPhaseNumber,\n        uint256 _lastVerificationPhaseNumber)\n    public\n    view\n    returns (uint256)\n    {\n        \n        uint256 payout = 0;\n        for (uint256 i = _firstVerificationPhaseNumber; i <= _lastVerificationPhaseNumber; i++)\n            payout = payout.add(_calculatePayout(_wallet, i));\n\n        \n        return payout;\n    }\n\n    \n    \n    \n    \n    \n    function stagePayout(address _wallet, uint256 _firstVerificationPhaseNumber,\n        uint256 _lastVerificationPhaseNumber)\n    public\n    onlyOracle\n    {\n        \n        uint256 amount = 0;\n        for (uint256 i = _firstVerificationPhaseNumber; i <= _lastVerificationPhaseNumber; i++)\n            amount = amount.add(_stagePayout(_wallet, i));\n\n        \n        emit PayoutStaged(_wallet, _firstVerificationPhaseNumber, _lastVerificationPhaseNumber, amount);\n    }\n\n    \n    \n    \n    function stageStake(address _wallet)\n    public\n    onlyOracle\n    onlyDisabled(RESOLVE_ACTION)\n    {\n        \n        uint256 amount = verificationPhaseByPhaseNumber[verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][true].add(\n            verificationPhaseByPhaseNumber[verificationPhaseNumber]\n            .stakedAmountByWalletStatus[_wallet][false]\n        );\n\n        \n        require(0 < amount, \"ResolutionEngine: stake is zero\");\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByWalletStatus[_wallet][true] = 0;\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByWalletStatus[_wallet][false] = 0;\n\n        \n        _stage(_wallet, amount);\n\n        \n        emit StakeStaged(_wallet, amount);\n    }\n\n    \n    \n    \n    \n    function stage(address _wallet, uint256 _amount)\n    public\n    onlyOracle\n    {\n        \n        _stage(_wallet, _amount);\n\n        \n        emit Staged(_wallet, _amount);\n    }\n\n    \n    \n    \n    \n    function withdraw(address _wallet, uint256 _amount)\n    public\n    onlyOracle\n    {\n        \n        require(_amount <= stagedAmountByWallet[_wallet], \"ResolutionEngine: amount is greater than staged amount\");\n\n        \n        stagedAmountByWallet[_wallet] = stagedAmountByWallet[_wallet].sub(_amount);\n\n        \n        token.transfer(_wallet, _amount);\n\n        \n        emit Withdrawn(_wallet, _amount);\n    }\n\n    \n    \n    function withdrawBounty(address _wallet)\n    public\n    onlyOperator\n    onlyDisabled(RESOLVE_ACTION)\n    {\n        \n        require(0 < verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount,\n            \"ResolutionEngine: bounty is zero\");\n\n        \n        uint256 amount = verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount;\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount = 0;\n\n        \n        token.transfer(_wallet, amount);\n\n        \n        emit BountyWithdrawn(_wallet, amount);\n    }\n\n    \n    function _openVerificationPhase()\n    internal\n    {\n        \n        require(\n            verificationPhaseByPhaseNumber[verificationPhaseNumber.add(1)].state == VerificationPhaseLib.State.Unopened,\n            \"ResolutionEngine: verification phase is not in unopened state\"\n        );\n\n        \n        verificationPhaseNumber = verificationPhaseNumber.add(1);\n\n        \n        uint256 bountyAmount = bountyFund.allocateTokens(bountyAllocator);\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].open(bountyAmount);\n\n        \n        _addVerificationCriteria();\n\n        \n        emit VerificationPhaseOpened(verificationPhaseNumber, bountyAmount);\n    }\n\n    \n    function _addVerificationCriteria() internal;\n\n    \n    function _closeVerificationPhase()\n    internal\n    {\n        \n        require(verificationPhaseByPhaseNumber[verificationPhaseNumber].state == VerificationPhaseLib.State.Opened,\n            \"ResolutionEngine: verification phase is not in opened state\");\n\n        \n        verificationPhaseByPhaseNumber[verificationPhaseNumber].close();\n\n        \n        if (verificationPhaseByPhaseNumber[verificationPhaseNumber].result != verificationStatus) {\n            \n            verificationStatus = verificationPhaseByPhaseNumber[verificationPhaseNumber].result;\n\n            \n            verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAwarded = true;\n        }\n\n        \n        emit VerificationPhaseClosed(verificationPhaseNumber);\n    }\n\n    \n    function _calculatePayout(address _wallet, uint256 _verificationPhaseNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        \n        if (VerificationPhaseLib.Status.Null == verificationPhaseByPhaseNumber[_verificationPhaseNumber].result)\n            return 0;\n\n        \n        bool status =\n        verificationPhaseByPhaseNumber[_verificationPhaseNumber].result == VerificationPhaseLib.Status.True;\n\n        \n        uint256 lot = verificationPhaseByPhaseNumber[_verificationPhaseNumber].stakedAmountByStatus[!status];\n\n        \n        if (verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAwarded)\n            lot = lot.add(verificationPhaseByPhaseNumber[_verificationPhaseNumber].bountyAmount);\n\n        \n        uint256 walletStatusAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByWalletStatus[_wallet][status];\n        uint256 statusAmount = verificationPhaseByPhaseNumber[_verificationPhaseNumber]\n        .stakedAmountByStatus[status];\n\n        \n        \n        return lot.mul(walletStatusAmount).div(statusAmount).add(walletStatusAmount);\n    }\n\n    \n    function _stagePayout(address _wallet, uint256 _verificationPhaseNumber)\n    internal\n    returns (uint256)\n    {\n        \n        if (VerificationPhaseLib.State.Closed != verificationPhaseByPhaseNumber[_verificationPhaseNumber].state)\n            return 0;\n\n        \n        if (payoutStagedByWalletPhase[_wallet][_verificationPhaseNumber])\n            return 0;\n\n        \n        payoutStagedByWalletPhase[_wallet][_verificationPhaseNumber] = true;\n\n        \n        uint256 payout = _calculatePayout(_wallet, _verificationPhaseNumber);\n\n        \n        _stage(_wallet, payout);\n\n        \n        return payout;\n    }\n\n    \n    function _stage(address _wallet, uint256 _amount)\n    internal\n    {\n        stagedAmountByWallet[_wallet] = stagedAmountByWallet[_wallet].add(_amount);\n    }\n}\n\nlibrary ConstantsLib {\n    \n    function PARTS_PER()\n    public\n    pure\n    returns (uint256)\n    {\n        return 1e18;\n    }\n}\n\nlibrary Math {\n    \n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    \n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\ncontract BergenResolutionEngine is Resolvable, ResolutionEngine {\n\n    event NextAlphaSet(uint256 alpha);\n    event NextBetaSet(uint256 beta);\n    event NextGammaSet(uint256 gamma);\n\n    uint256 constant private ALPHA_INDEX = 0;\n    uint256 constant private BETA_INDEX = 1;\n    uint256 constant private GAMMA_INDEX = 2;\n\n    uint256 public nextAlpha;\n    uint256 public nextBeta;\n    uint256 public nextGamma;\n\n    \n    \n    \n    \n    \n    \n    \n    constructor(address _oracle, address _operator, address _bountyFund,\n        uint256 _nextAlpha, uint256 _nextBeta, uint256 _nextGamma)\n    public\n    ResolutionEngine(_oracle, _operator, _bountyFund)\n    {\n        nextAlpha = _nextAlpha;\n        nextBeta = _nextBeta;\n        nextGamma = _nextGamma;\n    }\n\n    \n    \n    \n    function resolutionDeltaAmount(bool _status)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 alphaAmount = alphaResolutionDeltaAmount();\n        uint256 betaAmount = betaResolutionDeltaAmount(_status);\n        return Math.max(alphaAmount, betaAmount);\n    }\n\n    \n    \n    function alphaResolutionDeltaAmount()\n    public\n    view\n    returns (uint256)\n    {\n        uint256 scaledBountyAmount = alphaByPhaseNumber(verificationPhaseNumber)\n        .mul(verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount);\n        return (\n        scaledBountyAmount > verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount ?\n        scaledBountyAmount.sub(verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount) :\n        0\n        );\n    }\n\n    \n    \n    \n    function betaResolutionDeltaAmount(bool _status)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 scaledStakedAmount = betaByPhaseNumber(verificationPhaseNumber)\n        .mul(verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount);\n        uint256 scaledStatusStakedAmount = ConstantsLib.PARTS_PER()\n        .mul(verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByStatus[_status]);\n        return (\n        scaledStatusStakedAmount < scaledStakedAmount ?\n        scaledStakedAmount.sub(scaledStatusStakedAmount).div(\n            ConstantsLib.PARTS_PER().sub(betaByPhaseNumber(verificationPhaseNumber))\n        ) :\n        0\n        );\n    }\n\n    \n    \n    function gammaResolutionDelta()\n    public\n    view\n    returns (uint256)\n    {\n        return gammaByPhaseNumber(verificationPhaseNumber)\n        .sub(verificationPhaseByPhaseNumber[verificationPhaseNumber].stakingWallets);\n    }\n\n    \n    \n    function resolutionCriteriaMet()\n    public\n    view\n    returns (bool)\n    {\n        return alphaCriterionMet() && betaCriterionMet() && gammaCriterionMet();\n    }\n\n    \n    \n    function alphaCriterionMet()\n    public\n    view\n    returns (bool)\n    {\n        uint256 baseline = alphaByPhaseNumber(verificationPhaseNumber)\n        .mul(verificationPhaseByPhaseNumber[verificationPhaseNumber].bountyAmount);\n        return verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount >= baseline;\n    }\n\n    \n    \n    function betaCriterionMet()\n    public\n    view\n    returns (bool)\n    {\n        if (0 == verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount)\n            return false;\n\n        bool trueCriterionMet = verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByStatus[true]\n        .mul(ConstantsLib.PARTS_PER())\n        .div(verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount)\n        >= betaByPhaseNumber(verificationPhaseNumber);\n\n        bool falseCriterionMet = verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmountByStatus[false]\n        .mul(ConstantsLib.PARTS_PER())\n        .div(verificationPhaseByPhaseNumber[verificationPhaseNumber].stakedAmount)\n        >= betaByPhaseNumber(verificationPhaseNumber);\n\n        return trueCriterionMet || falseCriterionMet;\n    }\n\n    \n    \n    function gammaCriterionMet()\n    public\n    view\n    returns (bool)\n    {\n        return verificationPhaseByPhaseNumber[verificationPhaseNumber].stakingWallets\n        >= gammaByPhaseNumber(verificationPhaseNumber);\n    }\n\n    \n    \n    \n    function setNextAlpha(uint256 _nextAlpha)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    onlyNotFrozen\n    {\n        \n        nextAlpha = _nextAlpha;\n\n        \n        emit NextAlphaSet(nextAlpha);\n    }\n\n    \n    \n    \n    function setNextBeta(uint256 _nextBeta)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    onlyNotFrozen\n    {\n        \n        nextBeta = _nextBeta;\n\n        \n        emit NextBetaSet(nextBeta);\n    }\n\n    \n    \n    \n    function setNextGamma(uint256 _nextGamma)\n    public\n    onlyRoleAccessor(OWNER_ROLE)\n    onlyNotFrozen\n    {\n        \n        nextGamma = _nextGamma;\n\n        \n        emit NextGammaSet(nextGamma);\n    }\n\n    \n    \n    \n    function alphaByPhaseNumber(uint256 _verificationPhaseNumber)\n    public\n    view\n    returns (uint256)\n    {\n        return verificationPhaseByPhaseNumber[_verificationPhaseNumber].uintCriteria[ALPHA_INDEX];\n    }\n    \n    \n    \n    \n    function betaByPhaseNumber(uint256 _verificationPhaseNumber)\n    public\n    view\n    returns (uint256)\n    {\n        return verificationPhaseByPhaseNumber[_verificationPhaseNumber].uintCriteria[BETA_INDEX];\n    }\n\n    \n    \n    \n    function gammaByPhaseNumber(uint256 _verificationPhaseNumber)\n    public\n    view\n    returns (uint256)\n    {\n        return verificationPhaseByPhaseNumber[_verificationPhaseNumber].uintCriteria[GAMMA_INDEX];\n    }\n\n    \n    function _addVerificationCriteria()\n    internal\n    {\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].uintCriteria.push(nextAlpha);\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].uintCriteria.push(nextBeta);\n        verificationPhaseByPhaseNumber[verificationPhaseNumber].uintCriteria.push(nextGamma);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"metricsByVerificationPhaseNumber\",\"outputs\":[{\"internalType\":\"enum VerificationPhaseLib.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"trueStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"falseStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfWallets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bountyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bountyAwarded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfBlocks\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"metricsByBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"trueStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"falseStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextAlpha\",\"type\":\"uint256\"}],\"name\":\"setNextAlpha\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"isRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"metricsByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"trueStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"falseStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_firstVerificationPhaseNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastVerificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"stagePayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextGamma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextBeta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verificationStatus\",\"outputs\":[{\"internalType\":\"enum VerificationPhaseLib.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addRoleAccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolutionCriteriaMet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stagedAmountByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextAlpha\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeRoleAccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"disabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"withdrawBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"resolutionDeltaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_firstVerificationPhaseNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastVerificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"calculatePayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"betaResolutionDeltaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"stageStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"alphaResolutionDeltaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextBeta\",\"type\":\"uint256\"}],\"name\":\"setNextBeta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gammaCriterionMet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bountyAllocator\",\"type\":\"address\"}],\"name\":\"setBountyAllocator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESOLVE_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"alphaByPhaseNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAKE_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rolesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_action\",\"type\":\"string\"}],\"name\":\"enable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyFund\",\"outputs\":[{\"internalType\":\"contract BountyFund\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resolveIfCriteriaMet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"alphaCriterionMet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"gammaByPhaseNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"betaByPhaseNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyAllocator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verificationPhaseNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payoutStagedByWalletPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_action\",\"type\":\"string\"}],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betaCriterionMet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"stakedAmountByWalletStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextGamma\",\"type\":\"uint256\"}],\"name\":\"setNextGamma\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gammaResolutionDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"metricsByVerificationPhaseNumberAndWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"trueStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"falseStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isRoleAccessor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"stakedAmountByBlockStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"verificationPhaseByPhaseNumber\",\"outputs\":[{\"internalType\":\"enum VerificationPhaseLib.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"enum VerificationPhaseLib.Status\",\"name\":\"result\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingWallets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bountyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bountyAwarded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bountyFund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nextAlpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextBeta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextGamma\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"}],\"name\":\"NextAlphaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beta\",\"type\":\"uint256\"}],\"name\":\"NextBetaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gamma\",\"type\":\"uint256\"}],\"name\":\"NextGammaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_bountyAllocator\",\"type\":\"address\"}],\"name\":\"BountyAllocatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bountyAmount\",\"type\":\"uint256\"}],\"name\":\"BountyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bountyAmount\",\"type\":\"uint256\"}],\"name\":\"VerificationPhaseOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_verificationPhaseNumber\",\"type\":\"uint256\"}],\"name\":\"VerificationPhaseClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_firstVerificationPhaseNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_lastVerificationPhaseNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"name\":\"PayoutStaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakeStaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Staged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"Disabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"Enabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RoleAccessorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RoleAccessorRemoved\",\"type\":\"event\"}]","ContractName":"BergenResolutionEngine","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e5d6bc2457b23a8e18216bc5b57f2b67b008d0b90000000000000000000000004fceff181c59893f8c67ad720b33ab8daa0a131a0000000000000000000000000c6f9d649086011ebb5f11f7ea6213da07361b27000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000928ca80cfc200000000000000000000000000000000000000000000000000000000000000000005","Library":"ConstantsLib:005615cb698d8e8af5ede43cc5a9507285426ccb;VerificationPhaseLib:405ef762c07d450495f65ba4729b0b9fc877bd8f","LicenseType":"","SwarmSource":"bzzr://c55be6bbfd287196b529b7e0f483996c0c1ff58aa52be8b3bf930bd33a926815"}]}