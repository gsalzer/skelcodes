{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function allowance(address owner, address spender) external returns(uint256);\r\n    function approve(address spender, uint256 amount) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n}\r\n\r\ninterface Kyber {\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) external payable returns(uint256);\r\n    function swapTokenToEther(ERC20 token, uint256 srcAmount, uint256 minConversionRate) external returns(uint256);\r\n}\r\n\r\ninterface Synthetix {\r\n    function exchange(bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey, address destinationAddress) external returns(bool);\r\n    function synths(bytes32 currencyKey) external returns(address);\r\n}\r\n\r\ninterface UniswapFactory {\r\n    function getExchange(address token) external view returns(address);\r\n}\r\n\r\ninterface Uniswap {\r\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline) external payable returns(uint256);\r\n    function ethToTokenSwapOutput(uint256 tokensBought, uint256 deadline) external payable returns(uint256);\r\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline) external returns(uint256);\r\n    function tokenToEthSwapOutput(uint256 ethBought, uint256 maxTokens, uint256 deadline) external returns(uint256);\r\n}\r\n\r\ncontract KyberSynthetix {\r\n    Kyber kyber = Kyber(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\r\n    Synthetix synthetix = Synthetix(0xC011A72400E58ecD99Ee497CF89E3775d4bd732F);\r\n    UniswapFactory uniswapFactory = UniswapFactory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\r\n    \r\n    function ethToSynth(bytes32 synthKey) external payable {\r\n        ERC20 synth = ERC20(synthetix.synths(synthKey));\r\n        _ethToSeth();\r\n        _sethToSynth(synthKey);\r\n        synth.transfer(msg.sender, synth.balanceOf(address(this)));\r\n    }\r\n    \r\n    function synthToEth(bytes32 synthKey, uint256 inputAmount) external {\r\n        ERC20 synth = ERC20(synthetix.synths(synthKey));\r\n        synth.transferFrom(msg.sender, address(this), inputAmount);\r\n        _synthToSeth(synthKey);\r\n        _sethToEth();\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function tokenToSynth(ERC20 token, bytes32 synthKey, uint256 inputAmount) external {\r\n        ERC20 synth = ERC20(synthetix.synths(synthKey));\r\n        token.transferFrom(msg.sender, address(this), inputAmount);\r\n        _tokenToEth(token);\r\n        _ethToSeth();\r\n        _sethToSynth(synthKey);\r\n        synth.transfer(msg.sender, synth.balanceOf(address(this)));\r\n    }\r\n    \r\n    function synthToToken(bytes32 synthKey, ERC20 token, uint256 inputAmount) external {\r\n        ERC20 synth = ERC20(synthetix.synths(synthKey));\r\n        synth.transferFrom(msg.sender, address(this), inputAmount);\r\n        _synthToSeth(synthKey);\r\n        _sethToEth();\r\n        _ethToToken(token);\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n    \r\n    function _tokenToEth(ERC20 token) internal {\r\n        _unlockToken(token, address(kyber));\r\n        uint256 amount = token.balanceOf(address(this));\r\n        kyber.swapTokenToEther(token, amount, 0);\r\n    }\r\n    \r\n    function _ethToToken(ERC20 token) internal {\r\n        uint256 amount = token.balanceOf(address(this));\r\n        kyber.swapEtherToToken.value(amount)(token, 0);\r\n    }\r\n    \r\n    function _sethToSynth(bytes32 synthKey) internal {\r\n        if (synthKey == 'sETH') {\r\n            return;\r\n        }\r\n        ERC20 synth = ERC20(synthetix.synths(synthKey));\r\n        uint256 amount = synth.balanceOf(address(this));\r\n        _unlockToken(synth, address(synthetix));\r\n        synthetix.exchange('sETH', amount, synthKey, address(this));\r\n    }\r\n    \r\n    function _synthToSeth(bytes32 synthKey) internal {\r\n        if (synthKey == 'sETH') {\r\n            return;\r\n        }\r\n        ERC20 synth = ERC20(synthetix.synths(synthKey));\r\n        uint256 amount = synth.balanceOf(address(this));\r\n        _unlockToken(synth, address(synthetix));\r\n        synthetix.exchange(synthKey, amount, 'sETH', address(this));\r\n    }\r\n    \r\n    function _ethToSeth() internal {\r\n        address synthAddress = synthetix.synths('sETH');\r\n        Uniswap uniswap = Uniswap(uniswapFactory.getExchange(synthAddress));\r\n        uint256 amount;\r\n        if (msg.value > 0) {\r\n            amount = msg.value;\r\n        } else {\r\n            amount = address(this).balance;\r\n        }\r\n        uniswap.ethToTokenSwapInput.value(amount)(0, block.timestamp);\r\n    }\r\n    \r\n    function _sethToEth() internal {\r\n        ERC20 synth = ERC20(synthetix.synths('sETH'));\r\n        Uniswap uniswap = Uniswap(uniswapFactory.getExchange(address(synth)));\r\n        _unlockToken(synth, address(uniswap));\r\n        uniswap.tokenToEthSwapInput(synth.balanceOf(address(this)), 0, block.timestamp);\r\n    }\r\n    \r\n    function _unlockToken(ERC20 token, address to) internal {\r\n        if (token.allowance(address(this), to) == 0) {\r\n            token.approve(to, uint256(-1));\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"synthKey\",\"type\":\"bytes32\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"synthToToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"synthKey\",\"type\":\"bytes32\"}],\"name\":\"ethToSynth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"synthKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"synthToEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"synthKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"tokenToSynth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberSynthetix","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://8287b19900f27a87dcc930da086f0a23f3caaacf283dd584bb749f36dafd454d"}]}