{"status":"1","message":"OK","result":[{"SourceCode":"{\"AddressUtils.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary AddressUtils {\\n\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param _addr address to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly { size := extcodesize(_addr) }\\n        return size \\u003e 0;\\n    }\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n    function allowance(address _owner, address _spender)\\n    public view returns (uint256);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n    public returns (bool);\\n\\n    function approve(address _spender, uint256 _value) public returns (bool);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * See https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n    function totalSupply() public view returns (uint256);\\n    function balanceOf(address _who) public view returns (uint256);\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\". This adds two-phase\\n * ownership control to OpenZeppelin\\u0027s Ownable class. In this model, the original owner\\n * designates a new owner but does not actually transfer ownership. The new owner then accepts\\n * ownership and completes the transfer.\\n */\\ncontract Ownable {\\n    address _owner;\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"OwnerRole: caller does not have the Owner role\\\");\\n        _;\\n    }\\n\\n    function isOwner(address account) public view returns (bool) {\\n        return account == _owner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        c = _a * _b;\\n        assert(c / _a == _b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n        return _a / _b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        assert(_b \\u003c= _a);\\n        return _a - _b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n        c = _a + _b;\\n        assert(c \\u003e= _a);\\n        return c;\\n    }\\n}\\n\"},\"TokenStorage.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\u0027./Ownable.sol\\u0027;\\n\\n/**\\n* @title TokenStorage\\n*/\\ncontract TokenStorage  is Ownable{\\n    using SafeMath for uint256;\\n\\n    //    mapping (address =\\u003e bool) internal _allowedAccess;\\n\\n    // Access Modifier for Storage contract\\n    address internal _registryContract;\\n\\n    constructor() public {\\n        _owner = msg.sender;\\n        _totalSupply = 1000000000 * 10 ** 18;\\n        _balances[_owner] = _totalSupply;\\n    }\\n\\n    function setProxyContractAndVersionOneDeligatee(address registryContract) onlyOwner public{\\n        require(registryContract != address(0), \\\"InvalidAddress: invalid address passed for proxy contract\\\");\\n        _registryContract = registryContract;\\n    }\\n\\n    function getRegistryContract() view public returns(address){\\n        return _registryContract;\\n    }\\n\\n    //    function addDeligateContract(address upgradedDeligatee) public{\\n    //        require(msg.sender == _registryContract, \\\"AccessDenied: only registry contract allowed access\\\");\\n    //        _allowedAccess[upgradedDeligatee] = true;\\n    //    }\\n\\n    modifier onlyAllowedAccess() {\\n        require(msg.sender == _registryContract, \\\"AccessDenied: This address is not allowed to access the storage\\\");\\n        _;\\n    }\\n\\n    // Allowances with its Getter and Setter\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\n\\n    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyAllowedAccess {\\n        _allowances[_tokenHolder][_spender] = _value;\\n    }\\n\\n    function getAllowance(address _tokenHolder, address _spender) public view onlyAllowedAccess returns(uint256){\\n        return _allowances[_tokenHolder][_spender];\\n    }\\n\\n\\n    // Balances with its Getter and Setter\\n    mapping (address =\\u003e uint256) internal _balances;\\n    function addBalance(address _addr, uint256 _value) public onlyAllowedAccess {\\n        _balances[_addr] = _balances[_addr].add(_value);\\n    }\\n\\n    function subBalance(address _addr, uint256 _value) public onlyAllowedAccess {\\n        _balances[_addr] = _balances[_addr].sub(_value);\\n    }\\n\\n    function setBalance(address _addr, uint256 _value) public onlyAllowedAccess {\\n        _balances[_addr] = _value;\\n    }\\n\\n    function getBalance(address _addr) public view onlyAllowedAccess returns(uint256){\\n        return _balances[_addr];\\n    }\\n\\n    // Total Supply with Getter and Setter\\n    uint256 internal _totalSupply = 0;\\n\\n    function addTotalSupply(uint256 _value) public onlyAllowedAccess {\\n        _totalSupply = _totalSupply.add(_value);\\n    }\\n\\n    function subTotalSupply(uint256 _value) public onlyAllowedAccess {\\n        _totalSupply = _totalSupply.sub(_value);\\n    }\\n\\n    function setTotalSupply(uint256 _value) public onlyAllowedAccess {\\n        _totalSupply = _value;\\n    }\\n\\n    function getTotalSupply() public view onlyAllowedAccess returns(uint256) {\\n        return(_totalSupply);\\n    }\\n\\n\\n    // Locking Storage\\n    /**\\n    * @dev Reasons why a user\\u0027s tokens have been locked\\n    */\\n    mapping(address =\\u003e bytes32[]) internal lockReason;\\n\\n    /**\\n     * @dev locked token structure\\n     */\\n    struct lockToken {\\n        uint256 amount;\\n        uint256 validity;\\n        bool claimed;\\n    }\\n\\n    /**\\n     * @dev Holds number \\u0026 validity of tokens locked for a given reason for\\n     *      a specified address\\n     */\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e lockToken)) internal locked;\\n\\n\\n    // Lock Access Functions\\n    function getLockedTokenAmount(address _of, bytes32 _reason) public view onlyAllowedAccess returns (uint256 amount){\\n        if (!locked[_of][_reason].claimed)\\n            amount = locked[_of][_reason].amount;\\n    }\\n\\n    function getLockedTokensAtTime(address _of, bytes32 _reason, uint256 _time) public view onlyAllowedAccess returns(uint256 amount){\\n        if (locked[_of][_reason].validity \\u003e _time)\\n            amount = locked[_of][_reason].amount;\\n    }\\n\\n    function getTotalLockedTokens(address _of) public view onlyAllowedAccess returns(uint256 amount){\\n        for (uint256 i = 0; i \\u003c lockReason[_of].length; i++) {\\n            amount = amount.add(getLockedTokenAmount(_of, lockReason[_of][i]));\\n        }\\n    }\\n\\n    function extendTokenLock(address _of, bytes32 _reason, uint256 _time) public onlyAllowedAccess returns(uint256 amount, uint256 validity){\\n\\n        locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n        amount = locked[_of][_reason].amount;\\n        validity = locked[_of][_reason].validity;\\n    }\\n\\n    function increaseLockAmount(address _of, bytes32 _reason, uint256 _amount) public onlyAllowedAccess returns(uint256 amount, uint256 validity){\\n        locked[_of][_reason].amount = locked[_of][_reason].amount.add(_amount);\\n        amount = locked[_of][_reason].amount;\\n        validity = locked[_of][_reason].validity;\\n    }\\n\\n    function getUnlockable(address _of, bytes32 _reason) public view onlyAllowedAccess returns(uint256 amount){\\n        if (locked[_of][_reason].validity \\u003c= now \\u0026\\u0026 !locked[_of][_reason].claimed)\\n            amount = locked[_of][_reason].amount;\\n    }\\n\\n    function addLockedToken(address _of, bytes32 _reason, uint256 _amount, uint256 _validity) public onlyAllowedAccess {\\n        locked[_of][_reason] = lockToken(_amount, _validity, false);\\n    }\\n\\n    function addLockReason(address _of, bytes32 _reason) public onlyAllowedAccess {\\n        lockReason[_of].push(_reason);\\n    }\\n\\n    function getNumberOfLockReasons(address _of) public view onlyAllowedAccess returns(uint256 number){\\n        number = lockReason[_of].length;\\n    }\\n\\n    function getLockReason(address _of, uint256 _i) public view onlyAllowedAccess returns(bytes32 reason){\\n        reason = lockReason[_of][_i];\\n    }\\n\\n    function setClaimed(address _of, bytes32 _reason) public onlyAllowedAccess{\\n        locked[_of][_reason].claimed = true;\\n    }\\n\\n    function caller(address _of) public view  onlyAllowedAccess returns(uint){\\n        return getTotalLockedTokens(_of);\\n    }\\n}\"},\"Token_V0.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\nimport \\\"./TokenStorage.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./AddressUtils.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\u0027./Ownable.sol\\u0027;\\n\\n/**\\n* @title Token_V0\\n* @notice A basic ERC20 token with modular data storage\\n*/\\ncontract Token_V0 is ERC20, Ownable{\\n    using SafeMath for uint256;\\n\\n    string public constant name = \\u0027RoboAi Coin R2R\\u0027;\\n    string public constant symbol = \\u0027R2R\\u0027;\\n    uint8 public constant decimals = 18;\\n\\n    event Lock(\\n        address indexed _of,\\n        bytes32 indexed _reason,\\n        uint256 _amount,\\n        uint256 _validity\\n    );\\n\\n    /**\\n     * @dev Records data of all the tokens unlocked\\n     */\\n    event Unlock(\\n        address indexed _of,\\n        bytes32 indexed _reason,\\n        uint256 _amount\\n    );\\n\\n    string internal constant ALREADY_LOCKED = \\\"Tokens already locked\\\";\\n    string internal constant NOT_LOCKED = \\\"No tokens locked\\\";\\n    string internal constant AMOUNT_ZERO = \\\"Amount can not be 0\\\";\\n\\n    /** Events */\\n    event Mint(address indexed to, uint256 value);\\n    event Burn(address indexed burner, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    TokenStorage dataStore;\\n    address dataStoreAddress;\\n\\n    constructor(address storeAddress) public {\\n        dataStore = TokenStorage(storeAddress);\\n        dataStoreAddress = storeAddress;\\n    }\\n\\n    /** Modifiers **/\\n\\n    /** Functions **/\\n\\n    function totalSupply() public view returns(uint256) {\\n        return(dataStore.getTotalSupply());\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return dataStore.getBalance(account);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return dataStore.getAllowance(owner, spender);\\n    }\\n\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        require(dataStore.getAllowance(sender, msg.sender) \\u003e= amount, \\\"AllowanceError: The spender does not hve the required allowance to spend token holder\\u0027s tokens\\\");\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, dataStore.getAllowance(sender, msg.sender).sub(amount));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(dataStore.getBalance(sender) \\u003e= amount, \\\"Insufficient Funds\\\");\\n\\n        dataStore.subBalance(sender, amount);\\n        dataStore.addBalance(recipient, amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        dataStore.setAllowance(owner, spender, value);\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    // Mintable Functionality\\n    function mintToken(address recipient, uint256 value) public onlyOwner{\\n        dataStore.addTotalSupply(value);\\n        dataStore.addBalance(recipient, value);\\n        emit Mint(recipient, value);\\n    }\\n\\n    function burnToken(uint256 value) public{\\n        address sender = msg.sender;\\n        dataStore.subBalance(sender, value);\\n        dataStore.subTotalSupply(value);\\n        emit Burn(msg.sender, value);\\n    }\\n\\n\\n    // Lockable Functionality according to EIP1132\\n    /**\\n    * @dev Locks a specified amount of tokens against an address,\\n    *      for a specified reason and time\\n    * @param _reason The reason to lock tokens\\n    * @param _amount Number of tokens to be locked\\n    * @param _time Lock time in seconds\\n    */\\n    function lock(bytes32 _reason, uint256 _amount, uint256 _time)\\n    public\\n    returns (bool)\\n    {\\n        uint256 validUntil = block.timestamp.add(_time);\\n\\n        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);\\n\\n        require(tokensAlreadyLocked == 0, ALREADY_LOCKED);\\n        require(_amount != 0, AMOUNT_ZERO);\\n\\n        dataStore.addLockReason(msg.sender, _reason);\\n\\n        _transfer(msg.sender, dataStore, _amount);\\n\\n        dataStore.addLockedToken(msg.sender, _reason, _amount, validUntil);\\n\\n        emit Lock(msg.sender, _reason, _amount, validUntil);\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Transfers and Locks a specified amount of tokens,\\n     *      for a specified reason and time\\n     * @param _to adress to which tokens are to be transfered\\n     * @param _reason The reason to lock tokens\\n     * @param _amount Number of tokens to be transfered and locked\\n     * @param _time Lock time in seconds\\n     */\\n    function transferWithLock(address _to, bytes32 _reason, uint256 _amount, uint256 _time)\\n    public\\n    returns (bool)\\n    {\\n        uint256 validUntil = block.timestamp.add(_time);\\n\\n        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(_to, _reason);\\n\\n        require(tokensAlreadyLocked == 0, ALREADY_LOCKED);\\n        require(_amount != 0, AMOUNT_ZERO);\\n        require(_to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        dataStore.addLockReason(_to, _reason);\\n\\n        _transfer(msg.sender, dataStore, _amount);\\n\\n        dataStore.addLockedToken(_to, _reason, _amount, validUntil);\\n\\n        emit Lock(_to, _reason, _amount, validUntil);\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @dev Returns tokens locked for a specified address for a\\n    *      specified reason\\n    *\\n    * @param _of The address whose tokens are locked\\n    * @param _reason The reason to query the lock tokens for\\n    */\\n    function tokensLocked(address _of, bytes32 _reason)\\n    public\\n    view\\n    returns (uint256 amount)\\n    {\\n        return dataStore.getLockedTokenAmount(_of, _reason);\\n    }\\n\\n\\n    /**\\n    * @dev Returns tokens locked for a specified address for a\\n    *      specified reason at a specific time\\n    *\\n    * @param _of The address whose tokens are locked\\n    * @param _reason The reason to query the lock tokens for\\n    * @param _time The timestamp to query the lock tokens for\\n    */\\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\\n    public\\n    view\\n    returns (uint256 amount)\\n    {\\n        amount = dataStore.getLockedTokensAtTime(_of, _reason, _time);\\n    }\\n\\n\\n    /**\\n * @dev Returns total tokens held by an address (locked + transferable)\\n * @param _of The address to query the total balance of\\n */\\n    function totalBalanceOf(address _of)\\n    public\\n    view\\n    returns (uint256 amount)\\n    {\\n        amount = balanceOf(_of);\\n        amount = amount + dataStore.getTotalLockedTokens(_of);\\n    }\\n\\n\\n    /**\\n    * @dev Extends lock for a specified reason and time\\n    * @param _reason The reason to lock tokens\\n    * @param _time Lock extension time in seconds\\n    */\\n    function extendLock(bytes32 _reason, uint256 _time)\\n    public\\n    returns (bool)\\n    {\\n        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);\\n        require(tokensAlreadyLocked \\u003e 0, NOT_LOCKED);\\n\\n        (uint256 amount, uint256 validity) = dataStore.extendTokenLock(msg.sender, _reason, _time);\\n\\n        emit Lock(msg.sender, _reason, amount, validity);\\n        return true;\\n    }\\n\\n\\n    /**\\n  * @dev Increase number of tokens locked for a specified reason\\n  * @param _reason The reason to lock tokens\\n  * @param _amount Number of tokens to be increased\\n  */\\n    function increaseLockAmount(bytes32 _reason, uint256 _amount)\\n    public\\n    returns (bool)\\n    {\\n        uint256 tokensAlreadyLocked = dataStore.getLockedTokenAmount(msg.sender, _reason);\\n        require(tokensAlreadyLocked \\u003e 0, NOT_LOCKED);\\n        _transfer(msg.sender, dataStore, _amount);\\n        (uint256 amount, uint256 validity) = dataStore.increaseLockAmount(msg.sender, _reason, _amount);\\n\\n        emit Lock(msg.sender, _reason, amount, validity);\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @dev Returns unlockable tokens for a specified address for a specified reason\\n    * @param _of The address to query the the unlockable token count of\\n    * @param _reason The reason to query the unlockable tokens for\\n    */\\n    function tokensUnlockable(address _of, bytes32 _reason)\\n    public\\n    view\\n    returns (uint256 amount)\\n    {\\n        return dataStore.getUnlockable(_of, _reason);\\n    }\\n\\n\\n    /**\\n    * @dev Unlocks the unlockable tokens of a specified address\\n    * @param _of Address of user, claiming back unlockable tokens\\n    */\\n    function unlock(address _of)\\n    public\\n    returns (uint256 unlockableTokens)\\n    {\\n        uint256 lockedTokens;\\n        uint256 numLockReasons = dataStore.getNumberOfLockReasons(_of);\\n        for (uint256 i = 0; i \\u003c numLockReasons; i++) {\\n            bytes32 reason = dataStore.getLockReason(_of, i);\\n            lockedTokens = tokensUnlockable(_of, reason);\\n            if (lockedTokens \\u003e 0) {\\n                unlockableTokens += lockedTokens;\\n                dataStore.setClaimed(_of, reason);\\n                emit Unlock(_of, reason, lockedTokens);\\n            }\\n        }\\n\\n        if (unlockableTokens \\u003e 0)\\n            _transfer(dataStore, _of, unlockableTokens);\\n    }\\n\\n\\n    /**\\n    * @dev Gets the unlockable tokens of a specified address\\n    * @param _of The address to query the the unlockable token count of\\n    */\\n    function getUnlockableTokens(address _of)\\n    public\\n    view\\n    returns (uint256 unlockableTokens)\\n    {\\n        uint256 numLockReasons = dataStore.getNumberOfLockReasons(_of);\\n        for (uint256 i = 0; i \\u003c numLockReasons; i++) {\\n            bytes32 reason = dataStore.getLockReason(_of, i);\\n            unlockableTokens = unlockableTokens + tokensUnlockable(_of, reason);\\n        }\\n    }\\n}\"},\"Token_V1.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\nimport \\\"./Token_V0.sol\\\";\\n\\ncontract Token_V1 is Token_V0{\\n\\n    mapping(string =\\u003e uint) tokenDistribution;\\n\\n    constructor(address storeAddress)\\n    Token_V0(storeAddress)\\n    public {\\n        tokenDistribution[\\u0027team\\u0027] = 7;\\n        tokenDistribution[\\u0027partner\\u0027] = 5;\\n        tokenDistribution[\\u0027marketing\\u0027] = 7;\\n        tokenDistribution[\\u0027sale\\u0027] = 50;\\n        tokenDistribution[\\u0027reserve\\u0027] = 30;\\n        tokenDistribution[\\u0027airdrop\\u0027] = 1;\\n    }\\n\\n    function getTokenDistributionPercentage(string  allocatee) public view returns(uint percentage){\\n        percentage = tokenDistribution[allocatee];\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"allocatee\",\"type\":\"string\"}],\"name\":\"getTokenDistributionPercentage\",\"outputs\":[{\"name\":\"percentage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"tokensLockedAtTime\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reason\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[{\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"transferWithLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensUnlockable\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensLocked\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reason\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseLockAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reason\",\"type\":\"bytes32\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getUnlockableTokens\",\"outputs\":[{\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"storeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token_V1","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006da3b1c40cf4591fb55dccc09f22763e36a7db9e","Library":"","SwarmSource":"bzzr://c2f75eabced783983c8881c1b0a9662075ad8d204e7a2f3b5e432344a4058ce4"}]}