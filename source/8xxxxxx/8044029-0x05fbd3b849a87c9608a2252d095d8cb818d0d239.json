{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\ncontract Ownable {\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"You are not owner of this token!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Pausable\\r\\n * @dev Base contract which allows children to implement an emergency stop mechanism. Identical to OpenZeppelin version\\r\\n * except that it uses local Ownable contract\\r\\n */\\r\\ncontract Pausable is Ownable {\\r\\n    event Pause();\\r\\n    event Unpause();\\r\\n\\r\\n    bool public paused = false;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused, \\\"This token is not pausing!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(paused, \\\"This token is pausing!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev called by the owner to pause, triggers stopped state\\r\\n     */\\r\\n    function pause() onlyOwner whenNotPaused public {\\r\\n        paused = true;\\r\\n        emit Pause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev called by the owner to unpause, returns to normal state\\r\\n     */\\r\\n    function unpause() onlyOwner whenPaused public {\\r\\n        paused = false;\\r\\n        emit Unpause();\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\n\\r\\ncontract SafeMath {\\r\\n    function safeMul(uint256 a, uint256 b) internal returns (uint256) {\\r\\n        uint256 c = a * b;\\r\\n        assert(a == 0 || c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\\r\\n        assert(b \\u003e 0);\\r\\n        uint256 c = a / b;\\r\\n        assert(a == b * c + a % b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function safeSub(uint256 a, uint256 b) internal returns (uint256) {\\r\\n        assert(b \\u003c= a);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        assert(c\\u003e=a \\u0026\\u0026 c\\u003e=b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function assert(bool assertion) internal {\\r\\n        if (!assertion) {\\r\\n            throw;\\r\\n        }\\r\\n    }\\r\\n}\"},\"TokenERC20.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Pausable.sol\\\";\\r\\n\\r\\ninterface tokenRecipient {\\r\\n    //function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\\r\\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\\r\\n}\\r\\n\\r\\ncontract TokenERC20 is SafeMath, Pausable{\\r\\n\\r\\n    // Public variables of the token\\r\\n    address public manager;\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public decimals = 18;\\r\\n    // 18 decimals is the strongly suggested default, avoid changing it\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    // This creates an array with all balances\\r\\n    mapping (address =\\u003e uint256) public balanceOf;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\r\\n\\r\\n    // This generates a public event on the blockchain that will notify clients\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    // This generates a public event on the blockchain that will notify clients\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n\\r\\n    // This notifies clients about the amount burnt\\r\\n    event Burn(address indexed from, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * Constructor function\\r\\n     *\\r\\n     * Initializes contract with initial supply tokens to the creator of the contract\\r\\n     */\\r\\n    constructor(\\r\\n        uint256 initialSupply,\\r\\n        string memory tokenName,\\r\\n        string memory tokenSymbol\\r\\n    ) public {\\r\\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\\r\\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\\r\\n        name = tokenName;                                   // Set the name for display purposes\\r\\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\\r\\n        manager = msg.sender;\\r\\n    }\\r\\n    /**\\r\\n     *\\r\\n     * Get balance of \\u0027tokenOwner\\u0027\\r\\n     *\\r\\n     * @param tokenOwner The address of \\u0027tokenOwner\\u0027\\r\\n     */\\r\\n    function balanceOf(address tokenOwner) public view returns (uint) {\\r\\n        return balanceOf[tokenOwner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Internal transfer, only can be called by this contract\\r\\n     */\\r\\n    function _transfer(address _from, address _to, uint _value) internal {\\r\\n        // Prevent transfer to 0x0 address. Use burn() instead\\r\\n        require(_to != address(0x0));\\r\\n        // Check if the sender has enough\\r\\n        require(balanceOf[_from] \\u003e= _value);\\r\\n        // Check for overflows\\r\\n        require(balanceOf[_to] + _value \\u003e= balanceOf[_to]);\\r\\n        // Save this for an assertion in the future\\r\\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\\r\\n        // Subtract from the sender\\r\\n        // balanceOf[_from] -= _value;\\r\\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\\r\\n        // Add the same to the recipient\\r\\n        // balanceOf[_to] += _value;\\r\\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\\r\\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer tokens\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` from your account\\r\\n     *\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function transfer(address _to, uint256 _value) whenNotPaused public returns (bool success) {\\r\\n        _transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * Transfer tokens from other address\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` on behalf of `_from`\\r\\n     *\\r\\n     * @param _from The address of the sender\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\r\\n        require(_value \\u003c= allowance[_from][msg.sender]);     // Check allowance\\r\\n        allowance[_from][msg.sender] -= _value;\\r\\n        _transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set allowance for other address\\r\\n     *\\r\\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\\r\\n     *\\r\\n     * @param _spender The address authorized to spend\\r\\n     * @param _value the max amount they can spend\\r\\n     */\\r\\n    function approve(address _spender, uint256 _value) whenNotPaused public returns (bool success) {\\r\\n        allowance[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // This function returns the current approved number of tokens by an \\u0027_owner\\u0027 to a specific \\u0027_spender\\u0027,\\r\\n    // as set in the approve function.\\r\\n    function allowance(address _owner, address _spender) public view returns (uint) {\\r\\n        return allowance[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set allowance for other address and notify\\r\\n     *\\r\\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\\r\\n     *\\r\\n     * @param _spender The address authorized to spend\\r\\n     * @param _value the max amount they can spend\\r\\n     * @param _extraData some extra information to send to the approved contract\\r\\n     */\\r\\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\\r\\n        tokenRecipient spender = tokenRecipient(_spender);\\r\\n        if (approve(_spender, _value)) {\\r\\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly\\r\\n     *\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function burn(uint256 _value) public returns (bool success) {\\r\\n        require(balanceOf[msg.sender] \\u003e= _value);   // Check if the sender has enough\\r\\n        // balanceOf[msg.sender] -= _value;            // Subtract from the sender\\r\\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\\r\\n        // totalSupply -= _value;                      // Updates totalSupply\\r\\n        totalSupply = safeSub(totalSupply, _value);\\r\\n        emit Burn(msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens from other account\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\\r\\n        require(balanceOf[_from] \\u003e= _value);                // Check if the targeted balance is enough\\r\\n        require(_value \\u003c= allowance[_from][msg.sender]);    // Check allowance\\r\\n        // balanceOf[_from] -= _value;                         // Subtract from the targeted balance\\r\\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\\r\\n        // allowance[_from][msg.sender] -= _value;             // Subtract from the sender\\u0027s allowance\\r\\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\\r\\n        // totalSupply -= _value;                              // Update totalSupply\\r\\n        totalSupply = safeSub(totalSupply, _value);\\r\\n        emit Burn(_from, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"TokenERC865.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\nimport \\\"./TokenERC20.sol\\\";\\r\\n\\r\\ncontract TokenERC865 is TokenERC20 {\\r\\n\\r\\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\\r\\n    event TransferPreSignedNotFeeToken(address indexed from, address indexed to, address indexed delegate, uint256 amount);\\r\\n\\r\\n    function transferPreSigned(address _from, address _to, uint256 _value, uint256 _fee) onlyOwner public returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        require(_from != address(0));\\r\\n        require(balanceOf[_from] \\u003e= safeAdd(_value, _fee));\\r\\n        balanceOf[_from] = safeSub(safeSub(balanceOf[_from], _value), _fee);\\r\\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\\r\\n        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], _fee);\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        emit Transfer(_from, msg.sender, _fee);\\r\\n        emit TransferPreSigned(_from, _to, msg.sender, _value, _fee);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferPreSignedNotFeeToken(address _from, address _to, uint256 _value) onlyOwner public returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        require(_from != address(0));\\r\\n        require(balanceOf[_from] \\u003e= _value);\\r\\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\\r\\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        emit TransferPreSignedNotFeeToken(_from, _to, msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\"},\"TokenICBX.sol\":{\"content\":\"pragma solidity ^0.4.25;\\r\\n\\r\\nimport \\\"./TokenERC865.sol\\\";\\r\\n\\r\\ncontract TokenICBX is TokenERC865 {\\r\\n\\r\\n//    uint256 public sellPrice;\\r\\n//    uint256 public buyPrice;\\r\\n    mapping (address =\\u003e bool) public frozenAccount;\\r\\n    mapping (address =\\u003e uint256) public freezeOf;\\r\\n\\r\\n    /* This generates a public event on the blockchain that will notify clients */\\r\\n    event FrozenFunds(address target, bool frozen);\\r\\n\\r\\n    /* This notifies clients about the amount frozen */\\r\\n    event Freeze(address indexed from, uint256 value);\\r\\n\\r\\n    /* This notifies clients about the amount unfrozen */\\r\\n    event Unfreeze(address indexed from, uint256 value);\\r\\n\\r\\n    /* Initializes contract with initial supply tokens to the creator of the contract */\\r\\n    constructor(\\r\\n        uint256 initialSupply,\\r\\n        string tokenName,\\r\\n        string tokenSymbol\\r\\n    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}\\r\\n\\r\\n    /* Internal transfer, only can be called by this contract */\\r\\n    function _transfer(address _from, address _to, uint _value) internal {\\r\\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\\r\\n        require (balanceOf[_from] \\u003e= _value);               // Check if the sender has enough\\r\\n        require (balanceOf[_to] + _value \\u003e= balanceOf[_to]); // Check for overflows\\r\\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\\r\\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\\r\\n        // balanceOf[_from] -= _value;                         // Subtract from the sender\\r\\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\\r\\n        // balanceOf[_to] += _value;                           // Add the same to the recipient\\r\\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\\r\\n        emit Transfer(_from, _to, _value);\\r\\n    }\\r\\n\\r\\n    /// @notice Create `mintedAmount` tokens and send it to `target`\\r\\n    /// @param target Address to receive the tokens\\r\\n    /// @param mintedAmount the amount of tokens it will receive\\r\\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\\r\\n        // balanceOf[target] += mintedAmount;\\r\\n        balanceOf[target] = safeAdd(balanceOf[target], mintedAmount);\\r\\n        // totalSupply += mintedAmount;\\r\\n        totalSupply = safeAdd(totalSupply, mintedAmount);\\r\\n        emit Transfer(0, this, mintedAmount);\\r\\n        emit Transfer(this, target, mintedAmount);\\r\\n    }\\r\\n\\r\\n    /// @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\r\\n    /// @param target Address to be frozen\\r\\n    /// @param freeze either to freeze it or not\\r\\n    function freezeAccount(address target, bool freeze) onlyOwner public {\\r\\n        frozenAccount[target] = freeze;\\r\\n        emit FrozenFunds(target, freeze);\\r\\n    }\\r\\n\\r\\n//    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\\r\\n//    /// @param newSellPrice Price the users can sell to the contract\\r\\n//    /// @param newBuyPrice Price users can buy from the contract\\r\\n//    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\\r\\n//        sellPrice = newSellPrice;\\r\\n//        buyPrice = newBuyPrice;\\r\\n//    }\\r\\n//\\r\\n//    /// @notice Buy tokens from contract by sending ether\\r\\n//    function buy() payable public {\\r\\n//        //uint amount = msg.value / buyPrice;               // calculates the amount\\r\\n//        uint amount = safeDiv(msg.value, buyPrice);\\r\\n//        _transfer(this, msg.sender, amount);              // makes the transfers\\r\\n//    }\\r\\n//\\r\\n//    /// @notice Sell `amount` tokens to contract\\r\\n//    /// @param amount amount of tokens to be sold\\r\\n//    function sell(uint256 amount) public {\\r\\n//        address myAddress = this;\\r\\n//        require(myAddress.balance \\u003e= amount * sellPrice);      // checks if the contract has enough ether to buy\\r\\n//        _transfer(msg.sender, this, amount);              // makes the transfers\\r\\n//        //msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It\\u0027s important to do this last to avoid recursion attacks\\r\\n//        msg.sender.transfer(safeMul(amount, sellPrice));\\r\\n//    }\\r\\n\\r\\n    function freeze(uint256 _value) returns (bool success) {\\r\\n        require(balanceOf[msg.sender] \\u003e= _value);            // Check if the sender has enough\\r\\n        require(_value \\u003e 0);\\r\\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender\\r\\n        freezeOf[msg.sender] = safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply\\r\\n        emit Freeze(msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function unfreeze(uint256 _value) returns (bool success) {\\r\\n        require(freezeOf[msg.sender] \\u003e= _value);            // Check if the sender has enough\\r\\n        require(_value \\u003e= 0);\\r\\n        freezeOf[msg.sender] = safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender\\r\\n        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], _value);\\r\\n        emit Unfreeze(msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // transfer balance to owner\\r\\n    function withdrawEther(uint256 amount) onlyOwner {\\r\\n        owner.transfer(amount);\\r\\n    }\\r\\n\\r\\n    // can accept ether\\r\\n    function() payable {\\r\\n\\r\\n    }\\r\\n\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferPreSignedNotFeeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"transferPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unfreeze\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TransferPreSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferPreSignedNotFeeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenICBX","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004494342580000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044943425800000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://e9b9e7559d777b98e00e663b349a3e1e853411beca5e1876a75bb10715af7dc3"}]}