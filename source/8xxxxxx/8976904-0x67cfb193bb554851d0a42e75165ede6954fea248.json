{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\ncontract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public;\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public;\n\n    function permit(address src, address dst, bytes32 sig) public;\n    function forbid(address src, address dst, bytes32 sig) public;\n\n}\n\ncontract DSGuardFactory {\n    function newGuard() public returns (DSGuard guard);\n}\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint              wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache;  \n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    function() external payable {\n    }\n\n    \n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        returns (address target, bytes32 response)\n    {\n        target = cache.read(_code);\n        if (target == address(0)) {\n            \n            target = cache.write(_code);\n        }\n\n        response = execute(target, _data);\n    }\n\n    function execute(address _target, bytes memory _data)\n        public\n        auth\n        note\n        payable\n        returns (bytes32 response)\n    {\n        require(_target != address(0));\n\n        \n        assembly {\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 32)\n            response := mload(0)      \n            switch iszero(succeeded)\n            case 1 {\n                \n                revert(0, 0)\n            }\n        }\n    }\n\n    \n    function setCache(address _cacheAddr)\n        public\n        payable\n        auth\n        note\n        returns (bool)\n    {\n        require(_cacheAddr != address(0));        \n        cache = DSProxyCache(_cacheAddr);  \n        return true;\n    }\n}\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n            case 1 {\n                \n                revert(0, 0)\n            }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n\ncontract SubscribeToMonitorProxy {\n\n    address public constant MONITOR_PROXY_ADDRESS = 0x1a7C7F3088411Dd5e2f9d1f725b3c06C521a7bF9;\n\n    function allow() public {\n        DSGuard guard = getDSGuard();\n\n        guard.permit(MONITOR_PROXY_ADDRESS, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    function getDSGuard() internal view returns (DSGuard) {\n        DSProxy proxy = DSProxy(address(uint160(address(this))));\n        DSAuth auth = DSAuth(address(proxy.authority));\n\n        return DSGuard(address(auth));\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MONITOR_PROXY_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SubscribeToMonitorProxy","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://2c1502e1586f071bc6081683a9ff2325e59b4c908ccdd3deaa8c422af5aa4ef4"}]}