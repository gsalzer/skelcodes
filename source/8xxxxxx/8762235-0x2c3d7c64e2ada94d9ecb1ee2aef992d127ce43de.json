{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ITransferRules.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\ncontract ITransferRules {\r\n    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n    /// @param from Sending address\r\n    /// @param to Receiving address\r\n    /// @param value Amount of tokens being transferred\r\n    /// @return Code by which to reference message for rejection reasoning\r\n    function detectTransferRestriction(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external view returns (uint8);\r\n\r\n    /// @notice Returns a human-readable message for a given restriction code\r\n    /// @param restrictionCode Identifier for looking up a message\r\n    /// @return Text showing the restriction's reasoning\r\n    function messageForTransferRestriction(uint8 restrictionCode)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function checkSuccess(uint8 restrictionCode) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n// File: contracts/RestrictedToken.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n/// @title Restricted Token\r\n/// @author CoMakery, Inc.\r\n/// @notice An ERC-20 token with ERC-1404 transfer restrictions for managing security tokens, etc.\r\ncontract RestrictedToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  string public symbol;\r\n  string public name;\r\n  uint8 public decimals;\r\n  ITransferRules public transferRules;\r\n\r\n  using Roles for Roles.Role;\r\n  Roles.Role private _contractAdmins;\r\n  Roles.Role private _transferAdmins;\r\n\r\n  uint256 public maxTotalSupply;\r\n  uint256 public contractAdminCount;\r\n\r\n  // Transfer restriction \"eternal storage\" mappings that can be used by future TransferRules contract upgrades\r\n  // They are accessed through getter and setter methods\r\n  mapping(address => uint256) private _maxBalances;\r\n  mapping(address => uint256) private _lockUntil; // unix timestamp to lock funds until\r\n  mapping(address => uint256) private _transferGroups; // restricted groups like Reg D Accredited US, Reg CF Unaccredited US and Reg S Foreign\r\n  mapping(uint256 => mapping(uint256 => uint256)) private _allowGroupTransfers; // approve transfers between groups: from => to => TimeLockUntil\r\n  mapping(address => bool) private _frozenAddresses;\r\n\r\n  bool public isPaused = false;\r\n\r\n  uint256 public constant MAX_UINT256 = ((2 ** 255 - 1) * 2) + 1; // get max uint256 without overflow\r\n\r\n  event RoleChange(address indexed grantor, address indexed grantee, string role, bool indexed status);\r\n  event AddressMaxBalance(address indexed admin, address indexed addr, uint256 indexed value);\r\n  event AddressTimeLock(address indexed admin, address indexed addr, uint256 indexed value);\r\n  event AddressTransferGroup(address indexed admin, address indexed addr, uint256 indexed value);\r\n  event AddressFrozen(address indexed admin, address indexed addr, bool indexed status);\r\n  event AllowGroupTransfer(address indexed admin, uint256 indexed fromGroup, uint256 indexed toGroup, uint256 lockedUntil);\r\n\r\n  event Pause(address admin, bool status);\r\n  event Upgrade(address admin, address oldRules, address newRules);\r\n\r\n  constructor(\r\n    address transferRules_,\r\n    address contractAdmin_,\r\n    address tokenReserveAdmin_,\r\n    string memory symbol_,\r\n    string memory name_,\r\n    uint8 decimals_,\r\n    uint256 totalSupply_,\r\n    uint256 maxTotalSupply_\r\n  ) public {\r\n    require(transferRules_ != address(0), \"Transfer rules address cannot be 0x0\");\r\n    require(contractAdmin_ != address(0), \"Token owner address cannot be 0x0\");\r\n    require(tokenReserveAdmin_ != address(0), \"Token reserve admin address cannot be 0x0\");\r\n\r\n    // Transfer rules can be swapped out for a new contract inheriting from the ITransferRules interface\r\n    // The \"eternal storage\" for rule data stays in this RestrictedToken contract for use by TransferRules contract upgrades\r\n    transferRules = ITransferRules(transferRules_);\r\n    symbol = symbol_;\r\n    name = name_;\r\n    decimals = decimals_;\r\n    maxTotalSupply = maxTotalSupply_;\r\n\r\n    _contractAdmins.add(contractAdmin_);\r\n    contractAdminCount = 1;\r\n\r\n    _mint(tokenReserveAdmin_, totalSupply_);\r\n  }\r\n\r\n  modifier onlyContractAdmin() {\r\n    require(_contractAdmins.has(msg.sender), \"DOES NOT HAVE CONTRACT OWNER ROLE\");\r\n    _;\r\n  }\r\n\r\n   modifier onlyTransferAdmin() {\r\n    require(_transferAdmins.has(msg.sender), \"DOES NOT HAVE TRANSFER ADMIN ROLE\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyTransferAdminOrContractAdmin() {\r\n    require((_contractAdmins.has(msg.sender) || _transferAdmins.has(msg.sender)),\r\n    \"DOES NOT HAVE TRANSFER ADMIN OR CONTRACT ADMIN ROLE\");\r\n    _;\r\n  }\r\n\r\n  modifier validAddress(address addr) {\r\n    require(addr != address(0), \"Address cannot be 0x0\");\r\n    _;\r\n  }\r\n\r\n  /// @dev Authorizes an address holder to write transfer restriction rules\r\n  /// @param addr The address to grant transfer admin rights to\r\n  function grantTransferAdmin(address addr) external validAddress(addr) onlyContractAdmin {\r\n    _transferAdmins.add(addr);\r\n    emit RoleChange(msg.sender, addr, \"TransferAdmin\", true);\r\n  }\r\n\r\n  /// @dev Revokes authorization to write transfer restriction rules\r\n  /// @param addr The address to grant transfer admin rights to\r\n  function revokeTransferAdmin(address addr) external validAddress(addr) onlyContractAdmin  {\r\n    _transferAdmins.remove(addr);\r\n    emit RoleChange(msg.sender, addr, \"TransferAdmin\", false);\r\n  }\r\n\r\n  /// @dev Checks if an address is an authorized transfer admin.\r\n  /// @param addr The address to check for transfer admin privileges.\r\n  /// @return hasPermission returns true if the address has transfer admin permission and false if not.\r\n  function checkTransferAdmin(address addr) external view returns(bool hasPermission) {\r\n    return _transferAdmins.has(addr);\r\n  }\r\n\r\n  /// @dev Authorizes an address holder to be a contract admin. Contract admins grant privileges to accounts.\r\n  /// Contract admins can mint/burn tokens and freeze accounts.\r\n  /// @param addr The address to grant transfer admin rights to.\r\n  function grantContractAdmin(address addr) external validAddress(addr) onlyContractAdmin {\r\n    _contractAdmins.add(addr);\r\n    contractAdminCount = contractAdminCount.add(1);\r\n    emit RoleChange(msg.sender, addr, \"ContractAdmin\", true);\r\n  }\r\n\r\n  /// @dev Revokes authorization as a contract admin.\r\n  /// The contract requires there is at least 1 Contract Admin to avoid locking the Contract Admin functionality.\r\n  /// @param addr The address to remove contract admin rights from\r\n  function revokeContractAdmin(address addr) external validAddress(addr) onlyContractAdmin {\r\n    require(contractAdminCount > 1, \"Must have at least one contract admin\");\r\n    _contractAdmins.remove(addr);\r\n    contractAdminCount = contractAdminCount.sub(1);\r\n    emit RoleChange(msg.sender, addr, \"ContractAdmin\", false);\r\n  }\r\n\r\n  /// @dev Checks if an address is an authorized contract admin.\r\n  /// @param addr The address to check for contract admin privileges.\r\n  /// @return hasPermission returns true if the address has contract admin permission and false if not.\r\n  function checkContractAdmin(address addr) external view returns(bool hasPermission) {\r\n    return _contractAdmins.has(addr);\r\n  }\r\n\r\n  /// @dev Enforces transfer restrictions managed using the ERC-1404 standard functions.\r\n  /// The TransferRules contract defines what the rules are. The data inputs to those rules remains in the RestrictedToken contract.\r\n  /// TransferRules is a separate contract so its logic can be upgraded.\r\n  /// @param from The address the tokens are transferred from\r\n  /// @param to The address the tokens would be transferred to\r\n  /// @param value the quantity of tokens to be transferred\r\n  function enforceTransferRestrictions(address from, address to, uint256 value) private view {\r\n    uint8 restrictionCode = detectTransferRestriction(from, to, value);\r\n    require(transferRules.checkSuccess(restrictionCode), messageForTransferRestriction(restrictionCode));\r\n  }\r\n\r\n  /// @dev Calls the TransferRules detectTransferRetriction function to determine if tokens can be transferred.\r\n  /// detectTransferRestriction returns a status code.\r\n  /// @param from The address the tokens are transferred from\r\n  /// @param to The address the tokens would be transferred to\r\n  /// @param value The quantity of tokens to be transferred\r\n  function detectTransferRestriction(address from, address to, uint256 value) public view returns(uint8) {\r\n    return transferRules.detectTransferRestriction(address(this), from, to, value);\r\n  }\r\n\r\n  /// @dev Calls TransferRules to lookup a human readable error message that goes with an error code.\r\n  /// @param restrictionCode is an error code to lookup an error code for\r\n  function messageForTransferRestriction(uint8 restrictionCode) public view returns(string memory) {\r\n    return transferRules.messageForTransferRestriction(restrictionCode);\r\n  }\r\n\r\n  /// @dev Sets the maximum number of tokens an address will be allowed to hold.\r\n  /// Addresses can hold 0 tokens by default.\r\n  /// @param addr The address to restrict\r\n  /// @param updatedValue the maximum number of tokens the address can hold\r\n  function setMaxBalance(address addr, uint256 updatedValue) public validAddress(addr) onlyTransferAdmin {\r\n    _maxBalances[addr] = updatedValue;\r\n    emit AddressMaxBalance(msg.sender, addr, updatedValue);\r\n  }\r\n\r\n  /// @dev Gets the maximum number of tokens an address is allowed to hold\r\n  /// @param addr The address to check restrictions for\r\n  function getMaxBalance(address addr) external view returns(uint256) {\r\n    return _maxBalances[addr];\r\n  }\r\n\r\n  /// @dev Lock tokens in the address from being transfered until the specified time\r\n  /// @param addr The address to restrict\r\n  /// @param timestamp The time the tokens will be locked until as a Unix timetsamp.\r\n  /// Unix timestamp is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function setLockUntil(address addr, uint256 timestamp) public validAddress(addr)  onlyTransferAdmin {\r\n    _lockUntil[addr] = timestamp;\r\n    emit AddressTimeLock(msg.sender, addr, timestamp);\r\n  }\r\n  /// @dev A convenience method to remove an addresses timelock. It sets the lock date to 0 which corresponds to the\r\n  /// earliest possible timestamp in the past 00:00:00 UTC on 1 January 1970.\r\n  /// @param addr The address to remove the timelock for.\r\n  function removeLockUntil(address addr) external validAddress(addr) onlyTransferAdmin {\r\n    _lockUntil[addr] = 0;\r\n    emit AddressTimeLock(msg.sender, addr, 0);\r\n  }\r\n\r\n  /// @dev Check when the address will be locked for transfers until\r\n  /// @param addr The address to check\r\n  /// @return timestamp The time the address will be locked until.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function getLockUntil(address addr) external view returns(uint256 timestamp) {\r\n    return _lockUntil[addr];\r\n  }\r\n\r\n  /// @dev Set the one group that the address belongs to, such as a US Reg CF investor group.\r\n  /// @param addr The address to set the group for.\r\n  /// @param groupID The uint256 numeric ID of the group.\r\n  function setTransferGroup(address addr, uint256 groupID) public validAddress(addr) onlyTransferAdmin {\r\n    _transferGroups[addr] = groupID;\r\n    emit AddressTransferGroup(msg.sender, addr, groupID);\r\n  }\r\n\r\n  /// @dev Gets the transfer group the address belongs to. The default group is 0.\r\n  /// @param addr The address to check.\r\n  /// @return groupID The group id of the address.\r\n  function getTransferGroup(address addr) external view returns(uint256 groupID) {\r\n    return _transferGroups[addr];\r\n  }\r\n\r\n  /// @dev Freezes or unfreezes an address.\r\n  /// Tokens in a frozen address cannot be transferred from until the address is unfrozen.\r\n  /// @param addr The address to be frozen.\r\n  /// @param status The frozenAddress status of the address. True means frozen false means not frozen.\r\n  function freeze(address addr, bool status) public validAddress(addr)  onlyTransferAdminOrContractAdmin {\r\n    _frozenAddresses[addr] = status;\r\n    emit AddressFrozen(msg.sender, addr, status);\r\n  }\r\n\r\n  /// @dev Checks the status of an address to see if its frozen\r\n  /// @param addr The address to check\r\n  /// @return status Returns true if the address is frozen and false if its not frozen.\r\n  function getFrozenStatus(address addr) external view returns(bool status) {\r\n    return _frozenAddresses[addr];\r\n  }\r\n\r\n  /// @dev A convenience method for updating the transfer group, lock until, max balance, and freeze status.\r\n  /// The convenience method also helps to reduce gas costs.\r\n  /// @param addr The address to set permissions for.\r\n  /// @param groupID The ID of the address\r\n  /// @param timeLockUntil The unix timestamp that the address should be locked until. Use 0 if it's not locked.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  /// @param maxBalance Is the maximum number of tokens the account can hold.\r\n  /// @param status The frozenAddress status of the address. True means frozen false means not frozen.\r\n  function setAddressPermissions(address addr, uint256 groupID, uint256 timeLockUntil,\r\n    uint256 maxBalance, bool status) public validAddress(addr) onlyTransferAdmin {\r\n    setTransferGroup(addr, groupID);\r\n    setLockUntil(addr, timeLockUntil);\r\n    setMaxBalance(addr, maxBalance);\r\n    freeze(addr, status);\r\n  }\r\n\r\n  /// @dev Sets an allowed transfer from a group to another group beginning at a specific time.\r\n  /// There is only one definitive rule per from and to group.\r\n  /// @param from The group the transfer is coming from.\r\n  /// @param to The group the transfer is going to.\r\n  /// @param lockedUntil The unix timestamp that the transfer is locked until. 0 is a special number. 0 means the transfer is not allowed.\r\n  /// This is because in the smart contract mapping all pairs are implicitly defined with a default lockedUntil value of 0.\r\n  /// But no transfers should be authorized until explicitly allowed. Thus 0 must mean no transfer is allowed.\r\n  function setAllowGroupTransfer(uint256 from, uint256 to, uint256 lockedUntil) external onlyTransferAdmin {\r\n    _allowGroupTransfers[from][to] = lockedUntil;\r\n    emit AllowGroupTransfer(msg.sender, from, to, lockedUntil);\r\n  }\r\n\r\n  /// @dev Checks to see when a transfer between two addresses would be allowed.\r\n  /// @param from The address the transfer is coming from\r\n  /// @param to The address the transfer is going to\r\n  /// @return timestamp The Unix timestamp of the time the transfer would be allowed. A 0 means never.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function getAllowTransferTime(address from, address to) external view returns(uint timestamp) {\r\n    return _allowGroupTransfers[_transferGroups[from]][_transferGroups[to]];\r\n  }\r\n\r\n  /// @dev Checks to see when a transfer between two groups would be allowed.\r\n  /// @param from The group id the transfer is coming from\r\n  /// @param to The group id the transfer is going to\r\n  /// @return timestamp The Unix timestamp of the time the transfer would be allowed. A 0 means never.\r\n  /// The format is the number of seconds since the Unix epoch of 00:00:00 UTC on 1 January 1970.\r\n  function getAllowGroupTransferTime(uint from, uint to) external view returns(uint timestamp) {\r\n    return _allowGroupTransfers[from][to];\r\n  }\r\n\r\n  /// @dev Destroys tokens and removes them from the total supply. Can only be called by an address with a Contract Admin role.\r\n  /// @param from The address to destroy the tokens from.\r\n  /// @param value The number of tokens to destroy from the address.\r\n  function burn(address from, uint256 value) external validAddress(from) onlyContractAdmin {\r\n    require(value <= balanceOf(from), \"Insufficent tokens to burn\");\r\n    _burn(from, value);\r\n  }\r\n\r\n  /// @dev Allows the contract admin to create new tokens in a specified address.\r\n  /// The total number of tokens cannot exceed the maxTotalSupply (the \"Hard Cap\").\r\n  /// @param to The addres to mint tokens into.\r\n  /// @param value The number of tokens to mint.\r\n  function mint(address to, uint256 value) external validAddress(to) onlyContractAdmin  {\r\n    require(SafeMath.add(totalSupply(), value) <= maxTotalSupply, \"Cannot mint more than the max total supply\");\r\n    _mint(to, value);\r\n  }\r\n\r\n  /// @dev Allows the contract admin to pause transfers.\r\n  function pause() external onlyContractAdmin() {\r\n    isPaused = true;\r\n    emit Pause(msg.sender, true);\r\n  }\r\n\r\n  /// @dev Allows the contract admin to unpause transfers.\r\n  function unpause() external onlyContractAdmin() {\r\n    isPaused = false;\r\n    emit Pause(msg.sender, false);\r\n  }\r\n\r\n  /// @dev Allows the contrac admin to upgrade the transfer rules.\r\n  /// The upgraded transfer rules must implement the ITransferRules interface which conforms to the ERC-1404 token standard.\r\n  /// @param newTransferRules The address of the deployed TransferRules contract.\r\n  function upgradeTransferRules(ITransferRules newTransferRules) external onlyContractAdmin {\r\n    require(address(newTransferRules) != address(0x0), \"Address cannot be 0x0\");\r\n    address oldRules = address(transferRules);\r\n    transferRules = newTransferRules;\r\n    emit Upgrade(msg.sender, oldRules, address(newTransferRules));\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public validAddress(to) returns(bool success) {\r\n    require(value <= balanceOf(msg.sender), \"Insufficent tokens\");\r\n    enforceTransferRestrictions(msg.sender, to, value);\r\n    super.transfer(to, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public validAddress(from) validAddress(to) returns(bool success) {\r\n    require(value <= allowance(from, to), \"The approved allowance is lower than the transfer amount\");\r\n    require(value <= balanceOf(from), \"Insufficent tokens\");\r\n    enforceTransferRestrictions(from, to, value);\r\n    super.transferFrom(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function safeApprove(address spender, uint256 value) public {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (allowance(address(msg.sender), spender) == 0),\r\n        \"Cannot approve from non-zero to non-zero allowance\"\r\n    );\r\n    approve(spender, value);\r\n  }\r\n}\r\n\r\n// File: contracts/TransferRules.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\ncontract TransferRules is ITransferRules {\r\n    using SafeMath for uint256;\r\n    mapping(uint8 => string) internal errorMessage;\r\n\r\n    uint8 public constant SUCCESS = 0;\r\n    uint8 public constant GREATER_THAN_RECIPIENT_MAX_BALANCE = 1;\r\n    uint8 public constant SENDER_TOKENS_TIME_LOCKED = 2;\r\n    uint8 public constant DO_NOT_SEND_TO_TOKEN_CONTRACT = 3;\r\n    uint8 public constant DO_NOT_SEND_TO_EMPTY_ADDRESS = 4;\r\n    uint8 public constant SENDER_ADDRESS_FROZEN = 5;\r\n    uint8 public constant ALL_TRANSFERS_PAUSED = 6;\r\n    uint8 public constant TRANSFER_GROUP_NOT_APPROVED = 7;\r\n    uint8 public constant TRANSFER_GROUP_NOT_ALLOWED_UNTIL_LATER = 8;\r\n\r\n  constructor() public {\r\n    errorMessage[SUCCESS] = \"SUCCESS\";\r\n    errorMessage[GREATER_THAN_RECIPIENT_MAX_BALANCE] = \"GREATER THAN RECIPIENT MAX BALANCE\";\r\n    errorMessage[SENDER_TOKENS_TIME_LOCKED] = \"SENDER TOKENS LOCKED\";\r\n    errorMessage[DO_NOT_SEND_TO_TOKEN_CONTRACT] = \"DO NOT SEND TO TOKEN CONTRACT\";\r\n    errorMessage[DO_NOT_SEND_TO_EMPTY_ADDRESS] = \"DO NOT SEND TO EMPTY ADDRESS\";\r\n    errorMessage[SENDER_ADDRESS_FROZEN] = \"SENDER ADDRESS IS FROZEN\";\r\n    errorMessage[ALL_TRANSFERS_PAUSED] = \"ALL TRANSFERS PAUSED\";\r\n    errorMessage[TRANSFER_GROUP_NOT_APPROVED] = \"TRANSFER GROUP NOT APPROVED\";\r\n    errorMessage[TRANSFER_GROUP_NOT_ALLOWED_UNTIL_LATER] = \"TRANSFER GROUP NOT ALLOWED UNTIL LATER\";\r\n  }\r\n\r\n  /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n  /// @param from Sending address\r\n  /// @param to Receiving address\r\n  /// @param value Amount of tokens being transferred\r\n  /// @return Code by which to reference message for rejection reason\r\n  function detectTransferRestriction(address _token, address from, address to, uint256 value) external view returns(uint8) {\r\n    RestrictedToken token = RestrictedToken(_token);\r\n    if (token.isPaused()) return ALL_TRANSFERS_PAUSED;\r\n    if (to == address(0)) return DO_NOT_SEND_TO_EMPTY_ADDRESS;\r\n    if (to == address(token)) return DO_NOT_SEND_TO_TOKEN_CONTRACT;\r\n\r\n    if (token.balanceOf(to).add(value) > token.getMaxBalance(to)) return GREATER_THAN_RECIPIENT_MAX_BALANCE;\r\n    if (now < token.getLockUntil(from)) return SENDER_TOKENS_TIME_LOCKED;\r\n    if (token.getFrozenStatus(from)) return SENDER_ADDRESS_FROZEN;\r\n\r\n    uint256 lockedUntil = token.getAllowTransferTime(from, to);\r\n    if (0 == lockedUntil) return TRANSFER_GROUP_NOT_APPROVED;\r\n    if (now < lockedUntil) return TRANSFER_GROUP_NOT_ALLOWED_UNTIL_LATER;\r\n\r\n    return SUCCESS;\r\n  }\r\n\r\n  /// @notice Returns a human-readable message for a given restriction code\r\n  /// @param restrictionCode Identifier for looking up a message\r\n  /// @return Text showing the restriction's reasoning\r\n  function messageForTransferRestriction(uint8 restrictionCode) external view returns(string memory) {\r\n    return errorMessage[restrictionCode];\r\n  }\r\n\r\n  /// @notice a method for checking a response code to determine if a transfer was succesful.\r\n  /// Defining this separately from the token contract allows it to be upgraded.\r\n  /// For instance this method would need to be upgraded if the SUCCESS code was changed to 1\r\n  /// as specified in ERC-1066 instead of 0 as specified in ERC-1404.\r\n  /// @param restrictionCode The code to check.\r\n  /// @return isSuccess A boolean indicating if the code is the SUCCESS code.\r\n  function checkSuccess(uint8 restrictionCode) external view returns(bool isSuccess) {\r\n    return restrictionCode == SUCCESS;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferRules_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAdmin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenReserveAdmin_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalSupply_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"AddressFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddressMaxBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddressTimeLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddressTransferGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromGroup\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toGroup\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"AllowGroupTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"grantor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"grantee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RoleChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRules\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRules\",\"type\":\"address\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkContractAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasPermission\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkTransferAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasPermission\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractAdminCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"detectTransferRestriction\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"getAllowGroupTransferTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getAllowTransferTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getFrozenStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getLockUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getMaxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getTransferGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"groupID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"grantContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"grantTransferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"restrictionCode\",\"type\":\"uint8\"}],\"name\":\"messageForTransferRestriction\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeLockUntil\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revokeContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"revokeTransferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"groupID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLockUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAddressPermissions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"setAllowGroupTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setLockUntil\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"updatedValue\",\"type\":\"uint256\"}],\"name\":\"setMaxBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"groupID\",\"type\":\"uint256\"}],\"name\":\"setTransferGroup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferRules\",\"outputs\":[{\"internalType\":\"contract ITransferRules\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ITransferRules\",\"name\":\"newTransferRules\",\"type\":\"address\"}],\"name\":\"upgradeTransferRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RestrictedToken","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005b097a5f2d5579912494dbbeef8c0c1c8e1fe170000000000000000000000000fb87c53b7770b451a5f193fe9e954d87d2872855000000000000000000000000a153dd6e4725c94066a7aa3425a3a737cfaf7c1200000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000052b7d2dcc80cd2e400000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000758595a546573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000155265737472696374656420546f6b656e20546573740000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://ccfbc6e4dd4827747e21570ea618016582b01d4b9bb253a408ff0135733064a9"}]}