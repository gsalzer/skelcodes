{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/ERC20.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract ERC20\r\n{\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint    value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/BurnableERC20.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title Burnable ERC20 Token Interface\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract BurnableERC20 is ERC20\r\n{\r\n    function burn(\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function burnFrom(\r\n        address from,\r\n        uint value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/ERC20SafeTransfer.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title ERC20 safe transfer\r\n/// @dev see https://github.com/sec-bit/badERC20Fix\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ERC20SafeTransfer\r\n{\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return safeTransferWithGasLimit(\r\n            token,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferWithGasLimit(\r\n        address token,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // A transfer is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transfer(address,uint)\")) = 0xa9059cbb\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0xa9059cbb),\r\n            to,\r\n            value\r\n        );\r\n        (bool success, ) = token.call.gas(gasLimit)(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return safeTransferFromWithGasLimit(\r\n            token,\r\n            from,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferFromWithGasLimit(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // A transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transferFrom(address,address,uint)\")) = 0x23b872dd\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0x23b872dd),\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n        (bool success, ) = token.call.gas(gasLimit)(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function checkReturnValue(\r\n        bool success\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n        if (success) {\r\n            assembly {\r\n                switch returndatasize()\r\n                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\r\n                case 0 {\r\n                    success := 1\r\n                }\r\n                // Standard ERC20: a single boolean value is returned which needs to be true\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n                // None of the above: not successful\r\n                default {\r\n                    success := 0\r\n                }\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/lib/MathUint.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n\r\n    function decodeFloat(\r\n        uint f\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint value)\r\n    {\r\n        uint numBitsMantissa = 23;\r\n        uint exponent = f >> numBitsMantissa;\r\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\r\n        value = mantissa * (10 ** exponent);\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IBlockVerifier.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title IBlockVerifier\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract IBlockVerifier\r\n{\r\n    // -- Events --\r\n\r\n    event CircuitRegistered(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    event CircuitDisabled(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    // -- Public functions --\r\n\r\n    /// @dev Sets the verifying key for the specified circuit.\r\n    ///      Every block permutation needs its own circuit and thus its own set of\r\n    ///      verification keys. Only a limited number of block sizes per block\r\n    ///      type are supported.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param vk The verification key\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        bool     onchainDataAvailability,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external;\r\n\r\n    /// @dev Disables the use of the specified circuit.\r\n    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\r\n    ///      can still be verified.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external;\r\n\r\n    /// @dev Verify blocks with the given public data and proofs.\r\n    ///      Verifying a block makes sure all requests handled in the block\r\n    ///      are correctly handled by the operator.\r\n    /// @param blockType The type of block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param publicInputs The hash of all the public data of the blocks\r\n    /// @param proofs The ZK proofs proving that the blocks are correct\r\n    /// @return True if the block is valid, false otherwise\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit with the specified parameters is registered.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is registered, false otherwise\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit can still be used to commit new blocks.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is enabled, false otherwise\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/Ownable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Claimable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n// File: contracts/iface/ILoopring.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ILoopring\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopring is Claimable, ReentrancyGuard\r\n{\r\n    address public protocolRegistry;\r\n    address public lrcAddress;\r\n    uint    public exchangeCreationCostLRC;\r\n\r\n    event ExchangeInitialized(\r\n        uint    indexed exchangeId,\r\n        address indexed exchangeAddress,\r\n        address indexed owner,\r\n        address         operator,\r\n        bool            onchainDataAvailability\r\n    );\r\n\r\n    /// @dev Initialize and register an exchange.\r\n    ///      This function should only be callabled by the protocolRegistry contract.\r\n    ///      Also note that this function can only be called once per exchange instance.\r\n    /// @param  exchangeAddress The address of the exchange to initialize and register.\r\n    /// @param  exchangeId The unique exchange id.\r\n    /// @param  owner The owner of the exchange.\r\n    /// @param  operator The operator of the exchange.\r\n    /// @param  onchainDataAvailability True if \"Data Availability\" is turned on for this\r\n    ///         exchange. Note that this value can not be changed once the exchange is initialized.\r\n    /// @return exchangeId The id of the exchange.\r\n    function initializeExchange(\r\n        address exchangeAddress,\r\n        uint    exchangeId,\r\n        address owner,\r\n        address payable operator,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/iface/ILoopringV3.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/// @title ILoopringV3\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopringV3 is ILoopring\r\n{\r\n    // == Events ==\r\n\r\n    event ExchangeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeBurned(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event SettingsUpdated(\r\n        uint            time\r\n    );\r\n\r\n    // == Public Variables ==\r\n    struct Exchange\r\n    {\r\n        address exchangeAddress;\r\n        uint    exchangeStake;\r\n        uint    protocolFeeStake;\r\n    }\r\n\r\n    mapping (uint => Exchange) internal exchanges;\r\n\r\n    uint    public totalStake;\r\n\r\n    address public wethAddress;\r\n    address public exchangeDeployerAddress;\r\n    address public blockVerifierAddress;\r\n    address public downtimeCostCalculator;\r\n    uint    public maxWithdrawalFee;\r\n    uint    public withdrawalFineLRC;\r\n    uint    public tokenRegistrationFeeLRCBase;\r\n    uint    public tokenRegistrationFeeLRCDelta;\r\n    uint    public minExchangeStakeWithDataAvailability;\r\n    uint    public minExchangeStakeWithoutDataAvailability;\r\n    uint    public revertFineLRC;\r\n    uint8   public minProtocolTakerFeeBips;\r\n    uint8   public maxProtocolTakerFeeBips;\r\n    uint8   public minProtocolMakerFeeBips;\r\n    uint8   public maxProtocolMakerFeeBips;\r\n    uint    public targetProtocolTakerFeeStake;\r\n    uint    public targetProtocolMakerFeeStake;\r\n\r\n    address payable public protocolFeeVault;\r\n\r\n    // == Public Functions ==\r\n    /// @dev Update the global exchange settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateSettings(\r\n        address payable _protocolFeeVault,   // address(0) not allowed\r\n        address _blockVerifierAddress,       // address(0) not allowed\r\n        address _downtimeCostCalculator,     // address(0) allowed\r\n        uint    _exchangeCreationCostLRC,\r\n        uint    _maxWithdrawalFee,\r\n        uint    _tokenRegistrationFeeLRCBase,\r\n        uint    _tokenRegistrationFeeLRCDelta,\r\n        uint    _minExchangeStakeWithDataAvailability,\r\n        uint    _minExchangeStakeWithoutDataAvailability,\r\n        uint    _revertFineLRC,\r\n        uint    _withdrawalFineLRC\r\n        )\r\n        external;\r\n\r\n    /// @dev Update the global protocol fee settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateProtocolFeeSettings(\r\n        uint8 _minProtocolTakerFeeBips,\r\n        uint8 _maxProtocolTakerFeeBips,\r\n        uint8 _minProtocolMakerFeeBips,\r\n        uint8 _maxProtocolMakerFeeBips,\r\n        uint  _targetProtocolTakerFeeStake,\r\n        uint  _targetProtocolMakerFeeStake\r\n        )\r\n        external;\r\n\r\n    /// @dev Returns whether the Exchange has staked enough to commit blocks\r\n    ///      Exchanges with on-chain data-availaiblity need to stake at least\r\n    ///      minExchangeStakeWithDataAvailability, exchanges without\r\n    ///      data-availability need to stake at least\r\n    ///      minExchangeStakeWithoutDataAvailability.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return True if the exchange has staked enough, else false\r\n    function canExchangeCommitBlocks(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Get the amount of staked LRC for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @return stakedLRC The amount of LRC\r\n    function getExchangeStake(\r\n        uint exchangeId\r\n        )\r\n        public\r\n        view\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Burn a certain amount of staked LRC for a specific exchange.\r\n    ///      This function is meant to be called only from exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\r\n    ///         the staked amount, all staked LRC will be burned.\r\n    function burnExchangeStake(\r\n        uint exchangeId,\r\n        uint amount\r\n        )\r\n        external\r\n        returns (uint burnedLRC);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositExchangeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  requestedAmount The amount of LRC to withdraw\r\n    /// @return stakedLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    requestedAmount\r\n        )\r\n        external\r\n        returns (uint amount);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositProtocolFeeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  amount The amount of LRC to withdraw\r\n    function withdrawProtocolFeeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    amount\r\n        )\r\n        external;\r\n\r\n    /// @dev Get the protocol fee values for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    function getProtocolFeeValues(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips\r\n        );\r\n\r\n    /// @dev Returns the exchange's protocol fee stake.\r\n    /// @param  exchangeId The exchange's id.\r\n    /// @return protocolFeeStake The exchange's protocol fee stake.\r\n    function getProtocolFeeStake(\r\n        uint exchangeId\r\n        )\r\n        external\r\n        view\r\n        returns (uint protocolFeeStake);\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeData.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ExchangeData\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeData\r\n{\r\n    // -- Enums --\r\n    enum BlockType\r\n    {\r\n        RING_SETTLEMENT,\r\n        DEPOSIT,\r\n        ONCHAIN_WITHDRAWAL,\r\n        OFFCHAIN_WITHDRAWAL,\r\n        ORDER_CANCELLATION,\r\n        TRANSFER\r\n    }\r\n\r\n    enum BlockState\r\n    {\r\n        // This value should never be seen onchain, but we want to reserve 0 so the\r\n        // relayer can use this as the default for new blocks.\r\n        NEW,            // = 0\r\n\r\n        // The default state when a new block is included onchain.\r\n        COMMITTED,      // = 1\r\n\r\n        // A valid ZK proof has been submitted for this block.\r\n        // The genesis block is VERIFIED by default.\r\n        VERIFIED        // = 2\r\n    }\r\n\r\n    // -- Structs --\r\n    struct Account\r\n    {\r\n        address owner;\r\n\r\n        // pubKeyX and pubKeyY put together is the EdDSA public trading key. Users or their\r\n        // wallet software are supposed to manage the corresponding private key for signing\r\n        // orders and offchain requests.\r\n        //\r\n        // We use EdDSA because it is more circuit friendly than ECDSA. In later versions\r\n        // we may switch back to ECDSA, then we will not need such a dedicated tradig key-pair.\r\n        //\r\n        // We split the public key into two uint to make it more circuit friendly.\r\n        uint    pubKeyX;\r\n        uint    pubKeyY;\r\n    }\r\n\r\n    struct Token\r\n    {\r\n        address token;\r\n        bool    depositDisabled;\r\n    }\r\n\r\n    struct ProtocolFeeData\r\n    {\r\n        uint32 timestamp;\r\n        uint8 takerFeeBips;\r\n        uint8 makerFeeBips;\r\n        uint8 previousTakerFeeBips;\r\n        uint8 previousMakerFeeBips;\r\n    }\r\n\r\n    // This is the (virtual) block an operator needs to submit onchain to maintain the\r\n    // per-exchange (virtual) blockchain.\r\n    struct Block\r\n    {\r\n        // The merkle root of the offchain data stored in a merkle tree. The merkle tree\r\n        // stores balances for users using an account model.\r\n        bytes32 merkleRoot;\r\n\r\n        // The hash of all the public data sent in commitBlock. Committing a block\r\n        // is decoupled from the verification of a block, but we don't want to send\r\n        // the (often) large amount of data (certainly with onchain data availability) again\r\n        // when verifying the proof, so we hash all that data onchain in commitBlock so that we\r\n        // can use it in verifyBlock to verify the block. This also makes the verification cheaper\r\n        // onchain because we only have this single public input.\r\n        bytes32 publicDataHash;\r\n\r\n        // The current state of the block. See @BlockState for more information.\r\n        BlockState state;\r\n\r\n        // The type of the block (i.e. what kind of requests were processed).\r\n        // See @BlockType for more information.\r\n        BlockType blockType;\r\n\r\n        // The number of requests processed in the block. Only a limited number of permutations\r\n        // are available for each block type (because each will need a different circuit\r\n        // and thus different verification key onchain). Use IBlockVerifier.canVerify to find out if\r\n        // the block is supported.\r\n        uint16 blockSize;\r\n\r\n        // The block version (i.e. what circuit version needs to be used to verify the block).\r\n        uint8  blockVersion;\r\n\r\n        // The time the block was created.\r\n        uint32 timestamp;\r\n\r\n        // The number of onchain deposit requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numDepositRequestsCommitted;\r\n\r\n        // The number of onchain withdrawal requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numWithdrawalRequestsCommitted;\r\n\r\n        // Stores whether the fee earned by the operator for processing onchain requests\r\n        // is withdrawn or not.\r\n        bool   blockFeeWithdrawn;\r\n\r\n        // Number of withdrawals distributed using `distributeWithdrawals`\r\n        uint16 numWithdrawalsDistributed;\r\n\r\n        // The approved withdrawal data. Needs to be stored onchain so this data is available\r\n        // once the block is finalized and the funds can be withdrawn using the info stored\r\n        // in this data.\r\n        // For every withdrawal (there are 'blockSize' withdrawals),\r\n        // stored sequentially after each other:\r\n        //    - Token ID: 1 bytes\r\n        //    - Account ID: 2,5 bytes\r\n        //    - Amount: 3,5 bytes\r\n        bytes  withdrawals;\r\n    }\r\n\r\n    // Represents the post-state of an onchain deposit/withdrawal request. We can visualize\r\n    // a deposit request-chain and a withdrawal request-chain, each of which is\r\n    // composed of such Request objects. Please refer to the design doc for more details.\r\n    struct Request\r\n    {\r\n        bytes32 accumulatedHash;\r\n        uint    accumulatedFee;\r\n        uint32  timestamp;\r\n    }\r\n\r\n    // Represents an onchain deposit request.  `tokenID` being `0x0` means depositing Ether.\r\n    struct Deposit\r\n    {\r\n        uint24 accountID;\r\n        uint16 tokenID;\r\n        uint96 amount;\r\n    }\r\n\r\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\r\n        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 1 hours; }\r\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 2500; }\r\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 15 minutes; }\r\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 15 seconds; }\r\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 10 minutes; }\r\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\r\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\r\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 2 hours; }\r\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 5 minutes; }\r\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 30 minutes; }\r\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 60000; }\r\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\r\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 30000; }\r\n\r\n    // Represents the entire exchange state except the owner of the exchange.\r\n    struct State\r\n    {\r\n        uint    id;\r\n        uint    exchangeCreationTimestamp;\r\n        address payable operator; // The only address that can submit new blocks.\r\n        bool    onchainDataAvailability;\r\n\r\n        ILoopringV3    loopring;\r\n        IBlockVerifier blockVerifier;\r\n\r\n        address lrcAddress;\r\n\r\n        uint    totalTimeInMaintenanceSeconds;\r\n        uint    numDowntimeMinutes;\r\n        uint    downtimeStart;\r\n\r\n        address addressWhitelist;\r\n        uint    accountCreationFeeETH;\r\n        uint    accountUpdateFeeETH;\r\n        uint    depositFeeETH;\r\n        uint    withdrawalFeeETH;\r\n\r\n        Block[]     blocks;\r\n        Token[]     tokens;\r\n        Account[]   accounts;\r\n        Deposit[]   deposits;\r\n        Request[]   depositChain;\r\n        Request[]   withdrawalChain;\r\n\r\n        // A map from the account owner to accountID + 1\r\n        mapping (address => uint24) ownerToAccountId;\r\n        mapping (address => uint16) tokenToTokenId;\r\n\r\n        // A map from an account owner to a token to if the balance is withdrawn\r\n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\r\n\r\n        // A map from token address to their accumulated balances\r\n        mapping (address => uint) tokenBalances;\r\n\r\n        // A block's state will become FINALIZED when and only when this block is VERIFIED\r\n        // and all previous blocks in the chain have become FINALIZED.\r\n        // The genesis block is FINALIZED by default.\r\n        uint numBlocksFinalized;\r\n\r\n        // Cached data for the protocol fee\r\n        ProtocolFeeData protocolFeeData;\r\n\r\n        // Time when the exchange was shutdown\r\n        uint shutdownStartTime;\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeMode.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/// @title ExchangeMode.\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeMode\r\n{\r\n    using MathUint  for uint;\r\n\r\n    function isInWithdrawalMode(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool result)\r\n    {\r\n        result = false;\r\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\r\n\r\n        // Check if there's a deposit request that's too old\r\n        if (currentBlock.numDepositRequestsCommitted < S.depositChain.length) {\r\n            uint32 requestTimestamp = S.depositChain[currentBlock.numDepositRequestsCommitted].timestamp;\r\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\r\n        }\r\n\r\n        // Check if there's a withdrawal request that's too old\r\n        if (result == false && currentBlock.numWithdrawalRequestsCommitted < S.withdrawalChain.length) {\r\n            uint32 requestTimestamp = S.withdrawalChain[currentBlock.numWithdrawalRequestsCommitted].timestamp;\r\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\r\n        }\r\n\r\n        // Check if there's an unfinalized block that's too old\r\n        if (result == false) {\r\n            result = isAnyUnfinalizedBlockTooOld(S);\r\n        }\r\n\r\n        // Check if we're longer in a non-initial state while shutdown than allowed\r\n        if (result == false && isShutdown(S) && !isInInitialState(S)) {\r\n            // The max amount of time an exchange can be in shutdown is\r\n            // MAX_TIME_IN_SHUTDOWN_BASE + (accounts.length * MAX_TIME_IN_SHUTDOWN_DELTA)\r\n            uint maxTimeInShutdown = ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE();\r\n            maxTimeInShutdown = maxTimeInShutdown.add(S.accounts.length.mul(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()));\r\n            result = now > S.shutdownStartTime.add(maxTimeInShutdown);\r\n        }\r\n    }\r\n\r\n    function isShutdown(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        return S.shutdownStartTime > 0;\r\n    }\r\n\r\n    function isInMaintenance(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        return S.downtimeStart != 0 && getNumDowntimeMinutesLeft(S) > 0;\r\n    }\r\n\r\n    function isInInitialState(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        ExchangeData.Block storage firstBlock = S.blocks[0];\r\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\r\n        return (S.blocks.length == S.numBlocksFinalized) &&\r\n            (lastBlock.numDepositRequestsCommitted == S.depositChain.length) &&\r\n            (lastBlock.merkleRoot == firstBlock.merkleRoot);\r\n    }\r\n\r\n    function areUserRequestsEnabled(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        // User requests are possible when the exchange is not in maintenance mode,\r\n        // the exchange hasn't been shutdown, and the exchange isn't in withdrawal mode\r\n        return !isInMaintenance(S) && !isShutdown(S) && !isInWithdrawalMode(S);\r\n    }\r\n\r\n    function isAnyUnfinalizedBlockTooOld(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (S.numBlocksFinalized < S.blocks.length) {\r\n            uint32 blockTimestamp = S.blocks[S.numBlocksFinalized].timestamp;\r\n            return blockTimestamp < now.sub(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE());\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getNumDowntimeMinutesLeft(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (uint)\r\n    {\r\n        if (S.downtimeStart == 0) {\r\n            return S.numDowntimeMinutes;\r\n        } else {\r\n            // Calculate how long (in minutes) the exchange is in maintenance\r\n            uint numDowntimeMinutesUsed = now.sub(S.downtimeStart) / 60;\r\n            if (S.numDowntimeMinutes > numDowntimeMinutesUsed) {\r\n                return S.numDowntimeMinutes.sub(numDowntimeMinutesUsed);\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/impl/libexchange/ExchangeTokens.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeTokens.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeTokens\r\n{\r\n    using MathUint          for uint;\r\n    using ExchangeMode      for ExchangeData.State;\r\n\r\n    event TokenRegistered(\r\n        address indexed token,\r\n        uint16  indexed tokenId\r\n    );\r\n\r\n    function registerToken(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        external\r\n        returns (uint16 tokenID)\r\n    {\r\n        tokenID = registerToken(\r\n            S,\r\n            tokenAddress,\r\n            getLRCFeeForRegisteringOneMoreToken(S)\r\n        );\r\n    }\r\n\r\n    function getTokenAddress(\r\n        ExchangeData.State storage S,\r\n        uint16 tokenID\r\n        )\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        require(tokenID < S.tokens.length, \"INVALID_TOKEN_ID\");\r\n        return S.tokens[tokenID].token;\r\n    }\r\n\r\n    function getLRCFeeForRegisteringOneMoreToken(\r\n        ExchangeData.State storage S\r\n        )\r\n        public\r\n        view\r\n        returns (uint feeLRC)\r\n    {\r\n        return S.loopring.tokenRegistrationFeeLRCBase().add(\r\n            S.loopring.tokenRegistrationFeeLRCDelta().mul(S.tokens.length)\r\n        );\r\n    }\r\n\r\n    function registerToken(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress,\r\n        uint    amountToBurn\r\n        )\r\n        public\r\n        returns (uint16 tokenID)\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(S.tokenToTokenId[tokenAddress] == 0, \"TOKEN_ALREADY_EXIST\");\r\n        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), \"TOKEN_REGISTRY_FULL\");\r\n\r\n        if (amountToBurn > 0) {\r\n            require(BurnableERC20(S.lrcAddress).burnFrom(msg.sender, amountToBurn), \"BURN_FAILURE\");\r\n        }\r\n\r\n        ExchangeData.Token memory token = ExchangeData.Token(tokenAddress, false);\r\n        S.tokens.push(token);\r\n        tokenID = uint16(S.tokens.length - 1);\r\n        S.tokenToTokenId[tokenAddress] = tokenID + 1;\r\n\r\n        emit TokenRegistered(tokenAddress, tokenID);\r\n    }\r\n\r\n    function getTokenID(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        public\r\n        view\r\n        returns (uint16 tokenID)\r\n    {\r\n        tokenID = S.tokenToTokenId[tokenAddress];\r\n        require(tokenID != 0, \"TOKEN_NOT_FOUND\");\r\n        tokenID = tokenID - 1;\r\n    }\r\n\r\n    function disableTokenDeposit(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        external\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n\r\n        require(tokenAddress != address(0), \"ETHER_CANNOT_BE_DISABLED\");\r\n        require(tokenAddress != S.loopring.wethAddress(), \"WETH_CANNOT_BE_DISABLED\");\r\n        require(tokenAddress != S.loopring.lrcAddress(), \"LRC_CANNOT_BE_DISABLED\");\r\n\r\n        uint16 tokenID = getTokenID(S, tokenAddress);\r\n        ExchangeData.Token storage token = S.tokens[tokenID];\r\n        require(!token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_DISABLED\");\r\n        token.depositDisabled = true;\r\n    }\r\n\r\n    function enableTokenDeposit(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        external\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        uint16 tokenID = getTokenID(S, tokenAddress);\r\n        ExchangeData.Token storage token = S.tokens[tokenID];\r\n        require(token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_ENABLED\");\r\n        token.depositDisabled = false;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"}]","ContractName":"ExchangeTokens","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://65ad60d1a88001d1eb84e3c5b76a182c6190312f47651de347400af12c9c0d96"}]}