{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner || msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\ncontract Token{\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract Staking is Owned{\r\n    Token public token;\r\n    bool lock;\r\n    uint256 public stakeTokens;\r\n    uint256 private basePercent = 200;\r\n    using SafeMath for uint256;\r\n    \r\n    event stakingstarted(address staker, uint256 tokens, uint256 time);\r\n    event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);\r\n    \r\n    struct stake{\r\n        uint256 time;\r\n        bool redeem;\r\n        uint256 tokens;\r\n    }\r\n    mapping(address => stake) staker;\r\n    \r\n    \r\n    constructor(address tokenContractAddress) public{\r\n        token = Token(tokenContractAddress);\r\n        owner = msg.sender;\r\n        stakeTokens = 500 * 10 ** uint(10);\r\n    }\r\n    \r\n    function startStaking() public{\r\n        require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));\r\n        require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));\r\n        staker[msg.sender].time = now;\r\n        staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;\r\n        emit stakingstarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);\r\n    }\r\n    \r\n    function redeem() public{\r\n        require(!lock);\r\n        require(!staker[msg.sender].redeem);\r\n        require(staker[msg.sender].time + 3 weeks <= now);\r\n        require(token.transfer(msg.sender,staker[msg.sender].tokens));\r\n        require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * 30 * 100 / 10000));\r\n        emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * 30 * 100 / 10000);\r\n        staker[msg.sender].redeem = true;\r\n        staker[msg.sender].tokens = 0;\r\n    }\r\n    \r\n    function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{\r\n        stakeTokens = _NewTokensThreshold * 10 ** uint(10);\r\n    }\r\n    \r\n    function lockWithdrawals() public onlyOwner{\r\n        lock = true;\r\n    }\r\n    \r\n    function findOnePercent(uint256 value) private view returns (uint256)  {\r\n        uint256 roundValue = value.ceil(basePercent);\r\n        uint256 onePercent = roundValue.mul(basePercent).div(10000);\r\n        return onePercent;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Owned","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://6e881ac05ff70b8c1f5baf8c4df69547ff68504cd641d05ca044c8498af02ce4"}]}