{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n// ====== Libraries\r\n\r\n/**\r\n * @dev SafeMath\r\n *\r\n * source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n * version: 2f9ae97 (2019-05-24)\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// ====== Interfaces\r\n\r\n/**\r\n* @title Contract that will work with ERC-677 tokens\r\n* see:\r\n* https://github.com/ethereum/EIPs/issues/677\r\n* https://github.com/smartcontractkit/LinkToken/blob/master/contracts/ERC677Token.sol\r\n*/\r\ncontract ERC677Receiver {\r\n    /**\r\n    * The function is added to contracts enabling them to react to receiving tokens within a single transaction.\r\n    * The from parameter is the account which just transferred amount from the token contract. data is available to pass\r\n    * additional parameters, i.e. to indicate what the intention of the transfer is if a contract allows transfers for multiple reasons.\r\n    * @param from address sending tokens\r\n    * @param amount of tokens\r\n    * @param data to send to another contract\r\n    */\r\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool success);\r\n}\r\n\r\n/**\r\n* @title Contract that will work with overloaded 'transfer' function\r\n* see: https://github.com/ethereum/EIPs/issues/223\r\n*/\r\ncontract ERC223ReceivingContract {\r\n    /**\r\n     * @dev Standard ERC223 function that will handle incoming token transfers.\r\n     * @param _from  Token sender address.\r\n     * @param _value Amount of tokens.\r\n     * @param _data  Transaction metadata.\r\n     */\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external;\r\n}\r\n\r\n// ====== Main contract\r\n\r\n/**\r\n * @title Contract that implements:\r\n * ERC20  (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)\r\n * overloaded 'transfer' function like in ERC223 https://github.com/ethereum/EIPs/issues/223\r\n * (but it's not fully ERC223 compliant)\r\n * ERC677 (https://github.com/ethereum/EIPs/issues/677)\r\n * overloaded 'approve' function (https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/)\r\n*/\r\ncontract Token {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /* --- ERC-20 variables */\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public constant decimals = 0;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*\r\n    * stored address that deployed this smart contract to blockchain\r\n    */\r\n    address public creator;\r\n\r\n    /**\r\n    * Constructor\r\n    * no args constructor make possible to create contracts with code pre-verified on etherscan.io\r\n    * (once we verify one contract, all next contracts with the same code and constructor args will be verified by etherscan)\r\n    */\r\n    constructor() public {\r\n        creator = msg.sender;\r\n    }\r\n\r\n    /*\r\n    * initializes token: set initial values for erc20 variables\r\n    * assigns all tokens ('totalSupply') to one address ('tokenOwner')\r\n    * @param _name Name of the token\r\n    * @param _symbol Symbol of the token\r\n    * @param _totalSupply Amount of tokens to create\r\n    * @param _tokenOwner Address that will initially hold all created tokens\r\n    */\r\n    function initToken(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        uint256 _totalSupply,\r\n        address tokenOwner\r\n    ) external {\r\n\r\n        require(msg.sender == creator, \"Only creator can initialize token contract\");\r\n        require(totalSupply == 0, \"This token contract already initialized\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _totalSupply;\r\n        balanceOf[tokenOwner] = totalSupply;\r\n\r\n        emit Transfer(address(0), tokenOwner, totalSupply);\r\n\r\n    }\r\n\r\n    /* --- ERC-20 events */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n\r\n    /* --- Events for interaction with other smart contracts */\r\n\r\n    /**\r\n    * @param _from Address that sent transaction\r\n    * @param _toContract Receiver (smart contract)\r\n    * @param _extraData Data sent\r\n    */\r\n    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes indexed _extraData);\r\n\r\n    /* --- ERC-20 Functions */\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\r\n\r\n        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\r\n        // Variables of uint type cannot be negative. Thus, comparing uint variable with zero (greater than or equal) is redundant\r\n        // require(_value >= 0);\r\n\r\n        require(_to != address(0), \"_to was 0x0 address\");\r\n\r\n        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\r\n        require(msg.sender == _from || _value <= allowance[_from][msg.sender], \"Sender not authorized\");\r\n\r\n        // check if _from account have required amount\r\n        require(_value <= balanceOf[_from], \"Account doesn't have required amount\");\r\n\r\n        // Subtract from the sender\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        // Add the same to the recipient\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n\r\n        // If allowance used, change allowances correspondingly\r\n        if (_from != msg.sender) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        }\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    } // end of transferFrom\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success){\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * overloaded transfer like in ERC223 (but it's not fully ERC223 compliant)\r\n    * see: https://github.com/ethereum/EIPs/issues/223\r\n    * https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/ERC223_Token.sol\r\n    */\r\n    function transfer(address _to, uint _value, bytes calldata _data) external returns (bool success){\r\n        if (transfer(_to, _value)) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n            emit DataSentToAnotherContract(msg.sender, _to, _data);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * ERC-677\r\n    * https://github.com/ethereum/EIPs/issues/677\r\n    * transfer tokens with additional info to another smart contract, and calls its correspondent function\r\n    * @param _to Another smart contract address (receiver)\r\n    * @param _value Number of tokens to transfer\r\n    * @param _extraData Data to send to another contract\r\n    *\r\n    * This function is a recommended method to send tokens to smart contracts.\r\n    */\r\n    function transferAndCall(address _to, uint256 _value, bytes memory _extraData) public returns (bool success){\r\n        if (transferFrom(msg.sender, _to, _value)) {\r\n            ERC677Receiver receiver = ERC677Receiver(_to);\r\n            if (receiver.onTokenTransfer(msg.sender, _value, _extraData)) {\r\n                emit DataSentToAnotherContract(msg.sender, _to, _extraData);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * the same as above ('transferAndCall'), but for all tokens on user account\r\n    * for example for converting ALL tokens on user account to another tokens\r\n    */\r\n    function transferAllAndCall(address _to, bytes calldata _extraData) external returns (bool){\r\n        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /*\r\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\r\n    * there is an attack:\r\n    * https://github.com/CORIONplatform/solidity/issues/6,\r\n    * https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\r\n    * but this function is required by ERC-20:\r\n    * To prevent attack vectors like the one described on https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/\r\n    * and discussed on https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 ,\r\n    * clients SHOULD make sure to create user interfaces in such a way that they set the allowance first to 0 before\r\n    * setting it to another value for the same spender.\r\n    * THOUGH The contract itself shouldn’t enforce it, to allow backwards compatibility with contracts deployed before\r\n    *\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool success){\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Overloaded approve function\r\n    * see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _currentValue The current value of allowance for spender\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _currentValue, uint256 _value) external returns (bool success){\r\n        require(\r\n            allowance[msg.sender][_spender] == _currentValue,\r\n            \"Current value in contract is different than provided current value\"\r\n        );\r\n        return approve(_spender, _value);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"initToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"transferAllAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"DataSentToAnotherContract\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1741601807fbdac6d551f224be4a4a072621aea42f03194b47d6d3b947f64b00"}]}