{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IERC721.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\n\r\ninterface IERC721 {\r\n\r\n\r\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n  ///  may be created and assigned without emitting Transfer. At the time of\r\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n  event Transfer(address indexed _from, address indexed _to, uint indexed _tokenId);\r\n\r\n  /// @dev This emits when the approved address for an NFT is changed or\r\n  ///  reaffirmed. The zero address indicates there is no approved address.\r\n  ///  When a Transfer event emits, this also indicates that the approved\r\n  ///  address for that NFT (if any) is reset to none.\r\n  event Approval(address indexed _owner, address indexed _approved, uint indexed _tokenId);\r\n\r\n  /// @dev This emits when an operator is enabled or disabled for an owner.\r\n  ///  The operator can manage all NFTs of the owner.\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n  ///  THEY MAY BE PERMANENTLY LOST\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function transferFrom(address _from, address _to, uint _tokenId) external payable;\r\n\r\n  /// @notice Set or reaffirm the approved address for an NFT\r\n  /// @dev The zero address indicates there is no approved address.\r\n  /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n  ///  operator of the current owner.\r\n  /// @param _approved The new approved NFT controller\r\n  /// @param _tokenId The NFT to approve\r\n  function approve(address _approved, uint _tokenId) external payable;\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  ///  `onERC721Received` on `_to` and throws if the return value is not\r\n  ///  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  /// @param data Additional data with no specified format, sent in call to `_to`\r\n  function safeTransferFrom(address _from, address _to, uint _tokenId, bytes calldata data) external payable;\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev This works identically to the other function with an extra data parameter,\r\n  ///  except this function just sets data to ''\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function safeTransferFrom(address _from, address _to, uint _tokenId) external payable;\r\n\r\n  /// @notice Enable or disable approval for a third party ('operator') to manage\r\n  ///  all of `msg.sender`'s assets.\r\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n  ///  multiple operators per owner.\r\n  /// @param _operator Address to add to the set of authorized operators.\r\n  /// @param _approved True if the operator is approved, false to revoke approval\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n  /// @notice Count all NFTs assigned to an owner\r\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n  ///  function throws for queries about the zero address.\r\n  /// @param _owner An address for whom to query the balance\r\n  /// @return The number of NFTs owned by `_owner`, possibly zero\r\n  function balanceOf(address _owner) external view returns (uint);\r\n\r\n  /// @notice Find the owner of an NFT\r\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n  ///  about them do throw.\r\n  /// @param _tokenId The identifier for an NFT\r\n  /// @return The address of the owner of the NFT\r\n  function ownerOf(uint _tokenId) external view returns (address);\r\n\r\n  /// @notice Get the approved address for a single NFT\r\n  /// @dev Throws if `_tokenId` is not a valid NFT\r\n  /// @param _tokenId The NFT to find the approved address for\r\n  /// @return The approved address for this NFT, or the zero address if there is none\r\n  function getApproved(uint _tokenId) external view returns (address);\r\n\r\n  /// @notice Query if an address is an authorized operator for another address\r\n  /// @param _owner The address that owns the NFTs\r\n  /// @param _operator The address that acts on behalf of the owner\r\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string memory _name);\r\n}\r\n\r\n// File: zos-lib/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (`ERC165Checker`).\r\n *\r\n * For an implementation, see `ERC165`.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC165` interface.\r\n *\r\n * Contracts may inherit from this and call `_registerInterface` to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC165.supportsInterface`.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See `IERC165.supportsInterface`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/mixins/MixinFunds.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n/**\r\n * @title An implementation of the money related functions.\r\n * @author HardlyDifficult (unlock-protocol.com)\r\n */\r\ncontract MixinFunds\r\n{\r\n  /**\r\n   * The token-type that this Lock is priced in.  If 0, then use ETH, else this is\r\n   * a ERC20 token address.\r\n   */\r\n  address public tokenAddress;\r\n\r\n  constructor(\r\n    address _tokenAddress\r\n  ) public\r\n  {\r\n    require(\r\n      _tokenAddress == address(0) || IERC20(_tokenAddress).totalSupply() > 0,\r\n      'INVALID_TOKEN'\r\n    );\r\n    tokenAddress = _tokenAddress;\r\n  }\r\n\r\n  /**\r\n   * Gets the current balance of the account provided.\r\n   */\r\n  function getBalance(\r\n    address _account\r\n  ) public view\r\n    returns (uint)\r\n  {\r\n    if(tokenAddress == address(0)) {\r\n      return _account.balance;\r\n    } else {\r\n      return IERC20(tokenAddress).balanceOf(_account);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures that the msg.sender has paid at least the price stated.\r\n   *\r\n   * With ETH, this means the function originally called was `payable` and the\r\n   * transaction included at least the amount requested.\r\n   *\r\n   * Security: be wary of re-entrancy when calling this function.\r\n   */\r\n  function _chargeAtLeast(\r\n    uint _price\r\n  ) internal\r\n  {\r\n    if(_price > 0) {\r\n      if(tokenAddress == address(0)) {\r\n        require(msg.value >= _price, 'NOT_ENOUGH_FUNDS');\r\n      } else {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint balanceBefore = token.balanceOf(address(this));\r\n        token.transferFrom(msg.sender, address(this), _price);\r\n\r\n        // There are known bugs in popular ERC20 implements which means we cannot\r\n        // trust the return value of `transferFrom`.  This require statement ensures\r\n        // that a transfer occurred.\r\n        require(token.balanceOf(address(this)) > balanceBefore, 'TRANSFER_FAILED');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transfers funds from the contract to the account provided.\r\n   *\r\n   * Security: be wary of re-entrancy when calling this function.\r\n   */\r\n  function _transfer(\r\n    address _to,\r\n    uint _amount\r\n  ) internal\r\n  {\r\n    if(_amount > 0) {\r\n      if(tokenAddress == address(0)) {\r\n        address(uint160(_to)).transfer(_amount);\r\n      } else {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint balanceBefore = token.balanceOf(_to);\r\n        token.transfer(_to, _amount);\r\n\r\n        // There are known bugs in popular ERC20 implements which means we cannot\r\n        // trust the return value of `transferFrom`.  This require statement ensures\r\n        // that a transfer occurred.\r\n        require(token.balanceOf(_to) > balanceBefore, 'TRANSFER_FAILED');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/mixins/MixinDisableAndDestroy.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin allowing the Lock owner to disable a Lock (preventing new purchases)\r\n * and then destroy it.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinDisableAndDestroy is\r\n  IERC721,\r\n  Ownable,\r\n  MixinFunds\r\n{\r\n  // Used to disable payable functions when deprecating an old lock\r\n  bool public isAlive;\r\n\r\n  event Destroy(\r\n    uint balance,\r\n    address indexed owner\r\n  );\r\n\r\n  event Disable();\r\n\r\n  constructor(\r\n  ) internal\r\n  {\r\n    isAlive = true;\r\n  }\r\n\r\n  // Only allow usage when contract is Alive\r\n  modifier onlyIfAlive() {\r\n    require(isAlive, 'LOCK_DEPRECATED');\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Used to disable lock before migrating keys and/or destroying contract\r\n   */\r\n  function disableLock()\r\n    external\r\n    onlyOwner\r\n    onlyIfAlive\r\n  {\r\n    emit Disable();\r\n    isAlive = false;\r\n  }\r\n\r\n  /**\r\n  * @dev Used to clean up old lock contracts from the blockchain\r\n  * TODO: add a check to ensure all keys are INVALID!\r\n   */\r\n  function destroyLock()\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(isAlive == false, 'DISABLE_FIRST');\r\n\r\n    emit Destroy(address(this).balance, msg.sender);\r\n\r\n    // this will send any ETH or ERC20 held by the lock to the owner\r\n    _transfer(msg.sender, getBalance(address(this)));\r\n    selfdestruct(msg.sender);\r\n\r\n    // Note we don't clean up the `locks` data in Unlock.sol as it should not be necessary\r\n    // and leaves some data behind ('Unlock.LockBalances') which may be helpful.\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IUnlock.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n/**\r\n * @title The Unlock Interface\r\n * @author Nick Furfaro (unlock-protocol.com)\r\n**/\r\n\r\ninterface IUnlock {\r\n\r\n\r\n  // Events\r\n  event NewLock(\r\n    address indexed lockOwner,\r\n    address indexed newLockAddress\r\n  );\r\n\r\n  event NewTokenURI(\r\n    string tokenURI\r\n  );\r\n\r\n  event NewGlobalTokenSymbol(\r\n    string tokenSymbol\r\n  );\r\n\r\n  // Use initialize instead of a constructor to support proxies (for upgradeability via zos).\r\n  function initialize(address _owner) external;\r\n\r\n  /**\r\n  * @dev Create lock\r\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\r\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\r\n  */\r\n  function createLock(\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n    /**\r\n   * This function keeps track of the added GDP, as well as grants of discount tokens\r\n   * to the referrer, if applicable.\r\n   * The number of discount tokens granted is based on the value of the referal,\r\n   * the current growth rate and the lock's discount token distribution rate\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordKeyPurchase(\r\n    uint _value,\r\n    address _referrer // solhint-disable-line no-unused-vars\r\n  )\r\n    external;\r\n\r\n    /**\r\n   * This function will keep track of consumed discounts by a given user.\r\n   * It will also grant discount tokens to the creator who is granting the discount based on the\r\n   * amount of discount and compensation rate.\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordConsumedDiscount(\r\n    uint _discount,\r\n    uint _tokens // solhint-disable-line no-unused-vars\r\n  )\r\n    external;\r\n\r\n    /**\r\n   * This function returns the discount available for a user, when purchasing a\r\n   * a key from a lock.\r\n   * This does not modify the state. It returns both the discount and the number of tokens\r\n   * consumed to grant that discount.\r\n   */\r\n  function computeAvailableDiscountFor(\r\n    address _purchaser, // solhint-disable-line no-unused-vars\r\n    uint _keyPrice // solhint-disable-line no-unused-vars\r\n  )\r\n    external\r\n    view\r\n    returns (uint discount, uint tokens);\r\n\r\n  // Function to read the globalTokenURI field.\r\n  function getGlobalBaseTokenURI()\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n  /** Function to set the globalTokenURI field.\r\n   *  Should throw if called by other than owner\r\n   */\r\n  function setGlobalBaseTokenURI(\r\n    string calldata _URI\r\n  )\r\n    external;\r\n\r\n  // Function to read the globalTokenSymbol field.\r\n  function getGlobalTokenSymbol()\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n  /** Function to set the globalTokenSymbol field.\r\n   *  Should throw if called by other than owner.\r\n   */\r\n  function setGlobalTokenSymbol(\r\n    string calldata _symbol\r\n  )\r\n    external;\r\n\r\n}\r\n\r\n// File: contracts/mixins/MixinLockCore.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin for core lock data and functions.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinLockCore is\r\n  Ownable,\r\n  MixinFunds,\r\n  MixinDisableAndDestroy\r\n{\r\n  event PriceChanged(\r\n    uint oldKeyPrice,\r\n    uint keyPrice\r\n  );\r\n\r\n  event Withdrawal(\r\n    address indexed sender,\r\n    address indexed beneficiary,\r\n    uint amount\r\n  );\r\n\r\n  // Unlock Protocol address\r\n  // TODO: should we make that private/internal?\r\n  IUnlock public unlockProtocol;\r\n\r\n  // Duration in seconds for which the keys are valid, after creation\r\n  // should we take a smaller type use less gas?\r\n  // TODO: add support for a timestamp instead of duration\r\n  uint public expirationDuration;\r\n\r\n  // price in wei of the next key\r\n  // TODO: allow support for a keyPriceCalculator which could set prices dynamically\r\n  uint public keyPrice;\r\n\r\n  // Max number of keys sold if the keyReleaseMechanism is public\r\n  uint public maxNumberOfKeys;\r\n\r\n  // A count of how many new key purchases there have been\r\n  uint public numberOfKeysSold;\r\n\r\n  // The account which will receive funds on withdrawal\r\n  address public beneficiary;\r\n\r\n  // Ensure that the Lock has not sold all of its keys.\r\n  modifier notSoldOut() {\r\n    require(maxNumberOfKeys > numberOfKeysSold, 'LOCK_SOLD_OUT');\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwnerOrBeneficiary()\r\n  {\r\n    require(\r\n      msg.sender == owner() || msg.sender == beneficiary,\r\n      'ONLY_LOCK_OWNER_OR_BENEFICIARY'\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _beneficiary,\r\n    uint _expirationDuration,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys\r\n  ) internal\r\n  {\r\n    require(_expirationDuration <= 100 * 365 * 24 * 60 * 60, 'MAX_EXPIRATION_100_YEARS');\r\n    unlockProtocol = IUnlock(msg.sender); // Make sure we link back to Unlock's smart contract.\r\n    beneficiary = _beneficiary;\r\n    expirationDuration = _expirationDuration;\r\n    keyPrice = _keyPrice;\r\n    maxNumberOfKeys = _maxNumberOfKeys;\r\n  }\r\n\r\n  /**\r\n   * @dev Called by owner to withdraw all funds from the lock and send them to the `beneficiary`.\r\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\r\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\r\n   *\r\n   * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?\r\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` use case.\r\n   */\r\n  function withdraw(\r\n    uint _amount\r\n  ) external\r\n    onlyOwnerOrBeneficiary\r\n  {\r\n    uint balance = getBalance(address(this));\r\n    uint amount;\r\n    if(_amount == 0 || _amount > balance)\r\n    {\r\n      require(balance > 0, 'NOT_ENOUGH_FUNDS');\r\n      amount = balance;\r\n    }\r\n    else\r\n    {\r\n      amount = _amount;\r\n    }\r\n\r\n    emit Withdrawal(msg.sender, beneficiary, amount);\r\n    // Security: re-entrancy not a risk as this is the last line of an external function\r\n    _transfer(beneficiary, amount);\r\n  }\r\n\r\n  /**\r\n   * A function which lets the owner of the lock to change the price for future purchases.\r\n   */\r\n  function updateKeyPrice(\r\n    uint _keyPrice\r\n  )\r\n    external\r\n    onlyOwner\r\n    onlyIfAlive\r\n  {\r\n    uint oldKeyPrice = keyPrice;\r\n    keyPrice = _keyPrice;\r\n    emit PriceChanged(oldKeyPrice, keyPrice);\r\n  }\r\n\r\n  /**\r\n   * A function which lets the owner of the lock update the beneficiary account,\r\n   * which receives funds on withdrawal.\r\n   */\r\n  function updateBeneficiary(\r\n    address _beneficiary\r\n  ) external\r\n    onlyOwnerOrBeneficiary\r\n  {\r\n    require(_beneficiary != address(0), 'INVALID_ADDRESS');\r\n    beneficiary = _beneficiary;\r\n  }\r\n\r\n  /**\r\n   * Public function which returns the total number of unique keys sold (both\r\n   * expired and valid)\r\n   */\r\n  function totalSupply()\r\n    public\r\n    view\r\n    returns (uint)\r\n  {\r\n    return numberOfKeysSold;\r\n  }\r\n}\r\n\r\n// File: contracts/mixins/MixinKeys.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin for managing `Key` data.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinKeys is\r\n  Ownable,\r\n  MixinLockCore\r\n{\r\n  // The struct for a key\r\n  struct Key {\r\n    uint tokenId;\r\n    uint expirationTimestamp;\r\n  }\r\n\r\n  // Called when the Lock owner expires a user's Key\r\n  event ExpireKey(uint tokenId);\r\n\r\n  // Keys\r\n  // Each owner can have at most exactly one key\r\n  // TODO: could we use public here? (this could be confusing though because it getter will\r\n  // return 0 values when missing a key)\r\n  mapping (address => Key) private keyByOwner;\r\n\r\n  // Each tokenId can have at most exactly one owner at a time.\r\n  // Returns 0 if the token does not exist\r\n  // TODO: once we decouple tokenId from owner address (incl in js), then we can consider\r\n  // merging this with numberOfKeysSold into an array instead.\r\n  mapping (uint => address) private ownerByTokenId;\r\n\r\n  // Addresses of owners are also stored in an array.\r\n  // Addresses are never removed by design to avoid abuses around referals\r\n  address[] public owners;\r\n\r\n  // Ensures that an owner owns or has owned a key in the past\r\n  modifier ownsOrHasOwnedKey(\r\n    address _owner\r\n  ) {\r\n    require(\r\n      keyByOwner[_owner].expirationTimestamp > 0, 'HAS_NEVER_OWNED_KEY'\r\n    );\r\n    _;\r\n  }\r\n\r\n  // Ensures that an owner has a valid key\r\n  modifier hasValidKey(\r\n    address _owner\r\n  ) {\r\n    require(\r\n      getHasValidKey(_owner), 'KEY_NOT_VALID'\r\n    );\r\n    _;\r\n  }\r\n\r\n  // Ensures that a key has an owner\r\n  modifier isKey(\r\n    uint _tokenId\r\n  ) {\r\n    require(\r\n      ownerByTokenId[_tokenId] != address(0), 'NO_SUCH_KEY'\r\n    );\r\n    _;\r\n  }\r\n\r\n  // Ensure that the caller owns the key\r\n  modifier onlyKeyOwner(\r\n    uint _tokenId\r\n  ) {\r\n    require(\r\n      isKeyOwner(_tokenId, msg.sender), 'ONLY_KEY_OWNER'\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * A function which lets the owner of the lock expire a users' key.\r\n   */\r\n  function expireKeyFor(\r\n    address _owner\r\n  )\r\n    public\r\n    onlyOwner\r\n    hasValidKey(_owner)\r\n  {\r\n    Key storage key = keyByOwner[_owner];\r\n    key.expirationTimestamp = block.timestamp; // Effectively expiring the key\r\n    emit ExpireKey(key.tokenId);\r\n  }\r\n\r\n  /**\r\n   * In the specific case of a Lock, each owner can own only at most 1 key.\r\n   * @return The number of NFTs owned by `_owner`, either 0 or 1.\r\n  */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint)\r\n  {\r\n    require(_owner != address(0), 'INVALID_ADDRESS');\r\n    return getHasValidKey(_owner) ? 1 : 0;\r\n  }\r\n\r\n  /**\r\n   * Checks if the user has a non-expired key.\r\n   */\r\n  function getHasValidKey(\r\n    address _owner\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return keyByOwner[_owner].expirationTimestamp > block.timestamp;\r\n  }\r\n\r\n  /**\r\n   * @notice Find the tokenId for a given user\r\n   * @return The tokenId of the NFT, else revert\r\n  */\r\n  function getTokenIdFor(\r\n    address _account\r\n  )\r\n    external\r\n    view\r\n    hasValidKey(_account)\r\n    returns (uint)\r\n  {\r\n    return keyByOwner[_account].tokenId;\r\n  }\r\n\r\n /**\r\n  * A function which returns a subset of the keys for this Lock as an array\r\n  * @param _page the page of key owners requested when faceted by page size\r\n  * @param _pageSize the number of Key Owners requested per page\r\n  */\r\n  function getOwnersByPage(uint _page, uint _pageSize)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    require(owners.length > 0, 'NO_OUTSTANDING_KEYS');\r\n    uint pageSize = _pageSize;\r\n    uint _startIndex = _page * pageSize;\r\n    uint endOfPageIndex;\r\n\r\n    if (_startIndex + pageSize > owners.length) {\r\n      endOfPageIndex = owners.length;\r\n      pageSize = owners.length - _startIndex;\r\n    } else {\r\n      endOfPageIndex = (_startIndex + pageSize);\r\n    }\r\n\r\n    // new temp in-memory array to hold pageSize number of requested owners:\r\n    address[] memory ownersByPage = new address[](pageSize);\r\n    uint pageIndex = 0;\r\n\r\n    // Build the requested set of owners into a new temporary array:\r\n    for (uint i = _startIndex; i < endOfPageIndex; i++) {\r\n      ownersByPage[pageIndex] = owners[i];\r\n      pageIndex++;\r\n    }\r\n\r\n    return ownersByPage;\r\n  }\r\n\r\n  /**\r\n   * Checks if the given address owns the given tokenId.\r\n   */\r\n  function isKeyOwner(\r\n    uint _tokenId,\r\n    address _owner\r\n  ) public view\r\n    returns (bool)\r\n  {\r\n    return ownerByTokenId[_tokenId] == _owner;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\r\n  * @param _owner address of the user for whom we search the key\r\n  */\r\n  function keyExpirationTimestampFor(\r\n    address _owner\r\n  )\r\n    public view\r\n    ownsOrHasOwnedKey(_owner)\r\n    returns (uint timestamp)\r\n  {\r\n    return keyByOwner[_owner].expirationTimestamp;\r\n  }\r\n\r\n  /**\r\n   * Public function which returns the total number of unique owners (both expired\r\n   * and valid).  This may be larger than totalSupply.\r\n   */\r\n  function numberOfOwners()\r\n    public\r\n    view\r\n    returns (uint)\r\n  {\r\n    return owners.length;\r\n  }\r\n\r\n  /**\r\n   * @notice ERC721: Find the owner of an NFT\r\n   * @return The address of the owner of the NFT, if applicable\r\n  */\r\n  function ownerOf(\r\n    uint _tokenId\r\n  )\r\n    public view\r\n    isKey(_tokenId)\r\n    returns (address)\r\n  {\r\n    return ownerByTokenId[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * Assigns the key a new tokenId (from numberOfKeysSold) if it does not already have\r\n   * one assigned.\r\n   */\r\n  function _assignNewTokenId(\r\n    Key storage _key\r\n  ) internal\r\n  {\r\n    if (_key.tokenId == 0) {\r\n      // This is a brand new owner, else an owner of an expired key buying an extension.\r\n      // We increment the tokenId counter\r\n      numberOfKeysSold++;\r\n      // we assign the incremented `numberOfKeysSold` as the tokenId for the new key\r\n      _key.tokenId = numberOfKeysSold;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Records the owner of a given tokenId\r\n   */\r\n  function _recordOwner(\r\n    address _owner,\r\n    uint _tokenId\r\n  ) internal\r\n  {\r\n    if (ownerByTokenId[_tokenId] != _owner) {\r\n      // TODO: this may include duplicate entries\r\n      owners.push(_owner);\r\n      // We register the owner of the tokenID\r\n      ownerByTokenId[_tokenId] = _owner;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the Key struct for the given owner.\r\n   */\r\n  function _getKeyFor(\r\n    address _owner\r\n  ) internal view\r\n    returns (Key storage)\r\n  {\r\n    return keyByOwner[_owner];\r\n  }\r\n}\r\n\r\n// File: contracts/mixins/MixinApproval.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin for the Approval related functions needed to meet the ERC721\r\n * standard.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinApproval is\r\n  IERC721,\r\n  MixinDisableAndDestroy,\r\n  MixinKeys\r\n{\r\n  // Keeping track of approved transfers\r\n  // This is a mapping of addresses which have approved\r\n  // the transfer of a key to another address where their key can be transfered\r\n  // Note: the approver may actually NOT have a key... and there can only\r\n  // be a single approved beneficiary\r\n  // Note 2: for transfer, both addresses will be different\r\n  // Note 3: for sales (new keys on restricted locks), both addresses will be the same\r\n  mapping (uint => address) private approved;\r\n\r\n  // Keeping track of approved operators for a Key owner.\r\n  // Since an owner can have up to 1 Key, this is similiar to above\r\n  // but the approval does not reset when a transfer occurs.\r\n  mapping (address => mapping (address => bool)) private ownerToOperatorApproved;\r\n\r\n  // Ensure that the caller has a key\r\n  // or that the caller has been approved\r\n  // for ownership of that key\r\n  modifier onlyKeyOwnerOrApproved(\r\n    uint _tokenId\r\n  ) {\r\n    require(\r\n      isKeyOwner(_tokenId, msg.sender) ||\r\n        _isApproved(_tokenId, msg.sender) ||\r\n        isApprovedForAll(ownerOf(_tokenId), msg.sender),\r\n      'ONLY_KEY_OWNER_OR_APPROVED');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * This approves _approved to get ownership of _tokenId.\r\n   * Note: that since this is used for both purchase and transfer approvals\r\n   * the approved token may not exist.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint _tokenId\r\n  )\r\n    external\r\n    payable\r\n    onlyIfAlive\r\n    onlyKeyOwnerOrApproved(_tokenId)\r\n  {\r\n    require(msg.sender != _approved, 'APPROVE_SELF');\r\n\r\n    approved[_tokenId] = _approved;\r\n    emit Approval(ownerOf(_tokenId), _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(\r\n    address _to,\r\n    bool _approved\r\n  ) external\r\n    onlyIfAlive\r\n  {\r\n    require(_to != msg.sender, 'APPROVE_SELF');\r\n    ownerToOperatorApproved[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * external version\r\n   * Will return the approved recipient for a key, if any.\r\n   */\r\n  function getApproved(\r\n    uint _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address)\r\n  {\r\n    return _getApproved(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  ) public view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperatorApproved[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if the given user is approved to transfer the tokenId.\r\n   */\r\n  function _isApproved(\r\n    uint _tokenId,\r\n    address _user\r\n  ) internal view\r\n    returns (bool)\r\n  {\r\n    return approved[_tokenId] == _user;\r\n  }\r\n\r\n  /**\r\n   * Will return the approved recipient for a key transfer or ownership.\r\n   * Note: this does not check that a corresponding key\r\n   * actually exists.\r\n   */\r\n  function _getApproved(\r\n    uint _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    address approvedRecipient = approved[_tokenId];\r\n    require(approvedRecipient != address(0), 'NONE_APPROVED');\r\n    return approvedRecipient;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to clear current approval of a given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  ) internal\r\n  {\r\n    if (approved[_tokenId] != address(0)) {\r\n      approved[_tokenId] = address(0);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/mixins/MixinGrantKeys.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin allowing the Lock owner to grant / gift keys to users.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinGrantKeys is\r\n  IERC721,\r\n  Ownable,\r\n  MixinKeys\r\n{\r\n  /**\r\n   * Allows the Lock owner to give a user a key with no charge.\r\n   */\r\n  function grantKey(\r\n    address _recipient,\r\n    uint _expirationTimestamp\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    _grantKey(_recipient, _expirationTimestamp);\r\n  }\r\n\r\n  /**\r\n   * Allows the Lock owner to give a collection of users a key with no charge.\r\n   * All keys granted have the same expiration date.\r\n   */\r\n  function grantKeys(\r\n    address[] calldata _recipients,\r\n    uint _expirationTimestamp\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    for(uint i = 0; i < _recipients.length; i++) {\r\n      _grantKey(_recipients[i], _expirationTimestamp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Allows the Lock owner to give a collection of users a key with no charge.\r\n   * Each key may be assigned a different expiration date.\r\n   */\r\n  function grantKeys(\r\n    address[] calldata _recipients,\r\n    uint[] calldata _expirationTimestamps\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    for(uint i = 0; i < _recipients.length; i++) {\r\n      _grantKey(_recipients[i], _expirationTimestamps[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Give a key to the given user\r\n   */\r\n  function _grantKey(\r\n    address _recipient,\r\n    uint _expirationTimestamp\r\n  ) private\r\n  {\r\n    require(_recipient != address(0), 'INVALID_ADDRESS');\r\n\r\n    Key storage toKey = _getKeyFor(_recipient);\r\n    require(_expirationTimestamp > toKey.expirationTimestamp, 'ALREADY_OWNS_KEY');\r\n\r\n    _assignNewTokenId(toKey);\r\n    _recordOwner(_recipient, toKey.tokenId);\r\n    toKey.expirationTimestamp = _expirationTimestamp;\r\n\r\n    // trigger event\r\n    emit Transfer(\r\n      address(0), // This is a creation.\r\n      _recipient,\r\n      toKey.tokenId\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/UnlockUtils.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n// This contract provides some utility methods for use with the unlock protocol smart contracts.\r\n// Borrowed from:\r\n// https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol#L943\r\n\r\ncontract UnlockUtils {\r\n\r\n  function strConcat(\r\n    string memory _a,\r\n    string memory _b,\r\n    string memory _c,\r\n    string memory _d\r\n  ) public\r\n    pure\r\n    returns (string memory _concatenatedString)\r\n  {\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    string memory abcd = new string(_ba.length + _bb.length + _bc.length + _bd.length);\r\n    bytes memory babcd = bytes(abcd);\r\n    uint k = 0;\r\n    uint i = 0;\r\n    for (i = 0; i < _ba.length; i++) {\r\n      babcd[k++] = _ba[i];\r\n    }\r\n    for (i = 0; i < _bb.length; i++) {\r\n      babcd[k++] = _bb[i];\r\n    }\r\n    for (i = 0; i < _bc.length; i++) {\r\n      babcd[k++] = _bc[i];\r\n    }\r\n    for (i = 0; i < _bd.length; i++) {\r\n      babcd[k++] = _bd[i];\r\n    }\r\n    return string(babcd);\r\n  }\r\n\r\n  function uint2Str(\r\n    uint _i\r\n  ) public\r\n    pure\r\n    returns (string memory _uintAsString)\r\n  {\r\n    // make a copy of the param to avoid security/no-assign-params error\r\n    uint c = _i;\r\n    if (_i == 0) {\r\n      return '0';\r\n    }\r\n    uint j = _i;\r\n    uint len;\r\n    while (j != 0) {\r\n      len++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len - 1;\r\n    while (c != 0) {\r\n      bstr[k--] = byte(uint8(48 + c % 10));\r\n      c /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n\r\n  function address2Str(\r\n    address _addr\r\n  ) public\r\n    pure\r\n    returns(string memory)\r\n  {\r\n    bytes32 value = bytes32(uint256(_addr));\r\n    bytes memory alphabet = '0123456789abcdef';\r\n    bytes memory str = new bytes(42);\r\n    str[0] = '0';\r\n    str[1] = 'x';\r\n    for (uint i = 0; i < 20; i++) {\r\n      str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\r\n      str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n    }\r\n    return string(str);\r\n  }\r\n}\r\n\r\n// File: contracts/mixins/MixinLockMetadata.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin for metadata about the Lock.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinLockMetadata is\r\n  IERC721,\r\n  ERC165,\r\n  Ownable,\r\n  MixinLockCore,\r\n  UnlockUtils,\r\n  MixinKeys\r\n{\r\n  /// A descriptive name for a collection of NFTs in this contract.Defaults to \"Unlock-Protocol\" but is settable by lock owner\r\n  string private lockName;\r\n\r\n  /// An abbreviated name for NFTs in this contract. Defaults to \"KEY\" but is settable by lock owner\r\n  string private lockSymbol;\r\n\r\n  // the base Token URI for this Lock. If not set by lock owner, the global URI stored in Unlock is used.\r\n  string private baseTokenURI;\r\n\r\n  event NewLockSymbol(\r\n    string symbol\r\n  );\r\n\r\n  constructor(\r\n    string memory _lockName\r\n  ) internal\r\n  {\r\n    lockName = _lockName;\r\n    // registering the optional erc721 metadata interface with ERC165.sol using\r\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\r\n    _registerInterface(0x5b5e139f);\r\n  }\r\n\r\n  /**\r\n   * Allows the Lock owner to assign a descriptive name for this Lock.\r\n   */\r\n  function updateLockName(\r\n    string calldata _lockName\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    lockName = _lockName;\r\n  }\r\n\r\n  /**\r\n    * @dev Gets the token name\r\n    * @return string representing the token name\r\n    */\r\n  function name(\r\n  ) external view\r\n    returns (string memory)\r\n  {\r\n    return lockName;\r\n  }\r\n\r\n  /**\r\n   * Allows the Lock owner to assign a Symbol for this Lock.\r\n   */\r\n  function updateLockSymbol(\r\n    string calldata _lockSymbol\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    lockSymbol = _lockSymbol;\r\n    emit NewLockSymbol(_lockSymbol);\r\n  }\r\n\r\n  /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token name\r\n    */\r\n  function symbol()\r\n    external view\r\n    returns(string memory)\r\n  {\r\n    if(bytes(lockSymbol).length == 0) {\r\n      return unlockProtocol.getGlobalTokenSymbol();\r\n    } else {\r\n      return lockSymbol;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Allows the Lock owner to update the baseTokenURI for this Lock.\r\n   */\r\n  function setBaseTokenURI(\r\n    string calldata _baseTokenURI\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    baseTokenURI = _baseTokenURI;\r\n  }\r\n\r\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n   *  Metadata JSON Schema\".\r\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  ) external\r\n    view\r\n    isKey(_tokenId)\r\n    returns(string memory)\r\n  {\r\n    string memory URI;\r\n    if(bytes(baseTokenURI).length == 0) {\r\n      URI = unlockProtocol.getGlobalBaseTokenURI();\r\n    } else {\r\n      URI = baseTokenURI;\r\n    }\r\n\r\n    return UnlockUtils.strConcat(\r\n      URI,\r\n      UnlockUtils.address2Str(address(this)),\r\n      '/',\r\n      UnlockUtils.uint2Str(_tokenId)\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/mixins/MixinNoFallback.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n/**\r\n * @title Mixin for the fallback function implementation, which simply reverts.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinNoFallback\r\n{\r\n  /**\r\n   * @dev the fallback function should not be used.  This explicitly reverts\r\n   * to ensure it's never used.\r\n   */\r\n  function()\r\n    external\r\n  {\r\n    revert('NO_FALLBACK');\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/mixins/MixinPurchase.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin for the purchase-related functions.\r\n * @author HardlyDifficult\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\ncontract MixinPurchase is\r\n  MixinFunds,\r\n  MixinDisableAndDestroy,\r\n  MixinLockCore,\r\n  MixinKeys\r\n{\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n  * @dev Purchase function, public version, with no referrer.\r\n  * @param _recipient address of the recipient of the purchased key\r\n  */\r\n  function purchaseFor(\r\n    address _recipient\r\n  )\r\n    external\r\n    payable\r\n    onlyIfAlive\r\n  {\r\n    return _purchaseFor(_recipient, address(0));\r\n  }\r\n\r\n  /**\r\n  * @dev Purchase function, public version, with referrer.\r\n  * @param _recipient address of the recipient of the purchased key\r\n  * @param _referrer address of the user making the referral\r\n  */\r\n  function purchaseForFrom(\r\n    address _recipient,\r\n    address _referrer\r\n  )\r\n    external\r\n    payable\r\n    onlyIfAlive\r\n    hasValidKey(_referrer)\r\n  {\r\n    return _purchaseFor(_recipient, _referrer);\r\n  }\r\n\r\n  /**\r\n  * @dev Purchase function: this lets a user purchase a key from the lock for another user\r\n  * @param _recipient address of the recipient of the purchased key\r\n  * This will fail if\r\n  *  - the keyReleaseMechanism is private\r\n  *  - the keyReleaseMechanism is Approved and the recipient has not been previously approved\r\n  *  - the amount value is smaller than the price\r\n  *  - the recipient already owns a key\r\n  * TODO: next version of solidity will allow for message to be added to require.\r\n  */\r\n  function _purchaseFor(\r\n    address _recipient,\r\n    address _referrer\r\n  )\r\n    private\r\n    notSoldOut()\r\n  { // solhint-disable-line function-max-lines\r\n    require(_recipient != address(0), 'INVALID_ADDRESS');\r\n\r\n    // Let's get the actual price for the key from the Unlock smart contract\r\n    uint discount;\r\n    uint tokens;\r\n    uint inMemoryKeyPrice = keyPrice;\r\n    (discount, tokens) = unlockProtocol.computeAvailableDiscountFor(_recipient, inMemoryKeyPrice);\r\n    uint netPrice = inMemoryKeyPrice;\r\n    if (discount > inMemoryKeyPrice) {\r\n      netPrice = 0;\r\n    } else {\r\n      // SafeSub not required as the if statement already confirmed `inMemoryKeyPrice - discount` cannot underflow\r\n      netPrice = inMemoryKeyPrice - discount;\r\n    }\r\n\r\n    // Assign the key\r\n    Key storage toKey = _getKeyFor(_recipient);\r\n\r\n    if (toKey.tokenId == 0) {\r\n      // Assign a new tokenId (if a new owner or previously transfered)\r\n      _assignNewTokenId(toKey);\r\n      _recordOwner(_recipient, toKey.tokenId);\r\n    }\r\n\r\n    if (toKey.expirationTimestamp >= block.timestamp) {\r\n      // This is an existing owner trying to extend their key\r\n      toKey.expirationTimestamp = toKey.expirationTimestamp.add(expirationDuration);\r\n    } else {\r\n      // SafeAdd is not required here since expirationDuration is capped to a tiny value\r\n      // (relative to the size of a uint)\r\n      toKey.expirationTimestamp = block.timestamp + expirationDuration;\r\n    }\r\n\r\n    if (discount > 0) {\r\n      unlockProtocol.recordConsumedDiscount(discount, tokens);\r\n    }\r\n\r\n    unlockProtocol.recordKeyPurchase(netPrice, _referrer);\r\n\r\n    // trigger event\r\n    emit Transfer(\r\n      address(0), // This is a creation.\r\n      _recipient,\r\n      numberOfKeysSold\r\n    );\r\n\r\n    // We explicitly allow for greater amounts of ETH to allow 'donations'\r\n    // Security: last line to minimize risk of re-entrancy\r\n    _chargeAtLeast(netPrice);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\r\n     * JSON-RPC method.\r\n     *\r\n     * See `recover`.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/mixins/MixinRefunds.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MixinRefunds is\r\n  Ownable,\r\n  MixinFunds,\r\n  MixinLockCore,\r\n  MixinKeys\r\n{\r\n  using SafeMath for uint;\r\n\r\n  // CancelAndRefund will return funds based on time remaining minus this penalty.\r\n  // This is calculated as `proRatedRefund * refundPenaltyNumerator / refundPenaltyDenominator`.\r\n  uint public refundPenaltyNumerator = 1;\r\n  uint public refundPenaltyDenominator = 10;\r\n\r\n  // Stores a nonce per user to use for signed messages\r\n  mapping(address => uint) public keyOwnerToNonce;\r\n\r\n  event CancelKey(\r\n    uint indexed tokenId,\r\n    address indexed owner,\r\n    address indexed sendTo,\r\n    uint refund\r\n  );\r\n\r\n  event RefundPenaltyChanged(\r\n    uint oldRefundPenaltyNumerator,\r\n    uint oldRefundPenaltyDenominator,\r\n    uint refundPenaltyNumerator,\r\n    uint refundPenaltyDenominator\r\n  );\r\n\r\n  /**\r\n   * @dev Destroys the user's key and sends a refund based on the amount of time remaining.\r\n   */\r\n  function cancelAndRefund()\r\n    external\r\n  {\r\n    _cancelAndRefund(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a key owned by a different user and sends the funds to the msg.sender.\r\n   * @param _keyOwner this user's key will be canceled\r\n   * @param _signature getCancelAndRefundApprovalHash signed by the _keyOwner\r\n   */\r\n  function cancelAndRefundFor(\r\n    address _keyOwner,\r\n    bytes calldata _signature\r\n  ) external\r\n  {\r\n    require(\r\n      ECDSA.recover(\r\n        ECDSA.toEthSignedMessageHash(\r\n          getCancelAndRefundApprovalHash(_keyOwner, msg.sender)\r\n        ),\r\n        _signature\r\n      ) == _keyOwner, 'INVALID_SIGNATURE'\r\n    );\r\n\r\n    keyOwnerToNonce[_keyOwner]++;\r\n    _cancelAndRefund(_keyOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Increments the current nonce for the msg.sender.\r\n   * This can be used to invalidate a previously signed message.\r\n   */\r\n  function incrementNonce(\r\n  ) external\r\n  {\r\n    keyOwnerToNonce[msg.sender]++;\r\n  }\r\n\r\n  /**\r\n   * Allow the owner to change the refund penalty.\r\n   */\r\n  function updateRefundPenalty(\r\n    uint _refundPenaltyNumerator,\r\n    uint _refundPenaltyDenominator\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_refundPenaltyDenominator != 0, 'INVALID_RATE');\r\n\r\n    emit RefundPenaltyChanged(\r\n      refundPenaltyNumerator,\r\n      refundPenaltyDenominator,\r\n      _refundPenaltyNumerator,\r\n      _refundPenaltyDenominator\r\n    );\r\n    refundPenaltyNumerator = _refundPenaltyNumerator;\r\n    refundPenaltyDenominator = _refundPenaltyDenominator;\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how much of a refund a key owner would receive if they issued\r\n   * a cancelAndRefund block.timestamp.\r\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\r\n   * than what the user reads from this call.\r\n   */\r\n  function getCancelAndRefundValueFor(\r\n    address _owner\r\n  )\r\n    external view\r\n    returns (uint refund)\r\n  {\r\n    return _getCancelAndRefundValue(_owner);\r\n  }\r\n\r\n  /**\r\n   * @dev returns the hash to sign in order to allow another user to cancel on your behalf.\r\n   */\r\n  function getCancelAndRefundApprovalHash(\r\n    address _keyOwner,\r\n    address _txSender\r\n  ) public view\r\n    returns (bytes32 approvalHash)\r\n  {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        // Approval is specific to this Lock\r\n        address(this),\r\n        // Approval enables only one cancel call\r\n        keyOwnerToNonce[_keyOwner],\r\n        // Approval allows only one account to broadcast the tx\r\n        _txSender\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev cancels the key for the given keyOwner and sends the refund to the msg.sender.\r\n   */\r\n  function _cancelAndRefund(\r\n    address _keyOwner\r\n  ) internal\r\n  {\r\n    Key storage key = _getKeyFor(_keyOwner);\r\n\r\n    uint refund = _getCancelAndRefundValue(_keyOwner);\r\n\r\n    emit CancelKey(key.tokenId, _keyOwner, msg.sender, refund);\r\n    // expirationTimestamp is a proxy for hasKey, setting this to `block.timestamp` instead\r\n    // of 0 so that we can still differentiate hasKey from hasValidKey.\r\n    key.expirationTimestamp = block.timestamp;\r\n\r\n    if (refund > 0) {\r\n      // Security: doing this last to avoid re-entrancy concerns\r\n      _transfer(msg.sender, refund);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how much of a refund a key owner would receive if they issued\r\n   * a cancelAndRefund now.\r\n   * @param _owner The owner of the key check the refund value for.\r\n   */\r\n  function _getCancelAndRefundValue(\r\n    address _owner\r\n  )\r\n    private view\r\n    hasValidKey(_owner)\r\n    returns (uint refund)\r\n  {\r\n    Key storage key = _getKeyFor(_owner);\r\n    // Math: safeSub is not required since `hasValidKey` confirms timeRemaining is positive\r\n    uint timeRemaining = key.expirationTimestamp - block.timestamp;\r\n    if(timeRemaining >= expirationDuration) {\r\n      refund = keyPrice;\r\n    } else {\r\n      // Math: using safeMul in case keyPrice or timeRemaining is very large\r\n      refund = keyPrice.mul(timeRemaining) / expirationDuration;\r\n    }\r\n    uint penalty = keyPrice.mul(refundPenaltyNumerator) / refundPenaltyDenominator;\r\n    if (refund > penalty) {\r\n      // Math: safeSub is not required since the if confirms this won't underflow\r\n      refund -= penalty;\r\n    } else {\r\n      refund = 0;\r\n    }\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/mixins/MixinTransfer.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mixin for the transfer-related functions needed to meet the ERC721\r\n * standard.\r\n * @author Nick Furfaro\r\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\r\n * separates logically groupings of code to ease readability.\r\n */\r\n\r\ncontract MixinTransfer is\r\n  MixinFunds,\r\n  MixinLockCore,\r\n  MixinKeys,\r\n  MixinApproval\r\n{\r\n  using SafeMath for uint;\r\n  using Address for address;\r\n\r\n  event TransferFeeChanged(\r\n    uint oldTransferFeeNumerator,\r\n    uint oldTransferFeeDenominator,\r\n    uint transferFeeNumerator,\r\n    uint transferFeeDenominator\r\n  );\r\n\r\n  // 0x150b7a02 == bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\r\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  // The fee relative to keyPrice to charge when transfering a Key to another account\r\n  // (potentially on a 0x marketplace).\r\n  // This is calculated as `keyPrice * transferFeeNumerator / transferFeeDenominator`.\r\n  uint public transferFeeNumerator = 0;\r\n  uint public transferFeeDenominator = 100;\r\n\r\n  /**\r\n   * This is payable because at some point we want to allow the LOCK to capture a fee on 2ndary\r\n   * market transactions...\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _recipient,\r\n    uint _tokenId\r\n  )\r\n    public\r\n    payable\r\n    onlyIfAlive\r\n    hasValidKey(_from)\r\n    onlyKeyOwnerOrApproved(_tokenId)\r\n  {\r\n    require(_recipient != address(0), 'INVALID_ADDRESS');\r\n    _chargeAtLeast(getTransferFee(_from));\r\n\r\n    Key storage fromKey = _getKeyFor(_from);\r\n    Key storage toKey = _getKeyFor(_recipient);\r\n\r\n    uint previousExpiration = toKey.expirationTimestamp;\r\n\r\n    if (toKey.tokenId == 0) {\r\n      toKey.tokenId = fromKey.tokenId;\r\n      _recordOwner(_recipient, toKey.tokenId);\r\n    }\r\n\r\n    if (previousExpiration <= block.timestamp) {\r\n      // The recipient did not have a key, or had a key but it expired. The new expiration is the\r\n      // sender's key expiration\r\n      // an expired key is no longer a valid key, so the new tokenID is the sender's tokenID\r\n      toKey.expirationTimestamp = fromKey.expirationTimestamp;\r\n      toKey.tokenId = fromKey.tokenId;\r\n      _recordOwner(_recipient, _tokenId);\r\n    } else {\r\n      // The recipient has a non expired key. We just add them the corresponding remaining time\r\n      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\r\n      toKey.expirationTimestamp = fromKey\r\n        .expirationTimestamp.add(previousExpiration - block.timestamp);\r\n    }\r\n\r\n    // Effectively expiring the key for the previous owner\r\n    fromKey.expirationTimestamp = block.timestamp;\r\n\r\n    // Set the tokenID to 0 for the previous owner to avoid duplicates\r\n    fromKey.tokenId = 0;\r\n\r\n    // Clear any previous approvals\r\n    _clearApproval(_tokenId);\r\n\r\n    // trigger event\r\n    emit Transfer(\r\n      _from,\r\n      _recipient,\r\n      _tokenId\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of an NFT from one address to another address\r\n  * @dev This works identically to the other function with an extra data parameter,\r\n  *  except this function just sets data to ''\r\n  * @param _from The current owner of the NFT\r\n  * @param _to The new owner\r\n  * @param _tokenId The NFT to transfer\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint _tokenId\r\n  )\r\n    external\r\n    payable\r\n  {\r\n    safeTransferFrom(_from, _to, _tokenId, '');\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of an NFT from one address to another address.\r\n  * When transfer is complete, this functions\r\n  *  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  *  `onERC721Received` on `_to` and throws if the return value is not\r\n  *  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\r\n  * @param _from The current owner of the NFT\r\n  * @param _to The new owner\r\n  * @param _tokenId The NFT to transfer\r\n  * @param _data Additional data with no specified format, sent in call to `_to`\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint _tokenId,\r\n    bytes memory _data\r\n  )\r\n    public\r\n    payable\r\n    onlyIfAlive\r\n    onlyKeyOwnerOrApproved(_tokenId)\r\n    hasValidKey(ownerOf(_tokenId))\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');\r\n\r\n  }\r\n\r\n  /**\r\n   * Allow the Lock owner to change the transfer fee.\r\n   */\r\n  function updateTransferFee(\r\n    uint _transferFeeNumerator,\r\n    uint _transferFeeDenominator\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_transferFeeDenominator != 0, 'INVALID_RATE');\r\n    emit TransferFeeChanged(\r\n      transferFeeNumerator,\r\n      transferFeeDenominator,\r\n      _transferFeeNumerator,\r\n      _transferFeeDenominator\r\n    );\r\n    transferFeeNumerator = _transferFeeNumerator;\r\n    transferFeeDenominator = _transferFeeDenominator;\r\n  }\r\n\r\n  /**\r\n   * Determines how much of a fee a key owner would need to pay in order to\r\n   * transfer the key to another account.  This is pro-rated so the fee goes down\r\n   * overtime.\r\n   * @param _owner The owner of the key check the transfer fee for.\r\n   */\r\n  function getTransferFee(\r\n    address _owner\r\n  )\r\n    public view\r\n    hasValidKey(_owner)\r\n    returns (uint)\r\n  {\r\n    Key storage key = _getKeyFor(_owner);\r\n    // Math: safeSub is not required since `hasValidKey` confirms timeRemaining is positive\r\n    uint timeRemaining = key.expirationTimestamp - block.timestamp;\r\n    uint fee;\r\n    if(timeRemaining >= expirationDuration) {\r\n      // Max the potential impact of this fee for keys with long durations remaining\r\n      fee = keyPrice;\r\n    } else {\r\n      // Math: using safeMul in case keyPrice or timeRemaining is very large\r\n      fee = keyPrice.mul(timeRemaining) / expirationDuration;\r\n    }\r\n    return fee.mul(transferFeeNumerator) / transferFeeDenominator;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * The call is not executed if the target address is not a contract\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param to target address that will receive the tokens\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function _checkOnERC721Received(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\r\n      msg.sender, from, tokenId, _data);\r\n    return (retval == _ERC721_RECEIVED);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/PublicLock.sol\r\n\r\npragma solidity 0.5.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The Lock contract\r\n * @author Julien Genestoux (unlock-protocol.com)\r\n * Eventually: implement ERC721.\r\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\r\n * Every ERC-721 compliant contract must implement the ERC165 interface.\r\n * https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract PublicLock is\r\n  IERC721,\r\n  MixinNoFallback,\r\n  ERC165,\r\n  Ownable,\r\n  ERC721Holder,\r\n  MixinFunds,\r\n  MixinDisableAndDestroy,\r\n  MixinLockCore,\r\n  MixinKeys,\r\n  MixinLockMetadata,\r\n  MixinGrantKeys,\r\n  MixinPurchase,\r\n  MixinApproval,\r\n  MixinTransfer,\r\n  MixinRefunds\r\n{\r\n  constructor(\r\n    address _owner,\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string memory _lockName\r\n  )\r\n    public\r\n    MixinFunds(_tokenAddress)\r\n    MixinLockCore(_owner, _expirationDuration, _keyPrice, _maxNumberOfKeys)\r\n    MixinLockMetadata(_lockName)\r\n  {\r\n    // registering the interface for erc721 with ERC165.sol using\r\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\r\n    _registerInterface(0x80ac58cd);\r\n    // We must manually initialize Ownable.sol\r\n    Ownable.initialize(_owner);\r\n  }\r\n\r\n  // The version number of the current implementation on this network\r\n  function publicLockVersion(\r\n  ) external pure\r\n    returns (uint16)\r\n  {\r\n    return 4;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"updateBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundPenaltyDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundPenaltyNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockProtocol\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_page\",\"type\":\"uint256\"},{\"name\":\"_pageSize\",\"type\":\"uint256\"}],\"name\":\"getOwnersByPage\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expirationDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_keyPrice\",\"type\":\"uint256\"}],\"name\":\"updateKeyPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelAndRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseTokenURI\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refundPenaltyNumerator\",\"type\":\"uint256\"},{\"name\":\"_refundPenaltyDenominator\",\"type\":\"uint256\"}],\"name\":\"updateRefundPenalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfKeysSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferFeeNumerator\",\"type\":\"uint256\"},{\"name\":\"_transferFeeDenominator\",\"type\":\"uint256\"}],\"name\":\"updateTransferFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAlive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"},{\"name\":\"_b\",\"type\":\"string\"},{\"name\":\"_c\",\"type\":\"string\"},{\"name\":\"_d\",\"type\":\"string\"}],\"name\":\"strConcat\",\"outputs\":[{\"name\":\"_concatenatedString\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"keyOwnerToNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"uint2Str\",\"outputs\":[{\"name\":\"_uintAsString\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getCancelAndRefundValueFor\",\"outputs\":[{\"name\":\"refund\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockName\",\"type\":\"string\"}],\"name\":\"updateLockName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"address2Str\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incrementNonce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getHasValidKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"purchaseForFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberOfKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockSymbol\",\"type\":\"string\"}],\"name\":\"updateLockSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_expirationTimestamps\",\"type\":\"uint256[]\"}],\"name\":\"grantKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTransferFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keyOwner\",\"type\":\"address\"},{\"name\":\"_txSender\",\"type\":\"address\"}],\"name\":\"getCancelAndRefundApprovalHash\",\"outputs\":[{\"name\":\"approvalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTokenIdFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isKeyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"grantKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"expireKeyFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"keyExpirationTimestampFor\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_keyOwner\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"cancelAndRefundFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicLockVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"purchaseFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"grantKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_expirationDuration\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_keyPrice\",\"type\":\"uint256\"},{\"name\":\"_maxNumberOfKeys\",\"type\":\"uint256\"},{\"name\":\"_lockName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sendTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"CancelKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldRefundPenaltyNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldRefundPenaltyDenominator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundPenaltyNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundPenaltyDenominator\",\"type\":\"uint256\"}],\"name\":\"RefundPenaltyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldTransferFeeNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldTransferFeeDenominator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transferFeeNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transferFeeDenominator\",\"type\":\"uint256\"}],\"name\":\"TransferFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"NewLockSymbol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ExpireKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldKeyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keyPrice\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Disable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"PublicLock","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c0f32eba9a4192d93209e83e03b95be7f81036d700000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aad08158cd000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000094644432031204461790000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://47f15e51181351647a87d6980e0f8f20a1f88485a060e1fd9ce02eb8828eb7b4"}]}