{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract IERC721 {\r\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  function balanceOf(address owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n  function transferFrom(address from, address to, uint256 tokenId) public returns (bool);\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) public returns (bool);\r\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public returns (bool);\r\n\r\n  function approve(address to, uint256 tokenId) public;\r\n  function getApproved(uint256 tokenId) public view returns (address operator);\r\n  function setApprovalForAll(address operator, bool _approved) public;\r\n  function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n}\r\n\r\ncontract IERC721Receiver {\r\n  function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n * Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/IERC165.sol\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n * Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/ERC165.sol\r\n */\r\ncontract ERC165 is IERC165 {\r\n  /*\r\n   * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n   */\r\n  bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n  /**\r\n   * @dev Mapping of interface ids to whether or not it's supported.\r\n   */\r\n  mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n  constructor () internal {\r\n    // Derived contracts need only register support for their own interfaces,\r\n    // we register support for ERC165 itself here\r\n    registerInterface(_INTERFACE_ID_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   *\r\n   * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n    return _supportedInterfaces[interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev Registers the contract as an implementer of the interface defined by\r\n   * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n   * registering its interface id is not required.\r\n   *\r\n   * See {IERC165-supportsInterface}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n   */\r\n  function registerInterface(bytes4 interfaceId) internal {\r\n    require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n    _supportedInterfaces[interfaceId] = true;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b, \"Invalid argument.\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0, \"Invalid argument.\");\r\n    uint256 c = _a / _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a, \"Invalid argument.\");\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a, \"Invalid argument.\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"Invalid argument.\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address payable private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == _owner, \"Forbidden\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  function owner() public view returns (address payable) {\r\n    return _owner;\r\n  }\r\n\r\n  function transferOwnership(address payable newOwner) public onlyOwner {\r\n    require(newOwner != address(0), \"Non-zero address required.\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Ticket is ERC165, IERC721, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(uint256 => bool) private _redemptions;\r\n  mapping(address => bool) private _operators;\r\n  mapping(uint256 => address) private _tokenOwner;\r\n  mapping(uint256 => address) private _tokenApprovals;\r\n  mapping(address => uint256) private _ownedTokensCount;\r\n  mapping(address => uint256[]) private _ownedTokens;\r\n  mapping(uint256 => uint256) private _ownedTokensIndex;\r\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n  uint256[] private _allTokens;\r\n  mapping(uint256 => uint256) private _allTokensIndex;\r\n  bool private _paused;\r\n  string private _name;\r\n  string private _symbol;\r\n  mapping(uint256 => string) private _tokenURIs;\r\n\r\n  event TokenRedeemed(uint256 tokenID);\r\n\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"contract is paused\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOperator() {\r\n    require(_operators[msg.sender] == true, \"Forbidden\");\r\n    _;\r\n  }\r\n\r\n  constructor(string memory name, string memory symbol) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n\r\n    registerInterface(0x80ac58cd);\r\n    registerInterface(0x5b5e139f);\r\n    registerInterface(0x780e9d63);\r\n\r\n    _operators[msg.sender] = true;\r\n    _paused = true;\r\n  }\r\n\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n    require(exists(tokenId), \"URI query for nonexistent token\");\r\n    return _tokenURIs[tokenId];\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _ownedTokensCount[owner];\r\n  }\r\n\r\n  function ownerOf(uint256 tokenId) public view returns (address) {\r\n    address owner = _tokenOwner[tokenId];\r\n    return owner;\r\n  }\r\n\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _allTokens.length;\r\n  }\r\n\r\n  function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId) {\r\n    require(index < balanceOf(owner), \"owner index out of bounds\");\r\n    return _ownedTokens[owner][index];\r\n  }\r\n\r\n  function tokenByIndex(uint256 index) public view returns (uint256) {\r\n    require(index < totalSupply(), \"global index out of bounds\");\r\n    return _allTokens[index];\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused returns (bool) {\r\n    require(ownerOf(tokenId) == from, \"transfer of token that is not own\");\r\n    require(to != address(0), \"transfer to the zero address\");\r\n    require(isApprovedOrOwner(msg.sender, tokenId), \"transfer caller is not owner nor approved\");\r\n\r\n    clearApproval(tokenId);\r\n\r\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n    _tokenOwner[tokenId] = to;\r\n\r\n    removeTokenFromOwnerEnumeration(from, tokenId);\r\n    addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n    emit Transfer(from, to, tokenId);\r\n    return true;\r\n  }\r\n\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) public returns (bool) {\r\n    return safeTransferFrom(from, to, tokenId, \"\");\r\n  }\r\n\r\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public returns (bool) {\r\n    require(checkOnERC721Received(from, to, tokenId, data), \"transfer to non ERC721Receiver implementer\");\r\n    return transferFrom(from, to, tokenId);\r\n  }\r\n\r\n  function approve(address to, uint256 tokenId) public whenNotPaused {\r\n    address owner = ownerOf(tokenId);\r\n    require(to != owner, \"approval to current owner\");\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"approve caller is not owner nor approved for all\");\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(owner, to, tokenId);\r\n  }\r\n\r\n  function getApproved(uint256 tokenId) public view returns (address) {\r\n    require(exists(tokenId), \"approved query for nonexistent token\");\r\n    return _tokenApprovals[tokenId];\r\n  }\r\n\r\n  function setApprovalForAll(address to, bool approved) public whenNotPaused {\r\n    require(to != msg.sender, \"approve to caller\");\r\n    _operatorApprovals[msg.sender][to] = approved;\r\n    emit ApprovalForAll(msg.sender, to, approved);\r\n  }\r\n\r\n  function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n    return _operatorApprovals[owner][operator];\r\n  }\r\n\r\n  function exists(uint256 tokenId) public view returns (bool) {\r\n    address owner = _tokenOwner[tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  function mint(address to, uint256 tokenId) public onlyOwner returns (bool) {\r\n    require(to != address(0), \"mint to the zero address\");\r\n    require(!exists(tokenId), \"token already minted\");\r\n\r\n    _tokenOwner[tokenId] = to;\r\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n    addTokenToOwnerEnumeration(to, tokenId);\r\n    addTokenToAllTokensEnumeration(tokenId);\r\n\r\n    emit Transfer(address(0), to, tokenId);\r\n    return true;\r\n  }\r\n\r\n  function mintWithTokenURI(address to, uint256 tokenId, string memory uri) public onlyOwner returns (bool) {\r\n    mint(to, tokenId);\r\n    _tokenURIs[tokenId] = uri;\r\n    return true;\r\n  }\r\n\r\n  function burn(uint256 tokenId) public whenNotPaused returns (bool) {\r\n    require(isApprovedOrOwner(msg.sender, tokenId), \"caller is not owner nor approved\");\r\n\r\n    clearApproval(tokenId);\r\n\r\n    _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].sub(1);\r\n    _tokenOwner[tokenId] = address(0);\r\n\r\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n      delete _tokenURIs[tokenId];\r\n    }\r\n\r\n    removeTokenFromOwnerEnumeration(msg.sender, tokenId);\r\n    _ownedTokensIndex[tokenId] = 0;\r\n    removeTokenFromAllTokensEnumeration(tokenId);\r\n\r\n    emit Transfer(msg.sender, address(0), tokenId);\r\n\r\n    return true;\r\n  }\r\n\r\n  function pause() public onlyOwner {\r\n    _paused = true;\r\n  }\r\n\r\n  function unpause() public onlyOwner {\r\n    _paused = false;\r\n  }\r\n\r\n  function addOperator(address operator) public onlyOwner {\r\n    _operators[operator] = true;\r\n  }\r\n\r\n  function isOperator(address user) public view returns (bool) {\r\n    return _operators[user];\r\n  }\r\n\r\n  function removeOperator(address operator) public onlyOwner {\r\n    delete _operators[operator];\r\n  }\r\n\r\n  function isRedeemed(uint256 tokenID) public view returns (bool) {\r\n    return _redemptions[tokenID];\r\n  }\r\n\r\n  function getSignerAndOwner(uint256 tokenID, bytes memory signature) public view returns (address, address) {\r\n    bytes32 hash = keccak256(abi.encodePacked(_tokenURIs[tokenID]));\r\n\r\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    hash = keccak256(abi.encodePacked(prefix, hash));\r\n\r\n    address signer = recover(hash,signature);\r\n    address tokenOwner = ownerOf(tokenID);\r\n\r\n    return (signer, tokenOwner);\r\n  }\r\n\r\n  function markTokenAsRedeemed(uint256 tokenID, bytes memory signature) public onlyOperator {\r\n    require(!_redemptions[tokenID], \"Token already redeemed\");\r\n\r\n    (address signer, address tokenOwner) = getSignerAndOwner(tokenID, signature);\r\n\r\n    require(signer == tokenOwner, \"Not signed by token owner\");\r\n\r\n    _redemptions[tokenID] = true;\r\n    emit TokenRedeemed(tokenID);\r\n  }\r\n\r\n  function isApprovedOrOwner(address spender, uint256 tokenId) private view returns (bool) {\r\n    require(exists(tokenId), \"operator query for nonexistent token\");\r\n    address owner = ownerOf(tokenId);\r\n    return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n  }\r\n\r\n  function checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\r\n    if (!isContract(to)) {\r\n      return true;\r\n    }\r\n\r\n    bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n    return (retval == 0x150b7a02);\r\n  }\r\n\r\n  function clearApproval(uint256 tokenId) private {\r\n    if (_tokenApprovals[tokenId] != address(0)) {\r\n      _tokenApprovals[tokenId] = address(0);\r\n    }\r\n  }\r\n\r\n  function isContract(address account) private view returns (bool) {\r\n    uint256 size = 0;\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n\r\n  function addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n    _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n    _ownedTokens[to].push(tokenId);\r\n  }\r\n\r\n  function addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n    _allTokensIndex[tokenId] = _allTokens.length;\r\n    _allTokens.push(tokenId);\r\n  }\r\n\r\n  function removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n    uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n    if (tokenIndex != lastTokenIndex) {\r\n        uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n        _ownedTokens[from][tokenIndex] = lastTokenId;\r\n        _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n    }\r\n\r\n    _ownedTokens[from].pop();\r\n  }\r\n\r\n  function removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n    uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n    uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n    _allTokens[tokenIndex] = lastTokenId;\r\n    _allTokensIndex[lastTokenId] = tokenIndex;\r\n\r\n    _allTokens.pop();\r\n    _allTokensIndex[tokenId] = 0;\r\n  }\r\n\r\n  function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (signature.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(signature, 32))\r\n      s := mload(add(signature, 64))\r\n      v := byte(0, mload(add(signature, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  function destroy() public onlyOwner {\r\n    selfdestruct(owner());\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"isRedeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getSignerAndOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintWithTokenURI\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"markTokenAsRedeemed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"TokenRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Ticket","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000018446576636f6e2035204f6e2d436861696e205469636b6574000000000000000000000000000000000000000000000000000000000000000000000000000000034443560000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://9d787097ff0c884f00255c6b51fb61668d7d08d8750d7b2a0e6898968706b5f2"}]}