{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ninterface KyberReserveIf {\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\n\r\ncontract KyberNetworkIf { \r\n    mapping(address=>address[]) public reservesPerTokenSrc; //reserves supporting token to eth\r\n    mapping(address=>address[]) public reservesPerTokenDest;//reserves support eth to token\r\n}\r\n\r\n\r\ncontract CheckReserveSplit {\r\n    \r\n    ERC20 constant ETH = ERC20(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));\r\n    KyberNetworkIf constant kyber = KyberNetworkIf(0x9ae49C0d7F8F9EF4B864e004FE86Ac8294E20950);\r\n    ERC20 constant dai = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    ERC20 constant usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    uint constant minSplitValueEthDAI = 30;\r\n    uint constant maxSplitValueEthDAI = 140;\r\n    uint constant minSplitValueEthUsdc = 10;\r\n    uint constant maxSplitValueEthUsdc = 70;\r\n    \r\n    uint public numSplitRateIteration = 7;\r\n    \r\n    mapping(address=>address[]) public reservesPerTokenDest;//reserves supporting eth to token\r\n\r\n    constructor () public {\r\n    }\r\n    \r\n    function setNumSplitRateCalls (uint num) public {\r\n        numSplitRateIteration = num;\r\n    }\r\n    \r\n    function copyReserves(ERC20 token) public {\r\n        \r\n        KyberReserveIf reserve;\r\n        uint index;\r\n        \r\n        while(true) {\r\n            reserve = KyberReserveIf(getReserveTokenDest(address(token), index));\r\n            if (reserve == KyberReserveIf(address(0x0))) break;\r\n            reservesPerTokenDest[address(token)].push(address(reserve));\r\n            index++;\r\n        }        \r\n    }\r\n\r\n    // function copyBestReserves(ERC20 token, uint[] memory reserveIds) public {\r\n        \r\n    //     KyberReserveIf reserve;\r\n        \r\n    //     for (uint i = 0; i < reserveIds.length; i++) {\r\n    //         reserve = KyberReserveIf(getReserveTokenDest(address(token), reserveIds[i]));\r\n    //         if (reserve == KyberReserveIf(address(0x0))) continue;\r\n    //         reservesPerTokenDestBest[address(token)].push(address(reserve));\r\n    //     }        \r\n    // }\r\n\r\n    function getBestReservesEthToToken(ERC20 token) internal view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        \r\n        KyberReserveIf reserve;\r\n        uint rate;\r\n        index = 0;\r\n        \r\n        // fetch resereves find reserve with best rate and with 2nd best.\r\n        for(uint i = 0; i < reservesPerTokenDest[address(token)].length; i++) {\r\n        \r\n            reserve = KyberReserveIf(reservesPerTokenDest[address(token)][i]);\r\n            if (reserve == KyberReserveIf(address(0x0))) break;\r\n            rate = reserve.getConversionRate(ETH, token, 1 ether, block.number);\r\n            \r\n            if(rate > bestRate) {\r\n                \r\n                if (bestRate > secondRate) {\r\n                    secondRate = bestRate;\r\n                    second = best;\r\n                }\r\n                \r\n                bestRate = rate;\r\n                best = reserve;\r\n            } else if (rate > secondRate) {\r\n                secondRate = rate;\r\n                second = reserve;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getReserveTokenDest (address token, uint index) \r\n        internal view returns (address reserve) \r\n    {\r\n\r\n        (bool success, bytes memory returnData) = \r\n            address(kyber).staticcall(\r\n                abi.encodePacked( // This encodes the function to call and the parameters to pass to that function\r\n                        kyber.reservesPerTokenDest.selector, \r\n                        abi.encode(token, index) \r\n                    )\r\n                );\r\n        \r\n        if (success) {\r\n            reserve = abi.decode(returnData, (address));\r\n        } else { // transferFrom reverted. However, the complete tx did not revert and we can handle the case here.\r\n            reserve = address(0x0);\r\n        }\r\n    }\r\n\r\n    function getBestEthToDaiReserves() public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        return getBestReservesEthToToken(dai);\r\n    }\r\n    \r\n    function getBestEthToUsdcReserves() public view \r\n        returns(KyberReserveIf best, KyberReserveIf second, uint bestRate, uint secondRate, uint index) \r\n    {\r\n        return getBestReservesEthToToken(usdc);\r\n    }\r\n    \r\n    // which eth trade value 2nd best reserve has better rate then best reserve\r\n    function getSplitThresholdEthToToken(ERC20 token) internal view \r\n        returns(uint splitThresholdEth, KyberReserveIf best, KyberReserveIf second, uint rateBest, uint rate2nd) \r\n    {\r\n        uint rate;\r\n        \r\n        (best, second, rateBest, rate2nd, )  = getBestReservesEthToToken(token);\r\n        \r\n        (uint stepSizeWei, uint splitThresholdEthWei) = getBasicStepSizes(token);\r\n        \r\n        uint numSplitCalls = numSplitRateIteration;\r\n\r\n        while (numSplitCalls-- > 0) {\r\n            rate = best.getConversionRate(ETH, token, splitThresholdEthWei, block.number);\r\n            \r\n            stepSizeWei /= 2;\r\n            splitThresholdEthWei += rate < rate2nd ? (- stepSizeWei) : stepSizeWei;\r\n        }\r\n        \r\n        if(rate == 0) {\r\n            splitThresholdEthWei -= (stepSizeWei * 2);\r\n\r\n            rate = best.getConversionRate(ETH, token, splitThresholdEthWei, block.number);\r\n        }\r\n        \r\n        splitThresholdEth = splitThresholdEthWei / 10 ** 18;\r\n    }\r\n    \r\n    function getSplitValueEthToToken(ERC20 token, uint tradeSizeEth) internal view \r\n        returns(uint splitValueEth, uint splitThresholdEth, KyberReserveIf best, KyberReserveIf second) \r\n    {\r\n        \r\n        (splitThresholdEth, best, second, , )  = getSplitThresholdEthToToken(token);\r\n        \r\n        if (tradeSizeEth < splitThresholdEth) return (0, splitThresholdEth, best, second);\r\n        uint refRate = calcCombinedRate(token, best, second, splitThresholdEth, tradeSizeEth);\r\n        \r\n        uint stepSizeEth = (tradeSizeEth - splitThresholdEth) / 2;\r\n        \r\n        uint numSplitCalls = numSplitRateIteration;\r\n        uint newRate;\r\n        \r\n        uint prevSplitValue = splitThresholdEth;\r\n        splitValueEth = splitThresholdEth + stepSizeEth;\r\n\r\n        while (numSplitCalls-- > 0) {\r\n            newRate = calcCombinedRate(token, best, second, splitValueEth, tradeSizeEth);\r\n        \r\n            stepSizeEth /= 2;\r\n            bool isCurrentSplitBigger = splitValueEth > prevSplitValue ? true : false;\r\n            prevSplitValue = splitValueEth;\r\n            \r\n            if (newRate > refRate) {\r\n                refRate = newRate;\r\n                //if current split value is bigger the previous. and new rate > prev rate, we sould continue positive direction.\r\n                splitValueEth += isCurrentSplitBigger ? stepSizeEth : (-stepSizeEth);\r\n            } else {\r\n                splitValueEth += isCurrentSplitBigger  ? (-stepSizeEth) : stepSizeEth;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getBasicStepSizes (ERC20 token) internal pure returns(uint stepSizeWei, uint splitValueEthWei) {\r\n        if(token == usdc) {\r\n            stepSizeWei = (maxSplitValueEthUsdc - minSplitValueEthUsdc) * 10 ** 18 / 2;\r\n            splitValueEthWei = minSplitValueEthUsdc * 10 ** 18 + stepSizeWei;\r\n        } else {\r\n            stepSizeWei = (maxSplitValueEthDAI - minSplitValueEthDAI) * 10 ** 18 / 2;\r\n            splitValueEthWei = minSplitValueEthDAI * 10 ** 18 + stepSizeWei;            \r\n        }\r\n    }\r\n\r\n    function getDaiSplitThreshold() public view returns (uint splitThresholdEth) {\r\n        (splitThresholdEth, , , ,) = getSplitThresholdEthToToken(dai);\r\n    }\r\n   \r\n    function getDaiSplitValues(uint tradeSizeEth) public view \r\n        returns (KyberReserveIf bestReserve, uint bestRate, KyberReserveIf secondBest, uint secondRate, uint splitThresholdEth, uint splitValueEth, uint rateBestAfterSplitValue) \r\n    {\r\n        (splitValueEth, splitThresholdEth, bestReserve, secondBest) = getSplitValueEthToToken(dai, tradeSizeEth);\r\n        bestRate = bestReserve.getConversionRate(ETH, dai, 1 ether, block.number);\r\n        secondRate = secondBest.getConversionRate(ETH, dai, 1 ether, block.number);\r\n        rateBestAfterSplitValue = bestReserve.getConversionRate(ETH, dai, (splitValueEth + 1) * 10 ** 18, block.number);\r\n    }\r\n    \r\n    function getUsdcSplitThreshold() public view returns (uint splitThresholdEth) {\r\n        (splitThresholdEth, , , ,) = getSplitThresholdEthToToken(usdc);\r\n    }\r\n    \r\n    function getUsdcSplitValues(uint tradeSizeEth) public view \r\n        returns (KyberReserveIf bestReserve, uint rate1, KyberReserveIf secondBest, uint rate2, uint splitThresholdEth, uint splitValueEth, uint rateBestAfterSplitValue) \r\n    {\r\n        (splitValueEth, splitThresholdEth, bestReserve, secondBest) = getSplitValueEthToToken(usdc, tradeSizeEth);\r\n        rate1 = bestReserve.getConversionRate(ETH, usdc, 1 ether, block.number);\r\n        rate2 = secondBest.getConversionRate(ETH, usdc, 1 ether, block.number);\r\n        rateBestAfterSplitValue = bestReserve.getConversionRate(ETH, usdc, (splitValueEth + 1) *10 ** 18, block.number);\r\n    }\r\n    \r\n    function compareSplitTrade(ERC20 token, uint tradeValueEth) internal view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint amountSingleReserve, uint amountTwoRes, uint splitValueEth, uint splitThresholdEth) \r\n    {\r\n        KyberReserveIf reserveBest;\r\n        KyberReserveIf reseve2nd;\r\n        \r\n        (splitValueEth, splitThresholdEth, reserveBest, reseve2nd) = getSplitValueEthToToken(token, tradeValueEth);\r\n        if (splitValueEth > tradeValueEth) return(0, 0, 0, 0, splitValueEth, splitThresholdEth);\r\n        \r\n        rateSingleReserve = reserveBest.getConversionRate(ETH, token, splitValueEth * 10 ** 18, block.number);\r\n        rateTwoReserves = calcCombinedRate(token, reserveBest, reseve2nd, splitValueEth, tradeValueEth);\r\n        \r\n        amountSingleReserve = (rateSingleReserve / 10 ** 18) * tradeValueEth;\r\n        amountTwoRes = (rateTwoReserves / 10 ** 18) * tradeValueEth;\r\n    }\r\n    \r\n    function getDaiSplitValueGas() public \r\n        returns (KyberReserveIf bestReserve, uint bestRate, KyberReserveIf secondBest, uint secondRate, uint splitThresholdEth, uint splitValueEth, uint rateBestAfterSplitValue) \r\n    {\r\n        return getDaiSplitValues(120);\r\n    }\r\n    \r\n    function viewSplitTradeEthToDai(uint tradeValueEth)\r\n        public view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint amountSingleReserve, uint amountTwoRes, uint splitValueEth, uint splitThresholdEth) \r\n    {\r\n        return compareSplitTrade(dai, tradeValueEth);\r\n    }\r\n    \r\n    function viewSplitTradeEthToUsdc(uint tradeValueEth)\r\n        public view \r\n        returns(uint rateSingleReserve, uint rateTwoReserves, uint amountSingleReserve, uint amountTwoRes, uint splitValueEth, uint splitThresholdEth) \r\n    {\r\n        return compareSplitTrade(usdc, tradeValueEth);\r\n    }\r\n    \r\n    function calcCombinedRate(ERC20 token, KyberReserveIf best, KyberReserveIf second, uint splitValueEth, uint tradeValueEth)\r\n        internal view returns(uint rate)\r\n    {\r\n        uint rate1 = best.getConversionRate(ETH, token, splitValueEth * 10 ** 18, block.number);\r\n        uint rate2 = second.getConversionRate(ETH, token, (tradeValueEth - splitValueEth) * 10 ** 18, block.number);\r\n        rate = (rate1 * splitValueEth + rate2 * (tradeValueEth - splitValueEth)) / tradeValueEth;\r\n    }\r\n    \r\n    // function getAllReserves (ERC20 token) public view returns (KyberReserveIf [] memory reserves, uint [] memory rates) {\r\n        \r\n    //     KyberReserveIf reserve;\r\n    //     uint index;\r\n        \r\n    //     while(true) {\r\n    //         reserve = KyberReserveIf(getReserveTokenDest(address(token), index));\r\n    //         if (reserve == KyberReserveIf(address(0x0))) break;\r\n    //         index++;\r\n    //     }\r\n \r\n    //     reserves = new KyberReserveIf[](index + 1);\r\n    //     rates = new uint[](index + 1);\r\n        \r\n    //     // fetch all resereves and rates for token.\r\n    //     for(uint i = 0; i < index; i++) {\r\n    //         reserves[i] = KyberReserveIf(getReserveTokenDest(address(token), i));        \r\n    //         rates[i] = reserves[i].getConversionRate(ETH, token, 1 ether, block.number);\r\n    //     }\r\n    // }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getDaiSplitThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeValueEth\",\"type\":\"uint256\"}],\"name\":\"viewSplitTradeEthToDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateTwoReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTwoRes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setNumSplitRateCalls\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeValueEth\",\"type\":\"uint256\"}],\"name\":\"viewSplitTradeEthToUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateTwoReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSingleReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTwoRes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numSplitRateIteration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeSizeEth\",\"type\":\"uint256\"}],\"name\":\"getUsdcSplitValues\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"bestReserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate1\",\"type\":\"uint256\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"secondBest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBestAfterSplitValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBestEthToDaiReserves\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"best\",\"type\":\"address\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"second\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reservesPerTokenDest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeSizeEth\",\"type\":\"uint256\"}],\"name\":\"getDaiSplitValues\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"bestReserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"secondBest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBestAfterSplitValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDaiSplitValueGas\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"bestReserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"secondBest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitValueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateBestAfterSplitValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBestEthToUsdcReserves\",\"outputs\":[{\"internalType\":\"contract KyberReserveIf\",\"name\":\"best\",\"type\":\"address\"},{\"internalType\":\"contract KyberReserveIf\",\"name\":\"second\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"copyReserves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUsdcSplitThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"splitThresholdEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CheckReserveSplit","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://a2d21d9663fe8cf7288445d1a3bba94c260bd1b704dfd99b3918ff25ee8079a3"}]}