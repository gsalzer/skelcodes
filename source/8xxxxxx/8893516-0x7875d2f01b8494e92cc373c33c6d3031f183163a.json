{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\n\n\ninterface ERC165Interface {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract ERC721Interface is ERC165Interface {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\ncontract EntityDataInterface {\n\n    address public tokenAddr;\n\n    mapping(uint256 => Entity) public entityData;\n    mapping(uint256 => address) public siringApprovedTo;\n\n    event UpdateRootHash (\n        uint256 tokenId,\n        bytes rootHash\n    );\n\n    event Birth (\n        uint256 tokenId,\n        address owner,\n        uint256 matronId,\n        uint256 sireId\n    );\n\n    struct Entity {\n        bytes rootHash;\n        uint256 birthTime;\n        uint256 cooldownEndTime;\n        uint256 matronId;\n        uint256 sireId;\n        uint256 generation;\n    }\n\n    function updateRootHash(uint256 tokenId, bytes calldata rootHash) external;\n\n    function createEntity(address owner, uint256 tokenId, uint256 _generation, uint256 _matronId, uint256 _sireId, uint256 _birthTime) public;\n\n    function getEntity(uint256 tokenId)\n      external\n      view\n      returns(\n            uint256 birthTime,\n            uint256 cooldownEndTime,\n            uint256 matronId,\n            uint256 sireId,\n            uint256 generation\n        );\n\n    function setCooldownEndTime(uint256 tokenId, uint256 _cooldownEndTime) external;\n\n    function approveSiring(uint256 sireId, address approveTo) external;\n\n    function clearSiringApproval(uint256 sireId) external;\n\n    function isSiringApprovedTo(uint256 tokenId, address borrower)\n        external\n        view\n        returns(bool);\n\n    function isReadyForFusion(uint256 tokenId)\n        external\n        view\n        returns (bool ready);\n}\n\ncontract RoleManager {\n\n    mapping(address => bool) private admins;\n    mapping(address => bool) private controllers;\n\n    modifier onlyAdmins {\n        require(admins[msg.sender], 'only admins');\n        _;\n    }\n\n    modifier onlyControllers {\n        require(controllers[msg.sender], 'only controllers');\n        _;\n    } \n\n    constructor() public {\n        admins[msg.sender] = true;\n        controllers[msg.sender] = true;\n    }\n\n    function addController(address _newController) external onlyAdmins{\n        controllers[_newController] = true;\n    } \n\n    function addAdmin(address _newAdmin) external onlyAdmins{\n        admins[_newAdmin] = true;\n    } \n\n    function removeController(address _controller) external onlyAdmins{\n        controllers[_controller] = false;\n    } \n    \n    function removeAdmin(address _admin) external onlyAdmins{\n        require(_admin != msg.sender, 'unexecutable operation'); \n        admins[_admin] = false;\n    } \n\n    function isAdmin(address addr) external view returns (bool) {\n        return (admins[addr]);\n    }\n\n    function isController(address addr) external view returns (bool) {\n        return (controllers[addr]);\n    }\n\n}\n\ncontract AccessController {\n\n    address roleManagerAddr;\n\n    modifier onlyAdmins {\n        require(RoleManager(roleManagerAddr).isAdmin(msg.sender), 'only admins');\n        _;\n    }\n\n    modifier onlyControllers {\n        require(RoleManager(roleManagerAddr).isController(msg.sender), 'only controllers');\n        _;\n    }\n\n    constructor (address _roleManagerAddr) public {\n        require(_roleManagerAddr != address(0), '_roleManagerAddr: Invalid address (zero address)');\n        roleManagerAddr = _roleManagerAddr;\n    }\n\n}\n\nlibrary SafeMath {\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ncontract FusionInterface {\n    using SafeMath for uint256;\n\n    uint256 public fusionFeeWei;\n    address public tokenAddr;\n    address public entityDataAddr;\n    address payable generateRandomEntityAddr;\n    uint256 public cooldownPeriod;\n    uint256 public incubationTime;\n    address payable public adminWalletAddr;\n    bool public isFusionDisabled;\n    uint256 public idCounter;\n    uint256 public constant fusionTypeId = 2;\n    uint256 public capDrawByEth;\n    uint256 public cntDrawnByEth;\n\n    event Fuse(uint256 matronId, uint256 sireId, uint256 fusionTime);\n\n    function setFusionFee(uint256 newFeeWei) public;\n\n    function setAdminWallet(address payable newWalletAddr) public;\n\n    function fusion(uint256 matronId, uint256 sireId) external payable returns(uint256 childId);\n\n    function isValidFusionPair(uint256 matronId, uint256 sireId)\n        public\n        view\n        returns(bool isValid);\n\n    function setCapDrawByEth(uint256 _cap) external {\n        capDrawByEth = _cap;\n    }\n\n    function disableFusion() public {\n        isFusionDisabled = true;\n    }\n}\n\ncontract Market is AccessController{\n    using SafeMath for uint256;\n \n    mapping(uint256 => Deal) public tokenIdToDeal;\n    address public tokenAddr;\n    address public entityDataAddr;\n    uint256 public feeBasisPoint;\n    address payable public feeTransferToAddr;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    event Dealt (\n        uint256 tokenId,\n        uint256 priceWei,\n        address seller,\n        address buyer,\n        uint256 dealtAt\n    );\n\n    event Ask (\n        address owner,\n        uint256 tokenId,\n        uint256 priceWei,\n        uint256 saleStartedAt,\n        uint256 saleEndTime\n    );\n\n    event Cancel(\n        uint256 tokenId,\n        uint256 canceledAt\n    );\n\n    struct Deal {\n        address owner;\n        uint256 priceWei;\n        uint256 saleStartedAt;\n        uint256 saleEndTime;\n    }\n\n    constructor(\n        address _entityDataAddr,\n        address _roleManagerAddr\n    )\n      public\n      AccessController(_roleManagerAddr)\n    {\n        require(_entityDataAddr != address(0), '_entityDataAddr: Invalid address (zero address)');\n        entityDataAddr = _entityDataAddr;\n        tokenAddr = EntityDataInterface(entityDataAddr).tokenAddr();\n        require(ERC721Interface(tokenAddr).supportsInterface(_INTERFACE_ID_ERC721));\n\n        feeBasisPoint = 0;\n        feeTransferToAddr = msg.sender;\n    }\n\n    function setFee(uint256 _feeBasisPoint) external onlyAdmins {\n        \n        require(_feeBasisPoint <= 10000, 'Invalid feeBasisPoint');\n        feeBasisPoint = _feeBasisPoint;\n    }\n   \n    function setWallet(address payable _feeTransferToAddr) external onlyAdmins {\n        feeTransferToAddr = _feeTransferToAddr;\n    }\n    \n    function addDeal(uint256 tokenId, uint256 _priceWei, uint256 _saleEndTime) public {\n        require(ERC721Interface(tokenAddr).ownerOf(tokenId) == msg.sender, 'msg.sender is not the owner of the given tokenId');\n        require(_priceWei > 0, 'Invalid price');\n        \n        require(_saleEndTime > uint256(now), 'Invalid saleEndTime');\n\n        Deal memory newDeal = Deal({\n            saleStartedAt : block.timestamp,\n            saleEndTime : _saleEndTime,\n            priceWei : _priceWei,\n            owner : msg.sender\n        });\n\n        emit Ask(newDeal.owner, tokenId, newDeal.priceWei, newDeal.saleStartedAt, newDeal.saleEndTime);\n\n        tokenIdToDeal[tokenId] = newDeal;\n    }\n\n    function currentPrice(uint256 tokenId) external view returns(uint256 currentPriceWei);\n\n    function cancel(uint256 tokenId) external {\n        \n        require(tokenIdToDeal[tokenId].owner == msg.sender || tokenIdToDeal[tokenId].saleEndTime < block.timestamp, 'msg.sender is not the owner of the given tokenId');\n\n        ERC721Interface(tokenAddr).transferFrom(address(this), tokenIdToDeal[tokenId].owner, tokenId);\n        \n        delete tokenIdToDeal[tokenId];\n        emit Cancel(tokenId, block.timestamp);\n    }\n\n    function calculateFee(uint256 priceWei) public view returns(uint256 fee) {\n        \n        uint256 priceToCapFee = 1000000 ether;\n        if (priceWei > priceToCapFee) {\n          return priceToCapFee.mul(feeBasisPoint).div(10000);\n        }\n        return priceWei.mul(feeBasisPoint).div(10000);\n    }\n\n    function isAsked(uint256 tokenId) public view returns(bool) {\n        return (tokenIdToDeal[tokenId].owner != address(0));\n    }\n\n\n\n}\n\ncontract SiringMarket is Market {\n    using SafeMath for uint256;\n\n    address public fusionAddr;\n\n    constructor(\n        address _entityDataAddr,\n        address _roleManagerAddr,\n        address _fusionAddr\n    )\n        public\n        Market(_entityDataAddr, _roleManagerAddr)\n    {\n        require(_fusionAddr != address(0), '_fusionAddr: Invalid address (zero address)');\n        _setFusionAddress(_fusionAddr);\n    }\n\n    function () payable external {\n\n    }\n\n    function addDeal(uint256 tokenId, uint256 _priceWei, uint256 _saleEndTime) public {\n        require(EntityDataInterface(entityDataAddr).isReadyForFusion(tokenId), 'Not ready');\n        Market.addDeal(tokenId, _priceWei, _saleEndTime);\n    }\n\n    function bid(uint256 tokenId, uint256 matronId) external payable {\n        require(isAsked(tokenId), 'Not asked');\n\n        \n        Deal memory deal = tokenIdToDeal[tokenId];\n        require(deal.saleEndTime >= block.timestamp, 'Sale ended');\n\n        uint256 priceWei = this.currentPrice(tokenId);\n        uint256 fusionFeeWei = FusionInterface(fusionAddr).fusionFeeWei();\n        require(msg.value >=  (priceWei.add(fusionFeeWei)), 'Insufficient amount of ether');\n\n        \n        uint256 changeWei = (msg.value.sub(priceWei).sub(fusionFeeWei));\n\n        uint256 marketFeeWei = calculateFee(priceWei);\n\n        \n        FusionInterface(fusionAddr).fusion.value(fusionFeeWei)(matronId, tokenId);\n\n        emit Dealt(tokenId, deal.priceWei, deal.owner, msg.sender, block.timestamp);\n\n        \n        address payable originalOwner = address(uint160(deal.owner));\n\n        \n        originalOwner.transfer(priceWei.sub(marketFeeWei));\n        msg.sender.transfer(changeWei);\n\n        require(address(this).balance >= marketFeeWei);\n        feeTransferToAddr.transfer(address(this).balance);\n\n    }\n\n    function currentPrice(uint256 tokenId)\n        external\n        view\n        returns(uint256 currentPriceWei)\n    {\n        require(isAsked(tokenId), 'Not asked');\n        return tokenIdToDeal[tokenId].priceWei;\n    }\n\n    function setFusionAddress(address _fusionAddr)\n        public\n        onlyAdmins\n    {\n      _setFusionAddress(_fusionAddr);\n    }\n\n    function _setFusionAddress(address _fusionAddr)\n        internal\n    {\n      require(_fusionAddr != address(0), '_fusionAddr: Invalid address (zero address)');\n      fusionAddr = _fusionAddr;\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_fusionAddr\",\"type\":\"address\"}],\"name\":\"setFusionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"matronId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_priceWei\",\"type\":\"uint256\"},{\"name\":\"_saleEndTime\",\"type\":\"uint256\"}],\"name\":\"addDeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeBasisPoint\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"currentPriceWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"priceWei\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTransferToAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isAsked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fusionAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entityDataAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeTransferToAddr\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBasisPoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToDeal\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"priceWei\",\"type\":\"uint256\"},{\"name\":\"saleStartedAt\",\"type\":\"uint256\"},{\"name\":\"saleEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_entityDataAddr\",\"type\":\"address\"},{\"name\":\"_roleManagerAddr\",\"type\":\"address\"},{\"name\":\"_fusionAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dealtAt\",\"type\":\"uint256\"}],\"name\":\"Dealt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"saleStartedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"saleEndTime\",\"type\":\"uint256\"}],\"name\":\"Ask\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"canceledAt\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"}]","ContractName":"SiringMarket","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000016659c6931ec572d6b89781f2e5a5b8562ecb416000000000000000000000000d9e1ec33d63d6d73ec9418254261d0cb341eb646000000000000000000000000a2b09a7b3f9d94769fb310f17ba83264c807a529","Library":"","LicenseType":"","SwarmSource":"bzzr://425acb56febc83744cdd698a09bc1dbfed131ebcb8b5bb6668aed19217790d87"}]}