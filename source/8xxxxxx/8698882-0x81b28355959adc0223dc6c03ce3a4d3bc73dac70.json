{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\n\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\ninterface FundsInterface {\n    function lender(bytes32) external view returns (address);\n    function custom(bytes32) external view returns (bool);\n    function deposit(bytes32, uint256) external;\n    function decreaseTotalBorrow(uint256) external;\n    function calcGlobalInterest() external;\n}\n\ninterface SalesInterface {\n    function saleIndexByLoan(bytes32, uint256) external returns(bytes32);\n    function settlementExpiration(bytes32) external view returns (uint256);\n    function accepted(bytes32) external view returns (bool);\n    function next(bytes32) external view returns (uint256);\n    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant COL  = 10 ** 8;\n    uint constant WAD  = 10 ** 18;\n    uint constant RAY  = 10 ** 27;\n\n    function cmul(uint x, uint y) public pure returns (uint z) {\n        z = add(mul(x, y), COL / 2) / COL;\n    }\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function cdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, COL), y / 2) / y;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\ncontract Medianizer {\n    function peek() public view returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke() public;\n    function poke(bytes32) public;\n    function fund (uint256 amount, ERC20 token) public;\n}\n\ncontract Loans is DSMath {\n    FundsInterface funds;\n    Medianizer med;\n    SalesInterface sales;\n\n    uint256 public constant APPROVE_EXP_THRESHOLD = 2 hours;    \n    uint256 public constant ACCEPT_EXP_THRESHOLD = 2 days;      \n    uint256 public constant LIQUIDATION_EXP_THRESHOLD = 7 days; \n    uint256 public constant SEIZURE_EXP_THRESHOLD = 2 days;     \n    uint256 public constant LIQUIDATION_DISCOUNT = 930000000000000000; \n\n    mapping (bytes32 => Loan)         public loans;\n    mapping (bytes32 => PubKeys)      public pubKeys;      \n    mapping (bytes32 => SecretHashes) public secretHashes; \n    mapping (bytes32 => Bools)        public bools;        \n    mapping (bytes32 => bytes32)      public fundIndex;    \n    mapping (bytes32 => ERC20)        public tokes;        \n    mapping (bytes32 => uint256)      public repayments;   \n    uint256                           public loanIndex;    \n\n    mapping (address => bytes32[])    public borrowerLoans;\n    mapping (address => bytes32[])    public lenderLoans;\n\n    ERC20 public token; \n    uint256 public decimals;\n\n    address deployer;\n\n    \n    struct Loan {\n    \taddress borrower;\n        address lender;\n        address arbiter;\n        uint256 createdAt;\n        uint256 loanExpiration;\n        uint256 requestTimestamp;\n        uint256 closedTimestamp;\n        uint256 principal;\n        uint256 interest;\n        uint256 penalty;\n        uint256 fee;\n        uint256 collateral;\n        uint256 liquidationRatio;\n    }\n\n    \n    struct PubKeys {\n        bytes   borrowerPubKey;\n        bytes   lenderPubKey;\n        bytes   arbiterPubKey;\n    }\n\n    \n    struct SecretHashes {\n    \tbytes32    secretHashA1;\n    \tbytes32[3] secretHashAs;\n    \tbytes32    secretHashB1;\n    \tbytes32[3] secretHashBs;\n    \tbytes32    secretHashC1;\n    \tbytes32[3] secretHashCs;\n        bytes32    withdrawSecret;\n        bytes32    acceptSecret;\n    \tbool       set;\n    }\n\n    \n    struct Bools {\n    \tbool funded;\n    \tbool approved;\n    \tbool withdrawn;\n    \tbool sale;\n    \tbool paid;\n    \tbool off;\n    }\n\n    event Create(bytes32 loan);\n\n    function borrower(bytes32 loan) public view returns (address) {\n        return loans[loan].borrower;\n    }\n\n    function lender(bytes32 loan) public view returns (address) {\n        return loans[loan].lender;\n    }\n\n    function arbiter(bytes32 loan)  public view returns (address) {\n        return loans[loan].arbiter;\n    }\n\n    function approveExpiration(bytes32 loan) public view returns (uint256) { \n        return add(loans[loan].createdAt, APPROVE_EXP_THRESHOLD);\n    }\n\n    \n\n    function acceptExpiration(bytes32 loan) public view returns (uint256) { \n        return add(loans[loan].loanExpiration, ACCEPT_EXP_THRESHOLD);\n    }\n\n    function liquidationExpiration(bytes32 loan) public view returns (uint256) { \n        return add(loans[loan].loanExpiration, LIQUIDATION_EXP_THRESHOLD);\n    }\n\n    function seizureExpiration(bytes32 loan) public view returns (uint256) {\n        return add(liquidationExpiration(loan), SEIZURE_EXP_THRESHOLD);\n    }\n\n    function principal(bytes32 loan) public view returns (uint256) {\n        return loans[loan].principal;\n    }\n\n    function interest(bytes32 loan) public view returns (uint256) {\n        return loans[loan].interest;\n    }\n\n    function fee(bytes32 loan) public view returns (uint256) {\n        return loans[loan].fee;\n    }\n\n    function penalty(bytes32 loan) public view returns (uint256) {\n        return loans[loan].penalty;\n    }\n\n    function collateral(bytes32 loan) public view returns (uint256) {\n        return loans[loan].collateral;\n    }\n\n    function repaid(bytes32 loan) public view returns (uint256) { \n        return repayments[loan];\n    }\n\n    function liquidationRatio(bytes32 loan) public view returns (uint256) {\n        return loans[loan].liquidationRatio;\n    }\n\n    function owedToLender(bytes32 loan) public view returns (uint256) { \n        return add(principal(loan), interest(loan));\n    }\n\n    function owedForLoan(bytes32 loan) public view returns (uint256) { \n        return add(owedToLender(loan), fee(loan));\n    }\n\n    function owedForLiquidation(bytes32 loan) public view returns (uint256) { \n        return add(owedForLoan(loan), penalty(loan));\n    }\n\n    function owing(bytes32 loan) public view returns (uint256) {\n        return sub(owedForLoan(loan), repaid(loan));\n    }\n\n    function funded(bytes32 loan) public view returns (bool) {\n        return bools[loan].funded;\n    }\n\n    function approved(bytes32 loan) public view returns (bool) {\n        return bools[loan].approved;\n    }\n\n    function withdrawn(bytes32 loan) public view returns (bool) {\n        return bools[loan].withdrawn;\n    }\n\n    function sale(bytes32 loan) public view returns (bool) {\n        return bools[loan].sale;\n    }\n\n    function paid(bytes32 loan) public view returns (bool) {\n        return bools[loan].paid;\n    }\n\n    function off(bytes32 loan) public view returns (bool) {\n        return bools[loan].off;\n    }\n\n    function dmul(uint x) public view returns (uint256) {\n        return mul(x, (10 ** sub(18, decimals)));\n    }\n\n    function ddiv(uint x) public view returns (uint256) {\n        return div(x, (10 ** sub(18, decimals)));\n    }\n\n    function borrowerLoanCount(address borrower_) public view returns (uint256) {\n        return borrowerLoans[borrower_].length;\n    }\n\n    function lenderLoanCount(address lender_) public view returns (uint256) {\n        return lenderLoans[lender_].length;\n    }\n\n    function collateralValue(bytes32 loan) public view returns (uint256) { \n        (bytes32 val, bool set) = med.peek();\n        require(set);\n        uint256 price = uint(val);\n        return cmul(price, collateral(loan)); \n    }\n\n    function minCollateralValue(bytes32 loan) public view returns (uint256) {  \n        return rmul(dmul(sub(principal(loan), repaid(loan))), liquidationRatio(loan));\n    }\n\n    function discountCollateralValue(bytes32 loan) public view returns (uint256) {\n        return wmul(collateralValue(loan), LIQUIDATION_DISCOUNT);\n    }\n\n    function safe(bytes32 loan) public view returns (bool) { \n        return collateralValue(loan) >= minCollateralValue(loan);\n    }\n\n    constructor (FundsInterface funds_, Medianizer med_, ERC20 token_, uint256 decimals_) public {\n        deployer = msg.sender;\n    \tfunds    = funds_;\n    \tmed      = med_;\n        token    = token_;\n        decimals = decimals_;\n        require(token.approve(address(funds), 2**256-1));\n    }\n\n    \n    function setSales(SalesInterface sales_) external {\n        require(msg.sender == deployer);\n        require(address(sales) == address(0));\n        sales = sales_;\n    }\n    \n    \n    function create(\n        uint256             loanExpiration_,\n        address[3] calldata usrs_,\n        uint256[7] calldata vals_,\n        bytes32             fundIndex_\n    ) external returns (bytes32 loan) {\n        if (fundIndex_ != bytes32(0)) { require(funds.lender(fundIndex_) == usrs_[1]); }\n        loanIndex = add(loanIndex, 1);\n        loan = bytes32(loanIndex);\n        loans[loan].createdAt        = now;\n        loans[loan].loanExpiration   = loanExpiration_;\n        loans[loan].borrower         = usrs_[0];\n        loans[loan].lender           = usrs_[1];\n        loans[loan].arbiter          = usrs_[2];\n        loans[loan].principal        = vals_[0];\n        loans[loan].interest         = vals_[1];\n        loans[loan].penalty          = vals_[2];\n        loans[loan].fee              = vals_[3];\n        loans[loan].collateral       = vals_[4];\n        loans[loan].liquidationRatio = vals_[5];\n        loans[loan].requestTimestamp = vals_[6];\n        fundIndex[loan]              = fundIndex_;\n        secretHashes[loan].set       = false;\n        borrowerLoans[usrs_[0]].push(bytes32(loanIndex));\n        lenderLoans[usrs_[1]].push(bytes32(loanIndex));\n\n        emit Create(loan);\n    }\n\n    \n    function setSecretHashes(\n    \tbytes32             loan,\n        bytes32[4] calldata borrowerSecretHashes,\n        bytes32[4] calldata lenderSecretHashes,\n        bytes32[4] calldata arbiterSecretHashes,\n\t\tbytes      calldata borrowerPubKey_,\n        bytes      calldata lenderPubKey_,\n        bytes      calldata arbiterPubKey_\n\t) external returns (bool) {\n\t\trequire(!secretHashes[loan].set);\n\t\trequire(msg.sender == loans[loan].borrower || msg.sender == loans[loan].lender || msg.sender == address(funds));\n\t\tsecretHashes[loan].secretHashA1 = borrowerSecretHashes[0];\n\t\tsecretHashes[loan].secretHashAs = [ borrowerSecretHashes[1], borrowerSecretHashes[2], borrowerSecretHashes[3] ];\n\t\tsecretHashes[loan].secretHashB1 = lenderSecretHashes[0];\n\t\tsecretHashes[loan].secretHashBs = [ lenderSecretHashes[1], lenderSecretHashes[2], lenderSecretHashes[3] ];\n\t\tsecretHashes[loan].secretHashC1 = arbiterSecretHashes[0];\n\t\tsecretHashes[loan].secretHashCs = [ arbiterSecretHashes[1], arbiterSecretHashes[2], arbiterSecretHashes[3] ];\n\t\tpubKeys[loan].borrowerPubKey    = borrowerPubKey_;\n\t\tpubKeys[loan].lenderPubKey      = lenderPubKey_;\n        pubKeys[loan].arbiterPubKey       = arbiterPubKey_;\n        secretHashes[loan].set          = true;\n\t}\n\n    \n\tfunction fund(bytes32 loan) external {\n\t\trequire(secretHashes[loan].set);\n    \trequire(bools[loan].funded == false);\n    \trequire(token.transferFrom(msg.sender, address(this), principal(loan)));\n    \tbools[loan].funded = true;\n    }\n\n    \n    function approve(bytes32 loan) external { \n    \trequire(bools[loan].funded == true);\n    \trequire(loans[loan].lender == msg.sender);\n    \trequire(now                <= approveExpiration(loan));\n    \tbools[loan].approved = true;\n    }\n\n    \n    function withdraw(bytes32 loan, bytes32 secretA1) external {\n    \trequire(!off(loan));\n    \trequire(bools[loan].funded == true);\n    \trequire(bools[loan].approved == true);\n        require(bools[loan].withdrawn == false);\n    \trequire(sha256(abi.encodePacked(secretA1)) == secretHashes[loan].secretHashA1);\n    \trequire(token.transfer(loans[loan].borrower, principal(loan)));\n    \tbools[loan].withdrawn = true;\n        secretHashes[loan].withdrawSecret = secretA1;\n    }\n\n    \n    function repay(bytes32 loan, uint256 amount) external {\n    \trequire(!off(loan));\n        require(!sale(loan));\n    \trequire(bools[loan].withdrawn     == true);\n    \trequire(now                       <= loans[loan].loanExpiration);\n        require(add(amount, repaid(loan)) <= owedForLoan(loan));\n    \trequire(token.transferFrom(msg.sender, address(this), amount));\n    \trepayments[loan] = add(amount, repayments[loan]);\n    \tif (repaid(loan) == owedForLoan(loan)) {\n    \t\tbools[loan].paid = true;\n    \t}\n    }\n\n    \n    function refund(bytes32 loan) external {\n    \trequire(!off(loan));\n        require(!sale(loan));\n    \trequire(now              >  acceptExpiration(loan));\n    \trequire(bools[loan].paid == true);\n    \trequire(msg.sender       == loans[loan].borrower);\n        bools[loan].off = true;\n        loans[loan].closedTimestamp = now;\n    \trequire(token.transfer(loans[loan].borrower, owedForLoan(loan)));\n        if (funds.custom(fundIndex[loan]) == false) {\n            funds.decreaseTotalBorrow(loans[loan].principal);\n            funds.calcGlobalInterest();\n        }\n    }\n\n    \n    function cancel(bytes32 loan, bytes32 secret) external {\n        accept(loan, secret);\n    }\n\n    \n    function accept(bytes32 loan, bytes32 secret) public {\n        require(!off(loan));\n        require(bools[loan].withdrawn == false   || bools[loan].paid == true);\n        require(msg.sender == loans[loan].lender || msg.sender == loans[loan].arbiter);\n        require(sha256(abi.encodePacked(secret)) == secretHashes[loan].secretHashB1 || sha256(abi.encodePacked(secret)) == secretHashes[loan].secretHashC1);\n        require(now                              <= acceptExpiration(loan));\n        require(bools[loan].sale                 == false);\n        bools[loan].off = true;\n        loans[loan].closedTimestamp = now;\n        secretHashes[loan].acceptSecret = secret;\n        if (bools[loan].withdrawn == false) {\n            if (fundIndex[loan] == bytes32(0)) {\n                require(token.transfer(loans[loan].lender, loans[loan].principal));\n            } else {\n                if (funds.custom(fundIndex[loan]) == false) {\n                    funds.decreaseTotalBorrow(loans[loan].principal);\n                }\n                funds.deposit(fundIndex[loan], loans[loan].principal);\n            }\n        } else if (bools[loan].withdrawn == true) {\n            if (fundIndex[loan] == bytes32(0)) {\n                require(token.transfer(loans[loan].lender, owedToLender(loan)));\n            } else {\n                if (funds.custom(fundIndex[loan]) == false) {\n                    funds.decreaseTotalBorrow(loans[loan].principal);\n                }\n                funds.deposit(fundIndex[loan], owedToLender(loan));\n            }\n            require(token.transfer(loans[loan].arbiter, fee(loan)));\n        }\n    }\n\n    \n    function liquidate(bytes32 loan, bytes32 secretHash, bytes20 pubKeyHash) external returns (bytes32 sale_) {\n    \trequire(!off(loan));\n        require(bools[loan].withdrawn == true);\n        require(msg.sender != loans[loan].borrower && msg.sender != loans[loan].lender);\n    \tif (sales.next(loan) == 0) {\n    \t\tif (now > loans[loan].loanExpiration) {\n\t    \t\trequire(bools[loan].paid == false);\n\t\t\t} else {\n\t\t\t\trequire(!safe(loan));\n\t\t\t}\n            if (funds.custom(fundIndex[loan]) == false) {\n                funds.decreaseTotalBorrow(loans[loan].principal);\n                funds.calcGlobalInterest();\n            }\n\t\t} else {\n\t\t\trequire(sales.next(loan) < 3);\n            require(now > sales.settlementExpiration(sales.saleIndexByLoan(loan, sales.next(loan) - 1))); \n            require(!sales.accepted(sales.saleIndexByLoan(loan, sales.next(loan) - 1))); \n\t\t}\n        require(token.balanceOf(msg.sender) >= ddiv(discountCollateralValue(loan)));\n        require(token.transferFrom(msg.sender, address(sales), ddiv(discountCollateralValue(loan))));\n        SecretHashes storage h = secretHashes[loan];\n        uint256 i = sales.next(loan);\n\t\tsale_ = sales.create(loan, loans[loan].borrower, loans[loan].lender, loans[loan].arbiter, msg.sender, h.secretHashAs[i], h.secretHashBs[i], h.secretHashCs[i], secretHash, pubKeyHash);\n        if (bools[loan].sale == false) { require(token.transfer(address(sales), repaid(loan))); }\n\t\tbools[loan].sale = true;\n    }\n}\n\ncontract Sales is DSMath {\n\tLoans loans;\n\tMedianizer med;\n\n    uint256 public constant SWAP_EXP = 2 hours;       \n    uint256 public constant SETTLEMENT_EXP = 4 hours; \n\n\taddress public deployer; \n\n\tmapping (bytes32 => Sale)       public sales;        \n\tmapping (bytes32 => Sig)        public borrowerSigs; \n\tmapping (bytes32 => Sig)        public lenderSigs;   \n\tmapping (bytes32 => Sig)        public arbiterSigs;  \n\tmapping (bytes32 => SecretHash) public secretHashes; \n    uint256                         public saleIndex;    \n\n    mapping (bytes32 => bytes32[])  public saleIndexByLoan; \n\n    mapping(bytes32 => bool) revealed;\n\n    ERC20 public token;\n\n    \n    struct Sale {\n        bytes32    loanIndex;\n        uint256    discountBuy;\n        address    liquidator;\n        address    borrower;\n        address    lender;\n        address    arbiter;\n        uint256    createdAt;\n        bytes20    pubKeyHash;\n        bool       set;\n        bool       accepted;\n        bool       off;\n    }\n\n    \n    struct Sig {\n        bytes refundableSig;\n        bytes seizableSig;\n    }\n\n    \n    struct SecretHash {\n        bytes32 secretHashA; \n        bytes32 secretA;     \n        bytes32 secretHashB; \n        bytes32 secretB;     \n        bytes32 secretHashC; \n        bytes32 secretC;     \n        bytes32 secretHashD; \n        bytes32 secretD;     \n    }\n\n    function discountBuy(bytes32 sale) public view returns (uint256) {\n        return sales[sale].discountBuy;\n    }\n\n    function swapExpiration(bytes32 sale) public view returns (uint256) {\n        return sales[sale].createdAt + SWAP_EXP;\n    }\n\n    function settlementExpiration(bytes32 sale) public view returns (uint256) {\n        return sales[sale].createdAt + SETTLEMENT_EXP;\n    }\n\n    function accepted(bytes32 sale) public view returns (bool) {\n        return sales[sale].accepted;\n    }\n\n    function off(bytes32 sale) public view returns (bool) {\n        return sales[sale].off;\n    }\n\n    constructor (Loans loans_, Medianizer med_, ERC20 token_) public {\n    \tdeployer = address(loans_);\n    \tloans    = loans_;\n    \tmed      = med_;\n        token    = token_;\n    }\n\n    function next(bytes32 loan) public view returns (uint256) {\n    \treturn saleIndexByLoan[loan].length;\n    }\n\n    \n    function create(\n    \tbytes32 loanIndex,\n    \taddress borrower,\n    \taddress lender,\n        address arbiter,\n        address liquidator,\n    \tbytes32 secretHashA,\n    \tbytes32 secretHashB,\n    \tbytes32 secretHashC,\n        bytes32 secretHashD,\n        bytes20 pubKeyHash\n\t) external returns(bytes32 sale) {\n    \trequire(msg.sender == address(loans));\n    \tsaleIndex = add(saleIndex, 1);\n        sale = bytes32(saleIndex);\n        sales[sale].loanIndex   = loanIndex;\n        sales[sale].borrower    = borrower;\n        sales[sale].lender      = lender;\n        sales[sale].arbiter       = arbiter;\n        sales[sale].liquidator  = liquidator;\n        sales[sale].createdAt   = now;\n        sales[sale].pubKeyHash  = pubKeyHash;\n        sales[sale].discountBuy = loans.ddiv(loans.discountCollateralValue(loanIndex));\n        sales[sale].set         = true;\n        secretHashes[sale].secretHashA = secretHashA;\n        secretHashes[sale].secretHashB = secretHashB;\n        secretHashes[sale].secretHashC = secretHashC;\n        secretHashes[sale].secretHashD = secretHashD;\n        saleIndexByLoan[loanIndex].push(sale);\n    }\n\n    \n\tfunction provideSig(\n\t\tbytes32        sale,\n\t\tbytes calldata refundableSig,\n\t\tbytes calldata seizableSig\n\t) external {\n\t\trequire(sales[sale].set);\n\t\trequire(now < settlementExpiration(sale));\n\t\tif (msg.sender == sales[sale].borrower) {\n\t\t\tborrowerSigs[sale].refundableSig = refundableSig;\n\t\t\tborrowerSigs[sale].seizableSig   = seizableSig;\n\t\t} else if (msg.sender == sales[sale].lender) {\n\t\t\tlenderSigs[sale].refundableSig = refundableSig;\n\t\t\tlenderSigs[sale].seizableSig   = seizableSig;\n\t\t} else if (msg.sender == sales[sale].arbiter) {\n\t\t\tarbiterSigs[sale].refundableSig = refundableSig;\n\t\t\tarbiterSigs[sale].seizableSig   = seizableSig;\n\t\t} else {\n\t\t\trevert();\n\t\t}\n\t}\n\n    \n    function provideSecret(bytes32 sale, bytes32 secret_) public {\n        require(sales[sale].set);\n        bytes32 secretHash = sha256(abi.encodePacked(secret_));\n        revealed[secretHash] = true;\n        if (secretHash == secretHashes[sale].secretHashA) { secretHashes[sale].secretA = secret_; }\n        if (secretHash == secretHashes[sale].secretHashB) { secretHashes[sale].secretB = secret_; }\n        if (secretHash == secretHashes[sale].secretHashC) { secretHashes[sale].secretC = secret_; }\n        if (secretHash == secretHashes[sale].secretHashD) { secretHashes[sale].secretD = secret_; }\n    }\n\n    \n    function hasSecrets(bytes32 sale) public view returns (bool) {\n        uint8 numCorrectSecrets = 0;\n        if (revealed[secretHashes[sale].secretHashA]) { numCorrectSecrets += 1; }\n        if (revealed[secretHashes[sale].secretHashB]) { numCorrectSecrets += 1; }\n        if (revealed[secretHashes[sale].secretHashC]) { numCorrectSecrets += 1; }\n        return (numCorrectSecrets >= 2);\n    }\n\n    \n\tfunction accept(bytes32 sale) public {\n        require(!accepted(sale));\n        require(!off(sale));\n\t\trequire(hasSecrets(sale));\n\t\trequire(revealed[secretHashes[sale].secretHashD]);\n        sales[sale].accepted = true;\n\n        uint256 available = add(sales[sale].discountBuy, loans.repaid(sales[sale].loanIndex));\n        uint256 amount = min(available, loans.owedToLender(sales[sale].loanIndex));\n\n        require(token.transfer(sales[sale].lender, amount));\n        available = sub(available, amount);\n\n        if (available >= add(loans.fee(sales[sale].loanIndex), loans.penalty(sales[sale].loanIndex))) {\n            if (sales[sale].arbiter != address(0)) {\n                require(token.transfer(sales[sale].arbiter, loans.fee(sales[sale].loanIndex)));\n            }\n            require(token.approve(address(med), loans.penalty(sales[sale].loanIndex)));\n            med.fund(loans.penalty(sales[sale].loanIndex), token);\n            available = sub(available, add(loans.fee(sales[sale].loanIndex), loans.penalty(sales[sale].loanIndex)));\n        } else if (available > 0) {\n            require(token.approve(address(med), available));\n            med.fund(available, token);\n            available = 0;\n        }\n\n        if (available > 0) { require(token.transfer(sales[sale].borrower, available)); }\n\t}\n\n    function provideSecretsAndAccept(bytes32 sale, bytes32[3] calldata secrets_) external {\n        provideSecret(sale, secrets_[0]);\n        provideSecret(sale, secrets_[1]);\n        provideSecret(sale, secrets_[2]);\n        accept(sale);\n    }\n\n    \n\tfunction refund(bytes32 sale) external {\n        require(!accepted(sale));\n        require(!off(sale));\n\t\trequire(now > settlementExpiration(sale));\n\t\trequire(sales[sale].discountBuy > 0);\n        sales[sale].off = true;\n\t\trequire(token.transfer(sales[sale].liquidator, sales[sale].discountBuy));\n        if (next(sales[sale].loanIndex) == 3) {\n            require(token.transfer(sales[sale].borrower, loans.repaid(sales[sale].loanIndex)));\n        }\n\t}\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"loan\",\"type\":\"bytes32\"}],\"name\":\"next\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sales\",\"outputs\":[{\"name\":\"loanIndex\",\"type\":\"bytes32\"},{\"name\":\"discountBuy\",\"type\":\"uint256\"},{\"name\":\"liquidator\",\"type\":\"address\"},{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"pubKeyHash\",\"type\":\"bytes20\"},{\"name\":\"set\",\"type\":\"bool\"},{\"name\":\"accepted\",\"type\":\"bool\"},{\"name\":\"off\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"loanIndex\",\"type\":\"bytes32\"},{\"name\":\"borrower\",\"type\":\"address\"},{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"liquidator\",\"type\":\"address\"},{\"name\":\"secretHashA\",\"type\":\"bytes32\"},{\"name\":\"secretHashB\",\"type\":\"bytes32\"},{\"name\":\"secretHashC\",\"type\":\"bytes32\"},{\"name\":\"secretHashD\",\"type\":\"bytes32\"},{\"name\":\"pubKeyHash\",\"type\":\"bytes20\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleIndexByLoan\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"hasSecrets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SETTLEMENT_EXP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"},{\"name\":\"secret_\",\"type\":\"bytes32\"}],\"name\":\"provideSecret\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"off\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"},{\"name\":\"secrets_\",\"type\":\"bytes32[3]\"}],\"name\":\"provideSecretsAndAccept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"discountBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"swapExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"arbiterSigs\",\"outputs\":[{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"accepted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"settlementExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"},{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"name\":\"provideSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lenderSigs\",\"outputs\":[{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"secretHashes\",\"outputs\":[{\"name\":\"secretHashA\",\"type\":\"bytes32\"},{\"name\":\"secretA\",\"type\":\"bytes32\"},{\"name\":\"secretHashB\",\"type\":\"bytes32\"},{\"name\":\"secretB\",\"type\":\"bytes32\"},{\"name\":\"secretHashC\",\"type\":\"bytes32\"},{\"name\":\"secretC\",\"type\":\"bytes32\"},{\"name\":\"secretHashD\",\"type\":\"bytes32\"},{\"name\":\"secretD\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"borrowerSigs\",\"outputs\":[{\"name\":\"refundableSig\",\"type\":\"bytes\"},{\"name\":\"seizableSig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SWAP_EXP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sale\",\"type\":\"bytes32\"}],\"name\":\"accept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"cmul\",\"outputs\":[{\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"loans_\",\"type\":\"address\"},{\"name\":\"med_\",\"type\":\"address\"},{\"name\":\"token_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Sales","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000293553c60d59bc5fa2fe29f77446f589e3a2fd5000000000000000000000000010d2f250a30dc78f3b418730e6aae4c1cf69588900000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359","Library":"","LicenseType":"","SwarmSource":"bzzr://55aff55bf1e5a93a882340237f0b543126074b16b0592c1d69e6c76512e0bd35"}]}