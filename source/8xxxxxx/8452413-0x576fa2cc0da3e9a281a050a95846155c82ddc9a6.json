{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(msg.sender);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\ncontract Pausable is PauserRole {\n    \n    event Paused(address account);\n\n    \n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \n    constructor () internal {\n        _paused = false;\n    }\n\n    \n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    \n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    \n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    \n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    \n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n\ninterface IDistribution {\n    event RewardAssigned(uint256 periodEnd, address indexed masternode, uint256 value);\n    event RewardCollected(uint256 periodEnd, address indexed masternode, uint256 value);\n    event RewardSet(address indexed masternode, uint256 value);\n\n    function rewardOf(address account) external view returns (uint256);\n    function periodEndOf(address account) external view returns (uint256);\n\n    function assignRewards(uint256 periodEnd, address[] calldata accounts, uint256[] calldata values) external returns (bool);\n    function encodedAssignRewards(uint256 periodEnd, uint160 lotSize, uint256[] calldata rewards) external returns (bool);\n    function collect() external returns (bool);\n    function collectRewards(address[] calldata accounts) external returns (bool);\n    function clear() external returns (bool);\n}\n\ncontract ManagerRole {\n    using Roles for Roles.Role;\n\n    event ManagerAdded(address indexed account);\n    event ManagerRemoved(address indexed account);\n\n    Roles.Role private _manager;\n\n    \n    modifier onlyManager() {\n        require(_isManager(msg.sender));\n        _;\n    }\n\n    function _addManager(address account) internal {\n        _manager.add(account);\n        emit ManagerAdded(account);\n    }\n\n    function _removeManager(address account) internal {\n        _manager.remove(account);\n        emit ManagerRemoved(account);\n    }\n\n    function _isManager(address account) internal view returns (bool) {\n        return _manager.has(account);\n    }\n}\n\ncontract Distribution is IDistribution, ManagerRole, Ownable, Pausable {\n    using SafeMath for uint256;\n\n    struct AccountReward {\n        uint256 reward;\n        uint256 periodEnd;\n    }\n\n    \n    mapping(address => AccountReward) public _rewards;\n\n    \n    IERC20 private _swmERC20;\n\n    \n    constructor(address swmERC20) public {\n        _swmERC20 = IERC20(swmERC20);\n    }\n\n    \n    \n    function rewardOf(address account) external view returns (uint256) {\n        return _rewards[account].reward;\n    }\n\n    \n    function periodEndOf(address account) external view returns (uint256) {\n        return _rewards[account].periodEnd;\n    }\n\n    \n    function assignRewards(uint256 periodEnd, address[] calldata accounts, uint256[] calldata values) external whenNotPaused onlyOwnerOrManager returns (bool) {\n        require(accounts.length != 0, \"Accounts length is zero\");\n        require(accounts.length == values.length, \"Lengths difference\");\n        require(periodEnd < now, \"Period end is in future\");\n\n        uint256 sumValues = 0;\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _assign(periodEnd, accounts[i], values[i]);\n\n            sumValues = sumValues.add(values[i]);\n        }\n\n        require(_swmERC20.transferFrom(msg.sender, address(this), sumValues));\n\n        return true;\n    }\n\n    \n    function encodedAssignRewards(uint256 periodEnd, uint160 lotSize, uint256[] calldata rewards) external whenNotPaused onlyOwnerOrManager returns (bool) {\n        require(rewards.length != 0, \"Values length is zero\");\n        require(periodEnd < now, \"Period end is in future\");\n\n        uint256 count = rewards.length;\n        uint256 sumValues = 0;\n\n        for (uint256 i = 0; i < count; i++) {\n            uint256 reward = rewards[i];\n            uint256 value = (reward >> 160) * lotSize;\n            address to = address(reward & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            _assign(periodEnd, to, value);\n\n            sumValues = sumValues.add(value);\n        }\n\n        require(_swmERC20.transferFrom(msg.sender, address(this), sumValues), \"Transfer from failed\");\n\n        return true;\n    }\n\n    \n    function setRewards(address[] calldata accounts, uint256[] calldata values) external whenPaused onlyOwner returns (bool) {\n        require(accounts.length != 0, \"Accounts length is zero\");\n        require(accounts.length == values.length, \"Lengths difference\");\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _set(accounts[i], values[i]);\n        }\n\n        return true;\n    }\n\n    \n    function collect() external whenNotPaused returns (bool) {\n        _collect(msg.sender);\n\n        return true;\n    }\n\n    \n    function collectRewards(address[] calldata accounts) external onlyOwner returns (bool) {\n        require(accounts.length != 0, \"Accounts length is zero\");\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _collect(accounts[i]);\n        }\n\n        return true;\n    }\n\n    \n    function clear() external onlyOwner returns (bool) {\n        return _swmERC20.transfer(msg.sender, _swmERC20.balanceOf(address(this)));\n    }\n\n    \n    \n    function isManager(address account) external view returns (bool) {\n        return _isManager(account);\n    }\n\n    \n    function addManager(address account) external onlyOwner {\n        _addManager(account);\n    }\n\n    \n    function removeManager(address account) external onlyOwner {\n        _removeManager(account);\n    }\n\n    \n    modifier onlyOwnerOrManager() {\n        require(isOwner() || _isManager(msg.sender), \"Not Owner or Manager\");\n        _;\n    }\n\n    \n    function _collect(address account) internal {\n        require(_rewards[account].reward != 0, \"Reward is zero\");\n\n        uint256 reward = _rewards[account].reward;\n        uint256 periodEnd = _rewards[account].periodEnd;\n\n        delete _rewards[account].reward;\n\n        require(_swmERC20.transfer(account, reward));\n\n        emit RewardCollected(periodEnd, account, reward);\n    }\n\n    function _assign(uint256 periodEnd, address account, uint256 value) internal {\n        require(value != 0, \"Value is zero\");\n        require(account != address(0), \"Account address is zero\");\n        require(periodEnd > _rewards[account].periodEnd, \"Period end less than saved for account\");\n\n        _rewards[account].reward = _rewards[account].reward.add(value);\n        _rewards[account].periodEnd = periodEnd;\n\n        emit RewardAssigned(periodEnd, account, value);\n    }\n\n    function _set(address account, uint256 value) internal {\n        require(account != address(0), \"Account address is zero\");\n\n        _rewards[account].reward = value;\n\n        emit RewardSet(account, value);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clear\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodEnd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"setRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodEnd\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"assignRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"periodEndOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"collectRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"lotSize\",\"type\":\"uint160\"},{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"name\":\"encodedAssignRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swmERC20\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodEnd\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masternode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodEnd\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masternode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masternode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RewardSet\",\"type\":\"event\"}]","ContractName":"Distribution","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003505f494c3f0fed0b594e01fa41dd3967645ca39","Library":"","LicenseType":"","SwarmSource":"bzzr://8e2d31c7c58550afa396d194ab7487576f27f1d81e96146b279985408ad6a3eb"}]}