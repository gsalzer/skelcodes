{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaUpgradeBeaconEnvoyInterface {\r\n  function getImplementation(address beacon) external view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaUpgradeBeaconController\r\n * @author 0age\r\n * @notice This contract has exclusive control over modifications to the stored\r\n * implementation address on controlled \"upgrade beacon\" contracts. It is an\r\n * owned contract, where ownership can be transferred to another contract - that\r\n * way, the upgrade mechanism itself can be \"upgraded\". Apart from the ownable\r\n * methods, this contract is deliberately simple and only has one non-view\r\n * method - `upgrade`. Timelocks or other upgrade conditions will be managed by\r\n * the owner of this contract.\r\n */\r\ncontract DharmaUpgradeBeaconController {\r\n  // Fire an event whenever ownership of this contract changes.\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  // Fire an event any time a new implementation is set on an upgrade beacon.\r\n  event Upgraded(\r\n    address indexed upgradeBeacon,\r\n    address oldImplementation,\r\n    bytes32 oldImplementationCodeHash,\r\n    address newImplementation,\r\n    bytes32 newImplementationCodeHash\r\n  );\r\n\r\n  // Store address of owner - ownership modeled after OpenZeppelin's `Ownable`.\r\n  address private _owner;\r\n\r\n  // Store a mapping of the implementation code hash at the time of the last\r\n  // upgrade for each beacon. This can be used by calling contracts to verify\r\n  // that the implementation has not been altered since it was initially set.\r\n  mapping(address => bytes32) private _codeHashAtLastUpgrade;\r\n\r\n  // The Upgrade Beacon Envoy checks a beacon's implementation, used for events. \r\n  DharmaUpgradeBeaconEnvoyInterface private constant _UPGRADE_BEACON_ENVOY = (\r\n    DharmaUpgradeBeaconEnvoyInterface(\r\n      0x000000000067503c398F4c9652530DBC4eA95C02\r\n    )\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, set the transaction submitter as the initial\r\n   * owner of this contract and verify the runtime code of the referenced\r\n   * upgrade beacon envoy via `EXTCODEHASH`.\r\n   */\r\n  constructor() public {\r\n    // Set the transaction submitter as the initial owner of this contract.\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), tx.origin);\r\n    \r\n    // Ensure the upgrade beacon envoy has the expected runtime code hash.\r\n    address envoy = address(_UPGRADE_BEACON_ENVOY);\r\n    bytes32 envoyCodeHash;\r\n    assembly { envoyCodeHash := extcodehash(envoy)}\r\n    require(\r\n      envoyCodeHash == bytes32(\r\n        0x7332d06692fd32b21bdd8b8b7a0a3f0de5cf549668cbc4498fc6cfaa453f1176\r\n      ),\r\n      \"Upgrade Beacon Envoy runtime code is incorrect.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new implementation address on an upgrade beacon contract.\r\n   * This function may only be called by the owner of this contract.\r\n   * @param beacon Address of upgrade beacon to set the new implementation on.\r\n   * @param implementation The address of the new implementation.\r\n   */\r\n  function upgrade(address beacon, address implementation) external onlyOwner {\r\n    // Ensure that the implementaton contract is not the null address.\r\n    require(implementation != address(0), \"Must specify an implementation.\");\r\n\r\n    // Ensure that the implementation contract has code via extcodesize.\r\n    uint256 implementationSize;\r\n    assembly { implementationSize := extcodesize(implementation) }\r\n    require(implementationSize > 0, \"Implementation must have contract code.\");\r\n\r\n    // Ensure that the beacon contract is not the null address.\r\n    require(beacon != address(0), \"Must specify an upgrade beacon.\");\r\n\r\n    // Ensure that the upgrade beacon contract has code via extcodesize.\r\n    uint256 beaconSize;\r\n    assembly { beaconSize := extcodesize(beacon) }\r\n    require(beaconSize > 0, \"Upgrade beacon must have contract code.\");\r\n\r\n    // Update the upgrade beacon with the new implementation address.\r\n    _update(beacon, implementation);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n   * This function may only be called by the owner of this contract.\r\n   * @param newOwner Address of the new owner to set.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership of the contract to the null account, thereby\r\n   * preventing it from being used to perform upgrades in the future. This\r\n   * function may only be called by the owner of this contract.\r\n   */\r\n  function renounceOwnership() external onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the existing implementation on a given\r\n   * beacon. This is accomplished via a staticcall to the upgrade beacon envoy,\r\n   * which in turn performs a staticcall into the given beacon and passes along\r\n   * the returned implementation address.\r\n   * @param beacon Address of the upgrade beacon to check for an implementation.\r\n   * @return implementation Address of the implementation.\r\n   */\r\n  function getImplementation(\r\n    address beacon\r\n  ) external view returns (address implementation) {\r\n    // Perform a staticcall into envoy, supplying the beacon as the argument.\r\n    implementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the runtime code hash of a beacon's\r\n   * implementation contract at the time it was last updated. This can be used\r\n   * by other callers to verify that the implementation has not been altered\r\n   * since it was last updated by comparing this value to the current runtime\r\n   * code hash of the beacon's implementation contract. Note that this function\r\n   * will return `bytes32(0)` in the event the supplied beacon has not yet been\r\n   * updated.\r\n   * @param beacon Address of the upgrade beacon to check for a code hash.\r\n   * @return codeHashAtLastUpgrade Runtime code hash of the implementation\r\n   * contract when the beacon was last updated.\r\n   */\r\n  function getCodeHashAtLastUpgrade(\r\n    address beacon\r\n  ) external view returns (bytes32 codeHashAtLastUpgrade) {\r\n    // Return the code hash that was set when the given beacon was last updated.\r\n    codeHashAtLastUpgrade = _codeHashAtLastUpgrade[beacon];\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the current owner.\r\n   * @return The address of the owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the caller is the current owner.\r\n   * @return True if the caller is the current owner, else false.\r\n   */\r\n  function isOwner() external view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to perform an update to a given upgrade beacon and\r\n   * determine the runtime code hash of both the old and the new implementation.\r\n   * The latest code hash for the new implementation of the given beacon will be\r\n   * updated, and an event containing the beacon, the old and new implementation\r\n   * addresses, and the old and new implementation runtime code hashes will be\r\n   * emitted.\r\n   * @param beacon Address of upgrade beacon to set the new implementation on.\r\n   * @param implementation The address of the new implementation.\r\n   */\r\n  function _update(address beacon, address implementation) private {\r\n    // Get the address of the current implementation set on the upgrade beacon.\r\n    address oldImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n\r\n    // Get the runtime code hash for the current implementation.\r\n    bytes32 oldImplementationCodeHash;\r\n    assembly { oldImplementationCodeHash := extcodehash(oldImplementation) }\r\n\r\n    // Call into beacon and supply address of new implementation to update it.\r\n    (bool success,) = beacon.call(abi.encode(implementation));\r\n\r\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\r\n    if (!success) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n\r\n    // Get address of the new implementation that was set on the upgrade beacon.\r\n    address newImplementation = _UPGRADE_BEACON_ENVOY.getImplementation(beacon);\r\n\r\n    // Get the runtime code hash for the new implementation.\r\n    bytes32 newImplementationCodeHash;\r\n    assembly { newImplementationCodeHash := extcodehash(newImplementation) }\r\n\r\n    // Set runtime code hash of the new implementation for the given beacon.\r\n    _codeHashAtLastUpgrade[beacon] = newImplementationCodeHash;\r\n\r\n    // Emit an event to signal that the upgrade beacon was updated.\r\n    emit Upgraded(\r\n      beacon,\r\n      oldImplementation,\r\n      oldImplementationCodeHash,\r\n      newImplementation,\r\n      newImplementationCodeHash\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"getCodeHashAtLastUpgrade\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeHashAtLastUpgrade\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upgradeBeacon\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldImplementationCodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newImplementationCodeHash\",\"type\":\"bytes32\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]","ContractName":"DharmaUpgradeBeaconController","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://20446861726d6155706772616465426561636f6e436f6e74726f6c6c65722020"}]}