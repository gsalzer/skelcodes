{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaKeyRegistryInterface {\r\n  event NewGlobalKey(address oldGlobalKey, address newGlobalKey);\r\n\r\n  function setGlobalKey(address globalKey, bytes calldata signature) external;\r\n  function setSpecificKey(address account, address specificKey) external;\r\n  function getKey() external view returns (address key);\r\n  function getKeyForUser(address account) external view returns (address key);\r\n  function getGlobalKey() external view returns (address globalKey);\r\n  function getSpecificKey(address account) external view returns (address specificKey);\r\n}\r\n\r\n\r\nlibrary ECDSA {\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initialize contract by setting transaction submitter as initial owner.\r\n   */\r\n  constructor() internal {\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() public onlyOwner {\r\n    _newPotentialOwner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() public {\r\n    require(\r\n      msg.sender != _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaKeyRegistryV2\r\n * @author 0age\r\n * @notice The Dharma Key Registry is an owned contract that holds the public\r\n * user signing keys that will be used by the Dharma Smart Wallet. Each time a\r\n * particular Dharma Smart Wallet instance needs to validate a signature, it\r\n * will first retrieve the public address for the secondary signing key\r\n * associated with that wallet from the Dharma Key Registry. If a specific key\r\n * has not been set for that smart wallet, it will return the global public key.\r\n * Otherwise, it will return the specific signing key. Additional view functions\r\n * are also provided for retrieving public keys directly. Only the owner may\r\n * update these keys. Also, note that the V2 key registry includes an additional\r\n * mapping to track all global keys that have been used, and only allows a given\r\n * global key to be set one time.\r\n */\r\ncontract DharmaKeyRegistryV2 is TwoStepOwnable, DharmaKeyRegistryInterface {\r\n  using ECDSA for bytes32;\r\n\r\n  // The global public key serves as the default signing key.\r\n  address private _globalKey;\r\n\r\n  // Specific keys may also be set on a per-caller basis.\r\n  mapping (address => address) private _specificKeys;\r\n\r\n  // Maintain a mapping of all used global keys (to prevent reuse).\r\n  mapping (address => bool) private _usedGlobalKeys;\r\n\r\n  /**\r\n   * @notice In the constructor, set the initial global key and the initial\r\n   * owner to tx.origin.\r\n   */\r\n  constructor() public {\r\n    // Initially set the global key to the account of the transaction submitter.\r\n    _registerGlobalKey(tx.origin);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new global key. This method may only be called by the owner,\r\n   * and a signature must also be provided in order to verify that the provided\r\n   * global public key has a corresponding private key that can be used to sign\r\n   * messages.\r\n   * @param globalKey address The new global public key.\r\n   * @param signature bytes A signature of a message hash containing the address\r\n   * of this contract, the new global key, and a specific message, that must\r\n   * resolve to the supplied global key.\r\n   */\r\n  function setGlobalKey(\r\n    address globalKey,\r\n    bytes calldata signature\r\n  ) external onlyOwner {\r\n    // Ensure that the provided global key is not the null address.\r\n    require(globalKey != address(0), \"A global key must be supplied.\");\r\n\r\n    // Message hash constructed according to EIP-191-0x45 to prevent replays.\r\n    bytes32 messageHash = keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        globalKey,\r\n        \"This signature demonstrates that the supplied signing key is valid.\"\r\n      )\r\n    );\r\n\r\n    // Recover the signer of the message hash using the provided signature.\r\n    address signer = messageHash.toEthSignedMessageHash().recover(signature);\r\n\r\n    // Ensure that the provided signature resolves to the provided global key.\r\n    require(globalKey == signer, \"Invalid signature for supplied global key.\");\r\n\r\n    // Update global key to the provided global key and prevent future reuse.\r\n    _registerGlobalKey(globalKey);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new specific key for a particular account. This method may\r\n   * only be called by the owner. Signatures are not required in order to make\r\n   * setting specific keys more efficient at scale. Providing the null address\r\n   * for the specific key will remove a specific key from the given account.\r\n   * @param account address The account to set the new specific public key for.\r\n   * @param specificKey address The new specific public key.\r\n   */\r\n  function setSpecificKey(\r\n    address account,\r\n    address specificKey\r\n  ) external onlyOwner {\r\n    // Update specific key for provided account to the provided specific key.\r\n    _specificKeys[account] = specificKey;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the public key associated with the caller of this function. If\r\n   * a specific key is set for the caller, it will be returned; otherwise, the\r\n   * global key will be returned.\r\n   * @return The public key to use for the caller.\r\n   */\r\n  function getKey() external view returns (address key) {\r\n    // Retrieve the specific key, if any, for the caller.\r\n    key = _specificKeys[msg.sender];\r\n\r\n    // Fall back to the global key in the event that no specific key is set.\r\n    if (key == address(0)) {\r\n      key = _globalKey;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get the public key associated with a particular account. If a\r\n   * specific key is set for the account, it will be returned; otherwise, the\r\n   * global key will be returned.\r\n   * @param account address The account to find the public key for.\r\n   * @return The public key to use for the provided account.\r\n   */\r\n  function getKeyForUser(address account) external view returns (address key) {\r\n    // Retrieve the specific key, if any, for the specified account.\r\n    key = _specificKeys[account];\r\n\r\n    // Fall back to the global key in the event that no specific key is set.\r\n    if (key == address(0)) {\r\n      key = _globalKey;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get the global public key.\r\n   * @return The global public key.\r\n   */\r\n  function getGlobalKey() external view returns (address globalKey) {\r\n    // Retrieve and return the global key.\r\n    globalKey = _globalKey;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the specific public key associated with the supplied account.\r\n   * The call will revert if a specific public key is not set for the account.\r\n   * @param account address The account to find the specific public key for.\r\n   * @return The specific public key set on the provided account, if one exists.\r\n   */\r\n  function getSpecificKey(\r\n    address account\r\n  ) external view returns (address specificKey) {\r\n    // Retrieve the specific key, if any, for the account.\r\n    specificKey = _specificKeys[account];\r\n\r\n    // Revert in the event that there is no specific key set.\r\n    require(\r\n      specificKey != address(0),\r\n      \"No specific key set for the provided account.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set a new global key once contract ownership\r\n   * and signature validity have both been checked, or during contract creation.\r\n   * The provided global key must not have been used previously, and once set it\r\n   * will be registered as having been used.\r\n   * @param globalKey address The new global public key.\r\n   */\r\n  function _registerGlobalKey(address globalKey) internal {\r\n    // Ensure that the global key has not been used previously.\r\n    require(!_usedGlobalKeys[globalKey], \"Key has been used previously.\");\r\n\r\n    // Emit an event signifying that the global key has been modified.\r\n    emit NewGlobalKey(_globalKey, globalKey);\r\n\r\n    // Update the global key to the provided global key.\r\n    _globalKey = globalKey;\r\n\r\n    // Mark the key as having been used previously.\r\n    _usedGlobalKeys[globalKey] = true;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSpecificKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"specificKey\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"globalKey\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"setGlobalKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"globalKey\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getKeyForUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"specificKey\",\"type\":\"address\"}],\"name\":\"setSpecificKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGlobalKey\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGlobalKey\",\"type\":\"address\"}],\"name\":\"NewGlobalKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DharmaKeyRegistryV2","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://202020202020446861726d614b65795265676973747279563220202020202020"}]}