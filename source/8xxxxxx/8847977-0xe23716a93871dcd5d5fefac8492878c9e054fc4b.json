{"status":"1","message":"OK","result":[{"SourceCode":"// FIREDATE - Starcrossed lovers meet here\r\n\r\npragma solidity ^0.4.11;\r\n\r\ncontract Token {\r\n/* This is a slight change to the ERC20 base standard.\r\nfunction totalSupply() constant returns (uint256 supply);\r\nis replaced with:\r\nuint256 public totalSupply;\r\nThis automatically creates a getter function for the totalSupply.\r\nThis is moved to the base contract since public getter functions are not\r\ncurrently recognised as an implementation of the matching abstract\r\nfunction by the compiler.\r\n*/\r\n/// total amount of tokens\r\nuint256 public totalSupply;\r\n\r\n/// @param _owner The address from which the balance will be retrieved\r\n/// @return The balance\r\nfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n/// @notice send '_value' token to '_to' from 'msg.sender'\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n/// @notice send '_value' token to '_to' from '_from' on the condition it is approved by '_from'\r\n/// @param _from The address of the sender\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n/// @notice 'msg.sender' approves '_spender' to spend '_value' tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @param _value The amount of tokens to be approved for transfer\r\n/// @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n/// @param _owner The address of the account owning tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n/* function assert(bool assertion) internal { */\r\n/*   if (!assertion) { */\r\n/*     revert(); */\r\n/*   } */\r\n/* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\nfunction safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\nuint256 z = x + y;\r\nassert((z >= x) && (z >= y));\r\nreturn z;\r\n}\r\n\r\nfunction safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\r\nassert(x >= y);\r\nuint256 z = x - y;\r\nreturn z;\r\n}\r\n\r\nfunction safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\r\nuint256 z = x * y;\r\nassert((x == 0)||(z/x == y));\r\nreturn z;\r\n}\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n//Default assumes totalSupply can't be over max (2^256 - 1).\r\n//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n//Replace the if with this one instead.\r\n//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\nif (balances[msg.sender] >= _value && _value > 0) {\r\nbalances[msg.sender] -= _value;\r\nbalances[_to] += _value;\r\nemit Transfer(msg.sender, _to, _value);\r\nreturn true;\r\n} else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n//same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\nbalances[_to] += _value;\r\nbalances[_from] -= _value;\r\nallowed[_from][msg.sender] -= _value;\r\nemit Transfer(_from, _to, _value);\r\nreturn true;\r\n} else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\nreturn balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nemit Approval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\nreturn allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract FIREDATE is StandardToken, SafeMath {\r\n\r\n// metadata\r\nstring public constant name = \"FIREDATE\";\r\nstring public constant symbol = \"ðŸ”¥\"; // FIRE emoji\r\nuint256 public constant decimals = 0; // Whole tokens only\r\nstring public version = \"1.0\";\r\n\r\n// important addresses\r\naddress public depositAddress;      // deposit address for ETH for ICO owner\r\n\r\n// crowdsale params\r\nbool public isFinalized;            // true when ICO finalized and successful\r\nuint256 public targetEth;           // target ETH to raise\r\nuint256 public fundingStartBlock;   // when to start allowing funding\r\nuint256 public fundingEndBlock;     // when to stop allowing funding\r\n\r\n// events\r\nevent CreateFiredate(string _name);\r\nevent Contribute(address _sender, uint256 _value);\r\nevent FinalizeSale(address _sender);\r\nevent RefundContribution(address _sender, uint256 _value);\r\nevent ClaimTokens(address _sender, uint256 _value);\r\n\r\n// calculated values\r\nmapping (address => uint256) contributions;    // ETH contributed per address\r\nuint256 contributed;      // total ETH contributed\r\n\r\n// constructor\r\nfunction Firedate() public{\r\nisFinalized = false;\r\ntotalSupply = 21040868;\r\ntargetEth = 888 * 1000000000000000000; // Raising 888 ETHER\r\ndepositAddress = 0x509613c84672B7cef3c0838243134b5B02Df0365;\r\nfundingStartBlock = 8848888;\r\nfundingEndBlock = 8888888;\r\n// log\r\nemit CreateFiredate(name);}\r\n\r\n/// Accepts ETH from a contributor\r\nfunction contribute() payable external {\r\nif (block.number < fundingStartBlock) revert();    // not yet begun?\r\nif (block.number > fundingEndBlock) revert();      // already ended?\r\nif (msg.value == 0) revert();                  // no ETH sent in?\r\n\r\n// Add to contributions\r\ncontributions[msg.sender] += msg.value;\r\ncontributed += msg.value;\r\n\r\n// log\r\nemit Contribute(msg.sender, msg.value);  // logs contribution\r\n}\r\n\r\n/// Finalizes the funding and sends the ETH to deposit address\r\nfunction finalizeFunding() external {\r\nif (isFinalized) revert();                       // already succeeded?\r\nif (msg.sender != depositAddress) revert();      // wrong sender?\r\nif (block.number <= fundingEndBlock) revert();   // not yet finished?\r\nif (contributed < targetEth) revert();             // not enough raised?\r\n\r\nisFinalized = true;\r\n\r\n// send to deposit address\r\nif (!depositAddress.send(targetEth)) revert();\r\n\r\n// log\r\nemit FinalizeSale(msg.sender);\r\n}\r\n\r\n/// Allows contributors to claim their tokens and/or a refund. If funding failed then they get back all their Ether, otherwise they get back any excess Ether\r\nfunction claimTokensAndRefund() external {\r\nif (0 == contributions[msg.sender]) revert();    // must have previously contributed\r\nif (block.number < fundingEndBlock) revert();    // not yet done?\r\n\r\n// if not enough funding\r\nif (contributed < targetEth) {\r\n// refund my full contribution\r\nif (!msg.sender.send(contributions[msg.sender])) revert();\r\nemit RefundContribution(msg.sender, contributions[msg.sender]);\r\n} else {\r\n// calculate how many tokens I get\r\nbalances[msg.sender] = safeMult(totalSupply, contributions[msg.sender]) / contributed;\r\n// refund excess ETH\r\nif (!msg.sender.send(contributions[msg.sender] - (safeMult(targetEth, contributions[msg.sender]) / contributed))) revert();\r\nemit ClaimTokens(msg.sender, balances[msg.sender]);\r\n}\r\n\r\ncontributions[msg.sender] = 0;\r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Firedate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokensAndRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"CreateFiredate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Contribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"FinalizeSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"RefundContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ClaimTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FIREDATE","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://138689b806912b974b227e912f7cf0a5df77f756762267104e824ec56f79c4d3"}]}