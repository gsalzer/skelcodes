{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/extensions/BrokerExtension.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\ninterface Broker {\r\n    function owner() external returns (address);\r\n    function isAdmin(address _user) external returns(bool);\r\n    function markNonce(uint256 _nonce) external;\r\n}\r\n\r\ncontract BrokerExtension {\r\n    Broker public broker;\r\n\r\n    modifier onlyAdmin() {\r\n        require(broker.isAdmin(msg.sender), \"Invalid msg.sender\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(broker.owner() == msg.sender, \"Invalid msg.sender\");\r\n        _;\r\n    }\r\n\r\n    function initializeBroker(address _brokerAddress) external {\r\n        require(_brokerAddress != address(0), \"Invalid _brokerAddress\");\r\n        require(address(broker) == address(0), \"Broker already set\");\r\n        broker = Broker(_brokerAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/math/SafeMath.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface MarketDapp {\r\n    // Returns the address to approve tokens for\r\n    function tokenReceiver(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses) external view returns(address);\r\n    function trade(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses, address payable recipient) external payable;\r\n}\r\n\r\n/// @title Util functions for the BrokerV2 contract for Switcheo Exchange\r\n/// @author Switcheo Network\r\n/// @notice Functions were moved from the BrokerV2 contract into this contract\r\n/// so that the BrokerV2 contract would not exceed the maximum contract size of\r\n/// 24 KB.\r\nlibrary Utils {\r\n    using SafeMath for uint256;\r\n\r\n    // The constants for EIP-712 are precompiled to reduce contract size,\r\n    // the original values are left here for reference and verification.\r\n    //\r\n    // bytes32 public constant CONTRACT_NAME = keccak256(\"Switcheo Exchange\");\r\n    // bytes32 public constant CONTRACT_VERSION = keccak256(\"2\");\r\n    // uint256 public constant CHAIN_ID = 3; // TODO: update this before deployment\r\n    // address public constant VERIFYING_CONTRACT = address(0x7CFbeEa553784500394c878D4f4f79d3B79B9d41); // TODO: pre-calculate and update this before deployment\r\n    // bytes32 public constant SALT = keccak256(\"switcheo-eth-salt\");\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"EIP712Domain(\",\r\n    //         \"string name,\",\r\n    //         \"string version,\",\r\n    //         \"uint256 chainId,\",\r\n    //         \"address verifyingContract,\",\r\n    //         \"bytes32 salt\",\r\n    //     \")\"\r\n    // ));\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n\r\n    // bytes32 public constant DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n    //     EIP712_DOMAIN_TYPEHASH,\r\n    //     CONTRACT_NAME,\r\n    //     CONTRACT_VERSION,\r\n    //     CHAIN_ID,\r\n    //     VERIFYING_CONTRACT,\r\n    //     SALT\r\n    // ));\r\n    bytes32 public constant DOMAIN_SEPARATOR = 0x376a22e062fefdc56ac08f9a26f925278e5cc27dd2ef7880765327cadbb4fa5a;\r\n\r\n    // bytes32 public constant OFFER_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Offer(\",\r\n    //         \"address maker,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant OFFER_TYPEHASH = 0xf845c83a8f7964bc8dd1a092d28b83573b35be97630a5b8a3b8ae2ae79cd9260;\r\n\r\n    // bytes32 public constant FILL_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Fill(\",\r\n    //         \"address filler,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant FILL_TYPEHASH = 0x5f59dbc3412a4575afed909d028055a91a4250ce92235f6790c155a4b2669e99;\r\n\r\n    // The Ether token address is set as the constant 0x00 for backwards\r\n    // compatibility\r\n    address private constant ETHER_ADDR = address(0);\r\n\r\n    /// @dev Validates `BrokerV2.trade` parameters to ensure trade fairness,\r\n    /// see `BrokerV2.trade` for param details.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function validateTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateMatches(_values, _addresses);\r\n        _validateFillAmounts(_values);\r\n        _validateTradeData(_values, _addresses);\r\n\r\n        // validate signatures of all fills\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            FILL_TYPEHASH,\r\n            _values[0] & ~(~uint256(0) << 8), // numOffers\r\n            (_values[0] & ~(~uint256(0) << 8)) + ((_values[0] & ~(~uint256(0) << 16)) >> 8) // numOffers + numFills\r\n        );\r\n\r\n        // validate signatures of all offers\r\n        return _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] & ~(~uint256(0) << 8) // numOffers\r\n        );\r\n    }\r\n\r\n    /// @dev Validates `BrokerV2.networkTrade` parameters to ensure trade fairness,\r\n    /// see `BrokerV2.networkTrade` for param details.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _hashes Hashes from `networkTrade`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    /// @param _operator Address of the `BrokerV2.operator`\r\n    function validateNetworkTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateNetworkTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateNetworkMatches(_values, _addresses, _operator);\r\n        _validateOfferData(_values, _addresses, _operator);\r\n\r\n        // validate signatures of all offers\r\n        return _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] & ~(~uint256(0) << 8) // numOffers\r\n        );\r\n    }\r\n\r\n    /// @dev Executes trades against external markets,\r\n    /// see `BrokerV2.networkTrade` for param details.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    /// @param _marketDapps See `BrokerV2.marketDapps`\r\n    function performNetworkTrades(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address[] memory _marketDapps\r\n    )\r\n        public\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\r\n        // i = 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & ~(~uint256(0) << 8)) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            uint256[] memory data = new uint256[](9);\r\n            data[0] = _values[i]; // match data\r\n            data[1] = data[0] & ~(~uint256(0) << 8); // offerIndex\r\n            data[2] = (data[0] & ~(~uint256(0) << 24)) >> 16; // operator.surplusAssetIndex\r\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\r\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\r\n            data[5] = ((data[3] & ~(~uint256(0) << 16)) >> 8); // maker.offerAssetIndex\r\n            data[6] = ((data[3] & ~(~uint256(0) << 24)) >> 16); // maker.wantAssetIndex\r\n            // amount of offerAssetId to take from offer is equal to the match.takeAmount\r\n            data[7] = data[0] >> 128;\r\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\r\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & ~(~uint256(0) << 128));\r\n\r\n            address[] memory assetIds = new address[](3);\r\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\r\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\r\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\r\n\r\n            uint256[] memory dataValues = new uint256[](3);\r\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\r\n            dataValues[1] = data[8]; // the propotionate wantAmount of the offer\r\n            dataValues[2] = data[0]; // match data\r\n\r\n            increments[data[2]] = _performNetworkTrade(\r\n                assetIds,\r\n                dataValues,\r\n                _marketDapps,\r\n                _addresses\r\n            );\r\n        }\r\n\r\n        return increments;\r\n    }\r\n\r\n    /// @notice Approves a token transfer\r\n    /// @param _assetId The address of the token to approve\r\n    /// @param _spender The address of the spender to approve\r\n    /// @param _amount The number of tokens to approve\r\n    function approveTokenTransfer(\r\n        address _assetId,\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have an `approve` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"approve(address,uint256)\",\r\n            _spender,\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Transfers tokens into the contract\r\n    /// @param _user The address to transfer the tokens from\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    /// @param _expectedAmount The number of tokens expected to be received,\r\n    /// this may not match `_amount`, for example, tokens which have a\r\n    /// propotion burnt on transfer will have a different amount received.\r\n    function transferTokensIn(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _expectedAmount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        uint256 initialBalance = tokenBalance(_assetId);\r\n\r\n        // Some tokens have a `transferFrom` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"transferFrom(address,address,uint256)\",\r\n            _user,\r\n            address(this),\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n\r\n        uint256 finalBalance = tokenBalance(_assetId);\r\n        uint256 transferredAmount = finalBalance.sub(initialBalance);\r\n\r\n        require(transferredAmount == _expectedAmount, \"Invalid transfer\");\r\n    }\r\n\r\n    /// @notice Transfers tokens from the contract to a user\r\n    /// @param _receivingAddress The address to transfer the tokens to\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    function transferTokensOut(\r\n        address _receivingAddress,\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have a `transfer` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n                                   \"transfer(address,uint256)\",\r\n                                   _receivingAddress,\r\n                                   _amount\r\n                               );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract\r\n    /// @param _assetId The address of the token to query\r\n    function externalBalance(address _assetId) public view returns (uint256) {\r\n        if (_assetId == ETHER_ADDR) {\r\n            return address(this).balance;\r\n        }\r\n        return tokenBalance(_assetId);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract.\r\n    /// @dev This will not work for Ether tokens, use `externalBalance` for\r\n    /// Ether tokens.\r\n    /// @param _assetId The address of the token to query\r\n    function tokenBalance(address _assetId) public view returns (uint256) {\r\n        return ERC20(_assetId).balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Validates that the specified `_hash` was signed by the specified `_user`.\r\n    /// This method supports the EIP712 specification, the older Ethereum\r\n    /// signed message specification is also supported for backwards compatibility.\r\n    /// @param _hash The original hash that was signed by the user\r\n    /// @param _user The user who signed the hash\r\n    /// @param _v The `v` component of the `_user`'s signature\r\n    /// @param _r The `r` component of the `_user`'s signature\r\n    /// @param _s The `s` component of the `_user`'s signature\r\n    /// @param _prefixed If true, the signature will be verified\r\n    /// against the Ethereum signed message specification instead of the\r\n    /// EIP712 specification\r\n    function validateSignature(\r\n        bytes32 _hash,\r\n        address _user,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixed\r\n    )\r\n        public\r\n        pure\r\n    {\r\n        bytes32 eip712Hash = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            _hash\r\n        ));\r\n\r\n        if (_prefixed) {\r\n            bytes32 prefixedHash = keccak256(abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                eip712Hash\r\n            ));\r\n            require(_user == ecrecover(prefixedHash, _v, _r, _s), \"Invalid signature\");\r\n        } else {\r\n            require(_user == ecrecover(eip712Hash, _v, _r, _s), \"Invalid signature\");\r\n        }\r\n    }\r\n\r\n    /// @dev Ensures that `_address` is not the zero address\r\n    /// @param _address The address to check\r\n    function validateAddress(address _address) public pure {\r\n        require(_address != address(0), \"Invalid address\");\r\n    }\r\n\r\n    /// @notice Executes a trade against an external market.\r\n    /// @dev The initial Ether or token balance is compared with the\r\n    /// balance after the trade to ensure that the appropriate amounts of\r\n    /// tokens were taken and an appropriate amount received.\r\n    /// The trade will fail if the number of tokens received is less than\r\n    /// expected. If the number of tokens received is more than expected than\r\n    /// the excess tokens are transferred to the `BrokerV2.operator`.\r\n    /// @param _assetIds[0] The offerAssetId of the offer\r\n    /// @param _assetIds[2] The wantAssetId of the offer\r\n    /// @param _assetIds[3] The surplusAssetId\r\n    /// @param _dataValues[0] The number of tokens offerred\r\n    /// @param _dataValues[1] The number of tokens expected to be received\r\n    /// @param _dataValues[2] Match data\r\n    /// @param _marketDapps See `BrokerV2.marketDapps`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    function _performNetworkTrade(\r\n        address[] memory _assetIds,\r\n        uint256[] memory _dataValues,\r\n        address[] memory _marketDapps,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 dappIndex = (_dataValues[2] & ~(~uint256(0) << 16)) >> 8;\r\n        MarketDapp marketDapp = MarketDapp(_marketDapps[dappIndex]);\r\n\r\n        uint256[] memory funds = new uint256[](6);\r\n        funds[0] = externalBalance(_assetIds[0]); // initialOfferTokenBalance\r\n        funds[1] = externalBalance(_assetIds[1]); // initialWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            funds[2] = externalBalance(_assetIds[2]); // initialSurplusTokenBalance\r\n        }\r\n\r\n        uint256 ethValue = 0;\r\n        address tokenReceiver;\r\n\r\n        if (_assetIds[0] != ETHER_ADDR) {\r\n            tokenReceiver = marketDapp.tokenReceiver(_assetIds, _dataValues, _addresses);\r\n            approveTokenTransfer(\r\n                _assetIds[0], // offerAssetId\r\n                tokenReceiver,\r\n                _dataValues[0] // offerAmount\r\n            );\r\n        } else {\r\n            ethValue = _dataValues[0]; // offerAmount\r\n        }\r\n\r\n        marketDapp.trade.value(ethValue)(\r\n            _assetIds,\r\n            _dataValues,\r\n            _addresses,\r\n            // use uint160 to cast `address` to `address payable`\r\n            address(uint160(address(this))) // destAddress\r\n        );\r\n\r\n        funds[3] = externalBalance(_assetIds[0]); // finalOfferTokenBalance\r\n        funds[4] = externalBalance(_assetIds[1]); // finalWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            funds[5] = externalBalance(_assetIds[2]); // finalSurplusTokenBalance\r\n        }\r\n\r\n        uint256 surplusAmount = 0;\r\n\r\n        // validate that the appropriate offerAmount was deducted\r\n        // surplusAssetId == offerAssetId\r\n        if (_assetIds[2] == _assetIds[0]) {\r\n            // surplusAmount = finalOfferTokenBalance - (initialOfferTokenBalance - offerAmount)\r\n            surplusAmount = funds[3].sub(funds[0].sub(_dataValues[0]));\r\n        } else {\r\n            // finalOfferTokenBalance == initialOfferTokenBalance - offerAmount\r\n            require(funds[3] == funds[0].sub(_dataValues[0]), \"Invalid offer asset balance\");\r\n        }\r\n\r\n        // validate that the appropriate wantAmount was credited\r\n        // surplusAssetId == wantAssetId\r\n        if (_assetIds[2] == _assetIds[1]) {\r\n            // surplusAmount = finalWantTokenBalance - (initialWantTokenBalance + wantAmount)\r\n            surplusAmount = funds[4].sub(funds[1].add(_dataValues[1]));\r\n        } else {\r\n            // finalWantTokenBalance == initialWantTokenBalance + wantAmount\r\n            require(funds[4] == funds[1].add(_dataValues[1]), \"Invalid want asset balance\");\r\n        }\r\n\r\n        // surplusAssetId != offerAssetId && surplusAssetId != wantAssetId\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            // surplusAmount = finalSurplusTokenBalance - initialSurplusTokenBalance\r\n            surplusAmount = funds[5].sub(funds[2]);\r\n        }\r\n\r\n        // set the approved token amount back to zero\r\n        if (_assetIds[0] != ETHER_ADDR) {\r\n            approveTokenTransfer(\r\n                _assetIds[0],\r\n                tokenReceiver,\r\n                0\r\n            );\r\n        }\r\n\r\n        return surplusAmount;\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the `trade` method.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    function _validateTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & ~(~uint256(0) << 8);\r\n        uint256 numFills = (_values[0] & ~(~uint256(0) << 16)) >> 8;\r\n        uint256 numMatches = (_values[0] & ~(~uint256(0) << 24)) >> 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] >> 24 == 0, \"Invalid trade input\");\r\n\r\n        // It is enforced by other checks that if a fill is present\r\n        // then it must be completely filled so there must be at least one offer\r\n        // and at least one match in this case.\r\n        // It is possible to have one offer with no matches and no fills\r\n        // but that is blocked by this check as there is no foreseeable use\r\n        // case for it.\r\n        require(\r\n            numOffers > 0 && numFills > 0 && numMatches > 0,\r\n            \"Invalid trade input\"\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 + numOffers * 2 + numFills * 2 + numMatches,\r\n            \"Invalid _values.length\"\r\n        );\r\n\r\n        require(\r\n            _hashes.length == (numOffers + numFills) * 2,\r\n            \"Invalid _hashes.length\"\r\n        );\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the `networkTrade` method.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _hashes Hashes from `networkTrade`\r\n    function _validateNetworkTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & ~(~uint256(0) << 8);\r\n        uint256 numFills = (_values[0] & ~(~uint256(0) << 16)) >> 8;\r\n        uint256 numMatches = (_values[0] & ~(~uint256(0) << 24)) >> 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] >> 24 == 0, \"Invalid networkTrade input\");\r\n\r\n        // Validate that numFills is zero because the offers\r\n        // should be filled against external orders\r\n        require(\r\n            numOffers > 0 && numMatches > 0 && numFills == 0,\r\n            \"Invalid networkTrade input\"\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 + numOffers * 2 + numFills * 2 + numMatches,\r\n            \"Invalid _values.length\"\r\n        );\r\n\r\n        require(\r\n            _hashes.length == (numOffers + numFills) * 2,\r\n            \"Invalid _hashes.length\"\r\n        );\r\n    }\r\n\r\n    /// @dev See the `BrokerV2.trade` method for an explanation of why offer\r\n    /// uniquness is required.\r\n    /// The set of offers in `_values` must be sorted such that offer nonces'\r\n    /// are arranged in a strictly ascending order.\r\n    /// This allows the validation of offer uniqueness to be done in O(N) time,\r\n    /// with N being the number of offers.\r\n    /// @param _values Values from `trade`\r\n    function _validateUniqueOffers(uint256[] memory _values) private pure {\r\n        uint256 numOffers = _values[0] & ~(~uint256(0) << 8);\r\n\r\n        uint256 prevNonce;\r\n        uint256 mask = ~(~uint256(0) << 128);\r\n\r\n        for(uint256 i = 0; i < numOffers; i++) {\r\n            uint256 nonce = (_values[i * 2 + 1] & mask) >> 56;\r\n\r\n            if (i == 0) {\r\n                // Set the value of the first nonce\r\n                prevNonce = nonce;\r\n                continue;\r\n            }\r\n\r\n            require(nonce > prevNonce, \"Invalid offer nonces\");\r\n            prevNonce = nonce;\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. fillIndexes falls within the range of fills\r\n    /// 3. offer.offerAssetId == fill.wantAssetId\r\n    /// 4. offer.wantAssetId == fill.offerAssetId\r\n    /// 5. takeAmount > 0\r\n    /// 6. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & ~(~uint256(0) << 8);\r\n        uint256 numFills = (_values[0] & ~(~uint256(0) << 16)) >> 8;\r\n\r\n        uint256 i = 1 + numOffers * 2 + numFills * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & ~(~uint256(0) << 8);\r\n            uint256 fillIndex = (_values[i] & ~(~uint256(0) << 16)) >> 8;\r\n\r\n            require(offerIndex < numOffers, \"Invalid match.offerIndex\");\r\n\r\n            require(fillIndex >= numOffers && fillIndex < numOffers + numFills, \"Invalid match.fillIndex\");\r\n\r\n            uint256 makerOfferAssetIndex = (_values[1 + offerIndex * 2] & ~(~uint256(0) << 16)) >> 8;\r\n            uint256 makerWantAssetIndex = (_values[1 + offerIndex * 2] & ~(~uint256(0) << 24)) >> 16;\r\n            uint256 fillerOfferAssetIndex = (_values[1 + fillIndex * 2] & ~(~uint256(0) << 16)) >> 8;\r\n            uint256 fillerWantAssetIndex = (_values[1 + fillIndex * 2] & ~(~uint256(0) << 24)) >> 16;\r\n\r\n            require(\r\n                _addresses[makerOfferAssetIndex * 2 + 1] == _addresses[fillerWantAssetIndex * 2 + 1],\r\n                \"offer.offerAssetId does not match fill.wantAssetId\"\r\n            );\r\n\r\n            require(\r\n                _addresses[makerWantAssetIndex * 2 + 1] == _addresses[fillerOfferAssetIndex * 2 + 1],\r\n                \"offer.wantAssetId does not match fill.offerAssetId\"\r\n            );\r\n\r\n            // require that bits(16..128) are all zero for every match\r\n            require((_values[i] & ~(~uint256(0) << 128)) >> 16 == uint256(0), \"Invalid match data\");\r\n\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            require(takeAmount > 0, \"Invalid match.takeAmount\");\r\n\r\n            uint256 offerDataB = _values[2 + offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB >> 128).mul(takeAmount).mod(offerDataB & ~(~uint256(0) << 128)) == 0,\r\n                \"Invalid amounts\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. _addresses[surplusAssetIndexes * 2] matches the operator address\r\n    /// 3. takeAmount > 0\r\n    /// 4. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    /// @param _operator Address of the `BrokerV2.operator`\r\n    function _validateNetworkMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & ~(~uint256(0) << 8);\r\n\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & ~(~uint256(0) << 8)) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & ~(~uint256(0) << 8);\r\n            uint256 surplusAssetIndex = (_values[i] & ~(~uint256(0) << 24)) >> 16;\r\n\r\n            require(offerIndex < numOffers, \"Invalid match.offerIndex\");\r\n            require(_addresses[surplusAssetIndex * 2] == _operator, \"Invalid operator address\");\r\n\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            require(takeAmount > 0, \"Invalid match.takeAmount\");\r\n\r\n            uint256 offerDataB = _values[2 + offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB >> 128).mul(takeAmount).mod(offerDataB & ~(~uint256(0) << 128)) == 0,\r\n                \"Invalid amounts\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that all fills will be completely filled by the specified\r\n    /// matches. See the `BrokerV2.trade` method for an explanation of why\r\n    /// fills must be completely filled.\r\n    /// @param _values Values from `trade`\r\n    function _validateFillAmounts(uint256[] memory _values) private pure {\r\n        // \"filled\" is used to store the sum of `takeAmount`s and `giveAmount`s.\r\n        // While a fill's `offerAmount` and `wantAmount` are combined to share\r\n        // a single uint256 value, each sum of `takeAmount`s and `giveAmount`s\r\n        // for a fill is tracked with an individual uint256 value.\r\n        // This is to prevent the verification from being vulnerable to overflow\r\n        // issues.\r\n        uint256[] memory filled = new uint256[](_values.length);\r\n\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & ~(~uint256(0) << 8)) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & ~(~uint256(0) << 16)) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & ~(~uint256(0) << 8);\r\n            uint256 fillIndex = (_values[i] & ~(~uint256(0) << 16)) >> 8;\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            uint256 wantAmount = _values[2 + offerIndex * 2] >> 128;\r\n            uint256 offerAmount = _values[2 + offerIndex * 2] & ~(~uint256(0) << 128);\r\n            // giveAmount = takeAmount * wantAmount / offerAmount\r\n            uint256 giveAmount = takeAmount.mul(wantAmount).div(offerAmount);\r\n\r\n            // (1 + fillIndex * 2) would give the index of the first part\r\n            // of the data for the fill at fillIndex within `_values`,\r\n            // and (2 + fillIndex * 2) would give the index of the second part\r\n            filled[1 + fillIndex * 2] = filled[1 + fillIndex * 2].add(giveAmount);\r\n            filled[2 + fillIndex * 2] = filled[2 + fillIndex * 2].add(takeAmount);\r\n        }\r\n\r\n        // numOffers\r\n        i = (_values[0] & ~(~uint256(0) << 8));\r\n        // i + numFills\r\n        end = i + ((_values[0] & ~(~uint256(0) << 16)) >> 8);\r\n\r\n        // loop fills\r\n        for(i; i < end; i++) {\r\n            require(\r\n                // fill.offerAmount == (sum of given amounts for fill)\r\n                _values[i * 2 + 2] & ~(~uint256(0) << 128) == filled[i * 2 + 1] &&\r\n                // fill.wantAmount == (sum of taken amounts for fill)\r\n                _values[i * 2 + 2] >> 128 == filled[i * 2 + 2],\r\n                \"Invalid fills\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates that for every offer / fill:\r\n    /// 1. offerAssetId != wantAssetId\r\n    /// 2. offerAmount > 0 && wantAmount > 0\r\n    /// 3. The referenced `operator` address is the zero address\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateTradeData(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // numOffers + numFills\r\n        uint256 end = (_values[0] & ~(~uint256(0) << 8)) +\r\n                      ((_values[0] & ~(~uint256(0) << 16)) >> 8);\r\n\r\n        for (uint256 i = 0; i < end; i++) {\r\n            uint256 dataA = _values[i * 2 + 1];\r\n            uint256 dataB = _values[i * 2 + 2];\r\n\r\n            require(\r\n                // offerAssetId != wantAssetId\r\n                _addresses[((dataA & ~(~uint256(0) << 16)) >> 8) * 2 + 1] !=\r\n                _addresses[((dataA & ~(~uint256(0) << 24)) >> 16) * 2 + 1],\r\n                \"Invalid trade assets\"\r\n            );\r\n\r\n            require(\r\n                // offerAmount > 0 && wantAmount > 0\r\n                (dataB & ~(~uint256(0) << 128)) > 0 && (dataB >> 128) > 0,\r\n                \"Invalid trade amounts\"\r\n            );\r\n\r\n             require(\r\n                // _addresses[operator address index] == address(0)\r\n                // The actual operator address will be read directly from\r\n                // the contract's storage\r\n                _addresses[((dataA & ~(~uint256(0) << 40)) >> 32) * 2] == address(0),\r\n                \"Invalid operator address placeholder\"\r\n            );\r\n\r\n             require(\r\n                // _addresses[operator fee asset ID index] == address(1)\r\n                // address(1) is used to differentiate from the ETHER_ADDR which is address(0)\r\n                // The actual fee asset ID will be read from the filler / maker feeAssetId\r\n                _addresses[((dataA & ~(~uint256(0) << 40)) >> 32) * 2 + 1] == address(1),\r\n                \"Invalid operator fee asset ID placeholder\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates that for every offer\r\n    /// 1. offerAssetId != wantAssetId\r\n    /// 2. offerAmount > 0 && wantAmount > 0\r\n    /// 3. Specified `operator` address matches the expected `operator` address,\r\n    /// 4. Specified `operator.feeAssetId` matches the offer's feeAssetId\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateOfferData(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // numOffers\r\n        uint256 i = (_values[0] & ~(~uint256(0) << 8));\r\n        // numOffers + numFills\r\n        uint256 end = (_values[0] & ~(~uint256(0) << 8)) +\r\n                      ((_values[0] & ~(~uint256(0) << 16)) >> 8);\r\n\r\n        for (i; i < end; i++) {\r\n            uint256 dataA = _values[i * 2 + 1];\r\n            uint256 dataB = _values[i * 2 + 2];\r\n            uint256 feeAssetIndex = ((dataA & ~(~uint256(0) << 40)) >> 32) * 2;\r\n\r\n            require(\r\n                // offerAssetId != wantAssetId\r\n                _addresses[((dataA & ~(~uint256(0) << 16)) >> 8) * 2 + 1] !=\r\n                _addresses[((dataA & ~(~uint256(0) << 24)) >> 16) * 2 + 1],\r\n                \"Invalid trade assets\"\r\n            );\r\n\r\n            require(\r\n                // offerAmount > 0 && wantAmount > 0\r\n                (dataB & ~(~uint256(0) << 128)) > 0 && (dataB >> 128) > 0,\r\n                \"Invalid trade amounts\"\r\n            );\r\n\r\n             require(\r\n                _addresses[feeAssetIndex] == _operator,\r\n                \"Invalid operator address\"\r\n            );\r\n\r\n             require(\r\n                _addresses[feeAssetIndex + 1] == _addresses[((dataA & ~(~uint256(0) << 32)) >> 24) * 2 + 1],\r\n                \"Invalid operator fee asset ID\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates signatures for a set of offers or fills\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    /// @param _typehash The typehash used to construct the signed hash\r\n    /// @param _i The starting index to verify\r\n    /// @param _end The ending index to verify\r\n    /// @return An array of hash keys if _i started as 0, because only\r\n    /// the hash keys of offers are needed\r\n    function _validateTradeSignatures(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        bytes32 _typehash,\r\n        uint256 _i,\r\n        uint256 _end\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        bytes32[] memory hashKeys;\r\n        if (_i == 0) {\r\n            hashKeys = new bytes32[](_end - _i);\r\n        }\r\n\r\n        for (_i; _i < _end; _i++) {\r\n            uint256 dataA = _values[_i * 2 + 1];\r\n            uint256 dataB = _values[_i * 2 + 2];\r\n\r\n            bytes32 hashKey = keccak256(abi.encode(\r\n                _typehash,\r\n                _addresses[(dataA & ~(~uint256(0) << 8)) * 2], // user\r\n                _addresses[((dataA & ~(~uint256(0) << 16)) >> 8) * 2 + 1], // offerAssetId\r\n                dataB & ~(~uint256(0) << 128), // offerAmount\r\n                _addresses[((dataA & ~(~uint256(0) << 24)) >> 16) * 2 + 1], // wantAssetId\r\n                dataB >> 128, // wantAmount\r\n                _addresses[((dataA & ~(~uint256(0) << 32)) >> 24) * 2 + 1], // feeAssetId\r\n                dataA >> 128, // feeAmount\r\n                (dataA & ~(~uint256(0) << 128)) >> 56 // nonce\r\n            ));\r\n\r\n            // To reduce gas costs, each bit of _values[0] after the 24th bit\r\n            // is used to indicate whether the Ethereum signed message prefix\r\n            // should be prepended for signature verification of the offer / fill\r\n            // at that index\r\n            bool prefixedSignature = ((dataA & ~(~uint256(0) << 56)) >> 48) != 0;\r\n\r\n            validateSignature(\r\n                hashKey,\r\n                _addresses[(dataA & ~(~uint256(0) << 8)) * 2], // user\r\n                uint8((dataA & ~(~uint256(0) << 48)) >> 40), // The `v` component of the user's signature\r\n                _hashes[_i * 2], // The `r` component of the user's signature\r\n                _hashes[_i * 2 + 1], // The `s` component of the user's signature\r\n                prefixedSignature\r\n            );\r\n\r\n            if (hashKeys.length > 0) { hashKeys[_i] = hashKey; }\r\n        }\r\n\r\n        return hashKeys;\r\n    }\r\n\r\n    /// @dev Ensure that the address is a deployed contract\r\n    /// @param _contract The address to check\r\n    function _validateContractAddress(address _contract) private view {\r\n        assembly {\r\n            if iszero(extcodesize(_contract)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @dev A thin wrapper around the native `call` function, to\r\n    /// validate that the contract `call` must be successful.\r\n    /// See https://solidity.readthedocs.io/en/v0.5.1/050-breaking-changes.html\r\n    /// for details on constructing the `_payload`\r\n    /// @param _contract Address of the contract to call\r\n    /// @param _payload The data to call the contract with\r\n    /// @return The data returned from the contract call\r\n    function _callContract(\r\n        address _contract,\r\n        bytes memory _payload\r\n    )\r\n        private\r\n        returns (bytes memory)\r\n    {\r\n        bool success;\r\n        bytes memory returnData;\r\n\r\n        (success, returnData) = _contract.call(_payload);\r\n        require(success, \"Contract call failed\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    /// @dev Fix for ERC-20 tokens that do not have proper return type\r\n    /// See: https://github.com/ethereum/solidity/issues/4116\r\n    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\r\n    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\r\n    /// @param _data The data returned from a transfer call\r\n    function _validateContractCallResult(bytes memory _data) private pure {\r\n        require(\r\n            _data.length == 0 ||\r\n            (_data.length == 32 && _getUint256FromBytes(_data) != 0),\r\n            \"Invalid contract call result\"\r\n        );\r\n    }\r\n\r\n    /// @dev Converts data of type `bytes` into its corresponding `uint256` value\r\n    /// @param _data The data in bytes\r\n    /// @return The corresponding `uint256` value\r\n    function _getUint256FromBytes(\r\n        bytes memory _data\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 parsed;\r\n        assembly { parsed := mload(add(_data, 32)) }\r\n        return parsed;\r\n    }\r\n}\r\n\r\n// File: contracts/extensions/SpenderList.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n/// @title The SpenderList extension for the BrokerV2 contract\r\n/// @author Switcheo Network\r\n/// @notice This contract allows new features to be added to the BrokerV2 contract\r\n/// through spender contracts, these contracts are able to make fund transfers\r\n/// on behalf of users.\r\n/// @dev For security, the spender contract must first be whitelisted and separately\r\n/// authorized by individual users, before it can transfer the funds of a user.\r\ncontract SpenderList is BrokerExtension {\r\n    // The constants for EIP-712 are precompiled to reduce contract size,\r\n    // the original values are left here for reference and verification.\r\n    // bytes32 public constant AUTHORIZE_SPENDER_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"AuthorizeSpender(\",\r\n    //         \"address user,\",\r\n    //         \"address spender,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant AUTHORIZE_SPENDER_TYPEHASH = 0xe26b1365004fe3cb06fb24dd69b50c8263f0a5a1df21e0a76f4d6184c3515d50;\r\n\r\n    // A record of whitelisted spenders: spenderContract => isWhitelisted.\r\n    // Spenders are intended to be extension contracts.\r\n    // A user would first manually vet a spender contract then approve it to perform\r\n     // balance transfers for their address, using the `authorizeSpender` method.\r\n    mapping(address => bool) public spenderWhitelist;\r\n    // A record of spender authorizations: userAddress => spenderAddress => isAuthorized\r\n    mapping(address => mapping(address => bool)) public spenderAuthorizations;\r\n\r\n    event AuthorizeSpender(\r\n        address indexed user,\r\n        address indexed spender,\r\n        uint256 nonce\r\n    );\r\n\r\n    event UnauthorizeSpender(address indexed user, address indexed spender);\r\n\r\n    constructor() public {\r\n        // whitelist this contract so that it can call BrokerV2.markNonce\r\n        spenderWhitelist[address(this)] = true;\r\n    }\r\n\r\n    /// @notice Whitelists a spender contract\r\n    /// @dev Spender contracts are intended to offer additional functionality\r\n    /// to the Broker contract, allowing for new contract features to be added without\r\n    /// having to migrate user funds to a new contract.\r\n    /// After a spender contract is whitelisted, a user intending to use its\r\n    /// features must separately authorize the spender contract before it can\r\n    /// perform balance transfers for the user.\r\n    /// See `authorizeSpender` and `spendFrom` methods for more details.\r\n    /// @param _spender The address of the spender contract to whitelist\r\n    function whitelistSpender(address _spender) external onlyOwner {\r\n        Utils.validateAddress(_spender);\r\n        require(!spenderWhitelist[_spender], \"Spender already whitelisted\");\r\n        spenderWhitelist[_spender] = true;\r\n    }\r\n\r\n    /// @notice Removes a spender contract from the spender whitelist\r\n    /// @dev Note that removing a spender from the whitelist will not prevent\r\n    /// a it from transferring balances for users who had previously\r\n    /// authorized it.\r\n    /// This is required because the contract owner would otherwise be able to\r\n    /// cause a user's funds to be locked in the spender contract.\r\n    /// @param _spender The address of the spender contract to remove from the whitelist\r\n    function unwhitelistSpender(address _spender) external onlyOwner {\r\n        Utils.validateAddress(_spender);\r\n        require(spenderWhitelist[_spender], \"Spender not whitelisted\");\r\n        delete spenderWhitelist[_spender];\r\n    }\r\n\r\n    /// @notice Allows users to authorize a spender contract to perform\r\n    /// balance transfers for their address\r\n    /// @dev After a spender contract is authorized, it can call the `spendFrom`\r\n    /// method for the permitted user's address.\r\n    /// @param _user The address of the user\r\n    /// @param _spender The address of the whitelisted spender contract\r\n    /// @param _nonce An unused nonce to prevent replay attacks\r\n    /// @param _v The `v` component of the `_user`'s signature\r\n    /// @param _r The `r` component of the `_user`'s signature\r\n    /// @param _s The `s` component of the `_user`'s signature\r\n    /// @param _prefixedSignature Indicates whether the Ethereum signed message\r\n    /// prefix should be prepended during signature verification\r\n    function authorizeSpender(\r\n        address _user,\r\n        address _spender,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixedSignature\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(spenderWhitelist[_spender], \"Spender not whitelisted\");\r\n        broker.markNonce(_nonce);\r\n\r\n        Utils.validateSignature(\r\n            keccak256(abi.encode(\r\n                AUTHORIZE_SPENDER_TYPEHASH,\r\n                _user,\r\n                _spender,\r\n                _nonce\r\n            )),\r\n            _user,\r\n            _v,\r\n            _r,\r\n            _s,\r\n            _prefixedSignature\r\n        );\r\n        spenderAuthorizations[_user][_spender] = true;\r\n        emit AuthorizeSpender(_user, _spender, _nonce);\r\n    }\r\n\r\n    /// @notice Allows users to remove authorization for a spender contract to\r\n    /// perform balance transfers for their address\r\n    /// @dev This method can only be invoked for spender contracts already removed\r\n    /// from the whitelist. This is to prevent users from unexpectedly removing\r\n    /// authorization for a previously authorized spender, as doing so could prevent\r\n    /// regular operation of the features offerred by the spender contract.\r\n    /// This function does not require admin permission and is invokable directly by users.\r\n    /// @param _spender The address of the spender contract\r\n    function unauthorizeSpender(address _spender) external {\r\n        require(!spenderWhitelist[_spender], \"Spender not unlisted\");\r\n\r\n        address user = msg.sender;\r\n        require(spenderAuthorizations[user][_spender], \"Spender not authorized\");\r\n\r\n        delete spenderAuthorizations[user][_spender];\r\n        emit UnauthorizeSpender(user, _spender);\r\n    }\r\n\r\n    /// @notice Validates if a spender contract has been whitelisted\r\n    /// @param _spender The address of the spender contract\r\n    function validateSpender(address _spender) external view {\r\n        require(spenderWhitelist[_spender], \"Invalid spender\");\r\n    }\r\n\r\n    /// @notice Validates if a spender contract has been authorized by a user\r\n    /// @param _user The user of the spender contract\r\n    /// @param _spender The address of the spender contract\r\n    function validateSpenderAuthorization(address _user, address _spender) external view {\r\n        require(spenderAuthorizations[_user][_spender], \"Unauthorized spender\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"unwhitelistSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_brokerAddress\",\"type\":\"address\"}],\"name\":\"initializeBroker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"validateSpenderAuthorization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"unauthorizeSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTHORIZE_SPENDER_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_prefixedSignature\",\"type\":\"bool\"}],\"name\":\"authorizeSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"spenderAuthorizations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"broker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"whitelistSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"spenderWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"validateSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"AuthorizeSpender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"UnauthorizeSpender\",\"type\":\"event\"}]","ContractName":"SpenderList","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"Utils:93d4c213c6d6d9978fb1cb5052f8bae693fdb9a4","LicenseType":"MIT","SwarmSource":"bzzr://c561a8ea5625a48ce2c2965459522acc60dfc3da350ea9fb2ad4a637a95c0519"}]}