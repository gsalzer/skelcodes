{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-10-28\r\n*/\r\n\r\npragma solidity ^0.5.12;\r\n\r\ncontract UtilFairHot {\r\n\t\r\n\tuint ethWei =  1 ether;\r\n\r\n\tfunction getLevel(uint value) public view returns (uint) {\r\n\t\tif (value >= 1 * ethWei && value <= 5 * ethWei) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= 6 * ethWei && value <= 10 * ethWei) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= 11 * ethWei && value <= 15 * ethWei) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getNodeLevel(uint value) public view returns (uint) {\r\n\t\tif (value >= 1 * ethWei && value <= 5 * ethWei) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= 6 * ethWei && value <= 10 * ethWei) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= 11 * ethWei) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getScByLevel(uint level) public pure returns (uint) {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 7;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getFireScByLevel(uint level) public pure returns (uint) {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 6;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getRecommendScaleByLevelAndTim(uint level, uint times) public pure returns (uint){\r\n\t\tif (level == 1 && times == 1) {\r\n\t\t\treturn 50;\r\n\t\t}\r\n\t\tif (level == 2 && times == 1) {\r\n\t\t\treturn 70;\r\n\t\t}\r\n\t\tif (level == 2 && times == 2) {\r\n\t\t\treturn 50;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 100;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 70;\r\n\t\t\t}\r\n\t\t\tif (times == 3) {\r\n\t\t\t\treturn 50;\r\n\t\t\t}\r\n\t\t\tif (times >= 4 && times <= 10) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t\tif (times >= 11 && times <= 20) {\r\n\t\t\t\treturn 5;\r\n\t\t\t}\r\n\t\t\tif (times >= 21) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction compareStr(string memory _str, string memory str) public pure returns (bool) {\r\n\t\tif (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor() internal {}\r\n\t// solhint-disable-previous-line no-empty-blocks\r\n\r\n\tfunction _msgSender() internal view returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\t\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () internal {\r\n\t\t_owner = _msgSender();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the caller is the current owner.\r\n\t */\r\n\tfunction isOwner() public view returns (bool) {\r\n\t\treturn _msgSender() == _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n\t\r\n\tstruct Role {\r\n\t\tmapping(address => bool) bearer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Give an account access to this role.\r\n\t */\r\n\tfunction add(Role storage role, address account) internal {\r\n\t\trequire(!has(role, account), \"Roles: account already has role\");\r\n\t\trole.bearer[account] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove an account's access to this role.\r\n\t */\r\n\tfunction remove(Role storage role, address account) internal {\r\n\t\trequire(has(role, account), \"Roles: account does not have role\");\r\n\t\trole.bearer[account] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if an account has this role.\r\n\t * @return bool\r\n\t */\r\n\tfunction has(Role storage role, address account) internal view returns (bool) {\r\n\t\trequire(account != address(0), \"Roles: account is the zero address\");\r\n\t\treturn role.bearer[account];\r\n\t}\r\n}\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context, Ownable {\r\n\t\r\n\tusing Roles for Roles.Role;\r\n\r\n\tRoles.Role private _whitelistAdmins;\r\n\r\n\tconstructor () internal {\r\n\t}\r\n\r\n\tmodifier onlyWhitelistAdmin() {\r\n\t\trequire(isWhitelistAdmin(_msgSender()) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isWhitelistAdmin(address account) public view returns (bool) {\r\n\t\treturn _whitelistAdmins.has(account) || isOwner();\r\n\t}\r\n\r\n\tfunction addWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.add(account);\r\n\t}\r\n\r\n\tfunction removeWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.remove(account);\r\n\t}\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\t/**\r\n\t* @dev Multiplies two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"mul overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b > 0, \"div zero\");\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a, \"lower sub bigger\");\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n\t* reverts when dividing by zero.\r\n\t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0, \"mod zero\");\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev compare two numbers and returns the smaller one.\r\n\t*/\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a > b ? b : a;\r\n\t}\r\n}\r\n\r\ncontract FairHotWin is UtilFairHot, WhitelistAdminRole {\r\n\t\r\n\tusing SafeMath for *;\r\n\tuint ethWei = 1 ether;\r\n\r\n\taddress payable private devAddr =       address(0xd3947A690C9D96a796C16ee16E966aDA3CfE280c);\r\n    address payable private FOMO  =         address(0xac6832183b15d412830ace2C2404E2C693BdbD9E);\r\n    address payable private Foundation  =   address(0x38eEAAe96BB6ee05bdfcFb3AFa94842EEd383c39);\r\n\r\n\tstruct User {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tuint freeAmount;\r\n\t\tuint freezeAmount;\r\n\t\tuint lineAmount;\r\n\t\tuint inviteAmount;\r\n\t\tuint dayBonusAmount;\r\n\t\tuint bonusAmount;\r\n\t    uint dynamicAmount;\r\n\t\tuint totalAmount;\r\n\t\tuint level;\r\n\t\tuint lineLevel;\r\n\t\tuint resTime;\r\n\t\tuint investTimes;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint rewardIndex;\r\n\t\tuint lastRwTime;\r\n\t\tuint day;\r\n\t\tbool isNew;\r\n\t\tuint teamCount;\r\n\t}\r\n\r\n\tstruct UserGlobal {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint status;\r\n\t\tbool isVaild;\r\n\t}\r\n\r\n\tstruct AwardData {\r\n\t\tuint oneInvReward;\r\n\t\tuint twoInvReward;\r\n\t\tuint threeInvReward;\r\n\t}\r\n\r\n\tuint startTime;\r\n\tuint lineStatus = 0;\r\n\tmapping(uint => uint) rInvestCount;\r\n\tmapping(uint => uint) rInvestMoney;\r\n\r\n\tuint period = 1 days;\r\n\tuint uid = 0;\r\n\tuint rid = 1;\r\n\r\n\tmapping(uint => uint[]) lineArrayMapping;\r\n\tmapping(uint => mapping(address => User)) userRoundMapping;\r\n\tmapping(address => UserGlobal) userMapping;\r\n\tmapping(string => address) addressMapping;\r\n\tmapping(uint => address) indexMapping;\r\n\r\n\tmapping(uint => mapping(address => mapping(uint => AwardData))) userAwardDataMapping;\r\n\r\n\tuint bonuslimit = 15 ether;\r\n\tuint sendLimit = 100 ether;\r\n\tuint withdrawLimit = 15 ether;\r\n\tuint canImport = 1;\r\n\tuint canSetStartTime = 1;\r\n\r\n\tmodifier isHuman() {\r\n\t\taddress addr = msg.sender;\r\n\t\tuint codeLength;\r\n\t\tassembly {codeLength := extcodesize(addr)}\r\n\t\trequire(codeLength == 0, \"sorry humans only\");\r\n\t\trequire(tx.origin == msg.sender, \"sorry, humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n\tevent LogInvestIn(address indexed who, uint indexed uid, uint amount, uint time, string inviteCode, string referrer);\r\n    event LogWithdrawProfit(address indexed who, uint indexed uid, uint amount, uint time);\r\n\tevent LogChristmas(address indexed who, uint indexed uid, uint amount, uint time);\r\n\r\n\tconstructor () public {\r\n\t}\r\n\r\n\tfunction() external payable {\r\n\t}\r\n\r\n\tfunction dangerousGameStart(uint time) external onlyOwner {\r\n\t\trequire(canSetStartTime == 1, \"dangerousGameStart, limited!\");\r\n\t\trequire(time > now, \"no, dangerousGameStart\");\r\n\t\tstartTime = time;\r\n\t\tcanSetStartTime = 0;\r\n\t}\r\n\r\n\tfunction doNotImitate() public view returns (bool) {\r\n\t\treturn startTime != 0 && now > startTime;\r\n\t}\r\n\r\n\tfunction updateLine(uint line) external onlyWhitelistAdmin {\r\n\t\tlineStatus = line;\r\n\t}\r\n\r\n\tfunction isLine() private view returns (bool) {\r\n\t\treturn lineStatus != 0;\r\n\t}\r\n\r\n\tfunction actAllLimit(uint bonusLi, uint sendLi, uint withdrawLi) external onlyOwner {\r\n\t\trequire(bonusLi >= 15 ether && sendLi >= 100 ether && withdrawLi >= 15 ether, \"invalid amount\");\r\n\t\tbonuslimit = bonusLi;\r\n\t\tsendLimit = sendLi;\r\n\t\twithdrawLimit = withdrawLi;\r\n\t}\r\n\r\n\tfunction stopImport() external onlyOwner {\r\n\t\tcanImport = 0;\r\n\t}\r\n\r\n\tfunction actUserStatus(address addr, uint status) external onlyWhitelistAdmin {\r\n\t\trequire(status == 0 || status == 1 || status == 2, \"bad parameter status\");\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuserGlobal.status = status;\r\n\t}\r\n\r\n\tfunction investIn(string memory inviteCode, string memory beCode,uint day) public isHuman() payable {\r\n\t    require(day == 3 || day == 5,\"must day is 3 or 5\");\r\n\t\trequire(doNotImitate(), \"no, doNotImitate\");\r\n\t    require(msg.value >= 1 * ethWei && msg.value <= 15 * ethWei, \"between 1 and 15\");\r\n\t\trequire(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\r\n\t\tUserGlobal storage userGlobal = userMapping[msg.sender];\r\n\t\tif (userGlobal.id == 0) {\r\n\t\t\trequire(!compareStr(inviteCode, \"\") && bytes(inviteCode).length == 6, \"invalid invite code\");\r\n\t\t\taddress beCodeAddr = addressMapping[beCode];\r\n\t\t\trequire(isUsed(beCode), \"beCode not exist\");\r\n\t\t\trequire(beCodeAddr != msg.sender, \"beCodeAddr can't be self\");\r\n\t\t\trequire(!isUsed(inviteCode), \"invite code is used\");\r\n\t\t\tregisterUser(msg.sender, inviteCode, beCode);\r\n\t\t}\r\n\t\tuint investAmout;\r\n\t\tuint lineAmount;\r\n\t\tif (isLine()) {\r\n\t\t\tlineAmount = msg.value;\r\n\t\t} else {\r\n\t\t\tinvestAmout = msg.value;\r\n\t\t}\r\n\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\r\n\t\tif (user.id != 0) {\r\n\t\t\trequire(user.freezeAmount.add(user.lineAmount) == 0, \"only once invest\");\r\n\t\t\tuser.freezeAmount = investAmout;\r\n\t\t\tuser.lineAmount = lineAmount;\r\n\t\t\tuser.level = getLevel(user.freezeAmount);\r\n\t\t\tuser.lineLevel = getNodeLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount));\r\n\t\t\tuser.isNew = false;\r\n\t\t} else {\r\n\t\t\tuser.id = userGlobal.id;\r\n\t\t\tuser.userAddress = msg.sender;\r\n\t\t\tuser.freezeAmount = investAmout;\r\n\t\t\tuser.level = getLevel(investAmout);\r\n\t\t\tuser.lineAmount = lineAmount;\r\n\t\t\tuser.lineLevel = getNodeLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount));\r\n\t\t\tuser.inviteCode = userGlobal.inviteCode;\r\n\t\t\tuser.beCode = userGlobal.beCode;\r\n\t\t\tuser.isNew =  true;\r\n\t\t}\r\n\t\tuser.day = day;\r\n\t\tuser.totalAmount= user.totalAmount.add(investAmout);\r\n\r\n\t\trInvestCount[rid] = rInvestCount[rid].add(1);\r\n\t\trInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\r\n\t\tif (!isLine()) {\r\n\t\t\tsendFeetoAdmin(msg.value);\r\n\t\t\tcountBonus(user.userAddress);\r\n\t\t\temit LogInvestIn(msg.sender, userGlobal.id,msg.value, now, userGlobal.inviteCode, userGlobal.beCode);\r\n\t\t} else {\r\n\t\t\tlineArrayMapping[rid].push(user.id);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction importGlobal(address addr, string calldata inviteCode, string calldata beCode) external onlyWhitelistAdmin {\r\n\t\trequire(canImport == 1, \"import stopped\");\r\n\t\tUserGlobal storage user = userMapping[addr];\r\n\t\trequire(user.id == 0, \"user already exists\");\r\n\t\trequire(!compareStr(inviteCode, \"\"), \"empty invite code\");\r\n\t\tif (uid != 0) {\r\n\t\t\trequire(!compareStr(beCode, \"\"), \"empty beCode\");\r\n\t\t}\r\n\t\taddress beCodeAddr = addressMapping[beCode];\r\n\t\trequire(beCodeAddr != addr, \"beCodeAddr can't be self\");\r\n\t\trequire(!isUsed(inviteCode), \"invite code is used\");\r\n\r\n\t\tregisterUser(addr, inviteCode, beCode);\r\n\t}\r\n\r\n\tfunction testCode(uint start, uint end, uint isUser) external onlyWhitelistAdmin {\r\n\t\tfor (uint i = start; i <= end; i++) {\r\n\t\t\tuint userId = 0;\r\n\t\t\tif (isUser == 0) {\r\n\t\t\t\tuserId = lineArrayMapping[rid][i];\r\n\t\t\t} else {\r\n\t\t\t\tuserId = i;\r\n\t\t\t}\r\n\t\t\taddress userAddr = indexMapping[userId];\r\n\t\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\t\tif (user.freezeAmount == 0 && user.lineAmount >= 1 ether && user.lineAmount <= 15 ether) {\r\n\t\t\t\tuser.freezeAmount = user.lineAmount;\r\n\t\t\t\tuser.level = getLevel(user.freezeAmount);\r\n\t\t\t\tuser.lineAmount = 0;\r\n\t\t\t\tsendFeetoAdmin(user.freezeAmount);\r\n\t\t\t\tcountBonus(user.userAddress);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction countBonus(address userAddr) private {\r\n\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\tif (user.id == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint scale = getScByLevel(user.level);\r\n\t\tif(user.day == 5)\r\n\t\t{\r\n\t\t    user.dayBonusAmount = user.freezeAmount.mul(scale).div(1000);\r\n\t\t}\r\n\t\tif(user.day == 3)\r\n\t\t{\r\n\t\t   user.dayBonusAmount = user.freezeAmount.mul(scale).div(1000);\r\n\t\t   user.dayBonusAmount = user.dayBonusAmount.mul(7).div(10);\r\n\t\t}\r\n\r\n\t\tuser.investTimes = 0;\r\n\t\tUserGlobal memory userGlobal = userMapping[userAddr];\r\n\t\tif (user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && userGlobal.status == 0) {\r\n\t\t\tgetaway(user.beCode, user.freezeAmount, scale,user.isNew,user.day);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getaway(string memory beCode, uint money, uint shareSc,bool isNew,uint day) private {\r\n\t\tstring memory tmpReferrer = beCode;\r\n\r\n\t\tfor (uint i = 1; i <= 25; i++) {\r\n\t\t\tif (compareStr(tmpReferrer, \"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\taddress tmpUserAddr = addressMapping[tmpReferrer];\r\n\r\n\t\t\tUserGlobal storage userGlobal = userMapping[tmpUserAddr];\r\n\r\n\t\t\tUser storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\t\t\t\r\n\t\t\tif(isNew)\r\n\t\t\t{\r\n\t\t\t    calUser.teamCount = calUser.teamCount.add(1);\r\n\t\t\t}\r\n\r\n\t\t\tif (calUser.freezeAmount.add(calUser.freeAmount).add(calUser.lineAmount) == 0) {\r\n\t\t\t\ttmpReferrer = userGlobal.beCode;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tuint recommendSc = getRecommendScaleByLevelAndTim(3, i);\r\n\r\n\t\t\tuint moneyResult = 0;\r\n\r\n\t\t\tif (money <= 15 ether) {\r\n\t\t\t\tmoneyResult = money;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmoneyResult = 15 ether;\r\n\t\t\t}\r\n\r\n\t\t\tif (recommendSc != 0) {\r\n\t\t\t\tuint tmpDynamicAmount = moneyResult.mul(shareSc).div(1000);\r\n\t\t\t\tif(day == 3)\r\n\t\t\t\t{\r\n\t\t\t\t    tmpDynamicAmount = tmpDynamicAmount.mul(7).div(10);\r\n\t\t\t\t}\r\n\t\t\t\ttmpDynamicAmount = tmpDynamicAmount.mul(recommendSc).div(100);\r\n\t\t\t\tearneth(userGlobal.userAddress,day,tmpDynamicAmount, calUser.rewardIndex, i);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttmpReferrer = userGlobal.beCode;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction earneth(address userAddr,uint day, uint dayInvAmount, uint rewardIndex, uint times) private {\r\n\t\tfor (uint i = 0; i < day; i++) {\r\n\t\t\tAwardData storage awData = userAwardDataMapping[rid][userAddr][rewardIndex.add(i)];\r\n\r\n\t\t\tif (times == 1) {\r\n\t\t\t\tawData.oneInvReward += dayInvAmount;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\tawData.twoInvReward += dayInvAmount;\r\n\t\t\t}\r\n\t\t\tawData.threeInvReward += dayInvAmount;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction withdrawProfit() public isHuman() {\r\n\t\trequire(doNotImitate(), \"no doNotImitate\");\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\trequire(user.id != 0, \"user not exist\");\r\n\t\tuint sendMoney = user.freeAmount + user.lineAmount;\r\n\t\tbool isEnough = false;\r\n\t\tuint resultMoney = 0;\r\n\r\n\t\t(isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n\r\n\t\tif (resultMoney > 0 && resultMoney <= withdrawLimit) {\r\n\t\t\tsendMoneyToUser(msg.sender, resultMoney);\r\n\t\t\tuser.freeAmount = 0;\r\n\t\t\tuser.lineAmount = 0;\r\n\t\t\tuser.lineLevel = getNodeLevel(user.freezeAmount);\r\n\t\t\temit LogWithdrawProfit(msg.sender, user.id, resultMoney, now);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction aprilFoolsDay(uint start, uint end,uint times) external onlyWhitelistAdmin {\r\n\t\tfor (uint i = start; i <= end; i++) {\r\n\r\n\t\t\taddress userAddr = indexMapping[i];\r\n\t\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\t\tUserGlobal memory userGlobal = userMapping[userAddr];\r\n\r\n\t\t\t//记得改回12小时\r\n\t\t\tif(times == 1)\r\n\t\t\t{\r\n\t\t\t    if (now.sub(user.lastRwTime) <= 1 seconds) {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t    if (now.sub(user.lastRwTime) <= 12 hours) {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tuser.lastRwTime = now;\r\n\t\t\tif (userGlobal.status == 1) {\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tuint bonusSend = 0;\r\n\t\t\tif (user.id != 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit) {\r\n\t\t\t\tif (user.investTimes < user.day) {\r\n\t\t\t\t\tbonusSend += user.dayBonusAmount;\r\n\t\t\t\t\tuser.bonusAmount = user.bonusAmount.add(bonusSend);\r\n\t\t\t\t\tuser.investTimes = user.investTimes.add(1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuser.freeAmount = user.freeAmount.add(user.freezeAmount);\r\n\t\t\t\t\tuser.freezeAmount = 0;\r\n\t\t\t\t\tuser.dayBonusAmount = 0;\r\n\t\t\t\t\tuser.level = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tuint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n\t\t\tif (lineAmount < 1 ether || lineAmount > withdrawLimit) {\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tuint inviteSend = 0;\r\n\t\t\tif (userGlobal.status == 0) {\r\n\t\t\t\tAwardData memory awData = userAwardDataMapping[rid][userAddr][user.rewardIndex];\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t\tuint lineValue = lineAmount.div(ethWei);\r\n\t            if (lineValue >= 15) {\r\n\t\t\t\t\tinviteSend += awData.threeInvReward;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvReward > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvReward.div(15).mul(lineValue).div(2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 2 && lineAmount >= 6 ether && (awData.oneInvReward > 0 || awData.twoInvReward > 0)) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvReward.div(15).mul(lineValue).mul(7).div(10);\r\n\t\t\t\t\t\tinviteSend += awData.twoInvReward.div(15).mul(lineValue).mul(5).div(7);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 3 && lineAmount >= 11 ether && awData.threeInvReward > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.threeInvReward.div(15).mul(lineValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel < 3) {\r\n\t\t\t\t\t\tuint fireSc = getFireScByLevel(user.lineLevel);\r\n\t\t\t\t\t\tinviteSend = inviteSend.mul(fireSc).div(10);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (userGlobal.status == 2) {\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t}\r\n\r\n\t\t\tuint dynamicAmount = 0;\r\n\t\t\tdynamicAmount+=user.dynamicAmount.add(inviteSend);\r\n            user.dynamicAmount = dynamicAmount;\r\n\r\n\t\t\tif (bonusSend.add(inviteSend) <= sendLimit) {\r\n\t\t\t\tuser.inviteAmount = user.inviteAmount.add(inviteSend);\r\n\t\t\t\tbool isEnough = false;\r\n\t\t\t\tuint resultMoney = 0;\r\n\r\n\t\t\t\t(isEnough, resultMoney) = isEnoughBalance(bonusSend.add(inviteSend));\r\n\r\n\t\t\t\tif (resultMoney > 0) {\r\n\t\t\t\t\tuint confortMoney = resultMoney.mul(6).div(100);\r\n\t\t\t\t\t\r\n\t\t\t\t\tsendMoneyToUser(FOMO, confortMoney);\r\n\t\t\t\t\t\r\n\t\t\t\t\tsendMoneyToUser(Foundation, confortMoney);\r\n\t\t\t\t\t\r\n\t\t\t\t\tresultMoney = resultMoney.sub(confortMoney).sub(confortMoney);\r\n\t\t\t\t\t\r\n\t\t\t\t\taddress payable sendAddr = address(uint160(userAddr));\r\n\t\t\t\t\t\r\n\t\t\t\t\tsendMoneyToUser(sendAddr, resultMoney);\r\n\t\t\t\t\t\r\n\t\t\t\t\temit LogChristmas(userAddr,user.id, resultMoney,now);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isEnoughBalance(uint sendMoney) private view returns (bool, uint){\r\n\t\tif (sendMoney >= address(this).balance) {\r\n\t\t\treturn (false, address(this).balance);\r\n\t\t} else {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sendFeetoAdmin(uint amount) private {\r\n\t\tdevAddr.transfer(amount.div(25));\r\n\t}\r\n\r\n\tfunction sendMoneyToUser(address payable userAddress, uint money) private {\r\n\t\tif (money > 0) {\r\n\t\t\tuserAddress.transfer(money);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isUsed(string memory code) public view returns (bool) {\r\n\t\taddress addr = addressMapping[code];\r\n\t\treturn uint(addr) != 0;\r\n\t}\r\n\r\n\tfunction getUserAddressByCode(string memory code) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\treturn addressMapping[code];\r\n\t}\r\n\r\n\tfunction registerUser(address addr, string memory inviteCode, string memory beCode) private{\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuid++;\r\n\t\tuserGlobal.id = uid;\r\n\t\tuserGlobal.userAddress = addr;\r\n\t\tuserGlobal.inviteCode = inviteCode;\r\n\t\tuserGlobal.beCode = beCode;\r\n\r\n\t\taddressMapping[inviteCode] = addr;\r\n\t\tindexMapping[uid] = addr;\r\n\t}\r\n\r\n\tfunction endRound() external onlyOwner {\r\n\t\trequire(address(this).balance < 1 ether, \"contract balance must be lower than 1 ether\");\r\n\t\trid++;\r\n\t\tstartTime = now.add(period).div(1 days).mul(1 days);\r\n\t\tcanSetStartTime = 1;\r\n\t}\r\n\t\r\n\tfunction getGameInfo() public isHuman() view returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\t\treturn (\r\n\t\trid,\r\n\t\tuid,\r\n\t\tstartTime,\r\n\t\trInvestCount[rid],\r\n\t\trInvestMoney[rid],\r\n\t\tbonuslimit,\r\n\t\tsendLimit,\r\n\t\twithdrawLimit,\r\n\t\tcanImport,\r\n\t\tlineStatus,\r\n\t\tlineArrayMapping[rid].length,\r\n\t\tcanSetStartTime\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getUserInfo(address addr, uint roundId) public view returns (uint[18] memory info, string memory inviteCode, string memory beCode) {\r\n\t\trequire(isWhitelistAdmin(msg.sender) || msg.sender == addr, \"Permission denied for view user's privacy\");\r\n\r\n\t\tif (roundId == 0) {\r\n\t\t\troundId = rid;\r\n\t\t}\r\n\r\n\t\tUserGlobal memory userGlobal = userMapping[addr];\r\n\t\tUser memory user = userRoundMapping[roundId][addr];\r\n\t\tinfo[0] = userGlobal.id;\r\n\t\tinfo[1] = user.lineAmount;\r\n\t\tinfo[2] = user.freeAmount;\r\n\t\tinfo[3] = user.freezeAmount;\r\n\t\tinfo[4] = user.inviteAmount;\r\n\t\tinfo[5] = user.bonusAmount.mul(88).div(100);\r\n\t\tinfo[6] = user.lineLevel;\r\n\t\tinfo[7] = user.dayBonusAmount;\r\n\t\tinfo[8] = user.rewardIndex;\r\n\t\tinfo[9] = user.investTimes;\r\n\t\tinfo[10] = user.level;\r\n\t\tuint grantAmount = 0;\r\n\t\tif (user.id > 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && user.investTimes < user.day && userGlobal.status != 1) {\r\n\t\t\tgrantAmount += user.dayBonusAmount;\r\n\t\t}\r\n\t\tif (userGlobal.status == 0) {\r\n\t\t\tuint inviteSend = 0;\r\n\t\t\tAwardData memory awData = userAwardDataMapping[rid][user.userAddress][user.rewardIndex];\r\n\t\t\tuint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n\t\t\tif (lineAmount >= 1 ether) {\r\n\t\t\t\tuint lineValue = lineAmount.div(ethWei);\r\n\t\t\t\tif (lineValue >= 15) {\r\n\t\t\t\t\tinviteSend += awData.threeInvReward;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvReward > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvReward.div(15).mul(lineValue).div(2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 2 && lineAmount >= 1 ether && (awData.oneInvReward > 0 || awData.twoInvReward > 0)) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvReward.div(15).mul(lineValue).mul(7).div(10);\r\n\t\t\t\t\t\tinviteSend += awData.twoInvReward.div(15).mul(lineValue).mul(5).div(7);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 3 && lineAmount >= 1 ether && awData.threeInvReward > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.threeInvReward.div(15).mul(lineValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel < 3) {\r\n\t\t\t\t\t\tuint fireSc = getFireScByLevel(user.lineLevel);\r\n\t\t\t\t\t\tinviteSend = inviteSend.mul(fireSc).div(10);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tgrantAmount += inviteSend;\r\n\t\t\t}\r\n\t\t}\r\n\t\tinfo[11] = grantAmount.sub(grantAmount.mul(12).div(100));\r\n\t\tinfo[12] = user.lastRwTime;\r\n\t\tinfo[13] = userGlobal.status;\r\n\t\tinfo[14] = user.day;\r\n\t\tinfo[15] = user.totalAmount;\r\n\t\tinfo[16] = user.dynamicAmount.mul(88).div(100);\r\n\t\tinfo[17] = user.teamCount;\r\n\r\n\t\treturn (info, userGlobal.inviteCode, userGlobal.beCode);\r\n\t}\r\n\r\n\tfunction getUserAddressById(uint id) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\treturn indexMapping[id];\r\n\t}\r\n\r\n\tfunction getLineUserId(uint index, uint rouId) public view returns (uint) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\tif (rouId == 0) {\r\n\t\t\trouId = rid;\r\n\t\t}\r\n\t\treturn lineArrayMapping[rid][index];\r\n\t}\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LogChristmas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"referrer\",\"type\":\"string\"}],\"name\":\"LogInvestIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawProfit\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusLi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sendLi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawLi\",\"type\":\"uint256\"}],\"name\":\"actAllLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"actUserStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"aprilFoolsDay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_str\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"compareStr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"dangerousGameStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"doNotImitate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getFireScByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rouId\",\"type\":\"uint256\"}],\"name\":\"getLineUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getNodeLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"getRecommendScaleByLevelAndTim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getScByLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getUserAddressByCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserAddressById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256[18]\",\"name\":\"info\",\"type\":\"uint256[18]\"},{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"importGlobal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"inviteCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"beCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"investIn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"isUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopImport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"isUser\",\"type\":\"uint256\"}],\"name\":\"testCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"}],\"name\":\"updateLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FairHotWin","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://9dbc51f0e4a49e1cb6d5dc8949fc3d820d2be42193fe59747a38314aa77293fe"}]}