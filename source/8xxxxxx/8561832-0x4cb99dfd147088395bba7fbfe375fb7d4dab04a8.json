{"status":"1","message":"OK","result":[{"SourceCode":"{\"Blacklistable.sol\":{\"content\":\"/**\\n* Copyright CENTRE SECZ 2018\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy \\n* of this software and associated documentation files (the \\\"Software\\\"), to deal \\n* in the Software without restriction, including without limitation the rights \\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \\n* copies of the Software, and to permit persons to whom the Software is furnished to \\n* do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all \\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN \\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Blacklistable Token\\n * @dev Allows accounts to be blacklisted by a \\\"blacklister\\\" role\\n*/\\ncontract Blacklistable is Ownable {\\n\\n    address public blacklister;\\n    mapping(address =\\u003e bool) internal blacklisted;\\n\\n    event Blacklisted(address indexed _account);\\n    event UnBlacklisted(address indexed _account);\\n    event BlacklisterChanged(address indexed newBlacklister);\\n\\n    /**\\n     * @dev Throws if called by any account other than the blacklister\\n    */\\n    modifier onlyBlacklister() {\\n        require(msg.sender == blacklister);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if argument account is blacklisted\\n     * @param _account The address to check\\n    */\\n    modifier notBlacklisted(address _account) {\\n        require(blacklisted[_account] == false);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Checks if account is blacklisted\\n     * @param _account The address to check    \\n    */\\n    function isBlacklisted(address _account) public view returns (bool) {\\n        return blacklisted[_account];\\n    }\\n\\n    /**\\n     * @dev Adds account to blacklist\\n     * @param _account The address to blacklist\\n    */\\n    function blacklist(address _account) public onlyBlacklister {\\n        blacklisted[_account] = true;\\n        emit Blacklisted(_account);\\n    }\\n\\n    /**\\n     * @dev Removes account from blacklist\\n     * @param _account The address to remove from the blacklist\\n    */\\n    function unBlacklist(address _account) public onlyBlacklister {\\n        blacklisted[_account] = false;\\n        emit UnBlacklisted(_account);\\n    }\\n\\n    function updateBlacklister(address _newBlacklister) public onlyOwner {\\n        require(_newBlacklister != address(0));\\n        blacklister = _newBlacklister;\\n        emit BlacklisterChanged(blacklister);\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract ERC20 is IERC20 {\\n  using SafeMath for uint256;\\n\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n  uint256 private _totalSupply;\\n\\n  /**\\n  * @dev Total number of tokens in existence\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param owner The address to query the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param owner address The address which owns the funds.\\n   * @param spender address The address which will spend the funds.\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return _allowed[owner][spender];\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified address\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function transfer(address to, uint256 value) public returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   * @param spender The address which will spend the funds.\\n   * @param value The amount of tokens to be spent.\\n   */\\n  function approve(address spender, uint256 value) public returns (bool) {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param from address The address which you want to send tokens from\\n   * @param to address The address which you want to transfer to\\n   * @param value uint256 the amount of tokens to be transferred\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(value \\u003c= _allowed[from][msg.sender]);\\n\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    _transfer(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\n   * approve should be called when allowed_[_spender] == 0. To increment\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param spender The address which will spend the funds.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n   * approve should be called when allowed_[_spender] == 0. To decrement\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param spender The address which will spend the funds.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    require(spender != address(0));\\n\\n    _allowed[msg.sender][spender] = (\\n      _allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Transfer token for a specified addresses\\n  * @param from The address to transfer from.\\n  * @param to The address to transfer to.\\n  * @param value The amount to be transferred.\\n  */\\n  function _transfer(address from, address to, uint256 value) internal {\\n    require(value \\u003c= _balances[from]);\\n    require(to != address(0));\\n\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /**\\n   * @dev Internal function that mints an amount of the token and assigns it to\\n   * an account. This encapsulates the modification of balances such that the\\n   * proper events are emitted.\\n   * @param account The account that will receive the created tokens.\\n   * @param value The amount that will be created.\\n   */\\n  function _mint(address account, uint256 value) internal {\\n    require(account != 0);\\n    _totalSupply = _totalSupply.add(value);\\n    _balances[account] = _balances[account].add(value);\\n    emit Transfer(address(0), account, value);\\n  }\\n\\n  /**\\n   * @dev Internal function that burns an amount of the token of a given\\n   * account.\\n   * @param account The account whose tokens will be burnt.\\n   * @param value The amount that will be burnt.\\n   */\\n  function _burn(address account, uint256 value) internal {\\n    require(account != 0);\\n    require(value \\u003c= _balances[account]);\\n\\n    _totalSupply = _totalSupply.sub(value);\\n    _balances[account] = _balances[account].sub(value);\\n    emit Transfer(account, address(0), value);\\n  }\\n\\n  /**\\n   * @dev Internal function that burns an amount of the token of a given\\n   * account, deducting from the sender\\u0027s allowance for said account. Uses the\\n   * internal burn function.\\n   * @param account The account whose tokens will be burnt.\\n   * @param value The amount that will be burnt.\\n   */\\n  function _burnFrom(address account, uint256 value) internal {\\n    require(value \\u003c= _allowed[account][msg.sender]);\\n\\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n    // this function needs to emit an event with the updated approval.\\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n      value);\\n    _burn(account, value);\\n  }\\n}\\n\"},\"FiatTokenV1.sol\":{\"content\":\"/**\\n* Copyright CENTRE SECZ 2018\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy \\n* of this software and associated documentation files (the \\\"Software\\\"), to deal \\n* in the Software without restriction, including without limitation the rights \\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \\n* copies of the Software, and to permit persons to whom the Software is furnished to \\n* do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all \\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN \\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\u0027./ERC20.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\nimport \\u0027./Ownable.sol\\u0027;\\nimport \\u0027./Blacklistable.sol\\u0027;\\nimport \\\"./Pausable.sol\\\";\\n\\n/**\\n * @title FiatToken\\n * @dev ERC20 Token backed by fiat reserves\\n */\\ncontract FiatTokenV1 is Ownable, ERC20, Pausable, Blacklistable {\\n    using SafeMath for uint256;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    string public currency;\\n    address public masterMinter;\\n    bool internal initialized;\\n\\n    mapping(address =\\u003e uint256) internal balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal allowed;\\n    uint256 internal totalSupply_ = 0;\\n    mapping(address =\\u003e bool) internal minters;\\n    mapping(address =\\u003e uint256) internal minterAllowed;\\n\\n    event Mint(address indexed minter, address indexed to, uint256 amount);\\n    event Burn(address indexed burner, uint256 amount);\\n    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\\n    event MinterRemoved(address indexed oldMinter);\\n    event MasterMinterChanged(address indexed newMasterMinter);\\n\\n    function initialize(\\n        string _name,\\n        string _symbol,\\n        string _currency,\\n        uint8 _decimals,\\n        address _masterMinter,\\n        address _pauser,\\n        address _blacklister,\\n        address _owner\\n    ) public {\\n        require(!initialized);\\n        require(_masterMinter != address(0));\\n        require(_pauser != address(0));\\n        require(_blacklister != address(0));\\n        require(_owner != address(0));\\n\\n        name = _name;\\n        symbol = _symbol;\\n        currency = _currency;\\n        decimals = _decimals;\\n        masterMinter = _masterMinter;\\n        pauser = _pauser;\\n        blacklister = _blacklister;\\n        setOwner(_owner);\\n        initialized = true;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than a minter\\n    */\\n    modifier onlyMinters() {\\n        require(minters[msg.sender] == true);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function to mint tokens\\n     * @param _to The address that will receive the minted tokens.\\n     * @param _amount The amount of tokens to mint. Must be less than or equal to the minterAllowance of the caller.\\n     * @return A boolean that indicates if the operation was successful.\\n    */\\n    function mint(address _to, uint256 _amount) whenNotPaused onlyMinters notBlacklisted(msg.sender) notBlacklisted(_to) public returns (bool) {\\n        require(_to != address(0));\\n        require(_amount \\u003e 0);\\n\\n        uint256 mintingAllowedAmount = minterAllowed[msg.sender];\\n        require(_amount \\u003c= mintingAllowedAmount);\\n\\n        totalSupply_ = totalSupply_.add(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);\\n        emit Mint(msg.sender, _to, _amount);\\n        emit Transfer(0x0, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the masterMinter\\n    */\\n    modifier onlyMasterMinter() {\\n        require(msg.sender == masterMinter);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Get minter allowance for an account\\n     * @param minter The address of the minter\\n    */\\n    function minterAllowance(address minter) public view returns (uint256) {\\n        return minterAllowed[minter];\\n    }\\n\\n    /**\\n     * @dev Checks if account is a minter\\n     * @param account The address to check    \\n    */\\n    function isMinter(address account) public view returns (bool) {\\n        return minters[account];\\n    }\\n\\n    /**\\n     * @dev Get allowed amount for an account\\n     * @param owner address The account owner\\n     * @param spender address The account spender\\n    */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Get totalSupply of token\\n    */\\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n     * @dev Get token balance of an account\\n     * @param account address The account\\n    */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return balances[account];\\n    }\\n\\n    /**\\n     * @dev Adds blacklisted check to approve\\n     * @return True if the operation was successful.\\n    */\\n    function approve(address _spender, uint256 _value) whenNotPaused notBlacklisted(msg.sender) notBlacklisted(_spender) public returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     * @return bool success\\n    */\\n    function transferFrom(address _from, address _to, uint256 _value) whenNotPaused notBlacklisted(_to) notBlacklisted(msg.sender) notBlacklisted(_from) public returns (bool) {\\n        require(_to != address(0));\\n        require(_value \\u003c= balances[_from]);\\n        require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev transfer token for a specified address\\n     * @param _to The address to transfer to.\\n     * @param _value The amount to be transferred.\\n     * @return bool success\\n    */\\n    function transfer(address _to, uint256 _value) whenNotPaused notBlacklisted(msg.sender) notBlacklisted(_to) public returns (bool) {\\n        require(_to != address(0));\\n        require(_value \\u003c= balances[msg.sender]);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to add/update a new minter\\n     * @param minter The address of the minter\\n     * @param minterAllowedAmount The minting amount allowed for the minter\\n     * @return True if the operation was successful.\\n    */\\n    function configureMinter(address minter, uint256 minterAllowedAmount) whenNotPaused onlyMasterMinter public returns (bool) {\\n        minters[minter] = true;\\n        minterAllowed[minter] = minterAllowedAmount;\\n        emit MinterConfigured(minter, minterAllowedAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to remove a minter\\n     * @param minter The address of the minter to remove\\n     * @return True if the operation was successful.\\n    */\\n    function removeMinter(address minter) onlyMasterMinter public returns (bool) {\\n        minters[minter] = false;\\n        minterAllowed[minter] = 0;\\n        emit MinterRemoved(minter);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev allows a minter to burn some of its own tokens\\n     * Validates that caller is a minter and that sender is not blacklisted\\n     * amount is less than or equal to the minter\\u0027s account balance\\n     * @param _amount uint256 the amount of tokens to be burned\\n    */\\n    function burn(uint256 _amount) whenNotPaused onlyMinters notBlacklisted(msg.sender) public {\\n        uint256 balance = balances[msg.sender];\\n        require(_amount \\u003e 0);\\n        require(balance \\u003e= _amount);\\n\\n        totalSupply_ = totalSupply_.sub(_amount);\\n        balances[msg.sender] = balance.sub(_amount);\\n        emit Burn(msg.sender, _amount);\\n        emit Transfer(msg.sender, address(0), _amount);\\n    }\\n\\n    function updateMasterMinter(address _newMasterMinter) onlyOwner public {\\n        require(_newMasterMinter != address(0));\\n        masterMinter = _newMasterMinter;\\n        emit MasterMinterChanged(masterMinter);\\n    }\\n}\\n\"},\"FiatTokenV2.sol\":{\"content\":\"/**\\n* Copyright CENTRE SECZ 2018\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is furnished to\\n* do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\u0027./FiatTokenV1.sol\\u0027;\\n\\n/**\\n * @title FiatTokenV2\\n * @dev ERC20 Token backed by fiat reserves\\n */\\ncontract FiatTokenV2 is FiatTokenV1 {\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"},\"Ownable.sol\":{\"content\":\"/**\\n* Copyright CENTRE SECZ 2018\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy \\n* of this software and associated documentation files (the \\\"Software\\\"), to deal \\n* in the Software without restriction, including without limitation the rights \\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \\n* copies of the Software, and to permit persons to whom the Software is furnished to \\n* do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all \\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN \\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract from https://github.com/zeppelinos/labs/blob/master/upgradeability_ownership/contracts/ownership/Ownable.sol \\n * branch: master commit: 3887ab77b8adafba4a26ace002f3a684c1a3388b modified to:\\n * 1) Add emit prefix to OwnershipTransferred event (7/13/18)\\n * 2) Replace constructor with constructor syntax (7/13/18)\\n * 3) consolidate OwnableStorage into this contract\\n */\\ncontract Ownable {\\n\\n  // Owner of the contract\\n  address private _owner;\\n\\n  /**\\n  * @dev Event to show ownership has been transferred\\n  * @param previousOwner representing the address of the previous owner\\n  * @param newOwner representing the address of the new owner\\n  */\\n  event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n  /**\\n  * @dev The constructor sets the original owner of the contract to the sender account.\\n  */\\n  constructor() public {\\n    setOwner(msg.sender);\\n  }\\n\\n  /**\\n * @dev Tells the address of the owner\\n * @return the address of the owner\\n */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Sets a new owner address\\n   */\\n  function setOwner(address newOwner) internal {\\n    _owner = newOwner;\\n  }\\n\\n  /**\\n  * @dev Throws if called by any account other than the owner.\\n  */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner(), newOwner);\\n    setOwner(newOwner);\\n  }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"/**\\n* Copyright CENTRE SECZ 2018\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy \\n* of this software and associated documentation files (the \\\"Software\\\"), to deal \\n* in the Software without restriction, including without limitation the rights \\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \\n* copies of the Software, and to permit persons to whom the Software is furnished to \\n* do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all \\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN \\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n * Based on openzeppelin tag v1.10.0 commit: feb665136c0dae9912e08397c1a21c4af3651ef3\\n * Modifications:\\n * 1) Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)\\n * 2) Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)\\n * 3) Removed whenPaused (6/14/2018)\\n * 4) Switches ownable library to use zeppelinos (7/12/18)\\n * 5) Remove constructor (7/13/18)\\n */\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n  event PauserChanged(address indexed newAddress);\\n\\n\\n  address public pauser;\\n  bool public paused = false;\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev throws if called by any account other than the pauser\\n   */\\n  modifier onlyPauser() {\\n    require(msg.sender == pauser);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyPauser public {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() onlyPauser public {\\n    paused = false;\\n    emit Unpause();\\n  }\\n\\n  /**\\n   * @dev update the pauser role\\n   */\\n  function updatePauser(address _newPauser) onlyOwner public {\\n    require(_newPauser != address(0));\\n    pauser = _newPauser;\\n    emit PauserChanged(pauser);\\n  }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_currency\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_masterMinter\",\"type\":\"address\"},{\"name\":\"_pauser\",\"type\":\"address\"},{\"name\":\"_blacklister\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"},{\"name\":\"minterAllowedAmount\",\"type\":\"uint256\"}],\"name\":\"configureMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"minterAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMasterMinter\",\"type\":\"address\"}],\"name\":\"updateMasterMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBlacklister\",\"type\":\"address\"}],\"name\":\"updateBlacklister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blacklister\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minterAllowedAmount\",\"type\":\"uint256\"}],\"name\":\"MinterConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldMinter\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newMasterMinter\",\"type\":\"address\"}],\"name\":\"MasterMinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newBlacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FiatTokenV2","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://528f390edf2af6e06196a8f5a72d9e02d6f1a24f87ae9834feb9e7f8f56686bc"}]}