{"status":"1","message":"OK","result":[{"SourceCode":"{\"Drops.sol\":{\"content\":\"pragma solidity ^0.5.1;\\r\\nimport \\\"./ERC20_Token.sol\\\";\\r\\n\\r\\n/**\\r\\n * \\r\\n * @title Drops (DRP)\\r\\n * @dev Drops crypto currency smart contract based upon the ERC20 standart token \\r\\n *\\r\\n * Drops (DRP) Smart Contract v1.0 08.09.2019  (c) Mark R Rogers, 2019.\\r\\n * \\r\\n **/\\r\\ncontract Drops is ERC20_Token {                                                     // Build on ERC20 standard contract \\r\\n    // Initalise variables and data\\r\\n    string constant TOKEN_NAME = \\\"Drops\\\";                                           // Token description\\r\\n    string constant TOKEN_SYMBOL = \\\"DRP\\\";                                           // Token symbol\\r\\n    uint8  constant TOKEN_DECIMALS = 8;                                             // Token decimals\\r\\n\\r\\n    // Initial contract deployment setup\\r\\n    // @notice only run when the contract is created\\r\\n    // @param initialMint_ The amount of coins to create\\r\\n    constructor(uint256 initialMint_) public {\\r\\n        name = TOKEN_NAME;                                                          // Set description\\r\\n        symbol = TOKEN_SYMBOL;                                                      // Set symbol\\r\\n        decimals = TOKEN_DECIMALS;                                                  // Set decimals\\r\\n        coinOwner = msg.sender;                                                     // Set coin owner identity\\r\\n        coinSupply = initialMint_.toklets(TOKEN_DECIMALS);                          // Set total supply in droplets\\r\\n        balances[msg.sender] = coinSupply;                                          // Set owners balance\\r\\n    }\\r\\n}\"},\"ERC20_Token.sol\":{\"content\":\"pragma solidity ^0.5.1;\\r\\nimport \\\"../Genesis.sol\\\";\\r\\n\\r\\n/**\\r\\n * \\r\\n * @title ERC20 Standard Token\\r\\n * \\r\\n * Inherits events, modifiers \\u0026 data from the genesis contract which complies with the ERC20 token Standard.\\r\\n * Inizalizes genesis functions \\u0026 extra added functions\\r\\n * \\r\\n **/\\r\\ncontract ERC20_Token is Genesis {                                                     // Build on genesis contract\\r\\n    // Initalise global constants\\r\\n    string constant ERR_INSUFFICENT_BALANCE = \\\"Insufficent amount of DRP\\\";          // Error message 102\\r\\n    string constant ERR_INVALID_DELEGATE    = \\\"Invalid delegate address\\\";           // Error message 103\\r\\n    string constant ERR_ALLOWANCE_EXCEEDED  = \\\"Allowance exceeded!\\\";                // Error message 104\\r\\n    string constant ERR_INVALID_KILL_CODE   = \\\"Invalid kill code!\\\";                 // Error message 105\\r\\n    string constant KILL_CODE               = \\\"K-C102-473\\\";                         // WARNING! Contracts kill code\\r\\n\\r\\n    // Create new tokens\\r\\n    // @para tokens_ number of new tokens to create\\r\\n    function mintCoins(uint tokens_) ownerOnly public returns (uint balance) {\\r\\n        tokens_ = tokens_.toklets(decimals);                                        // Convert tokens to toklets\\r\\n        coinSupply = coinSupply.add(tokens_);                                       // Create new tokens\\r\\n        balances[coinOwner] = balances[coinOwner].add(tokens_);                     // Update owners balace\\r\\n      return coinSupply;\\r\\n    }\\r\\n    \\r\\n    // Destroy tokens\\r\\n    // @para tokens_ number of tokens to destroy\\r\\n    function burnCoins(uint tokens_) ownerOnly public returns (uint balance) {      // Restricted to owner only\\r\\n        tokens_ = tokens_.toklets(decimals);                                        // Convert tokens to toklets\\r\\n        if (valid(tokens_ \\u003c= balances[coinOwner], 102)) {                           // Check enough tokens available\\r\\n            coinSupply = coinSupply.sub(tokens_);                                   // Decrease total coin supply\\r\\n            balances[coinOwner] = balances[coinOwner].sub(tokens_);                 // Update owners token balance\\r\\n          return coinSupply;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Genesis: Transfer tokens to receiver\\r\\n    function transfer(address receiver_,\\r\\n                     uint tokens_) public returns (bool sucess) {\\r\\n      super.transfer(receiver_, tokens_);\\r\\n        if (valid(tokens_ \\u003c= balances[msg.sender] \\u0026\\u0026                                // Check enough tokens available\\r\\n            tokens_ \\u003e 0, 102)) {                                                    // and amount greater than zero\\r\\n            balances[msg.sender] = balances[msg.sender].sub(tokens_);               // Decrease senders token balance\\r\\n            balances[receiver_] = balances[receiver_].add(tokens_);                 // Increase receivers token balance\\r\\n            emit Transfer(msg.sender, receiver_, tokens_);                          // Transfer tokens\\r\\n          return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Genesis: Approve token allowence for delegate\\r\\n    function approve(address delegate_,\\r\\n                    uint tokens_) public returns (bool sucess) {\\r\\n      super.approve(delegate_, tokens_);\\r\\n        if (valid(delegate_ != msg.sender, 103)) {                                  // Check not delegating to yourself\\r\\n            if (tokens_ \\u003e coinSupply) { tokens_ = coinSupply; }                     // Limit allowance to total supply\\r\\n            allowed[msg.sender][delegate_] = tokens_;                               // Update token allowence\\r\\n            emit Approval(msg.sender, delegate_, tokens_);                          // Approve token allowance\\r\\n          return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Genesis: Transfer token from delegated address\\r\\n    function transferFrom(address owner_, address receiver_,\\r\\n                         uint tokens_) public returns (bool sucess) {\\r\\n      super.transferFrom(owner_ , receiver_, tokens_);\\r\\n        if (valid(tokens_ \\u003e 0 \\u0026\\u0026 tokens_ \\u003c= balances[owner_], 102) \\u0026\\u0026               // Check amount greater than zero and enough tokens available\\r\\n            valid(tokens_ \\u003c= allowed[owner_][msg.sender], 104)) {                   // Make sure smount is equal or less than token allowance\\r\\n            balances[owner_] = balances[owner_].sub(tokens_);                       // Decrease owner of tokens balance\\r\\n            allowed[owner_][msg.sender] = allowed[owner_][msg.sender].sub(tokens_); // Decrease senders tokens allowance\\r\\n            balances[receiver_] = balances[receiver_].add(tokens_);                 // Increase receivers tokens balance\\r\\n            emit Transfer(owner_, receiver_, tokens_);                              // Transfer tokens from the owner to the receiver\\r\\n        return true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Validation for autherisation and input error handler\\r\\n    function valid(bool valid_, uint errorID_) internal pure returns (bool) {       // Check for fatal errors\\r\\n        if (errorID_ == 101) {require(valid_, ERR_PERMISSION_DENIED);}              // Calling address doesn\\u0027t have permission\\r\\n          else if (errorID_ == 102) {require(valid_, ERR_INSUFFICENT_BALANCE);}     // Cancel trasaction due to insufficent value\\r\\n          else if (errorID_ == 103) {require(valid_, ERR_INVALID_DELEGATE);}        // Cannot delegate to address \\r\\n          else if (errorID_ == 104) {require(valid_, ERR_ALLOWANCE_EXCEEDED);}      // Cancel trasaction due to insufficent value\\r\\n          else if (errorID_ == 105) {require(valid_, ERR_INVALID_KILL_CODE);}       // Cancel trasaction due to insufficent value\\r\\n          else if (errorID_ == 100) {require (valid_);}                             // Check if required?\\r\\n        return valid_;\\r\\n    }\\r\\n    \\r\\n    // WARNING! CONFIRM NOTHING ELSE NEEDS THIS CONTRACT BEFORE BURNING IT!\\r\\n    // Terminates contract\\r\\n    // @param killCode_ The contracts kill code\\r\\n    // @return if contract has been terminated\\r\\n    function burnContract(string memory killCode_) ownerOnly public {\\r\\n        if (valid((keccak256(abi.encodePacked(killCode_)) ==\\r\\n                   keccak256(abi.encodePacked(KILL_CODE))), 105))                    // Authenticate kill code\\r\\n                   { selfdestruct(address(0)); }                                     // Kill contract\\r\\n    }\\r\\n}\"},\"Genesis.sol\":{\"content\":\"pragma solidity ^0.5.1;\\r\\n\\r\\n/**\\r\\n * \\r\\n * @title SafeMath Library\\r\\n * \\r\\n * @dev Math operations with safety checks that throw on logic error\\r\\n * \\r\\n *\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    // Converts Tokens into Toklets\\r\\n    function toklets(uint256 numA_, uint8 numD_) internal pure returns (uint256) {\\r\\n        uint256 numB_ = 10**uint256(numD_);\\r\\n        uint256 numC_ = numA_ * numB_;\\r\\n        require(numA_ \\u003e 0 \\u0026\\u0026 numC_ / numA_ == numB_, \\\"Invalid amount of tokens\\\");\\r\\n      return numC_;\\r\\n    }\\r\\n \\r\\n    // Multipy unsigned integer value and check logic \\r\\n    function mul(uint256 numA_, uint256 numB_) internal pure returns (uint256) {\\r\\n        uint256 numC_ = numA_ * numB_;\\r\\n        assert(numA_ == 0 || numC_ / numA_ == numB_);\\r\\n      return numC_;\\r\\n    }\\r\\n \\r\\n    // Divide unsigned integer value and check logic\\r\\n    function div(uint256 numA_, uint256 numB_) internal pure returns (uint256) {\\r\\n        uint256 numC_ = numA_ / numB_;                                                           // Solidity automatically throws when dividing by 0\\r\\n      return numC_;\\r\\n    }\\r\\n\\r\\n    // Subtract unsigned integer value and check logic\\r\\n    function sub(uint256 numA_, uint256 numB_) internal pure returns (uint256) {\\r\\n        assert(numB_ \\u003c= numA_);\\r\\n      return numA_ - numB_;\\r\\n    }\\r\\n\\r\\n     // Add unsigned integer values and check logic\\r\\n    function add(uint256 numA_, uint256 numB_) internal pure returns (uint256) {\\r\\n        uint256 numC_ = numA_ + numB_;\\r\\n        assert(numC_ \\u003e= numA_);\\r\\n      return numC_;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\r\\n * @title Genesis Contract\\r\\n * \\r\\n * Initializes events, modifiers \\u0026 data in the contract and defines default functionality\\r\\n * that follows the ERC20 standard token format\\r\\n * \\r\\n **/\\r\\ncontract Genesis {\\r\\n    using SafeMath for uint256;                                                     // Use SafeMath library to test the logic of uint256 calculations\\r\\n\\r\\n    // Initalise contract global constants\\r\\n    string constant ERR_PERMISSION_DENIED   = \\\"Permission denied!\\\";                 // Error message 101\\r\\n\\r\\n    // Initalise token information \\r\\n    string public name;                                                             // Token Name\\r\\n    string public symbol;                                                           // Token Symbol\\r\\n    uint8  public decimals;                                                         // Token decimals (droplets)\\r\\n    address coinOwner ;                                                             // Token owners address\\r\\n    uint256 coinSupply;                                                             // Total token supply\\r\\n    mapping(address =\\u003e uint256) balances;                                           // Token balance state\\r\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) allowed;                       // Token allowance state\\r\\n\\r\\n    // Owner privelages only \\r\\n    modifier ownerOnly() {\\r\\n        require(msg.sender == coinOwner, ERR_PERMISSION_DENIED) ;\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Transfer tokens\\r\\n    event Transfer(address indexed owner_, address indexed receiver_, uint256 tokens_);\\r\\n    \\r\\n    // Approve token allowances\\r\\n    event Approval(address indexed owner_, address indexed delegate_, uint256 tokens_);\\r\\n\\r\\n    // Fallback function handles unidentified calls and allows contract to receive payments\\r\\n    function() payable external { }\\r\\n    \\r\\n    // @return total supply of tokens\\r\\n    function totalSupply() external view returns (uint256 supply) { return coinSupply; }\\r\\n    \\r\\n    // @return number of tokens at address\\r\\n    function balanceOf(address owner_) external view returns (uint balance) { return balances[owner_]; }\\r\\n    \\r\\n    // Transfer tokens to receiver\\r\\n    // @notice send `token_` token to `receiver_` from `msg.sender`\\r\\n    // @param receiver_ The address of the recipient\\r\\n    // @param token_ The amount of token to be transferred\\r\\n    // @return whether the transfer was successful or not\\r\\n    function transfer(address receiver_, uint tokens_) public returns (bool sucess) {}\\r\\n\\r\\n    // Approve tokens allowence for delegate\\r\\n    // @notice `msg.sender` approves `delegate_` to spend `_tokens`\\r\\n    // @param _receiver The address of the account able to transfer the tokens\\r\\n    // @param _tokens The amount of wei to be approved for transfer\\r\\n    // @return Whether the approval was successful or not\\r\\n    function approve(address delegate_, uint tokens_) public returns (bool sucess) {}\\r\\n    \\r\\n    // Returns approved tokens allowance for delegate\\r\\n    // @param _owner The address of the account owning tokens\\r\\n    // @param _spender The address of the account able to transfer the tokens\\r\\n    // @return Amount of remaining tokens allowed to spent\\r\\n    function allowance(address owner_, address delegate_) external view returns (uint remaining) { return allowed[owner_][delegate_]; }\\r\\n\\r\\n    // Transfer tokens from delegated address\\r\\n    // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\r\\n    // @param _from The address of the sender\\r\\n    // @param _to The address of the recipient\\r\\n    // @param _value The amount of token to be transferred\\r\\n    // @return Whether the transfer was successful or not\\r\\n    function transferFrom(address owner_, address receiver_, uint tokens_) public returns (bool sucess) { }\\r\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"burnCoins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"sucess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"sucess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"killCode_\",\"type\":\"string\"}],\"name\":\"burnContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"mintCoins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"sucess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate_\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialMint_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Drops","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca00","Library":"","LicenseType":"None","SwarmSource":"bzzr://66c898132a394a38078772b37a08ad69946d62e368e1eddc4f9fde925a526fef"}]}