{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *created on 2019-07-11\r\n*/\r\n\r\npragma solidity ^0.4.20;\r\n\r\n/*\r\n* RANLYTICS ICO CONTRACT\r\n* Offers dividend distribution-based returns for all token holders equivalent to that received by all RANlytics shareholders\r\n* 300,000 tokens on offer - no more can be created once quota is filled. Tokens generated as purchased\r\n* Each token is equivalent to 1 RANlytics share.\r\n* In the event that the company is sold, the total proceeds of the sale will be divided equally by the total pool of shares + tokens, \r\n* and both shareholders and token holders will receive payment from the proceeds of the sale proportionate to their total share or token holding.\r\n*/\r\n\r\ncontract Hourglass {\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlyholders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with dividends\r\n    modifier hasDividends() {\r\n        require(myDividends() > 0);\r\n        _;\r\n    }\r\n    \r\n    // administrators can:\r\n    // -> change the name of the contract\r\n    // -> change the name of the token\r\n    // -> burn tokens in admin address\r\n    // -> close token buying\r\n    // they CANNOT:\r\n    // -> disable dividend withdrawals\r\n    // -> kill the contract\r\n    // -> change the price of tokens\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[_customerAddress]);\r\n        _;\r\n    }\r\n    \r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    event onCompanyBurn(\r\n        uint256 tokensBurnt\r\n    );\r\n    \r\n    // ERC20 spec\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"RANlytics Round C ICO\";\r\n    string public symbol = \"RANC\";\r\n    uint8 constant public decimals = 18;\r\n    uint256 constant maxTokens = 300000*1e18;\r\n    address constant internal companyAccount_ = 0xbADEc210d7E0E4082f8e9BC7b1C1abCAb925F4b8;\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 internal profitPerShare_;\r\n    \r\n    // administrator list (see above on what they can do)\r\n    mapping(address => bool) public administrators;\r\n    \r\n    //lock further investments\r\n    bool internal locked_ = false;\r\n\r\n    \r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    function Hourglass()\r\n        public\r\n    {\r\n        // add administrators here\r\n        administrators[0xbADEc210d7E0E4082f8e9BC7b1C1abCAb925F4b8] = true;\r\n\r\n    }\r\n    \r\n     \r\n    /**\r\n     * Converts all incoming ethereum to tokens for the caller\r\n     */\r\n    function buy()\r\n        public\r\n        payable\r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n    \r\n    /**\r\n     * Fallback function to handle ethereum that was sent straight to the contract\r\n     * Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function()\r\n        payable\r\n        public\r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n    \r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw()\r\n        hasDividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends(); \r\n        \r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends);\r\n        \r\n        \r\n        // lambo delivery service\r\n        _customerAddress.transfer(_dividends);\r\n        \r\n        // fire event\r\n        onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n  \r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyholders()\r\n        public\r\n        returns(bool)\r\n    {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n        \r\n        // make sure we have the requested tokens\r\n        // also disables transfers until ambassador phase is over\r\n        // ( we dont want whale premines )\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        \r\n        // withdraw all outstanding dividends first\r\n        if(myDividends() > 0) withdraw();\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n        \r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens / 1e18);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens / 1e18);\r\n        \r\n        \r\n        // fire event\r\n        Transfer(_customerAddress, _toAddress, _amountOfTokens);\r\n        \r\n        // ERC20\r\n        return true;\r\n       \r\n    }\r\n    \r\n\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n\r\n    /**\r\n     * In case one of us dies, we need to replace ourselves.\r\n     */\r\n    function setAdministrator(address _identifier, bool _status)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    \r\n    function payDividend()\r\n        onlyAdministrator()\r\n        payable\r\n        public\r\n    {\r\n        profitPerShare_ = SafeMath.add(profitPerShare_, (msg.value * 1e18 ) / tokenSupply_);    \r\n    }\r\n    \r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setName(string _name)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n    \r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setSymbol(string _symbol)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /**\r\n     *  If we want to burn tokens being converted to RANlytics shares.\r\n     */\r\n    function burnAdminTokens()\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        address _adminAddress = msg.sender;\r\n        require(tokenBalanceLedger_[_adminAddress] > 0);\r\n        \r\n        //decrease token supply\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, tokenBalanceLedger_[_adminAddress]);\r\n        \r\n        //burn tokens in admin address\r\n        tokenBalanceLedger_[_adminAddress] = 0;\r\n        \r\n        //fire event on burnt tokens\r\n        onCompanyBurn(tokenBalanceLedger_[_adminAddress]);\r\n    }\r\n\r\n     /**\r\n     * If we want to lock buying early, we can.\r\n     */\r\n    function lockBuying()\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        locked_ = true;\r\n    }\r\n    \r\n    /**\r\n     * dividends are rounded down to wei, as such we may see dust settle in the contract.\r\n     * admin has the ability to claim this dust\r\n     * Only call if all users have withdrawn all dividends\r\n     * the function can only work if dust left is less than 0.00010000 eth so admin can't claim unclaimed dividends\r\n     * \r\n     */\r\n    function cleanupEthInContract()\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        require(this.balance < 10000);\r\n         companyAccount_.transfer(this.balance);\r\n    }\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     * Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return this.balance;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the status of buying enabled or not.\r\n     * true if buying still possible\r\n     */\r\n    function buyOpen()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return !locked_;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n     */ \r\n    function myDividends() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return  dividendsOf(_customerAddress) ;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return (uint256) ((int256)(SafeMath.mul(profitPerShare_ , tokenBalanceLedger_[_customerAddress] )) / 1e18 - payoutsTo_[_customerAddress]) ;\r\n    }\r\n    \r\n    \r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    function purchaseTokens(uint256 _incomingEthereum)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        //we require the buy in is not locked\r\n        require(!locked_);\r\n        \r\n        //we require a minumum buyin of 0.1 ethereum\r\n        require(_incomingEthereum >= 1e17);\r\n        \r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        uint256 _amountOfTokens = _incomingEthereum * 20;\r\n        \r\n        // no point in continuing execution if OP is a hacker\r\n        // prevents overflow in the case that the ICO somehow magically starts being used by everyone in the world\r\n        // (or hackers)\r\n        // and yes we know that the safemath function automatically rules out the \"greater than\" equation.\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n        \r\n        //any purchase over a total of 300,000 tokens is rejected\r\n        require(SafeMath.add(tokenSupply_, _amountOfTokens) < maxTokens);\r\n        \r\n        // we can't give people infinite ethereum\r\n        if(tokenSupply_ > 0){\r\n            \r\n            // add tokens to the pool\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n        \r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n        \r\n        //set the invest lock if more than 300000 tokens are allocated\r\n        //we will accept the last buyers order and allocate those shares over the 300000 shares as an over subscription.\r\n        if (tokenSupply_ > maxTokens) locked_ = true;\r\n        \r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        \r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens / 1e18) );\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n        \r\n        //transfer all ethereum to RANLytics\r\n        companyAccount_.transfer(_incomingEthereum);\r\n        \r\n        // fire event\r\n        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n\r\n   \r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payDividend\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cleanupEthInContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnAdminTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockBuying\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokensBurnt\",\"type\":\"uint256\"}],\"name\":\"onCompanyBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Hourglass","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d19f90d46a20e5035b81a4aaa1e469a9874e9e3002ace895ed0195201e3b0ed"}]}