{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\ncontract ITokenSeller {\n    \n    \n    \n    \n    function sellToken(\n        address tokenS,\n        address tokenB\n        )\n        external\n        payable\n        returns (bool success);\n}\n\ncontract ERC20 {\n    function totalSupply()\n        public\n        view\n        returns (uint);\n\n    function balanceOf(\n        address who\n        )\n        public\n        view\n        returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n        )\n        public\n        view\n        returns (uint);\n\n    function transfer(\n        address to,\n        uint value\n        )\n        public\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint    value\n        )\n        public\n        returns (bool);\n\n    function approve(\n        address spender,\n        uint    value\n        )\n        public\n        returns (bool);\n}\n\nlibrary MathUint {\n    function mul(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n    }\n\n    function sub(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        require(b <= a, \"SUB_UNDERFLOW\");\n        return a - b;\n    }\n\n    function add(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n    }\n\n    function decodeFloat(\n        uint f\n        )\n        internal\n        pure\n        returns (uint value)\n    {\n        uint numBitsMantissa = 23;\n        uint exponent = f >> numBitsMantissa;\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n        value = mantissa * (10 ** exponent);\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract UniswapExchangeInterface {\n    \n    function tokenAddress() external view returns (address token);\n    \n    function factoryAddress() external view returns (address factory);\n    \n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    \n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    \n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    \n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    \n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    \n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    \n    bytes32 public name;\n    bytes32 public symbol;\n    uint256 public decimals;\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    \n    function setup(address token_addr) external;\n}\n\ncontract UniswapFactoryInterface {\n    \n    address public exchangeTemplate;\n    uint256 public tokenCount;\n    \n    function createExchange(address token) external returns (address exchange);\n    \n    function getExchange(address token) external view returns (address exchange);\n    function getToken(address exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    \n    function initializeFactory(address template) external;\n}\n\ncontract UniswapTokenSeller is ReentrancyGuard, ITokenSeller {\n\n    using MathUint for uint;\n\n    uint256 constant MAX_UINT = ~uint(0);\n    uint    public constant MAX_SLIPPAGE_BIPS = 100; \n    address public uniswapFactoryAddress; \n    address public recipient;\n\n    event TokenSold (\n        address indexed seller,\n        address indexed recipient,\n        address         tokenS,\n        address         tokenB,\n        uint            amountS,\n        uint            amountB,\n        uint8           slippage,\n        uint64          time\n    );\n\n    constructor(\n        address _uniswapFactoryAddress,\n        address _recipient\n        )\n        public\n    {\n        require(_uniswapFactoryAddress != address(0), \"ZERO_ADDRESS\");\n        uniswapFactoryAddress = _uniswapFactoryAddress;\n        recipient = _recipient;\n    }\n\n    function sellToken(\n        address tokenS,\n        address tokenB\n        )\n        external\n        payable\n        nonReentrant\n        returns (bool success)\n    {\n        require(tokenS != tokenB, \"SAME_TOKEN\");\n\n        \n        address _recipient = recipient == address(0) ? msg.sender : recipient;\n        uint  amountS; \n        uint  amountB; \n        uint8 slippage;\n        UniswapExchangeInterface exchange;\n\n        if (tokenS == address(0)) {\n            \n            amountS = address(this).balance;\n            require(amountS > 0, \"ZERO_AMOUNT\");\n            exchange = getUniswapExchange(tokenB);\n\n            slippage = getSlippage(\n                exchange.getEthToTokenInputPrice(amountS),\n                exchange.getEthToTokenInputPrice(amountS.mul(2))\n            );\n\n            amountB = exchange.ethToTokenTransferInput.value(amountS)(\n                1,  \n                MAX_UINT,\n                _recipient\n            );\n        } else {\n            \n            amountS = ERC20(tokenS).balanceOf(address(this));\n            require(amountS > 0, \"ZERO_AMOUNT\");\n            exchange = getUniswapExchange(tokenS);\n\n            approveUniswapExchange(exchange, tokenS, amountS);\n\n            if (tokenB == address(0)) {\n                \n                slippage = getSlippage(\n                    exchange.getTokenToEthInputPrice(amountS),\n                    exchange.getTokenToEthInputPrice(amountS.mul(2))\n                );\n\n                amountB = exchange.tokenToEthTransferInput(\n                    amountS,\n                    1,  \n                    MAX_UINT,\n                    _recipient\n                );\n            } else {\n                \n                UniswapExchangeInterface exchangeB = getUniswapExchange(tokenB);\n                slippage = getSlippage(\n                    exchangeB.getEthToTokenInputPrice(exchange.getTokenToEthInputPrice(amountS)),\n                    exchangeB.getEthToTokenInputPrice(exchange.getTokenToEthInputPrice(amountS.mul(2)))\n                );\n\n                amountB = exchange.tokenToTokenTransferInput(\n                    amountS,\n                    1, \n                    1, \n                    MAX_UINT,\n                    _recipient,\n                    tokenB\n                );\n            }\n        }\n\n        emit TokenSold(\n            msg.sender,\n            _recipient,\n            tokenS,\n            tokenB,\n            amountS,\n            amountB,\n            slippage,\n            uint64(now)\n        );\n\n        return true;\n    }\n\n    function getUniswapExchange(address token)\n        private\n        view\n        returns (UniswapExchangeInterface)\n    {\n        UniswapFactoryInterface factory = UniswapFactoryInterface(uniswapFactoryAddress);\n        return UniswapExchangeInterface(factory.getExchange(token));\n    }\n\n    function approveUniswapExchange(\n        UniswapExchangeInterface exchange,\n        address tokenS,\n        uint    amountS\n        )\n        private\n    {\n        ERC20 token = ERC20(tokenS);\n        uint allowance = token.allowance(address(this), address(exchange));\n        if (allowance < amountS) {\n            require(\n                token.approve(address(exchange), MAX_UINT),\n                \"APPROVAL_FAILURE\"\n            );\n        }\n    }\n\n    function getSlippage(\n        uint amountB,\n        uint amountB2\n        )\n        private\n        pure\n        returns (uint8)\n    {\n        require(amountB > 0 && amountB2 > 0, \"INVALID_PRICE\");\n        uint slippageBips = amountB.mul(2).sub(amountB2).mul(10000) / amountB;\n        require(slippageBips <= MAX_SLIPPAGE_BIPS, \"SLIPPAGE_TOO_LARGE\");\n        return uint8(slippageBips);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SLIPPAGE_BIPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"sellToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenS\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"slippage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"TokenSold\",\"type\":\"event\"}]","ContractName":"UniswapTokenSeller","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c0a47dfe034b400b47bdad5fecda2621de6c4d95000000000000000000000000a8b6a3efbcdd578154a913f33dc9949808b7a9f4","Library":"","LicenseType":"","SwarmSource":"bzzr://02cbf19373a4ccd4075fe68bd95cd9c73c842637304316e3df9d383949cc32d0"}]}