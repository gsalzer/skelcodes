{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Implementation of the `IERC165` interface.\n *\n * Contracts may inherit from this and call `_registerInterface` to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See `IERC165.supportsInterface`.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See `IERC165.supportsInterface`.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: contracts/OrganizationInterface.sol\n\npragma solidity ^0.5.6;\n\n\n/**\n * @title Minimal 0xORG interface\n * \n * @dev If you are creating your own implementation of Winding\n * Tree Organization, this is the minimal interface that you must\n * fullfill. Without it, the Organization won't be added into the\n * SegmentDirectory. For checked interface ID, head over to the\n * implementation of `addOrganization` in `SegmentDirectory`.\n *\n * This is not meant to be used by libraries that try to operate\n * with the organization as any data manipulation methods are\n * intentionally omitted. It can be used only for reading data.\n */\ncontract OrganizationInterface is IERC165 {\n    /**\n     * @dev Returns the address of the current owner.\n     * @return {\" \": \"Current owner address.\"}\n     */\n    function owner() public view returns (address);\n\n    /**\n     * @dev Returns the URI of ORG.JSON file stored off-chain.\n     * @return {\" \": \"Current ORG.JSON URI.\"}\n     */\n    function getOrgJsonUri() external view returns (string memory);\n\n    /**\n     * @dev Returns keccak256 hash of raw ORG.JSON contents. This should\n     * be used to verify that the contents of ORG.JSON has not been tampered\n     * with. It is a responsibility of the Organization owner to keep this\n     * hash up to date.\n     * @return {\" \": \"Current ORG.JSON hash.\"}\n     */\n    function getOrgJsonHash() external view returns (bytes32);\n\n    /**\n     * @dev Returns if an `address` is associated with the Organization.\n     * Associated keys can be used on behalf of the organization,\n     * typically to sign messages.\n     *\n     * @param addr Associated Ethereum address\n     * @return {\" \": \"true if associated, false otherwise\"}\n     */\n    function hasAssociatedKey(address addr) external view returns (bool);\n\n    /**\n     * @dev Returns all associatedKeys belonging to this organization.\n     * @return {\" \": \"List of associatedKeys\"}\n     */\n    function getAssociatedKeys() external view returns (address[] memory);\n}\n\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/Organization.sol\n\npragma solidity ^0.5.6;\n\n\n\n\n/**\n * @title Organization\n * @dev A contract that represents an Organization in the Winding Tree platform,\n * commonly referred to as 0xORG. This is a reference implementation that is\n * created by the OrganizationFactory. You cn implement your own logic if it\n * adheres to the `OrganizationInterface`.\n */\ncontract Organization is OrganizationInterface, ERC165, Initializable {\n    // Address of the contract owner\n    address _owner;\n\n    // Arbitrary locator of the off-chain stored Organization data\n    // This might be an HTTPS resource, IPFS hash, Swarm address...\n    // This is intentionally generic.\n    string public orgJsonUri;\n\n    // Number of a block when the Organization was created\n    uint public created;\n\n    // Index of associated addresses. These can be used\n    // to operate on behalf of this organization, typically sign messages.\n    mapping(address => uint) public associatedKeysIndex;\n\n    // List of associatedKeys. These addresses (i. e. public key\n    // fingerprints) can be used to associate signed content with this\n    // organization.\n    address[] public associatedKeys;\n\n    // keccak256 hash of the ORG.JSON file contents. This should\n    // be used to verify that the contents of ORG.JSON has not been tampered\n    // with. It is a responsibility of the Organization owner to keep this\n    // hash up to date.\n    bytes32 public orgJsonHash;\n\n    /**\n     * @dev Event triggered when owner of the organization is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Event triggered when orgJsonUri of the organization is changed.\n     */\n    event OrgJsonUriChanged(string previousOrgJsonUri, string newOrgJsonUri);\n\n    /**\n     * @dev Event triggered when orgJsonHash of the organization is changed.\n     */\n    event OrgJsonHashChanged(bytes32 indexed previousOrgJsonHash, bytes32 indexed newOrgJsonHash);\n\n    /**\n     * @dev Event triggered when new associatedKey is added.\n     */\n    event AssociatedKeyAdded(address indexed associatedKey, uint index);\n\n    /**\n     * @dev Event triggered when a associatedKey is removed.\n     */    \n    event AssociatedKeyRemoved(address indexed associatedKey);\n\n    /**\n     * @dev Initializer for upgradeable contracts.\n     * @param __owner The address of the contract owner\n     * @param _orgJsonUri pointer to Organization data\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function initialize(address payable __owner, string memory _orgJsonUri, bytes32 _orgJsonHash) public initializer {\n        require(__owner != address(0), 'Organization: Cannot set owner to 0x0 address');\n        require(bytes(_orgJsonUri).length != 0, 'Organization: orgJsonUri cannot be an empty string');\n        require(_orgJsonHash != 0, 'Organization: orgJsonHash cannot be empty');\n        emit OwnershipTransferred(_owner, __owner);\n        _owner = __owner;        \n        orgJsonUri = _orgJsonUri;\n        orgJsonHash = _orgJsonHash;\n        created = block.number;\n        associatedKeys.length++;\n        OrganizationInterface i;\n        _registerInterface(0x01ffc9a7);//_INTERFACE_ID_ERC165\n        bytes4 associatedKeysInterface = i.hasAssociatedKey.selector ^ i.getAssociatedKeys.selector; // 0xfed71811\n        bytes4 orgJsonInterface = i.getOrgJsonUri.selector ^ i.getOrgJsonHash.selector; // 0x6f4826be\n        _registerInterface(orgJsonInterface);\n        _registerInterface(associatedKeysInterface);\n        _registerInterface(i.owner.selector); // 0x8da5cb5b\n        _registerInterface(\n            i.owner.selector ^\n            orgJsonInterface ^\n            associatedKeysInterface\n        ); // 0x1c3af5f4\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'Organization: Only owner can call this method');\n        _;\n    }\n\n    /**\n     * @dev `changeOrgJsonUri` Allows owner to change Organization's orgJsonUri.\n     * @param  _orgJsonUri New orgJsonUri pointer of this Organization\n     */\n    function changeOrgJsonUri(string memory _orgJsonUri) public onlyOwner {\n        require(bytes(_orgJsonUri).length != 0, 'Organization: orgJsonUri cannot be an empty string');\n        emit OrgJsonUriChanged(orgJsonUri, _orgJsonUri);\n        orgJsonUri = _orgJsonUri;\n    }\n\n    /**\n     * @dev Returns current orgJsonUri\n     * @return {\" \": \"Current orgJsonUri.\"}\n     */\n    function getOrgJsonUri() external view returns (string memory) {\n        return orgJsonUri;\n    }\n\n    /**\n     * @dev `changeOrgJsonHash` Allows owner to change Organization's orgJsonHash.\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function changeOrgJsonHash(bytes32 _orgJsonHash) public onlyOwner {\n        require(_orgJsonHash != 0, 'Organization: orgJsonHash cannot be empty');\n        emit OrgJsonHashChanged(orgJsonHash, _orgJsonHash);\n        orgJsonHash = _orgJsonHash;\n    }\n\n    /**\n     * @dev Returns keccak256 hash of raw ORG.JSON contents. This should\n     * be used to verify that the contents of ORG.JSON has not been tampered\n     * with. It is a responsibility of the Organization owner to keep this\n     * hash up to date.\n     * @return {\" \": \"Current ORG.JSON hash.\"}\n     */\n    function getOrgJsonHash() external view returns (bytes32) {\n        return orgJsonHash;\n    }\n\n    /**\n     * @dev Shorthand method to change ORG.JSON uri and hash at the same time\n     * @param  _orgJsonUri New orgJsonUri pointer of this Organization\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function changeOrgJsonUriAndHash(string memory _orgJsonUri, bytes32 _orgJsonHash) public onlyOwner {\n        changeOrgJsonUri(_orgJsonUri);\n        changeOrgJsonHash(_orgJsonHash);\n    }\n\n    /**\n     * @dev Adds another associated key. Only owner can call this.\n     * @param addr Associated Ethereum address\n     * @return {\" \": \"Address of the added associatedKey\"}\n     */\n    function addAssociatedKey(address addr) public onlyOwner returns(address) {\n        require(addr != address(0), 'Organization: Cannot add associatedKey with 0x0 address');\n        require(associatedKeysIndex[addr] == 0, 'Organization: Cannot add associatedKey twice');\n        associatedKeysIndex[addr] = associatedKeys.length;\n        associatedKeys.push(addr);\n        emit AssociatedKeyAdded(addr, associatedKeysIndex[addr]);\n        return addr;\n    }\n\n    /**\n     * @dev Removes an associated key. Only owner can call this.\n     * @param addr Associated Ethereum address\n     */\n    function removeAssociatedKey(address addr) public onlyOwner {\n        require(addr != address(0), 'Organization: Cannot remove associatedKey with 0x0 address');\n        require(associatedKeysIndex[addr] != uint(0), 'Organization: Cannot remove unknown organization');\n        delete associatedKeys[associatedKeysIndex[addr]];\n        delete associatedKeysIndex[addr];\n        emit AssociatedKeyRemoved(addr);\n    }\n\n    /**\n     * @dev Is an address considered as associated for this organization?\n     * @return {\" \": \"True if address is considered as associatedKey, false otherwise\"}\n     */\n    function hasAssociatedKey(address addr) external view returns(bool) {\n        return associatedKeys[associatedKeysIndex[addr]] != address(0);\n    }\n\n    /**\n     * @dev Returns all addresses associated with this organization.\n     * @return {\" \": \"List of associated keys\"}\n     */\n    function getAssociatedKeys() external view returns (address[] memory) {\n        return associatedKeys;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        require(newOwner != address(0), 'Organization: Cannot transfer to 0x0 address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n\n    /**\n     * @dev A synchronization method that should be kept up to date with \n     * the list of interfaces set during initialization. It should also be called\n     * everytime the implementation gets updated. If the interface list gets out of\n     * sync with the implementation at anytime, it is possible that some integrations\n     * will stop working. Since this method is not destructive, no access restriction\n     * is in place. It's supposed to be called by the proxy admin anyway.\n     */\n    function setInterfaces() public {\n        // OrganizationInterface i;\n        bytes4[5] memory interfaceIds = [\n            bytes4(0x01ffc9a7), // _INTERFACE_ID_ERC165\n            bytes4(0x8da5cb5b), // i.owner.selector\n            bytes4(0xfed71811), // i.hasAssociatedKey.selector ^ i.getAssociatedKeys.selector\n            bytes4(0x6f4826be), // i.getOrgJsonUri.selector ^ i.getOrgJsonHash.selector\n            bytes4(0x1c3af5f4)  // 0x8da5cb5b ^ 0xfed71811 ^ 0x6f4826be\n        ];\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!this.supportsInterface(interfaceIds[i])) {\n                _registerInterface(interfaceIds[i]);\n            }\n        }\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAssociatedKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAssociatedKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"associatedKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrgJsonUri\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orgJsonHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orgJsonHash\",\"type\":\"bytes32\"}],\"name\":\"changeOrgJsonHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orgJsonUri\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrgJsonHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAssociatedKey\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orgJsonUri\",\"type\":\"string\"},{\"name\":\"_orgJsonHash\",\"type\":\"bytes32\"}],\"name\":\"changeOrgJsonUriAndHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orgJsonUri\",\"type\":\"string\"}],\"name\":\"changeOrgJsonUri\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"__owner\",\"type\":\"address\"},{\"name\":\"_orgJsonUri\",\"type\":\"string\"},{\"name\":\"_orgJsonHash\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"associatedKeysIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasAssociatedKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setInterfaces\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOrgJsonUri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newOrgJsonUri\",\"type\":\"string\"}],\"name\":\"OrgJsonUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOrgJsonHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"newOrgJsonHash\",\"type\":\"bytes32\"}],\"name\":\"OrgJsonHashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"associatedKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AssociatedKeyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"associatedKey\",\"type\":\"address\"}],\"name\":\"AssociatedKeyRemoved\",\"type\":\"event\"}]","ContractName":"Organization","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://c2747362a61e79f9daf35100988bfe3ad265bac3e1d3d586c03837a7d1824969"}]}