{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.7.0;\r\n\r\ncontract MultiSend {\r\n\r\n    /// @dev Sends multiple transactions and reverts all if one fails.\r\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\r\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\r\n    ///                     to as a address (=> 20 bytes),\r\n    ///                     value as a uint256 (=> 32 bytes),\r\n    ///                     data length as a uint256 (=> 32 bytes),\r\n    ///                     data as bytes.\r\n    ///                     see abi.encodePacked for more information on packed encoding\r\n    function multiSend(bytes memory transactions)\r\n        public\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let length := mload(transactions)\r\n            let i := 0x20\r\n            for { } lt(i, length) { } {\r\n                // First byte of the data is the operation.\r\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\r\n                // This will also zero out unused data.\r\n                let operation := shr(0xf8, mload(add(transactions, i)))\r\n                // We offset the load address by 1 byte (operation byte)\r\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\r\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\r\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\r\n                let value := mload(add(transactions, add(i, 0x15)))\r\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\r\n                let dataLength := mload(add(transactions, add(i, 0x35)))\r\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\r\n                let data := add(transactions, add(i, 0x55))\r\n                let success := 0\r\n                switch operation\r\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\r\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\r\n                if eq(success, 0) { revert(0, 0) }\r\n                // Next entry starts at 85 byte + data length\r\n                i := add(i, add(0x55, dataLength))\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"transactions\",\"type\":\"bytes\"}],\"name\":\"multiSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MultiSend","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://c94d3b7089a00fc27df5961961813b0622015c4dc448ff428d0e1c7bec76e91c"}]}